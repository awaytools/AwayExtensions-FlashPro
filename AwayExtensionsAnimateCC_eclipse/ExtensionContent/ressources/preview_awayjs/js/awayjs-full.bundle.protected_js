/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, callbacks = [];
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				callbacks.push.apply(callbacks, installedChunks[chunkId]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			modules[moduleId] = moreModules[moduleId];
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules);
/******/ 		while(callbacks.length)
/******/ 			callbacks.shift().call(null, __webpack_require__);
/******/ 		if(moreModules[0]) {
/******/ 			installedModules[0] = 0;
/******/ 			return __webpack_require__(0);
/******/ 		}
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// object to store loaded and loading chunks
/******/ 	// "0" means "already loaded"
/******/ 	// Array means "loading", array contains callbacks
/******/ 	var installedChunks = {
/******/ 		30:0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			exports: {},
/******/ 			id: moduleId,
/******/ 			loaded: false
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.loaded = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId, callback) {
/******/ 		// "0" is the signal for "already loaded"
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return callback.call(null, __webpack_require__);
/******/
/******/ 		// an array means "currently loading".
/******/ 		if(installedChunks[chunkId] !== undefined) {
/******/ 			installedChunks[chunkId].push(callback);
/******/ 		} else {
/******/ 			// start chunk loading
/******/ 			installedChunks[chunkId] = [callback];
/******/ 			var head = document.getElementsByTagName('head')[0];
/******/ 			var script = document.createElement('script');
/******/ 			script.type = 'text/javascript';
/******/ 			script.charset = 'utf-8';
/******/ 			script.async = true;
/******/
/******/ 			script.src = __webpack_require__.p + "" + chunkId + ".js/" + ({"0":"AWD3ViewerMinimal","1":"AWDBasicTests","2":"AWDSuzanne","3":"Advanced_MultiPassSponzaDemo","4":"AircraftDemo","5":"AmmoBasicWorker","6":"AmmoClothSimulation","7":"AmmoRopeSimulation","8":"AmmoSoftBodySimulation","9":"Basic_Fire","10":"Basic_Load3DS","11":"Basic_LoadAWD","12":"Basic_Shading","13":"Basic_Skybox","14":"Basic_VideoTexture","15":"Basic_View","16":"Basic_View_bkp","17":"CubePrimitive","18":"Graphics_Drawing","19":"Intermediate_AWDViewer","20":"Intermediate_Globe","21":"Intermediate_MD5Animation","22":"Intermediate_MonsterHeadShading","23":"Intermediate_MouseInteraction","24":"Intermediate_ParticleExplosions","25":"Intermediate_PerelithKnight","26":"ObjLoaderMasterChief","27":"TextRender_Canvas2D","28":"TextRender_Canvas3D","29":"TorusPrimitive"}[chunkId]||chunkId) + ".js";
/******/ 			head.appendChild(script);
/******/ 		}
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(0);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

	__webpack_require__(1);
	__webpack_require__(431);
	__webpack_require__(433);
	__webpack_require__(2);
	__webpack_require__(19);
	__webpack_require__(493);
	__webpack_require__(495);
	__webpack_require__(110);
	__webpack_require__(503);
	__webpack_require__(511);
	__webpack_require__(516);
	__webpack_require__(524);
	__webpack_require__(535);
	__webpack_require__(201);
	__webpack_require__(204);
	__webpack_require__(208);
	__webpack_require__(537);
	__webpack_require__(215);
	__webpack_require__(545);
	__webpack_require__(286);
	__webpack_require__(369);
	__webpack_require__(548);
	__webpack_require__(553);
	__webpack_require__(556);
	__webpack_require__(559);
	__webpack_require__(561);
	__webpack_require__(387);
	__webpack_require__(569);
	__webpack_require__(573);
	module.exports = __webpack_require__(576);


/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	var attributes = __webpack_require__(2);
	var base = __webpack_require__(19);
	var display = __webpack_require__(110);
	var graphics = __webpack_require__(201);
	var image = __webpack_require__(204);
	var library = __webpack_require__(208);
	var materials = __webpack_require__(215);
	var parsers = __webpack_require__(286);
	var partition = __webpack_require__(369);
	var textures = __webpack_require__(387);
	var GL_AttributesBuffer_1 = __webpack_require__(389);
	var Stage_1 = __webpack_require__(56);
	var GL_BitmapImage2D_1 = __webpack_require__(390);
	var GL_BitmapImageCube_1 = __webpack_require__(394);
	var GL_RenderImage2D_1 = __webpack_require__(396);
	var GL_RenderImageCube_1 = __webpack_require__(397);
	var GL_Sampler2D_1 = __webpack_require__(398);
	var GL_SamplerCube_1 = __webpack_require__(400);
	var GL_LineElements_1 = __webpack_require__(401);
	var GL_TriangleElements_1 = __webpack_require__(403);
	var GL_BillboardRenderable_1 = __webpack_require__(404);
	var GL_GraphicRenderable_1 = __webpack_require__(406);
	var GL_LineSegmentRenderable_1 = __webpack_require__(407);
	var GL_SkyboxRenderable_1 = __webpack_require__(408);
	var ShaderBase_1 = __webpack_require__(271);
	var GL_BasicMaterialSurface_1 = __webpack_require__(410);
	var GL_SkyboxSurface_1 = __webpack_require__(412);
	var SurfacePool_1 = __webpack_require__(414);
	var GL_Single2DTexture_1 = __webpack_require__(415);
	var GL_SingleCubeTexture_1 = __webpack_require__(417);
	var RendererBase_1 = __webpack_require__(418);
	var GL_MethodMaterialSurface_1 = __webpack_require__(282);
	library.Loader.enableParser(parsers.AWDParser);
	library.Loader.enableParser(parsers.Max3DSParser);
	library.Loader.enableParser(parsers.MD2Parser);
	library.Loader.enableParser(parsers.OBJParser);
	library.Loader.enableParser(parsers.FNTParser);
	library.Loader.enableParser(parsers.MD5AnimParser);
	library.Loader.enableParser(parsers.MD5MeshParser);
	library.Loader.enableParser(parsers.Image2DParser);
	library.Loader.enableParser(parsers.ImageCubeParser);
	library.Loader.enableParser(parsers.WaveAudioParser);
	partition.PartitionBase.registerAbstraction(partition.CameraNode, display.Camera);
	partition.PartitionBase.registerAbstraction(partition.EntityNode, display.Sprite);
	partition.PartitionBase.registerAbstraction(partition.EntityNode, display.Shape);
	partition.PartitionBase.registerAbstraction(partition.EntityNode, display.MovieClip);
	partition.PartitionBase.registerAbstraction(partition.EntityNode, display.Billboard);
	partition.PartitionBase.registerAbstraction(partition.EntityNode, display.LineSegment);
	partition.PartitionBase.registerAbstraction(partition.EntityNode, display.TextField);
	partition.PartitionBase.registerAbstraction(partition.LightProbeNode, display.LightProbe);
	partition.PartitionBase.registerAbstraction(partition.PointLightNode, display.PointLight);
	partition.PartitionBase.registerAbstraction(partition.DirectionalLightNode, display.DirectionalLight);
	partition.PartitionBase.registerAbstraction(partition.SkyboxNode, display.Skybox);
	base.Stage.registerAbstraction(GL_AttributesBuffer_1.GL_AttributesBuffer, attributes.AttributesBuffer);
	base.Stage.registerAbstraction(GL_RenderImage2D_1.GL_RenderImage2D, image.Image2D);
	base.Stage.registerAbstraction(GL_RenderImageCube_1.GL_RenderImageCube, image.ImageCube);
	base.Stage.registerAbstraction(GL_BitmapImage2D_1.GL_BitmapImage2D, image.BitmapImage2D);
	base.Stage.registerAbstraction(GL_BitmapImageCube_1.GL_BitmapImageCube, image.BitmapImageCube);
	base.Stage.registerAbstraction(GL_BitmapImage2D_1.GL_BitmapImage2D, image.SpecularImage2D);
	base.Stage.registerAbstraction(GL_Sampler2D_1.GL_Sampler2D, image.Sampler2D);
	base.Stage.registerAbstraction(GL_SamplerCube_1.GL_SamplerCube, image.SamplerCube);
	SurfacePool_1.SurfacePool.registerAbstraction(GL_BasicMaterialSurface_1.GL_BasicMaterialSurface, materials.BasicMaterial);
	SurfacePool_1.SurfacePool.registerAbstraction(GL_MethodMaterialSurface_1.GL_MethodMaterialSurface, materials.MethodMaterial);
	SurfacePool_1.SurfacePool.registerAbstraction(GL_SkyboxSurface_1.GL_SkyboxSurface, display.Skybox);
	Stage_1.Stage.registerAbstraction(GL_LineElements_1.GL_LineElements, graphics.LineElements);
	Stage_1.Stage.registerAbstraction(GL_TriangleElements_1.GL_TriangleElements, graphics.TriangleElements);
	ShaderBase_1.ShaderBase.registerAbstraction(GL_Single2DTexture_1.GL_Single2DTexture, textures.Single2DTexture);
	ShaderBase_1.ShaderBase.registerAbstraction(GL_SingleCubeTexture_1.GL_SingleCubeTexture, textures.SingleCubeTexture);
	RendererBase_1.RendererBase.registerAbstraction(GL_BillboardRenderable_1.GL_BillboardRenderable, display.Billboard);
	RendererBase_1.RendererBase.registerAbstraction(GL_LineSegmentRenderable_1.GL_LineSegmentRenderable, display.LineSegment);
	RendererBase_1.RendererBase.registerAbstraction(GL_GraphicRenderable_1.GL_GraphicRenderable, graphics.Graphic);
	RendererBase_1.RendererBase.registerAbstraction(GL_SkyboxRenderable_1.GL_SkyboxRenderable, display.Skybox);
	__export(__webpack_require__(431));
	__export(__webpack_require__(433));
	__export(__webpack_require__(2));
	__export(__webpack_require__(19));
	__export(__webpack_require__(493));
	__export(__webpack_require__(495));
	__export(__webpack_require__(110));
	__export(__webpack_require__(503));
	__export(__webpack_require__(511));
	__export(__webpack_require__(516));
	__export(__webpack_require__(524));
	__export(__webpack_require__(535));
	__export(__webpack_require__(201));
	__export(__webpack_require__(204));
	__export(__webpack_require__(208));
	__export(__webpack_require__(537));
	__export(__webpack_require__(215));
	__export(__webpack_require__(545));
	__export(__webpack_require__(286));
	__export(__webpack_require__(369));
	__export(__webpack_require__(548));
	__export(__webpack_require__(553));
	__export(__webpack_require__(556));
	__export(__webpack_require__(559));
	__export(__webpack_require__(561));
	__export(__webpack_require__(387));
	__export(__webpack_require__(569));
	__export(__webpack_require__(573));
	__export(__webpack_require__(576));
	var View_1 = __webpack_require__(586);
	exports.View = View_1.View;
	var DefaultRenderer_1 = __webpack_require__(587);
	exports.DefaultRenderer = DefaultRenderer_1.DefaultRenderer;


/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(3));


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AttributesView_1 = __webpack_require__(4);
	exports.AttributesView = AttributesView_1.AttributesView;
	var AttributesBuffer_1 = __webpack_require__(5);
	exports.AttributesBuffer = AttributesBuffer_1.AttributesBuffer;
	var Byte4Attributes_1 = __webpack_require__(12);
	exports.Byte4Attributes = Byte4Attributes_1.Byte4Attributes;
	var Float1Attributes_1 = __webpack_require__(13);
	exports.Float1Attributes = Float1Attributes_1.Float1Attributes;
	var Float2Attributes_1 = __webpack_require__(14);
	exports.Float2Attributes = Float2Attributes_1.Float2Attributes;
	var Float3Attributes_1 = __webpack_require__(15);
	exports.Float3Attributes = Float3Attributes_1.Float3Attributes;
	var Float4Attributes_1 = __webpack_require__(16);
	exports.Float4Attributes = Float4Attributes_1.Float4Attributes;
	var Short2Attributes_1 = __webpack_require__(17);
	exports.Short2Attributes = Short2Attributes_1.Short2Attributes;
	var Short3Attributes_1 = __webpack_require__(18);
	exports.Short3Attributes = Short3Attributes_1.Short3Attributes;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var AssetBase_1 = __webpack_require__(6);
	var AttributesView = (function (_super) {
	    __extends(AttributesView, _super);
	    function AttributesView(arrayClass, dimensions, attributesBufferCount, unsigned) {
	        if (attributesBufferCount === void 0) { attributesBufferCount = 0; }
	        if (unsigned === void 0) { unsigned = false; }
	        _super.call(this);
	        this._arrayClass = arrayClass;
	        this._size = arrayClass.BYTES_PER_ELEMENT;
	        this._dimensions = dimensions;
	        this._attributesBuffer = (attributesBufferCount instanceof AttributesBuffer_1.AttributesBuffer) ? attributesBufferCount : new AttributesBuffer_1.AttributesBuffer(this._dimensions * this._size, attributesBufferCount);
	        this._attributesBuffer._addView(this);
	        this._unsigned = unsigned;
	    }
	    Object.defineProperty(AttributesView.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return AttributesView.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "attributesBuffer", {
	        get: function () {
	            return this._attributesBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "size", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._size;
	        },
	        set: function (value) {
	            if (this._size == value)
	                return;
	            this._size = value;
	            this._attributesBuffer._removeView(this);
	            this._attributesBuffer._addView(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "dimensions", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._dimensions;
	        },
	        set: function (value) {
	            if (this._dimensions == value)
	                return;
	            this._dimensions = value;
	            //reset view
	            this._attributesBuffer._removeView(this);
	            this._attributesBuffer._addView(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "unsigned", {
	        get: function () {
	            return this._unsigned;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "count", {
	        get: function () {
	            return this._attributesBuffer.count;
	        },
	        set: function (value) {
	            this._attributesBuffer.count = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "offset", {
	        get: function () {
	            return this._attributesBuffer._getOffset(this._index);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "length", {
	        get: function () {
	            return this._attributesBuffer.count * this._dimensions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesView.prototype, "stride", {
	        get: function () {
	            return this._attributesBuffer.stride / this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AttributesView.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        this._attributesBuffer._setAttributes(this._index, (values instanceof Array) ? new (this._arrayClass)(values) : values, offset);
	    };
	    AttributesView.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return new (this._arrayClass)(this._attributesBuffer.buffer, offset * this._attributesBuffer.stride + this.offset, count * this.stride - this.offset / this.size);
	    };
	    AttributesView.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new AttributesView(this._arrayClass, this._dimensions, attributesBuffer, this._unsigned));
	    };
	    AttributesView.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        if (attributesBuffer)
	            this._internalClone(attributesBuffer);
	        if (!this._cloneCache)
	            this._attributesBuffer.clone();
	        var cloneCache = this._cloneCache;
	        this._cloneCache = null;
	        return cloneCache;
	    };
	    AttributesView.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._attributesBuffer.invalidate();
	    };
	    /**
	     * @inheritDoc
	     */
	    AttributesView.prototype.dispose = function () {
	        if (!this._attributesBuffer)
	            return;
	        this._attributesBuffer._removeView(this);
	        this._attributesBuffer = null;
	    };
	    AttributesView.assetType = "[attributes AttributesView]";
	    return AttributesView;
	}(AssetBase_1.AssetBase));
	exports.AttributesView = AttributesView;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var AttributesBuffer = (function (_super) {
	    __extends(AttributesBuffer, _super);
	    /**
	     *
	     */
	    function AttributesBuffer(stride, count) {
	        if (stride === void 0) { stride = 0; }
	        if (count === void 0) { count = 0; }
	        _super.call(this);
	        this._count = 0;
	        this._stride = 0;
	        this._newStride = 0;
	        this._viewVOs = new Array();
	        this._stride = this._newStride = stride;
	        this._count = count;
	        this._buffer = new ArrayBuffer(this._stride * this._count);
	        this._bufferView = new Uint8Array(this._buffer, 0, this._buffer.byteLength);
	    }
	    Object.defineProperty(AttributesBuffer.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return AttributesBuffer.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "stride", {
	        get: function () {
	            if (this._lengthDirty)
	                this._updateLength();
	            return this._stride;
	        },
	        set: function (value) {
	            if (this._newStride == value)
	                return;
	            this._newStride = value;
	            this.resize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "count", {
	        get: function () {
	            return this._count;
	        },
	        set: function (value) {
	            if (this._count == value)
	                return;
	            this._count = value;
	            this.resize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "buffer", {
	        get: function () {
	            if (this._lengthDirty)
	                this._updateLength();
	            this._contentDirty = false;
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "bufferView", {
	        get: function () {
	            if (this._lengthDirty)
	                this._updateLength();
	            this._contentDirty = false;
	            return this._bufferView;
	        },
	        set: function (value) {
	            this._bufferView = value;
	            this._buffer = this._bufferView.buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AttributesBuffer.prototype, "length", {
	        get: function () {
	            return this._count * this.stride;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    AttributesBuffer.prototype.invalidate = function () {
	        if (this._contentDirty)
	            return;
	        _super.prototype.invalidate.call(this);
	        this._contentDirty = true;
	    };
	    /**
	     *
	     * @private
	     */
	    AttributesBuffer.prototype.resize = function () {
	        if (this._lengthDirty)
	            return;
	        this.clear();
	        this._lengthDirty = true;
	        //dispose buffer if stride is 0
	        if (!this._newStride) {
	            this._buffer = null;
	            this._bufferView = null;
	        }
	    };
	    AttributesBuffer.prototype.clone = function () {
	        var attributesBuffer = new AttributesBuffer(this._stride, this._count);
	        attributesBuffer.bufferView.set(this.bufferView);
	        var len = this._viewVOs.length;
	        for (var i = 0; i < len; i++)
	            this._viewVOs[i].view._internalClone(attributesBuffer);
	        return attributesBuffer;
	    };
	    AttributesBuffer.prototype.getView = function (index) {
	        if (index < this._viewVOs.length)
	            return this._viewVOs[index].view;
	        return null;
	    };
	    AttributesBuffer.prototype._setAttributes = function (viewIndex, arrayBufferView, offset) {
	        if (offset === void 0) { offset = 0; }
	        var array = (arrayBufferView instanceof Uint8Array) ? arrayBufferView : new Uint8Array(arrayBufferView.buffer);
	        var viewVO = this._viewVOs[viewIndex];
	        var vLength = viewVO.length;
	        var vOffset = viewVO.offset;
	        var vCount = array.length / vLength;
	        //make sure there is enough space in the buffer
	        if (this.count < vCount + offset)
	            this.count = vCount + offset;
	        if (this._lengthDirty)
	            this._updateLength();
	        //fast path for separate buffers
	        if (this._viewVOs.length == 1) {
	            this._bufferView.set(array);
	        }
	        else {
	            for (var i = 0; i < vCount; i++)
	                this._bufferView.set(array.subarray(i * vLength, (i + 1) * vLength), (i + offset) * this._stride + vOffset);
	        }
	        this.invalidate();
	    };
	    AttributesBuffer.prototype._addView = function (view) {
	        var viewVO = new ViewVO(view);
	        var len = this._viewVOs.length;
	        viewVO.offset = len ? this._viewVOs[len - 1].offset + this._viewVOs[len - 1].length : 0;
	        this._viewVOs.push(viewVO);
	        if (this._newStride < viewVO.offset + viewVO.length) {
	            this._newStride = viewVO.offset + viewVO.length;
	            this.resize();
	        }
	        view._index = len;
	    };
	    AttributesBuffer.prototype._removeView = function (view) {
	        var viewIndex = view._index;
	        var viewVO = this._viewVOs.splice(viewIndex, 1)[0];
	        var len = this._viewVOs.length;
	        viewVO.dispose();
	        for (var i = viewIndex; i < len; i++) {
	            viewVO = this._viewVOs[i];
	            viewVO.offset = i ? this._viewVOs[i - 1].offset + this._viewVOs[i - 1].length : 0;
	            viewVO.view._index = i;
	        }
	        this._newStride = viewVO.offset + viewVO.length;
	        this.resize();
	    };
	    AttributesBuffer.prototype._getOffset = function (viewIndex) {
	        return this._viewVOs[viewIndex].offset;
	    };
	    AttributesBuffer.prototype._updateLength = function () {
	        this._lengthDirty = false;
	        var i;
	        var j;
	        var len = this._viewVOs.length;
	        var newLength = this._newStride * this._count;
	        if (!this._buffer || this._buffer.byteLength != newLength) {
	            var newBuffer = new ArrayBuffer(newLength);
	            var newView = new Uint8Array(newBuffer, 0, newBuffer.byteLength);
	            var viewVO;
	            var vLength;
	            var vOffset;
	            var vOldOffset;
	            if (this._stride != this._newStride) {
	                for (i = 0; i < len; i++) {
	                    viewVO = this._viewVOs[i];
	                    vLength = viewVO.length;
	                    vOffset = viewVO.offset;
	                    vOldOffset = viewVO.oldOffset;
	                    for (j = 0; j < this._count; j++)
	                        if (vOldOffset != null)
	                            newView.set(new Uint8Array(this._buffer, j * this._stride + vOldOffset, vLength), j * this._newStride + vOffset);
	                    viewVO.oldOffset = viewVO.offset;
	                }
	                this._stride = this._newStride;
	            }
	            else {
	                newView.set(new Uint8Array(this._buffer, 0, Math.min(newLength, this._buffer.byteLength))); //TODO: bypass quantisation of bytearray on instantiation
	            }
	            this._buffer = newBuffer;
	            this._bufferView = newView;
	        }
	    };
	    AttributesBuffer.assetType = "[assets AttributesBuffer]";
	    return AttributesBuffer;
	}(AssetBase_1.AssetBase));
	exports.AttributesBuffer = AttributesBuffer;
	var ViewVO = (function () {
	    function ViewVO(view) {
	        this.view = view;
	        this.length = view.size * view.dimensions;
	    }
	    ViewVO.prototype.dispose = function () {
	        this.view = null;
	    };
	    ViewVO.prototype.clone = function () {
	        return new ViewVO(this.view);
	    };
	    return ViewVO;
	}());


/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var AssetEvent_1 = __webpack_require__(9);
	var EventDispatcher_1 = __webpack_require__(11);
	var AssetBase = (function (_super) {
	    __extends(AssetBase, _super);
	    function AssetBase(name) {
	        if (name === void 0) { name = null; }
	        _super.call(this);
	        this._id = AssetBase.ID_COUNT++;
	        if (name == null)
	            name = 'null';
	        this._name = name;
	        this._originalName = name;
	        this.updateFullPath();
	    }
	    Object.defineProperty(AssetBase.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            throw new AbstractMethodError_1.AbstractMethodError();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "originalName", {
	        /**
	         * The original name used for this asset in the resource (e.g. file) in which
	         * it was found. This may not be the same as <code>name</code>, which may
	         * have changed due to of a name conflict.
	         */
	        get: function () {
	            return this._originalName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "id", {
	        /**
	         * A unique id for the asset, used to identify assets in an associative array
	         */
	        get: function () {
	            return this._id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "name", {
	        get: function () {
	            return this._name;
	        },
	        set: function (val) {
	            var prev;
	            prev = this._name;
	            this._name = val;
	            if (this._name == null)
	                this._name = 'null';
	            this.updateFullPath();
	            this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.RENAME, this, prev));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    AssetBase.prototype.invalidate = function () {
	        this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.INVALIDATE, this));
	    };
	    /**
	     * @inheritDoc
	     */
	    AssetBase.prototype.dispose = function () {
	        this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.DISPOSE, this));
	    };
	    AssetBase.prototype.clear = function () {
	        this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this));
	    };
	    Object.defineProperty(AssetBase.prototype, "assetNamespace", {
	        get: function () {
	            return this._namespace;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetBase.prototype, "assetFullPath", {
	        get: function () {
	            return this._full_path;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AssetBase.prototype.assetPathEquals = function (name, ns) {
	        return (this._name == name && (!ns || this._namespace == ns));
	    };
	    AssetBase.prototype.isAsset = function (assetClass) {
	        return this.assetType == assetClass.assetType;
	    };
	    AssetBase.prototype.resetAssetPath = function (name, ns, overrideOriginal) {
	        if (ns === void 0) { ns = null; }
	        if (overrideOriginal === void 0) { overrideOriginal = true; }
	        this._name = name ? name : 'null';
	        this._namespace = ns ? ns : AssetBase.DEFAULT_NAMESPACE;
	        if (overrideOriginal)
	            this._originalName = this._name;
	        this.updateFullPath();
	    };
	    AssetBase.prototype.updateFullPath = function () {
	        this._full_path = [this._namespace, this._name];
	    };
	    AssetBase.ID_COUNT = 0;
	    AssetBase.DEFAULT_NAMESPACE = 'default';
	    return AssetBase;
	}(EventDispatcher_1.EventDispatcher));
	exports.AssetBase = AssetBase;


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	/**
	 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
	 * by a concrete subclass.
	 */
	var AbstractMethodError = (function (_super) {
	    __extends(AbstractMethodError, _super);
	    /**
	     * Create a new AbstractMethodError.
	     * @param message An optional message to override the default error message.
	     * @param id The id of the error.
	     */
	    function AbstractMethodError(message, id) {
	        if (message === void 0) { message = null; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, message || "An abstract method was called! Either an instance of an abstract export class was created, or an abstract method was not overridden by the subclass.", id);
	    }
	    return AbstractMethodError;
	}(ErrorBase_1.ErrorBase));
	exports.AbstractMethodError = AbstractMethodError;


/***/ },
/* 8 */
/***/ function(module, exports) {

	"use strict";
	var ErrorBase = (function () {
	    function ErrorBase(message, id, _name) {
	        if (message === void 0) { message = ''; }
	        if (id === void 0) { id = 0; }
	        if (_name === void 0) { _name = ''; }
	        this._errorID = 0; //Contains the reference number associated with the specific error message.
	        this._messsage = ''; //Contains the message associated with the Error object.
	        this._name = ''; // Contains the name of the Error object.
	        this._messsage = message;
	        this._name = name;
	        this._errorID = id;
	    }
	    Object.defineProperty(ErrorBase.prototype, "message", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._messsage;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            this._messsage = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ErrorBase.prototype, "name", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._name;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            this._name = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ErrorBase.prototype, "errorID", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._errorID;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ErrorBase;
	}());
	exports.ErrorBase = ErrorBase;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	/**
	 * @export class away.events.AssetEvent
	 */
	var AssetEvent = (function (_super) {
	    __extends(AssetEvent, _super);
	    /**
	     *
	     */
	    function AssetEvent(type, asset, prevName) {
	        if (prevName === void 0) { prevName = null; }
	        _super.call(this, type);
	        this._asset = asset;
	        this._prevName = prevName || this._asset.name;
	    }
	    Object.defineProperty(AssetEvent.prototype, "asset", {
	        /**
	         *
	         */
	        get: function () {
	            return this._asset;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetEvent.prototype, "prevName", {
	        /**
	         *
	         */
	        get: function () {
	            return this._prevName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    AssetEvent.prototype.clone = function () {
	        return new AssetEvent(this.type, this._asset, this._prevName);
	    };
	    /**
	     * Dispatched when the content of an asset is invalidated
	     */
	    AssetEvent.INVALIDATE = "invalidate";
	    /**
	     * Dispatched when an asset is diposed
	     */
	    AssetEvent.DISPOSE = "dispose";
	    /**
	     * Dispatched when an asset is cleared
	     */
	    AssetEvent.CLEAR = "clear";
	    /**
	     *
	     */
	    AssetEvent.RENAME = 'rename';
	    /**
	     *
	     */
	    AssetEvent.ENTER_FRAME = 'enterFrame';
	    /**
	     *
	     */
	    AssetEvent.EXIT_FRAME = 'exitFrame';
	    /**
	     *
	     */
	    AssetEvent.ASSET_CONFLICT_RESOLVED = 'assetConflictResolved';
	    /**
	     * Dispatched when the loading of an asset and all of its dependencies is complete.
	     */
	    AssetEvent.ASSET_COMPLETE = "assetComplete";
	    /**
	     *
	     */
	    AssetEvent.TEXTURE_SIZE_ERROR = 'textureSizeError';
	    return AssetEvent;
	}(EventBase_1.EventBase));
	exports.AssetEvent = AssetEvent;


/***/ },
/* 10 */
/***/ function(module, exports) {

	"use strict";
	var EventBase = (function () {
	    function EventBase(type) {
	        /**
	         * Type of event
	         * @property type
	         * @type String
	         */
	        this.type = undefined;
	        /**
	         * Reference to target object
	         * @property target
	         * @type Object
	         */
	        this.target = undefined;
	        this.type = type;
	    }
	    /**
	     * Clones the current event.
	     * @return An exact duplicate of the current event.
	     */
	    EventBase.prototype.clone = function () {
	        return new EventBase(this.type);
	    };
	    return EventBase;
	}());
	exports.EventBase = EventBase;


/***/ },
/* 11 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Base export class for dispatching events
	*
	* @export class away.events.EventDispatcher
	*
	*/
	var EventDispatcher = (function () {
	    function EventDispatcher(target) {
	        if (target === void 0) { target = null; }
	        this.listenerObjects = new Array();
	        this.target = target || this;
	    }
	    /**
	     * Add an event listener
	     * @method addEventListener
	     * @param {String} Name of event to add a listener for
	     * @param {Function} Callback function
	     */
	    EventDispatcher.prototype.addEventListener = function (type, listener) {
	        var l = this.listenerObjects[type];
	        if (l === undefined)
	            l = this.listenerObjects[type] = new ListenerObject();
	        l.addEventListener(listener);
	    };
	    /**
	     * Remove an event listener
	     * @method removeEventListener
	     * @param {String} Name of event to remove a listener for
	     * @param {Function} Callback function
	     */
	    EventDispatcher.prototype.removeEventListener = function (type, listener) {
	        var l = this.listenerObjects[type];
	        if (l) {
	            l.removeEventListener(listener);
	            if (l.numListeners == 0)
	                delete this.listenerObjects[type];
	        }
	    };
	    /**
	     * Dispatch an event
	     * @method dispatchEvent
	     * @param {Event} Event to dispatch
	     */
	    EventDispatcher.prototype.dispatchEvent = function (event) {
	        var l = this.listenerObjects[event.type];
	        if (l) {
	            event.target = this.target;
	            l.dispatchEvent(event);
	        }
	    };
	    /**
	     * check if an object has an event listener assigned to it
	     * @method hasListener
	     * @param {String} Name of event to remove a listener for
	     * @param {Function} Callback function
	     */
	    EventDispatcher.prototype.hasEventListener = function (type, listener) {
	        if (this.listenerObjects[type] === undefined)
	            return false;
	        if (listener != null)
	            return this.listenerObjects[type].getEventListenerIndex(listener) !== -1;
	        return this.listenerObjects[type].numListeners > 0;
	    };
	    return EventDispatcher;
	}());
	exports.EventDispatcher = EventDispatcher;
	var ListenerObject = (function () {
	    function ListenerObject() {
	        this.index = 0;
	        this.listeners = new Array();
	        this.numListeners = 0;
	    }
	    ListenerObject.prototype.addEventListener = function (listener) {
	        //check if listener already added
	        if (this.getEventListenerIndex(listener) !== -1)
	            return;
	        this.listeners.push(listener);
	        this.numListeners++;
	    };
	    ListenerObject.prototype.removeEventListener = function (listener) {
	        //check if listener exists
	        var index = this.getEventListenerIndex(listener);
	        if (index === -1)
	            return;
	        this.listeners.splice(index, 1);
	        if (index <= this.index)
	            this.index--;
	        this.numListeners--;
	    };
	    ListenerObject.prototype.dispatchEvent = function (event) {
	        var len = this.numListeners;
	        for (this.index = 0; this.index < len && this.index < this.numListeners; this.index++)
	            this.listeners[this.index](event);
	    };
	    /**
	     * get Event Listener Index in array. Returns -1 if no listener is added
	     * @method getEventListenerIndex
	     * @param {String} Name of event to remove a listener for
	     * @param {Function} Callback function
	     */
	    ListenerObject.prototype.getEventListenerIndex = function (listener) {
	        for (var index = 0; index < this.numListeners; index++)
	            if (listener == this.listeners[index])
	                return index;
	        return -1;
	    };
	    return ListenerObject;
	}());
	exports.ListenerObject = ListenerObject;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = EventDispatcher;


/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Byte4Attributes = (function (_super) {
	    __extends(Byte4Attributes, _super);
	    function Byte4Attributes(attributesBufferLength, unsigned) {
	        if (unsigned === void 0) { unsigned = true; }
	        _super.call(this, unsigned ? Uint8Array : Int8Array, 4, attributesBufferLength, unsigned);
	    }
	    Object.defineProperty(Byte4Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Byte4Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Byte4Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Byte4Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Byte4Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Byte4Attributes(attributesBuffer, this._arrayClass == Uint8Array));
	    };
	    Byte4Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Byte4Attributes.assetType = "[attributes Byte4Attributes]";
	    return Byte4Attributes;
	}(AttributesView_1.AttributesView));
	exports.Byte4Attributes = Byte4Attributes;


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Float1Attributes = (function (_super) {
	    __extends(Float1Attributes, _super);
	    function Float1Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 1, attributesBufferLength);
	    }
	    Object.defineProperty(Float1Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float1Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float1Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float1Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float1Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float1Attributes(attributesBuffer));
	    };
	    Float1Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float1Attributes.assetType = "[attributes Float1Attributes]";
	    return Float1Attributes;
	}(AttributesView_1.AttributesView));
	exports.Float1Attributes = Float1Attributes;


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Float2Attributes = (function (_super) {
	    __extends(Float2Attributes, _super);
	    function Float2Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 2, attributesBufferLength);
	    }
	    Object.defineProperty(Float2Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float2Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float2Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float2Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float2Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float2Attributes(attributesBuffer));
	    };
	    Float2Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float2Attributes.assetType = "[attributes Float2Attributes]";
	    return Float2Attributes;
	}(AttributesView_1.AttributesView));
	exports.Float2Attributes = Float2Attributes;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Float3Attributes = (function (_super) {
	    __extends(Float3Attributes, _super);
	    function Float3Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 3, attributesBufferLength);
	    }
	    Object.defineProperty(Float3Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float3Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float3Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float3Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float3Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float3Attributes(attributesBuffer));
	    };
	    Float3Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float3Attributes.assetType = "[attributes Float3Attributes]";
	    return Float3Attributes;
	}(AttributesView_1.AttributesView));
	exports.Float3Attributes = Float3Attributes;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Float4Attributes = (function (_super) {
	    __extends(Float4Attributes, _super);
	    function Float4Attributes(attributesBufferLength) {
	        _super.call(this, Float32Array, 4, attributesBufferLength);
	    }
	    Object.defineProperty(Float4Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Float4Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Float4Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Float4Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Float4Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Float4Attributes(attributesBuffer));
	    };
	    Float4Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Float4Attributes.assetType = "[attributes Float4Attributes]";
	    return Float4Attributes;
	}(AttributesView_1.AttributesView));
	exports.Float4Attributes = Float4Attributes;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Short2Attributes = (function (_super) {
	    __extends(Short2Attributes, _super);
	    function Short2Attributes(attributesBufferLength, unsigned) {
	        if (unsigned === void 0) { unsigned = true; }
	        _super.call(this, unsigned ? Uint16Array : Int16Array, 2, attributesBufferLength, unsigned);
	    }
	    Object.defineProperty(Short2Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Short2Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Short2Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Short2Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Short2Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Short2Attributes(attributesBuffer, this._arrayClass == Uint16Array));
	    };
	    Short2Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Short2Attributes.assetType = "[attributes Short2Attributes]";
	    return Short2Attributes;
	}(AttributesView_1.AttributesView));
	exports.Short2Attributes = Short2Attributes;


/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Short3Attributes = (function (_super) {
	    __extends(Short3Attributes, _super);
	    function Short3Attributes(attributesBufferLength, unsigned) {
	        if (unsigned === void 0) { unsigned = true; }
	        _super.call(this, unsigned ? Uint16Array : Int16Array, 3, attributesBufferLength, unsigned);
	    }
	    Object.defineProperty(Short3Attributes.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Short3Attributes.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Short3Attributes.prototype.set = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.set.call(this, values, offset);
	    };
	    Short3Attributes.prototype.get = function (count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return _super.prototype.get.call(this, count, offset);
	    };
	    Short3Attributes.prototype._internalClone = function (attributesBuffer) {
	        return (this._cloneCache = new Short3Attributes(attributesBuffer, this._arrayClass == Uint16Array));
	    };
	    Short3Attributes.prototype.clone = function (attributesBuffer) {
	        if (attributesBuffer === void 0) { attributesBuffer = null; }
	        return _super.prototype.clone.call(this, attributesBuffer);
	    };
	    Short3Attributes.assetType = "[attributes Short3Attributes]";
	    return Short3Attributes;
	}(AttributesView_1.AttributesView));
	exports.Short3Attributes = Short3Attributes;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(20));
	__export(__webpack_require__(40));


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AlignmentMode_1 = __webpack_require__(21);
	exports.AlignmentMode = AlignmentMode_1.AlignmentMode;
	var HierarchicalProperties_1 = __webpack_require__(22);
	exports.HierarchicalProperties = HierarchicalProperties_1.HierarchicalProperties;
	var OrientationMode_1 = __webpack_require__(23);
	exports.OrientationMode = OrientationMode_1.OrientationMode;
	var Style_1 = __webpack_require__(24);
	exports.Style = Style_1.Style;
	var Timeline_1 = __webpack_require__(26);
	exports.Timeline = Timeline_1.Timeline;
	var TouchPoint_1 = __webpack_require__(30);
	exports.TouchPoint = TouchPoint_1.TouchPoint;
	var Transform_1 = __webpack_require__(31);
	exports.Transform = Transform_1.Transform;


/***/ },
/* 21 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var AlignmentMode = (function () {
	    function AlignmentMode() {
	    }
	    /**
	     *
	     */
	    AlignmentMode.REGISTRATION_POINT = "registrationPoint";
	    /**
	     *
	     */
	    AlignmentMode.PIVOT_POINT = "pivot";
	    return AlignmentMode;
	}());
	exports.AlignmentMode = AlignmentMode;


/***/ },
/* 22 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var HierarchicalProperties = (function () {
	    function HierarchicalProperties() {
	    }
	    /**
	     *
	     */
	    HierarchicalProperties.MOUSE_ENABLED = 1;
	    /**
	     *
	     */
	    HierarchicalProperties.VISIBLE = 2;
	    /**
	     *
	     */
	    HierarchicalProperties.MASK_ID = 4;
	    /**
	     *
	     */
	    HierarchicalProperties.MASKS = 8;
	    /**
	     *
	     */
	    HierarchicalProperties.COLOR_TRANSFORM = 16;
	    /**
	     *
	     */
	    HierarchicalProperties.SCENE_TRANSFORM = 32;
	    /**
	     *
	     */
	    HierarchicalProperties.ALL = 63;
	    return HierarchicalProperties;
	}());
	exports.HierarchicalProperties = HierarchicalProperties;


/***/ },
/* 23 */
/***/ function(module, exports) {

	"use strict";
	var OrientationMode = (function () {
	    function OrientationMode() {
	    }
	    /**
	     *
	     */
	    OrientationMode.DEFAULT = "default";
	    /**
	     *
	     */
	    OrientationMode.CAMERA_PLANE = "cameraPlane";
	    /**
	     *
	     */
	    OrientationMode.CAMERA_POSITION = "cameraPosition";
	    return OrientationMode;
	}());
	exports.OrientationMode = OrientationMode;


/***/ },
/* 24 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(11);
	var StyleEvent_1 = __webpack_require__(25);
	/**
	 *
	 */
	var Style = (function (_super) {
	    __extends(Style, _super);
	    function Style() {
	        _super.call(this);
	        this._samplers = new Object();
	        this._images = new Object();
	        this._color = 0xFFFFFF;
	    }
	    Object.defineProperty(Style.prototype, "sampler", {
	        get: function () {
	            return this._sampler;
	        },
	        set: function (value) {
	            if (this._sampler == value)
	                return;
	            this._sampler = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Style.prototype, "image", {
	        get: function () {
	            return this._image;
	        },
	        set: function (value) {
	            if (this._image == value)
	                return;
	            this._image = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Style.prototype, "uvMatrix", {
	        get: function () {
	            return this._uvMatrix;
	        },
	        set: function (value) {
	            if (this._uvMatrix == value)
	                return;
	            this._uvMatrix = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Style.prototype, "color", {
	        /**
	         * The diffuse reflectivity color of the surface.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            if (this._color == value)
	                return;
	            this._color = value;
	            this._invalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Style.prototype.getImageAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        return (this._images[texture.id] ? this._images[texture.id][index] : null) || this._image;
	    };
	    Style.prototype.getSamplerAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        return (this._samplers[texture.id] ? this._samplers[texture.id][index] : null) || this._sampler;
	    };
	    Style.prototype.addImageAt = function (image, texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._images[texture.id])
	            this._images[texture.id] = new Array();
	        this._images[texture.id][index] = image;
	    };
	    Style.prototype.addSamplerAt = function (sampler, texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._samplers[texture.id])
	            this._samplers[texture.id] = new Array();
	        this._samplers[texture.id][index] = sampler;
	        this._invalidateProperties();
	    };
	    Style.prototype.removeImageAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._images[texture.id])
	            return;
	        this._images[texture.id][index] = null;
	        this._invalidateProperties();
	    };
	    Style.prototype.removeSamplerAt = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        if (!this._samplers[texture.id])
	            return;
	        this._samplers[texture.id][index] = null;
	        this._invalidateProperties();
	    };
	    Style.prototype._invalidateProperties = function () {
	        this.dispatchEvent(new StyleEvent_1.StyleEvent(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this));
	    };
	    return Style;
	}(EventDispatcher_1.EventDispatcher));
	exports.Style = Style;


/***/ },
/* 25 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var StyleEvent = (function (_super) {
	    __extends(StyleEvent, _super);
	    function StyleEvent(type, style) {
	        _super.call(this, type);
	        this._style = style;
	    }
	    Object.defineProperty(StyleEvent.prototype, "style", {
	        get: function () {
	            return this._style;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    StyleEvent.prototype.clone = function () {
	        return new StyleEvent(this.type, this._style);
	    };
	    /**
	     *
	     */
	    StyleEvent.INVALIDATE_PROPERTIES = "invalidateProperties";
	    return StyleEvent;
	}(EventBase_1.EventBase));
	exports.StyleEvent = StyleEvent;


/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var HierarchicalProperties_1 = __webpack_require__(22);
	var ColorTransform_1 = __webpack_require__(27);
	var FrameScriptManager_1 = __webpack_require__(29);
	var Timeline = (function () {
	    function Timeline() {
	        this._functions = [];
	        this._update_indices = [];
	        this.numKeyFrames = 0;
	        this.keyframe_indices = [];
	        this._potentialPrototypes = [];
	        this._labels = {};
	        this._framescripts = {};
	        this._framescripts_translated = {};
	        //cache functions
	        this._functions[1] = this.update_mtx_all;
	        this._functions[2] = this.update_colortransform;
	        this._functions[3] = this.update_masks;
	        this._functions[4] = this.update_name;
	        this._functions[5] = this.update_button_name;
	        this._functions[6] = this.update_visibility;
	        this._functions[7] = this.update_blendmode;
	        this._functions[8] = this.update_rendermode;
	        this._functions[11] = this.update_mtx_scale_rot;
	        this._functions[12] = this.update_mtx_pos;
	        this._functions[200] = this.enable_maskmode;
	        this._functions[201] = this.remove_masks;
	    }
	    Timeline.prototype.init = function () {
	        if ((this.frame_command_indices == null) || (this.frame_recipe == null) || (this.keyframe_durations == null))
	            return;
	        this.keyframe_firstframes = [];
	        this.keyframe_constructframes = [];
	        var frame_cnt = 0;
	        var ic = 0;
	        var ic2 = 0;
	        var keyframe_cnt = 0;
	        var last_construct_frame = 0;
	        for (ic = 0; ic < this.numKeyFrames; ic++) {
	            var duration = this.keyframe_durations[(ic)];
	            if (this.frame_recipe[ic] & 1)
	                last_construct_frame = keyframe_cnt;
	            this.keyframe_firstframes[keyframe_cnt] = frame_cnt;
	            this.keyframe_constructframes[keyframe_cnt++] = last_construct_frame;
	            for (ic2 = 0; ic2 < duration; ic2++)
	                this.keyframe_indices[frame_cnt++] = ic;
	        }
	    };
	    Timeline.prototype.get_framescript = function (keyframe_index) {
	        if (this._framescripts[keyframe_index] == null)
	            return "";
	        if (typeof this._framescripts[keyframe_index] == "string")
	            return this._framescripts[keyframe_index];
	        else {
	            throw new Error("Framescript is already translated to Function!!!");
	        }
	    };
	    Timeline.prototype.add_framescript = function (value, keyframe_index) {
	        if (FrameScriptManager_1.FrameScriptManager.frameScriptDebug) {
	            // if we are in debug mode, we try to extract the function name from the first line of framescript code,
	            // and check if this function is available on the object that is set as frameScriptDebug
	            // try to get the functions name (it should be the first line as comment)
	            var functionname = value.split(/[\r\n]+/g)[0].split("//")[1];
	            if (FrameScriptManager_1.FrameScriptManager.frameScriptDebug[functionname]) {
	                this._framescripts[keyframe_index] = FrameScriptManager_1.FrameScriptManager.frameScriptDebug[functionname];
	                this._framescripts_translated[keyframe_index] = true;
	                return;
	            }
	            else {
	                throw new Error("Framescript could not be found on FrameScriptManager.frameScriptDebug.\n the Object set as FrameScriptmanager.frameScriptDebug should contain a function with the name '" + functionname + "' !!!");
	            }
	        }
	        this._framescripts[keyframe_index] = value;
	    };
	    Timeline.prototype.regexIndexOf = function (str, regex, startpos) {
	        var indexOf = str.substring(startpos || 0).search(regex);
	        return (indexOf >= 0) ? (indexOf + (startpos || 0)) : indexOf;
	    };
	    Timeline.prototype.add_script_for_postcontruct = function (target_mc, keyframe_idx, scriptPass1) {
	        if (scriptPass1 === void 0) { scriptPass1 = false; }
	        if (this._framescripts[keyframe_idx] != null) {
	            if (this._framescripts_translated[keyframe_idx] == null) {
	                this._framescripts[keyframe_idx] = target_mc.adapter.evalScript(this._framescripts[keyframe_idx]);
	                this._framescripts_translated[keyframe_idx] = true;
	            }
	            if (scriptPass1)
	                FrameScriptManager_1.FrameScriptManager.add_script_to_queue(target_mc, this._framescripts[keyframe_idx]);
	            else
	                FrameScriptManager_1.FrameScriptManager.add_script_to_queue_pass2(target_mc, this._framescripts[keyframe_idx]);
	        }
	    };
	    Object.defineProperty(Timeline.prototype, "numFrames", {
	        get: function () {
	            return this.keyframe_indices.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Timeline.prototype, "potentialPrototypes", {
	        get: function () {
	            return this._potentialPrototypes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Timeline.prototype.getPotentialChildPrototype = function (id) {
	        return this._potentialPrototypes[id];
	    };
	    Timeline.prototype.getKeyframeIndexForFrameIndex = function (frame_index) {
	        return this.keyframe_indices[frame_index];
	    };
	    Timeline.prototype.getPotentialChildInstance = function (id) {
	        var this_clone = this._potentialPrototypes[id].clone();
	        this_clone.name = "";
	        return this_clone;
	    };
	    Timeline.prototype.registerPotentialChild = function (prototype) {
	        var id = this._potentialPrototypes.length;
	        this._potentialPrototypes[id] = prototype;
	    };
	    Timeline.prototype.jumpToLabel = function (target_mc, label) {
	        var key_frame_index = this._labels[label];
	        if (key_frame_index >= 0)
	            target_mc.currentFrameIndex = this.keyframe_firstframes[key_frame_index];
	    };
	    Timeline.prototype.gotoFrame = function (target_mc, value, skip_script) {
	        if (skip_script === void 0) { skip_script = false; }
	        var current_keyframe_idx = target_mc.constructedKeyFrameIndex;
	        var target_keyframe_idx = this.keyframe_indices[value];
	        if (current_keyframe_idx == target_keyframe_idx)
	            return;
	        if (current_keyframe_idx + 1 == target_keyframe_idx) {
	            this.constructNextFrame(target_mc, !skip_script, true);
	            return;
	        }
	        var break_frame_idx = this.keyframe_constructframes[target_keyframe_idx];
	        //we now have 3 index to keyframes: current_keyframe_idx / target_keyframe_idx / break_frame_idx
	        var jump_forward = (target_keyframe_idx > current_keyframe_idx);
	        var jump_gap = (break_frame_idx > current_keyframe_idx);
	        // in case we jump forward, but not jump a gap, we start at current_keyframe_idx + 1
	        // in case we jump back or we jump a gap, we want to start constructing at BreakFrame
	        var start_construct_idx = (jump_forward && !jump_gap) ? current_keyframe_idx + 1 : break_frame_idx;
	        var i;
	        var k;
	        if (jump_gap)
	            for (i = target_mc.numChildren - 1; i >= 0; i--)
	                if (target_mc._children[i]._depthID < 0)
	                    target_mc.removeChildAt(i);
	        //if we jump back, we want to reset all objects (but not the timelines of the mcs)
	        if (!jump_forward)
	            target_mc.resetSessionIDs();
	        // in other cases, we want to collect the current objects to compare state of targetframe with state of currentframe
	        var depth_sessionIDs = target_mc.getSessionIDDepths();
	        //pass1: only apply add/remove commands into depth_sessionIDs.
	        this.pass1(start_construct_idx, target_keyframe_idx, depth_sessionIDs);
	        // check what childs are alive on both frames.
	        // childs that are not alive anymore get removed and unregistered
	        // childs that are alive on both frames have their properties reset if we are jumping back
	        var child;
	        for (i = target_mc.numChildren - 1; i >= 0; i--) {
	            child = target_mc._children[i];
	            if (child._depthID < 0) {
	                if (depth_sessionIDs[child._depthID] != child._sessionID) {
	                    target_mc.removeChildAt(i);
	                }
	                else if (!jump_forward) {
	                    if (child.adapter) {
	                        if (!child.adapter.isBlockedByScript()) {
	                            child.transform.clearMatrix3D();
	                            child.transform.clearColorTransform();
	                            //this.name="";
	                            child.masks = null;
	                            child.maskMode = false;
	                        }
	                        if (!child.adapter.isVisibilityByScript()) {
	                            child.visible = true;
	                        }
	                    }
	                }
	            }
	        }
	        // now we need to addchild the objects that were added before targetframe first
	        // than we can add the script of the targetframe
	        // than we can addchild objects added on targetframe
	        for (var key in depth_sessionIDs) {
	            child = target_mc.getPotentialChildInstance(this.add_child_stream[depth_sessionIDs[key] * 2]);
	            if (child._sessionID == -1)
	                target_mc._addTimelineChildAt(child, Number(key), depth_sessionIDs[key]);
	        }
	        if (!skip_script && this.keyframe_firstframes[target_keyframe_idx] == value)
	            this.add_script_for_postcontruct(target_mc, target_keyframe_idx, true);
	        //pass2: apply update commands for objects on stage (only if they are not blocked by script)
	        this.pass2(target_mc);
	        target_mc.constructedKeyFrameIndex = target_keyframe_idx;
	    };
	    Timeline.prototype.pass1 = function (start_construct_idx, target_keyframe_idx, depth_sessionIDs) {
	        var i;
	        var k;
	        this._update_indices.length = 0; // store a list of updatecommand_indices, so we dont have to read frame_recipe again
	        var update_cnt = 0;
	        var start_index;
	        var end_index;
	        for (k = start_construct_idx; k <= target_keyframe_idx; k++) {
	            var frame_command_idx = this.frame_command_indices[k];
	            var frame_recipe = this.frame_recipe[k];
	            if (frame_recipe & 2) {
	                // remove childs
	                start_index = this.command_index_stream[frame_command_idx];
	                end_index = start_index + this.command_length_stream[frame_command_idx++];
	                for (i = start_index; i < end_index; i++)
	                    delete depth_sessionIDs[this.remove_child_stream[i] - 16383];
	            }
	            if (frame_recipe & 4) {
	                start_index = this.command_index_stream[frame_command_idx];
	                end_index = start_index + this.command_length_stream[frame_command_idx++];
	                // apply add commands in reversed order to have script exeucted in correct order.
	                // this could be changed in exporter
	                for (i = end_index - 1; i >= start_index; i--)
	                    depth_sessionIDs[this.add_child_stream[i * 2 + 1] - 16383] = i;
	            }
	            if (frame_recipe & 8)
	                this._update_indices[update_cnt++] = frame_command_idx; // execute update command later
	        }
	    };
	    Timeline.prototype.pass2 = function (target_mc) {
	        var k;
	        var len = this._update_indices.length;
	        for (k = 0; k < len; k++)
	            this.update_childs(target_mc, this._update_indices[k]);
	    };
	    Timeline.prototype.constructNextFrame = function (target_mc, queueScript, scriptPass1) {
	        if (queueScript === void 0) { queueScript = true; }
	        if (scriptPass1 === void 0) { scriptPass1 = false; }
	        var frameIndex = target_mc.currentFrameIndex;
	        var new_keyFrameIndex = this.keyframe_indices[frameIndex];
	        if (queueScript && this.keyframe_firstframes[new_keyFrameIndex] == frameIndex)
	            this.add_script_for_postcontruct(target_mc, new_keyFrameIndex, scriptPass1);
	        if (target_mc.constructedKeyFrameIndex != new_keyFrameIndex) {
	            target_mc.constructedKeyFrameIndex = new_keyFrameIndex;
	            var frame_command_idx = this.frame_command_indices[new_keyFrameIndex];
	            var frame_recipe = this.frame_recipe[new_keyFrameIndex];
	            if (frame_recipe & 1) {
	                for (var i = target_mc.numChildren - 1; i >= 0; i--)
	                    if (target_mc._children[i]._depthID < 0)
	                        target_mc.removeChildAt(i);
	            }
	            else if (frame_recipe & 2) {
	                this.remove_childs_continous(target_mc, frame_command_idx++);
	            }
	            if (frame_recipe & 4)
	                this.add_childs_continous(target_mc, frame_command_idx++);
	            if (frame_recipe & 8)
	                this.update_childs(target_mc, frame_command_idx++);
	        }
	    };
	    Timeline.prototype.remove_childs_continous = function (sourceMovieClip, frame_command_idx) {
	        var start_index = this.command_index_stream[frame_command_idx];
	        var end_index = start_index + this.command_length_stream[frame_command_idx];
	        for (var i = start_index; i < end_index; i++)
	            sourceMovieClip.removeChildAt(sourceMovieClip.getDepthIndexInternal(this.remove_child_stream[i] - 16383));
	    };
	    // used to add childs when jumping between frames
	    Timeline.prototype.add_childs_continous = function (sourceMovieClip, frame_command_idx) {
	        // apply add commands in reversed order to have script exeucted in correct order.
	        // this could be changed in exporter
	        var idx;
	        var start_index = this.command_index_stream[frame_command_idx];
	        var end_index = start_index + this.command_length_stream[frame_command_idx];
	        for (var i = end_index - 1; i >= start_index; i--) {
	            idx = i * 2;
	            sourceMovieClip._addTimelineChildAt(sourceMovieClip.getPotentialChildInstance(this.add_child_stream[idx]), this.add_child_stream[idx + 1] - 16383, i);
	        }
	    };
	    Timeline.prototype.update_childs = function (target_mc, frame_command_idx) {
	        var p;
	        var props_start_idx;
	        var props_end_index;
	        var start_index = this.command_index_stream[frame_command_idx];
	        var end_index = start_index + this.command_length_stream[frame_command_idx];
	        var child;
	        for (var i = start_index; i < end_index; i++) {
	            child = target_mc.getChildAtSessionID(this.update_child_stream[i]);
	            if (child) {
	                // check if the child is active + not blocked by script
	                this._blocked = Boolean(child.adapter && child.adapter.isBlockedByScript());
	                props_start_idx = this.update_child_props_indices_stream[i];
	                props_end_index = props_start_idx + this.update_child_props_length_stream[i];
	                for (p = props_start_idx; p < props_end_index; p++)
	                    this._functions[this.property_type_stream[p]].call(this, child, target_mc, this.property_index_stream[p]);
	            }
	        }
	    };
	    Timeline.prototype.update_mtx_all = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 6;
	        var new_matrix = child.transform.matrix3D;
	        new_matrix.rawData[0] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[1] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[4] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[5] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[12] = this.properties_stream_f32_mtx_all[i++];
	        new_matrix.rawData[13] = this.properties_stream_f32_mtx_all[i];
	        child.transform.invalidateComponents();
	    };
	    Timeline.prototype.update_colortransform = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 8;
	        var new_ct = child.transform.colorTransform || (child.transform.colorTransform = new ColorTransform_1.ColorTransform());
	        new_ct.rawData[0] = this.properties_stream_f32_ct[i++];
	        new_ct.rawData[1] = this.properties_stream_f32_ct[i++];
	        new_ct.rawData[2] = this.properties_stream_f32_ct[i++];
	        new_ct.rawData[3] = this.properties_stream_f32_ct[i++];
	        new_ct.rawData[4] = this.properties_stream_f32_ct[i++];
	        new_ct.rawData[5] = this.properties_stream_f32_ct[i++];
	        new_ct.rawData[6] = this.properties_stream_f32_ct[i++];
	        new_ct.rawData[7] = this.properties_stream_f32_ct[i];
	        child.transform.invalidateColorTransform();
	    };
	    Timeline.prototype.update_masks = function (child, target_mc, i) {
	        // an object could have multiple groups of masks, in case a graphic clip was merged into the timeline
	        // this is not implmeented in the runtime yet
	        // for now, a second mask-groupd would overwrite the first one
	        var mask;
	        var masks = new Array();
	        var numMasks = this.properties_stream_int[i++];
	        //mask may not exist if a goto command moves the playhead to a point in the timeline after
	        //one of the masks in a mask array has already been removed. Therefore a check is needed.
	        for (var m = 0; m < numMasks; m++)
	            if ((mask = target_mc.getChildAtSessionID(this.properties_stream_int[i++])))
	                masks.push(mask);
	        child.masks = masks;
	    };
	    Timeline.prototype.update_name = function (child, target_mc, i) {
	        child.name = this.properties_stream_strings[i];
	        target_mc.adapter.registerScriptObject(child);
	    };
	    Timeline.prototype.update_button_name = function (target, sourceMovieClip, i) {
	        target.name = this.properties_stream_strings[i];
	        // todo: creating the buttonlistenrs later should also be done, but for icycle i dont think this will cause problems
	        target.addButtonListeners();
	        sourceMovieClip.adapter.registerScriptObject(target);
	    };
	    Timeline.prototype.update_visibility = function (child, target_mc, i) {
	        if (!child.adapter || !child.adapter.isVisibilityByScript())
	            child.visible = Boolean(i);
	    };
	    Timeline.prototype.update_mtx_scale_rot = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 4;
	        var new_matrix = child.transform.matrix3D;
	        new_matrix.rawData[0] = this.properties_stream_f32_mtx_scale_rot[i++];
	        new_matrix.rawData[1] = this.properties_stream_f32_mtx_scale_rot[i++];
	        new_matrix.rawData[4] = this.properties_stream_f32_mtx_scale_rot[i++];
	        new_matrix.rawData[5] = this.properties_stream_f32_mtx_scale_rot[i];
	        child.transform.invalidateComponents();
	        child.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM);
	    };
	    Timeline.prototype.update_mtx_pos = function (child, target_mc, i) {
	        if (this._blocked)
	            return;
	        i *= 2;
	        var new_matrix = child.transform.matrix3D;
	        new_matrix.rawData[12] = this.properties_stream_f32_mtx_pos[i++];
	        new_matrix.rawData[13] = this.properties_stream_f32_mtx_pos[i];
	        child.transform.invalidatePosition();
	    };
	    Timeline.prototype.enable_maskmode = function (child, target_mc, i) {
	        child.maskMode = true;
	    };
	    Timeline.prototype.remove_masks = function (child, target_mc, i) {
	        child.masks = null;
	    };
	    Timeline.prototype.update_blendmode = function (child, target_mc, i) {
	        console.log("update blendmode " + i);
	    };
	    Timeline.prototype.update_rendermode = function (child, target_mc, i) {
	        console.log("update rendermode " + i);
	    };
	    return Timeline;
	}());
	exports.Timeline = Timeline;


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ColorUtils_1 = __webpack_require__(28);
	/**
	 * The ColorTransform export class lets you adjust the color values in a display
	 * object. The color adjustment or <i>color transformation</i> can be applied
	 * to all four channels: red, green, blue, and alpha transparency.
	 *
	 * <p>When a ColorTransform object is applied to a display object, a new value
	 * for each color channel is calculated like this:</p>
	 *
	 * <ul>
	 *   <li>New red value = (old red value * <code>redMultiplier</code>) +
	 * <code>redOffset</code></li>
	 *   <li>New green value = (old green value * <code>greenMultiplier</code>) +
	 * <code>greenOffset</code></li>
	 *   <li>New blue value = (old blue value * <code>blueMultiplier</code>) +
	 * <code>blueOffset</code></li>
	 *   <li>New alpha value = (old alpha value * <code>alphaMultiplier</code>) +
	 * <code>alphaOffset</code></li>
	 * </ul>
	 *
	 * <p>If any of the color channel values is greater than 255 after the
	 * calculation, it is set to 255. If it is less than 0, it is set to 0.</p>
	 *
	 * <p>You can use ColorTransform objects in the following ways:</p>
	 *
	 * <ul>
	 *   <li>In the <code>colorTransform</code> parameter of the
	 * <code>colorTransform()</code> method of the BitmapData class</li>
	 *   <li>As the <code>colorTransform</code> property of a Transform object
	 * (which can be used as the <code>transform</code> property of a display
	 * object)</li>
	 * </ul>
	 *
	 * <p>You must use the <code>new ColorTransform()</code> constructor to create
	 * a ColorTransform object before you can call the methods of the
	 * ColorTransform object.</p>
	 *
	 * <p>Color transformations do not apply to the background color of a movie
	 * clip(such as a loaded SWF object). They apply only to graphics and symbols
	 * that are attached to the movie clip.</p>
	 */
	var ColorTransform = (function () {
	    function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
	        if (redMultiplier === void 0) { redMultiplier = 1; }
	        if (greenMultiplier === void 0) { greenMultiplier = 1; }
	        if (blueMultiplier === void 0) { blueMultiplier = 1; }
	        if (alphaMultiplier === void 0) { alphaMultiplier = 1; }
	        if (redOffset === void 0) { redOffset = 0; }
	        if (greenOffset === void 0) { greenOffset = 0; }
	        if (blueOffset === void 0) { blueOffset = 0; }
	        if (alphaOffset === void 0) { alphaOffset = 0; }
	        this.rawData = new Float32Array(8);
	        if (redMultiplier instanceof Float32Array) {
	            this.copyRawDataFrom(redMultiplier);
	        }
	        else {
	            this.redMultiplier = Number(redMultiplier);
	            this.greenMultiplier = greenMultiplier;
	            this.blueMultiplier = blueMultiplier;
	            this.alphaMultiplier = alphaMultiplier;
	            this.redOffset = redOffset;
	            this.greenOffset = greenOffset;
	            this.blueOffset = blueOffset;
	            this.alphaOffset = alphaOffset;
	        }
	    }
	    Object.defineProperty(ColorTransform.prototype, "alphaMultiplier", {
	        /**
	         * A decimal value that is multiplied with the alpha transparency channel
	         * value.
	         *
	         * <p>If you set the alpha transparency value of a display object directly by
	         * using the <code>alpha</code> property of the DisplayObject instance, it
	         * affects the value of the <code>alphaMultiplier</code> property of that
	         * display object's <code>transform.colorTransform</code> property.</p>
	         */
	        get: function () {
	            return this.rawData[3];
	        },
	        set: function (value) {
	            this.rawData[3] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "alphaOffset", {
	        /**
	         * A number from -255 to 255 that is added to the alpha transparency channel
	         * value after it has been multiplied by the <code>alphaMultiplier</code>
	         * value.
	         */
	        get: function () {
	            return this.rawData[7] * 0xFF;
	        },
	        set: function (value) {
	            this.rawData[7] = value / 0xFF;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "blueMultiplier", {
	        /**
	         * A decimal value that is multiplied with the blue channel value.
	         */
	        get: function () {
	            return this.rawData[2];
	        },
	        set: function (value) {
	            this.rawData[2] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "blueOffset", {
	        /**
	         * A number from -255 to 255 that is added to the blue channel value after it
	         * has been multiplied by the <code>blueMultiplier</code> value.
	         */
	        get: function () {
	            return this.rawData[6] * 0xFF;
	        },
	        set: function (value) {
	            this.rawData[6] = value / 0xFF;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "greenMultiplier", {
	        /**
	         * A decimal value that is multiplied with the green channel value.
	         */
	        get: function () {
	            return this.rawData[1];
	        },
	        set: function (value) {
	            this.rawData[1] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "greenOffset", {
	        /**
	         * A number from -255 to 255 that is added to the green channel value after
	         * it has been multiplied by the <code>greenMultiplier</code> value.
	         */
	        get: function () {
	            return this.rawData[5] * 0xFF;
	        },
	        set: function (value) {
	            this.rawData[5] = value / 0xFF;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "redMultiplier", {
	        /**
	         * A decimal value that is multiplied with the red channel value.
	         */
	        get: function () {
	            return this.rawData[0];
	        },
	        set: function (value) {
	            this.rawData[0] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "redOffset", {
	        /**
	         * A number from -255 to 255 that is added to the red channel value after it
	         * has been multiplied by the <code>redMultiplier</code> value.
	         */
	        get: function () {
	            return this.rawData[4] * 0xFF;
	        },
	        set: function (value) {
	            this.rawData[4] = value / 0xFF;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorTransform.prototype, "color", {
	        /**
	         * The RGB color value for a ColorTransform object.
	         *
	         * <p>When you set this property, it changes the three color offset values
	         * (<code>redOffset</code>, <code>greenOffset</code>, and
	         * <code>blueOffset</code>) accordingly, and it sets the three color
	         * multiplier values(<code>redMultiplier</code>,
	         * <code>greenMultiplier</code>, and <code>blueMultiplier</code>) to 0. The
	         * alpha transparency multiplier and offset values do not change.</p>
	         *
	         * <p>When you pass a value for this property, use the format
	         * 0x<i>RRGGBB</i>. <i>RR</i>, <i>GG</i>, and <i>BB</i> each consist of two
	         * hexadecimal digits that specify the offset of each color component. The 0x
	         * tells the ActionScript compiler that the number is a hexadecimal
	         * value.</p>
	         */
	        get: function () {
	            return ((this.rawData[0] << 16) | (this.rawData[1] << 8) | this.rawData[2]);
	        },
	        set: function (value) {
	            var argb = ColorUtils_1.ColorUtils.float32ColorToARGB(value);
	            this.rawData[4] = argb[1]; //(value >> 16) & 0xFF;
	            this.rawData[5] = argb[2]; //(value >> 8) & 0xFF;
	            this.rawData[6] = argb[3]; //value & 0xFF;
	            this.rawData[0] = 0;
	            this.rawData[1] = 0;
	            this.rawData[2] = 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ColorTransform.prototype.copyRawDataFrom = function (vector, index) {
	        if (index === void 0) { index = 0; }
	        for (var c = 0; c < 8; c++)
	            this.rawData[c] = vector[c + index];
	    };
	    ColorTransform.prototype.clear = function () {
	        this.rawData[0] = 1;
	        this.rawData[1] = 1;
	        this.rawData[2] = 1;
	        this.rawData[3] = 1;
	        this.rawData[4] = 0;
	        this.rawData[5] = 0;
	        this.rawData[6] = 0;
	        this.rawData[7] = 0;
	    };
	    ColorTransform.prototype.clone = function () {
	        return new ColorTransform(this.rawData);
	    };
	    ColorTransform.prototype.copyFrom = function (source) {
	        for (var c = 0; c < 8; c++)
	            this.rawData[c] = source.rawData[c];
	    };
	    ColorTransform.prototype.copyTo = function (destination) {
	        destination.copyFrom(this);
	    };
	    ColorTransform.prototype.prepend = function (ct) {
	        this.rawData[4] += ct.rawData[4] * this.rawData[0];
	        this.rawData[5] += ct.rawData[5] * this.rawData[1];
	        this.rawData[6] += ct.rawData[6] * this.rawData[2];
	        this.rawData[7] += ct.rawData[7] * this.rawData[3];
	        this.redMultiplier *= ct.redMultiplier;
	        this.greenMultiplier *= ct.greenMultiplier;
	        this.blueMultiplier *= ct.blueMultiplier;
	        this.alphaMultiplier *= ct.alphaMultiplier;
	    };
	    ColorTransform.prototype._isRenderable = function () {
	        return this.rawData[3] != 0 || this.rawData[7] > 0;
	    };
	    return ColorTransform;
	}());
	exports.ColorTransform = ColorTransform;


/***/ },
/* 28 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var ColorUtils = (function () {
	    function ColorUtils() {
	    }
	    ColorUtils.float32ColorToARGB = function (float32Color) {
	        var a = (float32Color & 0xff000000) >>> 24;
	        var r = (float32Color & 0xff0000) >>> 16;
	        var g = (float32Color & 0xff00) >>> 8;
	        var b = float32Color & 0xff;
	        var result = [a, r, g, b];
	        return result;
	    };
	    ColorUtils.ARGBtoFloat32 = function (a, r, g, b) {
	        return ((a << 24) | (r << 16) | (g << 8) | b);
	    };
	    ColorUtils.componentToHex = function (c) {
	        var hex = c.toString(16);
	        return hex.length == 1 ? "0" + hex : hex;
	    };
	    ColorUtils.RGBToHexString = function (argb) {
	        return "#" + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
	    };
	    ColorUtils.ARGBToHexString = function (argb) {
	        return "#" + ColorUtils.componentToHex(argb[0]) + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
	    };
	    return ColorUtils;
	}());
	exports.ColorUtils = ColorUtils;


/***/ },
/* 29 */
/***/ function(module, exports) {

	"use strict";
	var FrameScriptManager = (function () {
	    function FrameScriptManager() {
	    }
	    FrameScriptManager.setInterval = function (func) {
	        this._intervalID++;
	        this._active_intervals[this._intervalID] = func;
	        return this._intervalID;
	    };
	    FrameScriptManager.clearInterval = function (id) {
	        delete this._active_intervals[id];
	    };
	    FrameScriptManager.execute_intervals = function () {
	        for (var key in this._active_intervals) {
	            this._active_intervals[key].call();
	        }
	    };
	    FrameScriptManager.add_child_to_dispose = function (child) {
	        this._queued_dispose.push(child);
	    };
	    FrameScriptManager.add_script_to_queue = function (mc, script) {
	        // whenever we queue scripts of new objects, we first inject the lists of pass2
	        var i = this._queued_mcs_pass2.length;
	        while (i--) {
	            this._queued_mcs.push(this._queued_mcs_pass2[i]);
	            this._queued_scripts.push(this._queued_scripts_pass2[i]);
	        }
	        this._queued_mcs_pass2.length = 0;
	        this._queued_scripts_pass2.length = 0;
	        this._queued_mcs.push(mc);
	        this._queued_scripts.push(script);
	    };
	    FrameScriptManager.add_script_to_queue_pass2 = function (mc, script) {
	        this._queued_mcs_pass2.push(mc);
	        this._queued_scripts_pass2.push(script);
	    };
	    FrameScriptManager.execute_queue = function () {
	        if (this._queued_mcs.length == 0 && this._queued_mcs_pass2.length == 0)
	            return;
	        var i = this._queued_mcs_pass2.length;
	        while (i--) {
	            this._queued_mcs.push(this._queued_mcs_pass2[i]);
	            this._queued_scripts.push(this._queued_scripts_pass2[i]);
	        }
	        this._queued_mcs_pass2.length = 0;
	        this._queued_scripts_pass2.length = 0;
	        var mc;
	        for (i = 0; i < this._queued_mcs.length; i++) {
	            // during the loop we might add more scripts to the queue
	            mc = this._queued_mcs[i];
	            if (mc.scene != null) {
	                var caller = mc.adapter ? mc.adapter : mc;
	                //	try {
	                this._queued_scripts[i].call(caller);
	            }
	        }
	        // all scripts executed. clear all
	        this._queued_mcs.length = 0;
	        this._queued_scripts.length = 0;
	    };
	    FrameScriptManager.execute_dispose = function () {
	        var len = this._queued_dispose.length;
	        for (var i = 0; i < len; i++)
	            this._queued_dispose[i].dispose();
	        this._queued_dispose.length = 0;
	    };
	    // FrameScript debugging:
	    // the first line of a FrameScript should be a comment that represents the functions unique name
	    // the exporter creates a js file, containing a object that has the framescripts functions set as properties according to the unique names
	    // this object can be set as "frameScriptDebug" in order to enable debug mode
	    FrameScriptManager.frameScriptDebug = undefined;
	    //queue of objects for disposal
	    FrameScriptManager._queued_dispose = new Array();
	    // queues pass1 of scripts.
	    FrameScriptManager._queued_mcs = [];
	    FrameScriptManager._queued_scripts = [];
	    // queues pass2 of scripts. this will be inserted in reversed order into pass1 queue right before something should be added to pass1
	    FrameScriptManager._queued_mcs_pass2 = [];
	    FrameScriptManager._queued_scripts_pass2 = [];
	    FrameScriptManager._active_intervals = new Object(); // maps id to function
	    FrameScriptManager._intervalID = 0;
	    return FrameScriptManager;
	}());
	exports.FrameScriptManager = FrameScriptManager;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = FrameScriptManager;


/***/ },
/* 30 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var TouchPoint = (function () {
	    function TouchPoint(x, y, id) {
	        this.x = x;
	        this.y = y;
	        this.id = id;
	    }
	    return TouchPoint;
	}());
	exports.TouchPoint = TouchPoint;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(11);
	var Matrix3D_1 = __webpack_require__(32);
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Vector3D_1 = __webpack_require__(34);
	var TransformEvent_1 = __webpack_require__(39);
	/**
	 * The Transform class provides access to color adjustment properties and two-
	 * or three-dimensional transformation objects that can be applied to a
	 * display object. During the transformation, the color or the orientation and
	 * position of a display object is adjusted(offset) from the current values
	 * or coordinates to new values or coordinates. The Transform class also
	 * collects data about color and two-dimensional matrix transformations that
	 * are applied to a display object and all of its parent objects. You can
	 * access these combined transformations through the
	 * <code>concatenatedColorTransform</code> and <code>concatenatedMatrix</code>
	 * properties.
	 *
	 * <p>To apply color transformations: create a ColorTransform object, set the
	 * color adjustments using the object's methods and properties, and then
	 * assign the <code>colorTransformation</code> property of the
	 * <code>transform</code> property of the display object to the new
	 * ColorTransformation object.</p>
	 *
	 * <p>To apply two-dimensional transformations: create a Matrix object, set
	 * the matrix's two-dimensional transformation, and then assign the
	 * <code>transform.matrix</code> property of the display object to the new
	 * Matrix object.</p>
	 *
	 * <p>To apply three-dimensional transformations: start with a
	 * three-dimensional display object. A three-dimensional display object has a
	 * <code>z</code> property value other than zero. You do not need to create
	 * the Matrix3D object. For all three-dimensional objects, a Matrix3D object
	 * is created automatically when you assign a <code>z</code> value to a
	 * display object. You can access the display object's Matrix3D object through
	 * the display object's <code>transform</code> property. Using the methods of
	 * the Matrix3D class, you can add to or modify the existing transformation
	 * settings. Also, you can create a custom Matrix3D object, set the custom
	 * Matrix3D object's transformation elements, and then assign the new Matrix3D
	 * object to the display object using the <code>transform.matrix</code>
	 * property.</p>
	 *
	 * <p>To modify a perspective projection of the stage or root object: use the
	 * <code>transform.matrix</code> property of the root display object to gain
	 * access to the PerspectiveProjection object. Or, apply different perspective
	 * projection properties to a display object by setting the perspective
	 * projection properties of the display object's parent. The child display
	 * object inherits the new properties. Specifically, create a
	 * PerspectiveProjection object and set its properties, then assign the
	 * PerspectiveProjection object to the <code>perspectiveProjection</code>
	 * property of the parent display object's <code>transform</code> property.
	 * The specified projection transformation then applies to all the display
	 * object's three-dimensional children.</p>
	 *
	 * <p>Since both PerspectiveProjection and Matrix3D objects perform
	 * perspective transformations, do not assign both to a display object at the
	 * same time. Use the PerspectiveProjection object for focal length and
	 * projection center changes. For more control over the perspective
	 * transformation, create a perspective projection Matrix3D object.</p>
	 */
	var Transform = (function (_super) {
	    __extends(Transform, _super);
	    function Transform() {
	        _super.call(this);
	        this._matrix3D = new Matrix3D_1.Matrix3D();
	        this._rotation = new Vector3D_1.Vector3D();
	        this._skew = new Vector3D_1.Vector3D();
	        this._scale = new Vector3D_1.Vector3D(1, 1, 1);
	        // Cached vector of transformation components used when
	        // recomposing the transform matrix in updateTransform()
	        this._components = new Array(4);
	        this._components[1] = this._rotation;
	        this._components[2] = this._skew;
	        this._components[3] = this._scale;
	    }
	    Object.defineProperty(Transform.prototype, "backVector", {
	        /**
	         *
	         */
	        get: function () {
	            var director = Matrix3DUtils_1.Matrix3DUtils.getForward(this._matrix3D);
	            director.negate();
	            return director;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "colorTransform", {
	        /**
	         * A ColorTransform object containing values that universally adjust the
	         * colors in the display object.
	         *
	         * @throws TypeError The colorTransform is null when being set
	         */
	        get: function () {
	            return this._colorTransform;
	        },
	        set: function (val) {
	            if (this._colorTransform == val)
	                return;
	            this._colorTransform = val;
	            this.invalidateColorTransform();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "concatenatedColorTransform", {
	        /**
	         * A ColorTransform object representing the combined color transformations
	         * applied to the display object and all of its parent objects, back to the
	         * root level. If different color transformations have been applied at
	         * different levels, all of those transformations are concatenated into one
	         * ColorTransform object for this property.
	         */
	        get: function () {
	            return this._concatenatedColorTransform; //TODO
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "concatenatedMatrix", {
	        /**
	         * A Matrix object representing the combined transformation matrixes of the
	         * display object and all of its parent objects, back to the root level. If
	         * different transformation matrixes have been applied at different levels,
	         * all of those matrixes are concatenated into one matrix for this property.
	         * Also, for resizeable SWF content running in the browser, this property
	         * factors in the difference between stage coordinates and window coordinates
	         * due to window resizing. Thus, the property converts local coordinates to
	         * window coordinates, which may not be the same coordinate space as that of
	         * the Scene.
	         */
	        get: function () {
	            return this._concatenatedMatrix; //TODO
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "downVector", {
	        /**
	         *
	         */
	        get: function () {
	            var director = Matrix3DUtils_1.Matrix3DUtils.getUp(this._matrix3D);
	            director.negate();
	            return director;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "forwardVector", {
	        /**
	         *
	         */
	        get: function () {
	            return Matrix3DUtils_1.Matrix3DUtils.getForward(this._matrix3D);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "leftVector", {
	        /**
	         *
	         */
	        get: function () {
	            var director = Matrix3DUtils_1.Matrix3DUtils.getRight(this._matrix3D);
	            director.negate();
	            return director;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "matrix3D", {
	        /**
	         * Provides access to the Matrix3D object of a three-dimensional display
	         * object. The Matrix3D object represents a transformation matrix that
	         * determines the display object's position and orientation. A Matrix3D
	         * object can also perform perspective projection.
	         *
	         * <p>If the <code>matrix</code> property is set to a value(not
	         * <code>null</code>), the <code>matrix3D</code> property is
	         * <code>null</code>. And if the <code>matrix3D</code> property is set to a
	         * value(not <code>null</code>), the <code>matrix</code> property is
	         * <code>null</code>.</p>
	         */
	        get: function () {
	            if (this._matrix3DDirty)
	                this._updateMatrix3D();
	            return this._matrix3D;
	        },
	        set: function (val) {
	            for (var i = 0; i < 15; i++)
	                this._matrix3D.rawData[i] = val.rawData[i];
	            this.invalidateComponents();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "pixelBounds", {
	        /**
	         * A Rectangle object that defines the bounding rectangle of the display
	         * object on the stage.
	         */
	        get: function () {
	            return this._pixelBounds;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "position", {
	        /**
	         * Defines the position of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            return this._matrix3D.position;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "rightVector", {
	        /**
	         *
	         */
	        get: function () {
	            return Matrix3DUtils_1.Matrix3DUtils.getRight(this.matrix3D);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Transform.prototype, "rotation", {
	        /**
	         * Defines the rotation of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            if (this._componentsDirty)
	                this._updateComponents();
	            return this._rotation;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Rotates the 3d object directly to a euler angle
	     *
	     * @param    ax        The angle in degrees of the rotation around the x axis.
	     * @param    ay        The angle in degrees of the rotation around the y axis.
	     * @param    az        The angle in degrees of the rotation around the z axis.
	     */
	    Transform.prototype.rotateTo = function (ax, ay, az) {
	        if (this._componentsDirty)
	            this._updateComponents();
	        this._rotation.x = ax;
	        this._rotation.y = ay;
	        this._rotation.z = az;
	        this.invalidateMatrix3D();
	    };
	    Object.defineProperty(Transform.prototype, "scale", {
	        /**
	         * Defines the scale of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            if (this._componentsDirty)
	                this._updateComponents();
	            return this._scale;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Transform.prototype.scaleTo = function (sx, sy, sz) {
	        if (this._componentsDirty)
	            this._updateComponents();
	        this._scale.x = sx;
	        this._scale.y = sy;
	        this._scale.z = sz;
	        this.invalidateMatrix3D();
	    };
	    Object.defineProperty(Transform.prototype, "skew", {
	        /**
	         * Defines the scale of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	         */
	        get: function () {
	            if (this._componentsDirty)
	                this._updateComponents();
	            return this._skew;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Transform.prototype.skewTo = function (sx, sy, sz) {
	        if (this._componentsDirty)
	            this._updateComponents();
	        this._skew.x = sx;
	        this._skew.y = sy;
	        this._skew.z = sz;
	        this.invalidateMatrix3D();
	    };
	    Object.defineProperty(Transform.prototype, "upVector", {
	        /**
	         *
	         */
	        get: function () {
	            return Matrix3DUtils_1.Matrix3DUtils.getUp(this.matrix3D);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Transform.prototype.dispose = function () {
	    };
	    /**
	     * Returns a Matrix3D object, which can transform the space of a specified
	     * display object in relation to the current display object's space. You can
	     * use the <code>getRelativeMatrix3D()</code> method to move one
	     * three-dimensional display object relative to another three-dimensional
	     * display object.
	     *
	     * @param relativeTo The display object relative to which the transformation
	     *                   occurs. To get a Matrix3D object relative to the stage,
	     *                   set the parameter to the <code>root</code> or
	     *                   <code>stage</code> object. To get the world-relative
	     *                   matrix of the display object, set the parameter to a
	     *                   display object that has a perspective transformation
	     *                   applied to it.
	     * @return A Matrix3D object that can be used to transform the space from the
	     *         <code>relativeTo</code> display object to the current display
	     *         object space.
	     */
	    Transform.prototype.getRelativeMatrix3D = function (relativeTo) {
	        return new Matrix3D_1.Matrix3D(); //TODO
	    };
	    /**
	     * Moves the 3d object forwards along it's local z axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveForward = function (distance) {
	        this.translateLocal(Vector3D_1.Vector3D.Z_AXIS, distance);
	    };
	    /**
	     * Moves the 3d object backwards along it's local z axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveBackward = function (distance) {
	        this.translateLocal(Vector3D_1.Vector3D.Z_AXIS, -distance);
	    };
	    /**
	     * Moves the 3d object backwards along it's local x axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveLeft = function (distance) {
	        this.translateLocal(Vector3D_1.Vector3D.X_AXIS, -distance);
	    };
	    /**
	     * Moves the 3d object forwards along it's local x axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveRight = function (distance) {
	        this.translateLocal(Vector3D_1.Vector3D.X_AXIS, distance);
	    };
	    /**
	     * Moves the 3d object forwards along it's local y axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveUp = function (distance) {
	        this.translateLocal(Vector3D_1.Vector3D.Y_AXIS, distance);
	    };
	    /**
	     * Moves the 3d object backwards along it's local y axis
	     *
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.moveDown = function (distance) {
	        this.translateLocal(Vector3D_1.Vector3D.Y_AXIS, -distance);
	    };
	    /**
	     * Moves the 3d object directly to a point in space
	     *
	     * @param    dx        The amount of movement along the local x axis.
	     * @param    dy        The amount of movement along the local y axis.
	     * @param    dz        The amount of movement along the local z axis.
	     */
	    Transform.prototype.moveTo = function (dx, dy, dz) {
	        this._matrix3D.rawData[12] = dx;
	        this._matrix3D.rawData[13] = dy;
	        this._matrix3D.rawData[14] = dz;
	        this.invalidatePosition();
	    };
	    /**
	     * Rotates the 3d object around it's local x-axis
	     *
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.pitch = function (angle) {
	        this.rotate(Vector3D_1.Vector3D.X_AXIS, angle);
	    };
	    /**
	     * Rotates the 3d object around it's local z-axis
	     *
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.roll = function (angle) {
	        this.rotate(Vector3D_1.Vector3D.Z_AXIS, angle);
	    };
	    /**
	     * Rotates the 3d object around it's local y-axis
	     *
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.yaw = function (angle) {
	        this.rotate(Vector3D_1.Vector3D.Y_AXIS, angle);
	    };
	    /**
	     * Rotates the 3d object around an axis by a defined angle
	     *
	     * @param    axis        The vector defining the axis of rotation
	     * @param    angle        The amount of rotation in degrees
	     */
	    Transform.prototype.rotate = function (axis, angle) {
	        this.matrix3D.prependRotation(angle, axis);
	        this.invalidateComponents();
	    };
	    /**
	     * Moves the 3d object along a vector by a defined length
	     *
	     * @param    axis        The vector defining the axis of movement
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.translate = function (axis, distance) {
	        var x = axis.x, y = axis.y, z = axis.z;
	        var len = distance / Math.sqrt(x * x + y * y + z * z);
	        this.matrix3D.appendTranslation(x * len, y * len, z * len);
	        this.invalidatePosition();
	    };
	    /**
	     * Moves the 3d object along a vector by a defined length
	     *
	     * @param    axis        The vector defining the axis of movement
	     * @param    distance    The length of the movement
	     */
	    Transform.prototype.translateLocal = function (axis, distance) {
	        var x = axis.x, y = axis.y, z = axis.z;
	        var len = distance / Math.sqrt(x * x + y * y + z * z);
	        this.matrix3D.prependTranslation(x * len, y * len, z * len);
	        this.invalidatePosition();
	    };
	    Transform.prototype.clearMatrix3D = function () {
	        this._matrix3D.identity();
	        this.invalidateComponents();
	    };
	    Transform.prototype.clearColorTransform = function () {
	        if (!this._colorTransform)
	            return;
	        this._colorTransform.clear();
	        this.invalidateColorTransform();
	    };
	    /**
	     * Invalidates the 3D transformation matrix, causing it to be updated upon the next request
	     *
	     * @private
	     */
	    Transform.prototype.invalidateMatrix3D = function () {
	        this._matrix3DDirty = true;
	        this.dispatchEvent(new TransformEvent_1.TransformEvent(TransformEvent_1.TransformEvent.INVALIDATE_MATRIX3D, this));
	    };
	    Transform.prototype.invalidateComponents = function () {
	        this.invalidatePosition();
	        this._componentsDirty = true;
	    };
	    /**
	     *
	     */
	    Transform.prototype.invalidatePosition = function () {
	        this._matrix3D.invalidatePosition();
	        this.dispatchEvent(new TransformEvent_1.TransformEvent(TransformEvent_1.TransformEvent.INVALIDATE_MATRIX3D, this));
	    };
	    Transform.prototype.invalidateColorTransform = function () {
	        this.dispatchEvent(new TransformEvent_1.TransformEvent(TransformEvent_1.TransformEvent.INVALIDATE_COLOR_TRANSFORM, this));
	    };
	    /**
	     *
	     */
	    Transform.prototype._updateMatrix3D = function () {
	        this._matrix3D.recompose(this._components);
	        this._matrix3DDirty = false;
	    };
	    Transform.prototype._updateComponents = function () {
	        var elements = this._matrix3D.decompose();
	        var vec;
	        vec = elements[1];
	        this._rotation.x = vec.x;
	        this._rotation.y = vec.y;
	        this._rotation.z = vec.z;
	        vec = elements[2];
	        this._skew.x = vec.x;
	        this._skew.y = vec.y;
	        this._skew.z = vec.z;
	        vec = elements[3];
	        this._scale.x = vec.x;
	        this._scale.y = vec.y;
	        this._scale.z = vec.z;
	        this._componentsDirty = false;
	    };
	    return Transform;
	}(EventDispatcher_1.EventDispatcher));
	exports.Transform = Transform;


/***/ },
/* 32 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Box_1 = __webpack_require__(33);
	var MathConsts_1 = __webpack_require__(35);
	var Orientation3D_1 = __webpack_require__(36);
	var Vector3D_1 = __webpack_require__(34);
	var ArgumentError_1 = __webpack_require__(37);
	var Matrix3D = (function () {
	    /**
	     * Creates a Matrix3D object.
	     */
	    function Matrix3D(v) {
	        if (v === void 0) { v = null; }
	        /**
	         * A Vector of 16 Numbers, where every four elements is a column of a 4x4 matrix.
	         *
	         * <p>An exception is thrown if the rawData property is set to a matrix that is not invertible. The Matrix3D
	         * object must be invertible. If a non-invertible matrix is needed, create a subexport class of the Matrix3D object.</p>
	         */
	        this.rawData = new Float32Array(16);
	        this._position = new Vector3D_1.Vector3D();
	        this._positionDirty = true;
	        if (v != null && v.length == 16) {
	            this.copyRawDataFrom(v);
	        }
	        else {
	            this.identity();
	        }
	    }
	    /**
	     * Appends the matrix by multiplying another Matrix3D object by the current Matrix3D object.
	     */
	    Matrix3D.prototype.append = function (lhs) {
	        var lrd = lhs.rawData;
	        var m111 = this.rawData[0];
	        var m112 = this.rawData[1];
	        var m113 = this.rawData[2];
	        var m114 = this.rawData[3];
	        var m121 = this.rawData[4];
	        var m122 = this.rawData[5];
	        var m123 = this.rawData[6];
	        var m124 = this.rawData[7];
	        var m131 = this.rawData[8];
	        var m132 = this.rawData[9];
	        var m133 = this.rawData[10];
	        var m134 = this.rawData[11];
	        var m141 = this.rawData[12];
	        var m142 = this.rawData[13];
	        var m143 = this.rawData[14];
	        var m144 = this.rawData[15];
	        var m211 = lrd[0];
	        var m212 = lrd[1];
	        var m213 = lrd[2];
	        var m214 = lrd[3];
	        var m221 = lrd[4];
	        var m222 = lrd[5];
	        var m223 = lrd[6];
	        var m224 = lrd[7];
	        var m231 = lrd[8];
	        var m232 = lrd[9];
	        var m233 = lrd[10];
	        var m234 = lrd[11];
	        var m241 = lrd[12];
	        var m242 = lrd[13];
	        var m243 = lrd[14];
	        var m244 = lrd[15];
	        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
	        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
	        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
	        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
	        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
	        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
	        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
	        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
	        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
	        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
	        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
	        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
	        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
	        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
	        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
	        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
	        this._positionDirty = true;
	    };
	    /**
	     * Appends an incremental rotation to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendRotation = function (degrees, axis) {
	        this.append(Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees));
	    };
	    /**
	     * Appends an incremental skew change along the x, y, and z axes to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendSkew = function (xSkew, ySkew, zSkew) {
	        if (xSkew == 0 && ySkew == 0 && zSkew == 0)
	            return;
	        var raw = Matrix3D.tempRawData;
	        raw[0] = 1;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = xSkew;
	        raw[5] = 1;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = ySkew;
	        raw[9] = zSkew;
	        raw[10] = 1;
	        raw[11] = 0;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 1;
	        this.append(Matrix3D.tempMatrix);
	    };
	    /**
	     * Appends an incremental scale change along the x, y, and z axes to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
	        if (xScale == 1 && yScale == 1 && zScale == 1)
	            return;
	        var raw = Matrix3D.tempRawData;
	        raw[0] = xScale;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = 0;
	        raw[5] = yScale;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = 0;
	        raw[9] = 0;
	        raw[10] = zScale;
	        raw[11] = 0;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 1;
	        this.append(Matrix3D.tempMatrix);
	    };
	    /**
	     * Appends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
	     */
	    Matrix3D.prototype.appendTranslation = function (x, y, z) {
	        this.rawData[12] += x;
	        this.rawData[13] += y;
	        this.rawData[14] += z;
	        this._positionDirty = true;
	    };
	    /**
	     * Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.
	     */
	    Matrix3D.prototype.clone = function () {
	        return new Matrix3D(this.rawData);
	    };
	    /**
	     * Copies a Vector3D object into specific column of the calling Matrix3D object.
	     */
	    Matrix3D.prototype.copyColumnFrom = function (column, vector3D) {
	        switch (column) {
	            case 0:
	                this.rawData[0] = vector3D.x;
	                this.rawData[1] = vector3D.y;
	                this.rawData[2] = vector3D.z;
	                this.rawData[3] = vector3D.w;
	                break;
	            case 1:
	                this.rawData[4] = vector3D.x;
	                this.rawData[5] = vector3D.y;
	                this.rawData[6] = vector3D.z;
	                this.rawData[7] = vector3D.w;
	                break;
	            case 2:
	                this.rawData[8] = vector3D.x;
	                this.rawData[9] = vector3D.y;
	                this.rawData[10] = vector3D.z;
	                this.rawData[11] = vector3D.w;
	                break;
	            case 3:
	                this.rawData[12] = vector3D.x;
	                this.rawData[13] = vector3D.y;
	                this.rawData[14] = vector3D.z;
	                this.rawData[15] = vector3D.w;
	                break;
	            default:
	                throw new ArgumentError_1.ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Copies specific column of the calling Matrix3D object into the Vector3D object.
	     */
	    Matrix3D.prototype.copyColumnTo = function (column, vector3D) {
	        switch (column) {
	            case 0:
	                vector3D.x = this.rawData[0];
	                vector3D.y = this.rawData[1];
	                vector3D.z = this.rawData[2];
	                vector3D.w = this.rawData[3];
	                break;
	            case 1:
	                vector3D.x = this.rawData[4];
	                vector3D.y = this.rawData[5];
	                vector3D.z = this.rawData[6];
	                vector3D.w = this.rawData[7];
	                break;
	            case 2:
	                vector3D.x = this.rawData[8];
	                vector3D.y = this.rawData[9];
	                vector3D.z = this.rawData[10];
	                vector3D.w = this.rawData[11];
	                break;
	            case 3:
	                vector3D.x = this.rawData[12];
	                vector3D.y = this.rawData[13];
	                vector3D.z = this.rawData[14];
	                vector3D.w = this.rawData[15];
	                break;
	            default:
	                throw new ArgumentError_1.ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Copies all of the matrix data from the source Matrix3D object into the calling Matrix3D object.
	     */
	    Matrix3D.prototype.copyFrom = function (source) {
	        var sourceRaw = source.rawData;
	        var len = sourceRaw.length;
	        for (var c = 0; c < len; c++)
	            this.rawData[c] = sourceRaw[c];
	    };
	    /**
	     * Copies this Matrix3D object into a destination Matrix3D object.
	     */
	    Matrix3D.prototype.copyTo = function (target) {
	        var targetRaw = target.rawData;
	        var len = this.rawData.length;
	        for (var c = 0; c < len; c++)
	            targetRaw[c] = this.rawData[c];
	    };
	    Matrix3D.prototype.copyRawDataFrom = function (vector, index, transpose) {
	        if (index === void 0) { index = 0; }
	        if (transpose === void 0) { transpose = false; }
	        if (transpose)
	            this.transpose();
	        var len = vector.length - index;
	        for (var c = 0; c < len; c++)
	            this.rawData[c] = vector[c + index];
	        if (transpose)
	            this.transpose();
	    };
	    Matrix3D.prototype.copyRawDataTo = function (vector, index, transpose) {
	        if (index === void 0) { index = 0; }
	        if (transpose === void 0) { transpose = false; }
	        if (transpose)
	            this.transpose();
	        var len = this.rawData.length;
	        for (var c = 0; c < len; c++)
	            vector[c + index] = this.rawData[c];
	        if (transpose)
	            this.transpose();
	    };
	    /**
	     * Copies a Vector3D object into specific row of the calling Matrix3D object.
	     */
	    Matrix3D.prototype.copyRowFrom = function (row, vector3D) {
	        switch (row) {
	            case 0:
	                this.rawData[0] = vector3D.x;
	                this.rawData[4] = vector3D.y;
	                this.rawData[8] = vector3D.z;
	                this.rawData[12] = vector3D.w;
	                break;
	            case 1:
	                this.rawData[1] = vector3D.x;
	                this.rawData[5] = vector3D.y;
	                this.rawData[9] = vector3D.z;
	                this.rawData[13] = vector3D.w;
	                break;
	            case 2:
	                this.rawData[2] = vector3D.x;
	                this.rawData[6] = vector3D.y;
	                this.rawData[10] = vector3D.z;
	                this.rawData[14] = vector3D.w;
	                break;
	            case 3:
	                this.rawData[3] = vector3D.x;
	                this.rawData[7] = vector3D.y;
	                this.rawData[11] = vector3D.z;
	                this.rawData[15] = vector3D.w;
	                break;
	            default:
	                throw new ArgumentError_1.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Copies specific row of the calling Matrix3D object into the Vector3D object.
	     */
	    Matrix3D.prototype.copyRowTo = function (row, vector3D) {
	        switch (row) {
	            case 0:
	                vector3D.x = this.rawData[0];
	                vector3D.y = this.rawData[4];
	                vector3D.z = this.rawData[8];
	                vector3D.w = this.rawData[12];
	                break;
	            case 1:
	                vector3D.x = this.rawData[1];
	                vector3D.y = this.rawData[5];
	                vector3D.z = this.rawData[9];
	                vector3D.w = this.rawData[13];
	                break;
	            case 2:
	                vector3D.x = this.rawData[2];
	                vector3D.y = this.rawData[6];
	                vector3D.z = this.rawData[10];
	                vector3D.w = this.rawData[14];
	                break;
	            case 3:
	                vector3D.x = this.rawData[3];
	                vector3D.y = this.rawData[7];
	                vector3D.z = this.rawData[11];
	                vector3D.w = this.rawData[15];
	                break;
	            default:
	                throw new ArgumentError_1.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
	        }
	    };
	    /**
	     * Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector3D objects.
	     */
	    Matrix3D.prototype.decompose = function (orientationStyle) {
	        if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
	        var q;
	        if (this._components == null)
	            this._components = [null, new Vector3D_1.Vector3D(), new Vector3D_1.Vector3D(), new Vector3D_1.Vector3D()];
	        var colX = new Vector3D_1.Vector3D(this.rawData[0], this.rawData[1], this.rawData[2]);
	        var colY = new Vector3D_1.Vector3D(this.rawData[4], this.rawData[5], this.rawData[6]);
	        var colZ = new Vector3D_1.Vector3D(this.rawData[8], this.rawData[9], this.rawData[10]);
	        var scale = this._components[3];
	        var skew = this._components[2];
	        //compute X scale factor and normalise colX
	        scale.x = colX.length;
	        colX.scaleBy(1 / scale.x);
	        //compute XY shear factor and make colY orthogonal to colX
	        skew.x = colX.dotProduct(colY);
	        colY = Vector3D_1.Vector3D.combine(colY, colX, 1, -skew.x);
	        //compute Y scale factor and normalise colY
	        scale.y = colY.length;
	        colY.scaleBy(1 / scale.y);
	        skew.x /= scale.y;
	        //compute XZ and YZ shears and make colZ orthogonal to colX and colY
	        skew.y = colX.dotProduct(colZ);
	        colZ = Vector3D_1.Vector3D.combine(colZ, colX, 1, -skew.y);
	        skew.z = colY.dotProduct(colZ);
	        colZ = Vector3D_1.Vector3D.combine(colZ, colY, 1, -skew.z);
	        //compute Z scale and normalise colZ
	        scale.z = colZ.length;
	        colZ.scaleBy(1 / scale.z);
	        skew.y /= scale.z;
	        skew.z /= scale.z;
	        //at this point, the matrix (in cols) is orthonormal
	        //check for a coordinate system flip. If the determinant is -1, negate the z scaling factor
	        if (colX.dotProduct(colY.crossProduct(colZ)) < 0) {
	            scale.z = -scale.z;
	            colZ.x = -colZ.x;
	            colZ.y = -colZ.y;
	            colZ.z = -colZ.z;
	        }
	        var rot = this._components[1];
	        switch (orientationStyle) {
	            case Orientation3D_1.Orientation3D.AXIS_ANGLE:
	                rot.w = Math.acos((colX.x + colY.y + colZ.z - 1) / 2);
	                var len = Math.sqrt((colY.z - colZ.y) * (colY.z - colZ.y) + (colZ.x - colX.z) * (colZ.x - colX.z) + (colX.y - colY.x) * (colX.y - colY.x));
	                rot.x = (colY.z - colZ.y) / len;
	                rot.y = (colZ.x - colX.z) / len;
	                rot.z = (colX.y - colY.x) / len;
	                break;
	            case Orientation3D_1.Orientation3D.QUATERNION:
	                var tr = colX.x + colY.y + colZ.z;
	                if (tr > 0) {
	                    rot.w = Math.sqrt(1 + tr) / 2;
	                    rot.x = (colY.z - colZ.y) / (4 * rot.w);
	                    rot.y = (colZ.x - colX.z) / (4 * rot.w);
	                    rot.z = (colX.y - colY.x) / (4 * rot.w);
	                }
	                else if ((colX.x > colY.y) && (colX.x > colZ.z)) {
	                    rot.x = Math.sqrt(1 + colX.x - colY.y - colZ.z) / 2;
	                    rot.w = (colY.z - colZ.y) / (4 * rot.x);
	                    rot.y = (colX.y + colY.x) / (4 * rot.x);
	                    rot.z = (colZ.x + colX.z) / (4 * rot.x);
	                }
	                else if (colY.y > colZ.z) {
	                    rot.y = Math.sqrt(1 + colY.y - colX.x - colZ.z) / 2;
	                    rot.x = (colX.y + colY.x) / (4 * rot.y);
	                    rot.w = (colZ.x - colX.z) / (4 * rot.y);
	                    rot.z = (colY.z + colZ.y) / (4 * rot.y);
	                }
	                else {
	                    rot.z = Math.sqrt(1 + colZ.z - colX.x - colY.y) / 2;
	                    rot.x = (colZ.x + colX.z) / (4 * rot.z);
	                    rot.y = (colY.z + colZ.y) / (4 * rot.z);
	                    rot.w = (colX.y - colY.x) / (4 * rot.z);
	                }
	                break;
	            case Orientation3D_1.Orientation3D.EULER_ANGLES:
	                rot.y = Math.asin(-colX.z);
	                //var cos:number = Math.cos(rot.y);
	                if (colX.z != 1 && colX.z != -1) {
	                    rot.x = Math.atan2(colY.z, colZ.z);
	                    rot.z = Math.atan2(colX.y, colX.x);
	                }
	                else {
	                    rot.z = 0;
	                    rot.x = Math.atan2(colY.x, colY.y);
	                }
	                break;
	        }
	        this._components[0] = this.position;
	        return this._components;
	    };
	    /**
	     * Uses the transformation matrix without its translation elements to transform a Vector3D object from one space
	     * coordinate to another.
	     */
	    Matrix3D.prototype.deltaTransformVector = function (v, t) {
	        if (t === void 0) { t = null; }
	        var x = v.x;
	        var y = v.y;
	        var z = v.z;
	        if (!t)
	            t = new Vector3D_1.Vector3D();
	        t.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8];
	        t.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9];
	        t.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10];
	        t.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11];
	        return t;
	    };
	    /**
	     * Converts the current matrix to an identity or unit matrix.
	     */
	    Matrix3D.prototype.identity = function () {
	        this.rawData[0] = 1;
	        this.rawData[1] = 0;
	        this.rawData[2] = 0;
	        this.rawData[3] = 0;
	        this.rawData[4] = 0;
	        this.rawData[5] = 1;
	        this.rawData[6] = 0;
	        this.rawData[7] = 0;
	        this.rawData[8] = 0;
	        this.rawData[9] = 0;
	        this.rawData[10] = 1;
	        this.rawData[11] = 0;
	        this.rawData[12] = 0;
	        this.rawData[13] = 0;
	        this.rawData[14] = 0;
	        this.rawData[15] = 1;
	        this._positionDirty = true;
	    };
	    /**
	     * [static] Interpolates the translation, rotation, and scale transformation of one matrix toward those of the target matrix.
	     */
	    Matrix3D.interpolate = function (thisMat, toMat, percent) {
	        var m = new Matrix3D();
	        for (var i = 0; i < 16; ++i)
	            m.rawData[i] = thisMat.rawData[i] + (toMat.rawData[i] - thisMat.rawData[i]) * percent;
	        return m;
	    };
	    /**
	     * Interpolates this matrix towards the translation, rotation, and scale transformations of the target matrix.
	     */
	    Matrix3D.prototype.interpolateTo = function (toMat, percent) {
	        for (var i = 0; i < 16; ++i)
	            this.rawData[i] = this.rawData[i] + (toMat.rawData[i] - this.rawData[i]) * percent;
	    };
	    /**
	     * Inverts the current matrix.
	     */
	    Matrix3D.prototype.invert = function () {
	        var d = this.determinant;
	        var invertable = Math.abs(d) > 0.00000000001;
	        if (invertable) {
	            d = 1 / d;
	            var m11 = this.rawData[0];
	            var m12 = this.rawData[1];
	            var m13 = this.rawData[2];
	            var m14 = this.rawData[3];
	            var m21 = this.rawData[4];
	            var m22 = this.rawData[5];
	            var m23 = this.rawData[6];
	            var m24 = this.rawData[7];
	            var m31 = this.rawData[8];
	            var m32 = this.rawData[9];
	            var m33 = this.rawData[10];
	            var m34 = this.rawData[11];
	            var m41 = this.rawData[12];
	            var m42 = this.rawData[13];
	            var m43 = this.rawData[14];
	            var m44 = this.rawData[15];
	            this.rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
	            this.rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
	            this.rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
	            this.rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
	            this.rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
	            this.rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
	            this.rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
	            this.rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
	            this.rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
	            this.rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
	            this.rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
	            this.rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
	            this.rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
	            this.rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
	            this.rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
	            this.rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
	        }
	        this._positionDirty = true;
	        return invertable;
	    };
	    /* TODO implement pointAt
	     public pointAt( pos:Vector3D, at:Vector3D = null, up:Vector3D = null )
	     {
	     }
	     */
	    /**
	     * Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D object.
	     */
	    Matrix3D.prototype.prepend = function (rhs) {
	        var m111 = rhs.rawData[0];
	        var m112 = rhs.rawData[1];
	        var m113 = rhs.rawData[2];
	        var m114 = rhs.rawData[3];
	        var m121 = rhs.rawData[4];
	        var m122 = rhs.rawData[5];
	        var m123 = rhs.rawData[6];
	        var m124 = rhs.rawData[7];
	        var m131 = rhs.rawData[8];
	        var m132 = rhs.rawData[9];
	        var m133 = rhs.rawData[10];
	        var m134 = rhs.rawData[11];
	        var m141 = rhs.rawData[12];
	        var m142 = rhs.rawData[13];
	        var m143 = rhs.rawData[14];
	        var m144 = rhs.rawData[15];
	        var m211 = this.rawData[0];
	        var m212 = this.rawData[1];
	        var m213 = this.rawData[2];
	        var m214 = this.rawData[3];
	        var m221 = this.rawData[4];
	        var m222 = this.rawData[5];
	        var m223 = this.rawData[6];
	        var m224 = this.rawData[7];
	        var m231 = this.rawData[8];
	        var m232 = this.rawData[9];
	        var m233 = this.rawData[10];
	        var m234 = this.rawData[11];
	        var m241 = this.rawData[12];
	        var m242 = this.rawData[13];
	        var m243 = this.rawData[14];
	        var m244 = this.rawData[15];
	        this.rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
	        this.rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
	        this.rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
	        this.rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
	        this.rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
	        this.rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
	        this.rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
	        this.rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
	        this.rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
	        this.rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
	        this.rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
	        this.rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
	        this.rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
	        this.rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
	        this.rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
	        this.rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
	        this._positionDirty = true;
	    };
	    /**
	     * Prepends an incremental rotation to a Matrix3D object.
	     */
	    Matrix3D.prototype.prependRotation = function (degrees, axis) {
	        var m = Matrix3D.getAxisRotation(axis.x, axis.y, axis.z, degrees);
	        /*
	         if ( pivot != null )
	         {
	         var p:Vector3D = pivot;
	         m.appendTranslation( p.x, p.y, p.z );
	         }
	         */
	        this.prepend(m);
	    };
	    /**
	     * Prepends an incremental scale change along the x, y, and z axes to a Matrix3D object.
	     */
	    Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
	        if (xScale == 1 && yScale == 1 && zScale == 1)
	            return;
	        var raw = Matrix3D.tempRawData;
	        raw[0] = xScale;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = 0;
	        raw[5] = yScale;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = 0;
	        raw[9] = 0;
	        raw[10] = zScale;
	        raw[11] = 0;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 1;
	        this.prepend(Matrix3D.tempMatrix);
	    };
	    /**
	     * Prepends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
	     */
	    Matrix3D.prototype.prependTranslation = function (x, y, z) {
	        var raw = Matrix3D.tempRawData;
	        raw[0] = 1;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = 0;
	        raw[4] = 0;
	        raw[5] = 1;
	        raw[6] = 0;
	        raw[7] = 0;
	        raw[8] = 0;
	        raw[9] = 0;
	        raw[10] = 1;
	        raw[11] = 0;
	        raw[12] = x;
	        raw[13] = y;
	        raw[14] = z;
	        raw[15] = 1;
	        this.prepend(Matrix3D.tempMatrix);
	    };
	    // TODO orientationStyle
	    /**
	     * Sets the transformation matrix's translation, rotation, and scale settings.
	     */
	    Matrix3D.prototype.recompose = function (components) {
	        var pos = components[0] || this.position;
	        this.identity();
	        var scale = components[3];
	        if (scale && (scale.x != 1 || scale.y != 1 || scale.z != 1))
	            this.appendScale(scale.x, scale.y, scale.z);
	        var skew = components[2];
	        if (skew && (skew.x != 0 || skew.y != 0 || skew.z != 0))
	            this.appendSkew(skew.x, skew.y, skew.z);
	        var sin;
	        var cos;
	        var raw = Matrix3D.tempRawData;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 0;
	        var rotation = components[1];
	        if (rotation) {
	            var angle = -rotation.x;
	            if (angle != 0) {
	                sin = Math.sin(angle);
	                cos = Math.cos(angle);
	                raw[0] = 1;
	                raw[1] = 0;
	                raw[2] = 0;
	                raw[3] = 0;
	                raw[4] = 0;
	                raw[5] = cos;
	                raw[6] = -sin;
	                raw[7] = 0;
	                raw[8] = 0;
	                raw[9] = sin;
	                raw[10] = cos;
	                raw[11] = 0;
	                this.append(Matrix3D.tempMatrix);
	            }
	            angle = -rotation.y;
	            if (angle != 0) {
	                sin = Math.sin(angle);
	                cos = Math.cos(angle);
	                raw[0] = cos;
	                raw[1] = 0;
	                raw[2] = sin;
	                raw[3] = 0;
	                raw[4] = 0;
	                raw[5] = 1;
	                raw[6] = 0;
	                raw[7] = 0;
	                raw[8] = -sin;
	                raw[9] = 0;
	                raw[10] = cos;
	                raw[11] = 0;
	                this.append(Matrix3D.tempMatrix);
	            }
	            angle = -rotation.z;
	            if (angle != 0) {
	                sin = Math.sin(angle);
	                cos = Math.cos(angle);
	                raw[0] = cos;
	                raw[1] = -sin;
	                raw[2] = 0;
	                raw[3] = 0;
	                raw[4] = sin;
	                raw[5] = cos;
	                raw[6] = 0;
	                raw[7] = 0;
	                raw[8] = 0;
	                raw[9] = 0;
	                raw[10] = 1;
	                raw[11] = 0;
	                this.append(Matrix3D.tempMatrix);
	            }
	        }
	        this.rawData[12] = pos.x;
	        this.rawData[13] = pos.y;
	        this.rawData[14] = pos.z;
	        if (components[0])
	            this._positionDirty = true;
	        this.rawData[15] = 1;
	        return true;
	    };
	    Matrix3D.prototype.transformVector = function (v, t) {
	        if (t === void 0) { t = null; }
	        if (v == null)
	            return t || new Vector3D_1.Vector3D();
	        var x = v.x;
	        var y = v.y;
	        var z = v.z;
	        if (!t)
	            t = new Vector3D_1.Vector3D();
	        t.x = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
	        t.y = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
	        t.z = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
	        t.w = x * this.rawData[3] + y * this.rawData[7] + z * this.rawData[11] + this.rawData[15];
	        return t;
	    };
	    Matrix3D.prototype.transformBox = function (b, t) {
	        if (t === void 0) { t = null; }
	        if (b == null)
	            return t || new Box_1.Box();
	        var minX, minY, minZ;
	        var maxX, maxY, maxZ;
	        maxX = b.width + (minX = b.x);
	        maxY = b.height + (minY = b.y);
	        maxZ = b.depth + (minZ = b.z);
	        if (!t)
	            t = new Box_1.Box();
	        //TODO: take account of shear
	        t.width = maxX * this.rawData[0] + maxY * this.rawData[4] + maxZ * this.rawData[8] + this.rawData[12] - (t.x = minX * this.rawData[0] + minY * this.rawData[4] + minZ * this.rawData[8] + this.rawData[12]);
	        t.height = maxX * this.rawData[1] + maxY * this.rawData[5] + maxZ * this.rawData[9] + this.rawData[13] - (t.y = minX * this.rawData[1] + minY * this.rawData[5] + minZ * this.rawData[9] + this.rawData[13]);
	        t.depth = maxX * this.rawData[2] + maxY * this.rawData[6] + maxZ * this.rawData[10] + this.rawData[14] - (t.z = minX * this.rawData[2] + minY * this.rawData[6] + minZ * this.rawData[10] + this.rawData[14]);
	        return t;
	    };
	    /**
	     * Uses the transformation matrix to transform a Vector of Numbers from one coordinate space to another.
	     */
	    Matrix3D.prototype.transformVectors = function (vin, vout) {
	        var i = 0;
	        var x = 0, y = 0, z = 0;
	        while (i + 3 <= vin.length) {
	            x = vin[i];
	            y = vin[i + 1];
	            z = vin[i + 2];
	            vout[i] = x * this.rawData[0] + y * this.rawData[4] + z * this.rawData[8] + this.rawData[12];
	            vout[i + 1] = x * this.rawData[1] + y * this.rawData[5] + z * this.rawData[9] + this.rawData[13];
	            vout[i + 2] = x * this.rawData[2] + y * this.rawData[6] + z * this.rawData[10] + this.rawData[14];
	            i += 3;
	        }
	    };
	    /**
	     * Converts the current Matrix3D object to a matrix where the rows and columns are swapped.
	     */
	    Matrix3D.prototype.transpose = function () {
	        var raw = Matrix3D.tempRawData;
	        this.copyRawDataTo(raw);
	        this.rawData[1] = raw[4];
	        this.rawData[2] = raw[8];
	        this.rawData[3] = raw[12];
	        this.rawData[4] = raw[1];
	        this.rawData[6] = raw[9];
	        this.rawData[7] = raw[13];
	        this.rawData[8] = raw[2];
	        this.rawData[9] = raw[6];
	        this.rawData[11] = raw[14];
	        this.rawData[12] = raw[3];
	        this.rawData[13] = raw[7];
	        this.rawData[14] = raw[11];
	        this._positionDirty = true;
	    };
	    Matrix3D.getAxisRotation = function (x, y, z, degrees) {
	        // internal export class use by rotations which have been tested
	        var m = new Matrix3D();
	        var rad = degrees * MathConsts_1.MathConsts.DEGREES_TO_RADIANS;
	        var c = Math.cos(rad);
	        var s = Math.sin(rad);
	        var t = 1 - c;
	        var tmp1, tmp2;
	        m.rawData[0] = c + x * x * t;
	        m.rawData[5] = c + y * y * t;
	        m.rawData[10] = c + z * z * t;
	        tmp1 = x * y * t;
	        tmp2 = z * s;
	        m.rawData[1] = tmp1 + tmp2;
	        m.rawData[4] = tmp1 - tmp2;
	        tmp1 = x * z * t;
	        tmp2 = y * s;
	        m.rawData[8] = tmp1 + tmp2;
	        m.rawData[2] = tmp1 - tmp2;
	        tmp1 = y * z * t;
	        tmp2 = x * s;
	        m.rawData[9] = tmp1 - tmp2;
	        m.rawData[6] = tmp1 + tmp2;
	        return m;
	    };
	    Object.defineProperty(Matrix3D.prototype, "determinant", {
	        /**
	         * [read-only] A Number that determines whether a matrix is invertible.
	         */
	        get: function () {
	            return ((this.rawData[0] * this.rawData[5] - this.rawData[4] * this.rawData[1]) * (this.rawData[10] * this.rawData[15] - this.rawData[14] * this.rawData[11]) - (this.rawData[0] * this.rawData[9] - this.rawData[8] * this.rawData[1]) * (this.rawData[6] * this.rawData[15] - this.rawData[14] * this.rawData[7]) + (this.rawData[0] * this.rawData[13] - this.rawData[12] * this.rawData[1]) * (this.rawData[6] * this.rawData[11] - this.rawData[10] * this.rawData[7]) + (this.rawData[4] * this.rawData[9] - this.rawData[8] * this.rawData[5]) * (this.rawData[2] * this.rawData[15] - this.rawData[14] * this.rawData[3]) - (this.rawData[4] * this.rawData[13] - this.rawData[12] * this.rawData[5]) * (this.rawData[2] * this.rawData[11] - this.rawData[10] * this.rawData[3]) + (this.rawData[8] * this.rawData[13] - this.rawData[12] * this.rawData[9]) * (this.rawData[2] * this.rawData[7] - this.rawData[6] * this.rawData[3]));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix3D.prototype, "position", {
	        /**
	         * A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display object within the
	         * transformation's frame of reference.
	         */
	        get: function () {
	            if (this._positionDirty) {
	                this._positionDirty = false;
	                this._position.x = this.rawData[12];
	                this._position.y = this.rawData[13];
	                this._position.z = this.rawData[14];
	            }
	            return this._position;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Matrix3D.prototype.invalidatePosition = function () {
	        this._positionDirty = true;
	    };
	    Matrix3D.prototype.toFixed = function (decimalPlace) {
	        var magnitude = Math.pow(10, decimalPlace);
	        return "matrix3d(" + Math.round(this.rawData[0] * magnitude) / magnitude + "," + Math.round(this.rawData[1] * magnitude) / magnitude + "," + Math.round(this.rawData[2] * magnitude) / magnitude + "," + Math.round(this.rawData[3] * magnitude) / magnitude + "," + Math.round(this.rawData[4] * magnitude) / magnitude + "," + Math.round(this.rawData[5] * magnitude) / magnitude + "," + Math.round(this.rawData[6] * magnitude) / magnitude + "," + Math.round(this.rawData[7] * magnitude) / magnitude + "," + Math.round(this.rawData[8] * magnitude) / magnitude + "," + Math.round(this.rawData[9] * magnitude) / magnitude + "," + Math.round(this.rawData[10] * magnitude) / magnitude + "," + Math.round(this.rawData[11] * magnitude) / magnitude + "," + Math.round(this.rawData[12] * magnitude) / magnitude + "," + Math.round(this.rawData[13] * magnitude) / magnitude + "," + Math.round(this.rawData[14] * magnitude) / magnitude + "," + Math.round(this.rawData[15] * magnitude) / magnitude + ")";
	    };
	    Matrix3D.prototype.toString = function () {
	        return "matrix3d(" + Math.round(this.rawData[0] * 1000) / 1000 + "," + Math.round(this.rawData[1] * 1000) / 1000 + "," + Math.round(this.rawData[2] * 1000) / 1000 + "," + Math.round(this.rawData[3] * 1000) / 1000 + "," + Math.round(this.rawData[4] * 1000) / 1000 + "," + Math.round(this.rawData[5] * 1000) / 1000 + "," + Math.round(this.rawData[6] * 1000) / 1000 + "," + Math.round(this.rawData[7] * 1000) / 1000 + "," + Math.round(this.rawData[8] * 1000) / 1000 + "," + Math.round(this.rawData[9] * 1000) / 1000 + "," + Math.round(this.rawData[10] * 1000) / 1000 + "," + Math.round(this.rawData[11] * 1000) / 1000 + "," + Math.round(this.rawData[12] * 1000) / 1000 + "," + Math.round(this.rawData[13] * 1000) / 1000 + "," + Math.round(this.rawData[14] * 1000) / 1000 + "," + Math.round(this.rawData[15] * 1000) / 1000 + ")";
	    };
	    Matrix3D.tempMatrix = new Matrix3D();
	    Matrix3D.tempRawData = Matrix3D.tempMatrix.rawData;
	    return Matrix3D;
	}());
	exports.Matrix3D = Matrix3D;


/***/ },
/* 33 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(34);
	/**
	 * A Box object is an area defined by its position, as indicated by its
	 * top-left-front corner point(<i>x</i>, <i>y</i>, <i>z</i>) and by its width,
	 * height and depth.
	 *
	 *
	 * <p>The <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	 * <code>height</code> <code>depth</code> properties of the Box export class are
	 * independent of each other; changing the value of one property has no effect
	 * on the others. However, the <code>right</code>, <code>bottom</code> and
	 * <code>back</code> properties are integrally related to those six
	 * properties. For example, if you change the value of the <code>right</code>
	 * property, the value of the <code>width</code> property changes; if you
	 * change the <code>bottom</code> property, the value of the
	 * <code>height</code> property changes. </p>
	 *
	 * <p>The following methods and properties use Box objects:</p>
	 *
	 * <ul>
	 *   <li>The <code>bounds</code> property of the DisplayObject class</li>
	 * </ul>
	 *
	 * <p>You can use the <code>new Box()</code> constructor to create a
	 * Box object.</p>
	 *
	 * <p><b>Note:</b> The Box export class does not define a cubic Shape
	 * display object.
	 */
	var Box = (function () {
	    /**
	     * Creates a new Box object with the top-left-front corner specified by the
	     * <code>x</code>, <code>y</code> and <code>z</code> parameters and with the
	     * specified <code>width</code>, <code>height</code> and <code>depth</code>
	     * parameters. If you call this public without parameters, a box with
	     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	     * <code>height</code> and <code>depth</code> properties set to 0 is created.
	     *
	     * @param x      The <i>x</i> coordinate of the top-left-front corner of the
	     *               box.
	     * @param y      The <i>y</i> coordinate of the top-left-front corner of the
	     *               box.
	     * @param z      The <i>z</i> coordinate of the top-left-front corner of the
	     *               box.
	     * @param width  The width of the box, in pixels.
	     * @param height The height of the box, in pixels.
	     * @param depth The depth of the box, in pixels.
	     */
	    function Box(x, y, z, width, height, depth) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (width === void 0) { width = 0; }
	        if (height === void 0) { height = 0; }
	        if (depth === void 0) { depth = 0; }
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.width = width;
	        this.height = height;
	        this.depth = depth;
	    }
	    Object.defineProperty(Box.prototype, "back", {
	        /**
	         * The sum of the <code>z</code> and <code>height</code> properties.
	         */
	        get: function () {
	            return this.z + this.depth;
	        },
	        set: function (val) {
	            this.depth = val - this.z;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "bottom", {
	        /**
	         * The sum of the <code>y</code> and <code>height</code> properties.
	         */
	        get: function () {
	            return this.y + this.height;
	        },
	        set: function (val) {
	            this.height = val - this.y;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "bottomRightBack", {
	        /**
	         * The location of the Box object's bottom-right corner, determined by the
	         * values of the <code>right</code> and <code>bottom</code> properties.
	         */
	        get: function () {
	            if (this._bottomRightBack == null)
	                this._bottomRightBack = new Vector3D_1.Vector3D();
	            this._bottomRightBack.x = this.x + this.width;
	            this._bottomRightBack.y = this.y + this.height;
	            this._bottomRightBack.z = this.z + this.depth;
	            return this._bottomRightBack;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "front", {
	        /**
	         * The <i>z</i> coordinate of the top-left-front corner of the box. Changing
	         * the <code>front</code> property of a Box object has no effect on the
	         * <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code>
	         * properties. However it does affect the <code>depth</code> property,
	         * whereas changing the <code>z</code> value does <i>not</i> affect the
	         * <code>depth</code> property.
	         *
	         * <p>The value of the <code>left</code> property is equal to the value of
	         * the <code>x</code> property.</p>
	         */
	        get: function () {
	            return this.z;
	        },
	        set: function (val) {
	            this.depth += this.z - val;
	            this.z = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "left", {
	        /**
	         * The <i>x</i> coordinate of the top-left corner of the box. Changing the
	         * <code>left</code> property of a Box object has no effect on the
	         * <code>y</code> and <code>height</code> properties. However it does affect
	         * the <code>width</code> property, whereas changing the <code>x</code> value
	         * does <i>not</i> affect the <code>width</code> property.
	         *
	         * <p>The value of the <code>left</code> property is equal to the value of
	         * the <code>x</code> property.</p>
	         */
	        get: function () {
	            return this.x;
	        },
	        set: function (val) {
	            this.width += this.x - val;
	            this.x = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "right", {
	        /**
	         * The sum of the <code>x</code> and <code>width</code> properties.
	         */
	        get: function () {
	            return this.x + this.width;
	        },
	        set: function (val) {
	            this.width = val - this.x;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "size", {
	        /**
	         * The size of the Box object, expressed as a Vector3D object with the
	         * values of the <code>width</code>, <code>height</code> and
	         * <code>depth</code> properties.
	         */
	        get: function () {
	            if (this._size == null)
	                this._size = new Vector3D_1.Vector3D();
	            this._size.x = this.width;
	            this._size.y = this.height;
	            this._size.z = this.depth;
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "top", {
	        /**
	         * The <i>y</i> coordinate of the top-left-front corner of the box. Changing
	         * the <code>top</code> property of a Box object has no effect on the
	         * <code>x</code> and <code>width</code> properties. However it does affect
	         * the <code>height</code> property, whereas changing the <code>y</code>
	         * value does <i>not</i> affect the <code>height</code> property.
	         *
	         * <p>The value of the <code>top</code> property is equal to the value of the
	         * <code>y</code> property.</p>
	         */
	        get: function () {
	            return this.y;
	        },
	        set: function (val) {
	            this.height += (this.y - val);
	            this.y = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Box.prototype, "topLeftFront", {
	        /**
	         * The location of the Box object's top-left-front corner, determined by the
	         * <i>x</i>, <i>y</i> and <i>z</i> coordinates of the point.
	         */
	        get: function () {
	            if (this._topLeftFront == null)
	                this._topLeftFront = new Vector3D_1.Vector3D();
	            this._topLeftFront.x = this.x;
	            this._topLeftFront.y = this.y;
	            this._topLeftFront.z = this.z;
	            return this._topLeftFront;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new Box object with the same values for the <code>x</code>,
	     * <code>y</code>, <code>z</code>, <code>width</code>, <code>height</code>
	     * and <code>depth</code> properties as the original Box object.
	     *
	     * @return A new Box object with the same values for the <code>x</code>,
	     *         <code>y</code>, <code>z</code>, <code>width</code>,
	     *         <code>height</code> and <code>depth</code> properties as the
	     *         original Box object.
	     */
	    Box.prototype.clone = function () {
	        return new Box(this.x, this.y, this.z, this.width, this.height, this.depth);
	    };
	    /**
	     * Determines whether the specified position is contained within the cubic
	     * region defined by this Box object.
	     *
	     * @param x The <i>x</i> coordinate(horizontal component) of the position.
	     * @param y The <i>y</i> coordinate(vertical component) of the position.
	     * @param z The <i>z</i> coordinate(longitudinal component) of the position.
	     * @return A value of <code>true</code> if the Box object contains the
	     *         specified position; otherwise <code>false</code>.
	     */
	    Box.prototype.contains = function (x, y, z) {
	        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y && this.z <= z && this.z + this.depth >= z);
	    };
	    /**
	     * Determines whether the specified position is contained within the cubic
	     * region defined by this Box object. This method is similar to the
	     * <code>Box.contains()</code> method, except that it takes a Vector3D
	     * object as a parameter.
	     *
	     * @param position The position, as represented by its <i>x</i>, <i>y</i> and
	     *                 <i>z</i> coordinates.
	     * @return A value of <code>true</code> if the Box object contains the
	     *         specified position; otherwise <code>false</code>.
	     */
	    Box.prototype.containsPoint = function (position) {
	        return (this.x <= position.x && this.x + this.width >= position.x && this.y <= position.y && this.y + this.height >= position.y && this.z <= position.z && this.z + this.depth >= position.z);
	    };
	    /**
	     * Determines whether the Box object specified by the <code>box</code>
	     * parameter is contained within this Box object. A Box object is said to
	     * contain another if the second Box object falls entirely within the
	     * boundaries of the first.
	     *
	     * @param box The Box object being checked.
	     * @return A value of <code>true</code> if the Box object that you specify
	     *         is contained by this Box object; otherwise <code>false</code>.
	     */
	    Box.prototype.containsBox = function (box) {
	        return (this.x <= box.x && this.x + this.width >= box.x + box.width && this.y <= box.y && this.y + this.height >= box.y + box.height && this.z <= box.z && this.z + this.depth >= box.z + box.depth);
	    };
	    /**
	     * Copies all of box data from the source Box object into the calling
	     * Box object.
	     *
	     * @param sourceBox The Box object from which to copy the data.
	     */
	    Box.prototype.copyFrom = function (sourceBox) {
	        this.x = sourceBox.x;
	        this.y = sourceBox.y;
	        this.z = sourceBox.z;
	        this.width = sourceBox.width;
	        this.height = sourceBox.height;
	        this.depth = sourceBox.depth;
	    };
	    /**
	     * Determines whether the object specified in the <code>toCompare</code>
	     * parameter is equal to this Box object. This method compares the
	     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	     * <code>height</code> and <code>depth</code> properties of an object against
	     * the same properties of this Box object.
	     *
	     * @param toCompare The box to compare to this Box object.
	     * @return A value of <code>true</code> if the object has exactly the same
	     *         values for the <code>x</code>, <code>y</code>, <code>z</code>,
	     *         <code>width</code>, <code>height</code> and <code>depth</code>
	     *         properties as this Box object; otherwise <code>false</code>.
	     */
	    Box.prototype.equals = function (toCompare) {
	        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && this.width == toCompare.width && this.height == toCompare.height && this.depth == toCompare.depth);
	    };
	    /**
	     * Increases the size of the Box object by the specified amounts, in
	     * pixels. The center point of the Box object stays the same, and its
	     * size increases to the left and right by the <code>dx</code> value, to
	     * the top and the bottom by the <code>dy</code> value, and to
	     * the front and the back by the <code>dz</code> value.
	     *
	     * @param dx The value to be added to the left and the right of the Box
	     *           object. The following equation is used to calculate the new
	     *           width and position of the box:
	     * @param dy The value to be added to the top and the bottom of the Box
	     *           object. The following equation is used to calculate the new
	     *           height and position of the box:
	     * @param dz The value to be added to the front and the back of the Box
	     *           object. The following equation is used to calculate the new
	     *           depth and position of the box:
	     */
	    Box.prototype.inflate = function (dx, dy, dz) {
	        this.x -= dx / 2;
	        this.y -= dy / 2;
	        this.z -= dz / 2;
	        this.width += dx / 2;
	        this.height += dy / 2;
	        this.depth += dz / 2;
	    };
	    /**
	     * Increases the size of the Box object. This method is similar to the
	     * <code>Box.inflate()</code> method except it takes a Vector3D object as
	     * a parameter.
	     *
	     * <p>The following two code examples give the same result:</p>
	     *
	     * @param delta The <code>x</code> property of this Vector3D object is used to
	     *              increase the horizontal dimension of the Box object.
	     *              The <code>y</code> property is used to increase the vertical
	     *              dimension of the Box object.
	     *              The <code>z</code> property is used to increase the
	     *              longitudinal dimension of the Box object.
	     */
	    Box.prototype.inflatePoint = function (delta) {
	        this.x -= delta.x / 2;
	        this.y -= delta.y / 2;
	        this.z -= delta.z / 2;
	        this.width += delta.x / 2;
	        this.height += delta.y / 2;
	        this.depth += delta.z / 2;
	    };
	    /**
	     * If the Box object specified in the <code>toIntersect</code> parameter
	     * intersects with this Box object, returns the area of intersection
	     * as a Box object. If the boxes do not intersect, this method returns an
	     * empty Box object with its properties set to 0.
	     *
	     * @param toIntersect The Box object to compare against to see if it
	     *                    intersects with this Box object.
	     * @return A Box object that equals the area of intersection. If the
	     *         boxes do not intersect, this method returns an empty Box
	     *         object; that is, a box with its <code>x</code>, <code>y</code>,
	     *         <code>z</code>, <code>width</code>,  <code>height</code>, and
	     *         <code>depth</code> properties set to 0.
	     */
	    Box.prototype.intersection = function (toIntersect) {
	        if (this.intersects(toIntersect)) {
	            var i = new Box();
	            if (this.x > toIntersect.x) {
	                i.x = this.x;
	                i.width = toIntersect.x - this.x + toIntersect.width;
	                if (i.width > this.width)
	                    i.width = this.width;
	            }
	            else {
	                i.x = toIntersect.x;
	                i.width = this.x - toIntersect.x + this.width;
	                if (i.width > toIntersect.width)
	                    i.width = toIntersect.width;
	            }
	            if (this.y > toIntersect.y) {
	                i.y = this.y;
	                i.height = toIntersect.y - this.y + toIntersect.height;
	                if (i.height > this.height)
	                    i.height = this.height;
	            }
	            else {
	                i.y = toIntersect.y;
	                i.height = this.y - toIntersect.y + this.height;
	                if (i.height > toIntersect.height)
	                    i.height = toIntersect.height;
	            }
	            if (this.z > toIntersect.z) {
	                i.z = this.z;
	                i.depth = toIntersect.z - this.z + toIntersect.depth;
	                if (i.depth > this.depth)
	                    i.depth = this.depth;
	            }
	            else {
	                i.z = toIntersect.z;
	                i.depth = this.z - toIntersect.z + this.depth;
	                if (i.depth > toIntersect.depth)
	                    i.depth = toIntersect.depth;
	            }
	            return i;
	        }
	        return new Box();
	    };
	    /**
	     * Determines whether the object specified in the <code>toIntersect</code>
	     * parameter intersects with this Box object. This method checks the
	     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
	     * <code>height</code>, and <code>depth</code> properties of the specified
	     * Box object to see if it intersects with this Box object.
	     *
	     * @param toIntersect The Box object to compare against this Box object.
	     * @return A value of <code>true</code> if the specified object intersects
	     *         with this Box object; otherwise <code>false</code>.
	     */
	    Box.prototype.intersects = function (toIntersect) {
	        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height && this.z + this.depth > toIntersect.z && this.z < toIntersect.z + toIntersect.depth);
	    };
	    Box.prototype.rayIntersection = function (position, direction, targetNormal) {
	        if (this.containsPoint(position))
	            return 0;
	        var halfExtentsX = this.width / 2;
	        var halfExtentsY = this.height / 2;
	        var halfExtentsZ = this.depth / 2;
	        var centerX = this.x + halfExtentsX;
	        var centerY = this.y + halfExtentsY;
	        var centerZ = this.z + halfExtentsZ;
	        var px = position.x - centerX;
	        var py = position.y - centerY;
	        var pz = position.z - centerZ;
	        var vx = direction.x;
	        var vy = direction.y;
	        var vz = direction.z;
	        var ix;
	        var iy;
	        var iz;
	        var rayEntryDistance;
	        // ray-plane tests
	        var intersects;
	        if (vx < 0) {
	            rayEntryDistance = (halfExtentsX - px) / vx;
	            if (rayEntryDistance > 0) {
	                iy = py + rayEntryDistance * vy;
	                iz = pz + rayEntryDistance * vz;
	                if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = 1;
	                    targetNormal.y = 0;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vx > 0) {
	            rayEntryDistance = (-halfExtentsX - px) / vx;
	            if (rayEntryDistance > 0) {
	                iy = py + rayEntryDistance * vy;
	                iz = pz + rayEntryDistance * vz;
	                if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = -1;
	                    targetNormal.y = 0;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vy < 0) {
	            rayEntryDistance = (halfExtentsY - py) / vy;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iz = pz + rayEntryDistance * vz;
	                if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = 0;
	                    targetNormal.y = 1;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vy > 0) {
	            rayEntryDistance = (-halfExtentsY - py) / vy;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iz = pz + rayEntryDistance * vz;
	                if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
	                    targetNormal.x = 0;
	                    targetNormal.y = -1;
	                    targetNormal.z = 0;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vz < 0) {
	            rayEntryDistance = (halfExtentsZ - pz) / vz;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iy = py + rayEntryDistance * vy;
	                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
	                    targetNormal.x = 0;
	                    targetNormal.y = 0;
	                    targetNormal.z = 1;
	                    intersects = true;
	                }
	            }
	        }
	        if (!intersects && vz > 0) {
	            rayEntryDistance = (-halfExtentsZ - pz) / vz;
	            if (rayEntryDistance > 0) {
	                ix = px + rayEntryDistance * vx;
	                iy = py + rayEntryDistance * vy;
	                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
	                    targetNormal.x = 0;
	                    targetNormal.y = 0;
	                    targetNormal.z = -1;
	                    intersects = true;
	                }
	            }
	        }
	        return intersects ? rayEntryDistance : -1;
	    };
	    /**
	     * Finds the closest point on the Box to another given point. This can be used for maximum error calculations for content within a given Box.
	     *
	     * @param point The point for which to find the closest point on the Box
	     * @param target An optional Vector3D to store the result to prevent creating a new object.
	     * @return
	     */
	    Box.prototype.closestPointToPoint = function (point, target) {
	        if (target === void 0) { target = null; }
	        var p;
	        if (target == null)
	            target = new Vector3D_1.Vector3D();
	        p = point.x;
	        if (p < this.x)
	            p = this.x;
	        if (p > this.x + this.width)
	            p = this.x + this.width;
	        target.x = p;
	        p = point.y;
	        if (p < this.y + this.height)
	            p = this.y + this.height;
	        if (p > this.y)
	            p = this.y;
	        target.y = p;
	        p = point.z;
	        if (p < this.z)
	            p = this.z;
	        if (p > this.z + this.depth)
	            p = this.z + this.depth;
	        target.z = p;
	        return target;
	    };
	    /**
	     * Determines whether or not this Box object is empty.
	     *
	     * @return A value of <code>true</code> if the Box object's width, height or
	     *         depth is less than or equal to 0; otherwise <code>false</code>.
	     */
	    Box.prototype.isEmpty = function () {
	        return (this.x == 0 && this.y == 0 && this.z == 0 && this.width == 0 && this.height == 0 && this.depth == 0);
	    };
	    /**
	     * Adjusts the location of the Box object, as determined by its
	     * top-left-front corner, by the specified amounts.
	     *
	     * @param dx Moves the <i>x</i> value of the Box object by this amount.
	     * @param dy Moves the <i>y</i> value of the Box object by this amount.
	     * @param dz Moves the <i>z</i> value of the Box object by this amount.
	     */
	    Box.prototype.offset = function (dx, dy, dz) {
	        this.x += dx;
	        this.y += dy;
	        this.z += dz;
	    };
	    /**
	     * Adjusts the location of the Box object using a Vector3D object as a
	     * parameter. This method is similar to the <code>Box.offset()</code>
	     * method, except that it takes a Vector3D object as a parameter.
	     *
	     * @param position A Vector3D object to use to offset this Box object.
	     */
	    Box.prototype.offsetPosition = function (position) {
	        this.x += position.x;
	        this.y += position.y;
	        this.z += position.z;
	    };
	    /**
	     * Sets all of the Box object's properties to 0. A Box object is empty if its
	     * width, height or depth is less than or equal to 0.
	     *
	     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
	     * <code>z</code>, <code>width</code>, <code>height</code>, and
	     * <code>depth</code> properties to 0.</p>
	     *
	     */
	    Box.prototype.setEmpty = function () {
	        this.x = 0;
	        this.y = 0;
	        this.z = 0;
	        this.width = 0;
	        this.height = 0;
	        this.depth = 0;
	    };
	    Box.prototype.setBoundIdentity = function () {
	        this.x = Number.MAX_VALUE / 2;
	        this.y = Number.MAX_VALUE / 2;
	        this.z = Number.MAX_VALUE / 2;
	        this.width = -Number.MAX_VALUE;
	        this.height = -Number.MAX_VALUE;
	        this.depth = -Number.MAX_VALUE;
	    };
	    /**
	     * Sets the members of Box to the specified values
	     *
	     * @param xa      The <i>x</i> coordinate of the top-left-front corner of the
	     *                box.
	     * @param ya      The <i>y</i> coordinate of the top-left-front corner of the
	     *                box.
	     * @param yz      The <i>z</i> coordinate of the top-left-front corner of the
	     *                box.
	     * @param widtha  The width of the box, in pixels.
	     * @param heighta The height of the box, in pixels.
	     * @param deptha  The depth of the box, in pixels.
	     */
	    Box.prototype.setTo = function (xa, ya, za, widtha, heighta, deptha) {
	        this.x = xa;
	        this.y = ya;
	        this.z = za;
	        this.width = widtha;
	        this.height = heighta;
	        this.depth = deptha;
	    };
	    /**
	     * Builds and returns a string that lists the horizontal, vertical and
	     * longitudinal positions and the width, height and depth of the Box object.
	     *
	     * @return A string listing the value of each of the following properties of
	     *         the Box object: <code>x</code>, <code>y</code>, <code>z</code>,
	     *         <code>width</code>, <code>height</code>, and <code>depth</code>.
	     */
	    Box.prototype.toString = function () {
	        return "[Box] (x=" + this.x + ", y=" + this.y + ", z=" + this.z + ", width=" + this.width + ", height=" + this.height + ", depth=" + this.depth + ")";
	    };
	    /**
	     * Adds two boxes together to create a new Box object, by filling
	     * in the horizontal, vertical and longitudinal space between the two boxes.
	     *
	     * <p><b>Note:</b> The <code>union()</code> method ignores boxes with
	     * <code>0</code> as the height, width or depth value, such as: <code>var
	     * box2:Box = new Box(300,300,300,50,50,0);</code></p>
	     *
	     * @param toUnion A Box object to add to this Box object.
	     * @return A new Box object that is the union of the two boxes.
	     */
	    Box.prototype.union = function (toUnion, target) {
	        if (target === void 0) { target = null; }
	        var width;
	        var height;
	        var depth;
	        if (target == null)
	            target = new Box();
	        if (this.x < toUnion.x) {
	            width = toUnion.x - this.x + toUnion.width;
	            target.x = this.x;
	            target.width = (width < this.width) ? this.width : width;
	        }
	        else {
	            width = this.x - toUnion.x + this.width;
	            target.x = toUnion.x;
	            target.width = (width < toUnion.width) ? toUnion.width : width;
	        }
	        if (this.y < toUnion.y) {
	            height = toUnion.y - this.y + toUnion.height;
	            target.y = this.y;
	            target.height = (height < this.height) ? this.height : height;
	        }
	        else {
	            height = this.y - toUnion.y + this.height;
	            target.y = toUnion.y;
	            target.height = (height < toUnion.height) ? toUnion.height : height;
	        }
	        if (this.z < toUnion.z) {
	            depth = toUnion.z - this.z + toUnion.depth;
	            target.z = this.z;
	            target.depth = (depth < this.depth) ? this.depth : depth;
	        }
	        else {
	            depth = this.z - toUnion.z + this.depth;
	            target.z = toUnion.z;
	            target.depth = (depth < toUnion.depth) ? toUnion.depth : depth;
	        }
	        return target;
	    };
	    return Box;
	}());
	exports.Box = Box;


/***/ },
/* 34 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The Vector3D export class represents a point or a location in the three-dimensional
	 * space using the Cartesian coordinates x, y, and z. As in a two-dimensional
	 * space, the x property represents the horizontal axis and the y property
	 * represents the vertical axis. In three-dimensional space, the z property
	 * represents depth. The value of the x property increases as the object moves
	 * to the right. The value of the y property increases as the object moves
	 * down. The z property increases as the object moves farther from the point
	 * of view. Using perspective projection and scaling, the object is seen to be
	 * bigger when near and smaller when farther away from the screen. As in a
	 * right-handed three-dimensional coordinate system, the positive z-axis points
	 * away from the viewer and the value of the z property increases as the object
	 * moves away from the viewer's eye. The origin point (0,0,0) of the global
	 * space is the upper-left corner of the stage.
	 *
	 * <p>The Vector3D export class can also represent a direction, an arrow pointing from
	 * the origin of the coordinates, such as (0,0,0), to an endpoint; or a
	 * floating-point component of an RGB (Red, Green, Blue) color model.</p>
	 *
	 * <p>Quaternion notation introduces a fourth element, the w property, which
	 * provides additional orientation information. For example, the w property can
	 * define an angle of rotation of a Vector3D object. The combination of the
	 * angle of rotation and the coordinates x, y, and z can determine the display
	 * object's orientation. Here is a representation of Vector3D elements in
	 * matrix notation:</p>
	 */
	var Vector3D = (function () {
	    /**
	     * Creates an instance of a Vector3D object. If you do not specify a
	     * parameter for the constructor, a Vector3D object is created with
	     * the elements (0,0,0,0).
	     *
	     * @param x The first element, such as the x coordinate.
	     * @param y The second element, such as the y coordinate.
	     * @param z The third element, such as the z coordinate.
	     * @param w An optional element for additional data such as the angle
	     *          of rotation.
	     */
	    function Vector3D(x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 0; }
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    Object.defineProperty(Vector3D.prototype, "length", {
	        /**
	         * The length, magnitude, of the current Vector3D object from the
	         * origin (0,0,0) to the object's x, y, and z coordinates. The w
	         * property is ignored. A unit vector has a length or magnitude of
	         * one.
	         */
	        get: function () {
	            return Math.sqrt(this.lengthSquared);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vector3D.prototype, "lengthSquared", {
	        /**
	         * The square of the length of the current Vector3D object, calculated
	         * using the x, y, and z properties. The w property is ignored. Use the
	         * <code>lengthSquared()</code> method whenever possible instead of the
	         * slower <code>Math.sqrt()</code> method call of the
	         * <code>Vector3D.length()</code> method.
	         */
	        get: function () {
	            return this.x * this.x + this.y * this.y + this.z * this.z;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds the value of the x, y, and z elements of the current Vector3D
	     * object to the values of the x, y, and z elements of another Vector3D
	     * object. The <code>add()</code> method does not change the current
	     * Vector3D object. Instead, it returns a new Vector3D object with
	     * the new values.
	     *
	     * <p>The result of adding two vectors together is a resultant vector.
	     * One way to visualize the result is by drawing a vector from the
	     * origin or tail of the first vector to the end or head of the second
	     * vector. The resultant vector is the distance between the origin
	     * point of the first vector and the end point of the second vector.
	     * </p>
	     */
	    Vector3D.prototype.add = function (a) {
	        return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z, this.w + a.w);
	    };
	    /**
	     * Returns the angle in radians between two vectors. The returned angle
	     * is the smallest radian the first Vector3D object rotates until it
	     * aligns with the second Vector3D object.
	     *
	     * <p>The <code>angleBetween()</code> method is a static method. You
	     * can use it directly as a method of the Vector3D class.</p>
	     *
	     * <p>To convert a degree to a radian, you can use the following
	     * formula:</p>
	     *
	     * <p><code>radian = Math.PI/180 * degree</code></p>
	     *
	     * @param a The first Vector3D object.
	     * @param b The second Vector3D object.
	     * @returns The angle between two Vector3D objects.
	     */
	    Vector3D.angleBetween = function (a, b) {
	        return Math.acos(a.dotProduct(b) / (a.length * b.length));
	    };
	    /**
	     * Returns a new Vector3D object that is an exact copy of the current
	     * Vector3D object.
	     *
	     * @returns A new Vector3D object that is a copy of the current
	     * Vector3D object.
	     */
	    Vector3D.prototype.clone = function () {
	        return new Vector3D(this.x, this.y, this.z, this.w);
	    };
	    Vector3D.combine = function (a, b, ascl, bscl) {
	        return new Vector3D(a.x * ascl + b.x * bscl, a.y * ascl + b.y * bscl, a.z * ascl + b.z * bscl);
	    };
	    /**
	     * Copies all of vector data from the source Vector3D object into the
	     * calling Vector3D object.
	     *
	     * @param src The Vector3D object from which to copy the data.
	     */
	    Vector3D.prototype.copyFrom = function (src) {
	        this.x = src.x;
	        this.y = src.y;
	        this.z = src.z;
	        this.w = src.w;
	    };
	    /**
	     * Returns a new Vector3D object that is perpendicular (at a right
	     * angle) to the current Vector3D and another Vector3D object. If the
	     * returned Vector3D object's coordinates are (0,0,0), then the two
	     * Vector3D objects are parallel to each other.
	     *
	     * <p>You can use the normalized cross product of two vertices of a
	     * polygon surface with the normalized vector of the camera or eye
	     * viewpoint to get a dot product. The value of the dot product can
	     * identify whether a surface of a three-dimensional object is hidden
	     * from the viewpoint.</p>
	     *
	     * @param a A second Vector3D object.
	     * @returns A new Vector3D object that is perpendicular to the current
	     *          Vector3D object and the Vector3D object specified as the
	     *          parameter.
	     */
	    Vector3D.prototype.crossProduct = function (a, t) {
	        if (t === void 0) { t = null; }
	        if (t == null)
	            t = new Vector3D();
	        t.x = this.y * a.z - this.z * a.y;
	        t.y = this.z * a.x - this.x * a.z;
	        t.z = this.x * a.y - this.y * a.x;
	        return t;
	    };
	    /**
	     * Decrements the value of the x, y, and z elements of the current
	     * Vector3D object by the values of the x, y, and z elements of
	     * specified Vector3D object. Unlike the
	     * <code>Vector3D.subtract()</code> method, the
	     * <code>decrementBy()</code> method changes the current Vector3D
	     * object and does not return a new Vector3D object.
	     *
	     * @param a The Vector3D object containing the values to subtract from
	     *          the current Vector3D object.
	     */
	    Vector3D.prototype.decrementBy = function (a) {
	        this.x -= a.x;
	        this.y -= a.y;
	        this.z -= a.z;
	    };
	    /**
	     * Returns the distance between two Vector3D objects. The
	     * <code>distance()</code> method is a static method. You can use it
	     * directly as a method of the Vector3D export class to get the Euclidean
	     * distance between two three-dimensional points.
	     *
	     * @param pt1 A Vector3D object as the first three-dimensional point.
	     * @param pt2 A Vector3D object as the second three-dimensional point.
	     * @returns The distance between two Vector3D objects.
	     */
	    Vector3D.distance = function (pt1, pt2) {
	        var x = (pt1.x - pt2.x);
	        var y = (pt1.y - pt2.y);
	        var z = (pt1.z - pt2.z);
	        return Math.sqrt(x * x + y * y + z * z);
	    };
	    /**
	     * If the current Vector3D object and the one specified as the
	     * parameter are unit vertices, this method returns the cosine of the
	     * angle between the two vertices. Unit vertices are vertices that
	     * point to the same direction but their length is one. They remove the
	     * length of the vector as a factor in the result. You can use the
	     * <code>normalize()</code> method to convert a vector to a unit
	     * vector.
	     *
	     * <p>The <code>dotProduct()</code> method finds the angle between two
	     * vertices. It is also used in backface culling or lighting
	     * calculations. Backface culling is a procedure for determining which
	     * surfaces are hidden from the viewpoint. You can use the normalized
	     * vertices from the camera, or eye, viewpoint and the cross product of
	     * the vertices of a polygon surface to get the dot product. If the dot
	     * product is less than zero, then the surface is facing the camera or
	     * the viewer. If the two unit vertices are perpendicular to each
	     * other, they are orthogonal and the dot product is zero. If the two
	     * vertices are parallel to each other, the dot product is one.</p>
	     *
	     * @param a The second Vector3D object.
	     * @returns A scalar which is the dot product of the current Vector3D
	     *          object and the specified Vector3D object.
	     *
	     * @see away.geom.Vector3D#crossProduct()
	     * @see away.geom.Vector3D#normalize()
	     */
	    Vector3D.prototype.dotProduct = function (a) {
	        return this.x * a.x + this.y * a.y + this.z * a.z;
	    };
	    /**
	     * Determines whether two Vector3D objects are equal by comparing the
	     * x, y, and z elements of the current Vector3D object with a
	     * specified Vector3D object. If the values of these elements are the
	     * same, the two Vector3D objects are equal. If the second optional
	     * parameter is set to true, all four elements of the Vector3D objects,
	     * including the w property, are compared.
	     */
	    /**
	     *
	     * @param toCompare The Vector3D object to be compared with the current
	     *                  Vector3D object.
	     * @param allFour   An optional parameter that specifies whether the w
	     *                  property of the Vector3D objects is used in the
	     *                  comparison.
	     * @returns A value of true if the specified Vector3D object is equal
	     *          to the current Vector3D object; false if it is not equal.
	     */
	    Vector3D.prototype.equals = function (toCompare, allFour) {
	        if (allFour === void 0) { allFour = false; }
	        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
	    };
	    /**
	     * Increments the value of the x, y, and z elements of the current
	     * Vector3D object by the values of the x, y, and z elements of a
	     * specified Vector3D object. Unlike the <code>Vector3D.add()</code>
	     * method, the <code>incrementBy()</code> method changes the current
	     * Vector3D object and does not return a new Vector3D object.
	     *
	     * @param a The Vector3D object to be added to the current Vector3D
	     *          object.
	     */
	    Vector3D.prototype.incrementBy = function (a) {
	        this.x += a.x;
	        this.y += a.y;
	        this.z += a.z;
	    };
	    /**
	     * Compares the elements of the current Vector3D object with the
	     * elements of a specified Vector3D object to determine whether they
	     * are nearly equal. The two Vector3D objects are nearly equal if the
	     * value of all the elements of the two vertices are equal, or the
	     * result of the comparison is within the tolerance range. The
	     * difference between two elements must be less than the number
	     * specified as the tolerance parameter. If the third optional
	     * parameter is set to <code>true</code>, all four elements of the
	     * Vector3D objects, including the <code>w</code> property, are
	     * compared. Otherwise, only the x, y, and z elements are included in
	     * the comparison.
	     */
	    /**
	     *
	     * @param toCompare The Vector3D object to be compared with the current
	     *                  Vector3D object.
	     * @param tolerance A number determining the tolerance factor. If the
	     *                  difference between the values of the Vector3D
	     *                  element specified in the toCompare parameter and
	     *                  the current Vector3D element is less than the
	     *                  tolerance number, the two values are considered
	     *                  nearly equal.
	     * @param allFour   An optional parameter that specifies whether the w
	     *                  property of the Vector3D objects is used in the
	     *                  comparison.
	     * @returns A value of true if the specified Vector3D object is nearly
	     *          equal to the current Vector3D object; false if it is not
	     *          equal.
	     *
	     * @see away.geom.Vector3D#equals()
	     */
	    Vector3D.prototype.nearEquals = function (toCompare, tolerance, allFour) {
	        if (allFour === void 0) { allFour = true; }
	        return ((Math.abs(this.x - toCompare.x) < tolerance) && (Math.abs(this.y - toCompare.y) < tolerance) && (Math.abs(this.z - toCompare.z) < tolerance) && (!allFour || Math.abs(this.w - toCompare.w) < tolerance));
	    };
	    /**
	     * Sets the current Vector3D object to its inverse. The inverse object
	     * is also considered the opposite of the original object. The value of
	     * the x, y, and z properties of the current Vector3D object is changed
	     * to -x, -y, and -z.
	     */
	    Vector3D.prototype.negate = function () {
	        this.x = -this.x;
	        this.y = -this.y;
	        this.z = -this.z;
	    };
	    /**
	     * Converts a Vector3D object to a unit vector by dividing the first
	     * three elements (x, y, z) by the length of the vector. Unit vertices
	     * are vertices that have a direction but their length is one. They
	     * simplify vector calculations by removing length as a factor.
	     */
	    /**
	     * Scales the line segment between(0,0) and the current point to a set
	     * length.
	     *
	     * @param thickness The scaling value. For example, if the current
	     *                  Vector3D object is (0,3,4), and you normalize it to
	     *                  1, the point returned is at(0,0.6,0.8).
	     */
	    Vector3D.prototype.normalize = function (thickness) {
	        if (thickness === void 0) { thickness = 1; }
	        if (this.length != 0) {
	            var invLength = thickness / this.length;
	            this.x *= invLength;
	            this.y *= invLength;
	            this.z *= invLength;
	            return;
	        }
	    };
	    /**
	     * Divides the value of the <code>x</code>, <code>y</code>, and
	     * <code>z</code> properties of the current Vector3D object by the
	     * value of its <code>w</code> property.
	     *
	     * <p>If the current Vector3D object is the result of multiplying a
	     * Vector3D object by a projection Matrix3D object, the w property can
	     * hold the transform value. The <code>project()</code> method then can
	     * complete the projection by dividing the elements by the
	     * <code>w</code> property. Use the <code>Matrix3D.rawData</code>
	     * property to create a projection Matrix3D object.</p>
	     */
	    Vector3D.prototype.project = function () {
	        this.x /= this.w;
	        this.y /= this.w;
	        this.z /= this.w;
	    };
	    /**
	     * Scales the current Vector3D object by a scalar, a magnitude. The
	     * Vector3D object's x, y, and z elements are multiplied by the scalar
	     * number specified in the parameter. For example, if the vector is
	     * scaled by ten, the result is a vector that is ten times longer. The
	     * scalar can also change the direction of the vector. Multiplying the
	     * vector by a negative number reverses its direction.
	     *
	     * @param s A multiplier (scalar) used to scale a Vector3D object.
	
	     */
	    Vector3D.prototype.scaleBy = function (s) {
	        this.x *= s;
	        this.y *= s;
	        this.z *= s;
	    };
	    /**
	     * Sets the members of Vector3D to the specified values
	     *
	     * @param xa The first element, such as the x coordinate.
	     * @param ya The second element, such as the y coordinate.
	     * @param za The third element, such as the z coordinate.
	     */
	    Vector3D.prototype.setTo = function (xa, ya, za) {
	        this.x = xa;
	        this.y = ya;
	        this.z = za;
	    };
	    /**
	     * Subtracts the value of the x, y, and z elements of the current
	     * Vector3D object from the values of the x, y, and z elements of
	     * another Vector3D object. The <code>subtract()</code> method does not
	     * change the current Vector3D object. Instead, this method returns a
	     * new Vector3D object with the new values.
	     *
	     * @param a The Vector3D object to be subtracted from the current
	     *          Vector3D object.
	     * @returns A new Vector3D object that is the difference between the
	     *          current Vector3D and the specified Vector3D object.
	     *
	     * @see away.geom.Vector3D#decrementBy()
	     */
	    Vector3D.prototype.subtract = function (a) {
	        return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
	    };
	    /**
	     * Returns a string representation of the current Vector3D object. The
	     * string contains the values of the x, y, and z properties.
	     */
	    Vector3D.prototype.toString = function () {
	        return "[Vector3D] (x:" + this.x + " ,y:" + this.y + ", z" + this.z + ", w:" + this.w + ")";
	    };
	    /**
	     * The x axis defined as a Vector3D object with coordinates (1,0,0).
	     */
	    Vector3D.X_AXIS = new Vector3D(1, 0, 0);
	    /**
	     * The y axis defined as a Vector3D object with coordinates (0,1,0).
	     */
	    Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
	    /**
	     * The z axis defined as a Vector3D object with coordinates (0,0,1).
	     */
	    Vector3D.Z_AXIS = new Vector3D(0, 0, 1);
	    return Vector3D;
	}());
	exports.Vector3D = Vector3D;


/***/ },
/* 35 */
/***/ function(module, exports) {

	"use strict";
	/**
	* MathConsts provides some commonly used mathematical constants
	*/
	var MathConsts = (function () {
	    function MathConsts() {
	    }
	    /**
	     * The amount to multiply with when converting radians to degrees.
	     */
	    MathConsts.RADIANS_TO_DEGREES = 180 / Math.PI;
	    /**
	     * The amount to multiply with when converting degrees to radians.
	     */
	    MathConsts.DEGREES_TO_RADIANS = Math.PI / 180;
	    return MathConsts;
	}());
	exports.MathConsts = MathConsts;


/***/ },
/* 36 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A Quaternion object which can be used to represent rotations.
	 */
	var Orientation3D = (function () {
	    function Orientation3D() {
	    }
	    /**
	     * The axis angle orientation uses a combination of an axis and an angle to determine the orientation.
	     * @type {string}
	     */
	    Orientation3D.AXIS_ANGLE = "axisAngle";
	    /**
	     * The default orientation for decompose() and recompose() methods, defines the orientation with three separate angles of rotation for each axis.
	     * @type {string}
	     */
	    Orientation3D.EULER_ANGLES = "eulerAngles";
	    /**
	     * The quaternion orientation uses complex numbers.
	     * @type {string}
	     */
	    Orientation3D.QUATERNION = "quaternion";
	    return Orientation3D;
	}());
	exports.Orientation3D = Orientation3D;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	/**
	 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
	 * by a concrete subclass.
	 */
	var ArgumentError = (function (_super) {
	    __extends(ArgumentError, _super);
	    /**
	     * Create a new ArgumentError.
	     *
	     * @param message An optional message to override the default error message.
	     * @param id The id of the error.
	     */
	    function ArgumentError(message, id) {
	        if (message === void 0) { message = null; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, message || "ArgumentError", id);
	    }
	    return ArgumentError;
	}(ErrorBase_1.ErrorBase));
	exports.ArgumentError = ArgumentError;


/***/ },
/* 38 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Matrix3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(34);
	/**
	 * away.geom.Matrix3DUtils provides additional Matrix3D functions.
	 */
	var Matrix3DUtils = (function () {
	    function Matrix3DUtils() {
	    }
	    /**
	     * Fills the 3d matrix object with values representing the transformation made by the given quaternion.
	     *
	     * @param    quarternion    The quarterion object to convert.
	     */
	    Matrix3DUtils.quaternion2matrix = function (quarternion, m) {
	        if (m === void 0) { m = null; }
	        var x = quarternion.x;
	        var y = quarternion.y;
	        var z = quarternion.z;
	        var w = quarternion.w;
	        var xx = x * x;
	        var xy = x * y;
	        var xz = x * z;
	        var xw = x * w;
	        var yy = y * y;
	        var yz = y * z;
	        var yw = y * w;
	        var zz = z * z;
	        var zw = z * w;
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        raw[0] = 1 - 2 * (yy + zz);
	        raw[1] = 2 * (xy + zw);
	        raw[2] = 2 * (xz - yw);
	        raw[4] = 2 * (xy - zw);
	        raw[5] = 1 - 2 * (xx + zz);
	        raw[6] = 2 * (yz + xw);
	        raw[8] = 2 * (xz + yw);
	        raw[9] = 2 * (yz - xw);
	        raw[10] = 1 - 2 * (xx + yy);
	        raw[3] = raw[7] = raw[11] = raw[12] = raw[13] = raw[14] = 0;
	        raw[15] = 1;
	        if (m) {
	            m.copyRawDataFrom(raw);
	            return m;
	        }
	        else
	            return new Matrix3D_1.Matrix3D(raw);
	    };
	    /**
	     * Returns a normalised <code>Vector3D</code> object representing the forward vector of the given matrix.
	     * @param    m        The Matrix3D object to use to get the forward vector
	     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
	     * @return            The forward vector
	     */
	    Matrix3DUtils.getForward = function (m, v) {
	        if (v === void 0) { v = null; }
	        if (v === null)
	            v = new Vector3D_1.Vector3D(0.0, 0.0, 0.0);
	        m.copyColumnTo(2, v);
	        v.normalize();
	        return v;
	    };
	    /**
	     * Returns a normalised <code>Vector3D</code> object representing the up vector of the given matrix.
	     * @param    m        The Matrix3D object to use to get the up vector
	     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
	     * @return            The up vector
	     */
	    Matrix3DUtils.getUp = function (m, v) {
	        if (v === void 0) { v = null; }
	        if (v === null)
	            v = new Vector3D_1.Vector3D(0.0, 0.0, 0.0);
	        m.copyColumnTo(1, v);
	        v.normalize();
	        return v;
	    };
	    /**
	     * Returns a normalised <code>Vector3D</code> object representing the right vector of the given matrix.
	     * @param    m        The Matrix3D object to use to get the right vector
	     * @param    v        [optional] A vector holder to prevent make new Vector3D instance if already exists. Default is null.
	     * @return            The right vector
	     */
	    Matrix3DUtils.getRight = function (m, v) {
	        if (v === void 0) { v = null; }
	        //v ||= new Vector3D(0.0, 0.0, 0.0);
	        if (v === null) {
	            v = new Vector3D_1.Vector3D(0.0, 0.0, 0.0);
	        }
	        m.copyColumnTo(0, v);
	        v.normalize();
	        return v;
	    };
	    /**
	     * Returns a boolean value representing whether there is any significant difference between the two given 3d matrices.
	     */
	    Matrix3DUtils.compare = function (m1, m2) {
	        var r1 = Matrix3DUtils.RAW_DATA_CONTAINER;
	        var r2 = m2.rawData;
	        m1.copyRawDataTo(r1);
	        for (var i = 0; i < 16; ++i) {
	            if (r1[i] != r2[i])
	                return false;
	        }
	        return true;
	    };
	    Matrix3DUtils.lookAt = function (matrix, pos, dir, up) {
	        var dirN;
	        var upN;
	        var lftN;
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        lftN = dir.crossProduct(up);
	        lftN.normalize();
	        upN = lftN.crossProduct(dir);
	        upN.normalize();
	        dirN = dir.clone();
	        dirN.normalize();
	        raw[0] = lftN.x;
	        raw[1] = upN.x;
	        raw[2] = -dirN.x;
	        raw[3] = 0.0;
	        raw[4] = lftN.y;
	        raw[5] = upN.y;
	        raw[6] = -dirN.y;
	        raw[7] = 0.0;
	        raw[8] = lftN.z;
	        raw[9] = upN.z;
	        raw[10] = -dirN.z;
	        raw[11] = 0.0;
	        raw[12] = -lftN.dotProduct(pos);
	        raw[13] = -upN.dotProduct(pos);
	        raw[14] = dirN.dotProduct(pos);
	        raw[15] = 1.0;
	        matrix.copyRawDataFrom(raw);
	    };
	    Matrix3DUtils.reflection = function (plane, target) {
	        if (target === void 0) { target = null; }
	        if (target === null)
	            target = new Matrix3D_1.Matrix3D();
	        var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
	        var rawData = Matrix3DUtils.RAW_DATA_CONTAINER;
	        var ab2 = -2 * a * b;
	        var ac2 = -2 * a * c;
	        var bc2 = -2 * b * c;
	        // reflection matrix
	        rawData[0] = 1 - 2 * a * a;
	        rawData[4] = ab2;
	        rawData[8] = ac2;
	        rawData[12] = -2 * a * d;
	        rawData[1] = ab2;
	        rawData[5] = 1 - 2 * b * b;
	        rawData[9] = bc2;
	        rawData[13] = -2 * b * d;
	        rawData[2] = ac2;
	        rawData[6] = bc2;
	        rawData[10] = 1 - 2 * c * c;
	        rawData[14] = -2 * c * d;
	        rawData[3] = 0;
	        rawData[7] = 0;
	        rawData[11] = 0;
	        rawData[15] = 1;
	        target.copyRawDataFrom(rawData);
	        return target;
	    };
	    Matrix3DUtils.transformVector = function (matrix, vector, result) {
	        if (result === void 0) { result = null; }
	        if (!result)
	            result = new Vector3D_1.Vector3D();
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        matrix.copyRawDataTo(raw);
	        var a = raw[0];
	        var e = raw[1];
	        var i = raw[2];
	        var m = raw[3];
	        var b = raw[4];
	        var f = raw[5];
	        var j = raw[6];
	        var n = raw[7];
	        var c = raw[8];
	        var g = raw[9];
	        var k = raw[10];
	        var o = raw[11];
	        var d = raw[12];
	        var h = raw[13];
	        var l = raw[14];
	        var p = raw[15];
	        var x = vector.x;
	        var y = vector.y;
	        var z = vector.z;
	        result.x = a * x + b * y + c * z + d;
	        result.y = e * x + f * y + g * z + h;
	        result.z = i * x + j * y + k * z + l;
	        result.w = m * x + n * y + o * z + p;
	        return result;
	    };
	    Matrix3DUtils.deltaTransformVector = function (matrix, vector, result) {
	        if (result === void 0) { result = null; }
	        if (!result)
	            result = new Vector3D_1.Vector3D();
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        matrix.copyRawDataTo(raw);
	        var a = raw[0];
	        var e = raw[1];
	        var i = raw[2];
	        var m = raw[3];
	        var b = raw[4];
	        var f = raw[5];
	        var j = raw[6];
	        var n = raw[7];
	        var c = raw[8];
	        var g = raw[9];
	        var k = raw[10];
	        var o = raw[11];
	        var x = vector.x;
	        var y = vector.y;
	        var z = vector.z;
	        result.x = a * x + b * y + c * z;
	        result.y = e * x + f * y + g * z;
	        result.z = i * x + j * y + k * z;
	        result.w = m * x + n * y + o * z;
	        return result;
	    };
	    Matrix3DUtils.getTranslation = function (transform, result) {
	        if (result === void 0) { result = null; }
	        if (!result)
	            result = new Vector3D_1.Vector3D();
	        transform.copyColumnTo(3, result);
	        return result;
	    };
	    Matrix3DUtils.deltaTransformVectors = function (matrix, vin, vout) {
	        var raw = Matrix3DUtils.RAW_DATA_CONTAINER;
	        matrix.copyRawDataTo(raw);
	        var a = raw[0];
	        var e = raw[1];
	        var i = raw[2];
	        var m = raw[3];
	        var b = raw[4];
	        var f = raw[5];
	        var j = raw[6];
	        var n = raw[7];
	        var c = raw[8];
	        var g = raw[9];
	        var k = raw[10];
	        var o = raw[11];
	        var outIndex = 0;
	        var length = vin.length;
	        for (var index = 0; index < length; index += 3) {
	            var x = vin[index];
	            var y = vin[index + 1];
	            var z = vin[index + 2];
	            vout[outIndex++] = a * x + b * y + c * z;
	            vout[outIndex++] = e * x + f * y + g * z;
	            vout[outIndex++] = i * x + j * y + k * z;
	        }
	    };
	    /**
	     * A reference to a Vector to be used as a temporary raw data container, to prevent object creation.
	     */
	    Matrix3DUtils.RAW_DATA_CONTAINER = new Float32Array(16);
	    //public static RAW_DATA_CONTAINER:number[] = new Array<number>(16);
	    Matrix3DUtils.CALCULATION_MATRIX = new Matrix3D_1.Matrix3D();
	    return Matrix3DUtils;
	}());
	exports.Matrix3DUtils = Matrix3DUtils;


/***/ },
/* 39 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var TransformEvent = (function (_super) {
	    __extends(TransformEvent, _super);
	    function TransformEvent(type, transform) {
	        _super.call(this, type);
	        this._transform = transform;
	    }
	    Object.defineProperty(TransformEvent.prototype, "transform", {
	        get: function () {
	            return this._transform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    TransformEvent.prototype.clone = function () {
	        return new TransformEvent(this.type, this._transform);
	    };
	    /**
	     *
	     */
	    TransformEvent.INVALIDATE_MATRIX3D = "invalidateMatrix3D";
	    /**
	     *
	     */
	    TransformEvent.INVALIDATE_COLOR_TRANSFORM = "invalidateColorTransform";
	    return TransformEvent;
	}(EventBase_1.EventBase));
	exports.TransformEvent = TransformEvent;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ContextGLBlendFactor_1 = __webpack_require__(41);
	exports.ContextGLBlendFactor = ContextGLBlendFactor_1.ContextGLBlendFactor;
	var ContextGLClearMask_1 = __webpack_require__(42);
	exports.ContextGLClearMask = ContextGLClearMask_1.ContextGLClearMask;
	var ContextGLCompareMode_1 = __webpack_require__(43);
	exports.ContextGLCompareMode = ContextGLCompareMode_1.ContextGLCompareMode;
	var ContextGLDrawMode_1 = __webpack_require__(44);
	exports.ContextGLDrawMode = ContextGLDrawMode_1.ContextGLDrawMode;
	var ContextGLMipFilter_1 = __webpack_require__(45);
	exports.ContextGLMipFilter = ContextGLMipFilter_1.ContextGLMipFilter;
	var ContextGLProfile_1 = __webpack_require__(46);
	exports.ContextGLProfile = ContextGLProfile_1.ContextGLProfile;
	var ContextGLProgramType_1 = __webpack_require__(47);
	exports.ContextGLProgramType = ContextGLProgramType_1.ContextGLProgramType;
	var ContextGLStencilAction_1 = __webpack_require__(48);
	exports.ContextGLStencilAction = ContextGLStencilAction_1.ContextGLStencilAction;
	var ContextGLTextureFilter_1 = __webpack_require__(49);
	exports.ContextGLTextureFilter = ContextGLTextureFilter_1.ContextGLTextureFilter;
	var ContextGLTextureFormat_1 = __webpack_require__(50);
	exports.ContextGLTextureFormat = ContextGLTextureFormat_1.ContextGLTextureFormat;
	var ContextGLTriangleFace_1 = __webpack_require__(51);
	exports.ContextGLTriangleFace = ContextGLTriangleFace_1.ContextGLTriangleFace;
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	exports.ContextGLVertexBufferFormat = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat;
	var ContextGLWrapMode_1 = __webpack_require__(53);
	exports.ContextGLWrapMode = ContextGLWrapMode_1.ContextGLWrapMode;
	var ContextMode_1 = __webpack_require__(54);
	exports.ContextMode = ContextMode_1.ContextMode;
	var SamplerState_1 = __webpack_require__(55);
	exports.SamplerState = SamplerState_1.SamplerState;
	var Stage_1 = __webpack_require__(56);
	exports.Stage = Stage_1.Stage;


/***/ },
/* 41 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLBlendFactor = (function () {
	    function ContextGLBlendFactor() {
	    }
	    ContextGLBlendFactor.DESTINATION_ALPHA = "destinationAlpha";
	    ContextGLBlendFactor.DESTINATION_COLOR = "destinationColor";
	    ContextGLBlendFactor.ONE = "one";
	    ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA = "oneMinusDestinationAlpha";
	    ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR = "oneMinusDestinationColor";
	    ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA = "oneMinusSourceAlpha";
	    ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR = "oneMinusSourceColor";
	    ContextGLBlendFactor.SOURCE_ALPHA = "sourceAlpha";
	    ContextGLBlendFactor.SOURCE_COLOR = "sourceColor";
	    ContextGLBlendFactor.ZERO = "zero";
	    return ContextGLBlendFactor;
	}());
	exports.ContextGLBlendFactor = ContextGLBlendFactor;


/***/ },
/* 42 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLClearMask = (function () {
	    function ContextGLClearMask() {
	    }
	    ContextGLClearMask.COLOR = 1;
	    ContextGLClearMask.DEPTH = 2;
	    ContextGLClearMask.STENCIL = 4;
	    ContextGLClearMask.ALL = ContextGLClearMask.COLOR | ContextGLClearMask.DEPTH | ContextGLClearMask.STENCIL;
	    return ContextGLClearMask;
	}());
	exports.ContextGLClearMask = ContextGLClearMask;


/***/ },
/* 43 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLCompareMode = (function () {
	    function ContextGLCompareMode() {
	    }
	    ContextGLCompareMode.ALWAYS = "always";
	    ContextGLCompareMode.EQUAL = "equal";
	    ContextGLCompareMode.GREATER = "greater";
	    ContextGLCompareMode.GREATER_EQUAL = "greaterEqual";
	    ContextGLCompareMode.LESS = "less";
	    ContextGLCompareMode.LESS_EQUAL = "lessEqual";
	    ContextGLCompareMode.NEVER = "never";
	    ContextGLCompareMode.NOT_EQUAL = "notEqual";
	    return ContextGLCompareMode;
	}());
	exports.ContextGLCompareMode = ContextGLCompareMode;


/***/ },
/* 44 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLDrawMode = (function () {
	    function ContextGLDrawMode() {
	    }
	    ContextGLDrawMode.TRIANGLES = "triangles";
	    ContextGLDrawMode.LINES = "lines";
	    return ContextGLDrawMode;
	}());
	exports.ContextGLDrawMode = ContextGLDrawMode;


/***/ },
/* 45 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLMipFilter = (function () {
	    function ContextGLMipFilter() {
	    }
	    ContextGLMipFilter.MIPLINEAR = "miplinear";
	    ContextGLMipFilter.MIPNEAREST = "mipnearest";
	    ContextGLMipFilter.MIPNONE = "mipnone";
	    return ContextGLMipFilter;
	}());
	exports.ContextGLMipFilter = ContextGLMipFilter;


/***/ },
/* 46 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLProfile = (function () {
	    function ContextGLProfile() {
	    }
	    ContextGLProfile.BASELINE = "baseline";
	    ContextGLProfile.BASELINE_CONSTRAINED = "baselineConstrained";
	    ContextGLProfile.BASELINE_EXTENDED = "baselineExtended";
	    return ContextGLProfile;
	}());
	exports.ContextGLProfile = ContextGLProfile;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ContextGLProfile;


/***/ },
/* 47 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLProgramType = (function () {
	    function ContextGLProgramType() {
	    }
	    ContextGLProgramType.FRAGMENT = 0;
	    ContextGLProgramType.SAMPLER = 1;
	    ContextGLProgramType.VERTEX = 2;
	    return ContextGLProgramType;
	}());
	exports.ContextGLProgramType = ContextGLProgramType;


/***/ },
/* 48 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLStencilAction = (function () {
	    function ContextGLStencilAction() {
	    }
	    ContextGLStencilAction.DECREMENT_SATURATE = "decrementSaturate";
	    ContextGLStencilAction.DECREMENT_WRAP = "decrementWrap";
	    ContextGLStencilAction.INCREMENT_SATURATE = "incrementSaturate";
	    ContextGLStencilAction.INCREMENT_WRAP = "incrementWrap";
	    ContextGLStencilAction.INVERT = "invert";
	    ContextGLStencilAction.KEEP = "keep";
	    ContextGLStencilAction.SET = "set";
	    ContextGLStencilAction.ZERO = "zero";
	    return ContextGLStencilAction;
	}());
	exports.ContextGLStencilAction = ContextGLStencilAction;


/***/ },
/* 49 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLTextureFilter = (function () {
	    function ContextGLTextureFilter() {
	    }
	    ContextGLTextureFilter.LINEAR = "linear";
	    ContextGLTextureFilter.NEAREST = "nearest";
	    return ContextGLTextureFilter;
	}());
	exports.ContextGLTextureFilter = ContextGLTextureFilter;


/***/ },
/* 50 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLTextureFormat = (function () {
	    function ContextGLTextureFormat() {
	    }
	    ContextGLTextureFormat.BGRA = "bgra";
	    ContextGLTextureFormat.BGRA_PACKED = "bgraPacked4444";
	    ContextGLTextureFormat.BGR_PACKED = "bgrPacked565";
	    ContextGLTextureFormat.COMPRESSED = "compressed";
	    ContextGLTextureFormat.COMPRESSED_ALPHA = "compressedAlpha";
	    return ContextGLTextureFormat;
	}());
	exports.ContextGLTextureFormat = ContextGLTextureFormat;


/***/ },
/* 51 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLTriangleFace = (function () {
	    function ContextGLTriangleFace() {
	    }
	    ContextGLTriangleFace.BACK = "back";
	    ContextGLTriangleFace.FRONT = "front";
	    ContextGLTriangleFace.FRONT_AND_BACK = "frontAndBack";
	    ContextGLTriangleFace.NONE = "none";
	    return ContextGLTriangleFace;
	}());
	exports.ContextGLTriangleFace = ContextGLTriangleFace;


/***/ },
/* 52 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLVertexBufferFormat = (function () {
	    function ContextGLVertexBufferFormat() {
	    }
	    ContextGLVertexBufferFormat.FLOAT_1 = 0;
	    ContextGLVertexBufferFormat.FLOAT_2 = 1;
	    ContextGLVertexBufferFormat.FLOAT_3 = 2;
	    ContextGLVertexBufferFormat.FLOAT_4 = 3;
	    ContextGLVertexBufferFormat.BYTE_1 = 4;
	    ContextGLVertexBufferFormat.BYTE_2 = 5;
	    ContextGLVertexBufferFormat.BYTE_3 = 6;
	    ContextGLVertexBufferFormat.BYTE_4 = 7;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_1 = 8;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_2 = 9;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_3 = 10;
	    ContextGLVertexBufferFormat.UNSIGNED_BYTE_4 = 11;
	    ContextGLVertexBufferFormat.SHORT_1 = 12;
	    ContextGLVertexBufferFormat.SHORT_2 = 13;
	    ContextGLVertexBufferFormat.SHORT_3 = 14;
	    ContextGLVertexBufferFormat.SHORT_4 = 15;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_1 = 16;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_2 = 17;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_3 = 18;
	    ContextGLVertexBufferFormat.UNSIGNED_SHORT_4 = 19;
	    return ContextGLVertexBufferFormat;
	}());
	exports.ContextGLVertexBufferFormat = ContextGLVertexBufferFormat;


/***/ },
/* 53 */
/***/ function(module, exports) {

	"use strict";
	var ContextGLWrapMode = (function () {
	    function ContextGLWrapMode() {
	    }
	    ContextGLWrapMode.CLAMP = "clamp";
	    ContextGLWrapMode.REPEAT = "repeat";
	    return ContextGLWrapMode;
	}());
	exports.ContextGLWrapMode = ContextGLWrapMode;


/***/ },
/* 54 */
/***/ function(module, exports) {

	"use strict";
	var ContextMode = (function () {
	    function ContextMode() {
	    }
	    ContextMode.AUTO = "auto";
	    ContextMode.WEBGL = "webgl";
	    ContextMode.FLASH = "flash";
	    ContextMode.GLES = "gles";
	    ContextMode.NATIVE = "native";
	    ContextMode.SOFTWARE = "software";
	    return ContextMode;
	}());
	exports.ContextMode = ContextMode;


/***/ },
/* 55 */
/***/ function(module, exports) {

	"use strict";
	var SamplerState = (function () {
	    function SamplerState() {
	    }
	    return SamplerState;
	}());
	exports.SamplerState = SamplerState;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(11);
	var Rectangle_1 = __webpack_require__(57);
	var CSS_1 = __webpack_require__(59);
	var ContextMode_1 = __webpack_require__(54);
	var ContextGLMipFilter_1 = __webpack_require__(45);
	var ContextGLTextureFilter_1 = __webpack_require__(49);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ContextGLWrapMode_1 = __webpack_require__(53);
	var StageEvent_1 = __webpack_require__(60);
	var ProgramDataPool_1 = __webpack_require__(61);
	var ContextGLES_1 = __webpack_require__(63);
	var ContextWebGL_1 = __webpack_require__(78);
	var ContextFlash_1 = __webpack_require__(85);
	var ContextSoftware_1 = __webpack_require__(94);
	/**
	 * Stage provides a proxy class to handle the creation and attachment of the Context
	 * (and in turn the back buffer) it uses. Stage should never be created directly,
	 * but requested through StageManager.
	 *
	 * @see away.managers.StageManager
	 *
	 */
	var Stage = (function (_super) {
	    __extends(Stage, _super);
	    function Stage(container, stageIndex, stageManager, forceSoftware, profile) {
	        var _this = this;
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        _super.call(this);
	        this._abstractionPool = new Object();
	        this._programData = new Array();
	        this._x = 0;
	        this._y = 0;
	        //private static _frameEventDriver:Shape = new Shape(); // TODO: add frame driver/request animation frame
	        this._stageIndex = -1;
	        this._antiAlias = 0;
	        //private var _activeVertexBuffers : Vector.<VertexBuffer> = new Vector.<VertexBuffer>(8, true);
	        //private var _activeTextures : Vector.<TextureBase> = new Vector.<TextureBase>(8, true);
	        this._renderTarget = null;
	        this._renderSurfaceSelector = 0;
	        //private _mouse3DManager:away.managers.Mouse3DManager;
	        //private _touch3DManager:Touch3DManager; //TODO: imeplement dependency Touch3DManager
	        this._initialised = false;
	        this._bufferFormatDictionary = new Array(5);
	        this.globalDisableMipmap = false;
	        this.globalDisableSmooth = false;
	        this._programDataPool = new ProgramDataPool_1.ProgramDataPool(this);
	        this._container = container;
	        if (this._container) {
	            this._container.addEventListener("webglcontextlost", function (event) { return _this.onContextLost(event); });
	            this._container.addEventListener("webglcontextrestored", function (event) { return _this.onContextRestored(event); });
	        }
	        this._stageIndex = stageIndex;
	        this._stageManager = stageManager;
	        this._viewPort = new Rectangle_1.Rectangle();
	        this._enableDepthAndStencil = true;
	        CSS_1.CSS.setElementX(this._container, 0);
	        CSS_1.CSS.setElementY(this._container, 0);
	        this._bufferFormatDictionary[1] = new Array(5);
	        this._bufferFormatDictionary[1][1] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_1;
	        this._bufferFormatDictionary[1][2] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_2;
	        this._bufferFormatDictionary[1][3] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_3;
	        this._bufferFormatDictionary[1][4] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_4;
	        this._bufferFormatDictionary[2] = new Array(5);
	        this._bufferFormatDictionary[2][1] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_1;
	        this._bufferFormatDictionary[2][2] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_2;
	        this._bufferFormatDictionary[2][3] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_3;
	        this._bufferFormatDictionary[2][4] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_4;
	        this._bufferFormatDictionary[4] = new Array(5);
	        this._bufferFormatDictionary[4][1] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_1;
	        this._bufferFormatDictionary[4][2] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2;
	        this._bufferFormatDictionary[4][3] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3;
	        this._bufferFormatDictionary[4][4] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4;
	        this._bufferFormatDictionary[5] = new Array(5);
	        this._bufferFormatDictionary[5][1] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_1;
	        this._bufferFormatDictionary[5][2] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_2;
	        this._bufferFormatDictionary[5][3] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_3;
	        this._bufferFormatDictionary[5][4] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_4;
	        this._bufferFormatDictionary[6] = new Array(5);
	        this._bufferFormatDictionary[6][1] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_1;
	        this._bufferFormatDictionary[6][2] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_2;
	        this._bufferFormatDictionary[6][3] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_3;
	        this._bufferFormatDictionary[6][4] = ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_4;
	        this.visible = true;
	    }
	    Stage.prototype.getProgramData = function (vertexString, fragmentString) {
	        return this._programDataPool.getItem(vertexString, fragmentString);
	    };
	    Stage.prototype.setRenderTarget = function (target, enableDepthAndStencil, surfaceSelector) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        if (this._renderTarget === target && surfaceSelector == this._renderSurfaceSelector && this._enableDepthAndStencil == enableDepthAndStencil)
	            return;
	        this._renderTarget = target;
	        this._renderSurfaceSelector = surfaceSelector;
	        this._enableDepthAndStencil = enableDepthAndStencil;
	        if (target) {
	            this._context.setRenderToTexture(this.getAbstraction(target).texture, enableDepthAndStencil, this._antiAlias, surfaceSelector);
	        }
	        else {
	            this._context.setRenderToBackBuffer();
	            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
	        }
	    };
	    Stage.prototype.getAbstraction = function (asset) {
	        return (this._abstractionPool[asset.id] || (this._abstractionPool[asset.id] = new Stage._abstractionClassPool[asset.assetType](asset, this)));
	    };
	    /**
	     *
	     * @param image
	     */
	    Stage.prototype.clearAbstraction = function (asset) {
	        this._abstractionPool[asset.id] = null;
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    Stage.registerAbstraction = function (gl_assetClass, assetClass) {
	        Stage._abstractionClassPool[assetClass.assetType] = gl_assetClass;
	    };
	    /**
	     * Requests a Context object to attach to the managed gl canvas.
	     */
	    Stage.prototype.requestContext = function (forceSoftware, profile, mode) {
	        // If forcing software, we can be certain that the
	        // returned Context will be running software mode.
	        // If not, we can't be sure and should stick to the
	        // old value (will likely be same if re-requesting.)
	        var _this = this;
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        if (this._usesSoftwareRendering != null)
	            this._usesSoftwareRendering = forceSoftware;
	        this._profile = profile;
	        try {
	            if (mode == ContextMode_1.ContextMode.FLASH)
	                new ContextFlash_1.ContextFlash(this._container, function (context) { return _this._callback(context); });
	            else if (mode == ContextMode_1.ContextMode.SOFTWARE)
	                this._context = new ContextSoftware_1.ContextSoftware(this._container);
	            else if (mode == ContextMode_1.ContextMode.GLES)
	                this._context = new ContextGLES_1.ContextGLES(this._container);
	            else
	                this._context = new ContextWebGL_1.ContextWebGL(this._container);
	        }
	        catch (e) {
	            try {
	                if (mode == ContextMode_1.ContextMode.AUTO)
	                    new ContextFlash_1.ContextFlash(this._container, function (context) { return _this._callback(context); });
	                else
	                    this.dispatchEvent(new StageEvent_1.StageEvent(StageEvent_1.StageEvent.STAGE_ERROR, this));
	            }
	            catch (e) {
	                this.dispatchEvent(new StageEvent_1.StageEvent(StageEvent_1.StageEvent.STAGE_ERROR, this));
	            }
	        }
	        if (this._context)
	            this._callback(this._context);
	    };
	    Object.defineProperty(Stage.prototype, "width", {
	        /**
	         * The width of the gl canvas
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (val) {
	            if (this._width == val)
	                return;
	            CSS_1.CSS.setElementWidth(this._container, val);
	            this._width = this._viewPort.width = val;
	            this._backBufferDirty = true;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "height", {
	        /**
	         * The height of the gl canvas
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (val) {
	            if (this._height == val)
	                return;
	            CSS_1.CSS.setElementHeight(this._container, val);
	            this._height = this._viewPort.height = val;
	            this._backBufferDirty = true;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "x", {
	        /**
	         * The x position of the gl canvas
	         */
	        get: function () {
	            return this._x;
	        },
	        set: function (val) {
	            if (this._x == val)
	                return;
	            CSS_1.CSS.setElementX(this._container, val);
	            this._x = this._viewPort.x = val;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "y", {
	        /**
	         * The y position of the gl canvas
	         */
	        get: function () {
	            return this._y;
	        },
	        set: function (val) {
	            if (this._y == val)
	                return;
	            CSS_1.CSS.setElementY(this._container, val);
	            this._y = this._viewPort.y = val;
	            this.notifyViewportUpdated();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "visible", {
	        get: function () {
	            return CSS_1.CSS.getElementVisibility(this._container);
	        },
	        set: function (val) {
	            CSS_1.CSS.setElementVisibility(this._container, val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "container", {
	        get: function () {
	            return this._container;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "context", {
	        /**
	         * The Context object associated with the given stage object.
	         */
	        get: function () {
	            return this._context;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Stage.prototype.notifyViewportUpdated = function () {
	        if (this._viewportDirty)
	            return;
	        this._viewportDirty = true;
	        this.dispatchEvent(new StageEvent_1.StageEvent(StageEvent_1.StageEvent.VIEWPORT_UPDATED, this));
	    };
	    Object.defineProperty(Stage.prototype, "profile", {
	        get: function () {
	            return this._profile;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Disposes the Stage object, freeing the Context attached to the Stage.
	     */
	    Stage.prototype.dispose = function () {
	        for (var id in this._abstractionPool)
	            this._abstractionPool[id].clear();
	        this._abstractionPool = null;
	        this._stageManager.iRemoveStage(this);
	        this.freeContext();
	        this._stageManager = null;
	        this._stageIndex = -1;
	    };
	    /**
	     * Configures the back buffer associated with the Stage object.
	     * @param backBufferWidth The width of the backbuffer.
	     * @param backBufferHeight The height of the backbuffer.
	     * @param antiAlias The amount of anti-aliasing to use.
	     * @param enableDepthAndStencil Indicates whether the back buffer contains a depth and stencil buffer.
	     */
	    Stage.prototype.configureBackBuffer = function (backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil) {
	        this.width = backBufferWidth;
	        this.height = backBufferHeight;
	        this._antiAlias = antiAlias;
	        this._enableDepthAndStencil = enableDepthAndStencil;
	        if (this._context)
	            this._context.configureBackBuffer(backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil);
	    };
	    Object.defineProperty(Stage.prototype, "enableDepthAndStencil", {
	        /*
	         * Indicates whether the depth and stencil buffer is used
	         */
	        get: function () {
	            return this._enableDepthAndStencil;
	        },
	        set: function (enableDepthAndStencil) {
	            this._enableDepthAndStencil = enableDepthAndStencil;
	            this._backBufferDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "renderTarget", {
	        get: function () {
	            return this._renderTarget;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "renderSurfaceSelector", {
	        get: function () {
	            return this._renderSurfaceSelector;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /*
	     * Clear and reset the back buffer when using a shared context
	     */
	    Stage.prototype.clear = function () {
	        if (!this._context)
	            return;
	        if (this._backBufferDirty) {
	            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
	            this._backBufferDirty = false;
	        }
	        this._context.clear((this._color & 0xff000000) >>> 24, // <--------- Zero-fill right shift
	        (this._color & 0xff0000) >>> 16, // <-------------|
	        (this._color & 0xff00) >>> 8, // <----------------|
	        this._color & 0xff);
	        this._bufferClear = true;
	    };
	    Object.defineProperty(Stage.prototype, "scissorRect", {
	        get: function () {
	            return this._scissorRect;
	        },
	        set: function (value) {
	            this._scissorRect = value;
	            this._context.setScissorRectangle(this._scissorRect);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "stageIndex", {
	        /**
	         * The index of the Stage which is managed by this instance of StageProxy.
	         */
	        get: function () {
	            return this._stageIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "usesSoftwareRendering", {
	        /**
	         * Indicates whether the Stage managed by this proxy is running in software mode.
	         * Remember to wait for the CONTEXT_CREATED event before checking this property,
	         * as only then will it be guaranteed to be accurate.
	         */
	        get: function () {
	            return this._usesSoftwareRendering;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "antiAlias", {
	        /**
	         * The antiAliasing of the Stage.
	         */
	        get: function () {
	            return this._antiAlias;
	        },
	        set: function (antiAlias) {
	            this._antiAlias = antiAlias;
	            this._backBufferDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "viewPort", {
	        /**
	         * A viewPort rectangle equivalent of the Stage size and position.
	         */
	        get: function () {
	            this._viewportDirty = false;
	            return this._viewPort;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "color", {
	        /**
	         * The background color of the Stage.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (color) {
	            this._color = color;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Stage.prototype, "bufferClear", {
	        /**
	         * The freshly cleared state of the backbuffer before any rendering
	         */
	        get: function () {
	            return this._bufferClear;
	        },
	        set: function (newBufferClear) {
	            this._bufferClear = newBufferClear;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Stage.prototype.registerProgram = function (programData) {
	        var i = 0;
	        while (this._programData[i] != null)
	            i++;
	        this._programData[i] = programData;
	        programData.id = i;
	    };
	    Stage.prototype.unRegisterProgram = function (programData) {
	        this._programData[programData.id] = null;
	        programData.id = -1;
	    };
	    /**
	     * Frees the Context associated with this StageProxy.
	     */
	    Stage.prototype.freeContext = function () {
	        if (this._context) {
	            this._context.dispose();
	            this.dispatchEvent(new StageEvent_1.StageEvent(StageEvent_1.StageEvent.CONTEXT_DISPOSED, this));
	        }
	        this._context = null;
	        this._initialised = false;
	    };
	    Stage.prototype.onContextLost = function (event) {
	    };
	    Stage.prototype.onContextRestored = function (event) {
	    };
	    Stage.prototype.recoverFromDisposal = function () {
	        if (!this._context)
	            return false;
	        //away.Debug.throwPIR( 'StageProxy' , 'recoverFromDisposal' , '' );
	        /*
	         if (this._iContext.driverInfo == "Disposed")
	         {
	         this._iContext = null;
	         this.dispatchEvent(new StageEvent(StageEvent.CONTEXT_DISPOSED));
	         return false;
	
	         }
	         */
	        return true;
	    };
	    Stage.prototype._callback = function (context) {
	        this._context = context;
	        this._container = this._context.container;
	        // Only configure back buffer if width and height have been set,
	        // which they may not have been if View.render() has yet to be
	        // invoked for the first time.
	        if (this._width && this._height)
	            this._context.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
	        // Dispatch the appropriate event depending on whether context was
	        // created for the first time or recreated after a device loss.
	        this.dispatchEvent(new StageEvent_1.StageEvent(this._initialised ? StageEvent_1.StageEvent.CONTEXT_RECREATED : StageEvent_1.StageEvent.CONTEXT_CREATED, this));
	        this._initialised = true;
	    };
	    Stage.prototype.setVertexBuffer = function (index, buffer, size, dimensions, offset, unsigned) {
	        if (unsigned === void 0) { unsigned = false; }
	        this._context.setVertexBufferAt(index, buffer, offset, this._bufferFormatDictionary[unsigned ? size + 4 : size][dimensions]);
	    };
	    Stage.prototype.setSamplerState = function (index, repeat, smooth, mipmap) {
	        var wrap = repeat ? ContextGLWrapMode_1.ContextGLWrapMode.REPEAT : ContextGLWrapMode_1.ContextGLWrapMode.CLAMP;
	        var filter = (smooth && !this.globalDisableSmooth) ? ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR : ContextGLTextureFilter_1.ContextGLTextureFilter.NEAREST;
	        var mipfilter = (mipmap && !this.globalDisableMipmap) ? ContextGLMipFilter_1.ContextGLMipFilter.MIPLINEAR : ContextGLMipFilter_1.ContextGLMipFilter.MIPNONE;
	        this._context.setSamplerStateAt(index, wrap, filter, mipfilter);
	    };
	    Stage._abstractionClassPool = new Object();
	    return Stage;
	}(EventDispatcher_1.EventDispatcher));
	exports.Stage = Stage;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Point_1 = __webpack_require__(58);
	/**
	 * A Rectangle object is an area defined by its position, as indicated by its
	 * top-left corner point(<i>x</i>, <i>y</i>) and by its width and its height.
	 *
	 *
	 * <p>The <code>x</code>, <code>y</code>, <code>width</code>, and
	 * <code>height</code> properties of the Rectangle export class are independent of
	 * each other; changing the value of one property has no effect on the others.
	 * However, the <code>right</code> and <code>bottom</code> properties are
	 * integrally related to those four properties. For example, if you change the
	 * value of the <code>right</code> property, the value of the
	 * <code>width</code> property changes; if you change the <code>bottom</code>
	 * property, the value of the <code>height</code> property changes. </p>
	 *
	 * <p>The following methods and properties use Rectangle objects:</p>
	 *
	 * <ul>
	 *   <li>The <code>applyFilter()</code>, <code>colorTransform()</code>,
	 * <code>copyChannel()</code>, <code>copyPixels()</code>, <code>draw()</code>,
	 * <code>fillRect()</code>, <code>generateFilterRect()</code>,
	 * <code>getColorBoundsRect()</code>, <code>getPixels()</code>,
	 * <code>merge()</code>, <code>paletteMap()</code>,
	 * <code>pixelDisolve()</code>, <code>setPixels()</code>, and
	 * <code>threshold()</code> methods, and the <code>rect</code> property of the
	 * BitmapData class</li>
	 *   <li>The <code>getBounds()</code> and <code>getRect()</code> methods, and
	 * the <code>scrollRect</code> and <code>scale9Grid</code> properties of the
	 * DisplayObject class</li>
	 *   <li>The <code>getCharBoundaries()</code> method of the TextField
	 * class</li>
	 *   <li>The <code>pixelBounds</code> property of the Transform class</li>
	 *   <li>The <code>bounds</code> parameter for the <code>startDrag()</code>
	 * method of the Sprite class</li>
	 *   <li>The <code>printArea</code> parameter of the <code>addPage()</code>
	 * method of the PrintJob class</li>
	 * </ul>
	 *
	 * <p>You can use the <code>new Rectangle()</code> constructor to create a
	 * Rectangle object.</p>
	 *
	 * <p><b>Note:</b> The Rectangle export class does not define a rectangular Shape
	 * display object. To draw a rectangular Shape object onscreen, use the
	 * <code>drawRect()</code> method of the Graphics class.</p>
	 */
	var Rectangle = (function () {
	    /**
	     * Creates a new Rectangle object with the top-left corner specified by the
	     * <code>x</code> and <code>y</code> parameters and with the specified
	     * <code>width</code> and <code>height</code> parameters. If you call this
	     * public without parameters, a rectangle with <code>x</code>,
	     * <code>y</code>, <code>width</code>, and <code>height</code> properties set
	     * to 0 is created.
	     *
	     * @param x      The <i>x</i> coordinate of the top-left corner of the
	     *               rectangle.
	     * @param y      The <i>y</i> coordinate of the top-left corner of the
	     *               rectangle.
	     * @param width  The width of the rectangle, in pixels.
	     * @param height The height of the rectangle, in pixels.
	     */
	    function Rectangle(x, y, width, height) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (width === void 0) { width = 0; }
	        if (height === void 0) { height = 0; }
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;
	    }
	    Object.defineProperty(Rectangle.prototype, "bottom", {
	        /**
	         * The sum of the <code>y</code> and <code>height</code> properties.
	         */
	        get: function () {
	            return this.y + this.height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "bottomRight", {
	        /**
	         * The location of the Rectangle object's bottom-right corner, determined by
	         * the values of the <code>right</code> and <code>bottom</code> properties.
	         */
	        get: function () {
	            if (this._bottomRight == null)
	                this._bottomRight = new Point_1.Point();
	            this._bottomRight.x = this.x + this.width;
	            this._bottomRight.y = this.y + this.height;
	            return this._bottomRight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "left", {
	        /**
	         * The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
	         * the <code>left</code> property of a Rectangle object has no effect on the
	         * <code>y</code> and <code>height</code> properties. However it does affect
	         * the <code>width</code> property, whereas changing the <code>x</code> value
	         * does <i>not</i> affect the <code>width</code> property.
	         *
	         * <p>The value of the <code>left</code> property is equal to the value of
	         * the <code>x</code> property.</p>
	         */
	        get: function () {
	            return this.x;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "right", {
	        /**
	         * The sum of the <code>x</code> and <code>width</code> properties.
	         */
	        get: function () {
	            return this.x + this.width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "size", {
	        /**
	         * The size of the Rectangle object, expressed as a Point object with the
	         * values of the <code>width</code> and <code>height</code> properties.
	         */
	        get: function () {
	            if (this._size == null)
	                this._size = new Point_1.Point();
	            this._size.x = this.width;
	            this._size.y = this.height;
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "top", {
	        /**
	         * The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
	         * the <code>top</code> property of a Rectangle object has no effect on the
	         * <code>x</code> and <code>width</code> properties. However it does affect
	         * the <code>height</code> property, whereas changing the <code>y</code>
	         * value does <i>not</i> affect the <code>height</code> property.
	         *
	         * <p>The value of the <code>top</code> property is equal to the value of the
	         * <code>y</code> property.</p>
	         */
	        get: function () {
	            return this.y;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Rectangle.prototype, "topLeft", {
	        /**
	         * The location of the Rectangle object's top-left corner, determined by the
	         * <i>x</i> and <i>y</i> coordinates of the point.
	         */
	        get: function () {
	            if (this._topLeft == null)
	                this._topLeft = new Point_1.Point();
	            this._topLeft.x = this.x;
	            this._topLeft.y = this.y;
	            return this._topLeft;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new Rectangle object with the same values for the
	     * <code>x</code>, <code>y</code>, <code>width</code>, and
	     * <code>height</code> properties as the original Rectangle object.
	     *
	     * @return A new Rectangle object with the same values for the
	     *         <code>x</code>, <code>y</code>, <code>width</code>, and
	     *         <code>height</code> properties as the original Rectangle object.
	     */
	    Rectangle.prototype.clone = function () {
	        return new Rectangle(this.x, this.y, this.width, this.height);
	    };
	    /**
	     * Determines whether the specified point is contained within the rectangular
	     * region defined by this Rectangle object.
	     *
	     * @param x The <i>x</i> coordinate(horizontal position) of the point.
	     * @param y The <i>y</i> coordinate(vertical position) of the point.
	     * @return A value of <code>true</code> if the Rectangle object contains the
	     *         specified point; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.contains = function (x, y) {
	        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y);
	    };
	    /**
	     * Determines whether the specified point is contained within the rectangular
	     * region defined by this Rectangle object. This method is similar to the
	     * <code>Rectangle.contains()</code> method, except that it takes a Point
	     * object as a parameter.
	     *
	     * @param point The point, as represented by its <i>x</i> and <i>y</i>
	     *              coordinates.
	     * @return A value of <code>true</code> if the Rectangle object contains the
	     *         specified point; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.containsPoint = function (point) {
	        return (this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y);
	    };
	    /**
	     * Determines whether the Rectangle object specified by the <code>rect</code>
	     * parameter is contained within this Rectangle object. A Rectangle object is
	     * said to contain another if the second Rectangle object falls entirely
	     * within the boundaries of the first.
	     *
	     * @param rect The Rectangle object being checked.
	     * @return A value of <code>true</code> if the Rectangle object that you
	     *         specify is contained by this Rectangle object; otherwise
	     *         <code>false</code>.
	     */
	    Rectangle.prototype.containsRect = function (rect) {
	        return (this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height);
	    };
	    /**
	     * Copies all of rectangle data from the source Rectangle object into the
	     * calling Rectangle object.
	     *
	     * @param sourceRect The Rectangle object from which to copy the data.
	     */
	    Rectangle.prototype.copyFrom = function (sourceRect) {
	    };
	    /**
	     * Determines whether the object specified in the <code>toCompare</code>
	     * parameter is equal to this Rectangle object. This method compares the
	     * <code>x</code>, <code>y</code>, <code>width</code>, and
	     * <code>height</code> properties of an object against the same properties of
	     * this Rectangle object.
	     *
	     * @param toCompare The rectangle to compare to this Rectangle object.
	     * @return A value of <code>true</code> if the object has exactly the same
	     *         values for the <code>x</code>, <code>y</code>, <code>width</code>,
	     *         and <code>height</code> properties as this Rectangle object;
	     *         otherwise <code>false</code>.
	     */
	    Rectangle.prototype.equals = function (toCompare) {
	        return (this.x == toCompare.x && this.y == toCompare.y && this.width == toCompare.width && this.height == toCompare.height);
	    };
	    /**
	     * Increases the size of the Rectangle object by the specified amounts, in
	     * pixels. The center point of the Rectangle object stays the same, and its
	     * size increases to the left and right by the <code>dx</code> value, and to
	     * the top and the bottom by the <code>dy</code> value.
	     *
	     * @param dx The value to be added to the left and the right of the Rectangle
	     *           object. The following equation is used to calculate the new
	     *           width and position of the rectangle:
	     * @param dy The value to be added to the top and the bottom of the
	     *           Rectangle. The following equation is used to calculate the new
	     *           height and position of the rectangle:
	     */
	    Rectangle.prototype.inflate = function (dx, dy) {
	        this.x -= dx / 2;
	        this.y -= dy / 2;
	        this.width += dx / 2;
	        this.height += dy / 2;
	    };
	    /**
	     * Increases the size of the Rectangle object. This method is similar to the
	     * <code>Rectangle.inflate()</code> method except it takes a Point object as
	     * a parameter.
	     *
	     * <p>The following two code examples give the same result:</p>
	     *
	     * @param point The <code>x</code> property of this Point object is used to
	     *              increase the horizontal dimension of the Rectangle object.
	     *              The <code>y</code> property is used to increase the vertical
	     *              dimension of the Rectangle object.
	     */
	    Rectangle.prototype.inflatePoint = function (point) {
	        this.x -= point.x / 2;
	        this.y -= point.y / 2;
	        this.width += point.x / 2;
	        this.height += point.y / 2;
	    };
	    /**
	     * If the Rectangle object specified in the <code>toIntersect</code>
	     * parameter intersects with this Rectangle object, returns the area of
	     * intersection as a Rectangle object. If the rectangles do not intersect,
	     * this method returns an empty Rectangle object with its properties set to
	     * 0.
	     *
	     * @param toIntersect The Rectangle object to compare against to see if it
	     *                    intersects with this Rectangle object.
	     * @return A Rectangle object that equals the area of intersection. If the
	     *         rectangles do not intersect, this method returns an empty
	     *         Rectangle object; that is, a rectangle with its <code>x</code>,
	     *         <code>y</code>, <code>width</code>, and <code>height</code>
	     *         properties set to 0.
	     */
	    Rectangle.prototype.intersection = function (toIntersect) {
	        if (this.intersects(toIntersect)) {
	            var i = new Rectangle();
	            if (this.x > toIntersect.x) {
	                i.x = this.x;
	                i.width = toIntersect.x - this.x + toIntersect.width;
	                if (i.width > this.width)
	                    i.width = this.width;
	            }
	            else {
	                i.x = toIntersect.x;
	                i.width = this.x - toIntersect.x + this.width;
	                if (i.width > toIntersect.width)
	                    i.width = toIntersect.width;
	            }
	            if (this.y > toIntersect.y) {
	                i.y = this.y;
	                i.height = toIntersect.y - this.y + toIntersect.height;
	                if (i.height > this.height)
	                    i.height = this.height;
	            }
	            else {
	                i.y = toIntersect.y;
	                i.height = this.y - toIntersect.y + this.height;
	                if (i.height > toIntersect.height)
	                    i.height = toIntersect.height;
	            }
	            return i;
	        }
	        return new Rectangle();
	    };
	    /**
	     * Determines whether the object specified in the <code>toIntersect</code>
	     * parameter intersects with this Rectangle object. This method checks the
	     * <code>x</code>, <code>y</code>, <code>width</code>, and
	     * <code>height</code> properties of the specified Rectangle object to see if
	     * it intersects with this Rectangle object.
	     *
	     * @param toIntersect The Rectangle object to compare against this Rectangle
	     *                    object.
	     * @return A value of <code>true</code> if the specified object intersects
	     *         with this Rectangle object; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.intersects = function (toIntersect) {
	        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height);
	    };
	    /**
	     * Determines whether or not this Rectangle object is empty.
	     *
	     * @return A value of <code>true</code> if the Rectangle object's width or
	     *         height is less than or equal to 0; otherwise <code>false</code>.
	     */
	    Rectangle.prototype.isEmpty = function () {
	        return (this.x == 0 && this.y == 0 && this.width == 0 && this.height == 0);
	    };
	    /**
	     * Adjusts the location of the Rectangle object, as determined by its
	     * top-left corner, by the specified amounts.
	     *
	     * @param dx Moves the <i>x</i> value of the Rectangle object by this amount.
	     * @param dy Moves the <i>y</i> value of the Rectangle object by this amount.
	     */
	    Rectangle.prototype.offset = function (dx, dy) {
	        this.x += dx;
	        this.y += dy;
	    };
	    /**
	     * Adjusts the location of the Rectangle object using a Point object as a
	     * parameter. This method is similar to the <code>Rectangle.offset()</code>
	     * method, except that it takes a Point object as a parameter.
	     *
	     * @param point A Point object to use to offset this Rectangle object.
	     */
	    Rectangle.prototype.offsetPoint = function (point) {
	        this.x += point.x;
	        this.y += point.y;
	    };
	    /**
	     * Sets all of the Rectangle object's properties to 0. A Rectangle object is
	     * empty if its width or height is less than or equal to 0.
	     *
	     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
	     * <code>width</code>, and <code>height</code> properties to 0.</p>
	     *
	     */
	    Rectangle.prototype.setEmpty = function () {
	        this.x = 0;
	        this.y = 0;
	        this.width = 0;
	        this.height = 0;
	    };
	    /**
	     * Sets the members of Rectangle to the specified values
	     *
	     * @param xa      The <i>x</i> coordinate of the top-left corner of the
	     *                rectangle.
	     * @param ya      The <i>y</i> coordinate of the top-left corner of the
	     *                rectangle.
	     * @param widtha  The width of the rectangle, in pixels.
	     * @param heighta The height of the rectangle, in pixels.
	     */
	    Rectangle.prototype.setTo = function (xa, ya, widtha, heighta) {
	        this.x = xa;
	        this.y = ya;
	        this.width = widtha;
	        this.height = heighta;
	    };
	    /**
	     * Builds and returns a string that lists the horizontal and vertical
	     * positions and the width and height of the Rectangle object.
	     *
	     * @return A string listing the value of each of the following properties of
	     *         the Rectangle object: <code>x</code>, <code>y</code>,
	     *         <code>width</code>, and <code>height</code>.
	     */
	    Rectangle.prototype.toString = function () {
	        return "[Rectangle] (x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
	    };
	    /**
	     * Adds two rectangles together to create a new Rectangle object, by filling
	     * in the horizontal and vertical space between the two rectangles.
	     *
	     * <p><b>Note:</b> The <code>union()</code> method ignores rectangles with
	     * <code>0</code> as the height or width value, such as: <code>var
	     * rect2:Rectangle = new Rectangle(300,300,50,0);</code></p>
	     *
	     * @param toUnion A Rectangle object to add to this Rectangle object.
	     * @return A new Rectangle object that is the union of the two rectangles.
	     */
	    Rectangle.prototype.union = function (toUnion) {
	        var u = new Rectangle();
	        if (this.x < toUnion.x) {
	            u.x = this.x;
	            u.width = toUnion.x - this.x + toUnion.width;
	            if (u.width < this.width)
	                u.width = this.width;
	        }
	        else {
	            u.x = toUnion.x;
	            u.width = this.x - toUnion.x + this.width;
	            if (u.width < toUnion.width)
	                u.width = toUnion.width;
	        }
	        if (this.y < toUnion.y) {
	            u.y = this.y;
	            u.height = toUnion.y - this.y + toUnion.height;
	            if (u.height < this.height)
	                u.height = this.height;
	        }
	        else {
	            u.y = toUnion.y;
	            u.height = this.y - toUnion.y + this.height;
	            if (u.height < toUnion.height)
	                u.height = toUnion.height;
	        }
	        return u;
	    };
	    return Rectangle;
	}());
	exports.Rectangle = Rectangle;


/***/ },
/* 58 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The Point object represents a location in a two-dimensional coordinate
	 * system, where <i>x</i> represents the horizontal axis and <i>y</i>
	 * represents the vertical axis.
	 *
	 * <p>The following code creates a point at(0,0):</p>
	 *
	 * <p>Methods and properties of the following classes use Point objects:</p>
	 *
	 * <ul>
	 *   <li>BitmapData</li>
	 *   <li>DisplayObject</li>
	 *   <li>DisplayObjectContainer</li>
	 *   <li>DisplacementMapFilter</li>
	 *   <li>NativeWindow</li>
	 *   <li>Matrix</li>
	 *   <li>Rectangle</li>
	 * </ul>
	 *
	 * <p>You can use the <code>new Point()</code> constructor to create a Point
	 * object.</p>
	 */
	var Point = (function () {
	    /**
	     * Creates a new point. If you pass no parameters to this method, a point is
	     * created at(0,0).
	     *
	     * @param x The horizontal coordinate.
	     * @param y The vertical coordinate.
	     */
	    function Point(x, y) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        this.x = x;
	        this.y = y;
	    }
	    Object.defineProperty(Point.prototype, "length", {
	        /**
	         * The length of the line segment from(0,0) to this point.
	         */
	        get: function () {
	            return Math.sqrt(this.x * this.x + this.y * this.y);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds the coordinates of another point to the coordinates of this point to
	     * create a new point.
	     *
	     * @param v The point to be added.
	     * @return The new point.
	     */
	    Point.prototype.add = function (v) {
	        return new Point(this.x + v.x, this.y + v.y);
	    };
	    /**
	     * Creates a copy of this Point object.
	     *
	     * @return The new Point object.
	     */
	    Point.prototype.clone = function () {
	        return new Point(this.x, this.y);
	    };
	    Point.prototype.copyFrom = function (sourcePoint) {
	    };
	    /**
	     * Determines whether two points are equal. Two points are equal if they have
	     * the same <i>x</i> and <i>y</i> values.
	     *
	     * @param toCompare The point to be compared.
	     * @return A value of <code>true</code> if the object is equal to this Point
	     *         object; <code>false</code> if it is not equal.
	     */
	    Point.prototype.equals = function (toCompare) {
	        return (this.x == toCompare.x && this.y == toCompare.y);
	    };
	    /**
	     * Scales the line segment between(0,0) and the current point to a set
	     * length.
	     *
	     * @param thickness The scaling value. For example, if the current point is
	     *                 (0,5), and you normalize it to 1, the point returned is
	     *                  at(0,1).
	     */
	    Point.prototype.normalize = function (thickness) {
	        if (thickness === void 0) { thickness = 1; }
	        if (this.length != 0) {
	            var invLength = thickness / this.length;
	            this.x *= invLength;
	            this.y *= invLength;
	            return;
	        }
	        throw "Cannot divide by zero length.";
	    };
	    /**
	     * Offsets the Point object by the specified amount. The value of
	     * <code>dx</code> is added to the original value of <i>x</i> to create the
	     * new <i>x</i> value. The value of <code>dy</code> is added to the original
	     * value of <i>y</i> to create the new <i>y</i> value.
	     *
	     * @param dx The amount by which to offset the horizontal coordinate,
	     *           <i>x</i>.
	     * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.
	     */
	    Point.prototype.offset = function (dx, dy) {
	        this.x += dx;
	        this.y += dy;
	    };
	    Point.prototype.setTo = function (xa, ya) {
	        this.x = xa;
	        this.y = ya;
	    };
	    /**
	     * Subtracts the coordinates of another point from the coordinates of this
	     * point to create a new point.
	     *
	     * @param v The point to be subtracted.
	     * @return The new point.
	     */
	    Point.prototype.subtract = function (v) {
	        return new Point(this.x - v.x, this.y - v.y);
	    };
	    /**
	     * Returns a string that contains the values of the <i>x</i> and <i>y</i>
	     * coordinates. The string has the form <code>"(x=<i>x</i>,
	     * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
	     * point at 23,17 would return <code>"(x=23, y=17)"</code>.
	     *
	     * @return The string representation of the coordinates.
	     */
	    Point.prototype.toString = function () {
	        return "[Point] (x=" + this.x + ", y=" + this.y + ")";
	    };
	    /**
	     * Returns the distance between <code>pt1</code> and <code>pt2</code>.
	     *
	     * @param pt1 The first point.
	     * @param pt2 The second point.
	     * @return The distance between the first and second points.
	     */
	    Point.distance = function (pt1, pt2) {
	        var dx = pt2.x - pt1.x;
	        var dy = pt2.y - pt1.y;
	        return Math.sqrt(dx * dx + dy * dy);
	    };
	    /**
	     * Determines a point between two specified points. The parameter
	     * <code>f</code> determines where the new interpolated point is located
	     * relative to the two end points specified by parameters <code>pt1</code>
	     * and <code>pt2</code>. The closer the value of the parameter <code>f</code>
	     * is to <code>1.0</code>, the closer the interpolated point is to the first
	     * point(parameter <code>pt1</code>). The closer the value of the parameter
	     * <code>f</code> is to 0, the closer the interpolated point is to the second
	     * point(parameter <code>pt2</code>).
	     *
	     * @param pt1 The first point.
	     * @param pt2 The second point.
	     * @param f   The level of interpolation between the two points. Indicates
	     *            where the new point will be, along the line between
	     *            <code>pt1</code> and <code>pt2</code>. If <code>f</code>=1,
	     *            <code>pt1</code> is returned; if <code>f</code>=0,
	     *            <code>pt2</code> is returned.
	     * @return The new, interpolated point.
	     */
	    Point.interpolate = function (pt1, pt2, f) {
	        return new Point(pt2.x + (pt1.x - pt2.x) * f, pt2.y + (pt1.y - pt2.y) * f);
	    };
	    /**
	     * Converts a pair of polar coordinates to a Cartesian point coordinate.
	     *
	     * @param len   The length coordinate of the polar pair.
	     * @param angle The angle, in radians, of the polar pair.
	     * @return The Cartesian point.
	     */
	    Point.polar = function (len, angle) {
	        return new Point(len * Math.cos(angle), len * Math.sin(angle));
	    };
	    return Point;
	}());
	exports.Point = Point;


/***/ },
/* 59 */
/***/ function(module, exports) {

	"use strict";
	var CSS = (function () {
	    function CSS() {
	    }
	    CSS.setElementSize = function (element, width, height) {
	        if (!element)
	            return;
	        element.style.width = width + "px";
	        element.style.height = height + "px";
	        element["width"] = width;
	        element["height"] = height;
	    };
	    CSS.setElementWidth = function (element, width) {
	        if (!element)
	            return;
	        element.style.width = width + "px";
	        element["width"] = width;
	    };
	    CSS.setElementHeight = function (element, height) {
	        if (!element)
	            return;
	        element.style.height = height + "px";
	        element["height"] = height;
	    };
	    CSS.setElementX = function (element, x) {
	        if (!element)
	            return;
	        element.style.position = 'absolute';
	        element.style.left = x + "px";
	    };
	    CSS.setElementY = function (element, y) {
	        if (!element)
	            return;
	        element.style.position = 'absolute';
	        element.style.top = y + "px";
	    };
	    CSS.getElementVisibility = function (element) {
	        if (!element)
	            return false;
	        return element.style.visibility == 'visible';
	    };
	    CSS.setElementVisibility = function (element, visible) {
	        if (!element)
	            return;
	        if (visible) {
	            element.style.visibility = 'visible';
	        }
	        else {
	            element.style.visibility = 'hidden';
	        }
	    };
	    CSS.setElementAlpha = function (element, alpha) {
	        if (element instanceof HTMLCanvasElement) {
	            var context = element.getContext("2d");
	            context.globalAlpha = alpha;
	        }
	    };
	    CSS.setElementPosition = function (element, x, y, absolute) {
	        if (absolute === void 0) { absolute = false; }
	        if (!element)
	            return;
	        if (absolute) {
	            element.style.position = "absolute";
	        }
	        else {
	            element.style.position = "relative";
	        }
	        element.style.left = x + "px";
	        element.style.top = y + "px";
	    };
	    return CSS;
	}());
	exports.CSS = CSS;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var StageEvent = (function (_super) {
	    __extends(StageEvent, _super);
	    function StageEvent(type, stage) {
	        _super.call(this, type);
	        this._stage = stage;
	    }
	    Object.defineProperty(StageEvent.prototype, "stage", {
	        /**
	         *
	         */
	        get: function () {
	            return this._stage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    StageEvent.prototype.clone = function () {
	        return new StageEvent(this.type, this._stage);
	    };
	    /**
	     *
	     */
	    StageEvent.STAGE_ERROR = "stageError";
	    /**
	     *
	     */
	    StageEvent.CONTEXT_CREATED = "contextCreated";
	    /**
	     *
	     */
	    StageEvent.CONTEXT_DISPOSED = "contextDisposed";
	    /**
	     *
	     */
	    StageEvent.CONTEXT_RECREATED = "contextRecreated";
	    /**
	     *
	     */
	    StageEvent.VIEWPORT_UPDATED = "viewportUpdated";
	    return StageEvent;
	}(EventBase_1.EventBase));
	exports.StageEvent = StageEvent;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ProgramData_1 = __webpack_require__(62);
	/**
	 * @class away.pool.ProgramDataPool
	 */
	var ProgramDataPool = (function () {
	    /**
	     * //TODO
	     *
	     * @param textureDataClass
	     */
	    function ProgramDataPool(stage) {
	        this._pool = new Object();
	        this._stage = stage;
	    }
	    /**
	     * //TODO
	     *
	     * @param materialOwner
	     * @returns ITexture
	     */
	    ProgramDataPool.prototype.getItem = function (vertexString, fragmentString) {
	        var key = vertexString + fragmentString;
	        return this._pool[key] || (this._pool[key] = new ProgramData_1.ProgramData(this, this._stage, vertexString, fragmentString));
	    };
	    /**
	     * //TODO
	     *
	     * @param materialOwner
	     */
	    ProgramDataPool.prototype.disposeItem = function (key) {
	        this._pool[key] = null;
	    };
	    return ProgramDataPool;
	}());
	exports.ProgramDataPool = ProgramDataPool;


/***/ },
/* 62 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 * @class away.pool.ProgramDataBase
	 */
	var ProgramData = (function () {
	    function ProgramData(pool, context, vertexString, fragmentString) {
	        this.usages = 0;
	        this._pool = pool;
	        this.stage = context;
	        this.vertexString = vertexString;
	        this.fragmentString = fragmentString;
	        this.stage.registerProgram(this);
	    }
	    /**
	     *
	     */
	    ProgramData.prototype.dispose = function () {
	        this.usages--;
	        if (!this.usages) {
	            this._pool.disposeItem(this.vertexString + this.fragmentString);
	            this.stage.unRegisterProgram(this);
	            if (this.program) {
	                this.program.dispose();
	                this.program = null;
	            }
	        }
	    };
	    ProgramData.PROGRAMDATA_ID_COUNT = 0;
	    return ProgramData;
	}());
	exports.ProgramData = ProgramData;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ContextGLClearMask_1 = __webpack_require__(42);
	var CubeTextureGLES_1 = __webpack_require__(64);
	var IndexBufferGLES_1 = __webpack_require__(66);
	var ProgramGLES_1 = __webpack_require__(67);
	var TextureGLES_1 = __webpack_require__(76);
	var VertexBufferGLES_1 = __webpack_require__(77);
	var ContextGLES = (function () {
	    function ContextGLES(canvas) {
	        this._blendFactorDictionary = new Object();
	        this._drawModeDictionary = new Object();
	        this._compareModeDictionary = new Object();
	        this._stencilActionDictionary = new Object();
	        this._textureIndexDictionary = new Array(8);
	        this._textureTypeDictionary = new Object();
	        this._wrapDictionary = new Object();
	        this._filterDictionary = new Object();
	        this._mipmapFilterDictionary = new Object();
	        this._vertexBufferPropertiesDictionary = [];
	        this._samplerStates = new Array(8);
	        this._stencilReferenceValue = 0;
	        this._stencilReadMask = 0xff;
	        this._separateStencil = false;
	        this._container = canvas;
	        // try {
	        // 	this._gl = <WebGLRenderingContext> canvas.getContext("experimental-webgl", { premultipliedAlpha:false, alpha:false, stencil:true });
	        //
	        // 	if (!this._gl)
	        // 		this._gl = <WebGLRenderingContext> canvas.getContext("webgl", { premultipliedAlpha:false, alpha:false, stencil:true });
	        // } catch (e) {
	        // 	//this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
	        // }
	        //
	        // if (this._gl) {
	        // 	//this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_SUCCESS ) );
	        //
	        // 	if(this._gl.getExtension("OES_standard_derivatives"))
	        // 	{
	        // 		this._standardDerivatives = true;
	        // 	}else{
	        // 		this._standardDerivatives = false;
	        // 	}
	        //
	        // 	//setup shortcut dictionaries
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.ONE] = this._gl.ONE;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.DESTINATION_ALPHA] = this._gl.DST_ALPHA;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.DESTINATION_COLOR] = this._gl.DST_COLOR;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.ONE] = this._gl.ONE;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA] = this._gl.ONE_MINUS_DST_ALPHA;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR] = this._gl.ONE_MINUS_DST_COLOR;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA] = this._gl.ONE_MINUS_SRC_ALPHA;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR] = this._gl.ONE_MINUS_SRC_COLOR;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.SOURCE_ALPHA] = this._gl.SRC_ALPHA;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.SOURCE_COLOR] = this._gl.SRC_COLOR;
	        // 	this._blendFactorDictionary[ContextGLBlendFactor.ZERO] = this._gl.ZERO;
	        //
	        // 	this._drawModeDictionary[ContextGLDrawMode.LINES] = this._gl.LINES;
	        // 	this._drawModeDictionary[ContextGLDrawMode.TRIANGLES] = this._gl.TRIANGLES;
	        //
	        //    this._compareModeDictionary[ContextGLCompareMode.ALWAYS] = this._gl.ALWAYS;
	        //    this._compareModeDictionary[ContextGLCompareMode.EQUAL] = this._gl.EQUAL;
	        //    this._compareModeDictionary[ContextGLCompareMode.GREATER] = this._gl.GREATER;
	        // 	this._compareModeDictionary[ContextGLCompareMode.GREATER_EQUAL] = this._gl.GEQUAL;
	        // 	this._compareModeDictionary[ContextGLCompareMode.LESS] = this._gl.LESS;
	        // 	this._compareModeDictionary[ContextGLCompareMode.LESS_EQUAL] = this._gl.LEQUAL;
	        // 	this._compareModeDictionary[ContextGLCompareMode.NEVER] = this._gl.NEVER;
	        // 	this._compareModeDictionary[ContextGLCompareMode.NOT_EQUAL] = this._gl.NOTEQUAL;
	        //
	        //    this._stencilActionDictionary[ContextGLStencilAction.DECREMENT_SATURATE] = this._gl.DECR;
	        //    this._stencilActionDictionary[ContextGLStencilAction.DECREMENT_WRAP] = this._gl.DECR_WRAP;
	        //    this._stencilActionDictionary[ContextGLStencilAction.INCREMENT_SATURATE] = this._gl.INCR;
	        //    this._stencilActionDictionary[ContextGLStencilAction.INCREMENT_WRAP] = this._gl.INCR_WRAP;
	        //    this._stencilActionDictionary[ContextGLStencilAction.INVERT] = this._gl.INVERT;
	        //    this._stencilActionDictionary[ContextGLStencilAction.KEEP] = this._gl.KEEP;
	        //    this._stencilActionDictionary[ContextGLStencilAction.SET] = this._gl.REPLACE;
	        //    this._stencilActionDictionary[ContextGLStencilAction.ZERO] = this._gl.ZERO;
	        //
	        // 	this._textureIndexDictionary[0] = this._gl.TEXTURE0;
	        // 	this._textureIndexDictionary[1] = this._gl.TEXTURE1;
	        // 	this._textureIndexDictionary[2] = this._gl.TEXTURE2;
	        // 	this._textureIndexDictionary[3] = this._gl.TEXTURE3;
	        // 	this._textureIndexDictionary[4] = this._gl.TEXTURE4;
	        // 	this._textureIndexDictionary[5] = this._gl.TEXTURE5;
	        // 	this._textureIndexDictionary[6] = this._gl.TEXTURE6;
	        // 	this._textureIndexDictionary[7] = this._gl.TEXTURE7;
	        //
	        // 	this._textureTypeDictionary["texture2d"] = this._gl.TEXTURE_2D;
	        // 	this._textureTypeDictionary["textureCube"] = this._gl.TEXTURE_CUBE_MAP;
	        //
	        // 	this._wrapDictionary[ContextGLWrapMode.REPEAT] = this._gl.REPEAT;
	        // 	this._wrapDictionary[ContextGLWrapMode.CLAMP] = this._gl.CLAMP_TO_EDGE;
	        //
	        // 	this._filterDictionary[ContextGLTextureFilter.LINEAR] = this._gl.LINEAR;
	        // 	this._filterDictionary[ContextGLTextureFilter.NEAREST] = this._gl.NEAREST;
	        //
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR] = new Object();
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR][ContextGLMipFilter.MIPNEAREST] = this._gl.LINEAR_MIPMAP_NEAREST;
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR][ContextGLMipFilter.MIPLINEAR] = this._gl.LINEAR_MIPMAP_LINEAR;
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.LINEAR][ContextGLMipFilter.MIPNONE] = this._gl.LINEAR;
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST] = new Object();
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST][ContextGLMipFilter.MIPNEAREST] = this._gl.NEAREST_MIPMAP_NEAREST;
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST][ContextGLMipFilter.MIPLINEAR] = this._gl.NEAREST_MIPMAP_LINEAR;
	        // 	this._mipmapFilterDictionary[ContextGLTextureFilter.NEAREST][ContextGLMipFilter.MIPNONE] = this._gl.NEAREST;
	        //
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.FLOAT_1] = new VertexBufferProperties(1, this._gl.FLOAT, false);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.FLOAT_2] = new VertexBufferProperties(2, this._gl.FLOAT, false);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.FLOAT_3] = new VertexBufferProperties(3, this._gl.FLOAT, false);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.FLOAT_4] = new VertexBufferProperties(4, this._gl.FLOAT, false);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.BYTE_1] = new VertexBufferProperties(1, this._gl.BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.BYTE_2] = new VertexBufferProperties(2, this._gl.BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.BYTE_3] = new VertexBufferProperties(3, this._gl.BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.BYTE_4] = new VertexBufferProperties(4, this._gl.BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_BYTE_1] = new VertexBufferProperties(1, this._gl.UNSIGNED_BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_BYTE_2] = new VertexBufferProperties(2, this._gl.UNSIGNED_BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_BYTE_3] = new VertexBufferProperties(3, this._gl.UNSIGNED_BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_BYTE_4] = new VertexBufferProperties(4, this._gl.UNSIGNED_BYTE, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.SHORT_1] = new VertexBufferProperties(1, this._gl.SHORT, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.SHORT_2] = new VertexBufferProperties(2, this._gl.SHORT, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.SHORT_3] = new VertexBufferProperties(3, this._gl.SHORT, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.SHORT_4] = new VertexBufferProperties(4, this._gl.SHORT, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_SHORT_1] = new VertexBufferProperties(1, this._gl.UNSIGNED_SHORT, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_SHORT_2] = new VertexBufferProperties(2, this._gl.UNSIGNED_SHORT, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_SHORT_3] = new VertexBufferProperties(3, this._gl.UNSIGNED_SHORT, true);
	        // 	this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat.UNSIGNED_SHORT_4] = new VertexBufferProperties(4, this._gl.UNSIGNED_SHORT, true);
	        //
	        //    this._stencilCompareMode = this._gl.ALWAYS;
	        //    this._stencilCompareModeBack = this._gl.ALWAYS;
	        //    this._stencilCompareModeFront = this._gl.ALWAYS;
	        // } else {
	        // 	//this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
	        // 	alert("GLES is not available.");
	        // }
	        //
	        // //defaults
	        // for (var i:number = 0; i < ContextGLES.MAX_SAMPLERS; ++i) {
	        // 	this._samplerStates[i] = new SamplerState();
	        // 	this._samplerStates[i].wrap = this._gl.REPEAT;
	        // 	this._samplerStates[i].filter = this._gl.LINEAR;
	        // 	this._samplerStates[i].mipfilter = this._gl.LINEAR;
	        // }
	    }
	    Object.defineProperty(ContextGLES.prototype, "container", {
	        get: function () {
	            return this._container;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ContextGLES.prototype, "standardDerivatives", {
	        get: function () {
	            return this._standardDerivatives;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ContextGLES.prototype.gl = function () {
	        return this._gl;
	    };
	    ContextGLES.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
	        if (red === void 0) { red = 0; }
	        if (green === void 0) { green = 0; }
	        if (blue === void 0) { blue = 0; }
	        if (alpha === void 0) { alpha = 1; }
	        if (depth === void 0) { depth = 1; }
	        if (stencil === void 0) { stencil = 0; }
	        if (mask === void 0) { mask = ContextGLClearMask_1.ContextGLClearMask.ALL; }
	        // if (!this._drawing) {
	        // 	this.updateBlendStatus();
	        // 	this._drawing = true;
	        // }
	        //
	        // var glmask:number = 0;
	        // if (mask & ContextGLClearMask.COLOR) glmask |= this._gl.COLOR_BUFFER_BIT;
	        // if (mask & ContextGLClearMask.STENCIL) glmask |= this._gl.STENCIL_BUFFER_BIT;
	        // if (mask & ContextGLClearMask.DEPTH) glmask |= this._gl.DEPTH_BUFFER_BIT;
	        //
	        // this._gl.clearColor(red, green, blue, alpha);
	        // this._gl.clearDepth(depth);
	        // this._gl.clearStencil(stencil);
	        // this._gl.clear(glmask);
	    };
	    ContextGLES.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
	        // this._width = width;
	        // this._height = height;
	        //
	        // if (enableDepthAndStencil) {
	        // 	this._gl.enable(this._gl.STENCIL_TEST);
	        // 	this._gl.enable(this._gl.DEPTH_TEST);
	        // }
	        //
	        // this._gl.viewport['width'] = width;
	        // this._gl.viewport['height'] = height;
	        //
	        // this._gl.viewport(0, 0, width, height);
	    };
	    ContextGLES.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        return new CubeTextureGLES_1.CubeTextureGLES(this._gl, size);
	    };
	    ContextGLES.prototype.createIndexBuffer = function (numIndices) {
	        return new IndexBufferGLES_1.IndexBufferGLES(this._gl, numIndices);
	    };
	    ContextGLES.prototype.createProgram = function () {
	        return new ProgramGLES_1.ProgramGLES(this._gl);
	    };
	    ContextGLES.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        //TODO streaming
	        return new TextureGLES_1.TextureGLES(this._gl, width, height);
	    };
	    ContextGLES.prototype.createVertexBuffer = function (numVertices, dataPerVertex) {
	        return new VertexBufferGLES_1.VertexBufferGLES(this._gl, numVertices, dataPerVertex);
	    };
	    ContextGLES.prototype.dispose = function () {
	        // for (var i:number = 0; i < this._samplerStates.length; ++i)
	        // 	this._samplerStates[i] = null;
	    };
	    ContextGLES.prototype.drawToBitmapImage2D = function (destination) {
	        // var pixels:Uint8ClampedArray = new Uint8ClampedArray(destination.width*destination.height*4);
	        //
	        // this._gl.readPixels(0, 0, destination.width, destination.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixels);
	        //
	        // destination.setPixels(new Rectangle(0, 0, destination.width, destination.height), pixels);
	    };
	    ContextGLES.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
	        if (firstIndex === void 0) { firstIndex = 0; }
	        if (numIndices === void 0) { numIndices = -1; }
	        // if (!this._drawing)
	        // 	throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
	        //
	        //
	        // this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
	        // this._gl.drawElements(this._drawModeDictionary[mode], (numIndices == -1)? indexBuffer.numIndices : numIndices, this._gl.UNSIGNED_SHORT, firstIndex*2);
	    };
	    ContextGLES.prototype.drawVertices = function (mode, firstVertex, numVertices) {
	        if (firstVertex === void 0) { firstVertex = 0; }
	        if (numVertices === void 0) { numVertices = -1; }
	        // if (!this._drawing)
	        // 	throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
	        //
	        // this._gl.drawArrays(this._drawModeDictionary[mode], firstVertex, numVertices);
	    };
	    ContextGLES.prototype.present = function () {
	        // this._drawing = false;
	    };
	    ContextGLES.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
	        // this._blendEnabled = true;
	        //
	        // this._blendSourceFactor = this._blendFactorDictionary[sourceFactor];
	        //
	        // this._blendDestinationFactor = this._blendFactorDictionary[destinationFactor];
	        //
	        // this.updateBlendStatus();
	    };
	    ContextGLES.prototype.setColorMask = function (red, green, blue, alpha) {
	        // this._gl.colorMask(red, green, blue, alpha);
	    };
	    ContextGLES.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        // if (triangleFaceToCull == ContextGLTriangleFace.NONE) {
	        // 	this._gl.disable(this._gl.CULL_FACE);
	        // } else {
	        // 	this._gl.enable(this._gl.CULL_FACE);
	        //    this._gl.cullFace(this.translateTriangleFace(triangleFaceToCull, coordinateSystem));
	        // }
	    };
	    // TODO ContextGLCompareMode
	    ContextGLES.prototype.setDepthTest = function (depthMask, passCompareMode) {
	        // this._gl.depthFunc(this._compareModeDictionary[passCompareMode]);
	        //
	        // this._gl.depthMask(depthMask);
	    };
	    ContextGLES.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
	        if (triangleFace === void 0) { triangleFace = "frontAndBack"; }
	        if (compareMode === void 0) { compareMode = "always"; }
	        if (actionOnBothPass === void 0) { actionOnBothPass = "keep"; }
	        if (actionOnDepthFail === void 0) { actionOnDepthFail = "keep"; }
	        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = "keep"; }
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        // this._separateStencil = triangleFace != "frontAndBack";
	        //
	        // var compareModeGL = this._compareModeDictionary[compareMode];
	        //
	        // var fail = this._stencilActionDictionary[actionOnDepthPassStencilFail];
	        // var zFail = this._stencilActionDictionary[actionOnDepthFail];
	        // var pass = this._stencilActionDictionary[actionOnBothPass];
	        //
	        // if (!this._separateStencil) {
	        //     this._stencilCompareMode = compareModeGL;
	        //     this._gl.stencilFunc(compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	        //     this._gl.stencilOp(fail, zFail, pass);
	        // }
	        // else if (triangleFace == "back") {
	        //     this._stencilCompareModeBack = compareModeGL;
	        //     this._gl.stencilFuncSeparate(this._gl.BACK, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	        //     this._gl.stencilOpSeparate(this._gl.BACK, fail, zFail, pass);
	        // }
	        // else if (triangleFace == "front") {
	        //     this._stencilCompareModeFront = compareModeGL;
	        //     this._gl.stencilFuncSeparate(this._gl.FRONT, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	        //     this._gl.stencilOpSeparate(this._gl.FRONT, fail, zFail, pass);
	        // }
	    };
	    ContextGLES.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
	        // this._stencilReferenceValue = referenceValue;
	        // this._stencilReadMask = readMask;
	        //
	        // if (this._separateStencil) {
	        //     this._gl.stencilFuncSeparate(this._gl.FRONT, this._stencilCompareModeFront, referenceValue, readMask);
	        //     this._gl.stencilFuncSeparate(this._gl.BACK, this._stencilCompareModeBack, referenceValue, readMask);
	        // }
	        // else {
	        //     this._gl.stencilFunc(this._stencilCompareMode, referenceValue, readMask);
	        // }
	        //
	        // this._gl.stencilMask(writeMask);
	    };
	    ContextGLES.prototype.setProgram = function (program) {
	        // //TODO decide on construction/reference resposibilities
	        // this._currentProgram = program;
	        // program.focusProgram();
	    };
	    ContextGLES.prototype.setProgramConstantsFromArray = function (programType, data) {
	        // if (data.length)
	        // 	this._gl.uniform4fv(this._currentProgram.getUniformLocation(programType), data);
	    };
	    ContextGLES.prototype.setScissorRectangle = function (rectangle) {
	        // if (!rectangle) {
	        // 	this._gl.disable(this._gl.SCISSOR_TEST);
	        // 	return;
	        // }
	        //
	        // this._gl.enable(this._gl.SCISSOR_TEST);
	        // this._gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
	    };
	    ContextGLES.prototype.setTextureAt = function (sampler, texture) {
	        // var samplerState:SamplerState = this._samplerStates[sampler];
	        //
	        // if (this._activeTexture != sampler && (texture || samplerState.type)) {
	        // 	this._activeTexture = sampler;
	        // 	this._gl.activeTexture(this._textureIndexDictionary[sampler]);
	        // }
	        //
	        // if (!texture) {
	        // 	if (samplerState.type) {
	        // 		this._gl.bindTexture(samplerState.type, null);
	        // 		samplerState.type = null;
	        // 	}
	        //
	        // 	return;
	        // }
	        //
	        // var textureType:number = this._textureTypeDictionary[texture.textureType];
	        // samplerState.type = textureType;
	        //
	        // this._gl.bindTexture(textureType, texture.glTexture);
	        //
	        // this._gl.uniform1i(this._currentProgram.getUniformLocation(ContextGLProgramType.SAMPLER, sampler), sampler);
	        //
	        // this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, samplerState.wrap);
	        // this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, samplerState.wrap);
	        //
	        // this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, samplerState.filter);
	        // this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, samplerState.mipfilter);
	    };
	    ContextGLES.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
	        // if (0 <= sampler && sampler < ContextGLES.MAX_SAMPLERS) {
	        // 	this._samplerStates[sampler].wrap = this._wrapDictionary[wrap];
	        // 	this._samplerStates[sampler].filter = this._filterDictionary[filter];
	        // 	this._samplerStates[sampler].mipfilter = this._mipmapFilterDictionary[filter][mipfilter];
	        // } else {
	        // 	throw "Sampler is out of bounds.";
	        // }
	    };
	    ContextGLES.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
	        if (bufferOffset === void 0) { bufferOffset = 0; }
	        if (format === void 0) { format = 4; }
	        // var location:number = this._currentProgram? this._currentProgram.getAttribLocation(index) : -1;
	        //
	        // if (!buffer) {
	        // 	if (location > -1)
	        // 		this._gl.disableVertexAttribArray(location);
	        //
	        // 	return;
	        // }
	        //
	        // //buffer may not have changed if concatenated buffers are being used
	        // if (this._currentArrayBuffer != buffer) {
	        // 	this._currentArrayBuffer = buffer;
	        // 	this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer? buffer.glBuffer : null);
	        // }
	        //
	        // var properties:VertexBufferProperties = this._vertexBufferPropertiesDictionary[format];
	        //
	        // this._gl.enableVertexAttribArray(location);
	        // this._gl.vertexAttribPointer(location, properties.size, properties.type, properties.normalized, buffer.dataPerVertex, bufferOffset);
	    };
	    ContextGLES.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
	        if (antiAlias === void 0) { antiAlias = 0; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        // var texture:TextureGLES = <TextureGLES> target;
	        // var frameBuffer:WebGLFramebuffer = texture.frameBuffer;
	        // this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);
	        //
	        // if (enableDepthAndStencil) {
	        // 	this._gl.enable(this._gl.STENCIL_TEST);
	        // 	this._gl.enable(this._gl.DEPTH_TEST);
	        // }
	        //
	        // this._gl.viewport(0, 0, texture.width, texture.height );
	    };
	    ContextGLES.prototype.setRenderToBackBuffer = function () {
	        // this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
	    };
	    ContextGLES.prototype.updateBlendStatus = function () {
	        // if (this._blendEnabled) {
	        // 	this._gl.enable(this._gl.BLEND);
	        // 	this._gl.blendEquation(this._gl.FUNC_ADD);
	        // 	this._gl.blendFunc(this._blendSourceFactor, this._blendDestinationFactor);
	        // } else {
	        // 	this._gl.disable(this._gl.BLEND);
	        // }
	    };
	    ContextGLES.prototype.translateTriangleFace = function (triangleFace, coordinateSystem) {
	        // switch (triangleFace) {
	        //     case ContextGLTriangleFace.BACK:
	        //         return (coordinateSystem == "leftHanded")? this._gl.FRONT : this._gl.BACK;
	        //     case ContextGLTriangleFace.FRONT:
	        //         return (coordinateSystem == "leftHanded")? this._gl.BACK : this._gl.FRONT;
	        //     case ContextGLTriangleFace.FRONT_AND_BACK:
	        //         return this._gl.FRONT_AND_BACK;
	        //     default:
	        //         throw "Unknown ContextGLTriangleFace type."; // TODO error
	        // }
	    };
	    ContextGLES.MAX_SAMPLERS = 8;
	    ContextGLES.modulo = 0;
	    return ContextGLES;
	}());
	exports.ContextGLES = ContextGLES;
	var VertexBufferProperties = (function () {
	    function VertexBufferProperties(size, type, normalized) {
	        this.size = size;
	        this.type = type;
	        this.normalized = normalized;
	    }
	    return VertexBufferProperties;
	}());
	exports.VertexBufferProperties = VertexBufferProperties;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBaseGLES_1 = __webpack_require__(65);
	var CubeTextureGLES = (function (_super) {
	    __extends(CubeTextureGLES, _super);
	    function CubeTextureGLES(gl, size) {
	        _super.call(this, gl);
	        this._textureSelectorDictionary = new Array(6);
	        this.textureType = "textureCube";
	        this._size = size;
	        // this._glTexture = this._gl.createTexture();
	        //
	        // this._textureSelectorDictionary[0] = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
	        // this._textureSelectorDictionary[1] = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
	        // this._textureSelectorDictionary[2] = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
	        // this._textureSelectorDictionary[3] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
	        // this._textureSelectorDictionary[4] = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
	        // this._textureSelectorDictionary[5] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
	    }
	    CubeTextureGLES.prototype.uploadFromData = function (data, side, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        // this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._glTexture);
	        // this._gl.texImage2D(this._textureSelectorDictionary[side], miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
	        // this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
	    };
	    CubeTextureGLES.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
	        if (async === void 0) { async = false; }
	    };
	    Object.defineProperty(CubeTextureGLES.prototype, "size", {
	        get: function () {
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CubeTextureGLES;
	}(TextureBaseGLES_1.TextureBaseGLES));
	exports.CubeTextureGLES = CubeTextureGLES;


/***/ },
/* 65 */
/***/ function(module, exports) {

	"use strict";
	var TextureBaseGLES = (function () {
	    function TextureBaseGLES(gl) {
	        this.textureType = "";
	        // this._gl = gl;
	    }
	    TextureBaseGLES.prototype.dispose = function () {
	        // this._gl.deleteTexture(this._glTexture);
	    };
	    Object.defineProperty(TextureBaseGLES.prototype, "glTexture", {
	        get: function () {
	            return this._glTexture;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureBaseGLES.prototype.generateMipmaps = function () {
	        // this._gl.bindTexture( this._gl.TEXTURE_2D, this._glTexture );
	        // this._gl.generateMipmap(this._gl.TEXTURE_2D);
	        // //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
	    };
	    return TextureBaseGLES;
	}());
	exports.TextureBaseGLES = TextureBaseGLES;


/***/ },
/* 66 */
/***/ function(module, exports) {

	"use strict";
	var IndexBufferGLES = (function () {
	    function IndexBufferGLES(gl, numIndices) {
	        this._gl = gl;
	        // this._buffer = this._gl.createBuffer();
	        this._numIndices = numIndices;
	    }
	    IndexBufferGLES.prototype.uploadFromArray = function (data, startOffset, count) {
	        // this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	        //
	        // if (startOffset)
	        // 	this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset*2, new Uint16Array(data));
	        // else
	        // 	this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this._gl.STATIC_DRAW);
	    };
	    IndexBufferGLES.prototype.uploadFromByteArray = function (data, startOffset, count) {
	        // this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	        //
	        // if (startOffset)
	        // 	this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset*2, data);
	        // else
	        // 	this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
	    };
	    IndexBufferGLES.prototype.dispose = function () {
	        // this._gl.deleteBuffer(this._buffer);
	    };
	    Object.defineProperty(IndexBufferGLES.prototype, "numIndices", {
	        get: function () {
	            return this._numIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(IndexBufferGLES.prototype, "glBuffer", {
	        get: function () {
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return IndexBufferGLES;
	}());
	exports.IndexBufferGLES = IndexBufferGLES;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AGALTokenizer_1 = __webpack_require__(68);
	var AGLSLParser_1 = __webpack_require__(75);
	var ProgramGLES = (function () {
	    function ProgramGLES(gl) {
	        this._uniforms = [[], [], []];
	        this._attribs = [];
	        // this._gl = gl;
	        // this._program = this._gl.createProgram();
	    }
	    ProgramGLES.prototype.upload = function (vertexProgram, fragmentProgram) {
	        // var vertexString:string = ProgramGLES._aglslParser.parse(ProgramGLES._tokenizer.decribeAGALByteArray(vertexProgram));
	        // var fragmentString:string = ProgramGLES._aglslParser.parse(ProgramGLES._tokenizer.decribeAGALByteArray(fragmentProgram));
	        //
	        // this._vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);
	        // this._fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
	        //
	        // this._gl.shaderSource(this._vertexShader, vertexString);
	        // this._gl.compileShader(this._vertexShader);
	        //
	        // if (!this._gl.getShaderParameter(this._vertexShader, this._gl.COMPILE_STATUS))
	        // 	throw new Error(this._gl.getShaderInfoLog(this._vertexShader));
	        //
	        // this._gl.shaderSource(this._fragmentShader, fragmentString);
	        // this._gl.compileShader(this._fragmentShader);
	        //
	        // if (!this._gl.getShaderParameter(this._fragmentShader, this._gl.COMPILE_STATUS))
	        // 	throw new Error(this._gl.getShaderInfoLog(this._fragmentShader));
	        //
	        // this._gl.attachShader(this._program, this._vertexShader);
	        // this._gl.attachShader(this._program, this._fragmentShader);
	        // this._gl.linkProgram(this._program);
	        //
	        // if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS))
	        // 	throw new Error(this._gl.getProgramInfoLog(this._program));
	        //
	        // this._uniforms[0].length = 0;
	        // this._uniforms[1].length = 0;
	        // this._uniforms[2].length = 0;
	        // this._attribs.length = 0;
	    };
	    ProgramGLES.prototype.getUniformLocation = function (programType, index) {
	        if (index === void 0) { index = -1; }
	        // if (this._uniforms[programType][index + 1] != null)
	        // 	return this._uniforms[programType][index + 1];
	        //
	        // var name:string =  (index == -1)? ProgramGLES._uniformLocationNameDictionary[programType] : ProgramGLES._uniformLocationNameDictionary[programType] + index;
	        // return (this._uniforms[programType][index + 1] = this._gl.getUniformLocation(this._program, name));
	        return null;
	    };
	    //
	    // public getUniformLocation(programType:number, index:number):WebGLUniformLocation
	    // {
	    // 	if (this._uniforms[programType][index] != null)
	    // 		return this._uniforms[programType][index];
	    //
	    // 	return (this._uniforms[programType][index] = this._gl.getUniformLocation(this._program, ProgramGLES._uniformLocationNameDictionary[programType] + index));
	    // }
	    ProgramGLES.prototype.getAttribLocation = function (index) {
	        // if (this._attribs[index] != null)
	        // 	return this._attribs[index];
	        //
	        // return (this._attribs[index] = this._gl.getAttribLocation(this._program, "va" + index));
	        return 0;
	    };
	    ProgramGLES.prototype.dispose = function () {
	        // this._gl.deleteProgram(this._program);
	    };
	    ProgramGLES.prototype.focusProgram = function () {
	        // this._gl.useProgram(this._program);
	    };
	    Object.defineProperty(ProgramGLES.prototype, "glProgram", {
	        get: function () {
	            return this._program;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProgramGLES._tokenizer = new AGALTokenizer_1.AGALTokenizer();
	    ProgramGLES._aglslParser = new AGLSLParser_1.AGLSLParser();
	    ProgramGLES._uniformLocationNameDictionary = ["fc", "fs", "vc"];
	    return ProgramGLES;
	}());
	exports.ProgramGLES = ProgramGLES;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Description_1 = __webpack_require__(69);
	var Header_1 = __webpack_require__(70);
	var Mapping_1 = __webpack_require__(71);
	var Token_1 = __webpack_require__(73);
	var AGALTokenizer = (function () {
	    function AGALTokenizer() {
	    }
	    AGALTokenizer.prototype.decribeAGALByteArray = function (bytes) {
	        var header = new Header_1.Header();
	        if (bytes.readUnsignedByte() != 0xa0) {
	            throw "Bad AGAL: Missing 0xa0 magic byte.";
	        }
	        header.version = bytes.readUnsignedInt();
	        if (header.version >= 0x10) {
	            bytes.readUnsignedByte();
	            header.version >>= 1;
	        }
	        if (bytes.readUnsignedByte() != 0xa1) {
	            throw "Bad AGAL: Missing 0xa1 magic byte.";
	        }
	        header.progid = bytes.readUnsignedByte();
	        switch (header.progid) {
	            case 1:
	                header.type = "fragment";
	                break;
	            case 0:
	                header.type = "vertex";
	                break;
	            case 2:
	                header.type = "cpu";
	                break;
	            default:
	                header.type = "";
	                break;
	        }
	        var desc = new Description_1.Description();
	        var tokens = [];
	        while (bytes.position < bytes.length) {
	            var token = new Token_1.Token();
	            token.opcode = bytes.readUnsignedInt();
	            var lutentry = Mapping_1.Mapping.agal2glsllut[token.opcode];
	            if (!lutentry) {
	                throw "Opcode not valid or not implemented yet: " + token.opcode;
	            }
	            if (lutentry.matrixheight) {
	                desc.hasmatrix = true;
	            }
	            if (lutentry.dest) {
	                token.dest.regnum = bytes.readUnsignedShort();
	                token.dest.mask = bytes.readUnsignedByte();
	                token.dest.regtype = bytes.readUnsignedByte();
	                desc.regwrite[token.dest.regtype][token.dest.regnum] |= token.dest.mask;
	            }
	            else {
	                token.dest = null;
	                bytes.readUnsignedInt();
	            }
	            if (lutentry.a) {
	                this.readReg(token.a, 1, desc, bytes);
	            }
	            else {
	                token.a = null;
	                bytes.readUnsignedInt();
	                bytes.readUnsignedInt();
	            }
	            if (lutentry.b) {
	                this.readReg(token.b, lutentry.matrixheight | 0, desc, bytes);
	            }
	            else {
	                token.b = null;
	                bytes.readUnsignedInt();
	                bytes.readUnsignedInt();
	            }
	            tokens.push(token);
	        }
	        desc.header = header;
	        desc.tokens = tokens;
	        return desc;
	    };
	    AGALTokenizer.prototype.readReg = function (s, mh, desc, bytes) {
	        s.regnum = bytes.readUnsignedShort();
	        s.indexoffset = bytes.readByte();
	        s.swizzle = bytes.readUnsignedByte();
	        s.regtype = bytes.readUnsignedByte();
	        desc.regread[s.regtype][s.regnum] = 0xf; // sould be swizzle to mask? should be |=                                                 
	        if (s.regtype == 0x5) {
	            // sampler
	            s.lodbiad = s.indexoffset;
	            s.indexoffset = undefined;
	            s.swizzle = undefined;
	            // sampler 
	            s.readmode = bytes.readUnsignedByte();
	            s.dim = s.readmode >> 4;
	            s.readmode &= 0xf;
	            s.special = bytes.readUnsignedByte();
	            s.wrap = s.special >> 4;
	            s.special &= 0xf;
	            s.mipmap = bytes.readUnsignedByte();
	            s.filter = s.mipmap >> 4;
	            s.mipmap &= 0xf;
	            desc.samplers[s.regnum] = s;
	        }
	        else {
	            s.indexregtype = bytes.readUnsignedByte();
	            s.indexselect = bytes.readUnsignedByte();
	            s.indirectflag = bytes.readUnsignedByte();
	        }
	        if (s.indirectflag) {
	            desc.hasindirect = true;
	        }
	        if (!s.indirectflag && mh) {
	            for (var mhi = 0; mhi < mh; mhi++) {
	                desc.regread[s.regtype][s.regnum + mhi] = desc.regread[s.regtype][s.regnum];
	            }
	        }
	    };
	    return AGALTokenizer;
	}());
	exports.AGALTokenizer = AGALTokenizer;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Header_1 = __webpack_require__(70);
	var Description = (function () {
	    function Description() {
	        this.regread = [
	            [],
	            [],
	            [],
	            [],
	            [],
	            [],
	            []
	        ];
	        this.regwrite = [
	            [],
	            [],
	            [],
	            [],
	            [],
	            [],
	            []
	        ];
	        this.hasindirect = false;
	        this.writedepth = false;
	        this.hasmatrix = false;
	        this.samplers = [];
	        // added due to dynamic assignment 3*0xFFFFFFuuuu
	        this.tokens = [];
	        this.header = new Header_1.Header();
	    }
	    return Description;
	}());
	exports.Description = Description;


/***/ },
/* 70 */
/***/ function(module, exports) {

	"use strict";
	var Header = (function () {
	    function Header() {
	        this.progid = 0;
	        this.version = 0;
	        this.type = "";
	    }
	    return Header;
	}());
	exports.Header = Header;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var OpLUT_1 = __webpack_require__(72);
	var Mapping = (function () {
	    //TODO: get rid of hack that fixes including definition file
	    function Mapping(include) {
	    }
	    Mapping.agal2glsllut = [
	        //         s 												flags   dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
	        new OpLUT_1.OpLUT("%dest = %cast(%a);\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(%a + %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(%a - %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(%a * %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(%a / %b);\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(1.0) / %a;\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(min(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(max(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(fract(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(sqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(inversesqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(pow(abs(%a),%b));\n", 0, true, true, true, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(log2(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(exp2(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        //         s 												flags  	dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
	        new OpLUT_1.OpLUT("%dest = %cast(normalize(vec3( %a ) ));\n", 0, true, true, false, null, null, true, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(sin(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(cos(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(cross(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(abs(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(%a * -1.0);\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(clamp(%a,0.0,1.0));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", null, true, true, true, 3, 3, true, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 4, true, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 3, true, null, null, null),
	        //s:string, flags:number, dest:boolean, a:boolean, b:boolean, matrixwidth:number, matrixheight:number, ndwm:boolean, scaler:boolean, dm:boolean, lod:boolean
	        new OpLUT_1.OpLUT("%dest = %cast(dFdx(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("%dest = %cast(dFdy(%a));\n", 0, true, true, false, null, null, null, null, null, null),
	        new OpLUT_1.OpLUT("if (float(%a)==float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.OpLUT("if (float(%a)!=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.OpLUT("if (float(%a)>=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.OpLUT("if (float(%a)<float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT_1.OpLUT("} else {;\n", 0, false, false, false, null, null, null, null, null, null), new OpLUT_1.OpLUT("};\n", 0, false, false, false, null, null, null, null, null, null), new OpLUT_1.OpLUT(null, null, null, null, false, null, null, null, null, null, null), new OpLUT_1.OpLUT(null, null, null, null, false, null, null, null, null, null, null), new OpLUT_1.OpLUT(null, null, null, null, false, null, null, null, null, null, null), new OpLUT_1.OpLUT(null, null, null, null, false, null, null, null, null, null, null),
	        //         s 															flags  	dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
	        new OpLUT_1.OpLUT("%dest = %cast(texture%texdimLod(%b,%texsize(%a)).%dm);\n", null, true, true, true, null, null, null, null, true, null), new OpLUT_1.OpLUT("if ( float(%a)<0.0 ) discard;\n", null, false, true, false, null, null, null, true, null, null), new OpLUT_1.OpLUT("%dest = %cast(texture%texdim(%b,%texsize(%a)%lod).%dm);\n", null, true, true, true, null, null, true, null, true, true), new OpLUT_1.OpLUT("%dest = %cast(greaterThanEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT_1.OpLUT("%dest = %cast(lessThan(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT_1.OpLUT("%dest = %cast(sign(%a));\n", 0, true, true, false, null, null, null, null, null, null), new OpLUT_1.OpLUT("%dest = %cast(equal(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT_1.OpLUT("%dest = %cast(notEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null)
	    ];
	    return Mapping;
	}());
	exports.Mapping = Mapping;


/***/ },
/* 72 */
/***/ function(module, exports) {

	"use strict";
	var OpLUT = (function () {
	    function OpLUT(s, flags, dest, a, b, matrixwidth, matrixheight, ndwm, scaler, dm, lod) {
	        this.s = s;
	        this.flags = flags;
	        this.dest = dest;
	        this.a = a;
	        this.b = b;
	        this.matrixwidth = matrixwidth;
	        this.matrixheight = matrixheight;
	        this.ndwm = ndwm;
	        this.scalar = scaler;
	        this.dm = dm;
	        this.lod = lod;
	    }
	    return OpLUT;
	}());
	exports.OpLUT = OpLUT;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Destination_1 = __webpack_require__(74);
	var Token = (function () {
	    function Token() {
	        this.dest = new Destination_1.Destination();
	        this.opcode = 0;
	        this.a = new Destination_1.Destination();
	        this.b = new Destination_1.Destination();
	    }
	    return Token;
	}());
	exports.Token = Token;


/***/ },
/* 74 */
/***/ function(module, exports) {

	"use strict";
	var Destination = (function () {
	    function Destination() {
	        this.mask = 0;
	        this.regnum = 0;
	        this.regtype = 0;
	        this.dim = 0;
	        this.indexoffset = 0;
	        this.swizzle = 0;
	        this.lodbiad = 0;
	        this.readmode = 0;
	        this.special = 0;
	        this.wrap = 0;
	        this.filter = 0;
	        this.indexregtype = 0;
	        this.indexselect = 0;
	        this.indirectflag = 0;
	    }
	    return Destination;
	}());
	exports.Destination = Destination;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Mapping_1 = __webpack_require__(71);
	var AGLSLParser = (function () {
	    function AGLSLParser() {
	    }
	    AGLSLParser.prototype.parse = function (desc) {
	        var header = "";
	        var body = "";
	        header += "precision highp float;\n";
	        var tag = desc.header.type[0]; //TODO
	        // declare uniforms
	        if (desc.header.type == "vertex") {
	            header += "uniform float yflip;\n";
	        }
	        // if (!desc.hasindirect) {
	        // 	for (var i:number = 0; i < desc.regread[0x1].length; i++) {
	        // 		if (desc.regread[0x1][i]) {
	        // 			header += "uniform vec4 " + tag + "c" + i + ";\n";
	        // 		}
	        // 	}
	        // } else {
	        // 	header += "uniform vec4 " + tag + "carrr[" + AGLSLParser.maxvertexconstants + "];\n";                // use max const count instead
	        // }
	        var constcount = desc.regread[0x1].length;
	        if (constcount > 0)
	            header += "uniform vec4 " + tag + "c[" + constcount + "];\n";
	        // declare temps
	        for (var i = 0; i < desc.regread[0x2].length || i < desc.regwrite[0x2].length; i++) {
	            if (desc.regread[0x2][i] || desc.regwrite[0x2][i]) {
	                header += "vec4 " + tag + "t" + i + ";\n";
	            }
	        }
	        // declare streams
	        for (var i = 0; i < desc.regread[0x0].length; i++) {
	            if (desc.regread[0x0][i]) {
	                header += "attribute vec4 va" + i + ";\n";
	            }
	        }
	        // declare interpolated
	        for (var i = 0; i < desc.regread[0x4].length || i < desc.regwrite[0x4].length; i++) {
	            if (desc.regread[0x4][i] || desc.regwrite[0x4][i]) {
	                header += "varying vec4 vi" + i + ";\n";
	            }
	        }
	        // declare samplers
	        var samptype = ["2D", "Cube", "3D", ""];
	        for (var i = 0; i < desc.samplers.length; i++) {
	            if (desc.samplers[i]) {
	                header += "uniform sampler" + samptype[desc.samplers[i].dim & 3] + " fs" + i + ";\n";
	            }
	        }
	        // extra gl fluff: setup position and depth adjust temps
	        if (desc.header.type == "vertex") {
	            header += "vec4 outpos;\n";
	        }
	        if (desc.writedepth) {
	            header += "vec4 tmp_FragDepth;\n";
	        }
	        //if ( desc.hasmatrix ) 
	        //    header += "vec4 tmp_matrix;\n";
	        var derivatives = false;
	        // start body of code
	        body += "void main() {\n";
	        for (var i = 0; i < desc.tokens.length; i++) {
	            var lutentry = Mapping_1.Mapping.agal2glsllut[desc.tokens[i].opcode];
	            if (lutentry.s.indexOf("dFdx") != -1 || lutentry.s.indexOf("dFdy") != -1)
	                derivatives = true;
	            if (!lutentry) {
	                throw "Opcode not valid or not implemented yet: ";
	            }
	            var sublines = lutentry.matrixheight || 1;
	            for (var sl = 0; sl < sublines; sl++) {
	                var line = "  " + lutentry.s;
	                if (desc.tokens[i].dest) {
	                    if (lutentry.matrixheight) {
	                        if (((desc.tokens[i].dest.mask >> sl) & 1) != 1) {
	                            continue;
	                        }
	                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
	                        var destcaststring = "float";
	                        var destmaskstring = ["x", "y", "z", "w"][sl];
	                        destregstring += "." + destmaskstring;
	                    }
	                    else {
	                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
	                        var destcaststring;
	                        var destmaskstring;
	                        if (desc.tokens[i].dest.mask != 0xf) {
	                            var ndest = 0;
	                            destmaskstring = "";
	                            if (desc.tokens[i].dest.mask & 1) {
	                                ndest++;
	                                destmaskstring += "x";
	                            }
	                            if (desc.tokens[i].dest.mask & 2) {
	                                ndest++;
	                                destmaskstring += "y";
	                            }
	                            if (desc.tokens[i].dest.mask & 4) {
	                                ndest++;
	                                destmaskstring += "z";
	                            }
	                            if (desc.tokens[i].dest.mask & 8) {
	                                ndest++;
	                                destmaskstring += "w";
	                            }
	                            destregstring += "." + destmaskstring;
	                            switch (ndest) {
	                                case 1:
	                                    destcaststring = "float";
	                                    break;
	                                case 2:
	                                    destcaststring = "vec2";
	                                    break;
	                                case 3:
	                                    destcaststring = "vec3";
	                                    break;
	                                default:
	                                    throw "Unexpected destination mask";
	                            }
	                        }
	                        else {
	                            destcaststring = "vec4";
	                            destmaskstring = "xyzw";
	                        }
	                    }
	                    line = line.replace("%dest", destregstring);
	                    line = line.replace("%cast", destcaststring);
	                    line = line.replace("%dm", destmaskstring);
	                }
	                var dwm = 0xf;
	                if (!lutentry.ndwm && lutentry.dest && desc.tokens[i].dest) {
	                    dwm = desc.tokens[i].dest.mask;
	                }
	                if (desc.tokens[i].a) {
	                    line = line.replace("%a", this.sourcetostring(desc.tokens[i].a, 0, dwm, lutentry.scalar, desc, tag));
	                }
	                if (desc.tokens[i].b) {
	                    line = line.replace("%b", this.sourcetostring(desc.tokens[i].b, sl, dwm, lutentry.scalar, desc, tag));
	                    if (desc.tokens[i].b.regtype == 0x5) {
	                        // sampler dim
	                        var texdim = ["2D", "Cube", "3D"][desc.tokens[i].b.dim];
	                        var texsize = ["vec2", "vec3", "vec3"][desc.tokens[i].b.dim];
	                        line = line.replace("%texdim", texdim);
	                        line = line.replace("%texsize", texsize);
	                        var texlod = "";
	                        line = line.replace("%lod", texlod);
	                    }
	                }
	                body += line;
	            }
	        }
	        // adjust z from opengl range of -1..1 to 0..1 as in d3d, this also enforces a left handed coordinate system
	        if (desc.header.type == "vertex") {
	            body += "  gl_Position = vec4(outpos.x, outpos.y, outpos.z*2.0 - outpos.w, outpos.w);\n";
	        }
	        //flag based switch
	        if (derivatives && desc.header.type == "fragment") {
	            header = "#extension GL_OES_standard_derivatives : enable\n" + header;
	        }
	        // clamp fragment depth
	        if (desc.writedepth) {
	            body += "  gl_FragDepth = clamp(tmp_FragDepth,0.0,1.0);\n";
	        }
	        // close main
	        body += "}\n";
	        return header + body;
	    };
	    AGLSLParser.prototype.regtostring = function (regtype, regnum, desc, tag) {
	        switch (regtype) {
	            case 0x0:
	                return "va" + regnum;
	            case 0x1:
	                return desc.header.type[0] + "c[" + regnum + "]";
	            // case 0x1:
	            // 	if (desc.hasindirect && desc.header.type == "vertex") {
	            // 		return "vcarrr[" + regnum + "]";
	            // 	} else {
	            // 		return tag + "c" + regnum;
	            // 	}
	            case 0x2:
	                return tag + "t" + regnum;
	            case 0x3:
	                return desc.header.type == "vertex" ? "outpos" : "gl_FragColor";
	            case 0x4:
	                return "vi" + regnum;
	            case 0x5:
	                return "fs" + regnum;
	            case 0x6:
	                return "tmp_FragDepth";
	            default:
	                throw "Unknown register type";
	        }
	    };
	    AGLSLParser.prototype.sourcetostring = function (s, subline, dwm, isscalar, desc, tag) {
	        var swiz = ["x", "y", "z", "w"];
	        var r;
	        if (s.indirectflag) {
	            r = "vcarrr[int(" + this.regtostring(s.indexregtype, s.regnum, desc, tag) + "." + swiz[s.indexselect] + ")";
	            var realofs = subline + s.indexoffset;
	            if (realofs < 0)
	                r += realofs.toString();
	            if (realofs > 0)
	                r += "+" + realofs.toString();
	            r += "]";
	        }
	        else {
	            r = this.regtostring(s.regtype, s.regnum + subline, desc, tag);
	        }
	        // samplers never add swizzle        
	        if (s.regtype == 0x5) {
	            return r;
	        }
	        // scalar, first component only
	        if (isscalar) {
	            return r + "." + swiz[(s.swizzle >> 0) & 3];
	        }
	        // identity
	        if (s.swizzle == 0xe4 && dwm == 0xf) {
	            return r;
	        }
	        // with destination write mask folded in
	        r += ".";
	        if (dwm & 1)
	            r += swiz[(s.swizzle >> 0) & 3];
	        if (dwm & 2)
	            r += swiz[(s.swizzle >> 2) & 3];
	        if (dwm & 4)
	            r += swiz[(s.swizzle >> 4) & 3];
	        if (dwm & 8)
	            r += swiz[(s.swizzle >> 6) & 3];
	        return r;
	    };
	    AGLSLParser.maxvertexconstants = 128;
	    AGLSLParser.maxfragconstants = 28;
	    AGLSLParser.maxtemp = 8;
	    AGLSLParser.maxstreams = 8;
	    AGLSLParser.maxtextures = 8;
	    return AGLSLParser;
	}());
	exports.AGLSLParser = AGLSLParser;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBaseGLES_1 = __webpack_require__(65);
	var TextureGLES = (function (_super) {
	    __extends(TextureGLES, _super);
	    function TextureGLES(gl, width, height) {
	        _super.call(this, gl);
	        this.textureType = "texture2d";
	        this._width = width;
	        this._height = height;
	        //
	        // this._glTexture = this._gl.createTexture();
	    }
	    Object.defineProperty(TextureGLES.prototype, "width", {
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureGLES.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureGLES.prototype, "frameBuffer", {
	        get: function () {
	            // if (!this._frameBuffer) {
	            // 	this._frameBuffer = this._gl.createFramebuffer();
	            // 	this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
	            // 	this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
	            // 	this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._width, this._height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
	            //
	            // 	var renderBuffer:GLESRenderbuffer = this._gl.createRenderbuffer();
	            // 	this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
	            // 	this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_STENCIL, this._width, this._height);
	            //
	            // 	this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._glTexture, 0);
	            // 	this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_STENCIL_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
	            //
	            // 	this._gl.bindTexture(this._gl.TEXTURE_2D, null);
	            // 	this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
	            // 	this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
	            // }
	            return this._frameBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureGLES.prototype.uploadFromData = function (data, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        // this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
	        // this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
	        // this._gl.bindTexture(this._gl.TEXTURE_2D, null);
	    };
	    TextureGLES.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
	        if (async === void 0) { async = false; }
	        // var ext:Object = this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
	        // //this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this)
	    };
	    return TextureGLES;
	}(TextureBaseGLES_1.TextureBaseGLES));
	exports.TextureGLES = TextureGLES;


/***/ },
/* 77 */
/***/ function(module, exports) {

	"use strict";
	var VertexBufferGLES = (function () {
	    function VertexBufferGLES(gl, numVertices, dataPerVertex) {
	        // this._gl = gl;
	        // this._buffer = this._gl.createBuffer();
	        this._numVertices = numVertices;
	        this._dataPerVertex = dataPerVertex;
	    }
	    VertexBufferGLES.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
	        // this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
	        //
	        // if (startVertex)
	        // 	this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex*this._dataPerVertex, new Float32Array(vertices));
	        // else
	        // 	this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);
	    };
	    VertexBufferGLES.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
	        // this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
	        //
	        // if (startVertex)
	        // 	this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex*this._dataPerVertex, data);
	        // else
	        // 	this._gl.bufferData(this._gl.ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
	    };
	    Object.defineProperty(VertexBufferGLES.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferGLES.prototype, "dataPerVertex", {
	        get: function () {
	            return this._dataPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferGLES.prototype, "glBuffer", {
	        get: function () {
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    VertexBufferGLES.prototype.dispose = function () {
	        // this._gl.deleteBuffer(this._buffer);
	    };
	    return VertexBufferGLES;
	}());
	exports.VertexBufferGLES = VertexBufferGLES;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Rectangle_1 = __webpack_require__(57);
	var ContextGLBlendFactor_1 = __webpack_require__(41);
	var ContextGLDrawMode_1 = __webpack_require__(44);
	var ContextGLClearMask_1 = __webpack_require__(42);
	var ContextGLCompareMode_1 = __webpack_require__(43);
	var ContextGLMipFilter_1 = __webpack_require__(45);
	var ContextGLProgramType_1 = __webpack_require__(47);
	var ContextGLStencilAction_1 = __webpack_require__(48);
	var ContextGLTextureFilter_1 = __webpack_require__(49);
	var ContextGLTriangleFace_1 = __webpack_require__(51);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ContextGLWrapMode_1 = __webpack_require__(53);
	var SamplerState_1 = __webpack_require__(55);
	var CubeTextureWebGL_1 = __webpack_require__(79);
	var IndexBufferWebGL_1 = __webpack_require__(81);
	var ProgramWebGL_1 = __webpack_require__(82);
	var TextureWebGL_1 = __webpack_require__(83);
	var VertexBufferWebGL_1 = __webpack_require__(84);
	var ContextWebGL = (function () {
	    function ContextWebGL(canvas) {
	        this._blendFactorDictionary = new Object();
	        this._drawModeDictionary = new Object();
	        this._compareModeDictionary = new Object();
	        this._stencilActionDictionary = new Object();
	        this._textureIndexDictionary = new Array(8);
	        this._textureTypeDictionary = new Object();
	        this._wrapDictionary = new Object();
	        this._filterDictionary = new Object();
	        this._mipmapFilterDictionary = new Object();
	        this._vertexBufferPropertiesDictionary = [];
	        this._samplerStates = new Array(8);
	        this._stencilReferenceValue = 0;
	        this._stencilReadMask = 0xff;
	        this._separateStencil = false;
	        this._container = canvas;
	        try {
	            this._gl = canvas.getContext("experimental-webgl", { premultipliedAlpha: false, alpha: false, stencil: true });
	            if (!this._gl)
	                this._gl = canvas.getContext("webgl", { premultipliedAlpha: false, alpha: false, stencil: true });
	        }
	        catch (e) {
	        }
	        if (this._gl) {
	            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_SUCCESS ) );
	            if (this._gl.getExtension("OES_standard_derivatives")) {
	                this._standardDerivatives = true;
	            }
	            else {
	                this._standardDerivatives = false;
	            }
	            //setup shortcut dictionaries
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.ONE] = this._gl.ONE;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.DESTINATION_ALPHA] = this._gl.DST_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.DESTINATION_COLOR] = this._gl.DST_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.ONE] = this._gl.ONE;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA] = this._gl.ONE_MINUS_DST_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR] = this._gl.ONE_MINUS_DST_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA] = this._gl.ONE_MINUS_SRC_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR] = this._gl.ONE_MINUS_SRC_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.SOURCE_ALPHA] = this._gl.SRC_ALPHA;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.SOURCE_COLOR] = this._gl.SRC_COLOR;
	            this._blendFactorDictionary[ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO] = this._gl.ZERO;
	            this._drawModeDictionary[ContextGLDrawMode_1.ContextGLDrawMode.LINES] = this._gl.LINES;
	            this._drawModeDictionary[ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES] = this._gl.TRIANGLES;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.ALWAYS] = this._gl.ALWAYS;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.EQUAL] = this._gl.EQUAL;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.GREATER] = this._gl.GREATER;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.GREATER_EQUAL] = this._gl.GEQUAL;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.LESS] = this._gl.LESS;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL] = this._gl.LEQUAL;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.NEVER] = this._gl.NEVER;
	            this._compareModeDictionary[ContextGLCompareMode_1.ContextGLCompareMode.NOT_EQUAL] = this._gl.NOTEQUAL;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.DECREMENT_SATURATE] = this._gl.DECR;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.DECREMENT_WRAP] = this._gl.DECR_WRAP;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.INCREMENT_SATURATE] = this._gl.INCR;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.INCREMENT_WRAP] = this._gl.INCR_WRAP;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.INVERT] = this._gl.INVERT;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.KEEP] = this._gl.KEEP;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.SET] = this._gl.REPLACE;
	            this._stencilActionDictionary[ContextGLStencilAction_1.ContextGLStencilAction.ZERO] = this._gl.ZERO;
	            this._textureIndexDictionary[0] = this._gl.TEXTURE0;
	            this._textureIndexDictionary[1] = this._gl.TEXTURE1;
	            this._textureIndexDictionary[2] = this._gl.TEXTURE2;
	            this._textureIndexDictionary[3] = this._gl.TEXTURE3;
	            this._textureIndexDictionary[4] = this._gl.TEXTURE4;
	            this._textureIndexDictionary[5] = this._gl.TEXTURE5;
	            this._textureIndexDictionary[6] = this._gl.TEXTURE6;
	            this._textureIndexDictionary[7] = this._gl.TEXTURE7;
	            this._textureTypeDictionary["texture2d"] = this._gl.TEXTURE_2D;
	            this._textureTypeDictionary["textureCube"] = this._gl.TEXTURE_CUBE_MAP;
	            this._wrapDictionary[ContextGLWrapMode_1.ContextGLWrapMode.REPEAT] = this._gl.REPEAT;
	            this._wrapDictionary[ContextGLWrapMode_1.ContextGLWrapMode.CLAMP] = this._gl.CLAMP_TO_EDGE;
	            this._filterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR] = this._gl.LINEAR;
	            this._filterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.NEAREST] = this._gl.NEAREST;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR] = new Object();
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR][ContextGLMipFilter_1.ContextGLMipFilter.MIPNEAREST] = this._gl.LINEAR_MIPMAP_NEAREST;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR][ContextGLMipFilter_1.ContextGLMipFilter.MIPLINEAR] = this._gl.LINEAR_MIPMAP_LINEAR;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR][ContextGLMipFilter_1.ContextGLMipFilter.MIPNONE] = this._gl.LINEAR;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.NEAREST] = new Object();
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.NEAREST][ContextGLMipFilter_1.ContextGLMipFilter.MIPNEAREST] = this._gl.NEAREST_MIPMAP_NEAREST;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.NEAREST][ContextGLMipFilter_1.ContextGLMipFilter.MIPLINEAR] = this._gl.NEAREST_MIPMAP_LINEAR;
	            this._mipmapFilterDictionary[ContextGLTextureFilter_1.ContextGLTextureFilter.NEAREST][ContextGLMipFilter_1.ContextGLMipFilter.MIPNONE] = this._gl.NEAREST;
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_1] = new VertexBufferProperties(1, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2] = new VertexBufferProperties(2, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3] = new VertexBufferProperties(3, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4] = new VertexBufferProperties(4, this._gl.FLOAT, false);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_1] = new VertexBufferProperties(1, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_2] = new VertexBufferProperties(2, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_3] = new VertexBufferProperties(3, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.BYTE_4] = new VertexBufferProperties(4, this._gl.BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_1] = new VertexBufferProperties(1, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_2] = new VertexBufferProperties(2, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_3] = new VertexBufferProperties(3, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_4] = new VertexBufferProperties(4, this._gl.UNSIGNED_BYTE, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_1] = new VertexBufferProperties(1, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_2] = new VertexBufferProperties(2, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_3] = new VertexBufferProperties(3, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.SHORT_4] = new VertexBufferProperties(4, this._gl.SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_1] = new VertexBufferProperties(1, this._gl.UNSIGNED_SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_2] = new VertexBufferProperties(2, this._gl.UNSIGNED_SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_3] = new VertexBufferProperties(3, this._gl.UNSIGNED_SHORT, true);
	            this._vertexBufferPropertiesDictionary[ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_SHORT_4] = new VertexBufferProperties(4, this._gl.UNSIGNED_SHORT, true);
	            this._stencilCompareMode = this._gl.ALWAYS;
	            this._stencilCompareModeBack = this._gl.ALWAYS;
	            this._stencilCompareModeFront = this._gl.ALWAYS;
	        }
	        else {
	            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
	            alert("WebGL is not available.");
	        }
	        //defaults
	        for (var i = 0; i < ContextWebGL.MAX_SAMPLERS; ++i) {
	            this._samplerStates[i] = new SamplerState_1.SamplerState();
	            this._samplerStates[i].wrap = this._gl.REPEAT;
	            this._samplerStates[i].filter = this._gl.LINEAR;
	            this._samplerStates[i].mipfilter = this._gl.LINEAR;
	        }
	    }
	    Object.defineProperty(ContextWebGL.prototype, "container", {
	        get: function () {
	            return this._container;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ContextWebGL.prototype, "standardDerivatives", {
	        get: function () {
	            return this._standardDerivatives;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ContextWebGL.prototype.gl = function () {
	        return this._gl;
	    };
	    ContextWebGL.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
	        if (red === void 0) { red = 0; }
	        if (green === void 0) { green = 0; }
	        if (blue === void 0) { blue = 0; }
	        if (alpha === void 0) { alpha = 1; }
	        if (depth === void 0) { depth = 1; }
	        if (stencil === void 0) { stencil = 0; }
	        if (mask === void 0) { mask = ContextGLClearMask_1.ContextGLClearMask.ALL; }
	        if (!this._drawing) {
	            this.updateBlendStatus();
	            this._drawing = true;
	        }
	        var glmask = 0;
	        if (mask & ContextGLClearMask_1.ContextGLClearMask.COLOR)
	            glmask |= this._gl.COLOR_BUFFER_BIT;
	        if (mask & ContextGLClearMask_1.ContextGLClearMask.STENCIL)
	            glmask |= this._gl.STENCIL_BUFFER_BIT;
	        if (mask & ContextGLClearMask_1.ContextGLClearMask.DEPTH)
	            glmask |= this._gl.DEPTH_BUFFER_BIT;
	        this._gl.clearColor(red, green, blue, alpha);
	        this._gl.clearDepth(depth);
	        this._gl.clearStencil(stencil);
	        this._gl.clear(glmask);
	    };
	    ContextWebGL.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
	        this._width = width;
	        this._height = height;
	        if (enableDepthAndStencil) {
	            this._gl.enable(this._gl.STENCIL_TEST);
	            this._gl.enable(this._gl.DEPTH_TEST);
	        }
	        this._gl.viewport['width'] = width;
	        this._gl.viewport['height'] = height;
	        this._gl.viewport(0, 0, width, height);
	    };
	    ContextWebGL.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        return new CubeTextureWebGL_1.CubeTextureWebGL(this._gl, size);
	    };
	    ContextWebGL.prototype.createIndexBuffer = function (numIndices) {
	        return new IndexBufferWebGL_1.IndexBufferWebGL(this._gl, numIndices);
	    };
	    ContextWebGL.prototype.createProgram = function () {
	        return new ProgramWebGL_1.ProgramWebGL(this._gl);
	    };
	    ContextWebGL.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        //TODO streaming
	        return new TextureWebGL_1.TextureWebGL(this._gl, width, height);
	    };
	    ContextWebGL.prototype.createVertexBuffer = function (numVertices, dataPerVertex) {
	        return new VertexBufferWebGL_1.VertexBufferWebGL(this._gl, numVertices, dataPerVertex);
	    };
	    ContextWebGL.prototype.dispose = function () {
	        for (var i = 0; i < this._samplerStates.length; ++i)
	            this._samplerStates[i] = null;
	    };
	    ContextWebGL.prototype.drawToBitmapImage2D = function (destination) {
	        var pixels = new Uint8ClampedArray(destination.width * destination.height * 4);
	        this._gl.readPixels(0, 0, destination.width, destination.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixels);
	        destination.setPixels(new Rectangle_1.Rectangle(0, 0, destination.width, destination.height), pixels);
	    };
	    ContextWebGL.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
	        if (firstIndex === void 0) { firstIndex = 0; }
	        if (numIndices === void 0) { numIndices = -1; }
	        if (!this._drawing)
	            throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
	        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
	        this._gl.drawElements(this._drawModeDictionary[mode], (numIndices == -1) ? indexBuffer.numIndices : numIndices, this._gl.UNSIGNED_SHORT, firstIndex * 2);
	    };
	    ContextWebGL.prototype.drawVertices = function (mode, firstVertex, numVertices) {
	        if (firstVertex === void 0) { firstVertex = 0; }
	        if (numVertices === void 0) { numVertices = -1; }
	        if (!this._drawing)
	            throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
	        this._gl.drawArrays(this._drawModeDictionary[mode], firstVertex, numVertices);
	    };
	    ContextWebGL.prototype.present = function () {
	        this._drawing = false;
	    };
	    ContextWebGL.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
	        this._blendEnabled = true;
	        this._blendSourceFactor = this._blendFactorDictionary[sourceFactor];
	        this._blendDestinationFactor = this._blendFactorDictionary[destinationFactor];
	        this.updateBlendStatus();
	    };
	    ContextWebGL.prototype.setColorMask = function (red, green, blue, alpha) {
	        this._gl.colorMask(red, green, blue, alpha);
	    };
	    ContextWebGL.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        if (triangleFaceToCull == ContextGLTriangleFace_1.ContextGLTriangleFace.NONE) {
	            this._gl.disable(this._gl.CULL_FACE);
	        }
	        else {
	            this._gl.enable(this._gl.CULL_FACE);
	            this._gl.cullFace(this.translateTriangleFace(triangleFaceToCull, coordinateSystem));
	        }
	    };
	    // TODO ContextGLCompareMode
	    ContextWebGL.prototype.setDepthTest = function (depthMask, passCompareMode) {
	        this._gl.depthFunc(this._compareModeDictionary[passCompareMode]);
	        this._gl.depthMask(depthMask);
	    };
	    ContextWebGL.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
	        if (triangleFace === void 0) { triangleFace = "frontAndBack"; }
	        if (compareMode === void 0) { compareMode = "always"; }
	        if (actionOnBothPass === void 0) { actionOnBothPass = "keep"; }
	        if (actionOnDepthFail === void 0) { actionOnDepthFail = "keep"; }
	        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = "keep"; }
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        this._separateStencil = triangleFace != "frontAndBack";
	        var compareModeGL = this._compareModeDictionary[compareMode];
	        var fail = this._stencilActionDictionary[actionOnDepthPassStencilFail];
	        var zFail = this._stencilActionDictionary[actionOnDepthFail];
	        var pass = this._stencilActionDictionary[actionOnBothPass];
	        if (!this._separateStencil) {
	            this._stencilCompareMode = compareModeGL;
	            this._gl.stencilFunc(compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	            this._gl.stencilOp(fail, zFail, pass);
	        }
	        else if (triangleFace == "back") {
	            this._stencilCompareModeBack = compareModeGL;
	            this._gl.stencilFuncSeparate(this._gl.BACK, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	            this._gl.stencilOpSeparate(this._gl.BACK, fail, zFail, pass);
	        }
	        else if (triangleFace == "front") {
	            this._stencilCompareModeFront = compareModeGL;
	            this._gl.stencilFuncSeparate(this._gl.FRONT, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
	            this._gl.stencilOpSeparate(this._gl.FRONT, fail, zFail, pass);
	        }
	    };
	    ContextWebGL.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
	        this._stencilReferenceValue = referenceValue;
	        this._stencilReadMask = readMask;
	        if (this._separateStencil) {
	            this._gl.stencilFuncSeparate(this._gl.FRONT, this._stencilCompareModeFront, referenceValue, readMask);
	            this._gl.stencilFuncSeparate(this._gl.BACK, this._stencilCompareModeBack, referenceValue, readMask);
	        }
	        else {
	            this._gl.stencilFunc(this._stencilCompareMode, referenceValue, readMask);
	        }
	        this._gl.stencilMask(writeMask);
	    };
	    ContextWebGL.prototype.setProgram = function (program) {
	        //TODO decide on construction/reference resposibilities
	        this._currentProgram = program;
	        program.focusProgram();
	    };
	    ContextWebGL.prototype.setProgramConstantsFromArray = function (programType, data) {
	        if (data.length)
	            this._gl.uniform4fv(this._currentProgram.getUniformLocation(programType), data);
	    };
	    ContextWebGL.prototype.setScissorRectangle = function (rectangle) {
	        if (!rectangle) {
	            this._gl.disable(this._gl.SCISSOR_TEST);
	            return;
	        }
	        this._gl.enable(this._gl.SCISSOR_TEST);
	        this._gl.scissor(rectangle.x, rectangle.y, rectangle.width, rectangle.height);
	    };
	    ContextWebGL.prototype.setTextureAt = function (sampler, texture) {
	        var samplerState = this._samplerStates[sampler];
	        if (this._activeTexture != sampler && (texture || samplerState.type)) {
	            this._activeTexture = sampler;
	            this._gl.activeTexture(this._textureIndexDictionary[sampler]);
	        }
	        if (!texture) {
	            if (samplerState.type) {
	                this._gl.bindTexture(samplerState.type, null);
	                samplerState.type = null;
	            }
	            return;
	        }
	        var textureType = this._textureTypeDictionary[texture.textureType];
	        samplerState.type = textureType;
	        this._gl.bindTexture(textureType, texture.glTexture);
	        this._gl.uniform1i(this._currentProgram.getUniformLocation(ContextGLProgramType_1.ContextGLProgramType.SAMPLER, sampler), sampler);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, samplerState.wrap);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, samplerState.wrap);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, samplerState.filter);
	        this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, samplerState.mipfilter);
	    };
	    ContextWebGL.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
	        if (0 <= sampler && sampler < ContextWebGL.MAX_SAMPLERS) {
	            this._samplerStates[sampler].wrap = this._wrapDictionary[wrap];
	            this._samplerStates[sampler].filter = this._filterDictionary[filter];
	            this._samplerStates[sampler].mipfilter = this._mipmapFilterDictionary[filter][mipfilter];
	        }
	        else {
	            throw "Sampler is out of bounds.";
	        }
	    };
	    ContextWebGL.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
	        if (bufferOffset === void 0) { bufferOffset = 0; }
	        if (format === void 0) { format = 4; }
	        var location = this._currentProgram ? this._currentProgram.getAttribLocation(index) : -1;
	        if (!buffer) {
	            if (location > -1)
	                this._gl.disableVertexAttribArray(location);
	            return;
	        }
	        //buffer may not have changed if concatenated buffers are being used
	        if (this._currentArrayBuffer != buffer) {
	            this._currentArrayBuffer = buffer;
	            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer ? buffer.glBuffer : null);
	        }
	        var properties = this._vertexBufferPropertiesDictionary[format];
	        this._gl.enableVertexAttribArray(location);
	        this._gl.vertexAttribPointer(location, properties.size, properties.type, properties.normalized, buffer.dataPerVertex, bufferOffset);
	    };
	    ContextWebGL.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
	        if (antiAlias === void 0) { antiAlias = 0; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        var texture = target;
	        var frameBuffer = texture.frameBuffer;
	        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);
	        if (enableDepthAndStencil) {
	            this._gl.enable(this._gl.STENCIL_TEST);
	            this._gl.enable(this._gl.DEPTH_TEST);
	        }
	        this._gl.viewport(0, 0, texture.width, texture.height);
	    };
	    ContextWebGL.prototype.setRenderToBackBuffer = function () {
	        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
	    };
	    ContextWebGL.prototype.updateBlendStatus = function () {
	        if (this._blendEnabled) {
	            this._gl.enable(this._gl.BLEND);
	            this._gl.blendEquation(this._gl.FUNC_ADD);
	            this._gl.blendFunc(this._blendSourceFactor, this._blendDestinationFactor);
	        }
	        else {
	            this._gl.disable(this._gl.BLEND);
	        }
	    };
	    ContextWebGL.prototype.translateTriangleFace = function (triangleFace, coordinateSystem) {
	        switch (triangleFace) {
	            case ContextGLTriangleFace_1.ContextGLTriangleFace.BACK:
	                return (coordinateSystem == "leftHanded") ? this._gl.FRONT : this._gl.BACK;
	            case ContextGLTriangleFace_1.ContextGLTriangleFace.FRONT:
	                return (coordinateSystem == "leftHanded") ? this._gl.BACK : this._gl.FRONT;
	            case ContextGLTriangleFace_1.ContextGLTriangleFace.FRONT_AND_BACK:
	                return this._gl.FRONT_AND_BACK;
	            default:
	                throw "Unknown ContextGLTriangleFace type."; // TODO error
	        }
	    };
	    ContextWebGL.MAX_SAMPLERS = 8;
	    ContextWebGL.modulo = 0;
	    return ContextWebGL;
	}());
	exports.ContextWebGL = ContextWebGL;
	var VertexBufferProperties = (function () {
	    function VertexBufferProperties(size, type, normalized) {
	        this.size = size;
	        this.type = type;
	        this.normalized = normalized;
	    }
	    return VertexBufferProperties;
	}());
	exports.VertexBufferProperties = VertexBufferProperties;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBaseWebGL_1 = __webpack_require__(80);
	var CubeTextureWebGL = (function (_super) {
	    __extends(CubeTextureWebGL, _super);
	    function CubeTextureWebGL(gl, size) {
	        _super.call(this, gl);
	        this._textureSelectorDictionary = new Array(6);
	        this.textureType = "textureCube";
	        this._size = size;
	        this._glTexture = this._gl.createTexture();
	        this._textureSelectorDictionary[0] = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
	        this._textureSelectorDictionary[1] = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
	        this._textureSelectorDictionary[2] = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
	        this._textureSelectorDictionary[3] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
	        this._textureSelectorDictionary[4] = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
	        this._textureSelectorDictionary[5] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
	    }
	    CubeTextureWebGL.prototype.uploadFromData = function (data, side, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._glTexture);
	        this._gl.texImage2D(this._textureSelectorDictionary[side], miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
	        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
	    };
	    CubeTextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
	        if (async === void 0) { async = false; }
	    };
	    Object.defineProperty(CubeTextureWebGL.prototype, "size", {
	        get: function () {
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CubeTextureWebGL;
	}(TextureBaseWebGL_1.TextureBaseWebGL));
	exports.CubeTextureWebGL = CubeTextureWebGL;


/***/ },
/* 80 */
/***/ function(module, exports) {

	"use strict";
	var TextureBaseWebGL = (function () {
	    function TextureBaseWebGL(gl) {
	        this.textureType = "";
	        this._gl = gl;
	    }
	    TextureBaseWebGL.prototype.dispose = function () {
	        this._gl.deleteTexture(this._glTexture);
	    };
	    Object.defineProperty(TextureBaseWebGL.prototype, "glTexture", {
	        get: function () {
	            return this._glTexture;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureBaseWebGL.prototype.generateMipmaps = function () {
	        this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
	        this._gl.generateMipmap(this._gl.TEXTURE_2D);
	        //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
	    };
	    return TextureBaseWebGL;
	}());
	exports.TextureBaseWebGL = TextureBaseWebGL;


/***/ },
/* 81 */
/***/ function(module, exports) {

	"use strict";
	var IndexBufferWebGL = (function () {
	    function IndexBufferWebGL(gl, numIndices) {
	        this._gl = gl;
	        this._buffer = this._gl.createBuffer();
	        this._numIndices = numIndices;
	    }
	    IndexBufferWebGL.prototype.uploadFromArray = function (data, startOffset, count) {
	        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	        if (startOffset)
	            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset * 2, new Uint16Array(data));
	        else
	            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this._gl.STATIC_DRAW);
	    };
	    IndexBufferWebGL.prototype.uploadFromByteArray = function (data, startOffset, count) {
	        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
	        if (startOffset)
	            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset * 2, data);
	        else
	            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
	    };
	    IndexBufferWebGL.prototype.dispose = function () {
	        this._gl.deleteBuffer(this._buffer);
	    };
	    Object.defineProperty(IndexBufferWebGL.prototype, "numIndices", {
	        get: function () {
	            return this._numIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(IndexBufferWebGL.prototype, "glBuffer", {
	        get: function () {
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return IndexBufferWebGL;
	}());
	exports.IndexBufferWebGL = IndexBufferWebGL;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AGALTokenizer_1 = __webpack_require__(68);
	var AGLSLParser_1 = __webpack_require__(75);
	var ProgramWebGL = (function () {
	    function ProgramWebGL(gl) {
	        this._uniforms = [[], [], []];
	        this._attribs = [];
	        this._gl = gl;
	        this._program = this._gl.createProgram();
	    }
	    ProgramWebGL.prototype.upload = function (vertexProgram, fragmentProgram) {
	        var vertexString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(vertexProgram));
	        var fragmentString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(fragmentProgram));
	        this._vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);
	        this._fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
	        this._gl.shaderSource(this._vertexShader, vertexString);
	        this._gl.compileShader(this._vertexShader);
	        if (!this._gl.getShaderParameter(this._vertexShader, this._gl.COMPILE_STATUS))
	            throw new Error(this._gl.getShaderInfoLog(this._vertexShader));
	        this._gl.shaderSource(this._fragmentShader, fragmentString);
	        this._gl.compileShader(this._fragmentShader);
	        if (!this._gl.getShaderParameter(this._fragmentShader, this._gl.COMPILE_STATUS))
	            throw new Error(this._gl.getShaderInfoLog(this._fragmentShader));
	        this._gl.attachShader(this._program, this._vertexShader);
	        this._gl.attachShader(this._program, this._fragmentShader);
	        this._gl.linkProgram(this._program);
	        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS))
	            throw new Error(this._gl.getProgramInfoLog(this._program));
	        this._uniforms[0].length = 0;
	        this._uniforms[1].length = 0;
	        this._uniforms[2].length = 0;
	        this._attribs.length = 0;
	    };
	    ProgramWebGL.prototype.getUniformLocation = function (programType, index) {
	        if (index === void 0) { index = -1; }
	        if (this._uniforms[programType][index + 1] != null)
	            return this._uniforms[programType][index + 1];
	        var name = (index == -1) ? ProgramWebGL._uniformLocationNameDictionary[programType] : ProgramWebGL._uniformLocationNameDictionary[programType] + index;
	        return (this._uniforms[programType][index + 1] = this._gl.getUniformLocation(this._program, name));
	    };
	    //
	    // public getUniformLocation(programType:number, index:number):WebGLUniformLocation
	    // {
	    // 	if (this._uniforms[programType][index] != null)
	    // 		return this._uniforms[programType][index];
	    //
	    // 	return (this._uniforms[programType][index] = this._gl.getUniformLocation(this._program, ProgramWebGL._uniformLocationNameDictionary[programType] + index));
	    // }
	    ProgramWebGL.prototype.getAttribLocation = function (index) {
	        if (this._attribs[index] != null)
	            return this._attribs[index];
	        return (this._attribs[index] = this._gl.getAttribLocation(this._program, "va" + index));
	    };
	    ProgramWebGL.prototype.dispose = function () {
	        this._gl.deleteProgram(this._program);
	    };
	    ProgramWebGL.prototype.focusProgram = function () {
	        this._gl.useProgram(this._program);
	    };
	    Object.defineProperty(ProgramWebGL.prototype, "glProgram", {
	        get: function () {
	            return this._program;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProgramWebGL._tokenizer = new AGALTokenizer_1.AGALTokenizer();
	    ProgramWebGL._aglslParser = new AGLSLParser_1.AGLSLParser();
	    ProgramWebGL._uniformLocationNameDictionary = ["fc", "fs", "vc"];
	    return ProgramWebGL;
	}());
	exports.ProgramWebGL = ProgramWebGL;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBaseWebGL_1 = __webpack_require__(80);
	var TextureWebGL = (function (_super) {
	    __extends(TextureWebGL, _super);
	    function TextureWebGL(gl, width, height) {
	        _super.call(this, gl);
	        this.textureType = "texture2d";
	        this._width = width;
	        this._height = height;
	        this._glTexture = this._gl.createTexture();
	    }
	    Object.defineProperty(TextureWebGL.prototype, "width", {
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureWebGL.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureWebGL.prototype, "frameBuffer", {
	        get: function () {
	            if (!this._frameBuffer) {
	                this._frameBuffer = this._gl.createFramebuffer();
	                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
	                this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
	                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._width, this._height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
	                var renderBuffer = this._gl.createRenderbuffer();
	                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
	                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_STENCIL, this._width, this._height);
	                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._glTexture, 0);
	                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_STENCIL_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
	                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
	                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
	                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
	            }
	            return this._frameBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureWebGL.prototype.uploadFromData = function (data, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
	        this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
	        this._gl.bindTexture(this._gl.TEXTURE_2D, null);
	    };
	    TextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
	        if (async === void 0) { async = false; }
	        var ext = this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
	        //this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this)
	    };
	    return TextureWebGL;
	}(TextureBaseWebGL_1.TextureBaseWebGL));
	exports.TextureWebGL = TextureWebGL;


/***/ },
/* 84 */
/***/ function(module, exports) {

	"use strict";
	var VertexBufferWebGL = (function () {
	    function VertexBufferWebGL(gl, numVertices, dataPerVertex) {
	        this._gl = gl;
	        this._buffer = this._gl.createBuffer();
	        this._numVertices = numVertices;
	        this._dataPerVertex = dataPerVertex;
	    }
	    VertexBufferWebGL.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
	        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
	        if (startVertex)
	            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex * this._dataPerVertex, new Float32Array(vertices));
	        else
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);
	    };
	    VertexBufferWebGL.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
	        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
	        if (startVertex)
	            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex * this._dataPerVertex, data);
	        else
	            this._gl.bufferData(this._gl.ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
	    };
	    Object.defineProperty(VertexBufferWebGL.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferWebGL.prototype, "dataPerVertex", {
	        get: function () {
	            return this._dataPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferWebGL.prototype, "glBuffer", {
	        get: function () {
	            return this._buffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    VertexBufferWebGL.prototype.dispose = function () {
	        this._gl.deleteBuffer(this._buffer);
	    };
	    return VertexBufferWebGL;
	}());
	exports.VertexBufferWebGL = VertexBufferWebGL;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	//import {swfobject}					from "../swfobject";
	var ContextGLClearMask_1 = __webpack_require__(42);
	var ContextGLProgramType_1 = __webpack_require__(47);
	var CubeTextureFlash_1 = __webpack_require__(86);
	var IndexBufferFlash_1 = __webpack_require__(90);
	var OpCodes_1 = __webpack_require__(88);
	var ProgramFlash_1 = __webpack_require__(91);
	var TextureFlash_1 = __webpack_require__(92);
	var VertexBufferFlash_1 = __webpack_require__(93);
	var ContextFlash = (function () {
	    //TODO: get rid of hack that fixes including definition file
	    function ContextFlash(container, callback) {
	        this._cmdStream = "";
	        this._resources = new Array();
	        var swfVersionStr = "11.0.0";
	        // To use express install, set to playerProductInstall.swf, otherwise the empty string.
	        var flashvars = {
	            id: container.id
	        };
	        var params = {
	            quality: "high",
	            bgcolor: "#ffffff",
	            allowscriptaccess: "sameDomain",
	            allowfullscreen: "true",
	            wmode: "direct"
	        };
	        this._errorCheckingEnabled = false;
	        this._iDriverInfo = "Unknown";
	        var attributes = {
	            salign: "tl",
	            id: container.id,
	            name: container["name"] //TODO: needed?
	        };
	        this._oldCanvas = container.cloneNode(); // keep the old one to restore on dispose
	        this._oldParent = container.parentNode;
	        var context3dObj = this;
	        ContextFlash.contexts[container.id] = this;
	        function callbackSWFObject(callbackInfo) {
	            if (!callbackInfo.success)
	                return;
	            context3dObj._container = callbackInfo.ref;
	            context3dObj._iCallback = callback;
	        }
	        //swfobject.embedSWF("libs/molehill_js_flashbridge.swf", container.id, String(container.width), String(container.height), swfVersionStr, "", flashvars, params, attributes, callbackSWFObject);
	    }
	    Object.defineProperty(ContextFlash.prototype, "container", {
	        get: function () {
	            return this._container;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ContextFlash.prototype, "driverInfo", {
	        get: function () {
	            return this._iDriverInfo;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ContextFlash.prototype, "errorCheckingEnabled", {
	        get: function () {
	            return this._errorCheckingEnabled;
	        },
	        set: function (value) {
	            if (this._errorCheckingEnabled == value)
	                return;
	            this._errorCheckingEnabled = value;
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.enableErrorChecking, value ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue));
	            this.execute();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ContextFlash.prototype._iAddResource = function (resource) {
	        this._resources.push(resource);
	    };
	    ContextFlash.prototype._iRemoveResource = function (resource) {
	        this._resources.splice(this._resources.indexOf(resource));
	    };
	    ContextFlash.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        //TODO:streaming
	        return new TextureFlash_1.TextureFlash(this, width, height, format, optimizeForRenderToTexture);
	    };
	    ContextFlash.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
	        if (streamingLevels === void 0) { streamingLevels = 0; }
	        //TODO:streaming
	        return new CubeTextureFlash_1.CubeTextureFlash(this, size, format, optimizeForRenderToTexture);
	    };
	    ContextFlash.prototype.setTextureAt = function (sampler, texture) {
	        if (texture) {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setTextureAt) + sampler + "," + texture.id + ",");
	        }
	        else {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.clearTextureAt) + sampler.toString() + ",");
	        }
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
	        //nothing to do here
	    };
	    ContextFlash.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
	        if (triangleFace === void 0) { triangleFace = "frontAndBack"; }
	        if (compareMode === void 0) { compareMode = "always"; }
	        if (actionOnBothPass === void 0) { actionOnBothPass = "keep"; }
	        if (actionOnDepthFail === void 0) { actionOnDepthFail = "keep"; }
	        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = "keep"; }
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setStencilActions) + triangleFace + "$" + compareMode + "$" + actionOnBothPass + "$" + actionOnDepthFail + "$" + actionOnDepthPassStencilFail + "$");
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
	        if (readMask === void 0) { readMask = 255; }
	        if (writeMask === void 0) { writeMask = 255; }
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setStencilReferenceValue, referenceValue + OpCodes_1.OpCodes.intMask, readMask + OpCodes_1.OpCodes.intMask, writeMask + OpCodes_1.OpCodes.intMask));
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        //TODO implement coordinateSystem option
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setCulling) + triangleFaceToCull + "$");
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
	        if (firstIndex === void 0) { firstIndex = 0; }
	        if (numIndices === void 0) { numIndices = -1; }
	        firstIndex = firstIndex || 0;
	        if (!numIndices || numIndices < 0)
	            numIndices = indexBuffer.numIndices;
	        //assume triangles
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.drawTriangles, indexBuffer.id + OpCodes_1.OpCodes.intMask) + firstIndex + "," + numIndices + ",");
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.drawVertices = function (mode, firstVertex, numVertices) {
	        if (firstVertex === void 0) { firstVertex = 0; }
	        if (numVertices === void 0) { numVertices = -1; }
	        //can't be done in Stage3D
	    };
	    ContextFlash.prototype.setProgramConstantsFromArray = function (programType, data) {
	        var startIndex;
	        var numRegisters = data.length / 4;
	        var target = (programType == ContextGLProgramType_1.ContextGLProgramType.VERTEX) ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue;
	        for (var i = 0; i < numRegisters; i++) {
	            startIndex = i * 4;
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setProgramConstant, target, i + OpCodes_1.OpCodes.intMask) + data[startIndex] + "," + data[startIndex + 1] + "," + data[startIndex + 2] + "," + data[startIndex + 3] + ",");
	            if (ContextFlash.debug)
	                this.execute();
	        }
	    };
	    ContextFlash.prototype.setProgram = function (program) {
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setProgram, program.id + OpCodes_1.OpCodes.intMask));
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.present = function () {
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.present));
	        this.execute();
	    };
	    ContextFlash.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
	        if (red === void 0) { red = 0; }
	        if (green === void 0) { green = 0; }
	        if (blue === void 0) { blue = 0; }
	        if (alpha === void 0) { alpha = 1; }
	        if (depth === void 0) { depth = 1; }
	        if (stencil === void 0) { stencil = 0; }
	        if (mask === void 0) { mask = ContextGLClearMask_1.ContextGLClearMask.ALL; }
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.clear) + red + "," + green + "," + blue + "," + alpha + "," + depth + "," + stencil + "," + mask + ",");
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.createProgram = function () {
	        return new ProgramFlash_1.ProgramFlash(this);
	    };
	    ContextFlash.prototype.createVertexBuffer = function (numVertices, data32PerVertex) {
	        return new VertexBufferFlash_1.VertexBufferFlash(this, numVertices, data32PerVertex);
	    };
	    ContextFlash.prototype.createIndexBuffer = function (numIndices) {
	        return new IndexBufferFlash_1.IndexBufferFlash(this, numIndices);
	    };
	    ContextFlash.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
	        this._width = width;
	        this._height = height;
	        //TODO: add Anitalias setting
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.configureBackBuffer) + width + "," + height + ",");
	    };
	    ContextFlash.prototype.drawToBitmapImage2D = function (destination) {
	        //TODO
	    };
	    ContextFlash.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
	        if (bufferOffset === void 0) { bufferOffset = 0; }
	        if (format === void 0) { format = null; }
	        if (buffer) {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setVertexBufferAt, index + OpCodes_1.OpCodes.intMask) + buffer.id + "," + bufferOffset + "," + format + "$");
	        }
	        else {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.clearVertexBufferAt, index + OpCodes_1.OpCodes.intMask));
	        }
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setColorMask = function (red, green, blue, alpha) {
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setColorMask, red ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue, green ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue, blue ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue, alpha ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue));
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setBlendFactors) + sourceFactor + "$" + destinationFactor + "$");
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
	        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
	        if (antiAlias === void 0) { antiAlias = 0; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        if (target === null || target === undefined) {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.clearRenderToTexture));
	        }
	        else {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setRenderToTexture, enableDepthAndStencil ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue) + target.id + "," + (antiAlias || 0) + ",");
	        }
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setRenderToBackBuffer = function () {
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.clearRenderToTexture));
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setScissorRectangle = function (rectangle) {
	        if (rectangle) {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setScissorRect) + rectangle.x + "," + rectangle.y + "," + rectangle.width + "," + rectangle.height + ",");
	        }
	        else {
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.clearScissorRect));
	        }
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.setDepthTest = function (depthMask, passCompareMode) {
	        this.addStream(String.fromCharCode(OpCodes_1.OpCodes.setDepthTest, depthMask ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue) + passCompareMode + "$");
	        if (ContextFlash.debug)
	            this.execute();
	    };
	    ContextFlash.prototype.dispose = function () {
	        if (this._container == null)
	            return;
	        console.log("Context3D dispose, releasing " + this._resources.length + " resources.");
	        while (this._resources.length)
	            this._resources[0].dispose();
	        if (this._container) {
	            // encode command
	            this.addStream(String.fromCharCode(OpCodes_1.OpCodes.disposeContext));
	            this.execute();
	            //swfobject.removeSWF(this._oldCanvas.id);
	            if (this._oldCanvas && this._oldParent) {
	                this._oldParent.appendChild(this._oldCanvas);
	                this._oldParent = null;
	            }
	            this._container = null;
	        }
	        this._oldCanvas = null;
	    };
	    ContextFlash.prototype.addStream = function (stream) {
	        this._cmdStream += stream;
	    };
	    ContextFlash.prototype.execute = function () {
	        if (ContextFlash.logStream)
	            console.log(this._cmdStream);
	        var result = this._container["CallFunction"]("<invoke name=\"execStage3dOpStream\" returntype=\"javascript\"><arguments><string>" + this._cmdStream + "</string></arguments></invoke>");
	        if (Number(result) <= -3)
	            throw "Exec stream failed";
	        this._cmdStream = "";
	        return Number(result);
	    };
	    ContextFlash.contexts = new Object();
	    ContextFlash.debug = false;
	    ContextFlash.logStream = false;
	    return ContextFlash;
	}());
	exports.ContextFlash = ContextFlash;
	/**
	* global function for flash callback
	*/
	function mountain_js_context_available(id, driverInfo) {
	    var ctx = ContextFlash.contexts[id];
	    if (ctx._iCallback) {
	        ctx._iDriverInfo = driverInfo;
	        // get out of the current JS stack frame and call back from flash player
	        var timeOutId = window.setTimeout(function () {
	            window.clearTimeout(timeOutId);
	            try {
	                ctx._iCallback(ctx);
	            }
	            catch (e) {
	                console.log("Callback failed during flash initialization with '" + e.toString() + "'");
	            }
	        }, 1);
	    }
	}


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ByteArrayBase_1 = __webpack_require__(87);
	var OpCodes_1 = __webpack_require__(88);
	var ResourceBaseFlash_1 = __webpack_require__(89);
	var CubeTextureFlash = (function (_super) {
	    __extends(CubeTextureFlash, _super);
	    function CubeTextureFlash(context, size, format, forRTT, streaming) {
	        if (streaming === void 0) { streaming = false; }
	        _super.call(this);
	        this._context = context;
	        this._size = size;
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.initCubeTexture, (forRTT ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue)) + size + "," + streaming + "," + format + "$");
	        this._pId = this._context.execute();
	        this._context._iAddResource(this);
	    }
	    Object.defineProperty(CubeTextureFlash.prototype, "size", {
	        get: function () {
	            return this._size;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CubeTextureFlash.prototype.dispose = function () {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.disposeCubeTexture) + this._pId.toString() + ",");
	        this._context.execute();
	        this._context._iRemoveResource(this);
	        this._context = null;
	    };
	    CubeTextureFlash.prototype.uploadFromData = function (data, side, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        if (data instanceof HTMLImageElement) {
	            var can = document.createElement("canvas");
	            var w = data.width;
	            var h = data.height;
	            can.width = w;
	            can.height = h;
	            var ctx = can.getContext("2d");
	            ctx.drawImage(data, 0, 0);
	            data = ctx.getImageData(0, 0, w, h).data;
	        }
	        var pos = 0;
	        var bytes = ByteArrayBase_1.ByteArrayBase.internalGetBase64String(data.length, function () {
	            return data[pos++];
	        }, null);
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.uploadBytesCubeTexture) + this._pId + "," + miplevel + "," + side + "," + (this.size >> miplevel) + "," + bytes + "%");
	        this._context.execute();
	    };
	    CubeTextureFlash.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
	        if (async === void 0) { async = false; }
	    };
	    return CubeTextureFlash;
	}(ResourceBaseFlash_1.ResourceBaseFlash));
	exports.CubeTextureFlash = CubeTextureFlash;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(7);
	var ByteArrayBase = (function () {
	    function ByteArrayBase() {
	        this.position = 0;
	        this.length = 0;
	        this._mode = "";
	    }
	    ByteArrayBase.prototype.writeByte = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readByte = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeUnsignedByte = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readUnsignedByte = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeUnsignedShort = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readUnsignedShort = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeUnsignedInt = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readUnsignedInt = function () {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.writeFloat = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.toFloatBits = function (x) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.readFloat = function (b) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.fromFloatBits = function (x) {
	        throw "Virtual method";
	    };
	    ByteArrayBase.prototype.getBytesAvailable = function () {
	        throw new AbstractMethodError_1.AbstractMethodError('ByteArrayBase, getBytesAvailable() not implemented ');
	    };
	    ByteArrayBase.prototype.toString = function () {
	        return "[ByteArray] ( " + this._mode + " ) position=" + this.position + " length=" + this.length;
	    };
	    ByteArrayBase.prototype.compareEqual = function (other, count) {
	        if (count == undefined || count > this.length - this.position)
	            count = this.length - this.position;
	        if (count > other.length - other.position)
	            count = other.length - other.position;
	        var co0 = count;
	        var r = true;
	        while (r && count >= 4) {
	            count -= 4;
	            if (this.readUnsignedInt() != other.readUnsignedInt())
	                r = false;
	        }
	        while (r && count >= 1) {
	            count--;
	            if (this.readUnsignedByte() != other.readUnsignedByte())
	                r = false;
	        }
	        var c0;
	        this.position -= (c0 - count);
	        other.position -= (c0 - count);
	        return r;
	    };
	    ByteArrayBase.prototype.writeBase64String = function (s) {
	        for (var i = 0; i < s.length; i++) {
	            var v = s.charAt(i);
	        }
	    };
	    ByteArrayBase.prototype.dumpToConsole = function () {
	        var oldpos = this.position;
	        this.position = 0;
	        var nstep = 8;
	        function asHexString(x, digits) {
	            var lut = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
	            var sh = "";
	            for (var d = 0; d < digits; d++) {
	                sh = lut[(x >> (d << 2)) & 0xf] + sh;
	            }
	            return sh;
	        }
	        for (var i = 0; i < this.length; i += nstep) {
	            var s = asHexString(i, 4) + ":";
	            for (var j = 0; j < nstep && i + j < this.length; j++) {
	                s += " " + asHexString(this.readUnsignedByte(), 2);
	            }
	            console.log(s);
	        }
	        this.position = oldpos;
	    };
	    ByteArrayBase.prototype.readBase64String = function (count) {
	        if (count == undefined || count > this.length - this.position)
	            count = this.length - this.position;
	        if (!(count > 0))
	            return "";
	        return ByteArrayBase.internalGetBase64String(count, this.readUnsignedByte, this);
	    };
	    ByteArrayBase.internalGetBase64String = function (count, getUnsignedByteFunc, self) {
	        var r = "";
	        var b0, b1, b2, enc1, enc2, enc3, enc4;
	        var base64Key = ByteArrayBase.Base64Key;
	        while (count >= 3) {
	            b0 = getUnsignedByteFunc.apply(self);
	            b1 = getUnsignedByteFunc.apply(self);
	            b2 = getUnsignedByteFunc.apply(self);
	            enc1 = b0 >> 2;
	            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
	            enc3 = ((b1 & 15) << 2) | (b2 >> 6);
	            enc4 = b2 & 63;
	            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + base64Key.charAt(enc4);
	            count -= 3;
	        }
	        // pad
	        if (count == 2) {
	            b0 = getUnsignedByteFunc.apply(self);
	            b1 = getUnsignedByteFunc.apply(self);
	            enc1 = b0 >> 2;
	            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
	            enc3 = ((b1 & 15) << 2);
	            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + "=";
	        }
	        else if (count == 1) {
	            b0 = getUnsignedByteFunc.apply(self);
	            enc1 = b0 >> 2;
	            enc2 = ((b0 & 3) << 4);
	            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + "==";
	        }
	        return r;
	    };
	    ByteArrayBase.Base64Key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
	    return ByteArrayBase;
	}());
	exports.ByteArrayBase = ByteArrayBase;


/***/ },
/* 88 */
/***/ function(module, exports) {

	"use strict";
	var OpCodes = (function () {
	    function OpCodes() {
	    }
	    OpCodes.trueValue = 32;
	    OpCodes.falseValue = 33;
	    OpCodes.intMask = 63;
	    OpCodes.drawTriangles = 41;
	    OpCodes.setProgramConstant = 42;
	    OpCodes.setProgram = 43;
	    OpCodes.present = 44;
	    OpCodes.clear = 45;
	    OpCodes.initProgram = 46;
	    OpCodes.initVertexBuffer = 47;
	    OpCodes.initIndexBuffer = 48;
	    OpCodes.configureBackBuffer = 49;
	    OpCodes.uploadArrayIndexBuffer = 50;
	    OpCodes.uploadArrayVertexBuffer = 51;
	    OpCodes.uploadAGALBytesProgram = 52;
	    OpCodes.setVertexBufferAt = 53;
	    OpCodes.uploadBytesIndexBuffer = 54;
	    OpCodes.uploadBytesVertexBuffer = 55;
	    OpCodes.setColorMask = 56;
	    OpCodes.setDepthTest = 57;
	    OpCodes.disposeProgram = 58;
	    OpCodes.disposeContext = 59;
	    // must skip 60 '<' as it will invalidate xml being passed over the bridge
	    OpCodes.disposeVertexBuffer = 61;
	    // must skip 62 '>' as it will invalidate xml being passed over the bridge
	    OpCodes.disposeIndexBuffer = 63;
	    OpCodes.initTexture = 64;
	    OpCodes.setTextureAt = 65;
	    OpCodes.uploadBytesTexture = 66;
	    OpCodes.disposeTexture = 67;
	    OpCodes.setCulling = 68;
	    OpCodes.setScissorRect = 69;
	    OpCodes.clearScissorRect = 70;
	    OpCodes.setBlendFactors = 71;
	    OpCodes.setRenderToTexture = 72;
	    OpCodes.clearTextureAt = 73;
	    OpCodes.clearVertexBufferAt = 74;
	    OpCodes.setStencilActions = 75;
	    OpCodes.setStencilReferenceValue = 76;
	    OpCodes.initCubeTexture = 77;
	    OpCodes.disposeCubeTexture = 78;
	    OpCodes.uploadBytesCubeTexture = 79;
	    OpCodes.clearRenderToTexture = 80;
	    OpCodes.enableErrorChecking = 81;
	    return OpCodes;
	}());
	exports.OpCodes = OpCodes;


/***/ },
/* 89 */
/***/ function(module, exports) {

	"use strict";
	var ResourceBaseFlash = (function () {
	    function ResourceBaseFlash() {
	    }
	    Object.defineProperty(ResourceBaseFlash.prototype, "id", {
	        get: function () {
	            return this._pId;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ResourceBaseFlash.prototype.dispose = function () {
	    };
	    ResourceBaseFlash.prototype.generateMipmaps = function () {
	        //TODO
	    };
	    return ResourceBaseFlash;
	}());
	exports.ResourceBaseFlash = ResourceBaseFlash;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OpCodes_1 = __webpack_require__(88);
	var ResourceBaseFlash_1 = __webpack_require__(89);
	var IndexBufferFlash = (function (_super) {
	    __extends(IndexBufferFlash, _super);
	    function IndexBufferFlash(context, numIndices) {
	        _super.call(this);
	        this._context = context;
	        this._numIndices = numIndices;
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.initIndexBuffer, numIndices + OpCodes_1.OpCodes.intMask));
	        this._pId = this._context.execute();
	        this._context._iAddResource(this);
	    }
	    IndexBufferFlash.prototype.uploadFromArray = function (data, startOffset, count) {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.uploadArrayIndexBuffer, this._pId + OpCodes_1.OpCodes.intMask) + data.join() + "#" + startOffset + "," + count + ",");
	        this._context.execute();
	    };
	    IndexBufferFlash.prototype.uploadFromByteArray = function (data, startOffset, count) {
	    };
	    IndexBufferFlash.prototype.dispose = function () {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.disposeIndexBuffer, this._pId + OpCodes_1.OpCodes.intMask));
	        this._context.execute();
	        this._context._iRemoveResource(this);
	        this._context = null;
	    };
	    Object.defineProperty(IndexBufferFlash.prototype, "numIndices", {
	        get: function () {
	            return this._numIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return IndexBufferFlash;
	}(ResourceBaseFlash_1.ResourceBaseFlash));
	exports.IndexBufferFlash = IndexBufferFlash;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextFlash_1 = __webpack_require__(85);
	var OpCodes_1 = __webpack_require__(88);
	var ResourceBaseFlash_1 = __webpack_require__(89);
	var ProgramFlash = (function (_super) {
	    __extends(ProgramFlash, _super);
	    function ProgramFlash(context) {
	        _super.call(this);
	        this._context = context;
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.initProgram));
	        this._pId = this._context.execute();
	        this._context._iAddResource(this);
	    }
	    ProgramFlash.prototype.upload = function (vertexProgram, fragmentProgram) {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.uploadAGALBytesProgram, this._pId + OpCodes_1.OpCodes.intMask) + vertexProgram.readBase64String(vertexProgram.length) + "%" + fragmentProgram.readBase64String(fragmentProgram.length) + "%");
	        if (ContextFlash_1.ContextFlash.debug)
	            this._context.execute();
	    };
	    ProgramFlash.prototype.dispose = function () {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.disposeProgram, this._pId + OpCodes_1.OpCodes.intMask));
	        this._context.execute();
	        this._context._iRemoveResource(this);
	        this._context = null;
	    };
	    return ProgramFlash;
	}(ResourceBaseFlash_1.ResourceBaseFlash));
	exports.ProgramFlash = ProgramFlash;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ByteArrayBase_1 = __webpack_require__(87);
	var OpCodes_1 = __webpack_require__(88);
	var ResourceBaseFlash_1 = __webpack_require__(89);
	var TextureFlash = (function (_super) {
	    __extends(TextureFlash, _super);
	    function TextureFlash(context, width, height, format, forRTT, streaming) {
	        if (streaming === void 0) { streaming = false; }
	        _super.call(this);
	        this._context = context;
	        this._width = width;
	        this._height = height;
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.initTexture, (forRTT ? OpCodes_1.OpCodes.trueValue : OpCodes_1.OpCodes.falseValue)) + width + "," + height + "," + streaming + "," + format + "$");
	        this._pId = this._context.execute();
	        this._context._iAddResource(this);
	    }
	    Object.defineProperty(TextureFlash.prototype, "width", {
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureFlash.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureFlash.prototype.dispose = function () {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.disposeTexture) + this._pId.toString() + ",");
	        this._context.execute();
	        this._context._iRemoveResource(this);
	        this._context = null;
	    };
	    TextureFlash.prototype.uploadFromData = function (data, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        if (data instanceof HTMLImageElement) {
	            var can = document.createElement("canvas");
	            var w = data.width;
	            var h = data.height;
	            can.width = w;
	            can.height = h;
	            var ctx = can.getContext("2d");
	            ctx.drawImage(data, 0, 0);
	            data = ctx.getImageData(0, 0, w, h).data;
	        }
	        var pos = 0;
	        var bytes = ByteArrayBase_1.ByteArrayBase.internalGetBase64String(data.length, function () {
	            return data[pos++];
	        }, null);
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.uploadBytesTexture) + this._pId + "," + miplevel + "," + (this._width >> miplevel) + "," + (this._height >> miplevel) + "," + bytes + "%");
	        this._context.execute();
	    };
	    return TextureFlash;
	}(ResourceBaseFlash_1.ResourceBaseFlash));
	exports.TextureFlash = TextureFlash;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var OpCodes_1 = __webpack_require__(88);
	var ResourceBaseFlash_1 = __webpack_require__(89);
	var VertexBufferFlash = (function (_super) {
	    __extends(VertexBufferFlash, _super);
	    function VertexBufferFlash(context, numVertices, dataPerVertex) {
	        _super.call(this);
	        this._context = context;
	        this._numVertices = numVertices;
	        this._dataPerVertex = dataPerVertex;
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.initVertexBuffer, dataPerVertex + OpCodes_1.OpCodes.intMask) + numVertices.toString() + ",");
	        this._pId = this._context.execute();
	        this._context._iAddResource(this);
	    }
	    VertexBufferFlash.prototype.uploadFromArray = function (data, startVertex, numVertices) {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.uploadArrayVertexBuffer, this._pId + OpCodes_1.OpCodes.intMask) + data.join() + "#" + [startVertex, numVertices].join() + ",");
	        this._context.execute();
	    };
	    VertexBufferFlash.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
	    };
	    Object.defineProperty(VertexBufferFlash.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferFlash.prototype, "dataPerVertex", {
	        get: function () {
	            return this._dataPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    VertexBufferFlash.prototype.dispose = function () {
	        this._context.addStream(String.fromCharCode(OpCodes_1.OpCodes.disposeVertexBuffer, this._pId + OpCodes_1.OpCodes.intMask));
	        this._context.execute();
	        this._context._iRemoveResource(this);
	        this._context = null;
	    };
	    return VertexBufferFlash;
	}(ResourceBaseFlash_1.ResourceBaseFlash));
	exports.VertexBufferFlash = VertexBufferFlash;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImage2D_1 = __webpack_require__(95);
	var Matrix3D_1 = __webpack_require__(32);
	var Matrix_1 = __webpack_require__(102);
	var Point_1 = __webpack_require__(58);
	var Vector3D_1 = __webpack_require__(34);
	var Rectangle_1 = __webpack_require__(57);
	var ColorUtils_1 = __webpack_require__(28);
	var ContextGLBlendFactor_1 = __webpack_require__(41);
	var ContextGLClearMask_1 = __webpack_require__(42);
	var ContextGLCompareMode_1 = __webpack_require__(43);
	var ContextGLProgramType_1 = __webpack_require__(47);
	var ContextGLTriangleFace_1 = __webpack_require__(51);
	var IndexBufferSoftware_1 = __webpack_require__(104);
	var VertexBufferSoftware_1 = __webpack_require__(105);
	var TextureSoftware_1 = __webpack_require__(106);
	var ProgramSoftware_1 = __webpack_require__(107);
	var SoftwareSamplerState_1 = __webpack_require__(109);
	var ContextSoftware = (function () {
	    function ContextSoftware(canvas) {
	        this._backBufferRect = new Rectangle_1.Rectangle();
	        this._backBufferWidth = 100;
	        this._backBufferHeight = 100;
	        this._cullingMode = ContextGLTriangleFace_1.ContextGLTriangleFace.BACK;
	        this._blendSource = ContextGLBlendFactor_1.ContextGLBlendFactor.ONE;
	        this._blendDestination = ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO;
	        this._colorMaskR = true;
	        this._colorMaskG = true;
	        this._colorMaskB = true;
	        this._colorMaskA = true;
	        this._writeDepth = true;
	        this._depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS;
	        this._screenMatrix = new Matrix3D_1.Matrix3D();
	        this._frontBufferMatrix = new Matrix_1.Matrix();
	        this._bboxMin = new Point_1.Point();
	        this._bboxMax = new Point_1.Point();
	        this._clamp = new Point_1.Point();
	        this._samplerStates = [];
	        this._textures = [];
	        this._vertexBuffers = [];
	        this._vertexBufferOffsets = [];
	        this._vertexBufferFormats = [];
	        //public static _drawCallback:Function = null;
	        this._antialias = 0;
	        this._sx = new Vector3D_1.Vector3D();
	        this._sy = new Vector3D_1.Vector3D();
	        this._u = new Vector3D_1.Vector3D();
	        this._canvas = canvas;
	        this._backBufferColor = new BitmapImage2D_1.BitmapImage2D(this._backBufferWidth, this._backBufferHeight, false, 0, false);
	        this._frontBuffer = new BitmapImage2D_1.BitmapImage2D(this._backBufferWidth, this._backBufferHeight, true, 0, false);
	        if (document && document.body)
	            document.body.appendChild(this._frontBuffer.getCanvas());
	    }
	    Object.defineProperty(ContextSoftware.prototype, "frontBuffer", {
	        get: function () {
	            return this._frontBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ContextSoftware.prototype, "container", {
	        get: function () {
	            return this._canvas;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ContextSoftware.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
	        if (red === void 0) { red = 0; }
	        if (green === void 0) { green = 0; }
	        if (blue === void 0) { blue = 0; }
	        if (alpha === void 0) { alpha = 1; }
	        if (depth === void 0) { depth = 1; }
	        if (stencil === void 0) { stencil = 0; }
	        if (mask === void 0) { mask = ContextGLClearMask_1.ContextGLClearMask.ALL; }
	        this._backBufferColor.lock();
	        if (mask & ContextGLClearMask_1.ContextGLClearMask.COLOR) {
	            this._colorClearUint32.fill(((alpha * 0xFF << 24) | (red * 0xFF << 16) | (green * 0xFF << 8) | blue * 0xFF));
	            this._backBufferColor.setPixels(this._backBufferRect, this._colorClearUint8);
	        }
	        //TODO: mask & ContextGLClearMask.STENCIL
	        if (mask & ContextGLClearMask_1.ContextGLClearMask.DEPTH)
	            this._zbuffer.set(this._zbufferClear); //fast memcpy
	    };
	    ContextSoftware.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
	        this._antialias = antiAlias;
	        if (this._antialias % 2 != 0)
	            this._antialias = Math.floor(this._antialias - 0.5);
	        if (this._antialias == 0)
	            this._antialias = 1;
	        this._frontBuffer._setSize(width, height);
	        this._backBufferWidth = width * this._antialias;
	        this._backBufferHeight = height * this._antialias;
	        //double buffer for fast clearing
	        var len = this._backBufferWidth * this._backBufferHeight;
	        var zbufferBytes = new ArrayBuffer(len * 8);
	        this._zbuffer = new Float32Array(zbufferBytes, 0, len);
	        this._zbufferClear = new Float32Array(zbufferBytes, len * 4, len);
	        for (var i = 0; i < len; i++)
	            this._zbufferClear[i] = 10000000;
	        var colorClearBuffer = new ArrayBuffer(len * 4);
	        this._colorClearUint8 = new Uint8ClampedArray(colorClearBuffer);
	        this._colorClearUint32 = new Uint32Array(colorClearBuffer);
	        this._backBufferRect.width = this._backBufferWidth;
	        this._backBufferRect.height = this._backBufferHeight;
	        this._backBufferColor._setSize(this._backBufferWidth, this._backBufferHeight);
	        var raw = this._screenMatrix.rawData;
	        raw[0] = this._backBufferWidth / 2;
	        raw[1] = 0;
	        raw[2] = 0;
	        raw[3] = this._backBufferWidth / 2;
	        raw[4] = 0;
	        raw[5] = -this._backBufferHeight / 2;
	        raw[6] = 0;
	        raw[7] = this._backBufferHeight / 2;
	        raw[8] = 0;
	        raw[9] = 0;
	        raw[10] = 1;
	        raw[11] = 0;
	        raw[12] = 0;
	        raw[13] = 0;
	        raw[14] = 0;
	        raw[15] = 0;
	        this._screenMatrix.transpose();
	        this._frontBufferMatrix = new Matrix_1.Matrix();
	        this._frontBufferMatrix.scale(1 / this._antialias, 1 / this._antialias);
	    };
	    ContextSoftware.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
	        //TODO: impl
	        return undefined;
	    };
	    ContextSoftware.prototype.createIndexBuffer = function (numIndices) {
	        return new IndexBufferSoftware_1.IndexBufferSoftware(numIndices);
	    };
	    ContextSoftware.prototype.createProgram = function () {
	        return new ProgramSoftware_1.ProgramSoftware();
	    };
	    ContextSoftware.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
	        return new TextureSoftware_1.TextureSoftware(width, height);
	    };
	    ContextSoftware.prototype.createVertexBuffer = function (numVertices, dataPerVertex) {
	        return new VertexBufferSoftware_1.VertexBufferSoftware(numVertices, dataPerVertex);
	    };
	    ContextSoftware.prototype.dispose = function () {
	    };
	    ContextSoftware.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
	        this._blendSource = sourceFactor;
	        this._blendDestination = destinationFactor;
	    };
	    ContextSoftware.prototype.setColorMask = function (red, green, blue, alpha) {
	        this._colorMaskR = red;
	        this._colorMaskG = green;
	        this._colorMaskB = blue;
	        this._colorMaskA = alpha;
	    };
	    ContextSoftware.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
	        //TODO:
	    };
	    ContextSoftware.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
	        //TODO:
	    };
	    ContextSoftware.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
	        //TODO: CoordinateSystem.RIGHT_HAND
	        this._cullingMode = triangleFaceToCull;
	    };
	    ContextSoftware.prototype.setDepthTest = function (depthMask, passCompareMode) {
	        this._writeDepth = depthMask;
	        this._depthCompareMode = passCompareMode;
	    };
	    ContextSoftware.prototype.setProgram = function (program) {
	        this._program = program;
	    };
	    ContextSoftware.prototype.setProgramConstantsFromArray = function (programType, data) {
	        var target;
	        if (programType == ContextGLProgramType_1.ContextGLProgramType.VERTEX)
	            target = this._vertexConstants = new Float32Array(data.length);
	        else if (programType == ContextGLProgramType_1.ContextGLProgramType.FRAGMENT)
	            target = this._fragmentConstants = new Float32Array(data.length);
	        target.set(data);
	    };
	    ContextSoftware.prototype.setTextureAt = function (sampler, texture) {
	        this._textures[sampler] = texture;
	    };
	    ContextSoftware.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
	        this._vertexBuffers[index] = buffer;
	        this._vertexBufferOffsets[index] = bufferOffset;
	        this._vertexBufferFormats[index] = format;
	    };
	    ContextSoftware.prototype.present = function () {
	        this._backBufferColor.unlock();
	        this._frontBuffer.fillRect(this._frontBuffer.rect, ColorUtils_1.ColorUtils.ARGBtoFloat32(0, 0, 0, 0));
	        this._frontBuffer.draw(this._backBufferColor, this._frontBufferMatrix);
	    };
	    ContextSoftware.prototype.drawToBitmapImage2D = function (destination) {
	    };
	    ContextSoftware.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
	        if (!this._program)
	            return;
	        var position0 = new Float32Array(4);
	        var position1 = new Float32Array(4);
	        var position2 = new Float32Array(4);
	        var varying0 = new Float32Array(this._program.numVarying * 4);
	        var varying1 = new Float32Array(this._program.numVarying * 4);
	        var varying2 = new Float32Array(this._program.numVarying * 4);
	        if (this._cullingMode == ContextGLTriangleFace_1.ContextGLTriangleFace.BACK) {
	            for (var i = firstIndex; i < numIndices; i += 3) {
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position0, varying0);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position2, varying2);
	                this._triangle(position0, position1, position2, varying0, varying1, varying2);
	            }
	        }
	        else if (this._cullingMode == ContextGLTriangleFace_1.ContextGLTriangleFace.FRONT) {
	            for (var i = firstIndex; i < numIndices; i += 3) {
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position0, varying0);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position2, varying2);
	                this._triangle(position0, position1, position2, varying0, varying1, varying2);
	            }
	        }
	        else if (this._cullingMode == ContextGLTriangleFace_1.ContextGLTriangleFace.FRONT_AND_BACK || this._cullingMode == ContextGLTriangleFace_1.ContextGLTriangleFace.NONE) {
	            for (var i = firstIndex; i < numIndices; i += 3) {
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position0, varying0);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position2, varying2);
	                this._triangle(position0, position1, position2, varying0, varying1, varying2);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position0, varying0);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
	                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position2, varying2);
	                this._triangle(position0, position1, position2, varying0, varying1, varying2);
	            }
	        }
	    };
	    ContextSoftware.prototype.drawVertices = function (mode, firstVertex, numVertices) {
	        //TODO:
	    };
	    ContextSoftware.prototype.setScissorRectangle = function (rectangle) {
	        //TODO:
	    };
	    ContextSoftware.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
	        var state = this._samplerStates[sampler];
	        if (!state)
	            state = this._samplerStates[sampler] = new SoftwareSamplerState_1.SoftwareSamplerState();
	        state.wrap = wrap;
	        state.filter = filter;
	        state.mipfilter = mipfilter;
	    };
	    ContextSoftware.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
	        //TODO:
	    };
	    ContextSoftware.prototype.setRenderToBackBuffer = function () {
	        //TODO:
	    };
	    ContextSoftware.prototype._putPixel = function (x, y, source, dest) {
	        argb[0] = 0;
	        argb[1] = 0;
	        argb[2] = 0;
	        argb[3] = 0;
	        BlendModeSoftware[this._blendDestination](dest, dest, source);
	        BlendModeSoftware[this._blendSource](source, dest, source);
	        this._backBufferColor.setPixelData(x, y, argb);
	    };
	    ContextSoftware.prototype.clamp = function (value, min, max) {
	        if (min === void 0) { min = 0; }
	        if (max === void 0) { max = 1; }
	        return Math.max(min, Math.min(value, max));
	    };
	    ContextSoftware.prototype.interpolate = function (min, max, gradient) {
	        return min + (max - min) * this.clamp(gradient);
	    };
	    ContextSoftware.prototype._triangle = function (position0, position1, position2, varying0, varying1, varying2) {
	        var p0 = new Vector3D_1.Vector3D(position0[0], position0[1], position0[2], position0[3]);
	        if (!p0 || p0.w == 0 || isNaN(p0.w)) {
	            console.error("wrong position: " + position0);
	            return;
	        }
	        var p1 = new Vector3D_1.Vector3D(position1[0], position1[1], position1[2], position1[3]);
	        var p2 = new Vector3D_1.Vector3D(position2[0], position2[1], position2[2], position2[3]);
	        p0.z = p0.z * 2 - p0.w;
	        p1.z = p1.z * 2 - p1.w;
	        p2.z = p2.z * 2 - p2.w;
	        p0.scaleBy(1 / p0.w);
	        p1.scaleBy(1 / p1.w);
	        p2.scaleBy(1 / p2.w);
	        var project = new Vector3D_1.Vector3D(p0.w, p1.w, p2.w);
	        p0 = this._screenMatrix.transformVector(p0);
	        p1 = this._screenMatrix.transformVector(p1);
	        p2 = this._screenMatrix.transformVector(p2);
	        var depth = new Vector3D_1.Vector3D(p0.z, p1.z, p2.z);
	        this._bboxMin.x = 1000000;
	        this._bboxMin.y = 1000000;
	        this._bboxMax.x = -1000000;
	        this._bboxMax.y = -1000000;
	        this._clamp.x = this._backBufferWidth - 1;
	        this._clamp.y = this._backBufferHeight - 1;
	        this._bboxMin.x = Math.max(0, Math.min(this._bboxMin.x, p0.x));
	        this._bboxMin.y = Math.max(0, Math.min(this._bboxMin.y, p0.y));
	        this._bboxMin.x = Math.max(0, Math.min(this._bboxMin.x, p1.x));
	        this._bboxMin.y = Math.max(0, Math.min(this._bboxMin.y, p1.y));
	        this._bboxMin.x = Math.max(0, Math.min(this._bboxMin.x, p2.x));
	        this._bboxMin.y = Math.max(0, Math.min(this._bboxMin.y, p2.y));
	        this._bboxMax.x = Math.min(this._clamp.x, Math.max(this._bboxMax.x, p0.x));
	        this._bboxMax.y = Math.min(this._clamp.y, Math.max(this._bboxMax.y, p0.y));
	        this._bboxMax.x = Math.min(this._clamp.x, Math.max(this._bboxMax.x, p1.x));
	        this._bboxMax.y = Math.min(this._clamp.y, Math.max(this._bboxMax.y, p1.y));
	        this._bboxMax.x = Math.min(this._clamp.x, Math.max(this._bboxMax.x, p2.x));
	        this._bboxMax.y = Math.min(this._clamp.y, Math.max(this._bboxMax.y, p2.y));
	        this._bboxMin.x = Math.floor(this._bboxMin.x);
	        this._bboxMin.y = Math.floor(this._bboxMin.y);
	        this._bboxMax.x = Math.floor(this._bboxMax.x);
	        this._bboxMax.y = Math.floor(this._bboxMax.y);
	        for (var x = this._bboxMin.x; x <= this._bboxMax.x; x++)
	            for (var y = this._bboxMin.y; y <= this._bboxMax.y; y++) {
	                var screen = this._barycentric(p0, p1, p2, x, y);
	                if (screen.x < 0 || screen.y < 0 || screen.z < 0)
	                    continue;
	                var screenRight = this._barycentric(p0, p1, p2, x + 1, y);
	                var screenBottom = this._barycentric(p0, p1, p2, x, y + 1);
	                var clip = new Vector3D_1.Vector3D(screen.x / project.x, screen.y / project.y, screen.z / project.z);
	                clip.scaleBy(1 / (clip.x + clip.y + clip.z));
	                var clipRight = new Vector3D_1.Vector3D(screenRight.x / project.x, screenRight.y / project.y, screenRight.z / project.z);
	                clipRight.scaleBy(1 / (clipRight.x + clipRight.y + clipRight.z));
	                var clipBottom = new Vector3D_1.Vector3D(screenBottom.x / project.x, screenBottom.y / project.y, screenBottom.z / project.z);
	                clipBottom.scaleBy(1 / (clipBottom.x + clipBottom.y + clipBottom.z));
	                var index = (x % this._backBufferWidth) + y * this._backBufferWidth;
	                var fragDepth = depth.x * screen.x + depth.y * screen.y + depth.z * screen.z;
	                if (!DepthCompareModeSoftware[this._depthCompareMode](fragDepth, this._zbuffer[index]))
	                    continue;
	                var fragmentVO = this._program.fragment(this, clip, clipRight, clipBottom, varying0, varying1, varying2, fragDepth);
	                if (fragmentVO.discard)
	                    continue;
	                if (this._writeDepth)
	                    this._zbuffer[index] = fragDepth; //todo: fragmentVO.outputDepth?
	                //set source
	                source[0] = fragmentVO.outputColor[0] * 255;
	                source[1] = fragmentVO.outputColor[1] * 255;
	                source[2] = fragmentVO.outputColor[2] * 255;
	                source[3] = fragmentVO.outputColor[3] * 255;
	                //set dest
	                this._backBufferColor.getPixelData(x, y, dest);
	                this._putPixel(x, y, source, dest);
	            }
	    };
	    ContextSoftware.prototype._barycentric = function (a, b, c, x, y) {
	        this._sx.x = c.x - a.x;
	        this._sx.y = b.x - a.x;
	        this._sx.z = a.x - x;
	        this._sy.x = c.y - a.y;
	        this._sy.y = b.y - a.y;
	        this._sy.z = a.y - y;
	        this._u = this._sx.crossProduct(this._sy, this._u);
	        if (this._u.z < 0.01)
	            return new Vector3D_1.Vector3D(1 - (this._u.x + this._u.y) / this._u.z, this._u.y / this._u.z, this._u.x / this._u.z);
	        return new Vector3D_1.Vector3D(-1, 1, 1);
	    };
	    ContextSoftware.MAX_SAMPLERS = 8;
	    return ContextSoftware;
	}());
	exports.ContextSoftware = ContextSoftware;
	var BlendModeSoftware = (function () {
	    function BlendModeSoftware() {
	    }
	    BlendModeSoftware.destinationAlpha = function (result, dest, source) {
	        argb[0] += result[0] * dest[0] / 0xFF;
	        argb[1] += result[1] * dest[0] / 0xFF;
	        argb[2] += result[2] * dest[0] / 0xFF;
	        argb[3] += result[3] * dest[0] / 0xFF;
	    };
	    BlendModeSoftware.destinationColor = function (result, dest, source) {
	        argb[0] += result[0] * dest[0] / 0xFF;
	        argb[1] += result[1] * dest[1] / 0xFF;
	        argb[2] += result[2] * dest[2] / 0xFF;
	        argb[3] += result[3] * dest[3] / 0xFF;
	    };
	    BlendModeSoftware.zero = function (result, dest, source) {
	    };
	    BlendModeSoftware.one = function (result, dest, source) {
	        argb[0] += result[0];
	        argb[1] += result[1];
	        argb[2] += result[2];
	        argb[3] += result[3];
	    };
	    BlendModeSoftware.oneMinusDestinationAlpha = function (result, dest, source) {
	        argb[0] += result[0] * (1 - dest[0] / 0xFF);
	        argb[1] += result[1] * (1 - dest[0] / 0xFF);
	        argb[2] += result[2] * (1 - dest[0] / 0xFF);
	        argb[3] += result[3] * (1 - dest[0] / 0xFF);
	    };
	    BlendModeSoftware.oneMinusDestinationColor = function (result, dest, source) {
	        argb[0] += result[0] * (1 - dest[0] / 0xFF);
	        argb[1] += result[1] * (1 - dest[1] / 0xFF);
	        argb[2] += result[2] * (1 - dest[2] / 0xFF);
	        argb[3] += result[3] * (1 - dest[3] / 0xFF);
	    };
	    BlendModeSoftware.oneMinusSourceAlpha = function (result, dest, source) {
	        argb[0] += result[0] * (1 - source[0] / 0xFF);
	        argb[1] += result[1] * (1 - source[0] / 0xFF);
	        argb[2] += result[2] * (1 - source[0] / 0xFF);
	        argb[3] += result[3] * (1 - source[0] / 0xFF);
	    };
	    BlendModeSoftware.oneMinusSourceColor = function (result, dest, source) {
	        argb[0] += result[0] * (1 - source[0] / 0xFF);
	        argb[1] += result[1] * (1 - source[1] / 0xFF);
	        argb[2] += result[2] * (1 - source[2] / 0xFF);
	        argb[3] += result[3] * (1 - source[3] / 0xFF);
	    };
	    BlendModeSoftware.sourceAlpha = function (result, dest, source) {
	        argb[0] += result[0] * source[0] / 0xFF;
	        argb[1] += result[1] * source[0] / 0xFF;
	        argb[2] += result[2] * source[0] / 0xFF;
	        argb[3] += result[3] * source[0] / 0xFF;
	    };
	    BlendModeSoftware.sourceColor = function (result, dest, source) {
	        argb[0] += result[0] * source[0] / 0xFF;
	        argb[1] += result[1] * source[1] / 0xFF;
	        argb[2] += result[2] * source[2] / 0xFF;
	        argb[3] += result[3] * source[3] / 0xFF;
	    };
	    return BlendModeSoftware;
	}());
	exports.BlendModeSoftware = BlendModeSoftware;
	var DepthCompareModeSoftware = (function () {
	    function DepthCompareModeSoftware() {
	    }
	    DepthCompareModeSoftware.always = function (fragDepth, currentDepth) {
	        return true;
	    };
	    DepthCompareModeSoftware.equal = function (fragDepth, currentDepth) {
	        return fragDepth == currentDepth;
	    };
	    DepthCompareModeSoftware.greater = function (fragDepth, currentDepth) {
	        return fragDepth > currentDepth;
	    };
	    DepthCompareModeSoftware.greaterEqual = function (fragDepth, currentDepth) {
	        return fragDepth >= currentDepth;
	    };
	    DepthCompareModeSoftware.less = function (fragDepth, currentDepth) {
	        return fragDepth < currentDepth;
	    };
	    DepthCompareModeSoftware.lessEqual = function (fragDepth, currentDepth) {
	        return fragDepth <= currentDepth;
	    };
	    DepthCompareModeSoftware.never = function (fragDepth, currentDepth) {
	        return false;
	    };
	    DepthCompareModeSoftware.notEqual = function (fragDepth, currentDepth) {
	        return fragDepth != currentDepth;
	    };
	    return DepthCompareModeSoftware;
	}());
	exports.DepthCompareModeSoftware = DepthCompareModeSoftware;
	var argb = new Uint8ClampedArray(4);
	var source = new Uint8ClampedArray(4);
	var dest = new Uint8ClampedArray(4);


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(96);
	var ColorUtils_1 = __webpack_require__(28);
	var BitmapImageUtils_1 = __webpack_require__(99);
	var CPUCanvas_1 = __webpack_require__(100);
	/**
	 * The BitmapImage2D export class lets you work with the data(pixels) of a Bitmap
	 * object. You can use the methods of the BitmapImage2D export class to create
	 * arbitrarily sized transparent or opaque bitmap images and manipulate them
	 * in various ways at runtime. You can also access the BitmapImage2D for a bitmap
	 * image that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes.
	 *
	 * <p>This export class lets you separate bitmap rendering operations from the
	 * internal display updating routines of flash. By manipulating a
	 * BitmapImage2D object directly, you can create complex images without incurring
	 * the per-frame overhead of constantly redrawing the content from vector
	 * data.</p>
	 *
	 * <p>The methods of the BitmapImage2D export class support effects that are not
	 * available through the filters available to non-bitmap display objects.</p>
	 *
	 * <p>A BitmapImage2D object contains an array of pixel data. This data can
	 * represent either a fully opaque bitmap or a transparent bitmap that
	 * contains alpha channel data. Either type of BitmapImage2D object is stored as
	 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
	 * of a single pixel in the bitmap.</p>
	 *
	 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
	 * 0 to 255) that describe the alpha transparency and the red, green, and blue
	 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
	 * represents the alpha channel value, followed by red, green, and blue.)</p>
	 *
	 * <p>The four channels(alpha, red, green, and blue) are represented as
	 * numbers when you use them with the <code>BitmapImage2D.copyChannel()</code>
	 * method or the <code>DisplacementMapFilter.componentX</code> and
	 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
	 * are represented by the following constants in the BitmapImage2DChannel
	 * class:</p>
	 *
	 * <ul>
	 *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	 *   <li><code>BitmapImage2DChannel.RED</code></li>
	 *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	 *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	 * </ul>
	 *
	 * <p>You can attach BitmapImage2D objects to a Bitmap object by using the
	 * <code>bitmapData</code> property of the Bitmap object.</p>
	 *
	 * <p>You can use a BitmapImage2D object to fill a Graphics object by using the
	 * <code>Graphics.beginBitmapFill()</code> method.</p>
	 *
	 * <p>You can also use a BitmapImage2D object to perform batch tile rendering
	 * using the <code>flash.display.Tilesheet</code> class.</p>
	 *
	 * <p>In Flash Player 10, the maximum size for a BitmapImage2D object
	 * is 8,191 pixels in width or height, and the total number of pixels cannot
	 * exceed 16,777,215 pixels.(So, if a BitmapImage2D object is 8,191 pixels wide,
	 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation
	 * is 2,880 pixels in height and 2,880 in width.</p>
	 */
	var BitmapImage2D = (function (_super) {
	    __extends(BitmapImage2D, _super);
	    /**
	     * Creates a BitmapImage2D object with a specified width and height. If you
	     * specify a value for the <code>fillColor</code> parameter, every pixel in
	     * the bitmap is set to that color.
	     *
	     * <p>By default, the bitmap is created as transparent, unless you pass
	     * the value <code>false</code> for the transparent parameter. After you
	     * create an opaque bitmap, you cannot change it to a transparent bitmap.
	     * Every pixel in an opaque bitmap uses only 24 bits of color channel
	     * information. If you define the bitmap as transparent, every pixel uses 32
	     * bits of color channel information, including an alpha transparency
	     * channel.</p>
	     *
	     * @param width       The width of the bitmap image in pixels.
	     * @param height      The height of the bitmap image in pixels.
	     * @param transparent Specifies whether the bitmap image supports per-pixel
	     *                    transparency. The default value is <code>true</code>
	     *                    (transparent). To create a fully transparent bitmap,
	     *                    set the value of the <code>transparent</code>
	     *                    parameter to <code>true</code> and the value of the
	     *                    <code>fillColor</code> parameter to 0x00000000(or to
	     *                    0). Setting the <code>transparent</code> property to
	     *                    <code>false</code> can result in minor improvements
	     *                    in rendering performance.
	     * @param fillColor   A 32-bit ARGB color value that you use to fill the
	     *                    bitmap image area. The default value is
	     *                    0xFFFFFFFF(solid white).
	     */
	    function BitmapImage2D(width, height, transparent, fillColor, powerOfTwo) {
	        if (transparent === void 0) { transparent = true; }
	        if (fillColor === void 0) { fillColor = null; }
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        _super.call(this, width, height, powerOfTwo);
	        this._locked = false;
	        this._transparent = transparent;
	        if (typeof document !== "undefined") {
	            this._imageCanvas = document.createElement("canvas");
	        }
	        else {
	            this._imageCanvas = new CPUCanvas_1.CPUCanvas();
	        }
	        this._imageCanvas.width = width;
	        this._imageCanvas.height = height;
	        this._context = this._imageCanvas.getContext("2d");
	        if (fillColor != null)
	            this.fillRect(this._rect, fillColor);
	    }
	    Object.defineProperty(BitmapImage2D.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return BitmapImage2D.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapImage2D.prototype, "transparent", {
	        /**
	         * Defines whether the bitmap image supports per-pixel transparency. You can
	         * set this value only when you construct a BitmapImage2D object by passing in
	         * <code>true</code> for the <code>transparent</code> parameter of the
	         * constructor. Then, after you create a BitmapImage2D object, you can check
	         * whether it supports per-pixel transparency by determining if the value of
	         * the <code>transparent</code> property is <code>true</code>.
	         */
	        get: function () {
	            return this._transparent;
	        },
	        set: function (value) {
	            this._transparent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BitmapImage2D.prototype.invalidate = function () {
	        if (!this._imageDataDirty) {
	            this._imageDataDirty = true;
	            _super.prototype.invalidate.call(this);
	        }
	    };
	    /**
	     * Returns a new BitmapImage2D object that is a clone of the original instance
	     * with an exact copy of the contained bitmap.
	     *
	     * @return A new BitmapImage2D object that is identical to the original.
	     */
	    BitmapImage2D.prototype.clone = function () {
	        var t = new BitmapImage2D(this.width, this.height, this.transparent, null, this.powerOfTwo);
	        t.draw(this);
	        return t;
	    };
	    /**
	     * Adjusts the color values in a specified area of a bitmap image by using a
	     * <code>ColorTransform</code> object. If the rectangle matches the
	     * boundaries of the bitmap image, this method transforms the color values of
	     * the entire image.
	     *
	     * @param rect           A Rectangle object that defines the area of the
	     *                       image in which the ColorTransform object is applied.
	     * @param colorTransform A ColorTransform object that describes the color
	     *                       transformation values to apply.
	     */
	    BitmapImage2D.prototype.colorTransform = function (rect, colorTransform) {
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var data = this._imageData.data;
	        var i, j, index;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                index = (i + rect.x + (j + rect.y) * this.width) * 4;
	                data[index] = data[index] * colorTransform.redMultiplier + colorTransform.redOffset;
	                data[index + 1] = data[index + 1] * colorTransform.greenMultiplier + colorTransform.greenOffset;
	                data[index + 2] = data[index + 2] * colorTransform.blueMultiplier + colorTransform.blueOffset;
	                data[index + 3] = data[index + 3] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
	            }
	        }
	        if (!this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        this.invalidate();
	    };
	    /**
	     * Transfers data from one channel of another BitmapImage2D object or the
	     * current BitmapImage2D object into a channel of the current BitmapImage2D object.
	     * All of the data in the other channels in the destination BitmapImage2D object
	     * are preserved.
	     *
	     * <p>The source channel value and destination channel value can be one of
	     * following values: </p>
	     *
	     * <ul>
	     *   <li><code>BitmapImage2DChannel.RED</code></li>
	     *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	     *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	     *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	     * </ul>
	     *
	     * @param sourceBitmapImage2D The input bitmap image to use. The source image
	     *                         can be a different BitmapImage2D object or it can
	     *                         refer to the current BitmapImage2D object.
	     * @param sourceRect       The source Rectangle object. To copy only channel
	     *                         data from a smaller area within the bitmap,
	     *                         specify a source rectangle that is smaller than
	     *                         the overall size of the BitmapImage2D object.
	     * @param destPoint        The destination Point object that represents the
	     *                         upper-left corner of the rectangular area where
	     *                         the new channel data is placed. To copy only
	     *                         channel data from one area to a different area in
	     *                         the destination image, specify a point other than
	     *                        (0,0).
	     * @param sourceChannel    The source channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @param destChannel      The destination channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @throws TypeError The sourceBitmapImage2D, sourceRect or destPoint are null.
	     */
	    BitmapImage2D.prototype.copyChannel = function (sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
	        var imageData = sourceBitmap.getImageData();
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var sourceData = sourceBitmap.getImageData().data;
	        var destData = this._imageData.data;
	        var sourceOffset = Math.round(Math.log(sourceChannel) / Math.log(2));
	        var destOffset = Math.round(Math.log(destChannel) / Math.log(2));
	        var i, j, sourceIndex, destIndex;
	        for (i = 0; i < sourceRect.width; ++i) {
	            for (j = 0; j < sourceRect.height; ++j) {
	                sourceIndex = (i + sourceRect.x + (j + sourceRect.y) * sourceBitmap.width) * 4;
	                destIndex = (i + destPoint.x + (j + destPoint.y) * this.width) * 4;
	                destData[destIndex + destOffset] = sourceData[sourceIndex + sourceOffset];
	            }
	        }
	        if (!this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        this.invalidate();
	    };
	    BitmapImage2D.prototype.copyPixels = function (source, sourceRect, destRect) {
	        if (source instanceof BitmapImage2D)
	            source = source.getCanvas();
	        if (this._locked && this._imageData)
	            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	        BitmapImageUtils_1.BitmapImageUtils._copyPixels(this._context, source, sourceRect, destRect);
	        this._imageData = null;
	        this.invalidate();
	    };
	    /**
	     * Frees memory that is used to store the BitmapImage2D object.
	     *
	     * <p>When the <code>dispose()</code> method is called on an image, the width
	     * and height of the image are set to 0. All subsequent calls to methods or
	     * properties of this BitmapImage2D instance fail, and an exception is thrown.
	     * </p>
	     *
	     * <p><code>BitmapImage2D.dispose()</code> releases the memory occupied by the
	     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
	     * memory). After using <code>BitmapImage2D.dispose()</code>, the BitmapImage2D
	     * object is no longer usable and an exception may be thrown if
	     * you call functions on the BitmapImage2D object. However,
	     * <code>BitmapImage2D.dispose()</code> does not garbage collect the BitmapImage2D
	     * object(approximately 128 bytes); the memory occupied by the actual
	     * BitmapImage2D object is released at the time the BitmapImage2D object is
	     * collected by the garbage collector.</p>
	     *
	     */
	    BitmapImage2D.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this._context = null;
	        this._imageCanvas = null;
	        this._imageData = null;
	        this._rect = null;
	        this._transparent = null;
	        this._locked = null;
	    };
	    BitmapImage2D.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smoothing) {
	        if (source instanceof BitmapImage2D && source.getCanvas())
	            source = source.getCanvas();
	        if (this._locked && this._imageData)
	            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	        BitmapImageUtils_1.BitmapImageUtils._draw(this._context, source, matrix, colorTransform, blendMode, clipRect, smoothing);
	        this._imageData = null;
	        this.invalidate();
	    };
	    /**
	     * Fills a rectangular area of pixels with a specified ARGB color.
	     *
	     * @param rect  The rectangular area to fill.
	     * @param color The ARGB color value that fills the area. ARGB colors are
	     *              often specified in hexadecimal format; for example,
	     *              0xFF336699.
	     * @throws TypeError The rect is null.
	     */
	    BitmapImage2D.prototype.fillRect = function (rect, color) {
	        if (this._locked && this._imageData)
	            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	        BitmapImageUtils_1.BitmapImageUtils._fillRect(this._context, rect, color, this._transparent);
	        this._imageData = null;
	        this.invalidate();
	    };
	    /**
	     * Returns an integer that represents an RGB pixel value from a BitmapImage2D
	     * object at a specific point(<i>x</i>, <i>y</i>). The
	     * <code>getPixel()</code> method returns an unmultiplied pixel value. No
	     * alpha information is returned.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number that represents an RGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, the
	     *         method returns 0.
	     */
	    BitmapImage2D.prototype.getPixel = function (x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context.getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            if (!this._imageData)
	                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	            var index = (x + y * this._imageData.width) * 4;
	            r = this._imageData.data[index + 0];
	            g = this._imageData.data[index + 1];
	            b = this._imageData.data[index + 2];
	            a = this._imageData.data[index + 3];
	        }
	        //returns black if fully transparent
	        if (!a)
	            return 0x0;
	        return (r << 16) | (g << 8) | b;
	    };
	    /**
	     * Returns an ARGB color value that contains alpha channel data and RGB data.
	     * This method is similar to the <code>getPixel()</code> method, which
	     * returns an RGB color without alpha channel data.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number representing an ARGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
	     *         returned.
	     */
	    BitmapImage2D.prototype.getPixel32 = function (x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context.getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            if (!this._imageData)
	                this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	            var index = (x + y * this._imageData.width) * 4;
	            r = this._imageData.data[index + 0];
	            g = this._imageData.data[index + 1];
	            b = this._imageData.data[index + 2];
	            a = this._imageData.data[index + 3];
	        }
	        return (a << 24) | (r << 16) | (g << 8) | b;
	    };
	    BitmapImage2D.prototype.getPixelData = function (x, y, imagePixel) {
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var index = (x + y * this._imageData.width) * 4;
	        imagePixel[0] = this._imageData.data[index + 0];
	        imagePixel[1] = this._imageData.data[index + 1];
	        imagePixel[2] = this._imageData.data[index + 2];
	        imagePixel[3] = this._imageData.data[index + 3];
	    };
	    BitmapImage2D.prototype.setPixelData = function (x, y, imagePixel) {
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var index = (x + y * this._imageData.width) * 4;
	        this._imageData.data[index + 0] = imagePixel[0];
	        this._imageData.data[index + 1] = imagePixel[1];
	        this._imageData.data[index + 2] = imagePixel[2];
	        this._imageData.data[index + 3] = imagePixel[3];
	        this.invalidate();
	    };
	    /**
	     * Locks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are not updated when this BitmapImage2D object
	     * changes. To improve performance, use this method along with the
	     * <code>unlock()</code> method before and after numerous calls to the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method.
	     *
	     */
	    BitmapImage2D.prototype.lock = function () {
	        if (this._locked)
	            return;
	        this._locked = true;
	    };
	    /**
	     * Converts an Array into a rectangular region of pixel data. For each pixel,
	     * an Array element is read and written into the BitmapImage2D pixel. The data
	     * in the Array is expected to be 32-bit ARGB pixel values.
	     *
	     * @param rect        Specifies the rectangular region of the BitmapImage2D
	     *                    object.
	     * @param inputArray  An Array that consists of 32-bit unmultiplied pixel
	     *                    values to be used in the rectangular region.
	     * @throws RangeError The vector array is not large enough to read all the
	     *                    pixel data.
	     */
	    BitmapImage2D.prototype.setArray = function (rect, inputArray) {
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var i, j, index, argb;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                argb = ColorUtils_1.ColorUtils.float32ColorToARGB(inputArray[i + j * rect.width]);
	                index = (i + rect.x + (j + rect.y) * this._imageData.width) * 4;
	                this._imageData.data[index + 0] = argb[1];
	                this._imageData.data[index + 1] = argb[2];
	                this._imageData.data[index + 2] = argb[3];
	                this._imageData.data[index + 3] = argb[0];
	            }
	        }
	        if (!this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        this.invalidate();
	    };
	    /**
	     * Sets a single pixel of a BitmapImage2D object. The current alpha channel
	     * value of the image pixel is preserved during this operation. The value of
	     * the RGB color parameter is treated as an unmultiplied color value.
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting RGB color for the pixel.
	     */
	    BitmapImage2D.prototype.setPixel = function (x, y, color) {
	        var argb = ColorUtils_1.ColorUtils.float32ColorToARGB(color);
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var index = (x + y * this._imageData.width) * 4;
	        this._imageData.data[index + 0] = argb[1];
	        this._imageData.data[index + 1] = argb[2];
	        this._imageData.data[index + 2] = argb[3];
	        this._imageData.data[index + 3] = 0xFF;
	        if (!this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        this.invalidate();
	    };
	    /**
	     * Sets the color and alpha transparency values of a single pixel of a
	     * BitmapImage2D object. This method is similar to the <code>setPixel()</code>
	     * method; the main difference is that the <code>setPixel32()</code> method
	     * takes an ARGB color value that contains alpha channel information.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting ARGB color for the pixel. If the bitmap is
	     *              opaque(not transparent), the alpha transparency portion of
	     *              this color value is ignored.
	     */
	    BitmapImage2D.prototype.setPixel32 = function (x, y, color) {
	        var argb = ColorUtils_1.ColorUtils.float32ColorToARGB(color);
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var index = (x + y * this._imageData.width) * 4;
	        this._imageData.data[index + 0] = argb[1];
	        this._imageData.data[index + 1] = argb[2];
	        this._imageData.data[index + 2] = argb[3];
	        this._imageData.data[index + 3] = argb[0];
	        if (!this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        this.invalidate();
	    };
	    /**
	     * Converts a byte array into a rectangular region of pixel data. For each
	     * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
	     * the return value is written into the pixel. If the byte array ends before
	     * the full rectangle is written, the function returns. The data in the byte
	     * array is expected to be 32-bit ARGB pixel values. No seeking is performed
	     * on the byte array before or after the pixels are read.
	     *
	     * @param rect           Specifies the rectangular region of the BitmapImage2D
	     *                       object.
	     * @param inputByteArray A ByteArray object that consists of 32-bit
	     *                       unmultiplied pixel values to be used in the
	     *                       rectangular region.
	     * @throws EOFError  The <code>inputByteArray</code> object does not include
	     *                   enough data to fill the area of the <code>rect</code>
	     *                   rectangle. The method fills as many pixels as possible
	     *                   before throwing the exception.
	     * @throws TypeError The rect or inputByteArray are null.
	     */
	    BitmapImage2D.prototype.setPixels = function (rect, input) {
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        var i;
	        var w = this._imageData.width;
	        for (i = 0; i < rect.height; ++i)
	            this._imageData.data.set(input.subarray(i * w * 4, (i + 1) * w * 4), (rect.x + (i + rect.y) * w) * 4);
	        if (!this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        this.invalidate();
	    };
	    /**
	     * Unlocks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are updated when this BitmapImage2D object changes.
	     * To improve performance, use this method along with the <code>lock()</code>
	     * method before and after numerous calls to the <code>setPixel()</code> or
	     * <code>setPixel32()</code> method.
	     *
	     * @param changeRect The area of the BitmapImage2D object that has changed. If
	     *                   you do not specify a value for this parameter, the
	     *                   entire area of the BitmapImage2D object is considered
	     *                   changed.
	     */
	    BitmapImage2D.prototype.unlock = function () {
	        if (!this._locked)
	            return;
	        this._locked = false;
	        if (this._imageData)
	            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
	    };
	    /**
	     *
	     * @returns {ImageData}
	     */
	    BitmapImage2D.prototype.getImageData = function () {
	        if (!this._imageData)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	        return this._imageData;
	    };
	    /**
	     *
	     * @returns {HTMLCanvasElement}
	     */
	    BitmapImage2D.prototype.getCanvas = function () {
	        return this._imageCanvas;
	    };
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    BitmapImage2D.prototype._setSize = function (width, height) {
	        if (this._locked)
	            this._context.putImageData(this._imageData, 0, 0);
	        if (this._imageCanvas) {
	            this._imageCanvas.width = width;
	            this._imageCanvas.height = height;
	        }
	        _super.prototype._setSize.call(this, width, height);
	        if (this._locked)
	            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
	    };
	    BitmapImage2D.assetType = "[image BitmapImage2D]";
	    return BitmapImage2D;
	}(Image2D_1.Image2D));
	exports.BitmapImage2D = BitmapImage2D;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ImageBase_1 = __webpack_require__(97);
	var Rectangle_1 = __webpack_require__(57);
	var ImageUtils_1 = __webpack_require__(98);
	var Image2D = (function (_super) {
	    __extends(Image2D, _super);
	    /**
	     *
	     */
	    function Image2D(width, height, powerOfTwo) {
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        _super.call(this);
	        this._powerOfTwo = true;
	        this._rect = new Rectangle_1.Rectangle(0, 0, width, height);
	        this._powerOfTwo = powerOfTwo;
	        this._testDimensions();
	    }
	    Object.defineProperty(Image2D.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Image2D.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Image2D.prototype, "height", {
	        /**
	         * The height of the image in pixels.
	         */
	        get: function () {
	            return this._rect.height;
	        },
	        set: function (value) {
	            if (this._rect.height == value)
	                return;
	            this._setSize(this._rect.width, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Image2D.prototype, "rect", {
	        /**
	         * The rectangle that defines the size and location of the bitmap image. The
	         * top and left of the rectangle are 0; the width and height are equal to the
	         * width and height in pixels of the BitmapData object.
	         */
	        get: function () {
	            return this._rect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Image2D.prototype, "width", {
	        /**
	         * The width of the bitmap image in pixels.
	         */
	        get: function () {
	            return this._rect.width;
	        },
	        set: function (value) {
	            if (this._rect.width == value)
	                return;
	            this._setSize(value, this._rect.height);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    Image2D.prototype._setSize = function (width, height) {
	        if (this._rect.width != width || this._rect.height != height)
	            this.clear();
	        this._rect.width = width;
	        this._rect.height = height;
	        this._testDimensions();
	    };
	    /**
	     *
	     * @private
	     */
	    Image2D.prototype._testDimensions = function () {
	        if (this._powerOfTwo && (!ImageUtils_1.ImageUtils.isDimensionValid(this._rect.width) || !ImageUtils_1.ImageUtils.isDimensionValid(this._rect.height)))
	            throw new Error("Invalid dimension: Width and height must be power of 2 and cannot exceed 2048");
	    };
	    Object.defineProperty(Image2D.prototype, "powerOfTwo", {
	        /**
	         * Enable POT texture size validation
	         * @returns {boolean}
	         */
	        get: function () {
	            return this._powerOfTwo;
	        },
	        set: function (value) {
	            if (this._powerOfTwo == value)
	                return;
	            this._powerOfTwo = value;
	            this._testDimensions();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Image2D.assetType = "[image Image2D]";
	    return Image2D;
	}(ImageBase_1.ImageBase));
	exports.Image2D = Image2D;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var ImageBase = (function (_super) {
	    __extends(ImageBase, _super);
	    /**
	     *
	     */
	    function ImageBase() {
	        _super.call(this);
	        this._pFormat = "bgra";
	    }
	    Object.defineProperty(ImageBase.prototype, "format", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._pFormat;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ImageBase;
	}(AssetBase_1.AssetBase));
	exports.ImageBase = ImageBase;


/***/ },
/* 98 */
/***/ function(module, exports) {

	"use strict";
	var ImageUtils = (function () {
	    function ImageUtils() {
	    }
	    ImageUtils.isImage2DValid = function (image2D) {
	        if (image2D == null)
	            return true;
	        return ImageUtils.isDimensionValid(image2D.width, image2D.powerOfTwo) && ImageUtils.isDimensionValid(image2D.height, image2D.powerOfTwo);
	    };
	    ImageUtils.isHTMLImageElementValid = function (image) {
	        if (image == null)
	            return true;
	        return ImageUtils.isDimensionValid(image.width) && ImageUtils.isDimensionValid(image.height);
	    };
	    ImageUtils.isDimensionValid = function (d, powerOfTwo) {
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        return d >= 1 && d <= ImageUtils.MAX_SIZE && (!powerOfTwo || ImageUtils.isPowerOfTwo(d));
	    };
	    ImageUtils.isPowerOfTwo = function (value) {
	        return value ? ((value & -value) == value) : false;
	    };
	    ImageUtils.getBestPowerOf2 = function (value) {
	        var p = 1;
	        while (p < value)
	            p <<= 1;
	        if (p > ImageUtils.MAX_SIZE)
	            p = ImageUtils.MAX_SIZE;
	        return p;
	    };
	    ImageUtils.MAX_SIZE = 8192;
	    return ImageUtils;
	}());
	exports.ImageUtils = ImageUtils;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageUtils;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ColorUtils_1 = __webpack_require__(28);
	var BitmapImageUtils = (function () {
	    function BitmapImageUtils() {
	    }
	    BitmapImageUtils._fillRect = function (context, rect, color, transparent) {
	        if (color == 0x0 && transparent) {
	            context.clearRect(rect.x, rect.y, rect.width, rect.height);
	        }
	        else {
	            var argb = ColorUtils_1.ColorUtils.float32ColorToARGB(color);
	            if (transparent)
	                context.fillStyle = 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',' + argb[0] / 255 + ')';
	            else
	                context.fillStyle = 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',1)';
	            context.fillRect(rect.x, rect.y, rect.width, rect.height);
	        }
	    };
	    BitmapImageUtils._copyPixels = function (context, bmpd, sourceRect, destRect) {
	        context.drawImage(bmpd, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destRect.x, destRect.y, destRect.width, destRect.height);
	    };
	    BitmapImageUtils._draw = function (context, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
	        context.save();
	        if (matrix != null)
	            context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
	        if (clipRect != null)
	            context.drawImage(source, clipRect.x, clipRect.y, clipRect.width, clipRect.height);
	        else
	            context.drawImage(source, 0, 0);
	        context.restore();
	    };
	    return BitmapImageUtils;
	}());
	exports.BitmapImageUtils = BitmapImageUtils;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CPURenderingContext2D_1 = __webpack_require__(101);
	var ImageData_1 = __webpack_require__(103);
	var CPUCanvas = (function () {
	    function CPUCanvas() {
	        this.width = 1;
	        this.height = 1;
	        this.reset();
	    }
	    CPUCanvas.prototype.getContext = function (contextId) {
	        var args = [];
	        for (var _i = 1; _i < arguments.length; _i++) {
	            args[_i - 1] = arguments[_i];
	        }
	        return new CPURenderingContext2D_1.CPURenderingContext2D(this);
	    };
	    CPUCanvas.prototype.reset = function () {
	        if (!this.imageData) {
	            this.imageData = new ImageData_1.ImageData(this.width, this.height);
	        }
	        else {
	            this.imageData.width = this.width;
	            this.imageData.height = this.height;
	            if (this.imageData.data) {
	                //this.imageData.data.length = 0;
	                this.imageData.data = null;
	            }
	            this.imageData.data = new Uint8Array(this.width * this.height * 4);
	        }
	        for (var i = 0; i < this.width * this.height * 4; i += 4) {
	            this.imageData.data[i] = 255;
	            this.imageData.data[i + 1] = 255;
	            this.imageData.data[i + 2] = 255;
	            this.imageData.data[i + 3] = 255;
	        }
	    };
	    CPUCanvas.prototype.getImageData = function () {
	        if (this.imageData.width != this.width || this.imageData.height != this.height) {
	            this.reset();
	        }
	        return this.imageData;
	    };
	    return CPUCanvas;
	}());
	exports.CPUCanvas = CPUCanvas;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CPUCanvas;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImage2D_1 = __webpack_require__(95);
	var Matrix_1 = __webpack_require__(102);
	var Point_1 = __webpack_require__(58);
	//TODO: implement all methods
	var CPURenderingContext2D = (function () {
	    function CPURenderingContext2D(cpuCanvas) {
	        this.point = new Point_1.Point();
	        this.point2 = new Point_1.Point();
	        this.cpuCanvas = cpuCanvas;
	    }
	    CPURenderingContext2D.prototype.restore = function () {
	        this.matrix = null;
	    };
	    CPURenderingContext2D.prototype.setTransform = function (m11, m12, m21, m22, dx, dy) {
	        this.matrix = new Matrix_1.Matrix(m11, m12, m21, m22, dx, dy);
	    };
	    CPURenderingContext2D.prototype.save = function () {
	    };
	    CPURenderingContext2D.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
	    };
	    CPURenderingContext2D.prototype.measureText = function (text) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.isPointInPath = function (x, y, fillRule) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
	    };
	    CPURenderingContext2D.prototype.putImageData = function (imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
	    };
	    CPURenderingContext2D.prototype.rotate = function (angle) {
	    };
	    CPURenderingContext2D.prototype.fillText = function (text, x, y, maxWidth) {
	    };
	    CPURenderingContext2D.prototype.translate = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.scale = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.ellipse = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
	    };
	    CPURenderingContext2D.prototype.lineTo = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.getLineDash = function () {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.fill = function (fillRule) {
	    };
	    CPURenderingContext2D.prototype.createImageData = function (imageDataOrSw, sh) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.createPattern = function (image, repetition) {
	        return undefined;
	    };
	    CPURenderingContext2D.prototype.closePath = function () {
	    };
	    CPURenderingContext2D.prototype.rect = function (x, y, w, h) {
	    };
	    CPURenderingContext2D.prototype.clip = function (fillRule) {
	    };
	    CPURenderingContext2D.prototype.clearRect = function (x, y, w, h) {
	        var imageData = this.cpuCanvas.getImageData();
	        for (var i = x; i < x + w; i++) {
	            for (var j = y; j < y + h; j++) {
	                var index = (i + j * imageData.width) * 4;
	                imageData.data[index] = 0;
	                imageData.data[index + 1] = 0;
	                imageData.data[index + 2] = 0;
	                imageData.data[index + 3] = 0;
	            }
	        }
	    };
	    CPURenderingContext2D.prototype.moveTo = function (x, y) {
	    };
	    CPURenderingContext2D.prototype.getImageData = function (sx, sy, sw, sh) {
	        //var result:ImageData = new ImageData(sw, sh);
	        //var i:number = 0;
	        //
	        //for (i = 0; i < sw * sh * 4; i += 4) {
	        //    result.data[i] = 255;
	        //    result.data[i + 1] = 255;
	        //    result.data[i + 2] = 255;
	        //    result.data[i + 3] = 255;
	        //}
	        //
	        //var imageData:ImageData = this.cpuCanvas.getImageData();
	        //for (i = sx; i < sx + sw; i++) {
	        //    for (var j:number = sy; j < sy + sh; j++) {
	        //        this.copyPixel32(result, i - sx, i - sy, imageData, i, j);
	        //    }
	        //}
	        return this.cpuCanvas.getImageData();
	    };
	    CPURenderingContext2D.prototype.applyPixel32 = function (target, x, y, color) {
	        //todo: blending support
	        x = Math.floor(x);
	        y = Math.floor(y);
	        if (x < 0 || x >= target.width || y >= target.height || y < 0)
	            return;
	        var index = (x + y * target.width) * 4;
	        //var alpha:number = color[3] / 255;
	        target.data[index] += color[0];
	        target.data[index + 1] += color[1];
	        target.data[index + 2] += color[2];
	        target.data[index + 3] += color[3];
	        //target.data[index] = color[0];
	        //target.data[index + 1] = color[1];
	        //target.data[index + 2] = color[2];
	        //target.data[index + 3] = color[3];
	        target.data[index] = target.data[index] & 0xFF;
	        target.data[index + 1] = target.data[index + 1] & 0xFF;
	        target.data[index + 2] = target.data[index + 2] & 0xFF;
	        target.data[index + 3] = target.data[index + 3] & 0xFF;
	    };
	    CPURenderingContext2D.prototype.copyPixel32 = function (target, x, y, source, fromX, fromY) {
	        x = Math.floor(x);
	        y = Math.floor(y);
	        fromX = Math.floor(fromX);
	        fromY = Math.floor(fromY);
	        if (x < 0 || x >= target.width || y >= target.height || y < 0)
	            return;
	        if (fromX < 0 || fromX >= source.width || fromY >= source.height || fromY < 0)
	            return;
	        var index = (x + y * target.width) * 4;
	        var fromIndex = (fromX + fromY * source.width) * 4;
	        target.data[index] = source.data[fromIndex];
	        target.data[index + 1] = source.data[fromIndex + 1];
	        target.data[index + 2] = source.data[fromIndex + 2];
	        target.data[index + 3] = source.data[fromIndex + 3];
	    };
	    CPURenderingContext2D.prototype.fillRect = function (x, y, w, h) {
	        if (this.fillStyle) {
	            if (this.parsedFillStyle != this.fillStyle) {
	                var colorStrings = this.fillStyle.substring(5, this.fillStyle.lastIndexOf(")")).split(",");
	                this.parsedA = parseFloat(colorStrings[3]) * 255;
	                this.parsedR = parseInt(colorStrings[0]);
	                this.parsedG = parseInt(colorStrings[1]);
	                this.parsedB = parseInt(colorStrings[2]);
	                this.parsedFillStyle = this.fillStyle;
	            }
	            var imageData = this.cpuCanvas.getImageData();
	            for (var i = x; i < x + w; i++) {
	                for (var j = y; j < y + h; j++) {
	                    var index = (i + j * imageData.width) * 4;
	                    imageData.data[index] = this.parsedR;
	                    imageData.data[index + 1] = this.parsedG;
	                    imageData.data[index + 2] = this.parsedB;
	                    imageData.data[index + 3] = this.parsedA;
	                }
	            }
	        }
	    };
	    CPURenderingContext2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
	    };
	    CPURenderingContext2D.prototype.drawImage = function (image, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
	        var b = image;
	        if (image.constructor.toString().indexOf("BitmapImage2D") > -1) {
	            var bitmap = b;
	            bitmap.lock();
	            this.drawBitmap(bitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
	            bitmap.unlock();
	        }
	        else if (image.constructor.toString().indexOf("HTMLImage") > -1) {
	            var htmlImage = image;
	            var htmlCanvas = document.createElement("canvas");
	            htmlCanvas.width = htmlImage.width;
	            htmlCanvas.height = htmlImage.height;
	            var htmlContext = htmlCanvas.getContext("2d");
	            htmlContext.drawImage(htmlImage, 0, 0);
	            var htmlImageData = htmlContext.getImageData(0, 0, htmlImage.width, htmlImage.height);
	            var resultBitmap = new BitmapImage2D_1.BitmapImage2D(htmlImage.width, htmlImage.height, true, 0, false);
	            resultBitmap.getImageData().data = htmlImageData.data;
	            var passBitmap = resultBitmap;
	            this.drawImage(passBitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
	        }
	        else if (image.constructor.toString().indexOf("CPUCanvas") > -1) {
	            //
	            var canvas = b;
	            this.drawBitmap(canvas, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
	        }
	    };
	    CPURenderingContext2D.prototype.drawBitmap = function (bitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
	        if (!width || width == 0) {
	            width = bitmap.width;
	            height = bitmap.height;
	        }
	        if (!canvasOffsetX || canvasOffsetX == 0) {
	            canvasOffsetX = 0;
	            canvasOffsetY = 0;
	        }
	        if (!canvasImageWidth || canvasImageWidth == 0 || this.matrix) {
	            canvasImageWidth = width;
	            canvasImageHeight = height;
	        }
	        //console.log("CPURenderingContext2D:drawBitmap(width: " + width + " height: " + height + " canvasImageWidth: " + canvasImageWidth + " canvasImageHeight: " + canvasImageHeight);
	        var sourceData = bitmap.getImageData();
	        var canvasImageData = this.cpuCanvas.getImageData();
	        if (this.matrix || (canvasImageWidth != width || canvasImageHeight != height)) {
	            var matrix = this.matrix;
	            if (!matrix) {
	                matrix = new Matrix_1.Matrix();
	                matrix.scale(canvasImageWidth / width, canvasImageHeight / height);
	            }
	            var scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
	            var scaleY = Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d);
	            canvasImageWidth = width * scaleX;
	            canvasImageHeight = height * scaleY;
	            matrix.tx += canvasOffsetX;
	            matrix.ty += canvasOffsetY;
	            canvasOffsetX = Math.floor(matrix.tx);
	            canvasOffsetY = Math.floor(matrix.ty);
	            matrix.invert();
	            if (scaleX >= 1 || scaleY >= 1) {
	                var p = new Point_1.Point();
	                for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
	                    for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
	                        p.x = i;
	                        p.y = j;
	                        p = matrix.transformPoint(p);
	                        var color = CPURenderingContext2D.sampleBilinear(p.x, p.y, sourceData);
	                        this.applyPixel32(canvasImageData, i, j, color);
	                    }
	                }
	            }
	            else {
	                //decimate
	                var p1 = this.point;
	                var p2 = this.point2;
	                for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
	                    for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
	                        p1.x = i;
	                        p1.y = j;
	                        p1 = matrix.transformPoint(p1);
	                        p2.x = i + 1;
	                        p2.y = j + 1;
	                        p2 = matrix.transformPoint(p2);
	                        var color = CPURenderingContext2D.sampleBox(p1.x + offsetX, p1.y + offsetY, p2.x + offsetX, p2.y + offsetY, sourceData);
	                        this.applyPixel32(canvasImageData, i, j, color);
	                    }
	                }
	            }
	            matrix.invert();
	        }
	        else {
	            for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
	                for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
	                    var color = CPURenderingContext2D.sample(i - canvasOffsetX + offsetX, j - canvasOffsetY + offsetY, sourceData);
	                    this.applyPixel32(canvasImageData, i, j, color);
	                }
	            }
	        }
	    };
	    CPURenderingContext2D.prototype.transform = function (m11, m12, m21, m22, dx, dy) {
	    };
	    CPURenderingContext2D.prototype.stroke = function () {
	    };
	    CPURenderingContext2D.prototype.strokeRect = function (x, y, w, h) {
	    };
	    CPURenderingContext2D.prototype.setLineDash = function (segments) {
	    };
	    CPURenderingContext2D.prototype.strokeText = function (text, x, y, maxWidth) {
	    };
	    CPURenderingContext2D.prototype.beginPath = function () {
	    };
	    CPURenderingContext2D.prototype.arcTo = function (x1, y1, x2, y2, radius) {
	    };
	    CPURenderingContext2D.prototype.createLinearGradient = function (x0, y0, x1, y1) {
	        return undefined;
	    };
	    CPURenderingContext2D.sampleBilinear = function (u, v, texture, texelSizeX, texelSizeY) {
	        if (texelSizeX === void 0) { texelSizeX = 1; }
	        if (texelSizeY === void 0) { texelSizeY = 1; }
	        var color00 = CPURenderingContext2D.sample(u, v, texture);
	        var color10 = CPURenderingContext2D.sample(u + texelSizeX, v, texture);
	        var color01 = CPURenderingContext2D.sample(u, v + texelSizeY, texture);
	        var color11 = CPURenderingContext2D.sample(u + texelSizeX, v + texelSizeY, texture);
	        var a = u;
	        a = a - Math.floor(a);
	        var interColor0 = CPURenderingContext2D.interpolateColor(color00, color10, a);
	        var interColor1 = CPURenderingContext2D.interpolateColor(color01, color11, a);
	        var b = v;
	        b = b - Math.floor(b);
	        return CPURenderingContext2D.interpolateColor(interColor0, interColor1, b);
	    };
	    CPURenderingContext2D.sample = function (u, v, imageData) {
	        u = Math.floor(u);
	        v = Math.floor(v);
	        var result = [0, 0, 0, 0];
	        if (u < 0 || u >= imageData.width || v < 0 || v >= imageData.height) {
	            return result;
	        }
	        var index = (u + v * imageData.width) * 4;
	        result[0] = imageData.data[index];
	        result[1] = imageData.data[index + 1];
	        result[2] = imageData.data[index + 2];
	        result[3] = imageData.data[index + 3];
	        return result;
	    };
	    CPURenderingContext2D.sampleBox = function (x0, y0, x1, y1, texture) {
	        var area = 0; // -- total area accumulated in pixels
	        var result = [0, 0, 0, 0];
	        var x;
	        var y;
	        var xsize;
	        var ysize;
	        var fromY = Math.floor(y0);
	        var toY = Math.ceil(y1);
	        fromY = Math.max(Math.min(fromY, texture.height - 1), 0);
	        toY = Math.max(Math.min(toY, texture.height - 1), 0);
	        for (y = fromY; y < toY; y++) {
	            ysize = 1;
	            if (y < y0) {
	                ysize = ysize * (1.0 - (y0 - y));
	            }
	            if (y > y1) {
	                ysize = ysize * (1.0 - (y - y1));
	            }
	            var fromX = Math.floor(x0);
	            var toX = Math.ceil(x1);
	            fromX = Math.max(Math.min(fromX, texture.width - 1), 0);
	            toX = Math.max(Math.min(toX, texture.width - 1), 0);
	            for (x = fromX; x < toX; x++) {
	                xsize = ysize;
	                var color = CPURenderingContext2D.sample(x, y, texture);
	                if (x < x0) {
	                    xsize = xsize * (1.0 - (x0 - x));
	                }
	                if (x > x1) {
	                    xsize = xsize * (1.0 - (x - x1));
	                }
	                result[0] += color[0] * xsize;
	                result[1] += color[1] * xsize;
	                result[2] += color[2] * xsize;
	                result[3] += color[3] * xsize;
	                area = area + xsize;
	            }
	        }
	        result[0] /= area;
	        result[1] /= area;
	        result[2] /= area;
	        result[3] /= area;
	        result[0] = result[0] & 0xFF;
	        result[1] = result[1] & 0xFF;
	        result[2] = result[2] & 0xFF;
	        result[3] = result[3] & 0xFF;
	        return result;
	    };
	    CPURenderingContext2D.interpolateColor = function (source, target, a) {
	        var result = [];
	        result[0] = source[0] + (target[0] - source[0]) * a;
	        result[1] = source[1] + (target[1] - source[1]) * a;
	        result[2] = source[2] + (target[2] - source[2]) * a;
	        result[3] = source[3] + (target[3] - source[3]) * a;
	        return result;
	    };
	    return CPURenderingContext2D;
	}());
	exports.CPURenderingContext2D = CPURenderingContext2D;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CPURenderingContext2D;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Point_1 = __webpack_require__(58);
	var ArgumentError_1 = __webpack_require__(37);
	/**
	 * The Matrix export class represents a transformation matrix that determines how to
	 * map points from one coordinate space to another. You can perform various
	 * graphical transformations on a display object by setting the properties of
	 * a Matrix object, applying that Matrix object to the <code>matrix</code>
	 * property of a Transform object, and then applying that Transform object as
	 * the <code>transform</code> property of the display object. These
	 * transformation functions include translation(<i>x</i> and <i>y</i>
	 * repositioning), rotation, scaling, and skewing.
	 *
	 * <p>Together these types of transformations are known as <i>affine
	 * transformations</i>. Affine transformations preserve the straightness of
	 * lines while transforming, so that parallel lines stay parallel.</p>
	 *
	 * <p>To apply a transformation matrix to a display object, you create a
	 * Transform object, set its <code>matrix</code> property to the
	 * transformation matrix, and then set the <code>transform</code> property of
	 * the display object to the Transform object. Matrix objects are also used as
	 * parameters of some methods, such as the following:</p>
	 *
	 * <ul>
	 *   <li>The <code>draw()</code> method of a BitmapData object</li>
	 *   <li>The <code>beginBitmapFill()</code> method,
	 * <code>beginGradientFill()</code> method, or
	 * <code>lineGradientStyle()</code> method of a Graphics object</li>
	 * </ul>
	 *
	 * <p>A transformation matrix object is a 3 x 3 matrix with the following
	 * contents:</p>
	 *
	 * <p>In traditional transformation matrixes, the <code>u</code>,
	 * <code>v</code>, and <code>w</code> properties provide extra capabilities.
	 * The Matrix export class can only operate in two-dimensional space, so it always
	 * assumes that the property values <code>u</code> and <code>v</code> are 0.0,
	 * and that the property value <code>w</code> is 1.0. The effective values of
	 * the matrix are as follows:</p>
	 *
	 * <p>You can get and set the values of all six of the other properties in a
	 * Matrix object: <code>a</code>, <code>b</code>, <code>c</code>,
	 * <code>d</code>, <code>tx</code>, and <code>ty</code>.</p>
	 *
	 * <p>The Matrix export class supports the four major types of transformations:
	 * translation, scaling, rotation, and skewing. You can set three of these
	 * transformations by using specialized methods, as described in the following
	 * table: </p>
	 *
	 * <p>Each transformation function alters the current matrix properties so
	 * that you can effectively combine multiple transformations. To do this, you
	 * call more than one transformation function before applying the matrix to
	 * its display object target(by using the <code>transform</code> property of
	 * that display object).</p>
	 *
	 * <p>Use the <code>new Matrix()</code> constructor to create a Matrix object
	 * before you can call the methods of the Matrix object.</p>
	 */
	var Matrix = (function () {
	    function Matrix(a, b, c, d, tx, ty) {
	        if (a === void 0) { a = 1; }
	        if (b === void 0) { b = 0; }
	        if (c === void 0) { c = 0; }
	        if (d === void 0) { d = 1; }
	        if (tx === void 0) { tx = 0; }
	        if (ty === void 0) { ty = 0; }
	        this.rawData = new Float32Array(6);
	        if (a instanceof Float32Array) {
	            this.copyRawDataFrom(a);
	        }
	        else {
	            this.a = Number(a);
	            this.b = b;
	            this.c = c;
	            this.d = d;
	            this.tx = tx;
	            this.ty = ty;
	        }
	    }
	    Object.defineProperty(Matrix.prototype, "a", {
	        /**
	         * The value that affects the positioning of pixels along the <i>x</i> axis
	         * when scaling or rotating an image.
	         */
	        get: function () {
	            return this.rawData[0];
	        },
	        set: function (value) {
	            this.rawData[0] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix.prototype, "b", {
	        /**
	         * The value that affects the positioning of pixels along the <i>y</i> axis
	         * when rotating or skewing an image.
	         */
	        get: function () {
	            return this.rawData[2];
	        },
	        set: function (value) {
	            this.rawData[2] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix.prototype, "c", {
	        /**
	         * The value that affects the positioning of pixels along the <i>x</i> axis
	         * when rotating or skewing an image.
	         */
	        get: function () {
	            return this.rawData[1];
	        },
	        set: function (value) {
	            this.rawData[1] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix.prototype, "d", {
	        /**
	         * The value that affects the positioning of pixels along the <i>y</i> axis
	         * when scaling or rotating an image.
	         */
	        get: function () {
	            return this.rawData[3];
	        },
	        set: function (value) {
	            this.rawData[3] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix.prototype, "tx", {
	        /**
	         * The distance by which to translate each point along the <i>x</i> axis.
	         */
	        get: function () {
	            return this.rawData[4];
	        },
	        set: function (value) {
	            this.rawData[4] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Matrix.prototype, "ty", {
	        /**
	         * The distance by which to translate each point along the <i>y</i> axis.
	         */
	        get: function () {
	            return this.rawData[5];
	        },
	        set: function (value) {
	            this.rawData[5] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Matrix.prototype.copyRawDataFrom = function (vector, index) {
	        if (index === void 0) { index = 0; }
	        for (var c = 0; c < 6; c++)
	            this.rawData[c] = vector[c + index];
	    };
	    /**
	     * Returns a new Matrix object that is a clone of this matrix, with an exact
	     * copy of the contained object.
	     *
	     * @return A Matrix object.
	     */
	    Matrix.prototype.clone = function () {
	        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
	    };
	    /**
	     * Concatenates a matrix with the current matrix, effectively combining the
	     * geometric effects of the two. In mathematical terms, concatenating two
	     * matrixes is the same as combining them using matrix multiplication.
	     *
	     * <p>For example, if matrix <code>m1</code> scales an object by a factor of
	     * four, and matrix <code>m2</code> rotates an object by 1.5707963267949
	     * radians(<code>Math.PI/2</code>), then <code>m1.concat(m2)</code>
	     * transforms <code>m1</code> into a matrix that scales an object by a factor
	     * of four and rotates the object by <code>Math.PI/2</code> radians. </p>
	     *
	     * <p>This method replaces the source matrix with the concatenated matrix. If
	     * you want to concatenate two matrixes without altering either of the two
	     * source matrixes, first copy the source matrix by using the
	     * <code>clone()</code> method, as shown in the Class Examples section.</p>
	     *
	     * @param matrix The matrix to be concatenated to the source matrix.
	     */
	    Matrix.prototype.concat = function (matrix) {
	        var a1 = this.a * matrix.a + this.b * matrix.c;
	        this.b = this.a * matrix.b + this.b * matrix.d;
	        this.a = a1;
	        var c1 = this.c * matrix.a + this.d * matrix.c;
	        this.d = this.c * matrix.b + this.d * matrix.d;
	        this.c = c1;
	        var tx1 = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
	        this.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
	        this.tx = tx1;
	    };
	    /**
	     * Copies a Vector3D object into specific column of the calling Matrix3D
	     * object.
	     *
	     * @param column   The column from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyColumnFrom = function (column, vector3D) {
	        if (column > 2) {
	            throw "Column " + column + " out of bounds (2)";
	        }
	        else if (column == 0) {
	            this.a = vector3D.x;
	            this.c = vector3D.y;
	        }
	        else if (column == 1) {
	            this.b = vector3D.x;
	            this.d = vector3D.y;
	        }
	        else {
	            this.tx = vector3D.x;
	            this.ty = vector3D.y;
	        }
	    };
	    /**
	     * Copies specific column of the calling Matrix object into the Vector3D
	     * object. The w element of the Vector3D object will not be changed.
	     *
	     * @param column   The column from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyColumnTo = function (column, vector3D) {
	        if (column > 2) {
	            throw new ArgumentError_1.ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 2]");
	        }
	        else if (column == 0) {
	            vector3D.x = this.a;
	            vector3D.y = this.c;
	            vector3D.z = 0;
	        }
	        else if (column == 1) {
	            vector3D.x = this.b;
	            vector3D.y = this.d;
	            vector3D.z = 0;
	        }
	        else {
	            vector3D.x = this.tx;
	            vector3D.y = this.ty;
	            vector3D.z = 1;
	        }
	    };
	    /**
	     * Copies all of the matrix data from the source Point object into the
	     * calling Matrix object.
	     *
	     * @param sourceMatrix The Matrix object from which to copy the data.
	     */
	    Matrix.prototype.copyFrom = function (sourceMatrix) {
	        this.a = sourceMatrix.a;
	        this.b = sourceMatrix.b;
	        this.c = sourceMatrix.c;
	        this.d = sourceMatrix.d;
	        this.tx = sourceMatrix.tx;
	        this.ty = sourceMatrix.ty;
	    };
	    /**
	     * Copies a Vector3D object into specific row of the calling Matrix object.
	     *
	     * @param row      The row from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyRowFrom = function (row, vector3D) {
	        if (row > 2) {
	            throw new ArgumentError_1.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
	        }
	        else if (row == 0) {
	            this.a = vector3D.x;
	            this.c = vector3D.y;
	        }
	        else if (row == 1) {
	            this.b = vector3D.x;
	            this.d = vector3D.y;
	        }
	        else {
	            this.tx = vector3D.x;
	            this.ty = vector3D.y;
	        }
	    };
	    /**
	     * Copies specific row of the calling Matrix object into the Vector3D object.
	     * The w element of the Vector3D object will not be changed.
	     *
	     * @param row      The row from which to copy the data from.
	     * @param vector3D The Vector3D object from which to copy the data.
	     */
	    Matrix.prototype.copyRowTo = function (row, vector3D) {
	        if (row > 2) {
	            throw new ArgumentError_1.ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
	        }
	        else if (row == 0) {
	            vector3D.x = this.a;
	            vector3D.y = this.b;
	            vector3D.z = this.tx;
	        }
	        else if (row == 1) {
	            vector3D.x = this.c;
	            vector3D.y = this.d;
	            vector3D.z = this.ty;
	        }
	        else {
	            vector3D.setTo(0, 0, 1);
	        }
	    };
	    /**
	     * Includes parameters for scaling, rotation, and translation. When applied
	     * to a matrix it sets the matrix's values based on those parameters.
	     *
	     * <p>Using the <code>createBox()</code> method lets you obtain the same
	     * matrix as you would if you applied the <code>identity()</code>,
	     * <code>rotate()</code>, <code>scale()</code>, and <code>translate()</code>
	     * methods in succession. For example, <code>mat1.createBox(2,2,Math.PI/4,
	     * 100, 100)</code> has the same effect as the following:</p>
	     *
	     * @param scaleX   The factor by which to scale horizontally.
	     * @param scaleY   The factor by which scale vertically.
	     * @param rotation The amount to rotate, in radians.
	     * @param tx       The number of pixels to translate(move) to the right
	     *                 along the <i>x</i> axis.
	     * @param ty       The number of pixels to translate(move) down along the
	     *                 <i>y</i> axis.
	     */
	    Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
	        if (rotation === void 0) { rotation = 0; }
	        if (tx === void 0) { tx = 0; }
	        if (ty === void 0) { ty = 0; }
	        this.a = scaleX;
	        this.d = scaleY;
	        this.b = rotation;
	        this.tx = tx;
	        this.ty = ty;
	    };
	    /**
	     * Creates the specific style of matrix expected by the
	     * <code>beginGradientFill()</code> and <code>lineGradientStyle()</code>
	     * methods of the Graphics class. Width and height are scaled to a
	     * <code>scaleX</code>/<code>scaleY</code> pair and the
	     * <code>tx</code>/<code>ty</code> values are offset by half the width and
	     * height.
	     *
	     * <p>For example, consider a gradient with the following
	     * characteristics:</p>
	     *
	     * <ul>
	     *   <li><code>GradientType.LINEAR</code></li>
	     *   <li>Two colors, green and blue, with the ratios array set to <code>[0,
	     * 255]</code></li>
	     *   <li><code>SpreadMethod.PAD</code></li>
	     *   <li><code>InterpolationMethod.LINEAR_RGB</code></li>
	     * </ul>
	     *
	     * <p>The following illustrations show gradients in which the matrix was
	     * defined using the <code>createGradientBox()</code> method with different
	     * parameter settings:</p>
	     *
	     * @param width    The width of the gradient box.
	     * @param height   The height of the gradient box.
	     * @param rotation The amount to rotate, in radians.
	     * @param tx       The distance, in pixels, to translate to the right along
	     *                 the <i>x</i> axis. This value is offset by half of the
	     *                 <code>width</code> parameter.
	     * @param ty       The distance, in pixels, to translate down along the
	     *                 <i>y</i> axis. This value is offset by half of the
	     *                 <code>height</code> parameter.
	     */
	    Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
	        if (rotation === void 0) { rotation = 0; }
	        if (tx === void 0) { tx = 0; }
	        if (ty === void 0) { ty = 0; }
	        this.a = width / 1638.4;
	        this.d = height / 1638.4;
	        if (rotation != 0.0) {
	            var cos = Math.cos(rotation);
	            var sin = Math.sin(rotation);
	            this.b = sin * this.d;
	            this.c = -sin * this.a;
	            this.a *= cos;
	            this.d *= cos;
	        }
	        else {
	            this.b = this.c = 0;
	        }
	        this.tx = tx + width / 2;
	        this.ty = ty + height / 2;
	    };
	    /**
	     * Given a point in the pretransform coordinate space, returns the
	     * coordinates of that point after the transformation occurs. Unlike the
	     * standard transformation applied using the <code>transformPoint()</code>
	     * method, the <code>deltaTransformPoint()</code> method's transformation
	     * does not consider the translation parameters <code>tx</code> and
	     * <code>ty</code>.
	     *
	     * @param point The point for which you want to get the result of the matrix
	     *              transformation.
	     * @return The point resulting from applying the matrix transformation.
	     */
	    Matrix.prototype.deltaTransformPoint = function (point) {
	        return new Point_1.Point(point.x * this.a + point.y * this.c, point.x * this.b + point.y * this.d);
	    };
	    /**
	     * Sets each matrix property to a value that causes a null transformation. An
	     * object transformed by applying an identity matrix will be identical to the
	     * original.
	     *
	     * <p>After calling the <code>identity()</code> method, the resulting matrix
	     * has the following properties: <code>a</code>=1, <code>b</code>=0,
	     * <code>c</code>=0, <code>d</code>=1, <code>tx</code>=0,
	     * <code>ty</code>=0.</p>
	     *
	     * <p>In matrix notation, the identity matrix looks like this:</p>
	     *
	     */
	    Matrix.prototype.identity = function () {
	        this.a = 1;
	        this.b = 0;
	        this.c = 0;
	        this.d = 1;
	        this.tx = 0;
	        this.ty = 0;
	    };
	    /**
	     * Performs the opposite transformation of the original matrix. You can apply
	     * an inverted matrix to an object to undo the transformation performed when
	     * applying the original matrix.
	     */
	    Matrix.prototype.invert = function () {
	        var norm = this.a * this.d - this.b * this.c;
	        if (norm == 0) {
	            this.a = this.b = this.c = this.d = 0;
	            this.tx = -this.tx;
	            this.ty = -this.ty;
	        }
	        else {
	            norm = 1.0 / norm;
	            var a1 = this.d * norm;
	            this.d = this.a * norm;
	            this.a = a1;
	            this.b *= -norm;
	            this.c *= -norm;
	            var tx1 = -this.a * this.tx - this.c * this.ty;
	            this.ty = -this.b * this.tx - this.d * this.ty;
	            this.tx = tx1;
	        }
	    };
	    /**
	     * Returns a new Matrix object that is a clone of this matrix, with an exact
	     * copy of the contained object.
	     *
	     * @param matrix The matrix for which you want to get the result of the matrix
	     *               transformation.
	     * @return A Matrix object.
	     */
	    Matrix.prototype.multiply = function (matrix) {
	        var result = new Matrix();
	        result.a = this.a * matrix.a + this.b * matrix.c;
	        result.b = this.a * matrix.b + this.b * matrix.d;
	        result.c = this.c * matrix.a + this.d * matrix.c;
	        result.d = this.c * matrix.b + this.d * matrix.d;
	        result.tx = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
	        result.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
	        return result;
	    };
	    /**
	     * Applies a rotation transformation to the Matrix object.
	     *
	     * <p>The <code>rotate()</code> method alters the <code>a</code>,
	     * <code>b</code>, <code>c</code>, and <code>d</code> properties of the
	     * Matrix object. In matrix notation, this is the same as concatenating the
	     * current matrix with the following:</p>
	     *
	     * @param angle The rotation angle in radians.
	     */
	    Matrix.prototype.rotate = function (angle) {
	        var cos = Math.cos(angle);
	        var sin = Math.sin(angle);
	        var a1 = this.a * cos - this.b * sin;
	        this.b = this.a * sin + this.b * cos;
	        this.a = a1;
	        var c1 = this.c * cos - this.d * sin;
	        this.d = this.c * sin + this.d * cos;
	        this.c = c1;
	        var tx1 = this.tx * cos - this.ty * sin;
	        this.ty = this.tx * sin + this.ty * cos;
	        this.tx = tx1;
	    };
	    /**
	     * Applies a scaling transformation to the matrix. The <i>x</i> axis is
	     * multiplied by <code>sx</code>, and the <i>y</i> axis it is multiplied by
	     * <code>sy</code>.
	     *
	     * <p>The <code>scale()</code> method alters the <code>a</code> and
	     * <code>d</code> properties of the Matrix object. In matrix notation, this
	     * is the same as concatenating the current matrix with the following
	     * matrix:</p>
	     *
	     * @param sx A multiplier used to scale the object along the <i>x</i> axis.
	     * @param sy A multiplier used to scale the object along the <i>y</i> axis.
	     */
	    Matrix.prototype.scale = function (sx, sy) {
	        this.a *= sx;
	        this.b *= sy;
	        this.c *= sx;
	        this.d *= sy;
	        this.tx *= sx;
	        this.ty *= sy;
	    };
	    /**
	     * Sets the members of Matrix to the specified values.
	     *
	     * @param a  The value that affects the positioning of pixels along the
	     *           <i>x</i> axis when scaling or rotating an image.
	     * @param b  The value that affects the positioning of pixels along the
	     *           <i>y</i> axis when rotating or skewing an image.
	     * @param c  The value that affects the positioning of pixels along the
	     *           <i>x</i> axis when rotating or skewing an image.
	     * @param d  The value that affects the positioning of pixels along the
	     *           <i>y</i> axis when scaling or rotating an image..
	     * @param tx The distance by which to translate each point along the <i>x</i>
	     *           axis.
	     * @param ty The distance by which to translate each point along the <i>y</i>
	     *           axis.
	     */
	    Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
	        this.a = a;
	        this.b = b;
	        this.c = c;
	        this.d = d;
	        this.tx = tx;
	        this.ty = ty;
	    };
	    /**
	     * Returns a text value listing the properties of the Matrix object.
	     *
	     * @return A string containing the values of the properties of the Matrix
	     *         object: <code>a</code>, <code>b</code>, <code>c</code>,
	     *         <code>d</code>, <code>tx</code>, and <code>ty</code>.
	     */
	    Matrix.prototype.toString = function () {
	        return "[Matrix] (a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
	    };
	    /**
	     * Returns the result of applying the geometric transformation represented by
	     * the Matrix object to the specified point.
	     *
	     * @param point The point for which you want to get the result of the Matrix
	     *              transformation.
	     * @return The point resulting from applying the Matrix transformation.
	     */
	    Matrix.prototype.transformPoint = function (point) {
	        return new Point_1.Point(point.x * this.a + point.y * this.c + this.tx, point.x * this.b + point.y * this.d + this.ty);
	    };
	    /**
	     * Translates the matrix along the <i>x</i> and <i>y</i> axes, as specified
	     * by the <code>dx</code> and <code>dy</code> parameters.
	     *
	     * @param dx The amount of movement along the <i>x</i> axis to the right, in
	     *           pixels.
	     * @param dy The amount of movement down along the <i>y</i> axis, in pixels.
	     */
	    Matrix.prototype.translate = function (dx, dy) {
	        this.tx += dx;
	        this.ty += dy;
	    };
	    return Matrix;
	}());
	exports.Matrix = Matrix;


/***/ },
/* 103 */
/***/ function(module, exports) {

	"use strict";
	var ImageData = (function () {
	    function ImageData(width, height) {
	        this.width = width;
	        this.height = height;
	        this.data = new Uint8Array(width * height * 4);
	    }
	    return ImageData;
	}());
	exports.ImageData = ImageData;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ImageData;


/***/ },
/* 104 */
/***/ function(module, exports) {

	"use strict";
	var IndexBufferSoftware = (function () {
	    function IndexBufferSoftware(numIndices) {
	        this._numIndices = numIndices;
	    }
	    IndexBufferSoftware.prototype.uploadFromArray = function (data, startOffset, count) {
	        this._startOffset = startOffset * 2;
	        this._data = new Uint16Array(data);
	    };
	    IndexBufferSoftware.prototype.uploadFromByteArray = function (data, startOffset, count) {
	        this._startOffset = startOffset * 2;
	        this._data = new Uint16Array(data);
	    };
	    IndexBufferSoftware.prototype.dispose = function () {
	        this._data = null;
	    };
	    Object.defineProperty(IndexBufferSoftware.prototype, "numIndices", {
	        get: function () {
	            return this._numIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(IndexBufferSoftware.prototype, "data", {
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(IndexBufferSoftware.prototype, "startOffset", {
	        get: function () {
	            return this._startOffset;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return IndexBufferSoftware;
	}());
	exports.IndexBufferSoftware = IndexBufferSoftware;


/***/ },
/* 105 */
/***/ function(module, exports) {

	"use strict";
	var VertexBufferSoftware = (function () {
	    //private _dataOffset:number;
	    function VertexBufferSoftware(numVertices, dataPerVertex) {
	        this._numVertices = numVertices;
	        this._dataPerVertex = dataPerVertex;
	    }
	    VertexBufferSoftware.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
	        //this._dataOffset = startVertex * this._dataPerVertex;
	        this._floatData = new Float32Array(vertices);
	    };
	    VertexBufferSoftware.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
	        //this._dataOffset = startVertex * this._dataPerVertex;
	        this._floatData = new Float32Array(data, startVertex * this._dataPerVertex, numVertices * this._dataPerVertex / 4);
	        this._uintData = new Uint8Array(data);
	    };
	    Object.defineProperty(VertexBufferSoftware.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferSoftware.prototype, "dataPerVertex", {
	        get: function () {
	            return this._dataPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferSoftware.prototype, "attributesPerVertex", {
	        get: function () {
	            return this._dataPerVertex / 4;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    VertexBufferSoftware.prototype.dispose = function () {
	        this._floatData = null;
	    };
	    Object.defineProperty(VertexBufferSoftware.prototype, "data", {
	        get: function () {
	            return this._floatData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexBufferSoftware.prototype, "uintData", {
	        get: function () {
	            return this._uintData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return VertexBufferSoftware;
	}());
	exports.VertexBufferSoftware = VertexBufferSoftware;


/***/ },
/* 106 */
/***/ function(module, exports) {

	"use strict";
	var TextureSoftware = (function () {
	    function TextureSoftware(width, height) {
	        this.textureType = "texture2d";
	        this._mipLevels = [];
	        this._width = width;
	        this._height = height;
	    }
	    TextureSoftware.prototype.dispose = function () {
	        this._mipLevels = null;
	    };
	    Object.defineProperty(TextureSoftware.prototype, "width", {
	        get: function () {
	            return this._width;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureSoftware.prototype, "height", {
	        get: function () {
	            return this._height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextureSoftware.prototype.uploadFromData = function (data, miplevel) {
	        if (miplevel === void 0) { miplevel = 0; }
	        this._mipLevels[miplevel] = data.data;
	    };
	    TextureSoftware.prototype.getData = function (miplevel) {
	        return this._mipLevels[miplevel];
	    };
	    TextureSoftware.prototype.getMipLevelsCount = function () {
	        return this._mipLevels.length;
	    };
	    TextureSoftware.prototype.generateMipmaps = function () {
	        //TODO
	    };
	    return TextureSoftware;
	}());
	exports.TextureSoftware = TextureSoftware;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AGALTokenizer_1 = __webpack_require__(68);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ContextGLTextureFilter_1 = __webpack_require__(49);
	var ContextGLMipFilter_1 = __webpack_require__(45);
	var ContextGLWrapMode_1 = __webpack_require__(53);
	var ProgramVOSoftware_1 = __webpack_require__(108);
	var SoftwareSamplerState_1 = __webpack_require__(109);
	var ProgramSoftware = (function () {
	    function ProgramSoftware() {
	        this._numVarying = 0;
	    }
	    Object.defineProperty(ProgramSoftware.prototype, "numVarying", {
	        get: function () {
	            return this._numVarying;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProgramSoftware.prototype.upload = function (vertexProgram, fragmentProgram) {
	        this._vertexDescr = ProgramSoftware._tokenizer.decribeAGALByteArray(vertexProgram);
	        this._vertexVO = new ProgramVOSoftware_1.ProgramVOSoftware();
	        this._vertexVO.temp = new Float32Array(this._vertexDescr.regwrite[0x2].length * 4);
	        this._vertexVO.attributes = new Float32Array(this._vertexDescr.regread[0x0].length * 4);
	        this._numVarying = this._vertexDescr.regwrite[0x4].length;
	        this._fragmentDescr = ProgramSoftware._tokenizer.decribeAGALByteArray(fragmentProgram);
	        this._fragmentVO = new ProgramVOSoftware_1.ProgramVOSoftware();
	        this._fragmentVO.temp = new Float32Array(this._fragmentDescr.regwrite[0x2].length * 4);
	        this._fragmentVO.varying = new Float32Array(this._fragmentDescr.regread[0x4].length * 4);
	        this._fragmentVO.derivativeX = new Float32Array(this._fragmentVO.varying.length);
	        this._fragmentVO.derivativeY = new Float32Array(this._fragmentVO.varying.length);
	    };
	    ProgramSoftware.prototype.dispose = function () {
	        this._vertexDescr = null;
	        this._fragmentDescr = null;
	    };
	    ProgramSoftware.prototype.vertex = function (context, vertexIndex, position, varying) {
	        //set attributes
	        var i;
	        var j = 0;
	        var numAttributes = this._vertexDescr.regread[0x0].length;
	        var attributes = this._vertexVO.attributes;
	        for (i = 0; i < numAttributes; i++) {
	            var buffer = context._vertexBuffers[i];
	            if (!buffer)
	                continue;
	            var index = context._vertexBufferOffsets[i] / 4 + vertexIndex * buffer.attributesPerVertex;
	            if (context._vertexBufferFormats[i] == ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.UNSIGNED_BYTE_4) {
	                attributes[j++] = buffer.uintData[index * 4];
	                attributes[j++] = buffer.uintData[index * 4 + 1];
	                attributes[j++] = buffer.uintData[index * 4 + 2];
	                attributes[j++] = buffer.uintData[index * 4 + 3];
	            }
	            else if (context._vertexBufferFormats[i] == ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4) {
	                attributes[j++] = buffer.data[index];
	                attributes[j++] = buffer.data[index + 1];
	                attributes[j++] = buffer.data[index + 2];
	                attributes[j++] = buffer.data[index + 3];
	            }
	            else if (context._vertexBufferFormats[i] == ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3) {
	                attributes[j++] = buffer.data[index];
	                attributes[j++] = buffer.data[index + 1];
	                attributes[j++] = buffer.data[index + 2];
	                attributes[j++] = 1;
	            }
	            else if (context._vertexBufferFormats[i] == ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2) {
	                attributes[j++] = buffer.data[index];
	                attributes[j++] = buffer.data[index + 1];
	                attributes[j++] = 0;
	                attributes[j++] = 1;
	            }
	            else if (context._vertexBufferFormats[i] == ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_1) {
	                attributes[j++] = buffer.data[index];
	                attributes[j++] = 0;
	                attributes[j++] = 0;
	                attributes[j++] = 1;
	            }
	        }
	        //clear temps
	        var temp = this._vertexVO.temp;
	        var numTemp = temp.length;
	        for (var i = 0; i < numTemp; i += 4) {
	            temp[i] = 0;
	            temp[i + 1] = 0;
	            temp[i + 2] = 0;
	            temp[i + 3] = 1;
	        }
	        this._vertexVO.outputPosition = position;
	        this._vertexVO.varying = varying;
	        var len = this._vertexDescr.tokens.length;
	        for (var i = 0; i < len; i++) {
	            var token = this._vertexDescr.tokens[i];
	            ProgramSoftware._opCodeFunc[token.opcode](this._vertexVO, this._vertexDescr, token.dest, token.a, token.b, context);
	        }
	    };
	    ProgramSoftware.prototype.fragment = function (context, clip, clipRight, clipBottom, varying0, varying1, varying2, fragDepth) {
	        this._fragmentVO.outputDepth = fragDepth;
	        //clear temps
	        var temp = this._fragmentVO.temp;
	        var numTemp = temp.length;
	        for (var i = 0; i < numTemp; i += 4) {
	            temp[i] = 0;
	            temp[i + 1] = 0;
	            temp[i + 2] = 0;
	            temp[i + 3] = 1;
	        }
	        //check for requirement of derivatives
	        var varyingDerivatives = [];
	        var len = this._fragmentDescr.tokens.length;
	        for (var i = 0; i < len; i++) {
	            var token = this._fragmentDescr.tokens[i];
	            if (token.opcode == 0x28 && context._samplerStates[token.b.regnum] && context._samplerStates[token.b.regnum].mipfilter == ContextGLMipFilter_1.ContextGLMipFilter.MIPLINEAR && context._textures[token.b.regnum].getMipLevelsCount() > 1)
	                varyingDerivatives.push(token.a.regnum);
	        }
	        var derivativeX = this._fragmentVO.derivativeX;
	        var derivativeY = this._fragmentVO.derivativeY;
	        var varying = this._fragmentVO.varying;
	        var numVarying = varying.length;
	        for (var i = 0; i < numVarying; i += 4) {
	            // if (!varying0 || !varying1 || !varying2) continue;
	            varying[i] = clip.x * varying0[i] + clip.y * varying1[i] + clip.z * varying2[i];
	            varying[i + 1] = clip.x * varying0[i + 1] + clip.y * varying1[i + 1] + clip.z * varying2[i + 1];
	            varying[i + 2] = clip.x * varying0[i + 2] + clip.y * varying1[i + 2] + clip.z * varying2[i + 2];
	            varying[i + 3] = clip.x * varying0[i + 3] + clip.y * varying1[i + 3] + clip.z * varying2[i + 3];
	            if (varyingDerivatives.indexOf(i) == -1)
	                continue;
	            derivativeX[i] = clipRight.x * varying0[i] + clipRight.y * varying1[i] + clipRight.z * varying2[i];
	            derivativeX[i + 1] = clipRight.x * varying0[i + 1] + clipRight.y * varying1[i + 1] + clipRight.z * varying2[i + 1];
	            derivativeX[i + 2] = clipRight.x * varying0[i + 2] + clipRight.y * varying1[i + 2] + clipRight.z * varying2[i + 2];
	            derivativeX[i + 3] = clipRight.x * varying0[i + 3] + clipRight.y * varying1[i + 3] + clipRight.z * varying2[i + 3];
	            derivativeX[i] -= varying[i];
	            derivativeX[i + 1] -= varying[i + 1];
	            derivativeX[i + 2] -= varying[i + 2];
	            derivativeX[i + 3] -= varying[i + 3];
	            derivativeY[i] = clipBottom.x * varying0[i] + clipBottom.y * varying1[i] + clipBottom.z * varying2[i];
	            derivativeY[i + 1] = clipBottom.x * varying0[i + 1] + clipBottom.y * varying1[i + 1] + clipBottom.z * varying2[i + 1];
	            derivativeY[i + 2] = clipBottom.x * varying0[i + 2] + clipBottom.y * varying1[i + 2] + clipBottom.z * varying2[i + 2];
	            derivativeY[i + 3] = clipBottom.x * varying0[i + 3] + clipBottom.y * varying1[i + 3] + clipBottom.z * varying2[i + 3];
	            derivativeY[i] -= varying[i];
	            derivativeY[i + 1] -= varying[i + 1];
	            derivativeY[i + 2] -= varying[i + 2];
	            derivativeY[i + 3] -= varying[i + 3];
	        }
	        for (var i = 0; i < len; i++) {
	            var token = this._fragmentDescr.tokens[i];
	            ProgramSoftware._opCodeFunc[token.opcode](this._fragmentVO, this._fragmentDescr, token.dest, token.a, token.b, context);
	        }
	        return this._fragmentVO;
	    };
	    ProgramSoftware.getDestTarget = function (vo, desc, dest) {
	        var target;
	        if (dest.regtype == 0x2) {
	            target = vo.temp;
	        }
	        else if (dest.regtype == 0x3) {
	            if (desc.header.type == "vertex") {
	                target = vo.outputPosition;
	            }
	            else {
	                target = vo.outputColor;
	            }
	        }
	        else if (dest.regtype == 0x4) {
	            target = vo.varying;
	        }
	        return target;
	    };
	    ProgramSoftware.getSourceTarget = function (vo, desc, dest, context) {
	        var target;
	        if (dest.regtype == 0x0) {
	            target = vo.attributes;
	        }
	        else if (dest.regtype == 0x1) {
	            if (desc.header.type == "vertex") {
	                target = context._vertexConstants;
	            }
	            else {
	                target = context._fragmentConstants;
	            }
	        }
	        else if (dest.regtype == 0x2) {
	            target = vo.temp;
	        }
	        else if (dest.regtype == 0x4) {
	            target = vo.varying;
	        }
	        return target;
	    };
	    ProgramSoftware.mov = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1.swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1.swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1.swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1.swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.m44 = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg] * source2Target[source2Reg] + source1Target[source1Reg + 1] * source2Target[source2Reg + 1] + source1Target[source1Reg + 2] * source2Target[source2Reg + 2] + source2Target[source2Reg + 3];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg] * source2Target[source2Reg + 4] + source1Target[source1Reg + 1] * source2Target[source2Reg + 5] + source1Target[source1Reg + 2] * source2Target[source2Reg + 6] + source2Target[source2Reg + 7];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg] * source2Target[source2Reg + 8] + source1Target[source1Reg + 1] * source2Target[source2Reg + 9] + source1Target[source1Reg + 2] * source2Target[source2Reg + 10] + source2Target[source2Reg + 11];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg] * source2Target[source2Reg + 12] + source1Target[source1Reg + 1] * source2Target[source2Reg + 13] + source1Target[source1Reg + 2] * source2Target[source2Reg + 14] + source2Target[source2Reg + 15];
	    };
	    ProgramSoftware.sample = function (vo, desc, context, source1, textureIndex) {
	        var source1Reg = 4 * source1.regnum;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var u = source1Target[((source1.swizzle >> 0) & 3)];
	        var v = source1Target[((source1.swizzle >> 2) & 3)];
	        if (textureIndex >= context._textures.length || context._textures[textureIndex] == null)
	            return new Float32Array([1, u, v, 0]);
	        var texture = context._textures[textureIndex];
	        var state = context._samplerStates[textureIndex] || this._defaultSamplerState;
	        var repeat = state.wrap == ContextGLWrapMode_1.ContextGLWrapMode.REPEAT;
	        var mipmap = state.mipfilter == ContextGLMipFilter_1.ContextGLMipFilter.MIPLINEAR;
	        if (mipmap && texture.getMipLevelsCount() > 1) {
	            var dux = Math.abs(vo.derivativeX[source1Reg + ((source1.swizzle >> 0) & 3)]);
	            var dvx = Math.abs(vo.derivativeX[source1Reg + ((source1.swizzle >> 2) & 3)]);
	            var duy = Math.abs(vo.derivativeY[source1Reg + ((source1.swizzle >> 0) & 3)]);
	            var dvy = Math.abs(vo.derivativeY[source1Reg + ((source1.swizzle >> 2) & 3)]);
	            var lambda = Math.log(Math.max(texture.width * Math.sqrt(dux * dux + dvx * dvx), texture.height * Math.sqrt(duy * duy + dvy * dvy))) / Math.LN2;
	            if (lambda > 0) {
	                var miplevelLow = Math.floor(lambda);
	                var miplevelHigh = Math.ceil(lambda);
	                var maxmiplevel = Math.log(Math.min(texture.width, texture.height)) / Math.LN2;
	                if (miplevelHigh > maxmiplevel)
	                    miplevelHigh = maxmiplevel;
	                if (miplevelLow > maxmiplevel)
	                    miplevelLow = maxmiplevel;
	                var mipblend = lambda - Math.floor(lambda);
	                var resultLow;
	                var resultHigh;
	                var dataLow = texture.getData(miplevelLow);
	                var dataLowWidth = texture.width / Math.pow(2, miplevelLow);
	                var dataLowHeight = texture.height / Math.pow(2, miplevelLow);
	                var dataHigh = texture.getData(miplevelHigh);
	                var dataHighWidth = texture.width / Math.pow(2, miplevelHigh);
	                var dataHighHeight = texture.height / Math.pow(2, miplevelHigh);
	                if (state.filter == ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR) {
	                    resultLow = ProgramSoftware.sampleBilinear(u, v, dataLow, dataLowWidth, dataLowHeight, repeat);
	                    resultHigh = ProgramSoftware.sampleBilinear(u, v, dataHigh, dataHighWidth, dataHighHeight, repeat);
	                }
	                else {
	                    resultLow = ProgramSoftware.sampleNearest(u, v, dataLow, dataLowWidth, dataLowHeight, repeat);
	                    resultHigh = ProgramSoftware.sampleNearest(u, v, dataHigh, dataHighWidth, dataHighHeight, repeat);
	                }
	                return ProgramSoftware.interpolateColor(resultLow, resultHigh, mipblend);
	            }
	        }
	        var result;
	        var data = texture.getData(0);
	        if (state.filter == ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR) {
	            result = ProgramSoftware.sampleBilinear(u, v, data, texture.width, texture.height, repeat);
	        }
	        else {
	            result = ProgramSoftware.sampleNearest(u, v, data, texture.width, texture.height, repeat);
	        }
	        return result;
	    };
	    ProgramSoftware.sampleNearest = function (u, v, textureData, textureWidth, textureHeight, repeat) {
	        u *= textureWidth;
	        v *= textureHeight;
	        if (repeat) {
	            u = Math.abs(u % textureWidth);
	            v = Math.abs(v % textureHeight);
	        }
	        else {
	            if (u < 0)
	                u = 0;
	            else if (u > textureWidth - 1)
	                u = textureWidth - 1;
	            if (v < 0)
	                v = 0;
	            else if (v > textureHeight - 1)
	                v = textureHeight - 1;
	        }
	        u = Math.floor(u);
	        v = Math.floor(v);
	        var pos = (u + v * textureWidth) * 4;
	        var r = textureData[pos] / 255;
	        var g = textureData[pos + 1] / 255;
	        var b = textureData[pos + 2] / 255;
	        var a = textureData[pos + 3] / 255;
	        return new Float32Array([a, r, g, b]);
	    };
	    ProgramSoftware.sampleBilinear = function (u, v, textureData, textureWidth, textureHeight, repeat) {
	        var texelSizeX = 1 / textureWidth;
	        var texelSizeY = 1 / textureHeight;
	        u -= texelSizeX / 2;
	        v -= texelSizeY / 2;
	        var color00 = ProgramSoftware.sampleNearest(u, v, textureData, textureWidth, textureHeight, repeat);
	        var color10 = ProgramSoftware.sampleNearest(u + texelSizeX, v, textureData, textureWidth, textureHeight, repeat);
	        var color01 = ProgramSoftware.sampleNearest(u, v + texelSizeY, textureData, textureWidth, textureHeight, repeat);
	        var color11 = ProgramSoftware.sampleNearest(u + texelSizeX, v + texelSizeY, textureData, textureWidth, textureHeight, repeat);
	        var a = u * textureWidth;
	        a = a - Math.floor(a);
	        var interColor0 = ProgramSoftware.interpolateColor(color00, color10, a);
	        var interColor1 = ProgramSoftware.interpolateColor(color01, color11, a);
	        var b = v * textureHeight;
	        b = b - Math.floor(b);
	        return ProgramSoftware.interpolateColor(interColor0, interColor1, b);
	    };
	    ProgramSoftware.interpolateColor = function (source, target, a) {
	        var result = new Float32Array(4);
	        result[0] = source[0] + (target[0] - source[0]) * a;
	        result[1] = source[1] + (target[1] - source[1]) * a;
	        result[2] = source[2] + (target[2] - source[2]) * a;
	        result[3] = source[3] + (target[3] - source[3]) * a;
	        return result;
	    };
	    ProgramSoftware.tex = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var color = ProgramSoftware.sample(vo, desc, context, source1, source2.regnum);
	        var mask = dest.mask;
	        if (mask & 1)
	            target[targetReg] = color[1];
	        if (mask & 2)
	            target[targetReg + 1] = color[2];
	        if (mask & 4)
	            target[targetReg + 2] = color[3];
	        if (mask & 8)
	            target[targetReg + 3] = color[0];
	    };
	    ProgramSoftware.add = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.sub = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.mul = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.div = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.rcp = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = 1 / source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = 1 / source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = 1 / source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = 1 / source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.min = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)], source2Target[source2Reg + ((source2Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)], source2Target[source2Reg + ((source2Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)], source2Target[source2Reg + ((source2Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)], source2Target[source2Reg + ((source2Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.max = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)], source2Target[source2Reg + ((source2Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)], source2Target[source2Reg + ((source2Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)], source2Target[source2Reg + ((source2Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)], source2Target[source2Reg + ((source2Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.frc = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.sqt = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.rsq = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.pow = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)], source2Target[source2Reg + ((source2Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)], source2Target[source2Reg + ((source2Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)], source2Target[source2Reg + ((source2Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)], source2Target[source2Reg + ((source2Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.log = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]) / Math.LN2;
	        if (mask & 2)
	            target[targetReg + 1] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]) / Math.LN2;
	        if (mask & 4)
	            target[targetReg + 2] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]) / Math.LN2;
	        if (mask & 8)
	            target[targetReg + 3] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]) / Math.LN2;
	    };
	    ProgramSoftware.exp = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.nrm = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var x = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var y = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var z = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var len = Math.sqrt(x * x + y * y + z * z);
	        x /= len;
	        y /= len;
	        z /= len;
	        if (mask & 1)
	            target[targetReg] = x;
	        if (mask & 2)
	            target[targetReg + 1] = y;
	        if (mask & 4)
	            target[targetReg + 2] = z;
	    };
	    ProgramSoftware.sin = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.cos = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.crs = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        if (mask & 1)
	            target[targetReg] = source1TargetY * source2TargetZ - source1TargetZ * source2TargetY;
	        if (mask & 2)
	            target[targetReg + 1] = source1TargetZ * source2TargetX - source1TargetX * source2TargetZ;
	        if (mask & 4)
	            target[targetReg + 2] = source1TargetX * source2TargetY - source1TargetY * source2TargetX;
	    };
	    ProgramSoftware.dp3 = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        if (mask & 1)
	            target[targetReg] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
	        if (mask & 2)
	            target[targetReg + 1] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
	        if (mask & 4)
	            target[targetReg + 2] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
	        if (mask & 8)
	            target[targetReg + 3] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
	    };
	    ProgramSoftware.dp4 = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	        if (mask & 1)
	            target[targetReg] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
	        if (mask & 2)
	            target[targetReg + 1] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
	        if (mask & 4)
	            target[targetReg + 2] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
	        if (mask & 8)
	            target[targetReg + 3] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
	    };
	    ProgramSoftware.abs = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
	        if (mask & 2)
	            target[targetReg + 1] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
	        if (mask & 4)
	            target[targetReg + 2] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
	        if (mask & 8)
	            target[targetReg + 3] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
	    };
	    ProgramSoftware.neg = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = -source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = -source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = -source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = -source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.sat = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]));
	        if (mask & 2)
	            target[targetReg + 1] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]));
	        if (mask & 4)
	            target[targetReg + 2] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]));
	        if (mask & 8)
	            target[targetReg + 3] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]));
	    };
	    ProgramSoftware.m33 = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg] * source2Target[source2Reg] + source1Target[source1Reg + 1] * source2Target[source2Reg + 1] + source1Target[source1Reg + 2] * source2Target[source2Reg + 2];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg] * source2Target[source2Reg + 4] + source1Target[source1Reg + 1] * source2Target[source2Reg + 5] + source1Target[source1Reg + 2] * source2Target[source2Reg + 6];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg] * source2Target[source2Reg + 8] + source1Target[source1Reg + 1] * source2Target[source2Reg + 9] + source1Target[source1Reg + 2] * source2Target[source2Reg + 10];
	    };
	    ProgramSoftware.m34 = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source2.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var mask = dest.mask;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg] * source2Target[source2Reg] + source1Target[source1Reg + 1] * source2Target[source2Reg + 1] + source1Target[source1Reg + 2] * source2Target[source2Reg + 2] + source2Target[source2Reg + 3];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg] * source2Target[source2Reg + 4] + source1Target[source1Reg + 1] * source2Target[source2Reg + 5] + source1Target[source1Reg + 2] * source2Target[source2Reg + 6] + source2Target[source2Reg + 7];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg] * source2Target[source2Reg + 8] + source1Target[source1Reg + 1] * source2Target[source2Reg + 9] + source1Target[source1Reg + 2] * source2Target[source2Reg + 10] + source2Target[source2Reg + 11];
	    };
	    ProgramSoftware.ddx = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = vo.derivativeX;
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.ddy = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var source1Target = vo.derivativeY;
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        if (mask & 1)
	            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        if (mask & 2)
	            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        if (mask & 4)
	            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        if (mask & 8)
	            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	    };
	    ProgramSoftware.sge = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	        if (mask & 1)
	            target[targetReg] = source1TargetX >= source2TargetX ? 1 : 0;
	        if (mask & 2)
	            target[targetReg + 1] = source1TargetY >= source2TargetY ? 1 : 0;
	        if (mask & 4)
	            target[targetReg + 2] = source1TargetZ >= source2TargetZ ? 1 : 0;
	        if (mask & 8)
	            target[targetReg + 3] = source1TargetW >= source2TargetW ? 1 : 0;
	    };
	    ProgramSoftware.slt = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	        if (mask & 1)
	            target[targetReg] = source1TargetX < source2TargetX ? 1 : 0;
	        if (mask & 2)
	            target[targetReg + 1] = source1TargetY < source2TargetY ? 1 : 0;
	        if (mask & 4)
	            target[targetReg + 2] = source1TargetZ < source2TargetZ ? 1 : 0;
	        if (mask & 8)
	            target[targetReg + 3] = source1TargetW < source2TargetW ? 1 : 0;
	    };
	    ProgramSoftware.seq = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	        if (mask & 1)
	            target[targetReg] = source1TargetX == source2TargetX ? 1 : 0;
	        if (mask & 2)
	            target[targetReg + 1] = source1TargetY == source2TargetY ? 1 : 0;
	        if (mask & 4)
	            target[targetReg + 2] = source1TargetZ == source2TargetZ ? 1 : 0;
	        if (mask & 8)
	            target[targetReg + 3] = source1TargetW == source2TargetW ? 1 : 0;
	    };
	    ProgramSoftware.sne = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var source2Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source2Swizzle = source2.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
	        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
	        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
	        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
	        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
	        if (mask & 1)
	            target[targetReg] = source1TargetX != source2TargetX ? 1 : 0;
	        if (mask & 2)
	            target[targetReg + 1] = source1TargetY != source2TargetY ? 1 : 0;
	        if (mask & 4)
	            target[targetReg + 2] = source1TargetZ != source2TargetZ ? 1 : 0;
	        if (mask & 8)
	            target[targetReg + 3] = source1TargetW != source2TargetW ? 1 : 0;
	    };
	    ProgramSoftware.sgn = function (vo, desc, dest, source1, source2, context) {
	        var targetReg = 4 * dest.regnum;
	        var source1Reg = 4 * source1.regnum;
	        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
	        var mask = dest.mask;
	        var source1Swizzle = source1.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
	        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
	        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
	        if (mask & 1)
	            target[targetReg] = (source1TargetX < 0) ? -1 : (source1TargetX > 0) ? 1 : 0;
	        if (mask & 2)
	            target[targetReg + 1] = (source1TargetY < 0) ? -1 : (source1TargetY > 0) ? 1 : 0;
	        if (mask & 4)
	            target[targetReg + 2] = (source1TargetZ < 0) ? -1 : (source1TargetZ > 0) ? 1 : 0;
	        if (mask & 8)
	            target[targetReg + 3] = (source1TargetW < 0) ? -1 : (source1TargetW > 0) ? 1 : 0;
	    };
	    ProgramSoftware.kil = function (vo, desc, dest, source1, source2, context) {
	        var source1Reg = 4 * source1.regnum;
	        var source1Swizzle = source1.swizzle;
	        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
	        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
	        if (source1TargetX < 0)
	            vo.discard = true;
	    };
	    ProgramSoftware._defaultSamplerState = new SoftwareSamplerState_1.SoftwareSamplerState();
	    ProgramSoftware._tokenizer = new AGALTokenizer_1.AGALTokenizer();
	    ProgramSoftware._opCodeFunc = [
	        ProgramSoftware.mov,
	        ProgramSoftware.add,
	        ProgramSoftware.sub,
	        ProgramSoftware.mul,
	        ProgramSoftware.div,
	        ProgramSoftware.rcp,
	        ProgramSoftware.min,
	        ProgramSoftware.max,
	        ProgramSoftware.frc,
	        ProgramSoftware.sqt,
	        ProgramSoftware.rsq,
	        ProgramSoftware.pow,
	        ProgramSoftware.log,
	        ProgramSoftware.exp,
	        ProgramSoftware.nrm,
	        ProgramSoftware.sin,
	        ProgramSoftware.cos,
	        ProgramSoftware.crs,
	        ProgramSoftware.dp3,
	        ProgramSoftware.dp4,
	        ProgramSoftware.abs,
	        ProgramSoftware.neg,
	        ProgramSoftware.sat,
	        ProgramSoftware.m33,
	        ProgramSoftware.m44,
	        ProgramSoftware.m34,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        null,
	        ProgramSoftware.kil,
	        ProgramSoftware.tex,
	        ProgramSoftware.sge,
	        ProgramSoftware.slt,
	        ProgramSoftware.sgn,
	        ProgramSoftware.seq,
	        ProgramSoftware.sne
	    ];
	    return ProgramSoftware;
	}());
	exports.ProgramSoftware = ProgramSoftware;


/***/ },
/* 108 */
/***/ function(module, exports) {

	"use strict";
	var ProgramVOSoftware = (function () {
	    function ProgramVOSoftware() {
	        this.outputColor = new Float32Array([0, 0, 0, 1]);
	        this.discard = false;
	    }
	    return ProgramVOSoftware;
	}());
	exports.ProgramVOSoftware = ProgramVOSoftware;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ContextGLTextureFilter_1 = __webpack_require__(49);
	var ContextGLMipFilter_1 = __webpack_require__(45);
	var ContextGLWrapMode_1 = __webpack_require__(53);
	/**
	 * The same as SamplerState, but with strings
	 * TODO: replace two similar classes with one
	 */
	var SoftwareSamplerState = (function () {
	    function SoftwareSamplerState() {
	        this.wrap = ContextGLWrapMode_1.ContextGLWrapMode.REPEAT;
	        this.filter = ContextGLTextureFilter_1.ContextGLTextureFilter.LINEAR;
	        this.mipfilter = ContextGLMipFilter_1.ContextGLMipFilter.MIPLINEAR;
	    }
	    return SoftwareSamplerState;
	}());
	exports.SoftwareSamplerState = SoftwareSamplerState;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SoftwareSamplerState;


/***/ },
/* 110 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(111));


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Billboard_1 = __webpack_require__(112);
	exports.Billboard = Billboard_1.Billboard;
	var Camera_1 = __webpack_require__(139);
	exports.Camera = Camera_1.Camera;
	var DirectionalLight_1 = __webpack_require__(149);
	exports.DirectionalLight = DirectionalLight_1.DirectionalLight;
	var DisplayObject_1 = __webpack_require__(113);
	exports.DisplayObject = DisplayObject_1.DisplayObject;
	var DisplayObjectContainer_1 = __webpack_require__(146);
	exports.DisplayObjectContainer = DisplayObjectContainer_1.DisplayObjectContainer;
	var LightBase_1 = __webpack_require__(150);
	exports.LightBase = LightBase_1.LightBase;
	var LightProbe_1 = __webpack_require__(155);
	exports.LightProbe = LightProbe_1.LightProbe;
	var LineSegment_1 = __webpack_require__(157);
	exports.LineSegment = LineSegment_1.LineSegment;
	var LoaderContainer_1 = __webpack_require__(158);
	exports.LoaderContainer = LoaderContainer_1.LoaderContainer;
	var MovieClip_1 = __webpack_require__(176);
	exports.MovieClip = MovieClip_1.MovieClip;
	var PointLight_1 = __webpack_require__(196);
	exports.PointLight = PointLight_1.PointLight;
	var Scene_1 = __webpack_require__(198);
	exports.Scene = Scene_1.Scene;
	var Shape_1 = __webpack_require__(199);
	exports.Shape = Shape_1.Shape;
	var Skybox_1 = __webpack_require__(130);
	exports.Skybox = Skybox_1.Skybox;
	var Sprite_1 = __webpack_require__(177);
	exports.Sprite = Sprite_1.Sprite;
	var TextField_1 = __webpack_require__(191);
	exports.TextField = TextField_1.TextField;
	var TextureProjector_1 = __webpack_require__(200);
	exports.TextureProjector = TextureProjector_1.TextureProjector;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Rectangle_1 = __webpack_require__(57);
	var DisplayObject_1 = __webpack_require__(113);
	var BoundsType_1 = __webpack_require__(115);
	var RenderableEvent_1 = __webpack_require__(118);
	var SurfaceEvent_1 = __webpack_require__(119);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var StyleEvent_1 = __webpack_require__(25);
	/**
	 * The Billboard class represents display objects that represent bitmap images.
	 * These can be images that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes, or they can be images that you
	 * create with the <code>Billboard()</code> constructor.
	 *
	 * <p>The <code>Billboard()</code> constructor allows you to create a Billboard
	 * object that contains a reference to a Image2D object. After you create a
	 * Billboard object, use the <code>addChild()</code> or <code>addChildAt()</code>
	 * method of the parent DisplayObjectContainer instance to place the bitmap on
	 * the display list.</p>
	 *
	 * <p>A Billboard object can share its Image2D reference among several Billboard
	 * objects, independent of translation or rotation properties. Because you can
	 * create multiple Billboard objects that reference the same Image2D object,
	 * multiple display objects can use the same complex Image2D object without
	 * incurring the memory overhead of a Image2D object for each display
	 * object instance.</p>
	 *
	 * <p>A Image2D object can be drawn to the screen by a Billboard object in one
	 * of two ways: by using the default hardware renderer with a single hardware surface,
	 * or by using the slower software renderer when 3D acceleration is not available.</p>
	 *
	 * <p>If you would prefer to perform a batch rendering command, rather than using a
	 * single surface for each Billboard object, you can also draw to the screen using the
	 * <code>drawTiles()</code> or <code>drawTriangles()</code> methods which are
	 * available to <code>flash.display.Tilesheet</code> and <code>flash.display.Graphics
	 * objects.</code></p>
	 *
	 * <p><b>Note:</b> The Billboard class is not a subclass of the InteractiveObject
	 * class, so it cannot dispatch mouse events. However, you can use the
	 * <code>addEventListener()</code> method of the display object container that
	 * contains the Billboard object.</p>
	 */
	var Billboard = (function (_super) {
	    __extends(Billboard, _super);
	    function Billboard(material, pixelSnapping, smoothing) {
	        var _this = this;
	        if (pixelSnapping === void 0) { pixelSnapping = "auto"; }
	        if (smoothing === void 0) { smoothing = false; }
	        _super.call(this);
	        this._pIsEntity = true;
	        this.onInvalidateTextureDelegate = function (event) { return _this.onInvalidateTexture(event); };
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this.material = material;
	        this._updateDimensions();
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.AXIS_ALIGNED_BOX;
	    }
	    Object.defineProperty(Billboard.prototype, "animator", {
	        /**
	         * Defines the animator of the sprite. Act on the sprite's geometry. Defaults to null
	         */
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Billboard.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "billboardRect", {
	        /**
	         *
	         */
	        get: function () {
	            return this._billboardRect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "billboardHeight", {
	        /**
	         *
	         */
	        get: function () {
	            return this._billboardHeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "billboardWidth", {
	        /**
	         *
	         */
	        get: function () {
	            return this._billboardWidth;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Billboard.prototype, "material", {
	        /**
	         *
	         */
	        get: function () {
	            return this._material;
	        },
	        set: function (value) {
	            if (value == this._material)
	                return;
	            if (this._material) {
	                this._material.iRemoveOwner(this);
	                this._material.removeEventListener(SurfaceEvent_1.SurfaceEvent.INVALIDATE_TEXTURE, this.onInvalidateTextureDelegate);
	            }
	            this._material = value;
	            if (this._material) {
	                this._material.iAddOwner(this);
	                this._material.addEventListener(SurfaceEvent_1.SurfaceEvent.INVALIDATE_TEXTURE, this.onInvalidateTextureDelegate);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @protected
	     */
	    Billboard.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        this._pBoxBounds.width = this._billboardRect.width;
	        this._pBoxBounds.height = this._billboardRect.height;
	    };
	    Billboard.prototype.clone = function () {
	        var clone = new Billboard(this.material);
	        return clone;
	    };
	    Object.defineProperty(Billboard.prototype, "style", {
	        /**
	         * The style used to render the current Billboard. If set to null, the default style of the material will be used instead.
	         */
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._onInvalidateProperties();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * //TODO
	     *
	     * @param shortestCollisionDistance
	     * @returns {boolean}
	     *
	     * @internal
	     */
	    Billboard.prototype._iTestCollision = function (pickingCollision, pickingCollider) {
	        return pickingCollider.testBillboardCollision(this, this.material, pickingCollision);
	    };
	    /**
	     * @private
	     */
	    Billboard.prototype.onInvalidateTexture = function (event) {
	        this._updateDimensions();
	    };
	    Billboard.prototype._acceptTraverser = function (traverser) {
	        traverser.applyRenderable(this);
	    };
	    Billboard.prototype._updateDimensions = function () {
	        var texture = this.material.getTextureAt(0);
	        var image = texture ? ((this._style ? this._style.getImageAt(texture) : null) || (this.material.style ? this.material.style.getImageAt(texture) : null) || texture.getImageAt(0)) : null;
	        if (image) {
	            var sampler = ((this._style ? this._style.getSamplerAt(texture) : null) || (this.material.style ? this.material.style.getSamplerAt(texture) : null) || texture.getSamplerAt(0) || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultSampler());
	            if (sampler.imageRect) {
	                this._billboardWidth = sampler.imageRect.width * image.width;
	                this._billboardHeight = sampler.imageRect.height * image.height;
	            }
	            else {
	                this._billboardWidth = image.rect.width;
	                this._billboardHeight = image.rect.height;
	            }
	            this._billboardRect = sampler.frameRect || new Rectangle_1.Rectangle(0, 0, this._billboardWidth, this._billboardHeight);
	        }
	        else {
	            this._billboardWidth = 1;
	            this._billboardHeight = 1;
	            this._billboardRect = new Rectangle_1.Rectangle(0, 0, 1, 1);
	        }
	        this._pInvalidateBounds();
	        this.invalidateElements();
	    };
	    Billboard.prototype.invalidateElements = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_ELEMENTS, this));
	    };
	    Billboard.prototype.invalidateSurface = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_SURFACE, this));
	    };
	    Billboard.prototype._onInvalidateProperties = function (event) {
	        if (event === void 0) { event = null; }
	        this.invalidateSurface();
	        this._updateDimensions();
	    };
	    Billboard.assetType = "[asset Billboard]";
	    return Billboard;
	}(DisplayObject_1.DisplayObject));
	exports.Billboard = Billboard;


/***/ },
/* 113 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Box_1 = __webpack_require__(33);
	var ColorTransform_1 = __webpack_require__(27);
	var Sphere_1 = __webpack_require__(114);
	var MathConsts_1 = __webpack_require__(35);
	var Matrix3D_1 = __webpack_require__(32);
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Point_1 = __webpack_require__(58);
	var Vector3D_1 = __webpack_require__(34);
	var AssetBase_1 = __webpack_require__(6);
	var HierarchicalProperties_1 = __webpack_require__(22);
	var BoundsType_1 = __webpack_require__(115);
	var AlignmentMode_1 = __webpack_require__(21);
	var OrientationMode_1 = __webpack_require__(23);
	var Transform_1 = __webpack_require__(31);
	var PickingCollision_1 = __webpack_require__(116);
	var DisplayObjectEvent_1 = __webpack_require__(117);
	var TransformEvent_1 = __webpack_require__(39);
	/**
	 * The DisplayObject class is the base class for all objects that can be
	 * placed on the display list. The display list manages all objects displayed
	 * in flash. Use the DisplayObjectContainer class to arrange the
	 * display objects in the display list. DisplayObjectContainer objects can
	 * have child display objects, while other display objects, such as Shape and
	 * TextField objects, are "leaf" nodes that have only parents and siblings, no
	 * children.
	 *
	 * <p>The DisplayObject class supports basic functionality like the <i>x</i>
	 * and <i>y</i> position of an object, as well as more advanced properties of
	 * the object such as its transformation matrix. </p>
	 *
	 * <p>DisplayObject is an abstract base class; therefore, you cannot call
	 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
	 * <code>ArgumentError</code> exception. </p>
	 *
	 * <p>All display objects inherit from the DisplayObject class.</p>
	 *
	 * <p>The DisplayObject class itself does not include any APIs for rendering
	 * content onscreen. For that reason, if you want create a custom subclass of
	 * the DisplayObject class, you will want to extend one of its subclasses that
	 * do have APIs for rendering content onscreen, such as the Shape, Sprite,
	 * Bitmap, SimpleButton, TextField, or MovieClip class.</p>
	 *
	 * <p>The DisplayObject class contains several broadcast events. Normally, the
	 * target of any particular event is a specific DisplayObject instance. For
	 * example, the target of an <code>added</code> event is the specific
	 * DisplayObject instance that was added to the display list. Having a single
	 * target restricts the placement of event listeners to that target and in
	 * some cases the target's ancestors on the display list. With broadcast
	 * events, however, the target is not a specific DisplayObject instance, but
	 * rather all DisplayObject instances, including those that are not on the
	 * display list. This means that you can add a listener to any DisplayObject
	 * instance to listen for broadcast events. In addition to the broadcast
	 * events listed in the DisplayObject class's Events table, the DisplayObject
	 * class also inherits two broadcast events from the EventDispatcher class:
	 * <code>activate</code> and <code>deactivate</code>.</p>
	 *
	 * <p>Some properties previously used in the ActionScript 1.0 and 2.0
	 * MovieClip, TextField, and Button classes(such as <code>_alpha</code>,
	 * <code>_height</code>, <code>_name</code>, <code>_width</code>,
	 * <code>_x</code>, <code>_y</code>, and others) have equivalents in the
	 * ActionScript 3.0 DisplayObject class that are renamed so that they no
	 * longer begin with the underscore(_) character.</p>
	 *
	 * <p>For more information, see the "Display Programming" chapter of the
	 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
	 *
	 * @event added            Dispatched when a display object is added to the
	 *                         display list. The following methods trigger this
	 *                         event:
	 *                         <code>DisplayObjectContainer.addChild()</code>,
	 *                         <code>DisplayObjectContainer.addChildAt()</code>.
	 * @event addedToScene     Dispatched when a display object is added to the on
	 *                         scene display list, either directly or through the
	 *                         addition of a sub tree in which the display object
	 *                         is contained. The following methods trigger this
	 *                         event:
	 *                         <code>DisplayObjectContainer.addChild()</code>,
	 *                         <code>DisplayObjectContainer.addChildAt()</code>.
	 * @event enterFrame       [broadcast event] Dispatched when the playhead is
	 *                         entering a new frame. If the playhead is not
	 *                         moving, or if there is only one frame, this event
	 *                         is dispatched continuously in conjunction with the
	 *                         frame rate. This event is a broadcast event, which
	 *                         means that it is dispatched by all display objects
	 *                         with a listener registered for this event.
	 * @event exitFrame        [broadcast event] Dispatched when the playhead is
	 *                         exiting the current frame. All frame scripts have
	 *                         been run. If the playhead is not moving, or if
	 *                         there is only one frame, this event is dispatched
	 *                         continuously in conjunction with the frame rate.
	 *                         This event is a broadcast event, which means that
	 *                         it is dispatched by all display objects with a
	 *                         listener registered for this event.
	 * @event frameConstructed [broadcast event] Dispatched after the constructors
	 *                         of frame display objects have run but before frame
	 *                         scripts have run. If the playhead is not moving, or
	 *                         if there is only one frame, this event is
	 *                         dispatched continuously in conjunction with the
	 *                         frame rate. This event is a broadcast event, which
	 *                         means that it is dispatched by all display objects
	 *                         with a listener registered for this event.
	 * @event removed          Dispatched when a display object is about to be
	 *                         removed from the display list. Two methods of the
	 *                         DisplayObjectContainer class generate this event:
	 *                         <code>removeChild()</code> and
	 *                         <code>removeChildAt()</code>.
	 *
	 *                         <p>The following methods of a
	 *                         DisplayObjectContainer object also generate this
	 *                         event if an object must be removed to make room for
	 *                         the new object: <code>addChild()</code>,
	 *                         <code>addChildAt()</code>, and
	 *                         <code>setChildIndex()</code>. </p>
	 * @event removedFromScene Dispatched when a display object is about to be
	 *                         removed from the display list, either directly or
	 *                         through the removal of a sub tree in which the
	 *                         display object is contained. Two methods of the
	 *                         DisplayObjectContainer class generate this event:
	 *                         <code>removeChild()</code> and
	 *                         <code>removeChildAt()</code>.
	 *
	 *                         <p>The following methods of a
	 *                         DisplayObjectContainer object also generate this
	 *                         event if an object must be removed to make room for
	 *                         the new object: <code>addChild()</code>,
	 *                         <code>addChildAt()</code>, and
	 *                         <code>setChildIndex()</code>. </p>
	 * @event render           [broadcast event] Dispatched when the display list
	 *                         is about to be updated and rendered. This event
	 *                         provides the last opportunity for objects listening
	 *                         for this event to make changes before the display
	 *                         list is rendered. You must call the
	 *                         <code>invalidate()</code> method of the Scene
	 *                         object each time you want a <code>render</code>
	 *                         event to be dispatched. <code>Render</code> events
	 *                         are dispatched to an object only if there is mutual
	 *                         trust between it and the object that called
	 *                         <code>Scene.invalidate()</code>. This event is a
	 *                         broadcast event, which means that it is dispatched
	 *                         by all display objects with a listener registered
	 *                         for this event.
	 *
	 *                         <p><b>Note: </b>This event is not dispatched if the
	 *                         display is not rendering. This is the case when the
	 *                         content is either minimized or obscured. </p>
	 */
	var DisplayObject = (function (_super) {
	    __extends(DisplayObject, _super);
	    /**
	     * Creates a new <code>DisplayObject</code> instance.
	     */
	    function DisplayObject() {
	        var _this = this;
	        _super.call(this);
	        this._queuedEvents = new Array();
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	        this._pSceneTransform = new Matrix3D_1.Matrix3D();
	        this._pIsEntity = false;
	        this._pIsContainer = false;
	        this._sessionID = -1;
	        this._depthID = -16384;
	        this._inverseSceneTransform = new Matrix3D_1.Matrix3D();
	        this._scenePosition = new Vector3D_1.Vector3D();
	        this._explicitVisibility = true;
	        this._explicitMaskId = -1;
	        this._pImplicitVisibility = true;
	        this._pImplicitMaskId = -1;
	        this._pImplicitMaskIds = new Array();
	        this._explicitMouseEnabled = true;
	        this._pImplicitMouseEnabled = true;
	        this._orientationMatrix = new Matrix3D_1.Matrix3D();
	        this._inheritColorTransform = false;
	        this._maskMode = false;
	        //temp vector used in global to local
	        this._tempVector3D = new Vector3D_1.Vector3D();
	        /**
	         *
	         */
	        this.alignmentMode = AlignmentMode_1.AlignmentMode.REGISTRATION_POINT;
	        /**
	         *
	         */
	        this.castsShadows = true;
	        /**
	         *
	         */
	        this.orientationMode = OrientationMode_1.OrientationMode.DEFAULT;
	        /**
	         *
	         */
	        this.zOffset = 0;
	        //global debug bounding boxes:
	        //this._debugVisible=true;
	        //creation of associated transform object
	        this._transform = new Transform_1.Transform();
	        //setup transform listeners
	        this._transform.addEventListener(TransformEvent_1.TransformEvent.INVALIDATE_MATRIX3D, function (event) { return _this._onInvalidateMatrix3D(event); });
	        this._transform.addEventListener(TransformEvent_1.TransformEvent.INVALIDATE_COLOR_TRANSFORM, function (event) { return _this._onInvalidateColorTransform(event); });
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.AXIS_ALIGNED_BOX;
	    }
	    Object.defineProperty(DisplayObject.prototype, "adapter", {
	        /**
	         * adapter is used to provide MovieClip to scripts taken from different platforms
	         * setter typically managed by factory
	         */
	        get: function () {
	            return this._adapter;
	        },
	        set: function (value) {
	            this._adapter = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "inheritColorTransform", {
	        get: function () {
	            return this._inheritColorTransform;
	        },
	        set: function (value) {
	            if (this._inheritColorTransform == value)
	                return;
	            this._inheritColorTransform = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "alpha", {
	        /**
	         * Indicates the alpha transparency value of the object specified. Valid
	         * values are 0(fully transparent) to 1(fully opaque). The default value is
	         * 1. Display objects with <code>alpha</code> set to 0 <i>are</i> active,
	         * even though they are invisible.
	         */
	        get: function () {
	            return this._transform.colorTransform ? this._transform.colorTransform.alphaMultiplier : 1;
	        },
	        set: function (value) {
	            if (!this._transform.colorTransform)
	                this._transform.colorTransform = new ColorTransform_1.ColorTransform();
	            this._transform.colorTransform.alphaMultiplier = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "boundsType", {
	        /**
	         *
	         */
	        get: function () {
	            return this._boundsType;
	        },
	        set: function (value) {
	            if (this._boundsType == value)
	                return;
	            this._boundsType = value;
	            this.invalidate();
	            this._pInvalidateBounds();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "depth", {
	        /**
	         * Indicates the depth of the display object, in pixels. The depth is
	         * calculated based on the bounds of the content of the display object. When
	         * you set the <code>depth</code> property, the <code>scaleZ</code> property
	         * is adjusted accordingly, as shown in the following code:
	         *
	         * <p>Except for TextField and Video objects, a display object with no
	         * content (such as an empty sprite) has a depth of 0, even if you try to
	         * set <code>depth</code> to a different value.</p>
	         */
	        get: function () {
	            return this.getBox().depth * this.scaleZ;
	        },
	        set: function (val) {
	            if (this._depth == val)
	                return;
	            this._depth = val;
	            this._setScaleZ(val / this.getBox().depth);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "eulers", {
	        /**
	         * Defines the rotation of the 3d object as a <code>Vector3D</code> object containing euler angles for rotation around x, y and z axis.
	         */
	        get: function () {
	            if (!this._eulers)
	                this._eulers = new Vector3D_1.Vector3D();
	            this._eulers.x = this.rotationX;
	            this._eulers.y = this.rotationY;
	            this._eulers.z = this.rotationZ;
	            return this._eulers;
	        },
	        set: function (value) {
	            // previously this was using the setters for rotationX etc
	            // but because this will convert from radians to degree, i changed it to update directly
	            this._transform.rotation.x = value.x;
	            this._transform.rotation.y = value.y;
	            this._transform.rotation.z = value.z;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "height", {
	        /**
	         * An indexed array that contains each filter object currently associated
	         * with the display object. The flash.filters package contains several
	         * classes that define specific filters you can use.
	         *
	         * <p>Filters can be applied in Flash Professional at design time, or at run
	         * time by using ActionScript code. To apply a filter by using ActionScript,
	         * you must make a temporary copy of the entire <code>filters</code> array,
	         * modify the temporary array, then assign the value of the temporary array
	         * back to the <code>filters</code> array. You cannot directly add a new
	         * filter object to the <code>filters</code> array.</p>
	         *
	         * <p>To add a filter by using ActionScript, perform the following steps
	         * (assume that the target display object is named
	         * <code>myDisplayObject</code>):</p>
	         *
	         * <ol>
	         *   <li>Create a new filter object by using the constructor method of your
	         * chosen filter class.</li>
	         *   <li>Assign the value of the <code>myDisplayObject.filters</code> array
	         * to a temporary array, such as one named <code>myFilters</code>.</li>
	         *   <li>Add the new filter object to the <code>myFilters</code> temporary
	         * array.</li>
	         *   <li>Assign the value of the temporary array to the
	         * <code>myDisplayObject.filters</code> array.</li>
	         * </ol>
	         *
	         * <p>If the <code>filters</code> array is undefined, you do not need to use
	         * a temporary array. Instead, you can directly assign an array literal that
	         * contains one or more filter objects that you create. The first example in
	         * the Examples section adds a drop shadow filter by using code that handles
	         * both defined and undefined <code>filters</code> arrays.</p>
	         *
	         * <p>To modify an existing filter object, you must use the technique of
	         * modifying a copy of the <code>filters</code> array:</p>
	         *
	         * <ol>
	         *   <li>Assign the value of the <code>filters</code> array to a temporary
	         * array, such as one named <code>myFilters</code>.</li>
	         *   <li>Modify the property by using the temporary array,
	         * <code>myFilters</code>. For example, to set the quality property of the
	         * first filter in the array, you could use the following code:
	         * <code>myFilters[0].quality = 1;</code></li>
	         *   <li>Assign the value of the temporary array to the <code>filters</code>
	         * array.</li>
	         * </ol>
	         *
	         * <p>At load time, if a display object has an associated filter, it is
	         * marked to cache itself as a transparent bitmap. From this point forward,
	         * as long as the display object has a valid filter list, the player caches
	         * the display object as a bitmap. This source bitmap is used as a source
	         * image for the filter effects. Each display object usually has two bitmaps:
	         * one with the original unfiltered source display object and another for the
	         * final image after filtering. The final image is used when rendering. As
	         * long as the display object does not change, the final image does not need
	         * updating.</p>
	         *
	         * <p>The flash.filters package includes classes for filters. For example, to
	         * create a DropShadow filter, you would write:</p>
	         *
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	         *                       and the shader output type is not compatible with
	         *                       this operation(the shader must specify a
	         *                       <code>pixel4</code> output).
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	         *                       and the shader doesn't specify any image input or
	         *                       the first input is not an <code>image4</code> input.
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
	         *                       and the shader specifies an image input that isn't
	         *                       provided.
	         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter, a
	         *                       ByteArray or Vector.<Number> instance as a shader
	         *                       input, and the <code>width</code> and
	         *                       <code>height</code> properties aren't specified for
	         *                       the ShaderInput object, or the specified values
	         *                       don't match the amount of data in the input data.
	         *                       See the <code>ShaderInput.input</code> property for
	         *                       more information.
	         */
	        //		public filters:Array<Dynamic>;
	        /**
	         * Indicates the height of the display object, in pixels. The height is
	         * calculated based on the bounds of the content of the display object. When
	         * you set the <code>height</code> property, the <code>scaleY</code> property
	         * is adjusted accordingly, as shown in the following code:
	         *
	         * <p>Except for TextField and Video objects, a display object with no
	         * content (such as an empty sprite) has a height of 0, even if you try to
	         * set <code>height</code> to a different value.</p>
	         */
	        get: function () {
	            return this.getBox().height * this.scaleY;
	        },
	        set: function (val) {
	            if (this._height == val)
	                return;
	            this._height = val;
	            this._setScaleY(val / this.getBox().height);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "index", {
	        /**
	         * Indicates the instance container index of the DisplayObject. The object can be
	         * identified in the child list of its parent display object container by
	         * calling the <code>getChildByIndex()</code> method of the display object
	         * container.
	         *
	         * <p>If the DisplayObject has no parent container, index defaults to 0.</p>
	         */
	        get: function () {
	            if (this._pParent)
	                return this._pParent.getChildIndex(this);
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "inverseSceneTransform", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._inverseSceneTransformDirty) {
	                this._inverseSceneTransform.copyFrom(this.sceneTransform);
	                this._inverseSceneTransform.invert();
	                this._inverseSceneTransformDirty = false;
	            }
	            return this._inverseSceneTransform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "isEntity", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pIsEntity;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "isContainer", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pIsContainer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "loaderInfo", {
	        /**
	         * Returns a LoaderInfo object containing information about loading the file
	         * to which this display object belongs. The <code>loaderInfo</code> property
	         * is defined only for the root display object of a SWF file or for a loaded
	         * Bitmap(not for a Bitmap that is drawn with ActionScript). To find the
	         * <code>loaderInfo</code> object associated with the SWF file that contains
	         * a display object named <code>myDisplayObject</code>, use
	         * <code>myDisplayObject.root.loaderInfo</code>.
	         *
	         * <p>A large SWF file can monitor its download by calling
	         * <code>this.root.loaderInfo.addEventListener(Event.COMPLETE,
	         * func)</code>.</p>
	         */
	        get: function () {
	            return this._loaderInfo;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "maskMode", {
	        get: function () {
	            return this._maskMode;
	        },
	        set: function (value) {
	            if (this._maskMode == value)
	                return;
	            this._maskMode = value;
	            this._explicitMaskId = value ? this.id : -1;
	            this._updateMaskMode();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "mouseEnabled", {
	        /**
	         * Specifies whether this object receives mouse, or other user input,
	         * messages. The default value is <code>true</code>, which means that by
	         * default any InteractiveObject instance that is on the display list
	         * receives mouse events or other user input events. If
	         * <code>mouseEnabled</code> is set to <code>false</code>, the instance does
	         * not receive any mouse events(or other user input events like keyboard
	         * events). Any children of this instance on the display list are not
	         * affected. To change the <code>mouseEnabled</code> behavior for all
	         * children of an object on the display list, use
	         * <code>flash.display.DisplayObjectContainer.mouseChildren</code>.
	         *
	         * <p> No event is dispatched by setting this property. You must use the
	         * <code>addEventListener()</code> method to create interactive
	         * functionality.</p>
	         */
	        get: function () {
	            return this._explicitMouseEnabled;
	        },
	        set: function (value) {
	            if (this._explicitMouseEnabled == value)
	                return;
	            this._explicitMouseEnabled = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "mouseX", {
	        /**
	         * Indicates the x coordinate of the mouse or user input device position, in
	         * pixels.
	         *
	         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned x
	         * coordinate will reflect the non-rotated object.</p>
	         */
	        get: function () {
	            return this._mouseX;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "mouseY", {
	        /**
	         * Indicates the y coordinate of the mouse or user input device position, in
	         * pixels.
	         *
	         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned y
	         * coordinate will reflect the non-rotated object.</p>
	         */
	        get: function () {
	            return this._mouseY;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "name", {
	        /**
	         * Indicates the instance name of the DisplayObject. The object can be
	         * identified in the child list of its parent display object container by
	         * calling the <code>getChildByName()</code> method of the display object
	         * container.
	         *
	         * @throws IllegalOperationError If you are attempting to set this property
	         *                               on an object that was placed on the timeline
	         *                               in the Flash authoring tool.
	         */
	        get: function () {
	            return this._pName;
	        },
	        set: function (value) {
	            this._pName = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "parent", {
	        /**
	         * Indicates the DisplayObjectContainer object that contains this display
	         * object. Use the <code>parent</code> property to specify a relative path to
	         * display objects that are above the current display object in the display
	         * list hierarchy.
	         *
	         * <p>You can use <code>parent</code> to move up multiple levels in the
	         * display list as in the following:</p>
	         *
	         * @throws SecurityError The parent display object belongs to a security
	         *                       sandbox to which you do not have access. You can
	         *                       avoid this situation by having the parent movie call
	         *                       the <code>Security.allowDomain()</code> method.
	         */
	        get: function () {
	            return this._pParent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "isPartition", {
	        /**
	         *
	         */
	        get: function () {
	            return this._iIsPartition;
	        },
	        set: function (value) {
	            if (this._iIsPartition == value)
	                return;
	            this._iIsPartition = value;
	            this._iSetScene(this._pScene, this._pParent ? this._pParent._pPartition : null);
	            this.dispatchEvent(new DisplayObjectEvent_1.DisplayObjectEvent(DisplayObjectEvent_1.DisplayObjectEvent.PARTITION_CHANGED, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "pivot", {
	        /**
	         * Defines the local point around which the object rotates.
	         */
	        get: function () {
	            return this._pivot;
	        },
	        set: function (pivot) {
	            if (this._pivot && this._pivot.x == pivot.x && this._pivot.y == pivot.y && this._pivot.z == pivot.z)
	                return;
	            if (!pivot) {
	                this._pivot = null;
	                this._pivotScale = null;
	            }
	            else {
	                if (!this._pivot)
	                    this._pivot = new Vector3D_1.Vector3D();
	                this._pivot.x = pivot.x;
	                this._pivot.y = pivot.y;
	                this._pivot.z = pivot.z;
	            }
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "root", {
	        /**
	         * For a display object in a loaded SWF file, the <code>root</code> property
	         * is the top-most display object in the portion of the display list's tree
	         * structure represented by that SWF file. For a Bitmap object representing a
	         * loaded image file, the <code>root</code> property is the Bitmap object
	         * itself. For the instance of the main class of the first SWF file loaded,
	         * the <code>root</code> property is the display object itself. The
	         * <code>root</code> property of the Scene object is the Scene object itself.
	         * The <code>root</code> property is set to <code>null</code> for any display
	         * object that has not been added to the display list, unless it has been
	         * added to a display object container that is off the display list but that
	         * is a child of the top-most display object in a loaded SWF file.
	         *
	         * <p>For example, if you create a new Sprite object by calling the
	         * <code>Sprite()</code> constructor method, its <code>root</code> property
	         * is <code>null</code> until you add it to the display list(or to a display
	         * object container that is off the display list but that is a child of the
	         * top-most display object in a SWF file).</p>
	         *
	         * <p>For a loaded SWF file, even though the Loader object used to load the
	         * file may not be on the display list, the top-most display object in the
	         * SWF file has its <code>root</code> property set to itself. The Loader
	         * object does not have its <code>root</code> property set until it is added
	         * as a child of a display object for which the <code>root</code> property is
	         * set.</p>
	         */
	        get: function () {
	            return this._root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "rotationX", {
	        /**
	         * Indicates the x-axis rotation of the DisplayObject instance, in degrees,
	         * from its original orientation relative to the 3D parent container. Values
	         * from 0 to 180 represent clockwise rotation; values from 0 to -180
	         * represent counterclockwise rotation. Values outside this range are added
	         * to or subtracted from 360 to obtain a value within the range.
	         */
	        get: function () {
	            return this._transform.rotation.x * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	        },
	        set: function (val) {
	            if (this.rotationX == val)
	                return;
	            this._transform.rotation.x = val * MathConsts_1.MathConsts.DEGREES_TO_RADIANS;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "rotationY", {
	        /**
	         * Indicates the y-axis rotation of the DisplayObject instance, in degrees,
	         * from its original orientation relative to the 3D parent container. Values
	         * from 0 to 180 represent clockwise rotation; values from 0 to -180
	         * represent counterclockwise rotation. Values outside this range are added
	         * to or subtracted from 360 to obtain a value within the range.
	         */
	        get: function () {
	            return this._transform.rotation.y * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	        },
	        set: function (val) {
	            if (this.rotationY == val)
	                return;
	            this._transform.rotation.y = val * MathConsts_1.MathConsts.DEGREES_TO_RADIANS;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "rotationZ", {
	        /**
	         * Indicates the z-axis rotation of the DisplayObject instance, in degrees,
	         * from its original orientation relative to the 3D parent container. Values
	         * from 0 to 180 represent clockwise rotation; values from 0 to -180
	         * represent counterclockwise rotation. Values outside this range are added
	         * to or subtracted from 360 to obtain a value within the range.
	         */
	        get: function () {
	            return this._transform.rotation.z * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	        },
	        set: function (val) {
	            if (this.rotationZ == val)
	                return;
	            this._transform.rotation.z = val * MathConsts_1.MathConsts.DEGREES_TO_RADIANS;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scaleX", {
	        /**
	         * Indicates the horizontal scale(percentage) of the object as applied from
	         * the registration point. The default registration point is(0,0). 1.0
	         * equals 100% scale.
	         *
	         * <p>Scaling the local coordinate system changes the <code>x</code> and
	         * <code>y</code> property values, which are defined in whole pixels. </p>
	         */
	        get: function () {
	            return this._transform.scale.x;
	        },
	        set: function (val) {
	            //remove absolute width
	            this._width = null;
	            this._setScaleX(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scaleY", {
	        /**
	         * Indicates the vertical scale(percentage) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         * 1.0 is 100% scale.
	         *
	         * <p>Scaling the local coordinate system changes the <code>x</code> and
	         * <code>y</code> property values, which are defined in whole pixels. </p>
	         */
	        get: function () {
	            return this._transform.scale.y;
	        },
	        set: function (val) {
	            //remove absolute height
	            this._height = null;
	            this._setScaleY(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scaleZ", {
	        /**
	         * Indicates the depth scale(percentage) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         * 1.0 is 100% scale.
	         *
	         * <p>Scaling the local coordinate system changes the <code>x</code>,
	         * <code>y</code> and <code>z</code> property values, which are defined in
	         * whole pixels. </p>
	         */
	        get: function () {
	            return this._transform.scale.z;
	        },
	        set: function (val) {
	            //remove absolute depth
	            this._depth = null;
	            this._setScaleZ(val);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "skewX", {
	        /**
	         * Indicates the horizontal skew(angle) of the object as applied from
	         * the registration point. The default registration point is(0,0).
	         */
	        get: function () {
	            return this._transform.skew.x;
	        },
	        set: function (val) {
	            if (this.skewX == val)
	                return;
	            this._transform.skew.x = val;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "skewY", {
	        /**
	         * Indicates the vertical skew(angle) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         */
	        get: function () {
	            return this._transform.skew.y;
	        },
	        set: function (val) {
	            if (this.skewY == val)
	                return;
	            this._transform.skew.y = val;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "skewZ", {
	        /**
	         * Indicates the depth skew(angle) of an object as applied from the
	         * registration point of the object. The default registration point is(0,0).
	         */
	        get: function () {
	            return this._transform.skew.z;
	        },
	        set: function (val) {
	            if (this.skewZ == val)
	                return;
	            this._transform.skew.z = val;
	            this._transform.invalidateMatrix3D();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "partition", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pPartition;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scene", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pScene;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "scenePosition", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._scenePositionDirty) {
	                if (this._pivot && this.alignmentMode == AlignmentMode_1.AlignmentMode.PIVOT_POINT) {
	                    this._scenePosition = this.sceneTransform.transformVector(this._pivotScale);
	                }
	                else {
	                    this.sceneTransform.copyColumnTo(3, this._scenePosition);
	                }
	                this._scenePositionDirty = false;
	            }
	            return this._scenePosition;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "sceneTransform", {
	        get: function () {
	            if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM)
	                this.pUpdateSceneTransform();
	            return this._pSceneTransform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "shaderPickingDetails", {
	        /**
	         *
	         */
	        get: function () {
	            return this._shaderPickingDetails;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "debugVisible", {
	        /**
	         *
	         */
	        get: function () {
	            return this._debugVisible;
	        },
	        set: function (value) {
	            if (value == this._debugVisible)
	                return;
	            this._debugVisible = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "transform", {
	        /**
	         * An object with properties pertaining to a display object's matrix, color
	         * transform, and pixel bounds. The specific properties  -  matrix,
	         * colorTransform, and three read-only properties
	         * (<code>concatenatedMatrix</code>, <code>concatenatedColorTransform</code>,
	         * and <code>pixelBounds</code>)  -  are described in the entry for the
	         * Transform class.
	         *
	         * <p>Each of the transform object's properties is itself an object. This
	         * concept is important because the only way to set new values for the matrix
	         * or colorTransform objects is to create a new object and copy that object
	         * into the transform.matrix or transform.colorTransform property.</p>
	         *
	         * <p>For example, to increase the <code>tx</code> value of a display
	         * object's matrix, you must make a copy of the entire matrix object, then
	         * copy the new object into the matrix property of the transform object:</p>
	         * <pre xml:space="preserve"><code> public myMatrix:Matrix =
	         * myDisplayObject.transform.matrix; myMatrix.tx += 10;
	         * myDisplayObject.transform.matrix = myMatrix; </code></pre>
	         *
	         * <p>You cannot directly set the <code>tx</code> property. The following
	         * code has no effect on <code>myDisplayObject</code>: </p>
	         * <pre xml:space="preserve"><code> myDisplayObject.transform.matrix.tx +=
	         * 10; </code></pre>
	         *
	         * <p>You can also copy an entire transform object and assign it to another
	         * display object's transform property. For example, the following code
	         * copies the entire transform object from <code>myOldDisplayObj</code> to
	         * <code>myNewDisplayObj</code>:</p>
	         * <code>myNewDisplayObj.transform = myOldDisplayObj.transform;</code>
	         *
	         * <p>The resulting display object, <code>myNewDisplayObj</code>, now has the
	         * same values for its matrix, color transform, and pixel bounds as the old
	         * display object, <code>myOldDisplayObj</code>.</p>
	         *
	         * <p>Note that AIR for TV devices use hardware acceleration, if it is
	         * available, for color transforms.</p>
	         */
	        get: function () {
	            return this._transform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "visible", {
	        /**
	         * Whether or not the display object is visible. Display objects that are not
	         * visible are disabled. For example, if <code>visible=false</code> for an
	         * InteractiveObject instance, it cannot be clicked.
	         */
	        get: function () {
	            return this._explicitVisibility;
	        },
	        set: function (value) {
	            if (this._explicitVisibility == value)
	                return;
	            this._explicitVisibility = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.VISIBLE);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "masks", {
	        get: function () {
	            return this._explicitMasks;
	        },
	        set: function (value) {
	            if (this._explicitMasks == value)
	                return;
	            this._explicitMasks = value;
	            //make sure maskMode is set to true for all masks
	            if (value != null && value.length) {
	                var len = value.length;
	                for (var i = 0; i < len; i++)
	                    value[i].maskMode = true;
	            }
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.MASKS);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "width", {
	        /**
	         * Indicates the width of the display object, in pixels. The width is
	         * calculated based on the bounds of the content of the display object. When
	         * you set the <code>width</code> property, the <code>scaleX</code> property
	         * is adjusted accordingly, as shown in the following code:
	         *
	         * <p>Except for TextField and Video objects, a display object with no
	         * content(such as an empty sprite) has a width of 0, even if you try to set
	         * <code>width</code> to a different value.</p>
	         */
	        get: function () {
	            return this.getBox().width * this.scaleX;
	        },
	        set: function (val) {
	            if (this._width == val)
	                return;
	            this._width = val;
	            this._setScaleX(val / this.getBox().width);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "x", {
	        /**
	         * Indicates the <i>x</i> coordinate of the DisplayObject instance relative
	         * to the local coordinates of the parent DisplayObjectContainer. If the
	         * object is inside a DisplayObjectContainer that has transformations, it is
	         * in the local coordinate system of the enclosing DisplayObjectContainer.
	         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
	         * DisplayObjectContainer's children inherit a coordinate system that is
	         * rotated 90° counterclockwise. The object's coordinates refer to the
	         * registration point position.
	         */
	        get: function () {
	            return this._transform.position.x;
	        },
	        set: function (val) {
	            if (this._transform.position.x == val)
	                return;
	            this._transform.matrix3D.rawData[12] = val;
	            this._transform.invalidatePosition();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "y", {
	        /**
	         * Indicates the <i>y</i> coordinate of the DisplayObject instance relative
	         * to the local coordinates of the parent DisplayObjectContainer. If the
	         * object is inside a DisplayObjectContainer that has transformations, it is
	         * in the local coordinate system of the enclosing DisplayObjectContainer.
	         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
	         * DisplayObjectContainer's children inherit a coordinate system that is
	         * rotated 90° counterclockwise. The object's coordinates refer to the
	         * registration point position.
	         */
	        get: function () {
	            return this._transform.position.y;
	        },
	        set: function (val) {
	            if (this._transform.position.y == val)
	                return;
	            this._transform.matrix3D.rawData[13] = val;
	            this._transform.invalidatePosition();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObject.prototype, "z", {
	        /**
	         * Indicates the z coordinate position along the z-axis of the DisplayObject
	         * instance relative to the 3D parent container. The z property is used for
	         * 3D coordinates, not screen or pixel coordinates.
	         *
	         * <p>When you set a <code>z</code> property for a display object to
	         * something other than the default value of <code>0</code>, a corresponding
	         * Matrix3D object is automatically created. for adjusting a display object's
	         * position and orientation in three dimensions. When working with the
	         * z-axis, the existing behavior of x and y properties changes from screen or
	         * pixel coordinates to positions relative to the 3D parent container.</p>
	         *
	         * <p>For example, a child of the <code>_root</code> at position x = 100, y =
	         * 100, z = 200 is not drawn at pixel location(100,100). The child is drawn
	         * wherever the 3D projection calculation puts it. The calculation is:</p>
	         *
	         * <p><code>(x~~cameraFocalLength/cameraRelativeZPosition,
	         * y~~cameraFocalLength/cameraRelativeZPosition)</code></p>
	         */
	        get: function () {
	            return this._transform.position.z;
	        },
	        set: function (val) {
	            if (this._transform.position.z == val)
	                return;
	            this._transform.matrix3D.rawData[14] = val;
	            this._transform.invalidatePosition();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    DisplayObject.prototype.addEventListener = function (type, listener) {
	        _super.prototype.addEventListener.call(this, type, listener);
	        switch (type) {
	            case DisplayObjectEvent_1.DisplayObjectEvent.SCENE_CHANGED:
	                this._listenToSceneChanged = true;
	                break;
	            case DisplayObjectEvent_1.DisplayObjectEvent.SCENETRANSFORM_CHANGED:
	                this._listenToSceneTransformChanged = true;
	                break;
	        }
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.clone = function () {
	        var newInstance = new DisplayObject();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    DisplayObject.prototype.copyTo = function (newInstance) {
	        newInstance.isPartition = this._iIsPartition;
	        newInstance.boundsType = this._boundsType;
	        newInstance.pivot = this._pivot;
	        newInstance.name = this._pName;
	        newInstance.mouseEnabled = this._explicitMouseEnabled;
	        newInstance.extra = this.extra;
	        newInstance.maskMode = this._maskMode;
	        newInstance.castsShadows = this.castsShadows;
	        if (this._explicitMasks)
	            newInstance.masks = this._explicitMasks;
	        if (this._adapter)
	            newInstance.adapter = this._adapter.clone(newInstance);
	        newInstance._transform.matrix3D = this._transform.matrix3D;
	        if (this._transform.colorTransform)
	            newInstance.transform.colorTransform = this._transform.colorTransform.clone();
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.dispose = function () {
	        this.disposeValues();
	    };
	    DisplayObject.prototype.disposeValues = function () {
	        if (this._pParent)
	            this._pParent.removeChild(this);
	        //if (this._adapter) {
	        //	this._adapter.dispose();
	        //	this._adapter = null;
	        //}
	        //this._pos = null;
	        //this._rot = null;
	        //this._sca = null;
	        //this._ske = null;
	        //this._transformComponents = null;
	        //this._transform.dispose();
	        //this._transform = null;
	        //
	        //this._matrix3D = null;
	        //this._pSceneTransform = null;
	        //this._inverseSceneTransform = null;
	        this._explicitMasks = null;
	    };
	    /**
	     * Returns a rectangle that defines the area of the display object relative
	     * to the coordinate system of the <code>targetCoordinateSpace</code> object.
	     * Consider the following code, which shows how the rectangle returned can
	     * vary depending on the <code>targetCoordinateSpace</code> parameter that
	     * you pass to the method:
	     *
	     * <p><b>Note:</b> Use the <code>localToGlobal()</code> and
	     * <code>globalToLocal()</code> methods to convert the display object's local
	     * coordinates to display coordinates, or display coordinates to local
	     * coordinates, respectively.</p>
	     *
	     * <p>The <code>getBounds()</code> method is similar to the
	     * <code>getRect()</code> method; however, the Rectangle returned by the
	     * <code>getBounds()</code> method includes any strokes on shapes, whereas
	     * the Rectangle returned by the <code>getRect()</code> method does not. For
	     * an example, see the description of the <code>getRect()</code> method.</p>
	     *
	     * @param targetCoordinateSpace The display object that defines the
	     *                              coordinate system to use.
	     * @return The rectangle that defines the area of the display object relative
	     *         to the <code>targetCoordinateSpace</code> object's coordinate
	     *         system.
	     */
	    DisplayObject.prototype.getBounds = function (targetCoordinateSpace) {
	        return this._bounds; //TODO
	    };
	    /**
	     * Returns a rectangle that defines the boundary of the display object, based
	     * on the coordinate system defined by the <code>targetCoordinateSpace</code>
	     * parameter, excluding any strokes on shapes. The values that the
	     * <code>getRect()</code> method returns are the same or smaller than those
	     * returned by the <code>getBounds()</code> method.
	     *
	     * <p><b>Note:</b> Use <code>localToGlobal()</code> and
	     * <code>globalToLocal()</code> methods to convert the display object's local
	     * coordinates to Scene coordinates, or Scene coordinates to local
	     * coordinates, respectively.</p>
	     *
	     * @param targetCoordinateSpace The display object that defines the
	     *                              coordinate system to use.
	     * @return The rectangle that defines the area of the display object relative
	     *         to the <code>targetCoordinateSpace</code> object's coordinate
	     *         system.
	     */
	    DisplayObject.prototype.getRect = function (targetCoordinateSpace) {
	        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
	        return this._bounds; //TODO
	    };
	    DisplayObject.prototype.getBox = function (targetCoordinateSpace) {
	        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
	        if (this._iSourcePrefab)
	            this._iSourcePrefab._iValidate();
	        //TODO targetCoordinateSpace
	        if (this._boxBoundsInvalid) {
	            this._pUpdateBoxBounds();
	            //scale updates if absolute dimensions are detected
	            if (this._width != null)
	                this._setScaleX(this._width / this._pBoxBounds.width);
	            if (this._height != null)
	                this._setScaleY(this._height / this._pBoxBounds.height);
	            if (this._depth != null)
	                this._setScaleZ(this._depth / this._pBoxBounds.depth);
	        }
	        if (targetCoordinateSpace == null || targetCoordinateSpace == this)
	            return this._pBoxBounds;
	        if (targetCoordinateSpace == this._pParent)
	            return this._transform.matrix3D.transformBox(this._pBoxBounds);
	        else
	            return targetCoordinateSpace.inverseSceneTransform.transformBox(this.sceneTransform.transformBox(this._pBoxBounds));
	    };
	    DisplayObject.prototype.getSphere = function (targetCoordinateSpace) {
	        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
	        if (this._iSourcePrefab)
	            this._iSourcePrefab._iValidate();
	        if (this._sphereBoundsInvalid)
	            this._pUpdateSphereBounds();
	        return this._pSphereBounds;
	    };
	    /**
	     * Converts the <code>point</code> object from the Scene(global) coordinates
	     * to the display object's(local) coordinates.
	     *
	     * <p>To use this method, first create an instance of the Point class. The
	     * <i>x</i> and <i>y</i> values that you assign represent global coordinates
	     * because they relate to the origin(0,0) of the main display area. Then
	     * pass the Point instance as the parameter to the
	     * <code>globalToLocal()</code> method. The method returns a new Point object
	     * with <i>x</i> and <i>y</i> values that relate to the origin of the display
	     * object instead of the origin of the Scene.</p>
	     *
	     * @param point An object created with the Point class. The Point object
	     *              specifies the <i>x</i> and <i>y</i> coordinates as
	     *              properties.
	     * @return A Point object with coordinates relative to the display object.
	     */
	    DisplayObject.prototype.globalToLocal = function (point, target) {
	        if (target === void 0) { target = null; }
	        this._tempVector3D.setTo(point.x, point.y, 0);
	        var pos = this.inverseSceneTransform.transformVector(this._tempVector3D, this._tempVector3D);
	        if (!target)
	            target = new Point_1.Point();
	        target.x = pos.x;
	        target.y = pos.y;
	        return target;
	    };
	    /**
	     * Converts a two-dimensional point from the Scene(global) coordinates to a
	     * three-dimensional display object's(local) coordinates.
	     *
	     * <p>To use this method, first create an instance of the Vector3D class. The x,
	     * y and z values that you assign to the Vector3D object represent global
	     * coordinates because they are relative to the origin(0,0,0) of the scene. Then
	     * pass the Vector3D object to the <code>globalToLocal3D()</code> method as the
	     * <code>position</code> parameter.
	     * The method returns three-dimensional coordinates as a Vector3D object
	     * containing <code>x</code>, <code>y</code>, and <code>z</code> values that
	     * are relative to the origin of the three-dimensional display object.</p>
	     *
	     * @param point A Vector3D object representing global x, y and z coordinates in
	     *              the scene.
	     * @return A Vector3D object with coordinates relative to the three-dimensional
	     *         display object.
	     */
	    DisplayObject.prototype.globalToLocal3D = function (position) {
	        return this.inverseSceneTransform.transformVector(position);
	    };
	    /**
	     * Evaluates the bounding box of the display object to see if it overlaps or
	     * intersects with the bounding box of the <code>obj</code> display object.
	     *
	     * @param obj The display object to test against.
	     * @return <code>true</code> if the bounding boxes of the display objects
	     *         intersect; <code>false</code> if not.
	     */
	    DisplayObject.prototype.hitTestObject = function (obj) {
	        var objBox = obj.getBox();
	        if (!objBox)
	            return false;
	        var topLeft = new Point_1.Point(objBox.x, objBox.y);
	        var bottomLeft = new Point_1.Point(objBox.x, objBox.y - objBox.height);
	        var topRight = new Point_1.Point(objBox.x + objBox.width, objBox.y);
	        var bottomRight = new Point_1.Point(objBox.x + objBox.width, objBox.y - objBox.height);
	        topLeft = this.globalToLocal(obj.localToGlobal(topLeft));
	        bottomLeft = this.globalToLocal(obj.localToGlobal(bottomLeft));
	        topRight = this.globalToLocal(obj.localToGlobal(topRight));
	        bottomRight = this.globalToLocal(obj.localToGlobal(bottomRight));
	        var box = this.getBox();
	        if (!box)
	            return false;
	        //first check all points against targer box
	        if (topLeft.x <= box.left && topLeft.x <= box.left && topLeft.y <= box.top && topLeft.y >= box.bottom)
	            return true;
	        if (bottomLeft.x <= box.left && bottomLeft.x <= box.left && bottomLeft.y <= box.top && bottomLeft.y >= box.bottom)
	            return true;
	        if (topRight.x <= box.left && topRight.x <= box.left && topRight.y <= box.top && topRight.y >= box.bottom)
	            return true;
	        if (bottomRight.x <= box.left && bottomRight.x <= box.left && bottomRight.y <= box.top && bottomRight.y >= box.bottom)
	            return true;
	        //now test against obj box
	        var n0x = topRight.y - topLeft.y;
	        var n0y = -(topRight.x - topLeft.x);
	        var n1x = bottomRight.y - topRight.y;
	        var n1y = -(bottomRight.x - topRight.x);
	        var n2x = bottomLeft.y - bottomRight.y;
	        var n2y = -(bottomLeft.x - bottomRight.x);
	        var n3x = topLeft.y - bottomLeft.y;
	        var n3y = -(topLeft.x - bottomLeft.x);
	        var p0x = box.left - topLeft.x;
	        var p0y = box.top - topLeft.y;
	        var p1x = box.left - topRight.x;
	        var p1y = box.top - topRight.y;
	        var p2x = box.left - bottomRight.x;
	        var p2y = box.top - bottomRight.y;
	        var p3x = box.left - bottomLeft.x;
	        var p3y = box.top - bottomLeft.y;
	        var dot0 = (n0x * p0x) + (n0y * p0y);
	        var dot1 = (n1x * p1x) + (n1y * p1y);
	        var dot2 = (n2x * p2x) + (n2y * p2y);
	        var dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if topLeft is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        p0x = box.right - topLeft.x;
	        p0y = box.top - topLeft.y;
	        p1x = box.right - topRight.x;
	        p1y = box.top - topRight.y;
	        p2x = box.right - bottomRight.x;
	        p2y = box.top - bottomRight.y;
	        p3x = box.right - bottomLeft.x;
	        p3y = box.top - bottomLeft.y;
	        dot0 = (n0x * p0x) + (n0y * p0y);
	        dot1 = (n1x * p1x) + (n1y * p1y);
	        dot2 = (n2x * p2x) + (n2y * p2y);
	        dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if topRight is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        p0x = box.left - topLeft.x;
	        p0y = box.bottom - topLeft.y;
	        p1x = box.left - topRight.x;
	        p1y = box.bottom - topRight.y;
	        p2x = box.left - bottomRight.x;
	        p2y = box.bottom - bottomRight.y;
	        p3x = box.left - bottomLeft.x;
	        p3y = box.bottom - bottomLeft.y;
	        dot0 = (n0x * p0x) + (n0y * p0y);
	        dot1 = (n1x * p1x) + (n1y * p1y);
	        dot2 = (n2x * p2x) + (n2y * p2y);
	        dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if bottomLeft is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        p0x = box.right - topLeft.x;
	        p0y = box.bottom - topLeft.y;
	        p1x = box.right - topRight.x;
	        p1y = box.bottom - topRight.y;
	        p2x = box.right - bottomRight.x;
	        p2y = box.bottom - bottomRight.y;
	        p3x = box.right - bottomLeft.x;
	        p3y = box.bottom - bottomLeft.y;
	        dot0 = (n0x * p0x) + (n0y * p0y);
	        dot1 = (n1x * p1x) + (n1y * p1y);
	        dot2 = (n2x * p2x) + (n2y * p2y);
	        dot3 = (n3x * p3x) + (n3y * p3y);
	        //check if bottomRight is contained
	        if (dot0 < 0 && dot1 < 0 && dot2 < 0 && dot3 < 0)
	            return true;
	        return false; //TODO
	    };
	    /**
	     * Evaluates the display object to see if it overlaps or intersects with the
	     * point specified by the <code>x</code> and <code>y</code> parameters. The
	     * <code>x</code> and <code>y</code> parameters specify a point in the
	     * coordinate space of the Scene, not the display object container that
	     * contains the display object(unless that display object container is the
	     * Scene).
	     *
	     * @param x         The <i>x</i> coordinate to test against this object.
	     * @param y         The <i>y</i> coordinate to test against this object.
	     * @param shapeFlag Whether to check against the actual pixels of the object
	     *                 (<code>true</code>) or the bounding box
	     *                 (<code>false</code>).
	     * @param maskFlag Whether to check against the object when it is used as mask
	     *                 (<code>false</code>).
	     * @return <code>true</code> if the display object overlaps or intersects
	     *         with the specified point; <code>false</code> otherwise.
	     */
	    DisplayObject.prototype.hitTestPoint = function (x, y, shapeFlag, masksFlag) {
	        if (shapeFlag === void 0) { shapeFlag = false; }
	        if (masksFlag === void 0) { masksFlag = false; }
	        if (!this._pImplicitVisibility)
	            return;
	        if (this._pImplicitMaskId != -1 && !masksFlag)
	            return;
	        if (this._explicitMasks) {
	            var numMasks = this._explicitMasks.length;
	            var maskHit = false;
	            for (var i = 0; i < numMasks; i++) {
	                if (this._explicitMasks[i].hitTestPoint(x, y, shapeFlag, true)) {
	                    maskHit = true;
	                    break;
	                }
	            }
	            if (!maskHit)
	                return false;
	        }
	        return this._hitTestPointInternal(x, y, shapeFlag, masksFlag);
	    };
	    /**
	     * Rotates the 3d object around to face a point defined relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
	     *
	     * @param    target        The vector defining the point to be looked at
	     * @param    upAxis        An optional vector used to define the desired up orientation of the 3d object after rotation has occurred
	     */
	    DisplayObject.prototype.lookAt = function (target, upAxis) {
	        if (upAxis === void 0) { upAxis = null; }
	        var yAxis;
	        var zAxis;
	        var xAxis;
	        var raw;
	        if (upAxis == null)
	            upAxis = Vector3D_1.Vector3D.Y_AXIS;
	        else
	            upAxis.normalize();
	        zAxis = target.subtract(this._transform.position);
	        zAxis.normalize();
	        xAxis = upAxis.crossProduct(zAxis);
	        xAxis.normalize();
	        if (xAxis.length < 0.05) {
	            xAxis.x = upAxis.y;
	            xAxis.y = upAxis.x;
	            xAxis.z = 0;
	            xAxis.normalize();
	        }
	        yAxis = zAxis.crossProduct(xAxis);
	        raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        raw[0] = xAxis.x;
	        raw[1] = xAxis.y;
	        raw[2] = xAxis.z;
	        raw[3] = 0;
	        raw[4] = yAxis.x;
	        raw[5] = yAxis.y;
	        raw[6] = yAxis.z;
	        raw[7] = 0;
	        raw[8] = zAxis.x;
	        raw[9] = zAxis.y;
	        raw[10] = zAxis.z;
	        raw[11] = 0;
	        var m = new Matrix3D_1.Matrix3D();
	        m.copyRawDataFrom(raw);
	        var vec = m.decompose()[1];
	        this.rotationX = vec.x * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	        this.rotationY = vec.y * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	        this.rotationZ = vec.z * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	    };
	    /**
	     * Converts the <code>point</code> object from the display object's(local)
	     * coordinates to the Scene(global) coordinates.
	     *
	     * <p>This method allows you to convert any given <i>x</i> and <i>y</i>
	     * coordinates from values that are relative to the origin(0,0) of a
	     * specific display object(local coordinates) to values that are relative to
	     * the origin of the Scene(global coordinates).</p>
	     *
	     * <p>To use this method, first create an instance of the Point class. The
	     * <i>x</i> and <i>y</i> values that you assign represent local coordinates
	     * because they relate to the origin of the display object.</p>
	     *
	     * <p>You then pass the Point instance that you created as the parameter to
	     * the <code>localToGlobal()</code> method. The method returns a new Point
	     * object with <i>x</i> and <i>y</i> values that relate to the origin of the
	     * Scene instead of the origin of the display object.</p>
	     *
	     * @param point The name or identifier of a point created with the Point
	     *              class, specifying the <i>x</i> and <i>y</i> coordinates as
	     *              properties.
	     * @return A Point object with coordinates relative to the Scene.
	     */
	    DisplayObject.prototype.localToGlobal = function (point, target) {
	        if (target === void 0) { target = null; }
	        this._tempVector3D.setTo(point.x, point.y, 0);
	        var pos = this.sceneTransform.transformVector(this._tempVector3D, this._tempVector3D);
	        if (!target)
	            target = new Point_1.Point();
	        target.x = pos.x;
	        target.y = pos.y;
	        return target;
	    };
	    /**
	     * Converts a three-dimensional point of the three-dimensional display
	     * object's(local) coordinates to a three-dimensional point in the Scene
	     * (global) coordinates.
	     *
	     * <p>This method allows you to convert any given <i>x</i>, <i>y</i> and
	     * <i>z</i> coordinates from values that are relative to the origin(0,0,0) of
	     * a specific display object(local coordinates) to values that are relative to
	     * the origin of the Scene(global coordinates).</p>
	     *
	     * <p>To use this method, first create an instance of the Point class. The
	     * <i>x</i> and <i>y</i> values that you assign represent local coordinates
	     * because they relate to the origin of the display object.</p>
	     *
	     * <p>You then pass the Vector3D instance that you created as the parameter to
	     * the <code>localToGlobal3D()</code> method. The method returns a new
	     * Vector3D object with <i>x</i>, <i>y</i> and <i>z</i> values that relate to
	     * the origin of the Scene instead of the origin of the display object.</p>
	     *
	     * @param position A Vector3D object containing either a three-dimensional
	     *                position or the coordinates of the three-dimensional
	     *                display object.
	     * @return A Vector3D object representing a three-dimensional position in
	     *         the Scene.
	     */
	    DisplayObject.prototype.localToGlobal3D = function (position) {
	        return this.sceneTransform.transformVector(position);
	    };
	    /**
	     * Moves the local point around which the object rotates.
	     *
	     * @param    dx        The amount of movement along the local x axis.
	     * @param    dy        The amount of movement along the local y axis.
	     * @param    dz        The amount of movement along the local z axis.
	     */
	    DisplayObject.prototype.movePivot = function (dx, dy, dz) {
	        if (dx == 0 && dy == 0 && dz == 0)
	            return;
	        this._pivot.x += dx;
	        this._pivot.y += dy;
	        this._pivot.z += dz;
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM);
	    };
	    DisplayObject.prototype.reset = function () {
	        this.visible = true;
	        if (this._transform.matrix3D)
	            this._transform.clearMatrix3D();
	        if (this._transform.colorTransform)
	            this._transform.clearColorTransform();
	        //this.name="";
	        this.masks = null;
	        this.maskMode = false;
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.getRenderSceneTransform = function (cameraTransform) {
	        if (this.orientationMode == OrientationMode_1.OrientationMode.CAMERA_PLANE) {
	            var comps = cameraTransform.decompose();
	            var scale = comps[3];
	            comps[0].copyFrom(this.scenePosition);
	            scale.x = this.scaleX;
	            scale.y = this.scaleY;
	            scale.z = this.scaleZ;
	            this._orientationMatrix.recompose(comps);
	            //add in case of pivot
	            if (this._pivot && this.alignmentMode == AlignmentMode_1.AlignmentMode.PIVOT_POINT)
	                this._orientationMatrix.prependTranslation(-this._pivot.x / this.scaleX, -this._pivot.y / this.scaleY, -this._pivot.z / this.scaleZ);
	            return this._orientationMatrix;
	        }
	        return this.sceneTransform;
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype.removeEventListener = function (type, listener) {
	        _super.prototype.removeEventListener.call(this, type, listener);
	        if (this.hasEventListener(type))
	            return;
	        switch (type) {
	            case DisplayObjectEvent_1.DisplayObjectEvent.SCENE_CHANGED:
	                this._listenToSceneChanged = false;
	                break;
	            case DisplayObjectEvent_1.DisplayObjectEvent.SCENETRANSFORM_CHANGED:
	                this._listenToSceneTransformChanged = true;
	                break;
	        }
	    };
	    Object.defineProperty(DisplayObject.prototype, "_iPickingCollision", {
	        /**
	         * @internal
	         */
	        get: function () {
	            if (!this._pickingCollision)
	                this._pickingCollision = new PickingCollision_1.PickingCollision(this);
	            return this._pickingCollision;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @internal
	     */
	    DisplayObject.prototype.iSetParent = function (value) {
	        this._pParent = value;
	        if (value)
	            this._iSetScene(value._pScene, value._pPartition);
	        else
	            this._iSetScene(null, null);
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.ALL);
	    };
	    DisplayObject.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
	        var newPropDirty = (this._hierarchicalPropsDirty ^ propDirty) & propDirty;
	        if (!newPropDirty)
	            return true;
	        this._hierarchicalPropsDirty |= propDirty;
	        if (newPropDirty & HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM) {
	            this._inverseSceneTransformDirty = true;
	            this._scenePositionDirty = true;
	            if (this.isEntity)
	                this.invalidatePartitionBounds();
	            if (this._pParent)
	                this._pParent._pInvalidateBounds();
	            if (this._listenToSceneTransformChanged)
	                this.queueDispatch(this._sceneTransformChanged || (this._sceneTransformChanged = new DisplayObjectEvent_1.DisplayObjectEvent(DisplayObjectEvent_1.DisplayObjectEvent.SCENETRANSFORM_CHANGED, this)));
	        }
	        return false;
	    };
	    /**
	     * @protected
	     */
	    DisplayObject.prototype._iSetScene = function (scene, partition) {
	        var sceneChanged = this._pScene != scene;
	        if (this._pScene) {
	            //unregister object from current scene
	            this._pScene._iUnregisterObject(this);
	            //gc abstraction objects
	            this.clear();
	        }
	        // assign parent partition if _iIsPartition is false
	        this._pPartition = this._iIsPartition ? this : partition;
	        //assign scene
	        if (sceneChanged)
	            this._pScene = scene;
	        if (this._pScene) {
	            //register object with scene
	            this._pScene._iRegisterObject(this);
	        }
	        if (sceneChanged && this._listenToSceneChanged)
	            this.queueDispatch(this._sceneChanged || (this._sceneChanged = new DisplayObjectEvent_1.DisplayObjectEvent(DisplayObjectEvent_1.DisplayObjectEvent.SCENE_CHANGED, this)));
	    };
	    /**
	     * @protected
	     */
	    DisplayObject.prototype.pUpdateSceneTransform = function () {
	        if (this._iController)
	            this._iController.updateController();
	        this._pSceneTransform.copyFrom(this._transform.matrix3D);
	        if (this._pivot) {
	            if (!this._pivotScale)
	                this._pivotScale = new Vector3D_1.Vector3D();
	            this._pivotScale.x = this._pivot.x / this._transform.scale.x;
	            this._pivotScale.y = this._pivot.y / this._transform.scale.y;
	            this._pivotScale.z = this._pivot.z / this._transform.scale.z;
	            this._pSceneTransform.prependTranslation(-this._pivotScale.x, -this._pivotScale.y, -this._pivotScale.z);
	            if (this.alignmentMode != AlignmentMode_1.AlignmentMode.PIVOT_POINT)
	                this._pSceneTransform.appendTranslation(this._pivot.x, this._pivot.y, this._pivot.z);
	        }
	        if (this._pParent && !this._pParent._iIsRoot)
	            this._pSceneTransform.append(this._pParent.sceneTransform);
	        this._matrix3DDirty = false;
	        this._positionDirty = false;
	        this._rotationDirty = false;
	        this._skewDirty = false;
	        this._scaleDirty = false;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM;
	    };
	    /**
	     *
	     */
	    DisplayObject.prototype._iInternalUpdate = function () {
	        if (this._iController)
	            this._iController.update();
	        // Dispatch all queued events.
	        var len = this._queuedEvents.length;
	        for (var i = 0; i < len; ++i)
	            this.dispatchEvent(this._queuedEvents[i]);
	        this._queuedEvents.length = 0;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iIsVisible = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.VISIBLE)
	            this._updateVisible();
	        return this._pImplicitVisibility;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iAssignedMaskId = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.MASK_ID)
	            this._updateMaskId();
	        return this._pImplicitMaskId;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iAssignedMasks = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.MASKS)
	            this._updateMasks();
	        return this._pImplicitMasks;
	    };
	    DisplayObject.prototype._iMasksConfig = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.MASKS)
	            this._updateMasks();
	        return this._pImplicitMaskIds;
	    };
	    DisplayObject.prototype._iAssignedColorTransform = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM)
	            this._updateColorTransform();
	        return this._pImplicitColorTransform;
	    };
	    /**
	     * @internal
	     */
	    DisplayObject.prototype._iIsMouseEnabled = function () {
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.MOUSE_ENABLED)
	            this._updateMouseEnabled();
	        return this._pImplicitMouseEnabled && this._explicitMouseEnabled;
	    };
	    DisplayObject.prototype._acceptTraverser = function (collector) {
	        //nothing to do here
	    };
	    /**
	     * Invalidates the 3D transformation matrix, causing it to be updated upon the next request
	     *
	     * @private
	     */
	    DisplayObject.prototype._onInvalidateMatrix3D = function (event) {
	        if (this._matrix3DDirty)
	            return;
	        this._matrix3DDirty = true;
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM);
	    };
	    /**
	     * @private
	     */
	    DisplayObject.prototype._onInvalidateColorTransform = function (event) {
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM);
	    };
	    DisplayObject.prototype._pInvalidateBounds = function () {
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	        if (this.isEntity)
	            this.invalidatePartitionBounds();
	        if (this._pParent)
	            this._pParent._pInvalidateBounds();
	    };
	    DisplayObject.prototype._pUpdateBoxBounds = function () {
	        this._boxBoundsInvalid = false;
	        if (this._pBoxBounds == null)
	            this._pBoxBounds = new Box_1.Box();
	    };
	    DisplayObject.prototype._pUpdateSphereBounds = function () {
	        this._sphereBoundsInvalid = false;
	        if (this._pSphereBounds == null)
	            this._pSphereBounds = new Sphere_1.Sphere();
	    };
	    DisplayObject.prototype.queueDispatch = function (event) {
	        // Store event to be dispatched later.
	        this._queuedEvents.push(event);
	    };
	    DisplayObject.prototype._setScaleX = function (val) {
	        if (this.scaleX == val)
	            return;
	        this._transform.scale.x = val;
	        this._transform.invalidateMatrix3D();
	    };
	    DisplayObject.prototype._setScaleY = function (val) {
	        if (this.scaleY == val)
	            return;
	        this._transform.scale.y = val;
	        this._transform.invalidateMatrix3D();
	    };
	    DisplayObject.prototype._setScaleZ = function (val) {
	        if (this.scaleZ == val)
	            return;
	        this._transform.scale.z = val;
	        this._transform.invalidateMatrix3D();
	    };
	    DisplayObject.prototype._updateMouseEnabled = function () {
	        this._pImplicitMouseEnabled = (this._pParent) ? this._pParent.mouseChildren && this._pParent._pImplicitMouseEnabled : true;
	        // If there is a parent and this child does not have a picking collider, use its parent's picking collider.
	        if (this._pImplicitMouseEnabled && this._pParent && !this.pickingCollider)
	            this.pickingCollider = this._pParent.pickingCollider;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.HierarchicalProperties.MOUSE_ENABLED;
	    };
	    DisplayObject.prototype._updateVisible = function () {
	        this._pImplicitVisibility = (this._pParent) ? this._explicitVisibility && this._pParent._iIsVisible() : this._explicitVisibility;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.HierarchicalProperties.VISIBLE;
	    };
	    DisplayObject.prototype._updateMaskId = function () {
	        this._pImplicitMaskId = (this._pParent && this._pParent._iAssignedMaskId() != -1) ? this._pParent._iAssignedMaskId() : this._explicitMaskId;
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.HierarchicalProperties.MASK_ID;
	    };
	    DisplayObject.prototype._updateMasks = function () {
	        this._pImplicitMasks = (this._pParent && this._pParent._iAssignedMasks()) ? (this._explicitMasks != null) ? this._pParent._iAssignedMasks().concat([this._explicitMasks]) : this._pParent._iAssignedMasks().concat() : (this._explicitMasks != null) ? [this._explicitMasks] : null;
	        this._pImplicitMaskIds.length = 0;
	        if (this._pImplicitMasks && this._pImplicitMasks.length) {
	            var numLayers = this._pImplicitMasks.length;
	            var numChildren;
	            var implicitChildren;
	            var implicitChildIds;
	            for (var i = 0; i < numLayers; i++) {
	                implicitChildren = this._pImplicitMasks[i];
	                numChildren = implicitChildren.length;
	                implicitChildIds = new Array();
	                for (var j = 0; j < numChildren; j++)
	                    implicitChildIds.push(implicitChildren[j].id);
	                this._pImplicitMaskIds.push(implicitChildIds);
	            }
	        }
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.HierarchicalProperties.MASKS;
	    };
	    DisplayObject.prototype._updateColorTransform = function () {
	        if (!this._pImplicitColorTransform)
	            this._pImplicitColorTransform = new ColorTransform_1.ColorTransform();
	        if (this._inheritColorTransform && this._pParent && this._pParent._iAssignedColorTransform()) {
	            this._pImplicitColorTransform.copyFrom(this._pParent._iAssignedColorTransform());
	            if (this._transform.colorTransform)
	                this._pImplicitColorTransform.prepend(this._transform.colorTransform);
	        }
	        else {
	            if (this._transform.colorTransform)
	                this._pImplicitColorTransform.copyFrom(this._transform.colorTransform);
	            else
	                this._pImplicitColorTransform.clear();
	        }
	        this._hierarchicalPropsDirty ^= HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM;
	    };
	    DisplayObject.prototype._updateMaskMode = function () {
	        if (this.maskMode)
	            this.mouseEnabled = false;
	        this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.MASK_ID);
	    };
	    DisplayObject.prototype.clear = function () {
	        _super.prototype.clear.call(this);
	        var i;
	        this._pImplicitColorTransform = null;
	        this._pImplicitMasks = null;
	    };
	    DisplayObject.prototype.invalidatePartitionBounds = function () {
	        this.dispatchEvent(new DisplayObjectEvent_1.DisplayObjectEvent(DisplayObjectEvent_1.DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS, this));
	    };
	    DisplayObject.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
	        return false;
	    };
	    return DisplayObject;
	}(AssetBase_1.AssetBase));
	exports.DisplayObject = DisplayObject;


/***/ },
/* 114 */
/***/ function(module, exports) {

	"use strict";
	var Sphere = (function () {
	    /**
	     * Create a Sphere with ABCD coefficients
	     */
	    function Sphere(x, y, z, radius) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (radius === void 0) { radius = 0; }
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.radius = radius;
	    }
	    Sphere.prototype.rayIntersection = function (position, direction, targetNormal) {
	        if (this.containsPoint(position))
	            return 0;
	        var px = position.x - this.x, py = position.y - this.y, pz = position.z - this.z;
	        var vx = direction.x, vy = direction.y, vz = direction.z;
	        var rayEntryDistance;
	        var a = vx * vx + vy * vy + vz * vz;
	        var b = 2 * (px * vx + py * vy + pz * vz);
	        var c = px * px + py * py + pz * pz - this.radius * this.radius;
	        var det = b * b - 4 * a * c;
	        if (det >= 0) {
	            var sqrtDet = Math.sqrt(det);
	            rayEntryDistance = (-b - sqrtDet) / (2 * a);
	            if (rayEntryDistance >= 0) {
	                targetNormal.x = px + rayEntryDistance * vx;
	                targetNormal.y = py + rayEntryDistance * vy;
	                targetNormal.z = pz + rayEntryDistance * vz;
	                targetNormal.normalize();
	                return rayEntryDistance;
	            }
	        }
	        // ray misses sphere
	        return -1;
	    };
	    Sphere.prototype.containsPoint = function (position) {
	        var px = position.x - this.x;
	        var py = position.y - this.y;
	        var pz = position.z - this.z;
	        var distance = Math.sqrt(px * px + py * py + pz * pz);
	        return distance <= this.radius;
	    };
	    Sphere.prototype.toString = function () {
	        return "Sphere [x:" + this.x + ", y:" + this.y + ", z:" + this.z + ", radius:" + this.radius + "]";
	    };
	    return Sphere;
	}());
	exports.Sphere = Sphere;


/***/ },
/* 115 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var BoundsType = (function () {
	    function BoundsType() {
	    }
	    /**
	     *
	     */
	    BoundsType.SPHERE = "sphere";
	    /**
	     *
	     */
	    BoundsType.AXIS_ALIGNED_BOX = "axisAlignedBox";
	    /**
	     *
	     */
	    BoundsType.NULL = "null";
	    return BoundsType;
	}());
	exports.BoundsType = BoundsType;


/***/ },
/* 116 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Value object for a picking collision returned by a picking collider. Created as unique objects on display objects
	 *
	 * @see away.base.DisplayObject#pickingCollision
	 * @see away.core.pick.IPickingCollider
	 *
	 * @class away.pick.PickingCollision
	 */
	var PickingCollision = (function () {
	    /**
	     * Creates a new <code>PickingCollision</code> object.
	     *
	     * @param entity The entity to which this collision object belongs.
	     */
	    function PickingCollision(entity) {
	        this.entity = entity;
	    }
	    return PickingCollision;
	}());
	exports.PickingCollision = PickingCollision;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var DisplayObjectEvent = (function (_super) {
	    __extends(DisplayObjectEvent, _super);
	    function DisplayObjectEvent(type, object) {
	        _super.call(this, type);
	        this._object = object;
	    }
	    Object.defineProperty(DisplayObjectEvent.prototype, "object", {
	        get: function () {
	            return this._object;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    DisplayObjectEvent.prototype.clone = function () {
	        return new DisplayObjectEvent(this.type, this._object);
	    };
	    /**
	     *
	     */
	    DisplayObjectEvent.VISIBLITY_UPDATED = "visiblityUpdated";
	    /**
	     *
	     */
	    DisplayObjectEvent.SCENETRANSFORM_CHANGED = "scenetransformChanged";
	    /**
	     *
	     */
	    DisplayObjectEvent.SCENE_CHANGED = "sceneChanged";
	    /**
	     *
	     */
	    DisplayObjectEvent.PARTITION_CHANGED = "partitionChanged";
	    /**
	     *
	     */
	    DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS = "invalidatePartitionBounds";
	    return DisplayObjectEvent;
	}(EventBase_1.EventBase));
	exports.DisplayObjectEvent = DisplayObjectEvent;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	/**
	 * Dispatched to notify changes in a sub geometry object's state.
	 *
	 * @class away.events.RenderableEvent
	 * @see away.core.base.Graphics
	 */
	var RenderableEvent = (function (_super) {
	    __extends(RenderableEvent, _super);
	    /**
	     * Create a new GraphicsEvent
	     * @param type The event type.
	     * @param dataType An optional data type of the vertex data being updated.
	     */
	    function RenderableEvent(type, renderable) {
	        _super.call(this, type);
	        this._renderable = renderable;
	    }
	    Object.defineProperty(RenderableEvent.prototype, "renderable", {
	        /**
	         * The renderobject owner of the renderable owner.
	         */
	        get: function () {
	            return this._renderable;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    RenderableEvent.prototype.clone = function () {
	        return new RenderableEvent(this.type, this._renderable);
	    };
	    /**
	     * Dispatched when a Renderable owners's render object owner has been updated.
	     */
	    RenderableEvent.INVALIDATE_SURFACE = "invalidateRenderable";
	    /**
	     *
	     */
	    RenderableEvent.INVALIDATE_ELEMENTS = "invalidateElements";
	    return RenderableEvent;
	}(EventBase_1.EventBase));
	exports.RenderableEvent = RenderableEvent;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var SurfaceEvent = (function (_super) {
	    __extends(SurfaceEvent, _super);
	    /**
	     * Create a new GraphicsEvent
	     * @param type The event type.
	     * @param dataType An optional data type of the vertex data being updated.
	     */
	    function SurfaceEvent(type, surface) {
	        _super.call(this, type);
	        this._surface = surface;
	    }
	    Object.defineProperty(SurfaceEvent.prototype, "surface", {
	        /**
	         * The surface of the renderable.
	         */
	        get: function () {
	            return this._surface;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    SurfaceEvent.prototype.clone = function () {
	        return new SurfaceEvent(this.type, this._surface);
	    };
	    SurfaceEvent.INVALIDATE_TEXTURE = "invalidateTexture";
	    SurfaceEvent.INVALIDATE_ANIMATION = "invalidateAnimation";
	    SurfaceEvent.INVALIDATE_PASSES = "invalidatePasses";
	    return SurfaceEvent;
	}(EventBase_1.EventBase));
	exports.SurfaceEvent = SurfaceEvent;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Sampler2D_1 = __webpack_require__(121);
	var BitmapImage2D_1 = __webpack_require__(95);
	var BitmapImageCube_1 = __webpack_require__(123);
	var LineElements_1 = __webpack_require__(125);
	var Skybox_1 = __webpack_require__(130);
	var BasicMaterial_1 = __webpack_require__(134);
	var Single2DTexture_1 = __webpack_require__(136);
	var SingleCubeTexture_1 = __webpack_require__(132);
	var Graphic_1 = __webpack_require__(138);
	var DefaultMaterialManager = (function () {
	    function DefaultMaterialManager() {
	    }
	    DefaultMaterialManager.getDefaultMaterial = function (renderable) {
	        if (renderable === void 0) { renderable = null; }
	        if (renderable != null && renderable.isAsset(Graphic_1.Graphic) && renderable.elements.isAsset(LineElements_1.LineElements)) {
	            if (!DefaultMaterialManager._defaultColorMaterial)
	                DefaultMaterialManager.createDefaultColorMaterial();
	            return DefaultMaterialManager._defaultColorMaterial;
	        }
	        if (renderable != null && renderable.isAsset(Skybox_1.Skybox)) {
	            if (!DefaultMaterialManager._defaultCubeTextureMaterial)
	                DefaultMaterialManager.createDefaultCubeTextureMaterial();
	            return DefaultMaterialManager._defaultCubeTextureMaterial;
	        }
	        if (!DefaultMaterialManager._defaultTextureMaterial)
	            DefaultMaterialManager.createDefaultTextureMaterial();
	        return DefaultMaterialManager._defaultTextureMaterial;
	    };
	    DefaultMaterialManager.getDefaultTexture = function (renderable) {
	        if (renderable === void 0) { renderable = null; }
	        if (renderable != null && renderable.isAsset(Skybox_1.Skybox)) {
	            if (!DefaultMaterialManager._defaultCubeTexture)
	                DefaultMaterialManager.createDefaultCubeTexture();
	            return DefaultMaterialManager._defaultCubeTexture;
	        }
	        if (!DefaultMaterialManager._defaultTexture)
	            DefaultMaterialManager.createDefaultTexture();
	        return DefaultMaterialManager._defaultTexture;
	    };
	    DefaultMaterialManager.getDefaultImage2D = function () {
	        if (!DefaultMaterialManager._defaultBitmapImage2D)
	            DefaultMaterialManager.createDefaultImage2D();
	        return DefaultMaterialManager._defaultBitmapImage2D;
	    };
	    DefaultMaterialManager.getDefaultImageCube = function () {
	        if (!DefaultMaterialManager._defaultBitmapImageCube)
	            DefaultMaterialManager.createDefaultImageCube();
	        return DefaultMaterialManager._defaultBitmapImageCube;
	    };
	    DefaultMaterialManager.getDefaultSampler = function () {
	        if (!DefaultMaterialManager._defaultSampler2D)
	            DefaultMaterialManager.createDefaultSampler2D();
	        return DefaultMaterialManager._defaultSampler2D;
	    };
	    DefaultMaterialManager.createDefaultTexture = function () {
	        DefaultMaterialManager._defaultTexture = new Single2DTexture_1.Single2DTexture();
	        DefaultMaterialManager._defaultTexture.name = "defaultTexture";
	    };
	    DefaultMaterialManager.createDefaultCubeTexture = function () {
	        DefaultMaterialManager._defaultCubeTexture = new SingleCubeTexture_1.SingleCubeTexture();
	        DefaultMaterialManager._defaultCubeTexture.name = "defaultCubeTexture";
	    };
	    DefaultMaterialManager.createDefaultImageCube = function () {
	        if (!DefaultMaterialManager._defaultBitmapImage2D)
	            DefaultMaterialManager.createDefaultImage2D();
	        var b = new BitmapImageCube_1.BitmapImageCube(DefaultMaterialManager._defaultBitmapImage2D.width);
	        for (var i = 0; i < 6; i++)
	            b.draw(i, DefaultMaterialManager._defaultBitmapImage2D);
	        DefaultMaterialManager._defaultBitmapImageCube = b;
	    };
	    DefaultMaterialManager.createDefaultImage2D = function () {
	        var b = new BitmapImage2D_1.BitmapImage2D(8, 8, false, 0x000000);
	        //create chekerboard
	        var i, j;
	        for (i = 0; i < 8; i++)
	            for (j = 0; j < 8; j++)
	                if ((j & 1) ^ (i & 1))
	                    b.setPixel(i, j, 0XFFFFFF);
	        DefaultMaterialManager._defaultBitmapImage2D = b;
	    };
	    DefaultMaterialManager.createDefaultTextureMaterial = function () {
	        if (!DefaultMaterialManager._defaultTexture)
	            DefaultMaterialManager.createDefaultTexture();
	        DefaultMaterialManager._defaultTextureMaterial = new BasicMaterial_1.BasicMaterial();
	        DefaultMaterialManager._defaultTextureMaterial.texture = DefaultMaterialManager._defaultTexture;
	        DefaultMaterialManager._defaultTextureMaterial.name = "defaultTextureMaterial";
	    };
	    DefaultMaterialManager.createDefaultCubeTextureMaterial = function () {
	        if (!DefaultMaterialManager._defaultCubeTexture)
	            DefaultMaterialManager.createDefaultCubeTexture();
	        DefaultMaterialManager._defaultCubeTextureMaterial = new BasicMaterial_1.BasicMaterial();
	        DefaultMaterialManager._defaultCubeTextureMaterial.texture = DefaultMaterialManager._defaultCubeTexture;
	        DefaultMaterialManager._defaultCubeTextureMaterial.name = "defaultCubeTextureMaterial";
	    };
	    DefaultMaterialManager.createDefaultColorMaterial = function () {
	        DefaultMaterialManager._defaultColorMaterial = new BasicMaterial_1.BasicMaterial(0xFFFFFF);
	        DefaultMaterialManager._defaultColorMaterial.name = "defaultColorMaterial";
	    };
	    DefaultMaterialManager.createDefaultSampler2D = function () {
	        DefaultMaterialManager._defaultSampler2D = new Sampler2D_1.Sampler2D();
	    };
	    return DefaultMaterialManager;
	}());
	exports.DefaultMaterialManager = DefaultMaterialManager;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SamplerBase_1 = __webpack_require__(122);
	/**
	 * The Sampler2D export class represents display objects that represent bitmap images.
	 * These can be images that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes, or they can be images that you
	 * create with the <code>Sampler2D()</code> constructor.
	 *
	 * <p>The <code>Sampler2D()</code> constructor allows you to create a Sampler2D
	 * object that contains a reference to a Image2D object. After you create a
	 * Sampler2D object, use the <code>addChild()</code> or <code>addChildAt()</code>
	 * method of the parent DisplayObjectContainer instance to place the bitmap on
	 * the display list.</p>
	 *
	 * <p>A Sampler2D object can share its Image2D reference among several Sampler2D
	 * objects, independent of translation or rotation properties. Because you can
	 * create multiple Sampler2D objects that reference the same Image2D object,
	 * multiple texture objects can use the same complex Image2D object without
	 * incurring the memory overhead of a Image2D object for each texture
	 * object instance.</p>
	
	 */
	var Sampler2D = (function (_super) {
	    __extends(Sampler2D, _super);
	    /**
	     *
	     * @param image2D
	     * @param smoothing
	     */
	    function Sampler2D(repeat, smooth, mipmap) {
	        if (repeat === void 0) { repeat = false; }
	        if (smooth === void 0) { smooth = false; }
	        if (mipmap === void 0) { mipmap = false; }
	        _super.call(this, smooth, mipmap);
	        this._repeat = repeat;
	        this._updateRect();
	    }
	    Object.defineProperty(Sampler2D.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Sampler2D.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sampler2D.prototype, "repeat", {
	        /**
	         * Controls whether or not the Sampler2D object is snapped to the nearest pixel.
	         * This value is ignored in the native and HTML5 targets.
	         * The PixelSnapping export class includes possible values:
	         * <ul>
	         *   <li><code>PixelSnapping.NEVER</code> - No pixel snapping occurs.</li>
	         *   <li><code>PixelSnapping.ALWAYS</code> - The image is always snapped to
	         * the nearest pixel, independent of transformation.</li>
	         *   <li><code>PixelSnapping.AUTO</code> - The image is snapped to the
	         * nearest pixel if it is drawn with no rotation or skew and it is drawn at a
	         * scale factor of 99.9% to 100.1%. If these conditions are satisfied, the
	         * bitmap image is drawn at 100% scale, snapped to the nearest pixel.
	         * When targeting Flash Player, this value allows the image to be drawn as fast
	         * as possible using the internal vector renderer.</li>
	         * </ul>
	         */
	        //var pixelSnapping:PixelSnapping;
	        /**
	         * Controls whether or not the bitmap is smoothed when scaled. If
	         * <code>true</code>, the bitmap is smoothed when scaled. If
	         * <code>false</code>, the bitmap is not smoothed when scaled.
	         */
	        /**
	         *
	         */
	        get: function () {
	            return this._repeat;
	        },
	        set: function (value) {
	            if (this._repeat == value)
	                return;
	            this._repeat = value;
	            //TODO: update dependencies
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sampler2D.prototype, "imageRect", {
	        /**
	         *
	         */
	        get: function () {
	            return this._imageRect;
	        },
	        set: function (value) {
	            if (this._imageRect == value)
	                return;
	            this._imageRect = value;
	            this._updateRect();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sampler2D.prototype, "frameRect", {
	        /**
	         *
	         */
	        get: function () {
	            return this._frameRect;
	        },
	        set: function (value) {
	            if (this._frameRect == value)
	                return;
	            this._frameRect = value;
	            this._updateRect();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Sampler2D.prototype._updateRect = function () {
	    };
	    Sampler2D.assetType = "[asset Sampler2D]";
	    return Sampler2D;
	}(SamplerBase_1.SamplerBase));
	exports.Sampler2D = Sampler2D;


/***/ },
/* 122 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	/**
	 *
	 */
	var SamplerBase = (function (_super) {
	    __extends(SamplerBase, _super);
	    /**
	     *
	     */
	    function SamplerBase(smooth, mipmap) {
	        if (smooth === void 0) { smooth = false; }
	        if (mipmap === void 0) { mipmap = false; }
	        _super.call(this);
	        this._smooth = smooth;
	        this._mipmap = mipmap;
	    }
	    Object.defineProperty(SamplerBase.prototype, "smooth", {
	        /**
	         *
	         */
	        get: function () {
	            return this._smooth;
	        },
	        set: function (value) {
	            if (this._smooth == value)
	                return;
	            this._smooth = value;
	            //TODO: update dependencies
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SamplerBase.prototype, "mipmap", {
	        /**
	         *
	         */
	        get: function () {
	            return this._mipmap;
	        },
	        set: function (value) {
	            if (this._mipmap == value)
	                return;
	            this._mipmap = value;
	            //TODO: update dependencies
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SamplerBase;
	}(AssetBase_1.AssetBase));
	exports.SamplerBase = SamplerBase;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImage2D_1 = __webpack_require__(95);
	var ImageCube_1 = __webpack_require__(124);
	var Rectangle_1 = __webpack_require__(57);
	var ColorUtils_1 = __webpack_require__(28);
	var BitmapImageUtils_1 = __webpack_require__(99);
	/**
	 * The BitmapImage2D export class lets you work with the data(pixels) of a Bitmap
	 * object. You can use the methods of the BitmapImage2D export class to create
	 * arbitrarily sized transparent or opaque bitmap images and manipulate them
	 * in various ways at runtime. You can also access the BitmapImage2D for a bitmap
	 * image that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes.
	 *
	 * <p>This export class lets you separate bitmap rendering operations from the
	 * internal display updating routines of flash. By manipulating a
	 * BitmapImage2D object directly, you can create complex images without incurring
	 * the per-frame overhead of constantly redrawing the content from vector
	 * data.</p>
	 *
	 * <p>The methods of the BitmapImage2D export class support effects that are not
	 * available through the filters available to non-bitmap display objects.</p>
	 *
	 * <p>A BitmapImage2D object contains an array of pixel data. This data can
	 * represent either a fully opaque bitmap or a transparent bitmap that
	 * contains alpha channel data. Either type of BitmapImage2D object is stored as
	 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
	 * of a single pixel in the bitmap.</p>
	 *
	 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
	 * 0 to 255) that describe the alpha transparency and the red, green, and blue
	 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
	 * represents the alpha channel value, followed by red, green, and blue.)</p>
	 *
	 * <p>The four channels(alpha, red, green, and blue) are represented as
	 * numbers when you use them with the <code>BitmapImage2D.copyChannel()</code>
	 * method or the <code>DisplacementMapFilter.componentX</code> and
	 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
	 * are represented by the following constants in the BitmapImage2DChannel
	 * class:</p>
	 *
	 * <ul>
	 *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	 *   <li><code>BitmapImage2DChannel.RED</code></li>
	 *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	 *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	 * </ul>
	 *
	 * <p>You can attach BitmapImage2D objects to a Bitmap object by using the
	 * <code>bitmapData</code> property of the Bitmap object.</p>
	 *
	 * <p>You can use a BitmapImage2D object to fill a Graphics object by using the
	 * <code>Graphics.beginBitmapFill()</code> method.</p>
	 *
	 * <p>You can also use a BitmapImage2D object to perform batch tile rendering
	 * using the <code>flash.display.Tilesheet</code> class.</p>
	 *
	 * <p>In Flash Player 10, the maximum size for a BitmapImage2D object
	 * is 8,191 pixels in width or height, and the total number of pixels cannot
	 * exceed 16,777,215 pixels.(So, if a BitmapImage2D object is 8,191 pixels wide,
	 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation
	 * is 2,880 pixels in height and 2,880 in width.</p>
	 */
	var BitmapImageCube = (function (_super) {
	    __extends(BitmapImageCube, _super);
	    /**
	     * Creates a BitmapImage2D object with a specified width and height. If you
	     * specify a value for the <code>fillColor</code> parameter, every pixel in
	     * the bitmap is set to that color.
	     *
	     * <p>By default, the bitmap is created as transparent, unless you pass
	     * the value <code>false</code> for the transparent parameter. After you
	     * create an opaque bitmap, you cannot change it to a transparent bitmap.
	     * Every pixel in an opaque bitmap uses only 24 bits of color channel
	     * information. If you define the bitmap as transparent, every pixel uses 32
	     * bits of color channel information, including an alpha transparency
	     * channel.</p>
	     *
	     * @param width       The width of the bitmap image in pixels.
	     * @param height      The height of the bitmap image in pixels.
	     * @param transparent Specifies whether the bitmap image supports per-pixel
	     *                    transparency. The default value is <code>true</code>
	     *                    (transparent). To create a fully transparent bitmap,
	     *                    set the value of the <code>transparent</code>
	     *                    parameter to <code>true</code> and the value of the
	     *                    <code>fillColor</code> parameter to 0x00000000(or to
	     *                    0). Setting the <code>transparent</code> property to
	     *                    <code>false</code> can result in minor improvements
	     *                    in rendering performance.
	     * @param fillColor   A 32-bit ARGB color value that you use to fill the
	     *                    bitmap image area. The default value is
	     *                    0xFFFFFFFF(solid white).
	     */
	    function BitmapImageCube(size, transparent, fillColor) {
	        if (transparent === void 0) { transparent = true; }
	        if (fillColor === void 0) { fillColor = null; }
	        _super.call(this, size);
	        this._imageCanvas = new Array(6);
	        this._context = new Array(6);
	        this._imageData = new Array(6);
	        this._locked = false;
	        this._transparent = transparent;
	        for (var i = 0; i < 6; i++) {
	            this._imageCanvas[i] = document.createElement("canvas");
	            this._imageCanvas[i].width = size;
	            this._imageCanvas[i].height = size;
	            this._context[i] = this._imageCanvas[i].getContext("2d");
	            if (fillColor != null)
	                this.fillRect(i, new Rectangle_1.Rectangle(0, 0, size, size), fillColor);
	        }
	    }
	    Object.defineProperty(BitmapImageCube.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return BitmapImageCube.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapImageCube.prototype, "transparent", {
	        /**
	         * Defines whether the bitmap image supports per-pixel transparency. You can
	         * set this value only when you construct a BitmapImage2D object by passing in
	         * <code>true</code> for the <code>transparent</code> parameter of the
	         * constructor. Then, after you create a BitmapImage2D object, you can check
	         * whether it supports per-pixel transparency by determining if the value of
	         * the <code>transparent</code> property is <code>true</code>.
	         */
	        get: function () {
	            return this._transparent;
	        },
	        set: function (value) {
	            this._transparent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new BitmapImage2D object that is a clone of the original instance
	     * with an exact copy of the contained bitmap.
	     *
	     * @return A new BitmapImage2D object that is identical to the original.
	     */
	    BitmapImageCube.prototype.clone = function () {
	        var t = new BitmapImageCube(this._size, this.transparent);
	        for (var i = 0; i < 6; i++) {
	            t.draw(i, this.getCanvas(i));
	        }
	        return t;
	    };
	    /**
	     * Adjusts the color values in a specified area of a bitmap image by using a
	     * <code>ColorTransform</code> object. If the rectangle matches the
	     * boundaries of the bitmap image, this method transforms the color values of
	     * the entire image.
	     *
	     * @param rect           A Rectangle object that defines the area of the
	     *                       image in which the ColorTransform object is applied.
	     * @param colorTransform A ColorTransform object that describes the color
	     *                       transformation values to apply.
	     */
	    BitmapImageCube.prototype.colorTransform = function (side, rect, colorTransform) {
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var data = this._imageData[side].data;
	        var i, j, index;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                index = (i + rect.x + (j + rect.y) * this._size) * 4;
	                data[index] = data[index] * colorTransform.redMultiplier + colorTransform.redOffset;
	                data[index + 1] = data[index + 1] * colorTransform.greenMultiplier + colorTransform.greenOffset;
	                data[index + 2] = data[index + 2] * colorTransform.blueMultiplier + colorTransform.blueOffset;
	                data[index + 3] = data[index + 3] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Transfers data from one channel of another BitmapImage2D object or the
	     * current BitmapImage2D object into a channel of the current BitmapImage2D object.
	     * All of the data in the other channels in the destination BitmapImage2D object
	     * are preserved.
	     *
	     * <p>The source channel value and destination channel value can be one of
	     * following values: </p>
	     *
	     * <ul>
	     *   <li><code>BitmapImage2DChannel.RED</code></li>
	     *   <li><code>BitmapImage2DChannel.GREEN</code></li>
	     *   <li><code>BitmapImage2DChannel.BLUE</code></li>
	     *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
	     * </ul>
	     *
	     * @param sourceBitmapImage2D The input bitmap image to use. The source image
	     *                         can be a different BitmapImage2D object or it can
	     *                         refer to the current BitmapImage2D object.
	     * @param sourceRect       The source Rectangle object. To copy only channel
	     *                         data from a smaller area within the bitmap,
	     *                         specify a source rectangle that is smaller than
	     *                         the overall size of the BitmapImage2D object.
	     * @param destPoint        The destination Point object that represents the
	     *                         upper-left corner of the rectangular area where
	     *                         the new channel data is placed. To copy only
	     *                         channel data from one area to a different area in
	     *                         the destination image, specify a point other than
	     *                        (0,0).
	     * @param sourceChannel    The source channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @param destChannel      The destination channel. Use a value from the
	     *                         BitmapImage2DChannel class
	     *                        (<code>BitmapImage2DChannel.RED</code>,
	     *                         <code>BitmapImage2DChannel.BLUE</code>,
	     *                         <code>BitmapImage2DChannel.GREEN</code>,
	     *                         <code>BitmapImage2DChannel.ALPHA</code>).
	     * @throws TypeError The sourceBitmapImage2D, sourceRect or destPoint are null.
	     */
	    BitmapImageCube.prototype.copyChannel = function (side, sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
	        var imageData = sourceBitmap.getImageData();
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var sourceData = sourceBitmap.getImageData().data;
	        var destData = this._imageData[side].data;
	        var sourceOffset = Math.round(Math.log(sourceChannel) / Math.log(2));
	        var destOffset = Math.round(Math.log(destChannel) / Math.log(2));
	        var i, j, sourceIndex, destIndex;
	        for (i = 0; i < sourceRect.width; ++i) {
	            for (j = 0; j < sourceRect.height; ++j) {
	                sourceIndex = (i + sourceRect.x + (j + sourceRect.y) * sourceBitmap.width) * 4;
	                destIndex = (i + destPoint.x + (j + destPoint.y) * this._size) * 4;
	                destData[destIndex + destOffset] = sourceData[sourceIndex + sourceOffset];
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    BitmapImageCube.prototype.copyPixels = function (side, source, sourceRect, destRect) {
	        if (source instanceof BitmapImage2D_1.BitmapImage2D)
	            source = source.getCanvas();
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) draw object
	            //      3) read _imageData back out
	            this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
	            BitmapImageUtils_1.BitmapImageUtils._copyPixels(this._context[side], source, sourceRect, destRect);
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        }
	        else {
	            BitmapImageUtils_1.BitmapImageUtils._copyPixels(this._context[side], source, sourceRect, destRect);
	        }
	        this.invalidate();
	    };
	    /**
	     * Frees memory that is used to store the BitmapImage2D object.
	     *
	     * <p>When the <code>dispose()</code> method is called on an image, the width
	     * and height of the image are set to 0. All subsequent calls to methods or
	     * properties of this BitmapImage2D instance fail, and an exception is thrown.
	     * </p>
	     *
	     * <p><code>BitmapImage2D.dispose()</code> releases the memory occupied by the
	     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
	     * memory). After using <code>BitmapImage2D.dispose()</code>, the BitmapImage2D
	     * object is no longer usable and an exception may be thrown if
	     * you call functions on the BitmapImage2D object. However,
	     * <code>BitmapImage2D.dispose()</code> does not garbage collect the BitmapImage2D
	     * object(approximately 128 bytes); the memory occupied by the actual
	     * BitmapImage2D object is released at the time the BitmapImage2D object is
	     * collected by the garbage collector.</p>
	     *
	     */
	    BitmapImageCube.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        for (var i = 0; i < 6; i++) {
	            this._context[i] = null;
	            this._imageCanvas[i] = null;
	            this._imageData[i] = null;
	        }
	        this._transparent = null;
	        this._locked = null;
	    };
	    BitmapImageCube.prototype.draw = function (side, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
	        if (source instanceof BitmapImage2D_1.BitmapImage2D)
	            source = source.getCanvas();
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) draw object
	            //      3) read _imageData back out
	            this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
	            BitmapImageUtils_1.BitmapImageUtils._draw(this._context[side], source, matrix, colorTransform, blendMode, clipRect, smoothing);
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        }
	        else {
	            BitmapImageUtils_1.BitmapImageUtils._draw(this._context[side], source, matrix, colorTransform, blendMode, clipRect, smoothing);
	        }
	        this.invalidate();
	    };
	    /**
	     * Fills a rectangular area of pixels with a specified ARGB color.
	     *
	     * @param rect  The rectangular area to fill.
	     * @param color The ARGB color value that fills the area. ARGB colors are
	     *              often specified in hexadecimal format; for example,
	     *              0xFF336699.
	     * @throws TypeError The rect is null.
	     */
	    BitmapImageCube.prototype.fillRect = function (side, rect, color) {
	        if (this._locked) {
	            // If canvas is locked:
	            //
	            //      1) copy image data back to canvas
	            //      2) apply fill
	            //      3) read _imageData back out
	            if (this._imageData[side])
	                this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
	            BitmapImageUtils_1.BitmapImageUtils._fillRect(this._context[side], rect, color, this._transparent);
	            if (this._imageData[side])
	                this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        }
	        else {
	            BitmapImageUtils_1.BitmapImageUtils._fillRect(this._context[side], rect, color, this._transparent);
	        }
	        this.invalidate();
	    };
	    /**
	     * Returns an integer that represents an RGB pixel value from a BitmapImage2D
	     * object at a specific point(<i>x</i>, <i>y</i>). The
	     * <code>getPixel()</code> method returns an unmultiplied pixel value. No
	     * alpha information is returned.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number that represents an RGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, the
	     *         method returns 0.
	     */
	    BitmapImageCube.prototype.getPixel = function (side, x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context[side].getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            var index = (x + y * this._size) * 4;
	            r = this._imageData[side].data[index + 0];
	            g = this._imageData[side].data[index + 1];
	            b = this._imageData[side].data[index + 2];
	            a = this._imageData[side].data[index + 3];
	        }
	        //returns black if fully transparent
	        if (!a)
	            return 0x0;
	        return (r << 16) | (g << 8) | b;
	    };
	    /**
	     * Returns an ARGB color value that contains alpha channel data and RGB data.
	     * This method is similar to the <code>getPixel()</code> method, which
	     * returns an RGB color without alpha channel data.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * @param x The <i>x</i> position of the pixel.
	     * @param y The <i>y</i> position of the pixel.
	     * @return A number representing an ARGB pixel value. If the(<i>x</i>,
	     *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
	     *         returned.
	     */
	    BitmapImageCube.prototype.getPixel32 = function (side, x, y) {
	        var r;
	        var g;
	        var b;
	        var a;
	        if (!this._locked) {
	            var pixelData = this._context[side].getImageData(x, y, 1, 1);
	            r = pixelData.data[0];
	            g = pixelData.data[1];
	            b = pixelData.data[2];
	            a = pixelData.data[3];
	        }
	        else {
	            var index = (x + y * this._size) * 4;
	            r = this._imageData[side].data[index + 0];
	            g = this._imageData[side].data[index + 1];
	            b = this._imageData[side].data[index + 2];
	            a = this._imageData[side].data[index + 3];
	        }
	        return (a << 24) | (r << 16) | (g << 8) | b;
	    };
	    /**
	     * Locks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are not updated when this BitmapImage2D object
	     * changes. To improve performance, use this method along with the
	     * <code>unlock()</code> method before and after numerous calls to the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method.
	     *
	     */
	    BitmapImageCube.prototype.lock = function () {
	        if (this._locked)
	            return;
	        this._locked = true;
	        for (var i = 0; i < 6; i++)
	            this._imageData[i] = this._context[i].getImageData(0, 0, this._size, this._size);
	    };
	    /**
	     * Converts an Array into a rectangular region of pixel data. For each pixel,
	     * an Array element is read and written into the BitmapImage2D pixel. The data
	     * in the Array is expected to be 32-bit ARGB pixel values.
	     *
	     * @param rect        Specifies the rectangular region of the BitmapImage2D
	     *                    object.
	     * @param inputArray  An Array that consists of 32-bit unmultiplied pixel
	     *                    values to be used in the rectangular region.
	     * @throws RangeError The vector array is not large enough to read all the
	     *                    pixel data.
	     */
	    BitmapImageCube.prototype.setArray = function (side, rect, inputArray) {
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var i, j, index, argb;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                argb = ColorUtils_1.ColorUtils.float32ColorToARGB(inputArray[i + j * rect.width]);
	                index = (i + rect.x + (j + rect.y) * this._size) * 4;
	                this._imageData[side].data[index + 0] = argb[1];
	                this._imageData[side].data[index + 1] = argb[2];
	                this._imageData[side].data[index + 2] = argb[3];
	                this._imageData[side].data[index + 3] = argb[0];
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Sets a single pixel of a BitmapImage2D object. The current alpha channel
	     * value of the image pixel is preserved during this operation. The value of
	     * the RGB color parameter is treated as an unmultiplied color value.
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting RGB color for the pixel.
	     */
	    BitmapImageCube.prototype.setPixel = function (side, x, y, color) {
	        var argb = ColorUtils_1.ColorUtils.float32ColorToARGB(color);
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var index = (x + y * this._size) * 4;
	        this._imageData[side].data[index + 0] = argb[1];
	        this._imageData[side].data[index + 1] = argb[2];
	        this._imageData[side].data[index + 2] = argb[3];
	        this._imageData[side].data[index + 3] = 255;
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Sets the color and alpha transparency values of a single pixel of a
	     * BitmapImage2D object. This method is similar to the <code>setPixel()</code>
	     * method; the main difference is that the <code>setPixel32()</code> method
	     * takes an ARGB color value that contains alpha channel information.
	     *
	     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
	     * values. A premultiplied image pixel has the red, green, and blue color
	     * channel values already multiplied by the alpha data. For example, if the
	     * alpha value is 0, the values for the RGB channels are also 0, independent
	     * of their unmultiplied values. This loss of data can cause some problems
	     * when you perform operations. All BitmapImage2D methods take and return
	     * unmultiplied values. The internal pixel representation is converted from
	     * premultiplied to unmultiplied before it is returned as a value. During a
	     * set operation, the pixel value is premultiplied before the raw image pixel
	     * is set.</p>
	     *
	     * <p><b>Note:</b> To increase performance, when you use the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
	     * call the <code>lock()</code> method before you call the
	     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
	     * the <code>unlock()</code> method when you have made all pixel changes.
	     * This process prevents objects that reference this BitmapImage2D instance from
	     * updating until you finish making the pixel changes.</p>
	     *
	     * @param x     The <i>x</i> position of the pixel whose value changes.
	     * @param y     The <i>y</i> position of the pixel whose value changes.
	     * @param color The resulting ARGB color for the pixel. If the bitmap is
	     *              opaque(not transparent), the alpha transparency portion of
	     *              this color value is ignored.
	     */
	    BitmapImageCube.prototype.setPixel32 = function (side, x, y, color) {
	        var argb = ColorUtils_1.ColorUtils.float32ColorToARGB(color);
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        var index = (x + y * this._size) * 4;
	        this._imageData[side].data[index + 0] = argb[1];
	        this._imageData[side].data[index + 1] = argb[2];
	        this._imageData[side].data[index + 2] = argb[3];
	        this._imageData[side].data[index + 3] = argb[0];
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Converts a byte array into a rectangular region of pixel data. For each
	     * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
	     * the return value is written into the pixel. If the byte array ends before
	     * the full rectangle is written, the function returns. The data in the byte
	     * array is expected to be 32-bit ARGB pixel values. No seeking is performed
	     * on the byte array before or after the pixels are read.
	     *
	     * @param rect           Specifies the rectangular region of the BitmapImage2D
	     *                       object.
	     * @param inputByteArray A ByteArray object that consists of 32-bit
	     *                       unmultiplied pixel values to be used in the
	     *                       rectangular region.
	     * @throws EOFError  The <code>inputByteArray</code> object does not include
	     *                   enough data to fill the area of the <code>rect</code>
	     *                   rectangle. The method fills as many pixels as possible
	     *                   before throwing the exception.
	     * @throws TypeError The rect or inputByteArray are null.
	     */
	    BitmapImageCube.prototype.setPixels = function (side, rect, inputByteArray) {
	        if (!this._locked)
	            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
	        inputByteArray.position = 0;
	        var i, j, index;
	        for (i = 0; i < rect.width; ++i) {
	            for (j = 0; j < rect.height; ++j) {
	                index = (i + rect.x + (j + rect.y) * this._size) * 4;
	                this._imageData[side].data[index + 0] = inputByteArray.readUnsignedInt();
	                this._imageData[side].data[index + 1] = inputByteArray.readUnsignedInt();
	                this._imageData[side].data[index + 2] = inputByteArray.readUnsignedInt();
	                this._imageData[side].data[index + 3] = inputByteArray.readUnsignedInt();
	            }
	        }
	        if (!this._locked) {
	            this._context[side].putImageData(this._imageData[side], 0, 0);
	            this._imageData[side] = null;
	        }
	        this.invalidate();
	    };
	    /**
	     * Unlocks an image so that any objects that reference the BitmapImage2D object,
	     * such as Bitmap objects, are updated when this BitmapImage2D object changes.
	     * To improve performance, use this method along with the <code>lock()</code>
	     * method before and after numerous calls to the <code>setPixel()</code> or
	     * <code>setPixel32()</code> method.
	     *
	     * @param changeRect The area of the BitmapImage2D object that has changed. If
	     *                   you do not specify a value for this parameter, the
	     *                   entire area of the BitmapImage2D object is considered
	     *                   changed.
	     */
	    BitmapImageCube.prototype.unlock = function () {
	        if (!this._locked)
	            return;
	        this._locked = false;
	        for (var i = 0; i < 6; i++) {
	            this._context[i].putImageData(this._imageData[i], 0, 0); // at coords 0,0
	            this._imageData[i] = null;
	        }
	    };
	    /**
	     *
	     * @returns {ImageData}
	     */
	    BitmapImageCube.prototype.getImageData = function (side) {
	        if (!this._locked)
	            return this._context[side].getImageData(0, 0, this._size, this._size);
	        return this._imageData[side];
	    };
	    /**
	     *
	     * @returns {HTMLCanvasElement}
	     */
	    BitmapImageCube.prototype.getCanvas = function (side) {
	        return this._imageCanvas[side];
	    };
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    BitmapImageCube.prototype._setSize = function (size) {
	        _super.prototype._setSize.call(this, size);
	        for (var i = 0; i < 6; i++) {
	            if (this._locked)
	                this._context[i].putImageData(this._imageData[i], 0, 0);
	            this._imageCanvas[i].width = size;
	            this._imageCanvas[i].height = size;
	            if (this._locked)
	                this._imageData[i] = this._context[i].getImageData(0, 0, this._size, this._size);
	        }
	    };
	    BitmapImageCube.assetType = "[image BitmapImageCube]";
	    BitmapImageCube.posX = 0;
	    BitmapImageCube.negX = 1;
	    BitmapImageCube.posY = 2;
	    BitmapImageCube.negY = 3;
	    BitmapImageCube.posZ = 4;
	    BitmapImageCube.negZ = 5;
	    return BitmapImageCube;
	}(ImageCube_1.ImageCube));
	exports.BitmapImageCube = BitmapImageCube;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ImageBase_1 = __webpack_require__(97);
	var ImageUtils_1 = __webpack_require__(98);
	var ImageCube = (function (_super) {
	    __extends(ImageCube, _super);
	    /**
	     *
	     */
	    function ImageCube(size) {
	        _super.call(this);
	        this._size = size;
	        this._testDimensions();
	    }
	    Object.defineProperty(ImageCube.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return ImageCube.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ImageCube.prototype, "size", {
	        /**
	         * The size of the cube bitmap in pixels.
	         */
	        get: function () {
	            return this._size;
	        },
	        set: function (value) {
	            if (this._size == value)
	                return;
	            this._setSize(this._size);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    ImageCube.prototype._setSize = function (size) {
	        if (this._size != size)
	            this.clear();
	        this._size = size;
	        this._testDimensions();
	    };
	    /**
	     *
	     * @private
	     */
	    ImageCube.prototype._testDimensions = function () {
	        if (!ImageUtils_1.ImageUtils.isDimensionValid(this._size))
	            throw new Error("Invalid dimension: Width and height must be power of 2 and cannot exceed 2048");
	    };
	    ImageCube.assetType = "[image ImageCube]";
	    return ImageCube;
	}(ImageBase_1.ImageBase));
	exports.ImageCube = ImageCube;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Byte4Attributes_1 = __webpack_require__(12);
	var Float1Attributes_1 = __webpack_require__(13);
	var ElementsBase_1 = __webpack_require__(126);
	var ElementsUtils_1 = __webpack_require__(128);
	/**
	 * @class LineElements
	 */
	var LineElements = (function (_super) {
	    __extends(LineElements, _super);
	    /**
	     *
	     */
	    function LineElements(concatenatedBuffer) {
	        if (concatenatedBuffer === void 0) { concatenatedBuffer = null; }
	        _super.call(this, concatenatedBuffer);
	        this._positions = new AttributesView_1.AttributesView(Float32Array, 6, concatenatedBuffer);
	    }
	    Object.defineProperty(LineElements.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return LineElements.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineElements.prototype, "positions", {
	        /**
	         *
	         */
	        get: function () {
	            return this._positions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineElements.prototype, "thickness", {
	        /**
	         *
	         */
	        get: function () {
	            return this._thickness;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineElements.prototype, "colors", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._colors)
	                this.setColors(this._colors);
	            return this._colors;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LineElements.prototype.getBoxBounds = function (target) {
	        if (target === void 0) { target = null; }
	        //TODO bounding calculations for lines
	        return target;
	    };
	    LineElements.prototype.getSphereBounds = function (center, target) {
	        if (target === void 0) { target = null; }
	        //TODO bounding calculations for lines
	        return target;
	    };
	    LineElements.prototype.setPositions = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values instanceof AttributesView_1.AttributesView) {
	            this.clearVertices(this._positions);
	            this._positions = values;
	        }
	        else if (values) {
	            var i = 0;
	            var j = 0;
	            var index = 0;
	            var positions = new Float32Array(values.length * 4);
	            var indices = new Uint16Array(values.length);
	            while (i < values.length) {
	                if (index / 6 & 1) {
	                    positions[index] = values[i + 3];
	                    positions[index + 1] = values[i + 4];
	                    positions[index + 2] = values[i + 5];
	                    positions[index + 3] = values[i];
	                    positions[index + 4] = values[i + 1];
	                    positions[index + 5] = values[i + 2];
	                }
	                else {
	                    positions[index] = values[i];
	                    positions[index + 1] = values[i + 1];
	                    positions[index + 2] = values[i + 2];
	                    positions[index + 3] = values[i + 3];
	                    positions[index + 4] = values[i + 4];
	                    positions[index + 5] = values[i + 5];
	                }
	                index += 6;
	                if (++j == 4) {
	                    var o = index / 6 - 4;
	                    indices.set([o, o + 1, o + 2, o + 3, o + 2, o + 1], i);
	                    j = 0;
	                    i += 6;
	                }
	            }
	            this._positions.set(positions, offset * 4);
	            this.setIndices(indices, offset);
	        }
	        else {
	            this.clearVertices(this._positions);
	            this._positions = new AttributesView_1.AttributesView(Float32Array, 6, this._concatenatedBuffer);
	        }
	        this._numVertices = this._positions.count;
	        this.invalidateVertices(this._positions);
	        this._verticesDirty[this._positions.id] = false;
	    };
	    LineElements.prototype.setThickness = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values instanceof Float1Attributes_1.Float1Attributes) {
	            this._thickness = values;
	        }
	        else if (values) {
	            if (!this._thickness)
	                this._thickness = new Float1Attributes_1.Float1Attributes(this._concatenatedBuffer);
	            var i = 0;
	            var j = 0;
	            var index = 0;
	            var thickness = new Float32Array(values.length * 4);
	            while (i < values.length) {
	                thickness[index] = (Math.floor(0.5 * index + 0.5) & 1) ? -values[i] : values[i];
	                if (++j == 4) {
	                    j = 0;
	                    i++;
	                }
	                index++;
	            }
	            this._thickness.set(thickness, offset * 4);
	        }
	        else if (this._thickness) {
	            this._thickness.dispose();
	            this._thickness = null;
	        }
	        this.invalidateVertices(this._thickness);
	        this._verticesDirty[this._thickness.id] = false;
	    };
	    LineElements.prototype.setColors = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values) {
	            if (values == this._colors)
	                return;
	            if (values instanceof Byte4Attributes_1.Byte4Attributes) {
	                this.clearVertices(this._colors);
	                this._colors = values;
	            }
	            else {
	                if (!this._colors)
	                    this._colors = new Byte4Attributes_1.Byte4Attributes(this._concatenatedBuffer);
	                var i = 0;
	                var j = 0;
	                var index = 0;
	                var colors = new Uint8Array(values.length * 4);
	                while (i < values.length) {
	                    if (index / 4 & 1) {
	                        colors[index] = values[i + 4];
	                        colors[index + 1] = values[i + 5];
	                        colors[index + 2] = values[i + 6];
	                        colors[index + 3] = values[i + 7];
	                    }
	                    else {
	                        colors[index] = values[i];
	                        colors[index + 1] = values[i + 1];
	                        colors[index + 2] = values[i + 2];
	                        colors[index + 3] = values[i + 3];
	                    }
	                    if (++j == 4) {
	                        j = 0;
	                        i += 8;
	                    }
	                    index += 4;
	                }
	                this._colors.set(colors, offset * 4);
	            }
	        }
	        else {
	            //auto-derive colors
	            this._colors = ElementsUtils_1.ElementsUtils.generateColors(this.indices, this._colors, this._concatenatedBuffer, this._numVertices);
	        }
	        this.invalidateVertices(this._colors);
	        this._verticesDirty[this._colors.id] = false;
	    };
	    /**
	     *
	     */
	    LineElements.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this._positions.dispose();
	        this._positions = null;
	        this._thickness.dispose();
	        this._thickness = null;
	        this._colors.dispose();
	        this._colors = null;
	    };
	    /**
	     * Clones the current object
	     * @return An exact duplicate of the current object.
	     */
	    LineElements.prototype.clone = function () {
	        var clone = new LineElements(this._concatenatedBuffer ? this._concatenatedBuffer.clone() : null);
	        clone.setIndices(this.indices.clone());
	        clone.setPositions(this._positions.clone());
	        clone.setThickness(this._thickness.clone());
	        clone.setColors(this._colors.clone());
	        return clone;
	    };
	    LineElements.prototype._iTestCollision = function (pickingCollider, material, pickingCollision, count, offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        return pickingCollider.testLineCollision(this, material, pickingCollision, count || this._numVertices, offset);
	    };
	    LineElements.assetType = "[asset LineElements]";
	    return LineElements;
	}(ElementsBase_1.ElementsBase));
	exports.LineElements = LineElements;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Float3Attributes_1 = __webpack_require__(15);
	var Short3Attributes_1 = __webpack_require__(18);
	var AbstractMethodError_1 = __webpack_require__(7);
	var AssetBase_1 = __webpack_require__(6);
	var ElementsEvent_1 = __webpack_require__(127);
	/**
	 * @class away.base.TriangleElements
	 */
	var ElementsBase = (function (_super) {
	    __extends(ElementsBase, _super);
	    /**
	     *
	     */
	    function ElementsBase(concatenatedBuffer) {
	        if (concatenatedBuffer === void 0) { concatenatedBuffer = null; }
	        _super.call(this);
	        this._customAttributesNames = new Array();
	        this._customAttributes = new Object();
	        this._numElements = 0;
	        this._numVertices = 0;
	        this._verticesDirty = new Object();
	        this._invalidateVertices = new Object();
	        this._concatenatedBuffer = concatenatedBuffer;
	    }
	    Object.defineProperty(ElementsBase.prototype, "concatenatedBuffer", {
	        get: function () {
	            return this._concatenatedBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ElementsBase.prototype, "indices", {
	        /**
	         * The raw index data that define the faces.
	         */
	        get: function () {
	            return this._indices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    ElementsBase.prototype.getCustomAtributesNames = function () {
	        return this._customAttributesNames;
	    };
	    /**
	     *
	     */
	    ElementsBase.prototype.getCustomAtributes = function (name) {
	        return this._customAttributes[name];
	    };
	    Object.defineProperty(ElementsBase.prototype, "numElements", {
	        /**
	         * The total amount of triangles in the TriangleElements.
	         */
	        get: function () {
	            return this._numElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ElementsBase.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ElementsBase.prototype.copyTo = function (elements) {
	        if (this.indices)
	            elements.setIndices(this.indices.clone());
	        for (var name in this._customAttributes)
	            elements.setCustomAttributes(name, this.getCustomAtributes(name).clone());
	    };
	    /**
	     *
	     */
	    ElementsBase.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        if (this._indices) {
	            this._indices.dispose();
	            this._indices = null;
	        }
	        for (var name in this._customAttributes) {
	            this._customAttributes[name].dispose();
	            delete this._customAttributes;
	        }
	    };
	    ElementsBase.prototype.setIndices = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values instanceof Short3Attributes_1.Short3Attributes) {
	            if (this._indices)
	                this.clearIndices();
	            this._indices = values;
	        }
	        else if (values) {
	            if (!this._indices)
	                this._indices = new Short3Attributes_1.Short3Attributes();
	            this._indices.set(values, offset);
	        }
	        else if (this._indices) {
	            this._indices.dispose();
	            this._indices = null;
	            this.clearIndices();
	        }
	        if (this._indices) {
	            this._numElements = this._indices.count;
	            this.invalidateIndices();
	        }
	        else {
	            this._numElements = 0;
	        }
	    };
	    ElementsBase.prototype.setCustomAttributes = function (name, values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._customAttributes[name])
	            return;
	        if (values instanceof AttributesView_1.AttributesView) {
	            this.clearVertices(this._customAttributes[name]);
	            this._customAttributes[name] = values;
	        }
	        else if (values) {
	            if (!this._customAttributes[name])
	                this._customAttributes[name] = new Float3Attributes_1.Float3Attributes(this._concatenatedBuffer); //default custom atrributes is Float3
	            this._customAttributes[name].set(values, offset);
	        }
	        else if (this._customAttributes[name]) {
	            this.clearVertices(this._customAttributes[name]);
	            this._customAttributesNames.splice(this._customAttributesNames.indexOf(name), 1);
	            delete this._customAttributes[name];
	            return;
	        }
	        this.invalidateVertices(this._customAttributes[name]);
	        this._verticesDirty[this._customAttributes[name].id] = false;
	        if (this._customAttributesNames.indexOf(name) == -1)
	            this._customAttributesNames.push(name);
	    };
	    /**
	     * Clones the current object
	     * @return An exact duplicate of the current object.
	     */
	    ElementsBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ElementsBase.prototype.applyTransformation = function (transform, count, offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Scales the geometry.
	     * @param scale The amount by which to scale.
	     */
	    ElementsBase.prototype.scale = function (scale, count, offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ElementsBase.prototype.scaleUV = function (scaleU, scaleV, count, offset) {
	        if (scaleU === void 0) { scaleU = 1; }
	        if (scaleV === void 0) { scaleV = 1; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ElementsBase.prototype.getBoxBounds = function (target, count, offset, idx_count, idx_offset) {
	        if (target === void 0) { target = null; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ElementsBase.prototype.getSphereBounds = function (center, target, count, offset) {
	        if (target === void 0) { target = null; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ElementsBase.prototype.hitTestPoint = function (x, y, z, box, count, offset, idx_count, idx_offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ElementsBase.prototype.invalidateIndices = function () {
	        if (!this._invalidateIndices)
	            this._invalidateIndices = new ElementsEvent_1.ElementsEvent(ElementsEvent_1.ElementsEvent.INVALIDATE_INDICES, this._indices);
	        this.dispatchEvent(this._invalidateIndices);
	    };
	    ElementsBase.prototype.clearIndices = function () {
	        this.dispatchEvent(new ElementsEvent_1.ElementsEvent(ElementsEvent_1.ElementsEvent.CLEAR_INDICES, this._indices));
	    };
	    ElementsBase.prototype.invalidateVertices = function (attributesView) {
	        if (!attributesView || this._verticesDirty[attributesView.id])
	            return;
	        this._verticesDirty[attributesView.id] = true;
	        if (!this._invalidateVertices[attributesView.id])
	            this._invalidateVertices[attributesView.id] = new ElementsEvent_1.ElementsEvent(ElementsEvent_1.ElementsEvent.INVALIDATE_VERTICES, attributesView);
	        this.dispatchEvent(this._invalidateVertices[attributesView.id]);
	    };
	    ElementsBase.prototype.clearVertices = function (attributesView) {
	        if (!attributesView)
	            return;
	        attributesView.dispose();
	        this.dispatchEvent(new ElementsEvent_1.ElementsEvent(ElementsEvent_1.ElementsEvent.CLEAR_VERTICES, attributesView));
	        this._verticesDirty[attributesView.id] = null;
	        this._invalidateVertices[attributesView.id] = null;
	    };
	    ElementsBase.prototype._iTestCollision = function (pickingCollider, material, pickingCollision, count, offset, idx_count, idx_offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    return ElementsBase;
	}(AssetBase_1.AssetBase));
	exports.ElementsBase = ElementsBase;


/***/ },
/* 127 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	/**
	 * Dispatched to notify changes in a sub geometry object's state.
	 *
	 * @class away.events.ElementsEvent
	 * @see away.core.base.Graphics
	 */
	var ElementsEvent = (function (_super) {
	    __extends(ElementsEvent, _super);
	    /**
	     * Create a new GraphicsEvent
	     * @param type The event type.
	     * @param attributesView An optional data type of the vertex data being updated.
	     */
	    function ElementsEvent(type, attributesView) {
	        _super.call(this, type);
	        this._attributesView = attributesView;
	    }
	    Object.defineProperty(ElementsEvent.prototype, "attributesView", {
	        /**
	         * The attributes view of the vertex data.
	         */
	        get: function () {
	            return this._attributesView;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    ElementsEvent.prototype.clone = function () {
	        return new ElementsEvent(this.type, this._attributesView);
	    };
	    /**
	     * Dispatched when a Elements's index data has been updated.
	     */
	    ElementsEvent.INVALIDATE_INDICES = "invalidateIndices";
	    /**
	     * Dispatched when a Elements's index data has been disposed.
	     */
	    ElementsEvent.CLEAR_INDICES = "clearIndices";
	    /**
	     * Dispatched when a Elements's vertex data has been updated.
	     */
	    ElementsEvent.INVALIDATE_VERTICES = "invalidateVertices";
	    /**
	     * Dispatched when a Elements's vertex data has been disposed.
	     */
	    ElementsEvent.CLEAR_VERTICES = "clearVertices";
	    return ElementsEvent;
	}(EventBase_1.EventBase));
	exports.ElementsEvent = ElementsEvent;


/***/ },
/* 128 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AttributesBuffer_1 = __webpack_require__(5);
	var Float3Attributes_1 = __webpack_require__(15);
	var Float4Attributes_1 = __webpack_require__(16);
	var Byte4Attributes_1 = __webpack_require__(12);
	var Vector3D_1 = __webpack_require__(34);
	var Box_1 = __webpack_require__(33);
	var Sphere_1 = __webpack_require__(114);
	var HitTestCache_1 = __webpack_require__(129);
	var ElementsUtils = (function () {
	    function ElementsUtils() {
	    }
	    ElementsUtils.generateFaceNormals = function (indexAttributes, positionAttributes, faceNormalAttributes, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var indices = indexAttributes.get(count, offset);
	        var positions = positionAttributes.get(positionAttributes.count);
	        if (faceNormalAttributes == null)
	            faceNormalAttributes = new Float4Attributes_1.Float4Attributes(count + offset);
	        else if (faceNormalAttributes.count < count + offset)
	            faceNormalAttributes.count = count + offset;
	        var indexDim = indexAttributes.stride;
	        var posDim = positionAttributes.dimensions;
	        var posStride = positionAttributes.stride;
	        var faceNormals = faceNormalAttributes.get(count, offset);
	        var len = count * indexDim;
	        var i = 0;
	        var j = 0;
	        var index;
	        var x1, x2, x3;
	        var y1, y2, y3;
	        var z1, z2, z3;
	        var dx1, dy1, dz1;
	        var dx2, dy2, dz2;
	        var cx, cy, cz;
	        var d;
	        if (posDim == 3) {
	            for (i = 0; i < len; i += indexDim) {
	                index = indices[i] * posStride;
	                x1 = positions[index];
	                y1 = positions[index + 1];
	                z1 = positions[index + 2];
	                index = indices[i + 1] * posStride;
	                x2 = positions[index];
	                y2 = positions[index + 1];
	                z2 = positions[index + 2];
	                index = indices[i + 2] * posStride;
	                x3 = positions[index];
	                y3 = positions[index + 1];
	                z3 = positions[index + 2];
	                dx1 = x3 - x1;
	                dy1 = y3 - y1;
	                dz1 = z3 - z1;
	                dx2 = x2 - x1;
	                dy2 = y2 - y1;
	                dz2 = z2 - z1;
	                cx = dz1 * dy2 - dy1 * dz2;
	                cy = dx1 * dz2 - dz1 * dx2;
	                cz = dy1 * dx2 - dx1 * dy2;
	                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
	                // length of cross product = 2*triangle area
	                faceNormals[j++] = cx;
	                faceNormals[j++] = cy;
	                faceNormals[j++] = cz;
	                faceNormals[j++] = d;
	            }
	        }
	        else if (posDim == 2) {
	            for (i = 0; i < len; i += indexDim) {
	                faceNormals[j++] = 0;
	                faceNormals[j++] = 0;
	                faceNormals[j++] = 1;
	                faceNormals[j++] = 1;
	            }
	        }
	        return faceNormalAttributes;
	    };
	    ElementsUtils.generateNormals = function (indexAttributes, faceNormalAttributes, normalAttributes, concatenatedBuffer) {
	        var indices = indexAttributes.get(indexAttributes.count);
	        var faceNormals = faceNormalAttributes.get(faceNormalAttributes.count);
	        if (normalAttributes == null)
	            normalAttributes = new Float3Attributes_1.Float3Attributes(concatenatedBuffer);
	        var indexDim = indexAttributes.dimensions;
	        var normalStride = normalAttributes.stride;
	        var normals = normalAttributes.get(normalAttributes.count);
	        var i;
	        var len = normalAttributes.count * normalStride;
	        //clear normal values
	        for (i = 0; i < len; i += normalStride) {
	            normals[i] = 0;
	            normals[i + 1] = 0;
	            normals[i + 2] = 0;
	        }
	        len = indexAttributes.count * indexDim;
	        var index;
	        var f1 = 0;
	        var f2 = 1;
	        var f3 = 2;
	        //collect face normals
	        for (i = 0; i < len; i += indexDim) {
	            index = indices[i] * normalStride;
	            normals[index] += faceNormals[f1];
	            normals[index + 1] += faceNormals[f2];
	            normals[index + 2] += faceNormals[f3];
	            index = indices[i + 1] * normalStride;
	            normals[index] += faceNormals[f1];
	            normals[index + 1] += faceNormals[f2];
	            normals[index + 2] += faceNormals[f3];
	            index = indices[i + 2] * normalStride;
	            normals[index] += faceNormals[f1];
	            normals[index + 1] += faceNormals[f2];
	            normals[index + 2] += faceNormals[f3];
	            f1 += 4;
	            f2 += 4;
	            f3 += 4;
	        }
	        len = normalAttributes.count * normalStride;
	        var vx;
	        var vy;
	        var vz;
	        var d;
	        //normalise normals collections
	        for (i = 0; i < len; i += normalStride) {
	            vx = normals[i];
	            vy = normals[i + 1];
	            vz = normals[i + 2];
	            d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
	            normals[i] = vx * d;
	            normals[i + 1] = vy * d;
	            normals[i + 2] = vz * d;
	        }
	        return normalAttributes;
	    };
	    ElementsUtils.generateFaceTangents = function (indexAttributes, positionAttributes, uvAttributes, faceTangentAttributes, count, offset, useFaceWeights) {
	        if (offset === void 0) { offset = 0; }
	        if (useFaceWeights === void 0) { useFaceWeights = false; }
	        var indices = indexAttributes.get(count, offset);
	        var positions = positionAttributes.get(positionAttributes.count);
	        var uvs = uvAttributes.get(uvAttributes.count);
	        if (faceTangentAttributes == null)
	            faceTangentAttributes = new Float4Attributes_1.Float4Attributes(count + offset);
	        else if (faceTangentAttributes.count < count + offset)
	            faceTangentAttributes.count = count + offset;
	        var indexDim = indexAttributes.dimensions;
	        var posDim = positionAttributes.dimensions;
	        var posStride = positionAttributes.stride;
	        var uvStride = uvAttributes.stride;
	        var faceTangents = faceTangentAttributes.get(count, offset);
	        var i = 0;
	        var index1;
	        var index2;
	        var index3;
	        var v0;
	        var v1;
	        var v2;
	        var dv1;
	        var dv2;
	        var denom;
	        var x0, y0, z0;
	        var dx1, dy1, dz1;
	        var dx2, dy2, dz2;
	        var cx, cy, cz;
	        //multiply by dimension to get index length
	        var len = count * indexDim;
	        for (i = 0; i < len; i += indexDim) {
	            index1 = indices[i];
	            index2 = indices[i + 1];
	            index3 = indices[i + 2];
	            v0 = uvs[index1 * uvStride + 1];
	            dv1 = uvs[index2 * uvStride + 1] - v0;
	            dv2 = uvs[index3 * uvStride + 1] - v0;
	            v0 = index1 * posStride;
	            v1 = index2 * posStride;
	            v2 = index3 * posStride;
	            x0 = positions[v0];
	            dx1 = positions[v1] - x0;
	            dx2 = positions[v2] - x0;
	            cx = dv2 * dx1 - dv1 * dx2;
	            y0 = positions[v0 + 1];
	            dy1 = positions[v1 + 1] - y0;
	            dy2 = positions[v2 + 1] - y0;
	            cy = dv2 * dy1 - dv1 * dy2;
	            if (posDim == 3) {
	                z0 = positions[v0 + 2];
	                dz1 = positions[v1 + 2] - z0;
	                dz2 = positions[v2 + 2] - z0;
	                cz = dv2 * dz1 - dv1 * dz2;
	            }
	            else {
	                cz = 0;
	            }
	            denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
	            faceTangents[i] = denom * cx;
	            faceTangents[i + 1] = denom * cy;
	            faceTangents[i + 2] = denom * cz;
	        }
	        return faceTangentAttributes;
	    };
	    ElementsUtils.generateTangents = function (indexAttributes, faceTangentAttributes, faceNormalAttributes, tangentAttributes, concatenatedBuffer) {
	        var indices = indexAttributes.get(indexAttributes.count);
	        var faceTangents = faceTangentAttributes.get(faceTangentAttributes.count);
	        var faceNormals = faceNormalAttributes.get(faceNormalAttributes.count);
	        if (tangentAttributes == null)
	            tangentAttributes = new Float3Attributes_1.Float3Attributes(concatenatedBuffer);
	        var indexDim = indexAttributes.dimensions;
	        var tangentStride = tangentAttributes.stride;
	        var tangents = tangentAttributes.get(tangentAttributes.count);
	        var i;
	        var len = tangentAttributes.count * tangentStride;
	        //clear tangent values
	        for (i = 0; i < len; i += tangentStride) {
	            tangents[i] = 0;
	            tangents[i + 1] = 0;
	            tangents[i + 2] = 0;
	        }
	        var weight;
	        var index;
	        var f1 = 0;
	        var f2 = 1;
	        var f3 = 2;
	        var f4 = 3;
	        len = indexAttributes.count * indexDim;
	        //collect face tangents
	        for (i = 0; i < len; i += indexDim) {
	            weight = faceNormals[f4];
	            index = indices[i] * tangentStride;
	            tangents[index++] += faceTangents[f1] * weight;
	            tangents[index++] += faceTangents[f2] * weight;
	            tangents[index] += faceTangents[f3] * weight;
	            index = indices[i + 1] * tangentStride;
	            tangents[index++] += faceTangents[f1] * weight;
	            tangents[index++] += faceTangents[f2] * weight;
	            tangents[index] += faceTangents[f3] * weight;
	            index = indices[i + 2] * tangentStride;
	            tangents[index++] += faceTangents[f1] * weight;
	            tangents[index++] += faceTangents[f2] * weight;
	            tangents[index] += faceTangents[f3] * weight;
	            f1 += 3;
	            f2 += 3;
	            f3 += 3;
	            f4 += 4;
	        }
	        var vx;
	        var vy;
	        var vz;
	        var d;
	        //normalise tangents collections
	        for (i = 0; i < len; i += tangentStride) {
	            vx = tangents[i];
	            vy = tangents[i + 1];
	            vz = tangents[i + 2];
	            d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
	            tangents[i] = vx * d;
	            tangents[i + 1] = vy * d;
	            tangents[i + 2] = vz * d;
	        }
	        return tangentAttributes;
	    };
	    ElementsUtils.generateColors = function (indexAttributes, colorAttributes, concatenatedBuffer, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (colorAttributes == null)
	            colorAttributes = new Byte4Attributes_1.Byte4Attributes(concatenatedBuffer);
	        if (colorAttributes.count < count + offset)
	            colorAttributes.count = count + offset;
	        var colors = colorAttributes.get(count, offset);
	        var colorStride = colorAttributes.stride;
	        var len = colorAttributes.count * colorStride;
	        for (var i = 0; i < len; i += colorStride) {
	            colors[i] = 0xFF;
	            colors[i + 1] = 0xFF;
	            colors[i + 2] = 0xFF;
	            colors[i + 3] = 0xFF;
	        }
	        return colorAttributes;
	    };
	    ElementsUtils.scale = function (scaleA, scaleB, scaleC, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (output.count < count + offset)
	            output.count = count + offset;
	        var scaleArray = new Float32Array([scaleA, scaleB, scaleC]);
	        var values = output.get(count, offset);
	        var outputStride = output.stride;
	        var outputDim = output.dimensions;
	        var i;
	        var j;
	        var len = count * outputStride;
	        for (i = 0; i < len; i += outputStride)
	            for (j = 0; j < outputDim; j++)
	                values[i + j] *= scaleArray[j];
	        output.invalidate();
	    };
	    ElementsUtils.applyTransformation = function (transform, positionAttributes, normalAttributes, tangentAttributes, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        //todo: make this compatible with 2-dimensional positions
	        var positions = positionAttributes.get(count, offset);
	        var positionStride = positionAttributes.stride;
	        var normals;
	        var normalStride;
	        if (normalAttributes) {
	            normals = normalAttributes.get(count, offset);
	            normalStride = normalAttributes.stride;
	        }
	        var tangents;
	        var tangentStride;
	        if (tangentAttributes) {
	            tangents = tangentAttributes.get(count, offset);
	            tangentStride = tangentAttributes.stride;
	        }
	        var i;
	        var i1;
	        var i2;
	        var vector = new Vector3D_1.Vector3D();
	        var invTranspose;
	        if (normalAttributes || tangentAttributes) {
	            invTranspose = transform.clone();
	            invTranspose.invert();
	            invTranspose.transpose();
	        }
	        var vi0 = 0;
	        var ni0 = 0;
	        var ti0 = 0;
	        for (i = 0; i < count; ++i) {
	            // bake position
	            i1 = vi0 + 1;
	            i2 = vi0 + 2;
	            vector.x = positions[vi0];
	            vector.y = positions[i1];
	            vector.z = positions[i2];
	            vector = transform.transformVector(vector);
	            positions[vi0] = vector.x;
	            positions[i1] = vector.y;
	            positions[i2] = vector.z;
	            vi0 += positionStride;
	            if (normals) {
	                // bake normal
	                i1 = ni0 + 1;
	                i2 = ni0 + 2;
	                vector.x = normals[ni0];
	                vector.y = normals[i1];
	                vector.z = normals[i2];
	                vector = invTranspose.deltaTransformVector(vector);
	                vector.normalize();
	                normals[ni0] = vector.x;
	                normals[i1] = vector.y;
	                normals[i2] = vector.z;
	                ni0 += normalStride;
	            }
	            if (tangents) {
	                // bake tangent
	                i1 = ti0 + 1;
	                i2 = ti0 + 2;
	                vector.x = tangents[ti0];
	                vector.y = tangents[i1];
	                vector.z = tangents[i2];
	                vector = invTranspose.deltaTransformVector(vector);
	                vector.normalize();
	                tangents[ti0] = vector.x;
	                tangents[i1] = vector.y;
	                tangents[i2] = vector.z;
	                ti0 += tangentStride;
	            }
	        }
	        positionAttributes.invalidate();
	        if (normalAttributes)
	            normalAttributes.invalidate();
	        if (tangentAttributes)
	            tangentAttributes.invalidate();
	    };
	    ElementsUtils.getSubIndices = function (indexAttributes, numVertices, indexMappings, indexOffset) {
	        if (indexOffset === void 0) { indexOffset = 0; }
	        var buffer = indexAttributes.attributesBuffer;
	        var numIndices = indexAttributes.length;
	        //reset mappings
	        indexMappings.length = 0;
	        //shortcut for those buffers that fit into the maximum buffer sizes
	        if (numIndices < ElementsUtils.LIMIT_INDICES && numVertices < ElementsUtils.LIMIT_VERTS)
	            return buffer;
	        var i;
	        var indices = indexAttributes.get(indexAttributes.count, indexOffset);
	        var splitIndices = new Array();
	        var indexSwap = ElementsUtils._indexSwap;
	        indexSwap.length = numIndices;
	        for (i = 0; i < numIndices; i++)
	            indexSwap[i] = -1;
	        var originalIndex;
	        var splitIndex;
	        var index = 0;
	        var offsetLength = indexOffset * indexAttributes.dimensions;
	        // Loop over all triangles
	        i = 0;
	        while (i < numIndices + offsetLength && i + 1 < ElementsUtils.LIMIT_INDICES && index + 1 < ElementsUtils.LIMIT_VERTS) {
	            originalIndex = indices[i];
	            if (indexSwap[originalIndex] >= 0) {
	                splitIndex = indexSwap[originalIndex];
	            }
	            else {
	                // This vertex does not yet exist in the split list and
	                // needs to be copied from the long list.
	                splitIndex = index++;
	                indexSwap[originalIndex] = splitIndex;
	                indexMappings[splitIndex] = originalIndex;
	            }
	            // Store new index, which may have come from the swap look-up,
	            // or from copying a new set of vertex data from the original vector
	            splitIndices[i++] = splitIndex;
	        }
	        buffer = new AttributesBuffer_1.AttributesBuffer(indexAttributes.size * indexAttributes.dimensions, splitIndices.length / indexAttributes.dimensions);
	        indexAttributes = indexAttributes.clone(buffer);
	        indexAttributes.set(splitIndices);
	        return buffer;
	    };
	    ElementsUtils.getSubVertices = function (vertexBuffer, indexMappings) {
	        if (!indexMappings.length)
	            return vertexBuffer;
	        var stride = vertexBuffer.stride;
	        var vertices = vertexBuffer.bufferView;
	        var splitVerts = new Uint8Array(indexMappings.length * stride);
	        var splitIndex;
	        var originalIndex;
	        var i = 0;
	        var j = 0;
	        var len = indexMappings.length;
	        for (i = 0; i < len; i++) {
	            splitIndex = i * stride;
	            originalIndex = indexMappings[i] * stride;
	            for (j = 0; j < stride; j++)
	                splitVerts[splitIndex + j] = vertices[originalIndex + j];
	        }
	        vertexBuffer = new AttributesBuffer_1.AttributesBuffer(stride, len);
	        vertexBuffer.bufferView = splitVerts;
	        return vertexBuffer;
	    };
	    //TODO - generate this dyanamically based on num tris
	    ElementsUtils.hitTestTriangleElements = function (x, y, z, box, triangleElements, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var positionAttributes = triangleElements.positions;
	        var curveAttributes = triangleElements.getCustomAtributes("curves");
	        var posStride = positionAttributes.stride;
	        var curveStride = curveAttributes ? curveAttributes.stride : null;
	        var positions = positionAttributes.get(count, offset);
	        var curves = curveAttributes ? curveAttributes.get(count, offset) : null;
	        var id0;
	        var id1;
	        var id2;
	        var ax;
	        var ay;
	        var bx;
	        var by;
	        var cx;
	        var cy;
	        var hitTestCache = triangleElements.hitTestCache[offset] || (triangleElements.hitTestCache[offset] = new HitTestCache_1.HitTestCache());
	        var index = hitTestCache.lastCollisionIndex;
	        if (index != -1 && index < count) {
	            precheck: {
	                id0 = index + 2;
	                id1 = index + 1;
	                id2 = index + 0;
	                ax = positions[id0 * posStride];
	                ay = positions[id0 * posStride + 1];
	                bx = positions[id1 * posStride];
	                by = positions[id1 * posStride + 1];
	                cx = positions[id2 * posStride];
	                cy = positions[id2 * posStride + 1];
	                //console.log(ax, ay, bx, by, cx, cy);
	                //from a to p
	                var dx = ax - x;
	                var dy = ay - y;
	                //edge normal (a-b)
	                var nx = by - ay;
	                var ny = -(bx - ax);
	                //console.log(ax,ay,bx,by,cx,cy);
	                var dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                dx = bx - x;
	                dy = by - y;
	                nx = cy - by;
	                ny = -(cx - bx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                dx = cx - x;
	                dy = cy - y;
	                nx = ay - cy;
	                ny = -(ax - cx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                if (curves) {
	                    //check if not solid
	                    if (curves[id0 * curveStride + 2] != -128) {
	                        var v0x = bx - ax;
	                        var v0y = by - ay;
	                        var v1x = cx - ax;
	                        var v1y = cy - ay;
	                        var v2x = x - ax;
	                        var v2y = y - ay;
	                        var den = v0x * v1y - v1x * v0y;
	                        var v = (v2x * v1y - v1x * v2y) / den;
	                        var w = (v0x * v2y - v2x * v0y) / den;
	                        //var u:number = 1 - v - w;	//commented out as inlined away
	                        //here be dragons
	                        var uu = 0.5 * v + w;
	                        var vv = w;
	                        var d = uu * uu - vv;
	                        var az = curves[id0 * curveStride];
	                        if (d > 0 && az == -128) {
	                            break precheck;
	                        }
	                        else if (d < 0 && az == 127) {
	                            break precheck;
	                        }
	                    }
	                }
	                return true;
	            }
	        }
	        //hard coded min vertex count to bother using a grid for
	        if (count > 150) {
	            var cells = hitTestCache.cells;
	            var divisions = cells.length ? hitTestCache.divisions : (hitTestCache.divisions = Math.min(Math.ceil(Math.sqrt(count)), 32));
	            var conversionX = divisions / box.width;
	            var conversionY = divisions / box.height;
	            var minx = box.x;
	            var miny = box.y;
	            if (!cells.length) {
	                //now we have bounds start creating grid cells and filling
	                cells.length = divisions * divisions;
	                for (var k = 0; k < count; k += 3) {
	                    id0 = k + 2;
	                    id1 = k + 1;
	                    id2 = k + 0;
	                    ax = positions[id0 * posStride];
	                    ay = positions[id0 * posStride + 1];
	                    bx = positions[id1 * posStride];
	                    by = positions[id1 * posStride + 1];
	                    cx = positions[id2 * posStride];
	                    cy = positions[id2 * posStride + 1];
	                    //subtractions to push into positive space
	                    var min_index_x = Math.floor((Math.min(ax, bx, cx) - minx) * conversionX);
	                    var min_index_y = Math.floor((Math.min(ay, by, cy) - miny) * conversionY);
	                    var max_index_x = Math.floor((Math.max(ax, bx, cx) - minx) * conversionX);
	                    var max_index_y = Math.floor((Math.max(ay, by, cy) - miny) * conversionY);
	                    for (var i = min_index_x; i <= max_index_x; i++) {
	                        for (var j = min_index_y; j <= max_index_y; j++) {
	                            var index = i + j * divisions;
	                            var nodes = cells[index] || (cells[index] = new Array());
	                            //push in the triangle ids
	                            nodes.push(id0, id1, id2);
	                        }
	                    }
	                }
	            }
	            var index_x = Math.floor((x - minx) * conversionX);
	            var index_y = Math.floor((y - miny) * conversionY);
	            if ((index_x < 0 || index_x > divisions || index_y < 0 || index_y > divisions))
	                return false;
	            var nodes = cells[index_x + index_y * divisions];
	            if (nodes == null)
	                return false;
	            var nodeCount = nodes.length;
	            for (var k = 0; k < nodeCount; k += 3) {
	                id2 = nodes[k + 2];
	                if (id2 == index)
	                    continue;
	                id1 = nodes[k + 1];
	                id0 = nodes[k];
	                ax = positions[id0 * posStride];
	                ay = positions[id0 * posStride + 1];
	                bx = positions[id1 * posStride];
	                by = positions[id1 * posStride + 1];
	                cx = positions[id2 * posStride];
	                cy = positions[id2 * posStride + 1];
	                //from a to p
	                var dx = ax - x;
	                var dy = ay - y;
	                //edge normal (a-b)
	                var nx = by - ay;
	                var ny = -(bx - ax);
	                var dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                dx = bx - x;
	                dy = by - y;
	                nx = cy - by;
	                ny = -(cx - bx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                dx = cx - x;
	                dy = cy - y;
	                nx = ay - cy;
	                ny = -(ax - cx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                if (curves) {
	                    //check if not solid
	                    if (curves[id0 * curveStride + 2] != -128) {
	                        var v0x = bx - ax;
	                        var v0y = by - ay;
	                        var v1x = cx - ax;
	                        var v1y = cy - ay;
	                        var v2x = x - ax;
	                        var v2y = y - ay;
	                        var den = v0x * v1y - v1x * v0y;
	                        var v = (v2x * v1y - v1x * v2y) / den;
	                        var w = (v0x * v2y - v2x * v0y) / den;
	                        //var u:number = 1 - v - w;	//commented out as inlined away
	                        //here be dragons
	                        var uu = 0.5 * v + w;
	                        var vv = w;
	                        var d = uu * uu - vv;
	                        var az = curves[id0 * curveStride];
	                        if (d > 0 && az == -128)
	                            continue;
	                        else if (d < 0 && az == 127)
	                            continue;
	                    }
	                }
	                hitTestCache.lastCollisionIndex = id2;
	                return true;
	            }
	            hitTestCache.lastCollisionIndex = -1;
	            return false;
	        }
	        //brute force
	        for (var k = 0; k < count; k += 3) {
	            id2 = k + 0;
	            if (id2 == index)
	                continue;
	            id1 = k + 1;
	            id0 = k + 2;
	            ax = positions[id0 * posStride];
	            ay = positions[id0 * posStride + 1];
	            bx = positions[id1 * posStride];
	            by = positions[id1 * posStride + 1];
	            cx = positions[id2 * posStride];
	            cy = positions[id2 * posStride + 1];
	            //console.log(ax, ay, bx, by, cx, cy);
	            //from a to p
	            var dx = ax - x;
	            var dy = ay - y;
	            //edge normal (a-b)
	            var nx = by - ay;
	            var ny = -(bx - ax);
	            //console.log(ax,ay,bx,by,cx,cy);
	            var dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            dx = bx - x;
	            dy = by - y;
	            nx = cy - by;
	            ny = -(cx - bx);
	            dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            dx = cx - x;
	            dy = cy - y;
	            nx = ay - cy;
	            ny = -(ax - cx);
	            dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            if (curves) {
	                //check if not solid
	                if (curves[id0 * curveStride + 2] != -128) {
	                    var v0x = bx - ax;
	                    var v0y = by - ay;
	                    var v1x = cx - ax;
	                    var v1y = cy - ay;
	                    var v2x = x - ax;
	                    var v2y = y - ay;
	                    var den = v0x * v1y - v1x * v0y;
	                    var v = (v2x * v1y - v1x * v2y) / den;
	                    var w = (v0x * v2y - v2x * v0y) / den;
	                    //var u:number = 1 - v - w;	//commented out as inlined away
	                    //here be dragons
	                    var uu = 0.5 * v + w;
	                    var vv = w;
	                    var d = uu * uu - vv;
	                    var az = curves[id0 * curveStride];
	                    if (d > 0 && az == -128) {
	                        continue;
	                    }
	                    else if (d < 0 && az == 127) {
	                        continue;
	                    }
	                }
	            }
	            hitTestCache.lastCollisionIndex = id2;
	            return true;
	        }
	        hitTestCache.lastCollisionIndex = -1;
	        return false;
	    };
	    ElementsUtils.hitTestTriangleElementsIndices = function (x, y, z, box, triangleElements, idx_count, idx_offset) {
	        if (idx_offset === void 0) { idx_offset = 0; }
	        var positionAttributes = triangleElements.positions;
	        var posStride = positionAttributes.stride;
	        var positions = positionAttributes.get(positionAttributes.count);
	        var indexAttributes = triangleElements.indices;
	        var indices = indexAttributes.get(idx_count, idx_offset);
	        var indexDim = indexAttributes.dimensions;
	        var i = 0;
	        var id0;
	        var id1;
	        var id2;
	        var ax;
	        var ay;
	        var bx;
	        var by;
	        var cx;
	        var cy;
	        var hitTestCache = triangleElements.hitTestCache[idx_offset] || (triangleElements.hitTestCache[idx_offset] = new HitTestCache_1.HitTestCache());
	        var index = hitTestCache.lastCollisionIndex;
	        var len = idx_count * indexDim;
	        if (index != -1 && index < len) {
	            precheck: {
	                id0 = indices[index + 2];
	                id1 = indices[index + 1];
	                id2 = indices[index + 0];
	                ax = positions[id0 * posStride];
	                ay = positions[id0 * posStride + 1];
	                bx = positions[id1 * posStride];
	                by = positions[id1 * posStride + 1];
	                cx = positions[id2 * posStride];
	                cy = positions[id2 * posStride + 1];
	                //from a to p
	                var dx = ax - x;
	                var dy = ay - y;
	                //edge normal (a-b)
	                var nx = by - ay;
	                var ny = -(bx - ax);
	                var dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                dx = bx - x;
	                dy = by - y;
	                nx = cy - by;
	                ny = -(cx - bx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                dx = cx - x;
	                dy = cy - y;
	                nx = ay - cy;
	                ny = -(ax - cx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    break precheck;
	                return true;
	            }
	        }
	        //hard coded min vertex count to bother using a grid for
	        if (len > 150) {
	            var cells = hitTestCache.cells;
	            var divisions = cells.length ? hitTestCache.divisions : (hitTestCache.divisions = Math.min(Math.ceil(Math.sqrt(len)), 32));
	            var conversionX = divisions / box.width;
	            var conversionY = divisions / box.height;
	            var minx = box.x;
	            var miny = box.y;
	            if (!cells.length) {
	                //now we have bounds start creating grid cells and filling
	                cells.length = divisions * divisions;
	                for (var k = 0; k < len; k += indexDim) {
	                    id0 = indices[k + 2];
	                    id1 = indices[k + 1];
	                    id2 = indices[k];
	                    ax = positions[id0 * posStride];
	                    ay = positions[id0 * posStride + 1];
	                    bx = positions[id1 * posStride];
	                    by = positions[id1 * posStride + 1];
	                    cx = positions[id2 * posStride];
	                    cy = positions[id2 * posStride + 1];
	                    //subtractions to push into positive space
	                    var min_index_x = Math.floor((Math.min(ax, bx, cx) - minx) * conversionX);
	                    var min_index_y = Math.floor((Math.min(ay, by, cy) - miny) * conversionY);
	                    var max_index_x = Math.floor((Math.max(ax, bx, cx) - minx) * conversionX);
	                    var max_index_y = Math.floor((Math.max(ay, by, cy) - miny) * conversionY);
	                    for (var i = min_index_x; i <= max_index_x; i++) {
	                        for (var j = min_index_y; j <= max_index_y; j++) {
	                            var index = i + j * divisions;
	                            var nodes = cells[index] || (cells[index] = new Array());
	                            //push in the triangle ids
	                            nodes.push(id0, id1, id2);
	                        }
	                    }
	                }
	            }
	            var index_x = Math.floor((x - minx) * conversionX);
	            var index_y = Math.floor((y - miny) * conversionY);
	            if ((index_x < 0 || index_x > divisions || index_y < 0 || index_y > divisions))
	                return false;
	            var nodes = cells[index_x + index_y * divisions];
	            if (nodes == null)
	                return false;
	            var nodeCount = nodes.length;
	            for (var k = 0; k < nodeCount; k += indexDim) {
	                id2 = nodes[k + 2];
	                if (k + 2 == index)
	                    continue;
	                id1 = nodes[k + 1];
	                id0 = nodes[k];
	                ax = positions[id0 * posStride];
	                ay = positions[id0 * posStride + 1];
	                bx = positions[id1 * posStride];
	                by = positions[id1 * posStride + 1];
	                cx = positions[id2 * posStride];
	                cy = positions[id2 * posStride + 1];
	                //from a to p
	                var dx = ax - x;
	                var dy = ay - y;
	                //edge normal (a-b)
	                var nx = by - ay;
	                var ny = -(bx - ax);
	                var dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                dx = bx - x;
	                dy = by - y;
	                nx = cy - by;
	                ny = -(cx - bx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                dx = cx - x;
	                dy = cy - y;
	                nx = ay - cy;
	                ny = -(ax - cx);
	                dot = (dx * nx) + (dy * ny);
	                if (dot > 0)
	                    continue;
	                hitTestCache.lastCollisionIndex = k;
	                return true;
	            }
	            hitTestCache.lastCollisionIndex = -1;
	            return false;
	        }
	        //brute force
	        for (var k = 0; k < len; k += indexDim) {
	            id2 = indices[k];
	            if (k == index)
	                continue;
	            id1 = indices[k + 1];
	            id0 = indices[k + 2];
	            ax = positions[id0 * posStride];
	            ay = positions[id0 * posStride + 1];
	            bx = positions[id1 * posStride];
	            by = positions[id1 * posStride + 1];
	            cx = positions[id2 * posStride];
	            cy = positions[id2 * posStride + 1];
	            //console.log(ax, ay, bx, by, cx, cy);
	            //from a to p
	            var dx = ax - x;
	            var dy = ay - y;
	            //edge normal (a-b)
	            var nx = by - ay;
	            var ny = -(bx - ax);
	            //console.log(ax,ay,bx,by,cx,cy);
	            var dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            dx = bx - x;
	            dy = by - y;
	            nx = cy - by;
	            ny = -(cx - bx);
	            dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            dx = cx - x;
	            dy = cy - y;
	            nx = ay - cy;
	            ny = -(ax - cx);
	            dot = (dx * nx) + (dy * ny);
	            if (dot > 0)
	                continue;
	            hitTestCache.lastCollisionIndex = k;
	            return true;
	        }
	        hitTestCache.lastCollisionIndex = -1;
	        return false;
	    };
	    ElementsUtils.getTriangleGraphicsBoxBoundsIndices = function (positionAttributes, indexAttributes, output, idx_count, idx_offset) {
	        if (idx_offset === void 0) { idx_offset = 0; }
	        var positions = positionAttributes.get(positionAttributes.count);
	        var posDim = positionAttributes.dimensions;
	        var posStride = positionAttributes.stride;
	        var pos;
	        var minX = 0, minY = 0, minZ = 0;
	        var maxX = 0, maxY = 0, maxZ = 0;
	        var indices = indexAttributes.get(idx_count, idx_offset);
	        var indexDim = indexAttributes.dimensions;
	        var index;
	        var len = idx_count * indexDim;
	        for (var i = 0; i < len; i++) {
	            index = indices[i] * posStride;
	            if (i == 0) {
	                maxX = minX = positions[index];
	                maxY = minY = positions[index + 1];
	                maxZ = minZ = (posDim == 3) ? positions[index + 2] : 0;
	            }
	            else {
	                pos = positions[index];
	                if (pos < minX)
	                    minX = pos;
	                else if (pos > maxX)
	                    maxX = pos;
	                pos = positions[index + 1];
	                if (pos < minY)
	                    minY = pos;
	                else if (pos > maxY)
	                    maxY = pos;
	                if (posDim == 3) {
	                    pos = positions[index + 2];
	                    if (pos < minZ)
	                        minZ = pos;
	                    else if (pos > maxZ)
	                        maxZ = pos;
	                }
	            }
	        }
	        if (output == null)
	            output = new Box_1.Box();
	        output.x = minX;
	        output.y = minY;
	        output.z = minZ;
	        output.right = maxX;
	        output.bottom = maxY;
	        output.back = maxZ;
	        return output;
	    };
	    ElementsUtils.getTriangleGraphicsBoxBounds = function (positionAttributes, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var positions = positionAttributes.get(count, offset);
	        var posDim = positionAttributes.dimensions;
	        var posStride = positionAttributes.stride;
	        var pos;
	        var minX = 0, minY = 0, minZ = 0;
	        var maxX = 0, maxY = 0, maxZ = 0;
	        var len = count * posStride;
	        for (var i = 0; i < len; i += posStride) {
	            if (i == 0) {
	                maxX = minX = positions[i];
	                maxY = minY = positions[i + 1];
	                maxZ = minZ = (posDim == 3) ? positions[i + 2] : 0;
	            }
	            else {
	                pos = positions[i];
	                if (pos < minX)
	                    minX = pos;
	                else if (pos > maxX)
	                    maxX = pos;
	                pos = positions[i + 1];
	                if (pos < minY)
	                    minY = pos;
	                else if (pos > maxY)
	                    maxY = pos;
	                if (posDim == 3) {
	                    pos = positions[i + 2];
	                    if (pos < minZ)
	                        minZ = pos;
	                    else if (pos > maxZ)
	                        maxZ = pos;
	                }
	            }
	        }
	        if (output == null)
	            output = new Box_1.Box();
	        output.x = minX;
	        output.y = minY;
	        output.z = minZ;
	        output.right = maxX;
	        output.bottom = maxY;
	        output.back = maxZ;
	        return output;
	    };
	    ElementsUtils.getTriangleGraphicsSphereBounds = function (positionAttributes, center, output, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var positions = positionAttributes.get(count, offset);
	        var posDim = positionAttributes.dimensions;
	        var posStride = positionAttributes.stride;
	        var maxRadiusSquared = 0;
	        var radiusSquared;
	        var len = count * posStride;
	        var distanceX;
	        var distanceY;
	        var distanceZ;
	        for (var i = 0; i < len; i += posStride) {
	            distanceX = positions[i] - center.x;
	            distanceY = positions[i + 1] - center.y;
	            distanceZ = (posDim == 3) ? positions[i + 2] - center.z : -center.z;
	            radiusSquared = distanceX * distanceX + distanceY * distanceY + distanceZ * distanceZ;
	            if (maxRadiusSquared < radiusSquared)
	                maxRadiusSquared = radiusSquared;
	        }
	        if (output == null)
	            output = new Sphere_1.Sphere();
	        output.x = center.x;
	        output.y = center.y;
	        output.z = center.z;
	        output.radius = Math.sqrt(maxRadiusSquared);
	        return output;
	    };
	    ElementsUtils.tempFloat32x4 = new Float32Array(4);
	    ElementsUtils.LIMIT_VERTS = 0xffff;
	    ElementsUtils.LIMIT_INDICES = 0xffffff;
	    ElementsUtils._indexSwap = new Array();
	    return ElementsUtils;
	}());
	exports.ElementsUtils = ElementsUtils;


/***/ },
/* 129 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.base.HitTestCache
	 */
	var HitTestCache = (function () {
	    function HitTestCache() {
	        /**
	         *
	         */
	        this.cells = new Array();
	        /**
	         *
	         */
	        this.lastCollisionIndex = -1;
	    }
	    return HitTestCache;
	}());
	exports.HitTestCache = HitTestCache;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var BlendMode_1 = __webpack_require__(131);
	var DisplayObject_1 = __webpack_require__(113);
	var BoundsType_1 = __webpack_require__(115);
	var RenderableEvent_1 = __webpack_require__(118);
	var SurfaceEvent_1 = __webpack_require__(119);
	var SingleCubeTexture_1 = __webpack_require__(132);
	var Style_1 = __webpack_require__(24);
	var StyleEvent_1 = __webpack_require__(25);
	/**
	 * A Skybox class is used to render a sky in the scene. It's always considered static and 'at infinity', and as
	 * such it's always centered at the camera's position and sized to exactly fit within the camera's frustum, ensuring
	 * the sky box is always as large as possible without being clipped.
	 */
	var Skybox = (function (_super) {
	    __extends(Skybox, _super);
	    /**
	     * Create a new Skybox object.
	     *
	     * @param material	The material with which to render the Skybox.
	     */
	    function Skybox(image) {
	        var _this = this;
	        if (image === void 0) { image = null; }
	        _super.call(this);
	        this._textures = new Array();
	        this._pAlphaThreshold = 0;
	        this._pBlendMode = BlendMode_1.BlendMode.NORMAL;
	        this._curves = false;
	        this._imageRect = false;
	        this._style = new Style_1.Style();
	        this._onTextureInvalidateDelegate = function (event) { return _this.onTextureInvalidate(event); };
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._style.addEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	        this._pIsEntity = true;
	        this._owners = new Array(this);
	        this._style.image = image;
	        this.texture = new SingleCubeTexture_1.SingleCubeTexture();
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.NULL;
	    }
	    Object.defineProperty(Skybox.prototype, "alphaThreshold", {
	        /**
	         * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
	         * invisible or entirely opaque, often used with textures for foliage, etc.
	         * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
	         */
	        get: function () {
	            return this._pAlphaThreshold;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            else if (value > 1)
	                value = 1;
	            if (this._pAlphaThreshold == value)
	                return;
	            this._pAlphaThreshold = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "curves", {
	        /**
	         * Indicates whether skybox should use curves. Defaults to false.
	         */
	        get: function () {
	            return this._curves;
	        },
	        set: function (value) {
	            if (this._curves == value)
	                return;
	            this._curves = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "imageRect", {
	        /**
	         * Indicates whether or not the Skybox texture should use imageRects. Defaults to false.
	         */
	        get: function () {
	            return this._imageRect;
	        },
	        set: function (value) {
	            if (this._imageRect == value)
	                return;
	            this._imageRect = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "lightPicker", {
	        /**
	         * The light picker used by the material to provide lights to the material if it supports lighting.
	         *
	         * @see LightPickerBase
	         * @see StaticLightPicker
	         */
	        get: function () {
	            return this._pLightPicker;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "animationSet", {
	        /**
	         *
	         */
	        get: function () {
	            return this._animationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "blendMode", {
	        /**
	         * The blend mode to use when drawing this renderable. The following blend modes are supported:
	         * <ul>
	         * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
	         * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
	         * <li>BlendMode.MULTIPLY</li>
	         * <li>BlendMode.ADD</li>
	         * <li>BlendMode.ALPHA</li>
	         * </ul>
	         */
	        get: function () {
	            return this._pBlendMode;
	        },
	        set: function (value) {
	            if (this._pBlendMode == value)
	                return;
	            this._pBlendMode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "iOwners", {
	        /**
	         * A list of the IRenderables that use this material
	         *
	         * @private
	         */
	        get: function () {
	            return this._owners;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "animator", {
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "texture", {
	        /**
	        * The cube texture to use as the skybox.
	        */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.removeTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.addTexture(this._texture);
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Skybox.prototype.getNumTextures = function () {
	        return this._textures.length;
	    };
	    Skybox.prototype.getTextureAt = function (index) {
	        return this._textures[index];
	    };
	    Object.defineProperty(Skybox.prototype, "style", {
	        /**
	         *
	         */
	        get: function () {
	            return this._style;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Skybox.prototype, "assetType", {
	        get: function () {
	            return Skybox.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
	     *
	     * @private
	     */
	    Skybox.prototype.invalidatePasses = function () {
	        this.dispatchEvent(new SurfaceEvent_1.SurfaceEvent(SurfaceEvent_1.SurfaceEvent.INVALIDATE_PASSES, this));
	    };
	    Skybox.prototype.invalidateElements = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_ELEMENTS, this));
	    };
	    Skybox.prototype.invalidateSurface = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_SURFACE, this));
	    };
	    Skybox.prototype.addTexture = function (texture) {
	        this._textures.push(texture);
	        texture.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    Skybox.prototype.removeTexture = function (texture) {
	        this._textures.splice(this._textures.indexOf(texture), 1);
	        texture.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    Skybox.prototype.onTextureInvalidate = function (event) {
	        if (event === void 0) { event = null; }
	        this.invalidate();
	    };
	    Skybox.prototype._onInvalidateProperties = function (event) {
	        this.invalidatePasses();
	    };
	    Skybox.prototype._acceptTraverser = function (traverser) {
	        traverser.applyRenderable(this);
	    };
	    /**
	     * //TODO
	     *
	     * @param shortestCollisionDistance
	     * @returns {boolean}
	     *
	     * @internal
	     */
	    Skybox.prototype._iTestCollision = function (pickingCollision, pickingCollider) {
	        return false;
	    };
	    Skybox.assetType = "[asset Skybox]";
	    return Skybox;
	}(DisplayObject_1.DisplayObject));
	exports.Skybox = Skybox;


/***/ },
/* 131 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A export class that provides constant values for visual blend mode effects. These
	 * constants are used in the following:
	 * <ul>
	 *   <li> The <code>blendMode</code> property of the
	 * flash.display.DisplayObject class.</li>
	 *   <li> The <code>blendMode</code> parameter of the <code>draw()</code>
	 * method of the flash.display.BitmapData class</li>
	 * </ul>
	 */
	var BlendMode = (function () {
	    function BlendMode() {
	    }
	    /**
	     * Adds the values of the constituent colors of the display object to the
	     * colors of its background, applying a ceiling of 0xFF. This setting is
	     * commonly used for animating a lightening dissolve between two objects.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the
	     * resulting RGB value for the displayed pixel is 0xFFC833(because 0xAA +
	     * 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p>
	     */
	    BlendMode.ADD = "add";
	    /**
	     * Applies the alpha value of each pixel of the display object to the
	     * background. This requires the <code>blendMode</code> property of the
	     * parent display object be set to
	     * <code>away.base.BlendMode.LAYER</code>.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.ALPHA = "alpha";
	    /**
	     * Selects the darker of the constituent colors of the display object and the
	     * colors of the background(the colors with the smaller values). This
	     * setting is commonly used for superimposing type.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	     * resulting RGB value for the displayed pixel is 0xDDCC00(because 0xFF >
	     * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.DARKEN = "darken";
	    /**
	     * Compares the constituent colors of the display object with the colors of
	     * its background, and subtracts the darker of the values of the two
	     * constituent colors from the lighter value. This setting is commonly used
	     * for more vibrant colors.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	     * resulting RGB value for the displayed pixel is 0x222C33(because 0xFF -
	     * 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p>
	     */
	    BlendMode.DIFFERENCE = "difference";
	    /**
	     * Erases the background based on the alpha value of the display object. This
	     * process requires that the <code>blendMode</code> property of the parent
	     * display object be set to <code>flash.display.BlendMode.LAYER</code>.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.ERASE = "erase";
	    /**
	     * Adjusts the color of each pixel based on the darkness of the display
	     * object. If the display object is lighter than 50% gray, the display object
	     * and background colors are screened, which results in a lighter color. If
	     * the display object is darker than 50% gray, the colors are multiplied,
	     * which results in a darker color. This setting is commonly used for shading
	     * effects.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.HARDLIGHT = "hardlight";
	    /**
	     * Inverts the background.
	     */
	    BlendMode.INVERT = "invert";
	    /**
	     * Forces the creation of a transparency group for the display object. This
	     * means that the display object is precomposed in a temporary buffer before
	     * it is processed further. The precomposition is done automatically if the
	     * display object is precached by means of bitmap caching or if the display
	     * object is a display object container that has at least one child object
	     * with a <code>blendMode</code> setting other than <code>"normal"</code>.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.LAYER = "layer";
	    /**
	     * Selects the lighter of the constituent colors of the display object and
	     * the colors of the background(the colors with the larger values). This
	     * setting is commonly used for superimposing type.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
	     * resulting RGB value for the displayed pixel is 0xFFF833(because 0xFF >
	     * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.LIGHTEN = "lighten";
	    /**
	     * Multiplies the values of the display object constituent colors by the
	     * constituent colors of the background color, and normalizes by dividing by
	     * 0xFF, resulting in darker colors. This setting is commonly used for
	     * shadows and depth effects.
	     *
	     * <p>For example, if a constituent color(such as red) of one pixel in the
	     * display object and the corresponding color of the pixel in the background
	     * both have the value 0x88, the multiplied result is 0x4840. Dividing by
	     * 0xFF yields a value of 0x48 for that constituent color, which is a darker
	     * shade than the color of the display object or the color of the
	     * background.</p>
	     */
	    BlendMode.MULTIPLY = "multiply";
	    /**
	     * The display object appears in front of the background. Pixel values of the
	     * display object override the pixel values of the background. Where the
	     * display object is transparent, the background is visible.
	     */
	    BlendMode.NORMAL = "normal";
	    /**
	     * Adjusts the color of each pixel based on the darkness of the background.
	     * If the background is lighter than 50% gray, the display object and
	     * background colors are screened, which results in a lighter color. If the
	     * background is darker than 50% gray, the colors are multiplied, which
	     * results in a darker color. This setting is commonly used for shading
	     * effects.
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.OVERLAY = "overlay";
	    /**
	     * Multiplies the complement(inverse) of the display object color by the
	     * complement of the background color, resulting in a bleaching effect. This
	     * setting is commonly used for highlights or to remove black areas of the
	     * display object.
	     */
	    BlendMode.SCREEN = "screen";
	    /**
	     * Uses a shader to define the blend between objects.
	     *
	     * <p>Setting the <code>blendShader</code> property to a Shader instance
	     * automatically sets the display object's <code>blendMode</code> property to
	     * <code>BlendMode.SHADER</code>. If the <code>blendMode</code> property is
	     * set to <code>BlendMode.SHADER</code> without first setting the
	     * <code>blendShader</code> property, the <code>blendMode</code> property is
	     * set to <code>BlendMode.NORMAL</code> instead. If the
	     * <code>blendShader</code> property is set(which sets the
	     * <code>blendMode</code> property to <code>BlendMode.SHADER</code>), then
	     * later the value of the <code>blendMode</code> property is changed, the
	     * blend mode can be reset to use the blend shader simply by setting the
	     * <code>blendMode</code> property to <code>BlendMode.SHADER</code>. The
	     * <code>blendShader</code> property does not need to be set again except to
	     * change the shader that's used to define the blend mode.</p>
	     *
	     * <p>Not supported under GPU rendering.</p>
	     */
	    BlendMode.SHADER = "shader";
	    /**
	     * Subtracts the values of the constituent colors in the display object from
	     * the values of the background color, applying a floor of 0. This setting is
	     * commonly used for animating a darkening dissolve between two objects.
	     *
	     * <p>For example, if the display object has a pixel with an RGB value of
	     * 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the
	     * resulting RGB value for the displayed pixel is 0x338400(because 0xDD -
	     * 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00).</p>
	     */
	    BlendMode.SUBTRACT = "subtract";
	    return BlendMode;
	}());
	exports.BlendMode = BlendMode;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TextureBase_1 = __webpack_require__(133);
	var SingleCubeTexture = (function (_super) {
	    __extends(SingleCubeTexture, _super);
	    function SingleCubeTexture(imageCube) {
	        if (imageCube === void 0) { imageCube = null; }
	        _super.call(this);
	        this.setNumImages(1);
	        this.imageCube = imageCube;
	    }
	    Object.defineProperty(SingleCubeTexture.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return SingleCubeTexture.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SingleCubeTexture.prototype, "samplerCube", {
	        /**
	         *
	         * @returns {Image2D}
	         */
	        get: function () {
	            return this._samplers[0];
	        },
	        set: function (value) {
	            if (this._samplers[0] == value)
	                return;
	            this.setSamplerAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SingleCubeTexture.prototype, "imageCube", {
	        /**
	         *
	         * @returns {ImageCube}
	         */
	        get: function () {
	            return this._images[0];
	        },
	        set: function (value) {
	            if (this._images[0] == value)
	                return;
	            this.setImageAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SingleCubeTexture.assetType = "[texture SingleCubeTexture]";
	    return SingleCubeTexture;
	}(TextureBase_1.TextureBase));
	exports.SingleCubeTexture = SingleCubeTexture;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	/**
	 *
	 */
	var TextureBase = (function (_super) {
	    __extends(TextureBase, _super);
	    /**
	     *
	     */
	    function TextureBase() {
	        _super.call(this);
	        this._numImages = 0;
	        this._images = new Array();
	        this._samplers = new Array();
	    }
	    TextureBase.prototype.getNumImages = function () {
	        return this._numImages;
	    };
	    TextureBase.prototype.setNumImages = function (value) {
	        if (this._numImages == value)
	            return;
	        this._numImages = value;
	        this._images.length = value;
	        this._samplers.length = value;
	        this.invalidate();
	    };
	    TextureBase.prototype.getImageAt = function (index) {
	        return this._images[index];
	    };
	    TextureBase.prototype.setImageAt = function (image, index) {
	        this._images[index] = image;
	        this.invalidate();
	    };
	    TextureBase.prototype.getSamplerAt = function (index) {
	        return this._samplers[index];
	    };
	    TextureBase.prototype.setSamplerAt = function (sampler, index) {
	        this._samplers[index] = sampler;
	        this.invalidate();
	    };
	    return TextureBase;
	}(AssetBase_1.AssetBase));
	exports.TextureBase = TextureBase;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(96);
	var MaterialBase_1 = __webpack_require__(135);
	var Single2DTexture_1 = __webpack_require__(136);
	/**
	 * BasicMaterial forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var BasicMaterial = (function (_super) {
	    __extends(BasicMaterial, _super);
	    function BasicMaterial(imageColor, alpha) {
	        if (imageColor === void 0) { imageColor = null; }
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this, imageColor, alpha);
	        this._preserveAlpha = false;
	        //set a texture if an image is present
	        if (imageColor instanceof Image2D_1.Image2D)
	            this.texture = new Single2DTexture_1.Single2DTexture();
	    }
	    Object.defineProperty(BasicMaterial.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return BasicMaterial.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BasicMaterial.prototype, "preserveAlpha", {
	        /**
	         * Indicates whether alpha should be preserved - defaults to false
	         */
	        get: function () {
	            return this._preserveAlpha;
	        },
	        set: function (value) {
	            if (this._preserveAlpha == value)
	                return;
	            this._preserveAlpha = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BasicMaterial.prototype, "texture", {
	        /**
	         * The texture object to use for the albedo colour.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.removeTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.addTexture(this._texture);
	            this.invalidateTexture();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BasicMaterial.assetType = "[materials BasicMaterial]";
	    return BasicMaterial;
	}(MaterialBase_1.MaterialBase));
	exports.BasicMaterial = BasicMaterial;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BlendMode_1 = __webpack_require__(131);
	var ImageBase_1 = __webpack_require__(97);
	var ColorTransform_1 = __webpack_require__(27);
	var AssetEvent_1 = __webpack_require__(9);
	var AssetBase_1 = __webpack_require__(6);
	var SurfaceEvent_1 = __webpack_require__(119);
	var Style_1 = __webpack_require__(24);
	var StyleEvent_1 = __webpack_require__(25);
	/**
	 * MaterialBase forms an abstract base class for any material.
	 * A material consists of several passes, each of which constitutes at least one render call. Several passes could
	 * be used for special effects (render lighting for many lights in several passes, render an outline in a separate
	 * pass) or to provide additional render-to-texture passes (rendering diffuse light to texture for texture-space
	 * subsurface scattering, or rendering a depth map for specialized self-shadowing).
	 *
	 * Away3D provides default materials trough SinglePassMaterialBase and TriangleMaterial, which use modular
	 * methods to build the shader code. MaterialBase can be extended to build specific and high-performant custom
	 * shaders, or entire new material frameworks.
	 */
	var MaterialBase = (function (_super) {
	    __extends(MaterialBase, _super);
	    function MaterialBase(imageColor, alpha) {
	        var _this = this;
	        if (imageColor === void 0) { imageColor = null; }
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this);
	        this._textures = new Array();
	        this._pUseColorTransform = false;
	        this._alphaBlending = false;
	        this._alpha = 1;
	        this._pAlphaThreshold = 0;
	        this._pAnimateUVs = false;
	        this._enableLightFallOff = true;
	        this._specularLightSources = 0x01;
	        this._diffuseLightSources = 0x03;
	        this._style = new Style_1.Style();
	        this._iBaseScreenPassIndex = 0;
	        this._bothSides = false; // update
	        /**
	         * A list of material owners, renderables or custom Entities.
	         */
	        this._owners = new Array();
	        this._pBlendMode = BlendMode_1.BlendMode.NORMAL;
	        this._imageRect = false;
	        this._curves = false;
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._style.addEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	        if (imageColor instanceof ImageBase_1.ImageBase)
	            this._style.image = imageColor;
	        else if (imageColor)
	            this._style.color = Number(imageColor);
	        this.alpha = alpha;
	        this._onLightChangeDelegate = function (event) { return _this.onLightsChange(event); };
	        this._onTextureInvalidateDelegate = function (event) { return _this.onTextureInvalidate(event); };
	        this.alphaPremultiplied = false; //TODO: work out why this is different for WebGL
	    }
	    Object.defineProperty(MaterialBase.prototype, "alpha", {
	        /**
	         * The alpha of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            if (value > 1)
	                value = 1;
	            else if (value < 0)
	                value = 0;
	            if (this._alpha == value)
	                return;
	            this._alpha = value;
	            if (this._colorTransform == null)
	                this._colorTransform = new ColorTransform_1.ColorTransform();
	            this._colorTransform.alphaMultiplier = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "colorTransform", {
	        /**
	         * The ColorTransform object to transform the colour of the material with. Defaults to null.
	         */
	        get: function () {
	            return this._colorTransform;
	        },
	        set: function (value) {
	            this._colorTransform = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "alphaBlending", {
	        /**
	         * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
	         * example when using textures of foliage, consider using alphaThreshold instead.
	         */
	        get: function () {
	            return this._alphaBlending;
	        },
	        set: function (value) {
	            if (this._alphaBlending == value)
	                return;
	            this._alphaBlending = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "animationSet", {
	        /**
	         *
	         */
	        get: function () {
	            return this._animationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "lightPicker", {
	        /**
	         * The light picker used by the material to provide lights to the material if it supports lighting.
	         *
	         * @see LightPickerBase
	         * @see StaticLightPicker
	         */
	        get: function () {
	            return this._pLightPicker;
	        },
	        set: function (value) {
	            if (this._pLightPicker == value)
	                return;
	            if (this._pLightPicker)
	                this._pLightPicker.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightChangeDelegate);
	            this._pLightPicker = value;
	            if (this._pLightPicker)
	                this._pLightPicker.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightChangeDelegate);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "curves", {
	        /**
	         * Indicates whether material should use curves. Defaults to false.
	         */
	        get: function () {
	            return this._curves;
	        },
	        set: function (value) {
	            if (this._curves == value)
	                return;
	            this._curves = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "imageRect", {
	        /**
	         * Indicates whether or not any used textures should use an atlas. Defaults to false.
	         */
	        get: function () {
	            return this._imageRect;
	        },
	        set: function (value) {
	            if (this._imageRect == value)
	                return;
	            this._imageRect = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "style", {
	        /**
	         * The style used to render the current TriangleGraphic. If set to null, its parent Sprite's style will be used instead.
	         */
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "animateUVs", {
	        /**
	         * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
	         */
	        get: function () {
	            return this._pAnimateUVs;
	        },
	        set: function (value) {
	            if (this._pAnimateUVs == value)
	                return;
	            this._pAnimateUVs = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "useColorTransform", {
	        /**
	         * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
	         */
	        get: function () {
	            return this._pUseColorTransform;
	        },
	        set: function (value) {
	            if (this._pUseColorTransform == value)
	                return;
	            this._pUseColorTransform = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "enableLightFallOff", {
	        /**
	         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
	         * compatibility for constrained mode.
	         */
	        get: function () {
	            return this._enableLightFallOff;
	        },
	        set: function (value) {
	            if (this._enableLightFallOff == value)
	                return;
	            this._enableLightFallOff = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "diffuseLightSources", {
	        /**
	         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
	         * and/or light probes for diffuse reflections.
	         *
	         * @see away3d.materials.LightSources
	         */
	        get: function () {
	            return this._diffuseLightSources;
	        },
	        set: function (value) {
	            if (this._diffuseLightSources == value)
	                return;
	            this._diffuseLightSources = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "specularLightSources", {
	        /**
	         * Define which light source types to use for specular reflections. This allows choosing between regular lights
	         * and/or light probes for specular reflections.
	         *
	         * @see away3d.materials.LightSources
	         */
	        get: function () {
	            return this._specularLightSources;
	        },
	        set: function (value) {
	            if (this._specularLightSources == value)
	                return;
	            this._specularLightSources = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "bothSides", {
	        /**
	         * Defines whether or not the material should cull triangles facing away from the camera.
	         */
	        get: function () {
	            return this._bothSides;
	        },
	        set: function (value) {
	            if (this._bothSides = value)
	                return;
	            this._bothSides = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "blendMode", {
	        /**
	         * The blend mode to use when drawing this renderable. The following blend modes are supported:
	         * <ul>
	         * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
	         * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
	         * <li>BlendMode.MULTIPLY</li>
	         * <li>BlendMode.ADD</li>
	         * <li>BlendMode.ALPHA</li>
	         * </ul>
	         */
	        get: function () {
	            return this._pBlendMode;
	        },
	        set: function (value) {
	            if (this._pBlendMode == value)
	                return;
	            this._pBlendMode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
	        /**
	         * Indicates whether visible textures (or other pixels) used by this material have
	         * already been premultiplied. Toggle this if you are seeing black halos around your
	         * blended alpha edges.
	         */
	        get: function () {
	            return this._alphaPremultiplied;
	        },
	        set: function (value) {
	            if (this._alphaPremultiplied == value)
	                return;
	            this._alphaPremultiplied = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MaterialBase.prototype, "alphaThreshold", {
	        /**
	         * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
	         * invisible or entirely opaque, often used with textures for foliage, etc.
	         * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
	         */
	        get: function () {
	            return this._pAlphaThreshold;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            else if (value > 1)
	                value = 1;
	            if (this._pAlphaThreshold == value)
	                return;
	            this._pAlphaThreshold = value;
	            this.invalidatePasses();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //
	    // MATERIAL MANAGEMENT
	    //
	    /**
	     * Mark an IRenderable as owner of this material.
	     * Assures we're not using the same material across renderables with different animations, since the
	     * Programs depend on animation. This method needs to be called when a material is assigned.
	     *
	     * @param owner The IRenderable that had this material assigned
	     *
	     * @internal
	     */
	    MaterialBase.prototype.iAddOwner = function (owner) {
	        this._owners.push(owner);
	        var animationSet;
	        var animator = owner.animator;
	        if (animator)
	            animationSet = animator.animationSet;
	        if (owner.animator) {
	            if (this._animationSet && animationSet != this._animationSet) {
	                throw new Error("A Material instance cannot be shared across material owners with different animation sets");
	            }
	            else {
	                if (this._animationSet != animationSet) {
	                    this._animationSet = animationSet;
	                    this.invalidateAnimation();
	                }
	            }
	        }
	        owner.invalidateSurface();
	    };
	    /**
	     * Removes an IRenderable as owner.
	     * @param owner
	     *
	     * @internal
	     */
	    MaterialBase.prototype.iRemoveOwner = function (owner) {
	        this._owners.splice(this._owners.indexOf(owner), 1);
	        if (this._owners.length == 0) {
	            this._animationSet = null;
	            this.invalidateAnimation();
	        }
	        owner.invalidateSurface();
	    };
	    Object.defineProperty(MaterialBase.prototype, "iOwners", {
	        /**
	         * A list of the IRenderables that use this material
	         *
	         * @private
	         */
	        get: function () {
	            return this._owners;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MaterialBase.prototype.getNumTextures = function () {
	        return this._textures.length;
	    };
	    MaterialBase.prototype.getTextureAt = function (index) {
	        return this._textures[index];
	    };
	    /**
	     * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
	     *
	     * @private
	     */
	    MaterialBase.prototype.invalidatePasses = function () {
	        this.dispatchEvent(new SurfaceEvent_1.SurfaceEvent(SurfaceEvent_1.SurfaceEvent.INVALIDATE_PASSES, this));
	    };
	    MaterialBase.prototype.invalidateAnimation = function () {
	        this.dispatchEvent(new SurfaceEvent_1.SurfaceEvent(SurfaceEvent_1.SurfaceEvent.INVALIDATE_ANIMATION, this));
	    };
	    MaterialBase.prototype.invalidateSurfaces = function () {
	        var len = this._owners.length;
	        for (var i = 0; i < len; i++)
	            this._owners[i].invalidateSurface();
	    };
	    /**
	     * Called when the light picker's configuration changed.
	     */
	    MaterialBase.prototype.onLightsChange = function (event) {
	        this.invalidate();
	    };
	    MaterialBase.prototype.invalidateTexture = function () {
	        this.dispatchEvent(new SurfaceEvent_1.SurfaceEvent(SurfaceEvent_1.SurfaceEvent.INVALIDATE_TEXTURE, this));
	    };
	    MaterialBase.prototype.addTextureAt = function (texture, index) {
	        var i = this._textures.indexOf(texture);
	        if (i == index)
	            return;
	        else if (i != -1)
	            this._textures.splice(i, 1);
	        this._textures.splice(index, 0, texture);
	        texture.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    MaterialBase.prototype.addTexture = function (texture) {
	        if (this._textures.indexOf(texture) != -1)
	            return;
	        this._textures.push(texture);
	        texture.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    MaterialBase.prototype.removeTexture = function (texture) {
	        this._textures.splice(this._textures.indexOf(texture), 1);
	        texture.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
	        this.onTextureInvalidate();
	    };
	    MaterialBase.prototype.onTextureInvalidate = function (event) {
	        if (event === void 0) { event = null; }
	        this.invalidatePasses();
	        //invalidate renderables for number of images getter (in case it has changed)
	        this.invalidateSurfaces();
	    };
	    MaterialBase.prototype._onInvalidateProperties = function (event) {
	        this.invalidatePasses();
	    };
	    return MaterialBase;
	}(AssetBase_1.AssetBase));
	exports.MaterialBase = MaterialBase;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	var ImageUtils_1 = __webpack_require__(98);
	var MappingMode_1 = __webpack_require__(137);
	var TextureBase_1 = __webpack_require__(133);
	var Single2DTexture = (function (_super) {
	    __extends(Single2DTexture, _super);
	    function Single2DTexture(image2D) {
	        if (image2D === void 0) { image2D = null; }
	        _super.call(this);
	        this.setNumImages(1);
	        this.image2D = image2D;
	        this._mappingMode = MappingMode_1.MappingMode.NORMAL;
	    }
	    Object.defineProperty(Single2DTexture.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return Single2DTexture.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Single2DTexture.prototype, "mappingMode", {
	        get: function () {
	            return this._mappingMode;
	        },
	        set: function (value) {
	            if (this._mappingMode == value)
	                return;
	            this._mappingMode = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Single2DTexture.prototype, "sampler2D", {
	        /**
	         *
	         * @returns {Image2D}
	         */
	        get: function () {
	            return this._samplers[0];
	        },
	        set: function (value) {
	            if (this._samplers[0] == value)
	                return;
	            this.setSamplerAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Single2DTexture.prototype, "image2D", {
	        /**
	         *
	         * @returns {Image2D}
	         */
	        get: function () {
	            return this._images[0];
	        },
	        set: function (value) {
	            if (this._images[0] == value)
	                return;
	            if (!ImageUtils_1.ImageUtils.isImage2DValid(value))
	                throw new ErrorBase_1.ErrorBase("Invalid image2DData: Width and height must be power of 2 and cannot exceed 2048");
	            this.setImageAt(value, 0);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Single2DTexture.assetType = "[texture Single2DTexture]";
	    return Single2DTexture;
	}(TextureBase_1.TextureBase));
	exports.Single2DTexture = Single2DTexture;


/***/ },
/* 137 */
/***/ function(module, exports) {

	"use strict";
	/**
	
	
	 */
	var MappingMode = (function () {
	    function MappingMode() {
	    }
	    /**
	     *
	     */
	    MappingMode.NORMAL = "normal";
	    /**
	     *
	     */
	    MappingMode.LINEAR_GRADIENT = "linearGradient";
	    /**
	     *
	     */
	    MappingMode.RADIAL_GRADIENT = "radialGradient";
	    return MappingMode;
	}());
	exports.MappingMode = MappingMode;


/***/ },
/* 138 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Box_1 = __webpack_require__(33);
	var AssetBase_1 = __webpack_require__(6);
	var RenderableEvent_1 = __webpack_require__(118);
	var StyleEvent_1 = __webpack_require__(25);
	/**
	 * Graphic wraps a Elements as a scene graph instantiation. A Graphic is owned by a Sprite object.
	 *
	 *
	 * @see away.base.ElementsBase
	 * @see away.entities.Sprite
	 *
	 * @class away.base.Graphic
	 */
	var Graphic = (function (_super) {
	    __extends(Graphic, _super);
	    /**
	     * Creates a new Graphic object
	     */
	    function Graphic(index, parent, elements, material, style, count, offset, idx_count, idx_offset) {
	        var _this = this;
	        if (material === void 0) { material = null; }
	        if (style === void 0) { style = null; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        _super.call(this);
	        this._iIndex = 0;
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
	        this._iIndex = index;
	        this.parent = parent;
	        this.elements = elements;
	        this.material = material;
	        this.style = style;
	        this.count = count;
	        this.offset = offset;
	        this.idx_count = idx_count;
	        this.idx_offset = idx_offset;
	    }
	    Object.defineProperty(Graphic.prototype, "elements", {
	        /**
	         * The Elements object which provides the geometry data for this Graphic.
	         */
	        get: function () {
	            return this._elements;
	        },
	        set: function (value) {
	            if (this._elements == value)
	                return;
	            this._elements = value;
	            this.invalidateElements();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphic.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Graphic.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphic.prototype, "animator", {
	        /**
	         *
	         */
	        get: function () {
	            return this.parent.animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphic.prototype, "material", {
	        //TODO test shader picking
	        //		public get shaderPickingDetails():boolean
	        //		{
	        //
	        //			return this.sourceEntity.shaderPickingDetails;
	        //		}
	        /**
	         * The material used to render the current TriangleGraphic. If set to null, its parent Sprite's material will be used instead.
	         */
	        get: function () {
	            return this._material || this.parent.material;
	        },
	        set: function (value) {
	            if (this.material)
	                this.material.iRemoveOwner(this);
	            this._material = value;
	            if (this.material)
	                this.material.iAddOwner(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphic.prototype, "style", {
	        /**
	         * The style used to render the current TriangleGraphic. If set to null, its parent Sprite's style will be used instead.
	         */
	        get: function () {
	            return this._style || this.parent.style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this.invalidateSurface();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    Graphic.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this.parent.removeGraphic(this);
	        this.parent = null;
	        Graphic._available.push(this);
	    };
	    Graphic.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	    };
	    Graphic.prototype.invalidateElements = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_ELEMENTS, this));
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	    };
	    Graphic.prototype.invalidateSurface = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_SURFACE, this));
	    };
	    Graphic.prototype._iGetExplicitMaterial = function () {
	        return this._material;
	    };
	    Graphic.prototype._iGetExplicitStyle = function () {
	        return this._style;
	    };
	    Graphic.prototype._onInvalidateProperties = function (event) {
	        this.invalidateSurface();
	    };
	    Graphic.prototype._onInvalidateVertices = function (event) {
	        if (event.attributesView != event.target.positions)
	            return;
	        this.invalidate();
	        this.dispatchEvent(event);
	    };
	    /**
	     * //TODO
	     *
	     * @param shortestCollisionDistance
	     * @param findClosest
	     * @returns {boolean}
	     *
	     * @internal
	     */
	    Graphic.prototype._iTestCollision = function (pickingCollision, pickingCollider) {
	        return this._elements._iTestCollision(pickingCollider, this.material, pickingCollision, this.count, this.offset);
	    };
	    Graphic.prototype.applyTransformation = function (transform) {
	        this._elements.applyTransformation(transform, this.count, this.offset);
	    };
	    Graphic.prototype.hitTestPoint = function (x, y, z) {
	        var box;
	        //early out for box test
	        if (!(box = this.getBoxBounds()).contains(x, y, z))
	            return false;
	        return this._elements.hitTestPoint(x, y, z, box, this.count, this.offset, this.idx_count, this.idx_offset);
	    };
	    Graphic.prototype.scale = function (scale) {
	        this._elements.scale(scale, this.count, this.offset);
	    };
	    Graphic.prototype.scaleUV = function (scaleU, scaleV) {
	        if (scaleU === void 0) { scaleU = 1; }
	        if (scaleV === void 0) { scaleV = 1; }
	        this._elements.scaleUV(scaleU, scaleV, this.count, this.offset);
	    };
	    Graphic.prototype.getBoxBounds = function () {
	        if (this._boxBoundsInvalid) {
	            this._boxBoundsInvalid = false;
	            this._boxBounds = this._elements.getBoxBounds(this._boxBounds || (this._boxBounds = new Box_1.Box()), this.count, this.offset, this.idx_count, this.idx_offset);
	        }
	        return this._boxBounds;
	    };
	    Graphic.prototype.getSphereBounds = function (center, target) {
	        if (target === void 0) { target = null; }
	        return this._elements.getSphereBounds(center, target, this.count, this.offset);
	    };
	    Graphic._available = new Array();
	    Graphic.assetType = "[asset Graphic]";
	    return Graphic;
	}(AssetBase_1.AssetBase));
	exports.Graphic = Graphic;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var Plane3D_1 = __webpack_require__(140);
	var ProjectionEvent_1 = __webpack_require__(142);
	var PerspectiveProjection_1 = __webpack_require__(143);
	var HierarchicalProperties_1 = __webpack_require__(22);
	var BoundsType_1 = __webpack_require__(115);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var CameraEvent_1 = __webpack_require__(148);
	var Camera = (function (_super) {
	    __extends(Camera, _super);
	    function Camera(projection) {
	        var _this = this;
	        if (projection === void 0) { projection = null; }
	        _super.call(this);
	        this._viewProjection = new Matrix3D_1.Matrix3D();
	        this._viewProjectionDirty = true;
	        this._frustumPlanesDirty = true;
	        this._pIsEntity = true;
	        this._onProjectionMatrixChangedDelegate = function (event) { return _this.onProjectionMatrixChanged(event); };
	        this._projection = projection || new PerspectiveProjection_1.PerspectiveProjection();
	        this._projection.addEventListener(ProjectionEvent_1.ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	        this._frustumPlanes = [];
	        for (var i = 0; i < 6; ++i)
	            this._frustumPlanes[i] = new Plane3D_1.Plane3D();
	        this.z = -1000;
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.NULL;
	    }
	    Object.defineProperty(Camera.prototype, "assetType", {
	        //@override
	        get: function () {
	            return Camera.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Camera.prototype.onProjectionMatrixChanged = function (event) {
	        this._viewProjectionDirty = true;
	        this._frustumPlanesDirty = true;
	        this.dispatchEvent(event);
	    };
	    Object.defineProperty(Camera.prototype, "frustumPlanes", {
	        get: function () {
	            if (this._frustumPlanesDirty)
	                this.updateFrustum();
	            return this._frustumPlanes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Camera.prototype.updateFrustum = function () {
	        var a, b, c;
	        //var d : Number;
	        var c11, c12, c13, c14;
	        var c21, c22, c23, c24;
	        var c31, c32, c33, c34;
	        var c41, c42, c43, c44;
	        var p;
	        var raw = this.viewProjection.rawData;
	        var invLen;
	        c11 = raw[0];
	        c12 = raw[4];
	        c13 = raw[8];
	        c14 = raw[12];
	        c21 = raw[1];
	        c22 = raw[5];
	        c23 = raw[9];
	        c24 = raw[13];
	        c31 = raw[2];
	        c32 = raw[6];
	        c33 = raw[10];
	        c34 = raw[14];
	        c41 = raw[3];
	        c42 = raw[7];
	        c43 = raw[11];
	        c44 = raw[15];
	        // left plane
	        p = this._frustumPlanes[0];
	        a = c41 + c11;
	        b = c42 + c12;
	        c = c43 + c13;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = -(c44 + c14) * invLen;
	        // right plane
	        p = this._frustumPlanes[1];
	        a = c41 - c11;
	        b = c42 - c12;
	        c = c43 - c13;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = (c14 - c44) * invLen;
	        // bottom
	        p = this._frustumPlanes[2];
	        a = c41 + c21;
	        b = c42 + c22;
	        c = c43 + c23;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = -(c44 + c24) * invLen;
	        // top
	        p = this._frustumPlanes[3];
	        a = c41 - c21;
	        b = c42 - c22;
	        c = c43 - c23;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = (c24 - c44) * invLen;
	        // near
	        p = this._frustumPlanes[4];
	        a = c31;
	        b = c32;
	        c = c33;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = -c34 * invLen;
	        // far
	        p = this._frustumPlanes[5];
	        a = c41 - c31;
	        b = c42 - c32;
	        c = c43 - c33;
	        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
	        p.a = a * invLen;
	        p.b = b * invLen;
	        p.c = c * invLen;
	        p.d = (c34 - c44) * invLen;
	        this._frustumPlanesDirty = false;
	    };
	    Camera.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
	        if (_super.prototype.pInvalidateHierarchicalProperties.call(this, propDirty))
	            return true;
	        if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM) {
	            this._viewProjectionDirty = true;
	            this._frustumPlanesDirty = true;
	        }
	        return false;
	    };
	    Object.defineProperty(Camera.prototype, "projection", {
	        /**
	         *
	         */
	        get: function () {
	            return this._projection;
	        },
	        set: function (value) {
	            if (this._projection == value)
	                return;
	            if (!value)
	                throw new Error("Projection cannot be null!");
	            this._projection.removeEventListener(ProjectionEvent_1.ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	            this._projection = value;
	            this._projection.addEventListener(ProjectionEvent_1.ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	            this.dispatchEvent(new CameraEvent_1.CameraEvent(CameraEvent_1.CameraEvent.PROJECTION_CHANGED, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Camera.prototype, "viewProjection", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._viewProjectionDirty) {
	                this._viewProjection.copyFrom(this.inverseSceneTransform);
	                this._viewProjection.append(this._projection.matrix);
	                this._viewProjectionDirty = false;
	            }
	            return this._viewProjection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Calculates the ray in scene space from the camera to the given normalized coordinates in screen space.
	     *
	     * @param nX The normalised x coordinate in screen space, -1 corresponds to the left edge of the viewport, 1 to the right.
	     * @param nY The normalised y coordinate in screen space, -1 corresponds to the top edge of the viewport, 1 to the bottom.
	     * @param sZ The z coordinate in screen space, representing the distance into the screen.
	     * @return The ray from the camera to the scene space position of the given screen coordinates.
	     */
	    Camera.prototype.getRay = function (nX, nY, sZ) {
	        return this.sceneTransform.deltaTransformVector(this._projection.unproject(nX, nY, sZ));
	    };
	    /**
	     * Calculates the normalised position in screen space of the given scene position.
	     *
	     * @param point3d the position vector of the scene coordinates to be projected.
	     * @return The normalised screen position of the given scene coordinates.
	     */
	    Camera.prototype.project = function (point3d) {
	        return this._projection.project(this.inverseSceneTransform.transformVector(point3d));
	    };
	    /**
	     * Calculates the scene position of the given normalized coordinates in screen space.
	     *
	     * @param nX The normalised x coordinate in screen space, minus the originX offset of the projection property.
	     * @param nY The normalised y coordinate in screen space, minus the originY offset of the projection property.
	     * @param sZ The z coordinate in screen space, representing the distance into the screen.
	     * @return The scene position of the given screen coordinates.
	     */
	    Camera.prototype.unproject = function (nX, nY, sZ) {
	        return this.sceneTransform.transformVector(this._projection.unproject(nX, nY, sZ));
	    };
	    Camera.prototype._applyRenderer = function (renderer) {
	        // Since this getter is invoked every iteration of the render loop, and
	        // the prefab construct could affect the sub-sprites, the prefab is
	        // validated here to give it a chance to rebuild.
	        if (this._iSourcePrefab)
	            this._iSourcePrefab._iValidate();
	        //nothing to do here
	    };
	    Camera.assetType = "[asset Camera]";
	    return Camera;
	}(DisplayObjectContainer_1.DisplayObjectContainer));
	exports.Camera = Camera;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PlaneClassification_1 = __webpack_require__(141);
	var Plane3D = (function () {
	    /**
	     * Create a Plane3D with ABCD coefficients
	     */
	    function Plane3D(a, b, c, d) {
	        if (a === void 0) { a = 0; }
	        if (b === void 0) { b = 0; }
	        if (c === void 0) { c = 0; }
	        if (d === void 0) { d = 0; }
	        this.a = a;
	        this.b = b;
	        this.c = c;
	        this.d = d;
	        if (a == 0 && b == 0) {
	            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
	        }
	        else if (b == 0 && c == 0) {
	            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
	        }
	        else if (a == 0 && c == 0) {
	            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
	        }
	        else {
	            this._iAlignment = Plane3D.ALIGN_ANY;
	        }
	    }
	    /**
	     * Fills this Plane3D with the coefficients from 3 points in 3d space.
	     * @param p0 Vector3D
	     * @param p1 Vector3D
	     * @param p2 Vector3D
	     */
	    Plane3D.prototype.fromPoints = function (p0, p1, p2) {
	        var d1x = p1.x - p0.x;
	        var d1y = p1.y - p0.y;
	        var d1z = p1.z - p0.z;
	        var d2x = p2.x - p0.x;
	        var d2y = p2.y - p0.y;
	        var d2z = p2.z - p0.z;
	        this.a = d1y * d2z - d1z * d2y;
	        this.b = d1z * d2x - d1x * d2z;
	        this.c = d1x * d2y - d1y * d2x;
	        this.d = this.a * p0.x + this.b * p0.y + this.c * p0.z;
	        // not using epsilon, since a plane is infinite and a small incorrection can grow very large
	        if (this.a == 0 && this.b == 0) {
	            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
	        }
	        else if (this.b == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
	        }
	        else if (this.a == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
	        }
	        else {
	            this._iAlignment = Plane3D.ALIGN_ANY;
	        }
	    };
	    /**
	     * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
	     * @param normal Vector3D
	     * @param point  Vector3D
	     */
	    Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
	        this.a = normal.x;
	        this.b = normal.y;
	        this.c = normal.z;
	        this.d = this.a * point.x + this.b * point.y + this.c * point.z;
	        if (this.a == 0 && this.b == 0) {
	            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
	        }
	        else if (this.b == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
	        }
	        else if (this.a == 0 && this.c == 0) {
	            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
	        }
	        else {
	            this._iAlignment = Plane3D.ALIGN_ANY;
	        }
	    };
	    /**
	     * Normalize this Plane3D
	     * @return Plane3D This Plane3D.
	     */
	    Plane3D.prototype.normalize = function () {
	        var len = 1 / Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
	        this.a *= len;
	        this.b *= len;
	        this.c *= len;
	        this.d *= len;
	        return this;
	    };
	    /**
	     * Returns the signed distance between this Plane3D and the point p.
	     * @param p Vector3D
	     * @returns Number
	     */
	    Plane3D.prototype.distance = function (p) {
	        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS) {
	            return this.a * p.x - this.d;
	        }
	        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS) {
	            return this.b * p.y - this.d;
	        }
	        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS) {
	            return this.c * p.z - this.d;
	        }
	        else {
	            return this.a * p.x + this.b * p.y + this.c * p.z - this.d;
	        }
	    };
	    /**
	     * Classify a point against this Plane3D. (in front, back or intersecting)
	     * @param p Vector3D
	     * @return int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
	     */
	    Plane3D.prototype.classifyPoint = function (p, epsilon) {
	        if (epsilon === void 0) { epsilon = 0.01; }
	        // check NaN
	        if (this.d != this.d)
	            return PlaneClassification_1.PlaneClassification.FRONT;
	        var len;
	        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS)
	            len = this.a * p.x - this.d;
	        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS)
	            len = this.b * p.y - this.d;
	        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS)
	            len = this.c * p.z - this.d;
	        else
	            len = this.a * p.x + this.b * p.y + this.c * p.z - this.d;
	        if (len < -epsilon)
	            return PlaneClassification_1.PlaneClassification.BACK;
	        else if (len > epsilon)
	            return PlaneClassification_1.PlaneClassification.FRONT;
	        else
	            return PlaneClassification_1.PlaneClassification.INTERSECT;
	    };
	    Plane3D.prototype.toString = function () {
	        return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
	    };
	    // indicates the alignment of the plane
	    Plane3D.ALIGN_ANY = 0;
	    Plane3D.ALIGN_XY_AXIS = 1;
	    Plane3D.ALIGN_YZ_AXIS = 2;
	    Plane3D.ALIGN_XZ_AXIS = 3;
	    return Plane3D;
	}());
	exports.Plane3D = Plane3D;


/***/ },
/* 141 */
/***/ function(module, exports) {

	"use strict";
	var PlaneClassification = (function () {
	    function PlaneClassification() {
	    }
	    // "back" is synonymous with "in", but used for planes (back of plane is "inside" a solid volume walled by a plane)
	    PlaneClassification.BACK = 0;
	    PlaneClassification.FRONT = 1;
	    PlaneClassification.IN = 0;
	    PlaneClassification.OUT = 1;
	    PlaneClassification.INTERSECT = 2;
	    return PlaneClassification;
	}());
	exports.PlaneClassification = PlaneClassification;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var ProjectionEvent = (function (_super) {
	    __extends(ProjectionEvent, _super);
	    function ProjectionEvent(type, projection) {
	        _super.call(this, type);
	        this._projection = projection;
	    }
	    Object.defineProperty(ProjectionEvent.prototype, "projection", {
	        get: function () {
	            return this._projection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionEvent.MATRIX_CHANGED = "matrixChanged";
	    return ProjectionEvent;
	}(EventBase_1.EventBase));
	exports.ProjectionEvent = ProjectionEvent;


/***/ },
/* 143 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Vector3D_1 = __webpack_require__(34);
	var CoordinateSystem_1 = __webpack_require__(144);
	var ProjectionBase_1 = __webpack_require__(145);
	var PerspectiveProjection = (function (_super) {
	    __extends(PerspectiveProjection, _super);
	    function PerspectiveProjection(fieldOfView, coordinateSystem) {
	        if (fieldOfView === void 0) { fieldOfView = 60; }
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        _super.call(this, coordinateSystem);
	        this._fieldOfView = 60;
	        this._focalLength = 1000;
	        this._hFieldOfView = 60;
	        this._hFocalLength = 1000;
	        this._preserveAspectRatio = true;
	        this._preserveFocalLength = false;
	        this.fieldOfView = fieldOfView;
	    }
	    Object.defineProperty(PerspectiveProjection.prototype, "preserveAspectRatio", {
	        /**
	         *
	         */
	        get: function () {
	            return this._preserveAspectRatio;
	        },
	        set: function (value) {
	            if (this._preserveAspectRatio == value)
	                return;
	            this._preserveAspectRatio = value;
	            if (this._preserveAspectRatio)
	                this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "preserveFocalLength", {
	        /**
	         *
	         */
	        get: function () {
	            return this._preserveFocalLength;
	        },
	        set: function (value) {
	            if (this._preserveFocalLength == value)
	                return;
	            this._preserveFocalLength = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "fieldOfView", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._pMatrixInvalid && this._preserveFocalLength)
	                this.pUpdateMatrix();
	            return this._fieldOfView;
	        },
	        set: function (value) {
	            if (this._fieldOfView == value)
	                return;
	            this._fieldOfView = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "focalLength", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._pMatrixInvalid && !this._preserveFocalLength)
	                this.pUpdateMatrix();
	            return this._focalLength;
	        },
	        set: function (value) {
	            if (this._focalLength == value)
	                return;
	            this._focalLength = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "hFieldOfView", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._pMatrixInvalid && this._preserveFocalLength)
	                this.pUpdateMatrix();
	            return this._hFieldOfView;
	        },
	        set: function (value) {
	            if (this._hFieldOfView == value)
	                return;
	            this._hFieldOfView = value;
	            this._hFocalLength = 1 / Math.tan(this._hFieldOfView * Math.PI / 360);
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PerspectiveProjection.prototype, "hFocalLength", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._pMatrixInvalid && !this._preserveFocalLength)
	                this.pUpdateMatrix();
	            return this._hFocalLength;
	        },
	        set: function (value) {
	            if (this._hFocalLength == value)
	                return;
	            this._hFocalLength = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    PerspectiveProjection.prototype.unproject = function (nX, nY, sZ) {
	        var v = new Vector3D_1.Vector3D(nX, -nY, sZ, 1.0);
	        v.x *= sZ;
	        v.y *= sZ;
	        v = this.unprojectionMatrix.transformVector(v);
	        //z is unaffected by transform
	        v.z = sZ;
	        return v;
	    };
	    //@override
	    PerspectiveProjection.prototype.clone = function () {
	        var clone = new PerspectiveProjection(this._fieldOfView);
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        clone._pCoordinateSystem = this._pCoordinateSystem;
	        return clone;
	    };
	    //@override
	    PerspectiveProjection.prototype.pUpdateMatrix = function () {
	        var raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        if (this._preserveFocalLength) {
	            if (this._preserveAspectRatio)
	                this._hFocalLength = this._focalLength;
	            this._fieldOfView = Math.atan(0.5 * this._pScissorRect.height / this._focalLength) * 360 / Math.PI;
	            this._hFieldOfView = Math.atan(0.5 * this._pScissorRect.width / this._hFocalLength) * 360 / Math.PI;
	        }
	        else {
	            this._focalLength = 0.5 * this._pScissorRect.height / Math.tan(this._fieldOfView * Math.PI / 360);
	            if (this._preserveAspectRatio)
	                this._hFocalLength = this._focalLength;
	            else
	                this._hFocalLength = 0.5 * this._pScissorRect.width / Math.tan(this._hFieldOfView * Math.PI / 360);
	        }
	        var tanMinX = -this._pOriginX / this._hFocalLength;
	        var tanMaxX = (1 - this._pOriginX) / this._hFocalLength;
	        var tanMinY = -this._pOriginY / this._focalLength;
	        var tanMaxY = (1 - this._pOriginY) / this._focalLength;
	        var left;
	        var right;
	        var top;
	        var bottom;
	        // assume scissored frustum
	        var center = -((tanMinX - tanMaxX) * this._pScissorRect.x + tanMinX * this._pScissorRect.width);
	        var middle = ((tanMinY - tanMaxY) * this._pScissorRect.y + tanMinY * this._pScissorRect.height);
	        left = center - (tanMaxX - tanMinX) * this._pViewPort.width;
	        right = center;
	        top = middle;
	        bottom = middle + (tanMaxY - tanMinY) * this._pViewPort.height;
	        raw[0] = 2 / (right - left);
	        raw[5] = 2 / (bottom - top);
	        raw[8] = (right + left) / (right - left);
	        raw[9] = (bottom + top) / (bottom - top);
	        raw[10] = (this._pFar + this._pNear) / (this._pFar - this._pNear);
	        raw[11] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[12] = raw[13] = raw[15] = 0;
	        raw[14] = -2 * this._pFar * this._pNear / (this._pFar - this._pNear);
	        if (this._pCoordinateSystem == CoordinateSystem_1.CoordinateSystem.RIGHT_HANDED)
	            raw[5] = -raw[5];
	        this._pMatrix.copyRawDataFrom(raw);
	        this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pNear * left;
	        this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pNear * right;
	        this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pNear * top;
	        this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pNear * bottom;
	        this._pFrustumCorners[12] = this._pFrustumCorners[21] = this._pFar * left;
	        this._pFrustumCorners[15] = this._pFrustumCorners[18] = this._pFar * right;
	        this._pFrustumCorners[13] = this._pFrustumCorners[16] = this._pFar * top;
	        this._pFrustumCorners[19] = this._pFrustumCorners[22] = this._pFar * bottom;
	        this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
	        this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;
	        this._pMatrixInvalid = false;
	    };
	    return PerspectiveProjection;
	}(ProjectionBase_1.ProjectionBase));
	exports.PerspectiveProjection = PerspectiveProjection;


/***/ },
/* 144 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Provides constant values for camera lens projection options use the the <code>coordinateSystem</code> property
	 *
	 * @see away.projections.PerspectiveLens#coordinateSystem
	 */
	var CoordinateSystem = (function () {
	    function CoordinateSystem() {
	    }
	    /**
	     * Default option, projects to a left-handed coordinate system
	     */
	    CoordinateSystem.LEFT_HANDED = "leftHanded";
	    /**
	     * Projects to a right-handed coordinate system
	     */
	    CoordinateSystem.RIGHT_HANDED = "rightHanded";
	    return CoordinateSystem;
	}());
	exports.CoordinateSystem = CoordinateSystem;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var Rectangle_1 = __webpack_require__(57);
	var EventDispatcher_1 = __webpack_require__(11);
	var ProjectionEvent_1 = __webpack_require__(142);
	var AbstractMethodError_1 = __webpack_require__(7);
	var ProjectionBase = (function (_super) {
	    __extends(ProjectionBase, _super);
	    function ProjectionBase(coordinateSystem) {
	        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
	        _super.call(this);
	        this._pMatrix = new Matrix3D_1.Matrix3D();
	        this._pScissorRect = new Rectangle_1.Rectangle();
	        this._pViewPort = new Rectangle_1.Rectangle();
	        this._pNear = 20;
	        this._pFar = 3000;
	        this._pAspectRatio = 1;
	        this._pMatrixInvalid = true;
	        this._pFrustumCorners = [];
	        this._pOriginX = 0.5;
	        this._pOriginY = 0.5;
	        this._unprojectionInvalid = true;
	        this.coordinateSystem = coordinateSystem;
	    }
	    Object.defineProperty(ProjectionBase.prototype, "coordinateSystem", {
	        /**
	         * The handedness of the coordinate system projection. The default is LEFT_HANDED.
	         */
	        get: function () {
	            return this._pCoordinateSystem;
	        },
	        set: function (value) {
	            if (this._pCoordinateSystem == value)
	                return;
	            this._pCoordinateSystem = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "frustumCorners", {
	        get: function () {
	            return this._pFrustumCorners;
	        },
	        set: function (frustumCorners) {
	            this._pFrustumCorners = frustumCorners;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "matrix", {
	        get: function () {
	            if (this._pMatrixInvalid) {
	                this.pUpdateMatrix();
	                this._pMatrixInvalid = false;
	            }
	            return this._pMatrix;
	        },
	        set: function (value) {
	            this._pMatrix = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "near", {
	        get: function () {
	            return this._pNear;
	        },
	        set: function (value) {
	            if (value == this._pNear) {
	                return;
	            }
	            this._pNear = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "originX", {
	        get: function () {
	            return this._pOriginX;
	        },
	        set: function (value) {
	            if (this._pOriginX == value)
	                return;
	            this._pOriginX = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "originY", {
	        get: function () {
	            return this._pOriginY;
	        },
	        set: function (value) {
	            if (this._pOriginY == value)
	                return;
	            this._pOriginY = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ProjectionBase.prototype, "far", {
	        get: function () {
	            return this._pFar;
	        },
	        set: function (value) {
	            if (value == this._pFar) {
	                return;
	            }
	            this._pFar = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionBase.prototype.project = function (point3d) {
	        var v = this.matrix.transformVector(point3d);
	        v.x = v.x / v.w;
	        v.y = -v.y / v.w;
	        //z is unaffected by transform
	        v.z = point3d.z;
	        return v;
	    };
	    Object.defineProperty(ProjectionBase.prototype, "unprojectionMatrix", {
	        get: function () {
	            if (this._unprojectionInvalid) {
	                if (!this._unprojection)
	                    this._unprojection = new Matrix3D_1.Matrix3D();
	                this._unprojection.copyFrom(this.matrix);
	                this._unprojection.invert();
	                this._unprojectionInvalid = false;
	            }
	            return this._unprojection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionBase.prototype.unproject = function (nX, nY, sZ) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ProjectionBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    Object.defineProperty(ProjectionBase.prototype, "_iAspectRatio", {
	        get: function () {
	            return this._pAspectRatio;
	        },
	        set: function (value) {
	            if (this._pAspectRatio == value)
	                return;
	            this._pAspectRatio = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ProjectionBase.prototype.pInvalidateMatrix = function () {
	        this._pMatrixInvalid = true;
	        this._unprojectionInvalid = true;
	        this.dispatchEvent(new ProjectionEvent_1.ProjectionEvent(ProjectionEvent_1.ProjectionEvent.MATRIX_CHANGED, this));
	    };
	    ProjectionBase.prototype.pUpdateMatrix = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ProjectionBase.prototype._iUpdateScissorRect = function (x, y, width, height) {
	        this._pScissorRect.x = x;
	        this._pScissorRect.y = y;
	        this._pScissorRect.width = width;
	        this._pScissorRect.height = height;
	        this.pInvalidateMatrix();
	    };
	    ProjectionBase.prototype._iUpdateViewport = function (x, y, width, height) {
	        this._pViewPort.x = x;
	        this._pViewPort.y = y;
	        this._pViewPort.width = width;
	        this._pViewPort.height = height;
	        this.pInvalidateMatrix();
	    };
	    return ProjectionBase;
	}(EventDispatcher_1.EventDispatcher));
	exports.ProjectionBase = ProjectionBase;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ArgumentError_1 = __webpack_require__(37);
	var RangeError_1 = __webpack_require__(147);
	var DisplayObject_1 = __webpack_require__(113);
	var HierarchicalProperties_1 = __webpack_require__(22);
	/**
	 * The DisplayObjectContainer class is the base class for all objects that can
	 * serve as display object containers on the display list. The display list
	 * manages all objects displayed in the Flash runtimes. Use the
	 * DisplayObjectContainer class to arrange the display objects in the display
	 * list. Each DisplayObjectContainer object has its own child list for
	 * organizing the z-order of the objects. The z-order is the front-to-back
	 * order that determines which object is drawn in front, which is behind, and
	 * so on.
	 *
	 * <p>DisplayObject is an abstract base class; therefore, you cannot call
	 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
	 * <code>ArgumentError</code> exception.</p>
	 * The DisplayObjectContainer class is an abstract base class for all objects
	 * that can contain child objects. It cannot be instantiated directly; calling
	 * the <code>new DisplayObjectContainer()</code> constructor throws an
	 * <code>ArgumentError</code> exception.
	 *
	 * <p>For more information, see the "Display Programming" chapter of the
	 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
	 */
	var DisplayObjectContainer = (function (_super) {
	    __extends(DisplayObjectContainer, _super);
	    /**
	     * Calling the <code>new DisplayObjectContainer()</code> constructor throws
	     * an <code>ArgumentError</code> exception. You <i>can</i>, however, call
	     * constructors for the following subclasses of DisplayObjectContainer:
	     * <ul>
	     *   <li><code>new Loader()</code></li>
	     *   <li><code>new Sprite()</code></li>
	     *   <li><code>new MovieClip()</code></li>
	     * </ul>
	     */
	    function DisplayObjectContainer() {
	        _super.call(this);
	        this._mouseChildren = true;
	        this._depth_childs = {};
	        this._nextHighestDepth = 0;
	        this._children = new Array();
	    }
	    Object.defineProperty(DisplayObjectContainer.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return DisplayObjectContainer.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObjectContainer.prototype, "mouseChildren", {
	        /**
	         * Determines whether or not the children of the object are mouse, or user
	         * input device, enabled. If an object is enabled, a user can interact with
	         * it by using a mouse or user input device. The default is
	         * <code>true</code>.
	         *
	         * <p>This property is useful when you create a button with an instance of
	         * the Sprite class(instead of using the SimpleButton class). When you use a
	         * Sprite instance to create a button, you can choose to decorate the button
	         * by using the <code>addChild()</code> method to add additional Sprite
	         * instances. This process can cause unexpected behavior with mouse events
	         * because the Sprite instances you add as children can become the target
	         * object of a mouse event when you expect the parent instance to be the
	         * target object. To ensure that the parent instance serves as the target
	         * objects for mouse events, you can set the <code>mouseChildren</code>
	         * property of the parent instance to <code>false</code>.</p>
	         *
	         * <p> No event is dispatched by setting this property. You must use the
	         * <code>addEventListener()</code> method to create interactive
	         * functionality.</p>
	         */
	        get: function () {
	            if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.MOUSE_ENABLED)
	                this._updateMouseEnabled();
	            return this._mouseChildren;
	        },
	        set: function (value) {
	            if (this._mouseChildren == value)
	                return;
	            this._mouseChildren = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.MOUSE_ENABLED);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObjectContainer.prototype, "numChildren", {
	        /**
	         * Returns the number of children of this object.
	         */
	        get: function () {
	            return this._children.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a child DisplayObject instance to this DisplayObjectContainer
	     * instance. The child is added to the front(top) of all other children in
	     * this DisplayObjectContainer instance.(To add a child to a specific index
	     * position, use the <code>addChildAt()</code> method.)
	     *
	     * <p>If you add a child object that already has a different display object
	     * container as a parent, the object is removed from the child list of the
	     * other display object container. </p>
	     *
	     * <p><b>Note:</b> The command <code>stage.addChild()</code> can cause
	     * problems with a published SWF file, including security problems and
	     * conflicts with other loaded SWF files. There is only one Stage within a
	     * Flash runtime instance, no matter how many SWF files you load into the
	     * runtime. So, generally, objects should not be added to the Stage,
	     * directly, at all. The only object the Stage should contain is the root
	     * object. Create a DisplayObjectContainer to contain all of the items on the
	     * display list. Then, if necessary, add that DisplayObjectContainer instance
	     * to the Stage.</p>
	     *
	     * @param child The DisplayObject instance to add as a child of this
	     *              DisplayObjectContainer instance.
	     * @return The DisplayObject instance that you pass in the <code>child</code>
	     *         parameter.
	     * @throws ArgumentError Throws if the child is the same as the parent. Also
	     *                       throws if the caller is a child(or grandchild etc.)
	     *                       of the child being added.
	     * @event added Dispatched when a display object is added to the display
	     *              list.
	     */
	    DisplayObjectContainer.prototype.addChild = function (child) {
	        return this.addChildAt(child, this._children.length);
	    };
	    DisplayObjectContainer.prototype.addChildAtDepth = function (child, depth, replace) {
	        if (replace === void 0) { replace = true; }
	        if (child == null)
	            throw new ArgumentError_1.ArgumentError("Parameter child cannot be null.");
	        //if child already has a parent, remove it.
	        if (child._pParent)
	            child._pParent.removeChildAtInternal(child._pParent.getChildIndex(child));
	        var index = this.getDepthIndexInternal(depth);
	        if (index != -1) {
	            if (replace) {
	                this.removeChildAt(index);
	            }
	            else {
	                //move depth of existing child up by 1
	                this.addChildAtDepth(this._children[index], depth + 1, false);
	            }
	        }
	        if (this._nextHighestDepth < depth + 1)
	            this._nextHighestDepth = depth + 1;
	        this._depth_childs[depth] = child;
	        this._children.push(child);
	        child._depthID = depth;
	        child.iSetParent(this);
	        this._invalidateChildren();
	        return child;
	    };
	    /**
	     * Adds a child DisplayObject instance to this DisplayObjectContainer
	     * instance. The child is added at the index position specified. An index of
	     * 0 represents the back(bottom) of the display list for this
	     * DisplayObjectContainer object.
	     *
	     * <p>For example, the following example shows three display objects, labeled
	     * a, b, and c, at index positions 0, 2, and 1, respectively:</p>
	     *
	     * <p>If you add a child object that already has a different display object
	     * container as a parent, the object is removed from the child list of the
	     * other display object container. </p>
	     *
	     * @param child The DisplayObject instance to add as a child of this
	     *              DisplayObjectContainer instance.
	     * @param index The index position to which the child is added. If you
	     *              specify a currently occupied index position, the child object
	     *              that exists at that position and all higher positions are
	     *              moved up one position in the child list.
	     * @return The DisplayObject instance that you pass in the <code>child</code>
	     *         parameter.
	     * @throws ArgumentError Throws if the child is the same as the parent. Also
	     *                       throws if the caller is a child(or grandchild etc.)
	     *                       of the child being added.
	     * @throws RangeError    Throws if the index position does not exist in the
	     *                       child list.
	     * @event added Dispatched when a display object is added to the display
	     *              list.
	     */
	    DisplayObjectContainer.prototype.addChildAt = function (child, index) {
	        return this.addChildAtDepth(child, (index < this._children.length) ? this._children[index]._depthID : this.getNextHighestDepth(), false);
	    };
	    DisplayObjectContainer.prototype.addChildren = function () {
	        var childarray = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            childarray[_i - 0] = arguments[_i];
	        }
	        var len = childarray.length;
	        for (var i = 0; i < len; i++)
	            this.addChild(childarray[i]);
	    };
	    /**
	     *
	     */
	    DisplayObjectContainer.prototype.clone = function () {
	        var newInstance = new DisplayObjectContainer();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    DisplayObjectContainer.prototype.copyTo = function (newInstance) {
	        _super.prototype.copyTo.call(this, newInstance);
	        newInstance.mouseChildren = this._mouseChildren;
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            newInstance.addChild(this._children[i].clone());
	    };
	    /**
	     * Determines whether the specified display object is a child of the
	     * DisplayObjectContainer instance or the instance itself. The search
	     * includes the entire display list including this DisplayObjectContainer
	     * instance. Grandchildren, great-grandchildren, and so on each return
	     * <code>true</code>.
	     *
	     * @param child The child object to test.
	     * @return <code>true</code> if the <code>child</code> object is a child of
	     *         the DisplayObjectContainer or the container itself; otherwise
	     *         <code>false</code>.
	     */
	    DisplayObjectContainer.prototype.contains = function (child) {
	        return this._children.indexOf(child) >= 0;
	    };
	    /**
	     *
	     */
	    DisplayObjectContainer.prototype.disposeValues = function () {
	        for (var i = this._children.length - 1; i >= 0; i--)
	            this.removeChild(this._children[i]);
	        _super.prototype.disposeValues.call(this);
	    };
	    DisplayObjectContainer.prototype.getChildAtDepth = function (depth) {
	        return this._depth_childs[depth];
	    };
	    /**
	     * Returns the child display object instance that exists at the specified
	     * index.
	     *
	     * @param index The index position of the child object.
	     * @return The child display object at the specified index position.
	     * @throws RangeError    Throws if the index does not exist in the child
	     *                       list.
	     */
	    DisplayObjectContainer.prototype.getChildAt = function (index) {
	        var child = this._children[index];
	        if (child == null)
	            throw new RangeError_1.RangeError("Index does not exist in the child list of the caller");
	        return child;
	    };
	    /**
	     * Returns the child display object that exists with the specified name. If
	     * more that one child display object has the specified name, the method
	     * returns the first object in the child list.
	     *
	     * <p>The <code>getChildAt()</code> method is faster than the
	     * <code>getChildByName()</code> method. The <code>getChildAt()</code> method
	     * accesses a child from a cached array, whereas the
	     * <code>getChildByName()</code> method has to traverse a linked list to
	     * access a child.</p>
	     *
	     * @param name The name of the child to return.
	     * @return The child display object with the specified name.
	     */
	    DisplayObjectContainer.prototype.getChildByName = function (name) {
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            if (this._children[i].name == name)
	                return this._children[i];
	        return null;
	    };
	    /**
	     * Returns the index position of a <code>child</code> DisplayObject instance.
	     *
	     * @param child The DisplayObject instance to identify.
	     * @return The index position of the child display object to identify.
	     * @throws ArgumentError Throws if the child parameter is not a child of this
	     *                       object.
	     */
	    DisplayObjectContainer.prototype.getChildIndex = function (child) {
	        var childIndex = this._children.indexOf(child);
	        if (childIndex == -1)
	            throw new ArgumentError_1.ArgumentError("Child parameter is not a child of the caller");
	        return childIndex;
	    };
	    DisplayObjectContainer.prototype.getNextHighestDepth = function () {
	        if (this._nextHighestDepthDirty)
	            this._updateNextHighestDepth();
	        return this._nextHighestDepth;
	    };
	    /**
	     * Returns an array of objects that lie under the specified point and are
	     * children(or grandchildren, and so on) of this DisplayObjectContainer
	     * instance. Any child objects that are inaccessible for security reasons are
	     * omitted from the returned array. To determine whether this security
	     * restriction affects the returned array, call the
	     * <code>areInaccessibleObjectsUnderPoint()</code> method.
	     *
	     * <p>The <code>point</code> parameter is in the coordinate space of the
	     * Stage, which may differ from the coordinate space of the display object
	     * container(unless the display object container is the Stage). You can use
	     * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
	     * methods to convert points between these coordinate spaces.</p>
	     *
	     * @param point The point under which to look.
	     * @return An array of objects that lie under the specified point and are
	     *         children(or grandchildren, and so on) of this
	     *         DisplayObjectContainer instance.
	     */
	    DisplayObjectContainer.prototype.getObjectsUnderPoint = function (point) {
	        return new Array();
	    };
	    /**
	     * Removes the specified <code>child</code> DisplayObject instance from the
	     * child list of the DisplayObjectContainer instance. The <code>parent</code>
	     * property of the removed child is set to <code>null</code> , and the object
	     * is garbage collected if no other references to the child exist. The index
	     * positions of any display objects above the child in the
	     * DisplayObjectContainer are decreased by 1.
	     *
	     * <p>The garbage collector reallocates unused memory space. When a variable
	     * or object is no longer actively referenced or stored somewhere, the
	     * garbage collector sweeps through and wipes out the memory space it used to
	     * occupy if no other references to it exist.</p>
	     *
	     * @param child The DisplayObject instance to remove.
	     * @return The DisplayObject instance that you pass in the <code>child</code>
	     *         parameter.
	     * @throws ArgumentError Throws if the child parameter is not a child of this
	     *                       object.
	     */
	    DisplayObjectContainer.prototype.removeChild = function (child) {
	        if (child == null)
	            throw new ArgumentError_1.ArgumentError("Parameter child cannot be null");
	        this.removeChildAt(this.getChildIndex(child));
	        return child;
	    };
	    DisplayObjectContainer.prototype.removeChildAtDepth = function (depth) {
	        return this.removeChildAt(this.getDepthIndexInternal(depth));
	    };
	    /**
	     * Removes a child DisplayObject from the specified <code>index</code>
	     * position in the child list of the DisplayObjectContainer. The
	     * <code>parent</code> property of the removed child is set to
	     * <code>null</code>, and the object is garbage collected if no other
	     * references to the child exist. The index positions of any display objects
	     * above the child in the DisplayObjectContainer are decreased by 1.
	     *
	     * <p>The garbage collector reallocates unused memory space. When a variable
	     * or object is no longer actively referenced or stored somewhere, the
	     * garbage collector sweeps through and wipes out the memory space it used to
	     * occupy if no other references to it exist.</p>
	     *
	     * @param index The child index of the DisplayObject to remove.
	     * @return The DisplayObject instance that was removed.
	     * @throws RangeError    Throws if the index does not exist in the child
	     *                       list.
	     * @throws SecurityError This child display object belongs to a sandbox to
	     *                       which the calling object does not have access. You
	     *                       can avoid this situation by having the child movie
	     *                       call the <code>Security.allowDomain()</code> method.
	     */
	    DisplayObjectContainer.prototype.removeChildAt = function (index) {
	        var child = this.removeChildAtInternal(index);
	        child.iSetParent(null);
	        this._invalidateChildren();
	        return child;
	    };
	    /**
	     * Removes all <code>child</code> DisplayObject instances from the child list
	     * of the DisplayObjectContainer instance. The <code>parent</code> property
	     * of the removed children is set to <code>null</code>, and the objects are
	     * garbage collected if no other references to the children exist.
	     *
	     * The garbage collector reallocates unused memory space. When a variable or
	     * object is no longer actively referenced or stored somewhere, the garbage
	     * collector sweeps through and wipes out the memory space it used to occupy
	     * if no other references to it exist.
	     *
	     * @param beginIndex The beginning position. A value smaller than 0 throws a RangeError.
	     * @param endIndex The ending position. A value smaller than 0 throws a RangeError.
	     * @throws RangeError    Throws if the beginIndex or endIndex positions do
	     *                       not exist in the child list.
	     */
	    DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {
	        if (beginIndex === void 0) { beginIndex = 0; }
	        if (endIndex === void 0) { endIndex = 2147483647; }
	        if (beginIndex < 0)
	            throw new RangeError_1.RangeError("beginIndex is out of range of the child list");
	        if (endIndex > this._children.length)
	            throw new RangeError_1.RangeError("endIndex is out of range of the child list");
	        for (var i = beginIndex; i < endIndex; i++)
	            this.removeChild(this._children[i]);
	    };
	    /**
	     * Changes the position of an existing child in the display object container.
	     * This affects the layering of child objects. For example, the following
	     * example shows three display objects, labeled a, b, and c, at index
	     * positions 0, 1, and 2, respectively:
	     *
	     * <p>When you use the <code>setChildIndex()</code> method and specify an
	     * index position that is already occupied, the only positions that change
	     * are those in between the display object's former and new position. All
	     * others will stay the same. If a child is moved to an index LOWER than its
	     * current index, all children in between will INCREASE by 1 for their index
	     * reference. If a child is moved to an index HIGHER than its current index,
	     * all children in between will DECREASE by 1 for their index reference. For
	     * example, if the display object container in the previous example is named
	     * <code>container</code>, you can swap the position of the display objects
	     * labeled a and b by calling the following code:</p>
	     *
	     * <p>This code results in the following arrangement of objects:</p>
	     *
	     * @param child The child DisplayObject instance for which you want to change
	     *              the index number.
	     * @param index The resulting index number for the <code>child</code> display
	     *              object.
	     * @throws ArgumentError Throws if the child parameter is not a child of this
	     *                       object.
	     * @throws RangeError    Throws if the index does not exist in the child
	     *                       list.
	     */
	    DisplayObjectContainer.prototype.setChildIndex = function (child, index) {
	        //TODO
	    };
	    /**
	     * Swaps the z-order (front-to-back order) of the two specified child
	     * objects. All other child objects in the display object container remain in
	     * the same index positions.
	     *
	     * @param child1 The first child object.
	     * @param child2 The second child object.
	     * @throws ArgumentError Throws if either child parameter is not a child of
	     *                       this object.
	     */
	    DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
	        this.swapChildrenAt(this.getChildIndex(child1), this.getChildIndex(child2));
	    };
	    /**
	     * Swaps the z-order(front-to-back order) of the child objects at the two
	     * specified index positions in the child list. All other child objects in
	     * the display object container remain in the same index positions.
	     *
	     * @param index1 The index position of the first child object.
	     * @param index2 The index position of the second child object.
	     * @throws RangeError If either index does not exist in the child list.
	     */
	    DisplayObjectContainer.prototype.swapChildrenAt = function (index1, index2) {
	        var depth = this._children[index2]._depthID;
	        var child = this._children[index1];
	        this.addChildAtDepth(this._children[index2], this._children[index1]._depthID);
	        this.addChildAtDepth(child, depth);
	    };
	    /**
	     * //TODO
	     *
	     * @protected
	     */
	    DisplayObjectContainer.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        var box;
	        var numChildren = this._children.length;
	        if (numChildren > 0) {
	            var min;
	            var max;
	            var minX, minY, minZ;
	            var maxX, maxY, maxZ;
	            for (var i = 0; i < numChildren; ++i) {
	                box = this._children[i].getBox(this);
	                if (i == 0) {
	                    maxX = box.width + (minX = box.x);
	                    maxY = box.height + (minY = box.y);
	                    maxZ = box.depth + (minZ = box.z);
	                }
	                else {
	                    max = box.width + (min = box.x);
	                    if (min < minX)
	                        minX = min;
	                    if (max > maxX)
	                        maxX = max;
	                    max = box.height + (min = box.y);
	                    if (min < minY)
	                        minY = min;
	                    if (max > maxY)
	                        maxY = max;
	                    max = box.depth + (min = box.z);
	                    if (min < minZ)
	                        minZ = min;
	                    if (max > maxZ)
	                        maxZ = max;
	                }
	            }
	            this._pBoxBounds.width = maxX - (this._pBoxBounds.x = minX);
	            this._pBoxBounds.height = maxY - (this._pBoxBounds.y = minY);
	            this._pBoxBounds.depth = maxZ - (this._pBoxBounds.z = minZ);
	        }
	        else {
	            this._pBoxBounds.setBoundIdentity();
	        }
	    };
	    /**
	     * @protected
	     */
	    DisplayObjectContainer.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
	        if (_super.prototype.pInvalidateHierarchicalProperties.call(this, propDirty))
	            return true;
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            this._children[i].pInvalidateHierarchicalProperties(propDirty);
	        return false;
	    };
	    /**
	     * @internal
	     */
	    DisplayObjectContainer.prototype._iSetScene = function (value, partition) {
	        _super.prototype._iSetScene.call(this, value, partition);
	        var len = this._children.length;
	        for (var i = 0; i < len; ++i)
	            this._children[i]._iSetScene(value, this._pPartition);
	    };
	    /**
	     * @private
	     *
	     * @param child
	     */
	    DisplayObjectContainer.prototype.removeChildAtInternal = function (index) {
	        var child = this._children.splice(index, 1)[0];
	        //update next highest depth
	        if (this._nextHighestDepth == child._depthID + 1)
	            this._nextHighestDepthDirty = true;
	        delete this._depth_childs[child._depthID];
	        child._depthID = -16384;
	        return child;
	    };
	    DisplayObjectContainer.prototype.getDepthIndexInternal = function (depth) {
	        if (!this._depth_childs[depth])
	            return -1;
	        return this._children.indexOf(this._depth_childs[depth]);
	    };
	    DisplayObjectContainer.prototype._updateNextHighestDepth = function () {
	        this._nextHighestDepthDirty = false;
	        this._nextHighestDepth = 0;
	        var len = this._children.length;
	        for (var i = 0; i < len; i++)
	            if (this._nextHighestDepth < this._children[i]._depthID)
	                this._nextHighestDepth = this._children[i]._depthID;
	        this._nextHighestDepth += 1;
	    };
	    DisplayObjectContainer.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
	        var numChildren = this._children.length;
	        for (var i = 0; i < numChildren; i++)
	            if (this._children[i].hitTestPoint(x, y, shapeFlag, masksFlag))
	                return true;
	        return false;
	    };
	    DisplayObjectContainer.prototype._updateMaskMode = function () {
	        if (this.maskMode)
	            this.mouseChildren = false;
	        _super.prototype._updateMaskMode.call(this);
	    };
	    DisplayObjectContainer.prototype._invalidateChildren = function () {
	        if (this._pIsContainer != Boolean(this._children.length)) {
	            if (this._pScene)
	                this._pScene._iUnregisterObject(this);
	            this._pIsContainer = Boolean(this._children.length);
	            if (this._pScene)
	                this._pScene._iRegisterObject(this);
	        }
	        this._pInvalidateBounds();
	    };
	    DisplayObjectContainer.assetType = "[asset DisplayObjectContainer]";
	    return DisplayObjectContainer;
	}(DisplayObject_1.DisplayObject));
	exports.DisplayObjectContainer = DisplayObjectContainer;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	/**
	 * RangeError is thrown when an index is accessed out of range of the number of
	 * available indices on an Array.
	 */
	var RangeError = (function (_super) {
	    __extends(RangeError, _super);
	    /**
	     * Create a new RangeError.
	     *
	     * @param message An optional message to override the default error message.
	     * @param id The id of the error.
	     */
	    function RangeError(message, id) {
	        if (message === void 0) { message = null; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, message || "RangeError", id);
	    }
	    return RangeError;
	}(ErrorBase_1.ErrorBase));
	exports.RangeError = RangeError;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	/**
	 * @class away.events.CameraEvent
	 */
	var CameraEvent = (function (_super) {
	    __extends(CameraEvent, _super);
	    function CameraEvent(type, camera) {
	        _super.call(this, type);
	        this._camera = camera;
	    }
	    Object.defineProperty(CameraEvent.prototype, "camera", {
	        get: function () {
	            return this._camera;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     * @return An exact duplicate of the current object.
	     */
	    CameraEvent.prototype.clone = function () {
	        return new CameraEvent(this.type, this._camera);
	    };
	    CameraEvent.PROJECTION_CHANGED = "projectionChanged";
	    return CameraEvent;
	}(EventBase_1.EventBase));
	exports.CameraEvent = CameraEvent;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Matrix3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(34);
	var LightBase_1 = __webpack_require__(150);
	var HierarchicalProperties_1 = __webpack_require__(22);
	var BoundsType_1 = __webpack_require__(115);
	var DirectionalShadowMapper_1 = __webpack_require__(152);
	var DirectionalLight = (function (_super) {
	    __extends(DirectionalLight, _super);
	    function DirectionalLight(xDir, yDir, zDir) {
	        if (xDir === void 0) { xDir = 0; }
	        if (yDir === void 0) { yDir = -1; }
	        if (zDir === void 0) { zDir = 1; }
	        _super.call(this);
	        this._pAabbPoints = new Array(24);
	        this._pIsEntity = true;
	        this.direction = new Vector3D_1.Vector3D(xDir, yDir, zDir);
	        this._sceneDirection = new Vector3D_1.Vector3D();
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.NULL;
	    }
	    Object.defineProperty(DirectionalLight.prototype, "assetType", {
	        get: function () {
	            return DirectionalLight.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
	        get: function () {
	            if (this._hierarchicalPropsDirty & HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM)
	                this.pUpdateSceneTransform();
	            return this._sceneDirection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalLight.prototype, "direction", {
	        get: function () {
	            return this._direction;
	        },
	        set: function (value) {
	            this._direction = value;
	            if (!this._tmpLookAt)
	                this._tmpLookAt = new Vector3D_1.Vector3D();
	            this._tmpLookAt.x = this.x + this._direction.x;
	            this._tmpLookAt.y = this.y + this._direction.y;
	            this._tmpLookAt.z = this.z + this._direction.z;
	            this.lookAt(this._tmpLookAt);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    DirectionalLight.prototype.pUpdateSceneTransform = function () {
	        _super.prototype.pUpdateSceneTransform.call(this);
	        this.sceneTransform.copyColumnTo(2, this._sceneDirection);
	        this._sceneDirection.normalize();
	    };
	    //@override
	    DirectionalLight.prototype.pCreateShadowMapper = function () {
	        return new DirectionalShadowMapper_1.DirectionalShadowMapper();
	    };
	    //override
	    DirectionalLight.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        var raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        var m = new Matrix3D_1.Matrix3D();
	        m.copyFrom(entity.getRenderSceneTransform(cameraTransform));
	        m.append(this.inverseSceneTransform);
	        if (!this._projAABBPoints)
	            this._projAABBPoints = [];
	        m.transformVectors(this._pAabbPoints, this._projAABBPoints);
	        var xMin = Infinity, xMax = -Infinity;
	        var yMin = Infinity, yMax = -Infinity;
	        var zMin = Infinity, zMax = -Infinity;
	        var d;
	        for (var i = 0; i < 24;) {
	            d = this._projAABBPoints[i++];
	            if (d < xMin)
	                xMin = d;
	            if (d > xMax)
	                xMax = d;
	            d = this._projAABBPoints[i++];
	            if (d < yMin)
	                yMin = d;
	            if (d > yMax)
	                yMax = d;
	            d = this._projAABBPoints[i++];
	            if (d < zMin)
	                zMin = d;
	            if (d > zMax)
	                zMax = d;
	        }
	        var invXRange = 1 / (xMax - xMin);
	        var invYRange = 1 / (yMax - yMin);
	        var invZRange = 1 / (zMax - zMin);
	        raw[0] = 2 * invXRange;
	        raw[5] = 2 * invYRange;
	        raw[10] = invZRange;
	        raw[12] = -(xMax + xMin) * invXRange;
	        raw[13] = -(yMax + yMin) * invYRange;
	        raw[14] = -zMin * invZRange;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	        raw[15] = 1;
	        if (!target)
	            target = new Matrix3D_1.Matrix3D();
	        target.copyRawDataFrom(raw);
	        target.prepend(m);
	        return target;
	    };
	    /**
	     * //TODO
	     *
	     * @protected
	     */
	    DirectionalLight.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        //update points
	        var minX = this._pBoxBounds.x;
	        var minY = this._pBoxBounds.y - this._pBoxBounds.height;
	        var minZ = this._pBoxBounds.z;
	        var maxX = this._pBoxBounds.x + this._pBoxBounds.width;
	        var maxY = this._pBoxBounds.y;
	        var maxZ = this._pBoxBounds.z + this._pBoxBounds.depth;
	        this._pAabbPoints[0] = minX;
	        this._pAabbPoints[1] = minY;
	        this._pAabbPoints[2] = minZ;
	        this._pAabbPoints[3] = maxX;
	        this._pAabbPoints[4] = minY;
	        this._pAabbPoints[5] = minZ;
	        this._pAabbPoints[6] = minX;
	        this._pAabbPoints[7] = maxY;
	        this._pAabbPoints[8] = minZ;
	        this._pAabbPoints[9] = maxX;
	        this._pAabbPoints[10] = maxY;
	        this._pAabbPoints[11] = minZ;
	        this._pAabbPoints[12] = minX;
	        this._pAabbPoints[13] = minY;
	        this._pAabbPoints[14] = maxZ;
	        this._pAabbPoints[15] = maxX;
	        this._pAabbPoints[16] = minY;
	        this._pAabbPoints[17] = maxZ;
	        this._pAabbPoints[18] = minX;
	        this._pAabbPoints[19] = maxY;
	        this._pAabbPoints[20] = maxZ;
	        this._pAabbPoints[21] = maxX;
	        this._pAabbPoints[22] = maxY;
	        this._pAabbPoints[23] = maxZ;
	    };
	    DirectionalLight.assetType = "[light DirectionalLight]";
	    return DirectionalLight;
	}(LightBase_1.LightBase));
	exports.DirectionalLight = DirectionalLight;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var LightEvent_1 = __webpack_require__(151);
	var LightBase = (function (_super) {
	    __extends(LightBase, _super);
	    function LightBase() {
	        _super.call(this);
	        this._color = 0xffffff;
	        this._colorR = 1;
	        this._colorG = 1;
	        this._colorB = 1;
	        this._ambientColor = 0xffffff;
	        this._ambient = 0;
	        this._iAmbientR = 0;
	        this._iAmbientG = 0;
	        this._iAmbientB = 0;
	        this._specular = 1;
	        this._iSpecularR = 1;
	        this._iSpecularG = 1;
	        this._iSpecularB = 1;
	        this._diffuse = 1;
	        this._iDiffuseR = 1;
	        this._iDiffuseG = 1;
	        this._iDiffuseB = 1;
	        this._shadowsEnabled = false;
	    }
	    Object.defineProperty(LightBase.prototype, "shadowsEnabled", {
	        get: function () {
	            return this._shadowsEnabled;
	        },
	        set: function (value) {
	            if (this._shadowsEnabled == value)
	                return;
	            this._shadowsEnabled = value;
	            if (value) {
	                if (this._shadowMapper == null)
	                    this._shadowMapper = this.pCreateShadowMapper();
	                this._shadowMapper.light = this;
	            }
	            else {
	                this._shadowMapper.dispose();
	                this._shadowMapper = null;
	            }
	            //*/
	            this.dispatchEvent(new LightEvent_1.LightEvent(LightEvent_1.LightEvent.CASTS_SHADOW_CHANGE));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LightBase.prototype.pCreateShadowMapper = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    Object.defineProperty(LightBase.prototype, "specular", {
	        get: function () {
	            return this._specular;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            this._specular = value;
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "diffuse", {
	        get: function () {
	            return this._diffuse;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            this._diffuse = value;
	            this.updateDiffuse();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "color", {
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            this._color = value;
	            this._colorR = ((this._color >> 16) & 0xff) / 0xff;
	            this._colorG = ((this._color >> 8) & 0xff) / 0xff;
	            this._colorB = (this._color & 0xff) / 0xff;
	            this.updateDiffuse();
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "ambient", {
	        get: function () {
	            return this._ambient;
	        },
	        set: function (value) {
	            if (value < 0)
	                value = 0;
	            else if (value > 1)
	                value = 1;
	            this._ambient = value;
	            this.updateAmbient();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightBase.prototype, "ambientColor", {
	        get: function () {
	            return this._ambientColor;
	        },
	        set: function (value) {
	            this._ambientColor = value;
	            this.updateAmbient();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    LightBase.prototype.updateAmbient = function () {
	        this._iAmbientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
	        this._iAmbientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
	        this._iAmbientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
	    };
	    LightBase.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    LightBase.prototype.updateSpecular = function () {
	        this._iSpecularR = this._colorR * this._specular;
	        this._iSpecularG = this._colorG * this._specular;
	        this._iSpecularB = this._colorB * this._specular;
	    };
	    LightBase.prototype.updateDiffuse = function () {
	        this._iDiffuseR = this._colorR * this._diffuse;
	        this._iDiffuseG = this._colorG * this._diffuse;
	        this._iDiffuseB = this._colorB * this._diffuse;
	    };
	    Object.defineProperty(LightBase.prototype, "shadowMapper", {
	        get: function () {
	            return this._shadowMapper;
	        },
	        set: function (value) {
	            this._shadowMapper = value;
	            this._shadowMapper.light = this;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return LightBase;
	}(DisplayObjectContainer_1.DisplayObjectContainer));
	exports.LightBase = LightBase;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var LightEvent = (function (_super) {
	    __extends(LightEvent, _super);
	    function LightEvent(type) {
	        _super.call(this, type);
	    }
	    //@override
	    LightEvent.prototype.clone = function () {
	        return new LightEvent(this.type);
	    };
	    LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";
	    return LightEvent;
	}(EventBase_1.EventBase));
	exports.LightEvent = LightEvent;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(96);
	var Matrix3D_1 = __webpack_require__(32);
	var Matrix3DUtils_1 = __webpack_require__(38);
	var FreeMatrixProjection_1 = __webpack_require__(153);
	var Camera_1 = __webpack_require__(139);
	var ShadowMapperBase_1 = __webpack_require__(154);
	var Single2DTexture_1 = __webpack_require__(136);
	var DirectionalShadowMapper = (function (_super) {
	    __extends(DirectionalShadowMapper, _super);
	    function DirectionalShadowMapper() {
	        _super.call(this);
	        this._pLightOffset = 10000;
	        this._pSnap = 64;
	        this._pCullPlanes = [];
	        this._pOverallDepthProjection = new FreeMatrixProjection_1.FreeMatrixProjection();
	        this._pOverallDepthCamera = new Camera_1.Camera(this._pOverallDepthProjection);
	        this._pLocalFrustum = [];
	        this._pMatrix = new Matrix3D_1.Matrix3D();
	    }
	    Object.defineProperty(DirectionalShadowMapper.prototype, "snap", {
	        get: function () {
	            return this._pSnap;
	        },
	        set: function (value) {
	            this._pSnap = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalShadowMapper.prototype, "lightOffset", {
	        get: function () {
	            return this._pLightOffset;
	        },
	        set: function (value) {
	            this._pLightOffset = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalShadowMapper.prototype, "iDepthProjection", {
	        //@arcane
	        get: function () {
	            return this._pOverallDepthCamera.viewProjection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
	        //@arcane
	        get: function () {
	            return this._pMaxZ - this._pMinZ;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DirectionalShadowMapper.prototype.iSetDepthMap = function (depthMap) {
	        if (this._depthMap == depthMap)
	            return;
	        _super.prototype.iSetDepthMap.call(this, depthMap);
	        if (this._depthMap) {
	            this._explicitDepthMap = true;
	            this._pDepthMapSize = depthMap.image2D.rect.width;
	        }
	        else {
	            this._explicitDepthMap = false;
	        }
	    };
	    DirectionalShadowMapper.prototype.pCreateDepthTexture = function () {
	        return new Single2DTexture_1.Single2DTexture(new Image2D_1.Image2D(this._pDepthMapSize, this._pDepthMapSize));
	    };
	    //@override
	    DirectionalShadowMapper.prototype.pDrawDepthMap = function (view, target, renderer) {
	        renderer.cullPlanes = this._pCullPlanes;
	        renderer._iRender(this._pOverallDepthCamera, view, target.image2D);
	    };
	    //@protected
	    DirectionalShadowMapper.prototype.pUpdateCullPlanes = function (camera) {
	        var lightFrustumPlanes = this._pOverallDepthCamera.frustumPlanes;
	        var viewFrustumPlanes = camera.frustumPlanes;
	        this._pCullPlanes.length = 4;
	        this._pCullPlanes[0] = lightFrustumPlanes[0];
	        this._pCullPlanes[1] = lightFrustumPlanes[1];
	        this._pCullPlanes[2] = lightFrustumPlanes[2];
	        this._pCullPlanes[3] = lightFrustumPlanes[3];
	        var light = this._pLight;
	        var dir = light.sceneDirection;
	        var dirX = dir.x;
	        var dirY = dir.y;
	        var dirZ = dir.z;
	        var j = 4;
	        for (var i = 0; i < 6; ++i) {
	            var plane = viewFrustumPlanes[i];
	            if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0)
	                this._pCullPlanes[j++] = plane;
	        }
	    };
	    //@override
	    DirectionalShadowMapper.prototype.pUpdateDepthProjection = function (camera) {
	        this.pUpdateProjectionFromFrustumCorners(camera, camera.projection.frustumCorners, this._pMatrix);
	        this._pOverallDepthProjection.matrix = this._pMatrix;
	        this.pUpdateCullPlanes(camera);
	    };
	    DirectionalShadowMapper.prototype.pUpdateProjectionFromFrustumCorners = function (camera, corners, matrix) {
	        var raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        var dir;
	        var x, y, z;
	        var minX, minY;
	        var maxX, maxY;
	        var i;
	        var light = this._pLight;
	        dir = light.sceneDirection;
	        this._pOverallDepthCamera.transform.matrix3D = this._pLight.sceneTransform;
	        x = Math.floor((camera.x - dir.x * this._pLightOffset) / this._pSnap) * this._pSnap;
	        y = Math.floor((camera.y - dir.y * this._pLightOffset) / this._pSnap) * this._pSnap;
	        z = Math.floor((camera.z - dir.z * this._pLightOffset) / this._pSnap) * this._pSnap;
	        this._pOverallDepthCamera.x = x;
	        this._pOverallDepthCamera.y = y;
	        this._pOverallDepthCamera.z = z;
	        this._pMatrix.copyFrom(this._pOverallDepthCamera.inverseSceneTransform);
	        this._pMatrix.prepend(camera.sceneTransform);
	        this._pMatrix.transformVectors(corners, this._pLocalFrustum);
	        minX = maxX = this._pLocalFrustum[0];
	        minY = maxY = this._pLocalFrustum[1];
	        this._pMaxZ = this._pLocalFrustum[2];
	        i = 3;
	        while (i < 24) {
	            x = this._pLocalFrustum[i];
	            y = this._pLocalFrustum[i + 1];
	            z = this._pLocalFrustum[i + 2];
	            if (x < minX)
	                minX = x;
	            if (x > maxX)
	                maxX = x;
	            if (y < minY)
	                minY = y;
	            if (y > maxY)
	                maxY = y;
	            if (z > this._pMaxZ)
	                this._pMaxZ = z;
	            i += 3;
	        }
	        this._pMinZ = 1;
	        var w = maxX - minX;
	        var h = maxY - minY;
	        var d = 1 / (this._pMaxZ - this._pMinZ);
	        if (minX < 0)
	            minX -= this._pSnap; // because int() rounds up for < 0
	        if (minY < 0)
	            minY -= this._pSnap;
	        minX = Math.floor(minX / this._pSnap) * this._pSnap;
	        minY = Math.floor(minY / this._pSnap) * this._pSnap;
	        var snap2 = 2 * this._pSnap;
	        w = Math.floor(w / snap2 + 2) * snap2;
	        h = Math.floor(h / snap2 + 2) * snap2;
	        maxX = minX + w;
	        maxY = minY + h;
	        w = 1 / w;
	        h = 1 / h;
	        raw[0] = 2 * w;
	        raw[5] = 2 * h;
	        raw[10] = d;
	        raw[12] = -(maxX + minX) * w;
	        raw[13] = -(maxY + minY) * h;
	        raw[14] = -this._pMinZ * d;
	        raw[15] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	        matrix.copyRawDataFrom(raw);
	    };
	    return DirectionalShadowMapper;
	}(ShadowMapperBase_1.ShadowMapperBase));
	exports.DirectionalShadowMapper = DirectionalShadowMapper;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PerspectiveProjection_1 = __webpack_require__(143);
	var ProjectionBase_1 = __webpack_require__(145);
	var FreeMatrixProjection = (function (_super) {
	    __extends(FreeMatrixProjection, _super);
	    function FreeMatrixProjection() {
	        _super.call(this);
	        this._pMatrix.copyFrom(new PerspectiveProjection_1.PerspectiveProjection().matrix);
	    }
	    Object.defineProperty(FreeMatrixProjection.prototype, "near", {
	        //@override
	        set: function (value) {
	            this._pNear = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FreeMatrixProjection.prototype, "far", {
	        //@override
	        set: function (value) {
	            this._pFar = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FreeMatrixProjection.prototype, "iAspectRatio", {
	        //@override
	        set: function (value) {
	            this._pAspectRatio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    FreeMatrixProjection.prototype.clone = function () {
	        var clone = new FreeMatrixProjection();
	        clone._pMatrix.copyFrom(this._pMatrix);
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        clone.pInvalidateMatrix();
	        return clone;
	    };
	    //@override
	    FreeMatrixProjection.prototype.pUpdateMatrix = function () {
	        this._pMatrixInvalid = false;
	    };
	    return FreeMatrixProjection;
	}(ProjectionBase_1.ProjectionBase));
	exports.FreeMatrixProjection = FreeMatrixProjection;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var AssetBase_1 = __webpack_require__(6);
	var ShadowMapperBase = (function (_super) {
	    __extends(ShadowMapperBase, _super);
	    function ShadowMapperBase() {
	        _super.apply(this, arguments);
	        this._pDepthMapSize = 2048;
	        this._autoUpdateShadows = true;
	    }
	    Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
	        get: function () {
	            return this._autoUpdateShadows;
	        },
	        set: function (value) {
	            this._autoUpdateShadows = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadowMapperBase.prototype.updateShadows = function () {
	        this._iShadowsInvalid = true;
	    };
	    ShadowMapperBase.prototype.iSetDepthMap = function (depthMap) {
	        if (this._depthMap && !this._explicitDepthMap)
	            this._depthMap.dispose();
	        this._depthMap = depthMap;
	    };
	    Object.defineProperty(ShadowMapperBase.prototype, "light", {
	        get: function () {
	            return this._pLight;
	        },
	        set: function (value) {
	            this._pLight = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
	        get: function () {
	            if (!this._depthMap)
	                this._depthMap = this.pCreateDepthTexture();
	            return this._depthMap;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
	        get: function () {
	            return this._pDepthMapSize;
	        },
	        set: function (value) {
	            if (value == this._pDepthMapSize)
	                return;
	            this._pSetDepthMapSize(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadowMapperBase.prototype.dispose = function () {
	        if (this._depthMap && !this._explicitDepthMap)
	            this._depthMap.dispose();
	        this._depthMap = null;
	    };
	    ShadowMapperBase.prototype.pCreateDepthTexture = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ShadowMapperBase.prototype.iRenderDepthMap = function (view, renderer) {
	        this._iShadowsInvalid = false;
	        this.pUpdateDepthProjection(view.camera);
	        if (!this._depthMap)
	            this._depthMap = this.pCreateDepthTexture();
	        this.pDrawDepthMap(view, this._depthMap, renderer);
	    };
	    ShadowMapperBase.prototype.pUpdateDepthProjection = function (camera) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ShadowMapperBase.prototype.pDrawDepthMap = function (view, target, renderer) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ShadowMapperBase.prototype._pSetDepthMapSize = function (value) {
	        this._pDepthMapSize = value;
	        if (this._explicitDepthMap) {
	            throw Error("Cannot set depth map size for the current renderer.");
	        }
	        else if (this._depthMap) {
	            this._depthMap.dispose();
	            this._depthMap = null;
	        }
	    };
	    return ShadowMapperBase;
	}(AssetBase_1.AssetBase));
	exports.ShadowMapperBase = ShadowMapperBase;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SamplerCube_1 = __webpack_require__(156);
	var ErrorBase_1 = __webpack_require__(8);
	var LightBase_1 = __webpack_require__(150);
	var BoundsType_1 = __webpack_require__(115);
	var LightProbe = (function (_super) {
	    __extends(LightProbe, _super);
	    function LightProbe(diffuseMap, specularMap) {
	        if (specularMap === void 0) { specularMap = null; }
	        _super.call(this);
	        this.diffuseSampler = new SamplerCube_1.SamplerCube();
	        this.specularSampler = new SamplerCube_1.SamplerCube();
	        this._pIsEntity = true;
	        this.diffuseMap = diffuseMap;
	        this.specularMap = specularMap;
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.NULL;
	    }
	    Object.defineProperty(LightProbe.prototype, "assetType", {
	        get: function () {
	            return LightProbe.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    LightProbe.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        throw new ErrorBase_1.ErrorBase("Object projection matrices are not supported for LightProbe objects!");
	    };
	    LightProbe.assetType = "[light LightProbe]";
	    return LightProbe;
	}(LightBase_1.LightBase));
	exports.LightProbe = LightProbe;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SamplerBase_1 = __webpack_require__(122);
	/**
	 * The Bitmap export class represents display objects that represent bitmap images.
	 * These can be images that you load with the <code>flash.Assets</code> or
	 * <code>flash.display.Loader</code> classes, or they can be images that you
	 * create with the <code>Bitmap()</code> constructor.
	 *
	 * <p>The <code>Bitmap()</code> constructor allows you to create a Bitmap
	 * object that contains a reference to a BitmapData object. After you create a
	 * Bitmap object, use the <code>addChild()</code> or <code>addChildAt()</code>
	 * method of the parent DisplayObjectContainer instance to place the bitmap on
	 * the display list.</p>
	 *
	 * <p>A Bitmap object can share its BitmapData reference among several Bitmap
	 * objects, independent of translation or rotation properties. Because you can
	 * create multiple Bitmap objects that reference the same BitmapData object,
	 * multiple texture objects can use the same complex BitmapData object without
	 * incurring the memory overhead of a BitmapData object for each texture
	 * object instance.</p>
	
	 */
	var SamplerCube = (function (_super) {
	    __extends(SamplerCube, _super);
	    /**
	     *
	     * @param bitmapData
	     * @param smoothing
	     */
	    function SamplerCube(smooth, mipmap) {
	        if (smooth === void 0) { smooth = false; }
	        if (mipmap === void 0) { mipmap = false; }
	        _super.call(this, smooth, mipmap);
	    }
	    Object.defineProperty(SamplerCube.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return SamplerCube.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    SamplerCube.assetType = "[asset SamplerCube]";
	    return SamplerCube;
	}(SamplerBase_1.SamplerBase));
	exports.SamplerCube = SamplerCube;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DisplayObject_1 = __webpack_require__(113);
	var BoundsType_1 = __webpack_require__(115);
	var RenderableEvent_1 = __webpack_require__(118);
	var StyleEvent_1 = __webpack_require__(25);
	/**
	 * A Line Segment primitive.
	 */
	var LineSegment = (function (_super) {
	    __extends(LineSegment, _super);
	    /**
	     * Create a line segment
	     *
	     * @param startPosition Start position of the line segment
	     * @param endPosition Ending position of the line segment
	     * @param thickness Thickness of the line
	     */
	    function LineSegment(material, startPosition, endPosition, thickness) {
	        var _this = this;
	        if (thickness === void 0) { thickness = 1; }
	        _super.call(this);
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._pIsEntity = true;
	        this.material = material;
	        this._startPosition = startPosition;
	        this._endPosition = endPosition;
	        this._halfThickness = thickness * 0.5;
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.AXIS_ALIGNED_BOX;
	    }
	    Object.defineProperty(LineSegment.prototype, "animator", {
	        /**
	         * Defines the animator of the line segment. Act on the line segment's geometry. Defaults to null
	         */
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineSegment.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return LineSegment.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineSegment.prototype, "startPostion", {
	        /**
	         *
	         */
	        get: function () {
	            return this._startPosition;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineSegment.prototype, "startPosition", {
	        set: function (value) {
	            if (this._startPosition == value)
	                return;
	            this._startPosition = value;
	            this.invalidateElements();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineSegment.prototype, "endPosition", {
	        /**
	         *
	         */
	        get: function () {
	            return this._endPosition;
	        },
	        set: function (value) {
	            if (this._endPosition == value)
	                return;
	            this._endPosition = value;
	            this.invalidateElements();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineSegment.prototype, "material", {
	        /**
	         *
	         */
	        get: function () {
	            return this._material;
	        },
	        set: function (value) {
	            if (this.material)
	                this.material.iRemoveOwner(this);
	            this._material = value;
	            if (this.material)
	                this.material.iAddOwner(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineSegment.prototype, "thickness", {
	        /**
	         *
	         */
	        get: function () {
	            return this._halfThickness * 2;
	        },
	        set: function (value) {
	            if (this._halfThickness == value)
	                return;
	            this._halfThickness = value * 0.5;
	            this.invalidateElements();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LineSegment.prototype, "style", {
	        /**
	         * The style used to render the current LineSegment. If set to null, the default style of the material will be used instead.
	         */
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this.invalidateSurface();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @protected
	     */
	    LineSegment.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        this._pBoxBounds.x = Math.min(this._startPosition.x, this._endPosition.x);
	        this._pBoxBounds.y = Math.min(this._startPosition.y, this._endPosition.y);
	        this._pBoxBounds.z = Math.min(this._startPosition.z, this._endPosition.z);
	        this._pBoxBounds.width = Math.abs(this._startPosition.x - this._endPosition.x);
	        this._pBoxBounds.height = Math.abs(this._startPosition.y - this._endPosition.y);
	        this._pBoxBounds.depth = Math.abs(this._startPosition.z - this._endPosition.z);
	    };
	    LineSegment.prototype._pUpdateSphereBounds = function () {
	        _super.prototype._pUpdateSphereBounds.call(this);
	        this._pUpdateBoxBounds();
	        var halfWidth = (this._endPosition.x - this._startPosition.x) / 2;
	        var halfHeight = (this._endPosition.y - this._startPosition.y) / 2;
	        var halfDepth = (this._endPosition.z - this._startPosition.z) / 2;
	        this._pSphereBounds.x = this._startPosition.x + halfWidth;
	        this._pSphereBounds.y = this._startPosition.y + halfHeight;
	        this._pSphereBounds.z = this._startPosition.z + halfDepth;
	        this._pSphereBounds.radius = Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight + halfDepth * halfDepth);
	    };
	    /**
	     * @private
	     */
	    LineSegment.prototype.invalidateElements = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_ELEMENTS, this)); //TODO improve performance by only using one geometry for all line segments
	    };
	    LineSegment.prototype.invalidateSurface = function () {
	        this.dispatchEvent(new RenderableEvent_1.RenderableEvent(RenderableEvent_1.RenderableEvent.INVALIDATE_SURFACE, this));
	    };
	    LineSegment.prototype._onInvalidateProperties = function (event) {
	        this.invalidateSurface();
	    };
	    /**
	     * //TODO
	     *
	     * @param shortestCollisionDistance
	     * @param findClosest
	     * @returns {boolean}
	     *
	     * @internal
	     */
	    LineSegment.prototype._iTestCollision = function (pickingCollision, pickingCollider) {
	        return false; //TODO: detect line collisions
	    };
	    LineSegment.prototype._acceptTraverser = function (traverser) {
	        traverser.applyRenderable(this);
	    };
	    LineSegment.assetType = "[asset LineSegment]";
	    return LineSegment;
	}(DisplayObject_1.DisplayObject));
	exports.LineSegment = LineSegment;


/***/ },
/* 158 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetLibraryBundle_1 = __webpack_require__(159);
	var Loader_1 = __webpack_require__(161);
	var AssetEvent_1 = __webpack_require__(9);
	var URLLoaderEvent_1 = __webpack_require__(166);
	var LoaderEvent_1 = __webpack_require__(167);
	var ParserEvent_1 = __webpack_require__(168);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	/**
	 * The LoaderContainer class is used to load SWF files or image(JPG, PNG, or GIF)
	 * files. Use the <code>load()</code> method to initiate loading. The loaded
	 * display object is added as a child of the LoaderContainer object.
	 *
	 * <p>Use the URLLoader class to load text or binary data.</p>
	 *
	 * <p>The LoaderContainer class overrides the following methods that it inherits,
	 * because a LoaderContainer object can only have one child display object - the
	 * display object that it loads. Calling the following methods throws an
	 * exception: <code>addChild()</code>, <code>addChildAt()</code>,
	 * <code>removeChild()</code>, <code>removeChildAt()</code>, and
	 * <code>setChildIndex()</code>. To remove a loaded display object, you must
	 * remove the <i>LoaderContainer</i> object from its parent DisplayObjectContainer
	 * child array. </p>
	 *
	 * <p><b>Note:</b> The ActionScript 2.0 MovieClipLoader and LoadVars classes
	 * are not used in ActionScript 3.0. The LoaderContainer and URLLoader classes replace
	 * them.</p>
	 *
	 * <p>When you use the LoaderContainer class, consider the Flash Player and Adobe AIR
	 * security model: </p>
	 *
	 * <ul>
	 *   <li>You can load content from any accessible source. </li>
	 *   <li>Loading is not allowed if the calling SWF file is in a network
	 * sandbox and the file to be loaded is local. </li>
	 *   <li>If the loaded content is a SWF file written with ActionScript 3.0, it
	 * cannot be cross-scripted by a SWF file in another security sandbox unless
	 * that cross-scripting arrangement was approved through a call to the
	 * <code>System.allowDomain()</code> or the
	 * <code>System.allowInsecureDomain()</code> method in the loaded content
	 * file.</li>
	 *   <li>If the loaded content is an AVM1 SWF file(written using ActionScript
	 * 1.0 or 2.0), it cannot be cross-scripted by an AVM2 SWF file(written using
	 * ActionScript 3.0). However, you can communicate between the two SWF files
	 * by using the LocalConnection class.</li>
	 *   <li>If the loaded content is an image, its data cannot be accessed by a
	 * SWF file outside of the security sandbox, unless the domain of that SWF
	 * file was included in a URL policy file at the origin domain of the
	 * image.</li>
	 *   <li>Movie clips in the local-with-file-system sandbox cannot script movie
	 * clips in the local-with-networking sandbox, and the reverse is also
	 * prevented. </li>
	 *   <li>You cannot connect to commonly reserved ports. For a complete list of
	 * blocked ports, see "Restricting Networking APIs" in the <i>ActionScript 3.0
	 * Developer's Guide</i>. </li>
	 * </ul>
	 *
	 * <p>However, in AIR, content in the <code>application</code> security
	 * sandbox(content installed with the AIR application) are not restricted by
	 * these security limitations.</p>
	 *
	 * <p>For more information related to security, see the Flash Player Developer
	 * Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
	 * scope="external">Security</a>.</p>
	 *
	 * <p>When loading a SWF file from an untrusted source(such as a domain other
	 * than that of the LoaderContainer object's root SWF file), you may want to define a
	 * mask for the LoaderContainer object, to prevent the loaded content(which is a child
	 * of the LoaderContainer object) from drawing to portions of the Stage outside of that
	 * mask, as shown in the following code:</p>
	 */
	var LoaderContainer = (function (_super) {
	    __extends(LoaderContainer, _super);
	    /**
	     * Creates a Loader object that you can use to load files, such as SWF, JPEG,
	     * GIF, or PNG files. Call the <code>load()</code> method to load the asset
	     * as a child of the Loader instance. You can then add the Loader object to
	     * the display list(for instance, by using the <code>addChild()</code>
	     * method of a DisplayObjectContainer instance). The asset appears on the
	     * Stage as it loads.
	     *
	     * <p>You can also use a Loader instance "offlist," that is without adding it
	     * to a display object container on the display list. In this mode, the
	     * Loader instance might be used to load a SWF file that contains additional
	     * modules of an application. </p>
	     *
	     * <p>To detect when the SWF file is finished loading, you can use the events
	     * of the LoaderInfo object associated with the
	     * <code>contentLoaderInfo</code> property of the Loader object. At that
	     * point, the code in the module SWF file can be executed to initialize and
	     * start the module. In the offlist mode, a Loader instance might also be
	     * used to load a SWF file that contains components or media assets. Again,
	     * you can use the LoaderInfo object event notifications to detect when the
	     * components are finished loading. At that point, the application can start
	     * using the components and media assets in the library of the SWF file by
	     * instantiating the ActionScript 3.0 classes that represent those components
	     * and assets.</p>
	     *
	     * <p>To determine the status of a Loader object, monitor the following
	     * events that the LoaderInfo object associated with the
	     * <code>contentLoaderInfo</code> property of the Loader object:</p>
	     *
	     * <ul>
	     *   <li>The <code>open</code> event is dispatched when loading begins.</li>
	     *   <li>The <code>ioError</code> or <code>securityError</code> event is
	     * dispatched if the file cannot be loaded or if an error occured during the
	     * load process. </li>
	     *   <li>The <code>progress</code> event fires continuously while the file is
	     * being loaded.</li>
	     *   <li>The <code>complete</code> event is dispatched when a file completes
	     * downloading, but before the loaded movie clip's methods and properties are
	     * available. </li>
	     *   <li>The <code>init</code> event is dispatched after the properties and
	     * methods of the loaded SWF file are accessible, so you can begin
	     * manipulating the loaded SWF file. This event is dispatched before the
	     * <code>complete</code> handler. In streaming SWF files, the
	     * <code>init</code> event can occur significantly earlier than the
	     * <code>complete</code> event. For most purposes, use the <code>init</code>
	     * handler.</li>
	     * </ul>
	     */
	    function LoaderContainer(useAssetLibrary, assetLibraryId) {
	        var _this = this;
	        if (useAssetLibrary === void 0) { useAssetLibrary = true; }
	        if (assetLibraryId === void 0) { assetLibraryId = null; }
	        _super.call(this);
	        this._useAssetLib = useAssetLibrary;
	        this._assetLibId = assetLibraryId;
	        this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
	        this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
	        this._onLoadCompleteDelegate = function (event) { return _this.onLoadComplete(event); };
	        this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
	        this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
	    }
	    Object.defineProperty(LoaderContainer.prototype, "content", {
	        /**
	         * Contains the root display object of the SWF file or image(JPG, PNG, or
	         * GIF) file that was loaded by using the <code>load()</code> or
	         * <code>loadBytes()</code> methods.
	         *
	         * @throws SecurityError The loaded SWF file or image file belongs to a
	         *                       security sandbox to which you do not have access.
	         *                       For a loaded SWF file, you can avoid this situation
	         *                       by having the file call the
	         *                       <code>Security.allowDomain()</code> method or by
	         *                       having the loading file specify a
	         *                       <code>loaderContext</code> parameter with its
	         *                       <code>securityDomain</code> property set to
	         *                       <code>SecurityDomain.currentDomain</code> when you
	         *                       call the <code>load()</code> or
	         *                       <code>loadBytes()</code> method.
	         */
	        get: function () {
	            return this._content;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Cancels a <code>load()</code> method operation that is currently in
	     * progress for the Loader instance.
	     *
	     */
	    LoaderContainer.prototype.close = function () {
	        if (!this._loader)
	            return;
	        if (this._useAssetLib) {
	            var lib;
	            lib = AssetLibraryBundle_1.AssetLibraryBundle.getInstance(this._assetLibId);
	            lib.disposeLoader(this._loader);
	        }
	        this._disposeLoader();
	    };
	    /**
	     * Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an
	     * object that is a child of this Loader object. If you load an animated GIF
	     * file, only the first frame is displayed. As the Loader object can contain
	     * only a single child, issuing a subsequent <code>load()</code> request
	     * terminates the previous request, if still pending, and commences a new
	     * load.
	     *
	     * <p><b>Note</b>: In AIR 1.5 and Flash Player 10, the maximum size for a
	     * loaded image is 8,191 pixels in width or height, and the total number of
	     * pixels cannot exceed 16,777,215 pixels.(So, if an loaded image is 8,191
	     * pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and
	     * earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height
	     * and 2,880 pixels in width.</p>
	     *
	     * <p>A SWF file or image loaded into a Loader object inherits the position,
	     * rotation, and scale properties of the parent display objects of the Loader
	     * object. </p>
	     *
	     * <p>Use the <code>unload()</code> method to remove movies or images loaded
	     * with this method, or to cancel a load operation that is in progress.</p>
	     *
	     * <p>You can prevent a SWF file from using this method by setting the
	     * <code>allowNetworking</code> parameter of the the <code>object</code> and
	     * <code>embed</code> tags in the HTML page that contains the SWF
	     * content.</p>
	     *
	     * <p>When you use this method, consider the Flash Player security model,
	     * which is described in the Loader class description. </p>
	     *
	     * <p> In Flash Player 10 and later, if you use a multipart Content-Type(for
	     * example "multipart/form-data") that contains an upload(indicated by a
	     * "filename" parameter in a "content-disposition" header within the POST
	     * body), the POST operation is subject to the security rules applied to
	     * uploads:</p>
	     *
	     * <ul>
	     *   <li>The POST operation must be performed in response to a user-initiated
	     * action, such as a mouse click or key press.</li>
	     *   <li>If the POST operation is cross-domain(the POST target is not on the
	     * same server as the SWF file that is sending the POST request), the target
	     * server must provide a URL policy file that permits cross-domain
	     * access.</li>
	     * </ul>
	     *
	     * <p>Also, for any multipart Content-Type, the syntax must be valid
	     * (according to the RFC2046 standard). If the syntax appears to be invalid,
	     * the POST operation is subject to the security rules applied to
	     * uploads.</p>
	     *
	     * <p>For more information related to security, see the Flash Player
	     * Developer Center Topic: <a
	     * href="http://www.adobe.com/go/devnet_security_en"
	     * scope="external">Security</a>.</p>
	     *
	     * @param request The absolute or relative URL of the SWF, JPEG, GIF, or PNG
	     *                file to be loaded. A relative path must be relative to the
	     *                main SWF file. Absolute URLs must include the protocol
	     *                reference, such as http:// or file:///. Filenames cannot
	     *                include disk drive specifications.
	     * @param context A LoaderContext object, which has properties that define
	     *                the following:
	     *                <ul>
	     *                  <li>Whether or not to check for the existence of a policy
	     *                file upon loading the object</li>
	     *                  <li>The ApplicationDomain for the loaded object</li>
	     *                  <li>The SecurityDomain for the loaded object</li>
	     *                  <li>The ImageDecodingPolicy for the loaded image
	     *                object</li>
	     *                </ul>
	     *
	     *                <p>If the <code>context</code> parameter is not specified
	     *                or refers to a null object, the loaded content remains in
	     *                its own security domain.</p>
	     *
	     *                <p>For complete details, see the description of the
	     *                properties in the <a
	     *                href="../system/LoaderContext.html">LoaderContext</a>
	     *                class.</p>
	     * @param ns      An optional namespace string under which the file is to be
	     *                loaded, allowing the differentiation of two resources with
	     *                identical assets.
	     * @param parser  An optional parser object for translating the loaded data
	     *                into a usable resource. If not provided, Loader will
	     *                attempt to auto-detect the file type.
	     * @throws IOError               The <code>digest</code> property of the
	     *                               <code>request</code> object is not
	     *                               <code>null</code>. You should only set the
	     *                               <code>digest</code> property of a URLRequest
	     *                               object when calling the
	     *                               <code>URLLoader.load()</code> method when
	     *                               loading a SWZ file(an Adobe platform
	     *                               component).
	     * @throws IllegalOperationError If the <code>requestedContentParent</code>
	     *                               property of the <code>context</code>
	     *                               parameter is a <code>Loader</code>.
	     * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
	     *                               parameter is set to non-null and has some
	     *                               values which are not Strings.
	     * @throws SecurityError         The value of
	     *                               <code>LoaderContext.securityDomain</code>
	     *                               must be either <code>null</code> or
	     *                               <code>SecurityDomain.currentDomain</code>.
	     *                               This reflects the fact that you can only
	     *                               place the loaded media in its natural
	     *                               security sandbox or your own(the latter
	     *                               requires a policy file).
	     * @throws SecurityError         Local SWF files may not set
	     *                               LoaderContext.securityDomain to anything
	     *                               other than <code>null</code>. It is not
	     *                               permitted to import non-local media into a
	     *                               local sandbox, or to place other local media
	     *                               in anything other than its natural sandbox.
	     * @throws SecurityError         You cannot connect to commonly reserved
	     *                               ports. For a complete list of blocked ports,
	     *                               see "Restricting Networking APIs" in the
	     *                               <i>ActionScript 3.0 Developer's Guide</i>.
	     * @throws SecurityError         If the <code>applicationDomain</code> or
	     *                               <code>securityDomain</code> properties of
	     *                               the <code>context</code> parameter are from
	     *                               a disallowed domain.
	     * @throws SecurityError         If a local SWF file is attempting to use the
	     *                               <code>securityDomain</code> property of the
	     *                               <code>context</code> parameter.
	     * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
	     *                      object if the
	     *                      <code>LoaderContext.requestedContentParent</code>
	     *                      property has been specified and it is not possible to
	     *                      add the loaded content as a child to the specified
	     *                      DisplayObjectContainer. This could happen if the
	     *                      loaded content is a
	     *                      <code>flash.display.AVM1Movie</code> or if the
	     *                      <code>addChild()</code> call to the
	     *                      requestedContentParent throws an error.
	     * @event complete      Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when the file has completed loading. The
	     *                      <code>complete</code> event is always dispatched
	     *                      after the <code>init</code> event.
	     * @event httpStatus    Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when a network request is made over HTTP and
	     *                      Flash Player can detect the HTTP status code.
	     * @event init          Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when the properties and methods of the loaded
	     *                      SWF file are accessible. The <code>init</code> event
	     *                      always precedes the <code>complete</code> event.
	     * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when an input or output error occurs that
	     *                      causes a load operation to fail.
	     * @event open          Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when the loading operation starts.
	     * @event progress      Dispatched by the <code>contentLoaderInfo</code>
	     *                      object as data is received while load operation
	     *                      progresses.
	     * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	     *                      object if a SWF file in the local-with-filesystem
	     *                      sandbox attempts to load content in the
	     *                      local-with-networking sandbox, or vice versa.
	     * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	     *                      object if the
	     *                      <code>LoaderContext.requestedContentParent</code>
	     *                      property has been specified and the security sandbox
	     *                      of the
	     *                      <code>LoaderContext.requestedContentParent</code>
	     *                      does not have access to the loaded SWF.
	     * @event unload        Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when a loaded object is removed.
	     */
	    LoaderContainer.prototype.load = function (request, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this._getLoader().load(request, context, ns, parser);
	    };
	    /**
	     * Loads from binary data stored in a ByteArray object.
	     *
	     * <p>The <code>loadBytes()</code> method is asynchronous. You must wait for
	     * the "init" event before accessing the properties of a loaded object.</p>
	     *
	     * <p>When you use this method, consider the Flash Player security model,
	     * which is described in the Loader class description. </p>
	     *
	     * @param bytes   A ByteArray object. The contents of the ByteArray can be
	     *                any of the file formats supported by the Loader class: SWF,
	     *                GIF, JPEG, or PNG.
	     * @param context A LoaderContext object. Only the
	     *                <code>applicationDomain</code> property of the
	     *                LoaderContext object applies; the
	     *                <code>checkPolicyFile</code> and
	     *                <code>securityDomain</code> properties of the LoaderContext
	     *                object do not apply.
	     *
	     *                <p>If the <code>context</code> parameter is not specified
	     *                or refers to a null object, the content is loaded into the
	     *                current security domain -  a process referred to as "import
	     *                loading" in Flash Player security documentation.
	     *                Specifically, if the loading SWF file trusts the remote SWF
	     *                by incorporating the remote SWF into its code, then the
	     *                loading SWF can import it directly into its own security
	     *                domain.</p>
	     *
	     *                <p>For more information related to security, see the Flash
	     *                Player Developer Center Topic: <a
	     *                href="http://www.adobe.com/go/devnet_security_en"
	     *                scope="external">Security</a>.</p>
	     * @throws ArgumentError         If the <code>length</code> property of the
	     *                               ByteArray object is not greater than 0.
	     * @throws IllegalOperationError If the <code>checkPolicyFile</code> or
	     *                               <code>securityDomain</code> property of the
	     *                               <code>context</code> parameter are non-null.
	     * @throws IllegalOperationError If the <code>requestedContentParent</code>
	     *                               property of the <code>context</code>
	     *                               parameter is a <code>Loader</code>.
	     * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
	     *                               parameter is set to non-null and has some
	     *                               values which are not Strings.
	     * @throws SecurityError         If the provided
	     *                               <code>applicationDomain</code> property of
	     *                               the <code>context</code> property is from a
	     *                               disallowed domain.
	     * @throws SecurityError         You cannot connect to commonly reserved
	     *                               ports. For a complete list of blocked ports,
	     *                               see "Restricting Networking APIs" in the
	     *                               <i>ActionScript 3.0 Developer's Guide</i>.
	     * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
	     *                      object if the
	     *                      <code>LoaderContext.requestedContentParent</code>
	     *                      property has been specified and it is not possible to
	     *                      add the loaded content as a child to the specified
	     *                      DisplayObjectContainer. This could happen if the
	     *                      loaded content is a
	     *                      <code>flash.display.AVM1Movie</code> or if the
	     *                      <code>addChild()</code> call to the
	     *                      requestedContentParent throws an error.
	     * @event complete      Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when the operation is complete. The
	     *                      <code>complete</code> event is always dispatched
	     *                      after the <code>init</code> event.
	     * @event init          Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when the properties and methods of the loaded
	     *                      data are accessible. The <code>init</code> event
	     *                      always precedes the <code>complete</code> event.
	     * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when the runtime cannot parse the data in the
	     *                      byte array.
	     * @event open          Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when the operation starts.
	     * @event progress      Dispatched by the <code>contentLoaderInfo</code>
	     *                      object as data is transfered in memory.
	     * @event securityError Dispatched by the <code>contentLoaderInfo</code>
	     *                      object if the
	     *                      <code>LoaderContext.requestedContentParent</code>
	     *                      property has been specified and the security sandbox
	     *                      of the
	     *                      <code>LoaderContext.requestedContentParent</code>
	     *                      does not have access to the loaded SWF.
	     * @event unload        Dispatched by the <code>contentLoaderInfo</code>
	     *                      object when a loaded object is removed.
	     */
	    LoaderContainer.prototype.loadData = function (data, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this._getLoader().loadData(data, '', context, ns, parser);
	    };
	    LoaderContainer.prototype._getLoader = function () {
	        if (this._useAssetLib) {
	            var lib = AssetLibraryBundle_1.AssetLibraryBundle.getInstance(this._assetLibId);
	            this._loader = lib.getLoader();
	        }
	        else {
	            this._loader = new Loader_1.Loader();
	        }
	        this._loader.addEventListener(LoaderEvent_1.LoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
	        this._loader.addEventListener(AssetEvent_1.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        this._loader.addEventListener(AssetEvent_1.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	        // Error are handled separately (see documentation for addErrorHandler)
	        this._loader._iAddErrorHandler(this._onLoadErrorDelegate);
	        this._loader._iAddParseErrorHandler(this._onParseErrorDelegate);
	        return this._loader;
	    };
	    LoaderContainer.prototype._disposeLoader = function () {
	        this._loader.removeEventListener(LoaderEvent_1.LoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
	        this._loader.removeEventListener(AssetEvent_1.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        this._loader.removeEventListener(AssetEvent_1.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	        if (!this._useAssetLib)
	            this._loader.stop();
	        this._loader = null;
	    };
	    /**
	     * Removes a child of this Loader object that was loaded by using the
	     * <code>load()</code> method. The <code>property</code> of the associated
	     * LoaderInfo object is reset to <code>null</code>. The child is not
	     * necessarily destroyed because other objects might have references to it;
	     * however, it is no longer a child of the Loader object.
	     *
	     * <p>As a best practice, before you unload a child SWF file, you should
	     * explicitly close any streams in the child SWF file's objects, such as
	     * LocalConnection, NetConnection, NetStream, and Sound objects. Otherwise,
	     * audio in the child SWF file might continue to play, even though the child
	     * SWF file was unloaded. To close streams in the child SWF file, add an
	     * event listener to the child that listens for the <code>unload</code>
	     * event. When the parent calls <code>Loader.unload()</code>, the
	     * <code>unload</code> event is dispatched to the child. The following code
	     * shows how you might do this:</p>
	     * <pre xml:space="preserve"> public closeAllStreams(evt:Event) {
	     * myNetStream.close(); mySound.close(); myNetConnection.close();
	     * myLocalConnection.close(); }
	     * myMovieClip.loaderInfo.addEventListener(Event.UNLOAD,
	     * closeAllStreams);</pre>
	     *
	     */
	    LoaderContainer.prototype.unload = function () {
	        //TODO
	    };
	    /**
	     * Enables a specific parser.
	     * When no specific parser is set for a loading/parsing opperation,
	     * loader3d can autoselect the correct parser to use.
	     * A parser must have been enabled, to be considered when autoselecting the parser.
	     *
	     * @param parserClass The parser class to enable.
	     * @see away.parsers.Parsers
	     */
	    LoaderContainer.enableParser = function (parserClass) {
	        Loader_1.Loader.enableParser(parserClass);
	    };
	    /**
	     * Enables a list of parsers.
	     * When no specific parser is set for a loading/parsing opperation,
	     * loader3d can autoselect the correct parser to use.
	     * A parser must have been enabled, to be considered when autoselecting the parser.
	     *
	     * @param parserClasses A Vector of parser classes to enable.
	     * @see away.parsers.Parsers
	     */
	    LoaderContainer.enableParsers = function (parserClasses) {
	        Loader_1.Loader.enableParsers(parserClasses);
	    };
	    LoaderContainer.prototype.onAssetComplete = function (event) {
	        this.dispatchEvent(event);
	    };
	    /**
	     * Called when an error occurs during loading
	     */
	    LoaderContainer.prototype.onLoadError = function (event) {
	        if (this.hasEventListener(URLLoaderEvent_1.URLLoaderEvent.LOAD_ERROR)) {
	            this.dispatchEvent(event);
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    /**
	     * Called when a an error occurs during parsing
	     */
	    LoaderContainer.prototype.onParseError = function (event) {
	        if (this.hasEventListener(ParserEvent_1.ParserEvent.PARSE_ERROR)) {
	            this.dispatchEvent(event);
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    LoaderContainer.prototype.onTextureSizeError = function (event) {
	        this.dispatchEvent(event);
	    };
	    /**
	     * Called when the resource and all of its dependencies was retrieved.
	     */
	    LoaderContainer.prototype.onLoadComplete = function (event) {
	        this._content = event.content;
	        if (this._content)
	            this.addChild(this._content);
	        this.dispatchEvent(event);
	        this._disposeLoader();
	    };
	    return LoaderContainer;
	}(DisplayObjectContainer_1.DisplayObjectContainer));
	exports.LoaderContainer = LoaderContainer;


/***/ },
/* 159 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetLibraryIterator_1 = __webpack_require__(160);
	var Loader_1 = __webpack_require__(161);
	var ConflictPrecedence_1 = __webpack_require__(170);
	var ConflictStrategy_1 = __webpack_require__(171);
	var AssetBase_1 = __webpack_require__(6);
	var ErrorBase_1 = __webpack_require__(8);
	var AssetEvent_1 = __webpack_require__(9);
	var URLLoaderEvent_1 = __webpack_require__(166);
	var LoaderEvent_1 = __webpack_require__(167);
	var EventDispatcher_1 = __webpack_require__(11);
	var ParserEvent_1 = __webpack_require__(168);
	/**
	 * AssetLibraryBundle enforces a multiton pattern and is not intended to be instanced directly.
	 * Its purpose is to create a container for 3D data management, both before and after parsing.
	 * If you are interested in creating multiple library bundles, please use the <code>getInstance()</code> method.
	 */
	var AssetLibraryBundle = (function (_super) {
	    __extends(AssetLibraryBundle, _super);
	    /**
	     * Creates a new <code>AssetLibraryBundle</code> object.
	     *
	     * @param me A multiton enforcer for the AssetLibraryBundle ensuring it cannnot be instanced.
	     */
	    function AssetLibraryBundle() {
	        var _this = this;
	        _super.call(this);
	        this._loaderSessionsGarbage = new Array();
	        this._assets = new Array(); //new Vector.<IAsset>;
	        this._assetDictionary = new Object();
	        this._loaderSessions = new Array();
	        this.conflictStrategy = ConflictStrategy_1.ConflictStrategy.IGNORE.create();
	        this.conflictPrecedence = ConflictPrecedence_1.ConflictPrecedence.FAVOR_NEW;
	        this._onAssetRenameDelegate = function (event) { return _this.onAssetRename(event); };
	        this._onAssetConflictResolvedDelegate = function (event) { return _this.onAssetConflictResolved(event); };
	        this._onResourceCompleteDelegate = function (event) { return _this.onResourceComplete(event); };
	        this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
	        this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
	        this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
	        this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
	    }
	    /**
	     * Returns an AssetLibraryBundle instance. If no key is given, returns the default bundle instance (which is
	     * similar to using the AssetLibraryBundle as a singleton.) To keep several separated library bundles,
	     * pass a string key to this method to define which bundle should be returned. This is
	     * referred to as using the AssetLibrary as a multiton.
	     *
	     * @param key Defines which multiton instance should be returned.
	     * @return An instance of the asset library
	     */
	    AssetLibraryBundle.getInstance = function (key) {
	        if (key === void 0) { key = 'default'; }
	        if (!key)
	            key = 'default';
	        if (!AssetLibraryBundle._iInstances.hasOwnProperty(key))
	            AssetLibraryBundle._iInstances[key] = new AssetLibraryBundle();
	        return AssetLibraryBundle._iInstances[key];
	    };
	    /**
	     *
	     */
	    AssetLibraryBundle.prototype.enableParser = function (parserClass) {
	        Loader_1.Loader.enableParser(parserClass);
	    };
	    /**
	     *
	     */
	    AssetLibraryBundle.prototype.enableParsers = function (parserClasses) {
	        Loader_1.Loader.enableParsers(parserClasses);
	    };
	    Object.defineProperty(AssetLibraryBundle.prototype, "conflictStrategy", {
	        /**
	         * Defines which strategy should be used for resolving naming conflicts, when two library
	         * assets are given the same name. By default, <code>ConflictStrategy.APPEND_NUM_SUFFIX</code>
	         * is used which means that a numeric suffix is appended to one of the assets. The
	         * <code>conflictPrecedence</code> property defines which of the two conflicting assets will
	         * be renamed.
	         *
	         * @see naming.ConflictStrategy
	         * @see AssetLibrary.conflictPrecedence
	         */
	        get: function () {
	            return this._strategy;
	        },
	        set: function (val) {
	            if (!val)
	                throw new ErrorBase_1.ErrorBase('namingStrategy must not be null. To ignore naming, use AssetLibrary.IGNORE');
	            this._strategy = val.create();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetLibraryBundle.prototype, "conflictPrecedence", {
	        /**
	         * Defines which asset should have precedence when resolving a naming conflict between
	         * two assets of which one has just been renamed by the user or by a parser. By default
	         * <code>ConflictPrecedence.FAVOR_NEW</code> is used, meaning that the newly renamed
	         * asset will keep it's new name while the older asset gets renamed to not conflict.
	         *
	         * This property is ignored for conflict strategies that do not actually rename an
	         * asset automatically, such as ConflictStrategy.IGNORE and ConflictStrategy.THROW_ERROR.
	         *
	         * @see away.library.ConflictPrecedence
	         * @see away.library.ConflictStrategy
	         */
	        get: function () {
	            return this._strategyPreference;
	        },
	        set: function (val) {
	            this._strategyPreference = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Create an AssetLibraryIterator instance that can be used to iterate over the assets
	     * in this asset library instance. The iterator can filter assets on asset type and/or
	     * namespace. A "null" filter value means no filter of that type is used.
	     *
	     * @param assetTypeFilter Asset type to filter on (from the AssetType enum class.) Use
	     * null to not filter on asset type.
	     * @param namespaceFilter Namespace to filter on. Use null to not filter on namespace.
	     * @param filterFunc Callback function to use when deciding whether an asset should be
	     * included in the iteration or not. This needs to be a function that takes a single
	     * parameter of type IAsset and returns a boolean where true means it should be included.
	     *
	     * @see away.library.AssetType
	     */
	    AssetLibraryBundle.prototype.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
	        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
	        if (namespaceFilter === void 0) { namespaceFilter = null; }
	        if (filterFunc === void 0) { filterFunc = null; }
	        return new AssetLibraryIterator_1.AssetLibraryIterator(this._assets, assetTypeFilter, namespaceFilter, filterFunc);
	    };
	    /**
	     * Loads a file and (optionally) all of its dependencies.
	     *
	     * @param req The URLRequest object containing the URL of the file to be loaded.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     * @return A handle to the retrieved resource.
	     */
	    AssetLibraryBundle.prototype.load = function (req, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this.getLoader().load(req, context, ns, parser);
	    };
	    /**
	     * Loads a resource from existing data in memory.
	     *
	     * @param data The data object containing all resource information.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     * @return A handle to the retrieved resource.
	     */
	    AssetLibraryBundle.prototype.loadData = function (data, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this.getLoader().loadData(data, '', context, ns, parser);
	    };
	    AssetLibraryBundle.prototype.getLoader = function () {
	        var loader = new Loader_1.Loader();
	        this._loaderSessions.push(loader);
	        loader.addEventListener(LoaderEvent_1.LoaderEvent.LOAD_COMPLETE, this._onResourceCompleteDelegate);
	        loader.addEventListener(AssetEvent_1.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        loader.addEventListener(AssetEvent_1.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	        // Error are handled separately (see documentation for addErrorHandler)
	        loader._iAddErrorHandler(this._onLoadErrorDelegate);
	        loader._iAddParseErrorHandler(this._onParseErrorDelegate);
	        return loader;
	    };
	    AssetLibraryBundle.prototype.disposeLoader = function (loader) {
	        var _this = this;
	        var index = this._loaderSessions.indexOf(loader);
	        this._loaderSessions.splice(index, 1);
	        // Add loader to a garbage array - for a collection sweep and kill
	        this._loaderSessionsGarbage.push(loader);
	        this._gcTimeoutIID = setTimeout(function () { _this.loaderSessionGC(); }, 100);
	    };
	    /**
	     *
	     */
	    AssetLibraryBundle.prototype.getAsset = function (name, ns) {
	        if (ns === void 0) { ns = null; }
	        if (this._assetDictDirty)
	            this.rehashAssetDict();
	        if (ns == null)
	            ns = AssetBase_1.AssetBase.DEFAULT_NAMESPACE;
	        if (!this._assetDictionary.hasOwnProperty(ns))
	            return null;
	        return this._assetDictionary[ns][name];
	    };
	    AssetLibraryBundle.prototype.getAllAssets = function () {
	        return this._assets;
	    };
	    /**
	     * Adds an asset to the asset library, first making sure that it's name is unique
	     * using the method defined by the <code>conflictStrategy</code> and
	     * <code>conflictPrecedence</code> properties.
	     */
	    AssetLibraryBundle.prototype.addAsset = function (asset) {
	        var ns;
	        var old;
	        // Bail if asset has already been added.
	        if (this._assets.indexOf(asset) >= 0)
	            return;
	        old = this.getAsset(asset.name, asset.assetNamespace);
	        ns = asset.assetNamespace || AssetBase_1.AssetBase.DEFAULT_NAMESPACE;
	        if (old != null)
	            this._strategy.resolveConflict(asset, old, this._assetDictionary[ns], this._strategyPreference);
	        //create unique-id (for now this is used in AwayBuilder only
	        //asset.id = IDUtil.createUID();
	        // Add it
	        this._assets.push(asset);
	        if (!this._assetDictionary.hasOwnProperty(ns))
	            this._assetDictionary[ns] = new Object();
	        this._assetDictionary[ns][asset.name] = asset;
	        asset.addEventListener(AssetEvent_1.AssetEvent.RENAME, this._onAssetRenameDelegate);
	        asset.addEventListener(AssetEvent_1.AssetEvent.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
	    };
	    /**
	     * Removes an asset from the library, and optionally disposes that asset by calling
	     * it's disposeAsset() method (which for most assets is implemented as a default
	     * version of that type's dispose() method.
	     *
	     * @param asset The asset which should be removed from this library.
	     * @param dispose Defines whether the assets should also be disposed.
	     */
	    AssetLibraryBundle.prototype.removeAsset = function (asset, dispose) {
	        if (dispose === void 0) { dispose = true; }
	        var idx;
	        this.removeAssetFromDict(asset);
	        asset.removeEventListener(AssetEvent_1.AssetEvent.RENAME, this._onAssetRenameDelegate);
	        asset.removeEventListener(AssetEvent_1.AssetEvent.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
	        idx = this._assets.indexOf(asset);
	        if (idx >= 0)
	            this._assets.splice(idx, 1);
	        if (dispose)
	            asset.dispose();
	    };
	    /**
	     * Removes an asset which is specified using name and namespace.
	     *
	     * @param name The name of the asset to be removed.
	     * @param ns The namespace to which the desired asset belongs.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see away.library.AssetLibrary.removeAsset()
	     */
	    AssetLibraryBundle.prototype.removeAssetByName = function (name, ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        var asset = this.getAsset(name, ns);
	        if (asset)
	            this.removeAsset(asset, dispose);
	        return asset;
	    };
	    /**
	     * Removes all assets from the asset library, optionally disposing them as they
	     * are removed.
	     *
	     * @param dispose Defines whether the assets should also be disposed.
	     */
	    AssetLibraryBundle.prototype.removeAllAssets = function (dispose) {
	        if (dispose === void 0) { dispose = true; }
	        if (dispose) {
	            var asset;
	            var len = this._assets.length;
	            for (var c = 0; c < len; c++) {
	                asset = this._assets[c];
	                asset.dispose();
	            }
	        }
	        this._assets.length = 0;
	        this.rehashAssetDict();
	    };
	    /**
	     * Removes all assets belonging to a particular namespace (null for default)
	     * from the asset library, and optionall disposes them by calling their
	     * disposeAsset() method.
	     *
	     * @param ns The namespace from which all assets should be removed.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see away.library.AssetLibrary.removeAsset()
	     */
	    AssetLibraryBundle.prototype.removeNamespaceAssets = function (ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        var idx = 0;
	        var asset;
	        var old_assets;
	        // Empty the assets vector after having stored a copy of it.
	        // The copy will be filled with all assets which weren't removed.
	        old_assets = this._assets.concat();
	        this._assets.length = 0;
	        if (ns == null)
	            ns = AssetBase_1.AssetBase.DEFAULT_NAMESPACE;
	        var len = old_assets.length;
	        for (var d = 0; d < len; d++) {
	            asset = old_assets[d];
	            // Remove from dict if in the supplied namespace. If not,
	            // transfer over to the new vector.
	            if (asset.assetNamespace == ns) {
	                if (dispose)
	                    asset.dispose();
	                // Remove asset from dictionary, but don't try to auto-remove
	                // the namespace, which will trigger an unnecessarily expensive
	                // test that is not needed since we know that the namespace
	                // will be empty when loop finishes.
	                this.removeAssetFromDict(asset, false);
	            }
	            else {
	                this._assets[idx++] = asset;
	            }
	        }
	        /*
	         for each (asset in old_assets) {
	         // Remove from dict if in the supplied namespace. If not,
	         // transfer over to the new vector.
	         if (asset.assetNamespace == ns) {
	         if (dispose)
	         asset.dispose();
	
	         // Remove asset from dictionary, but don't try to auto-remove
	         // the namespace, which will trigger an unnecessarily expensive
	         // test that is not needed since we know that the namespace
	         // will be empty when loop finishes.
	         removeAssetFromDict(asset, false);
	         } else
	         _assets[idx++] = asset;
	
	         }
	         */
	        // Remove empty namespace
	        if (this._assetDictionary.hasOwnProperty(ns))
	            delete this._assetDictionary[ns];
	    };
	    AssetLibraryBundle.prototype.removeAssetFromDict = function (asset, autoRemoveEmptyNamespace) {
	        if (autoRemoveEmptyNamespace === void 0) { autoRemoveEmptyNamespace = true; }
	        if (this._assetDictDirty)
	            this.rehashAssetDict();
	        if (this._assetDictionary.hasOwnProperty(asset.assetNamespace)) {
	            if (this._assetDictionary[asset.assetNamespace].hasOwnProperty(asset.name))
	                delete this._assetDictionary[asset.assetNamespace][asset.name];
	            if (autoRemoveEmptyNamespace) {
	                var key;
	                var empty = true;
	                for (key in this._assetDictionary[asset.assetNamespace]) {
	                    empty = false;
	                    break;
	                }
	                if (empty)
	                    delete this._assetDictionary[asset.assetNamespace];
	            }
	        }
	    };
	    AssetLibraryBundle.prototype.stopAllLoaders = function () {
	        var len = this._loaderSessions.length;
	        for (var i = 0; i < len; i++)
	            this.killloaderSession(this._loaderSessions[i]);
	        this._loaderSessions = new Array();
	    };
	    AssetLibraryBundle.prototype.rehashAssetDict = function () {
	        var asset;
	        this._assetDictionary = {};
	        var len = this._assets.length;
	        for (var c = 0; c < len; c++) {
	            asset = this._assets[c];
	            if (!this._assetDictionary.hasOwnProperty(asset.assetNamespace))
	                this._assetDictionary[asset.assetNamespace] = {};
	            this._assetDictionary[asset.assetNamespace][asset.name] = asset;
	        }
	        this._assetDictDirty = false;
	    };
	    /**
	     * Called when a an error occurs during loading.
	     */
	    AssetLibraryBundle.prototype.onLoadError = function (event) {
	        if (this.hasEventListener(URLLoaderEvent_1.URLLoaderEvent.LOAD_ERROR)) {
	            this.dispatchEvent(event);
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    /**
	     * Called when a an error occurs during parsing.
	     */
	    AssetLibraryBundle.prototype.onParseError = function (event) {
	        if (this.hasEventListener(ParserEvent_1.ParserEvent.PARSE_ERROR)) {
	            this.dispatchEvent(event);
	            return true;
	        }
	        else {
	            return false;
	        }
	    };
	    AssetLibraryBundle.prototype.onAssetComplete = function (event) {
	        // Only add asset to library the first time.
	        if (event.type == AssetEvent_1.AssetEvent.ASSET_COMPLETE)
	            this.addAsset(event.asset);
	        this.dispatchEvent(event);
	    };
	    AssetLibraryBundle.prototype.onTextureSizeError = function (event) {
	        this.dispatchEvent(event);
	    };
	    /**
	     * Called when the resource and all of its dependencies was retrieved.
	     */
	    AssetLibraryBundle.prototype.onResourceComplete = function (event) {
	        var loader = event.target;
	        this.dispatchEvent(event);
	        this.disposeLoader(loader);
	    };
	    AssetLibraryBundle.prototype.loaderSessionGC = function () {
	        var loader;
	        while (this._loaderSessionsGarbage.length > 0) {
	            loader = this._loaderSessionsGarbage.pop();
	            this.killloaderSession(loader);
	        }
	        clearTimeout(this._gcTimeoutIID);
	        this._gcTimeoutIID = null;
	    };
	    AssetLibraryBundle.prototype.killloaderSession = function (loader) {
	        loader.removeEventListener(LoaderEvent_1.LoaderEvent.LOAD_COMPLETE, this._onResourceCompleteDelegate);
	        loader.removeEventListener(AssetEvent_1.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        loader.removeEventListener(AssetEvent_1.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	        loader.stop();
	    };
	    AssetLibraryBundle.prototype.onAssetRename = function (event) {
	        var asset = event.target; // TODO: was ev.currentTarget - watch this var
	        var old = this.getAsset(asset.assetNamespace, asset.name);
	        if (old != null) {
	            this._strategy.resolveConflict(asset, old, this._assetDictionary[asset.assetNamespace], this._strategyPreference);
	        }
	        else {
	            var dict = this._assetDictionary[event.asset.assetNamespace];
	            if (dict == null)
	                return;
	            dict[event.prevName] = null;
	            dict[event.asset.name] = event.asset;
	        }
	    };
	    AssetLibraryBundle.prototype.onAssetConflictResolved = function (event) {
	        this.dispatchEvent(event.clone());
	    };
	    AssetLibraryBundle._iInstances = new Object();
	    return AssetLibraryBundle;
	}(EventDispatcher_1.EventDispatcher));
	exports.AssetLibraryBundle = AssetLibraryBundle;


/***/ },
/* 160 */
/***/ function(module, exports) {

	"use strict";
	var AssetLibraryIterator = (function () {
	    function AssetLibraryIterator(assets, assetTypeFilter, namespaceFilter, filterFunc) {
	        this._assets = assets;
	        this.filter(assetTypeFilter, namespaceFilter, filterFunc);
	    }
	    Object.defineProperty(AssetLibraryIterator.prototype, "currentAsset", {
	        get: function () {
	            // Return current, or null if no current
	            return (this._idx < this._filtered.length) ? this._filtered[this._idx] : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetLibraryIterator.prototype, "numAssets", {
	        get: function () {
	            return this._filtered.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AssetLibraryIterator.prototype.next = function () {
	        var next = null;
	        if (this._idx < this._filtered.length)
	            next = this._filtered[this._idx];
	        this._idx++;
	        return next;
	    };
	    AssetLibraryIterator.prototype.reset = function () {
	        this._idx = 0;
	    };
	    AssetLibraryIterator.prototype.setIndex = function (index) {
	        this._idx = index;
	    };
	    AssetLibraryIterator.prototype.filter = function (assetTypeFilter, namespaceFilter, filterFunc) {
	        if (assetTypeFilter || namespaceFilter) {
	            var idx;
	            var asset;
	            idx = 0;
	            this._filtered = new Array(); //new Vector.<IAsset>;
	            var l = this._assets.length;
	            for (var c = 0; c < l; c++) {
	                asset = this._assets[c];
	                // Skip this assets if filtering on type and this is wrong type
	                if (assetTypeFilter && asset.assetType != assetTypeFilter)
	                    continue;
	                // Skip this asset if filtering on namespace and this is wrong namespace
	                if (namespaceFilter && asset.assetNamespace != namespaceFilter)
	                    continue;
	                // Skip this asset if a filter func has been provided and it returns false
	                if (filterFunc != null && !filterFunc(asset))
	                    continue;
	                this._filtered[idx++] = asset;
	            }
	        }
	        else {
	            this._filtered = this._assets;
	        }
	    };
	    return AssetLibraryIterator;
	}());
	exports.AssetLibraryIterator = AssetLibraryIterator;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var URLLoader_1 = __webpack_require__(162);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var AssetEvent_1 = __webpack_require__(9);
	var EventDispatcher_1 = __webpack_require__(11);
	var URLLoaderEvent_1 = __webpack_require__(166);
	var LoaderEvent_1 = __webpack_require__(167);
	var ParserEvent_1 = __webpack_require__(168);
	var ResourceDependency_1 = __webpack_require__(169);
	/**
	 * Dispatched when any asset finishes parsing. Also see specific events for each
	 * individual asset type (meshes, materials et c.)
	 *
	 * @eventType away.events.AssetEvent
	 */
	//[Event(name="assetComplete", type="away3d.events.AssetEvent")]
	/**
	 * Dispatched when a full resource (including dependencies) finishes loading.
	 *
	 * @eventType away.events.LoaderEvent
	 */
	//[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
	/**
	 * Dispatched when a single dependency (which may be the main file of a resource)
	 * finishes loading.
	 *
	 * @eventType away.events.LoaderEvent
	 */
	//[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
	/**
	 * Dispatched when an error occurs during loading. I
	 *
	 * @eventType away.events.LoaderEvent
	 */
	//[Event(name="loadError", type="away3d.events.LoaderEvent")]
	/**
	 * Dispatched when an error occurs during parsing.
	 *
	 * @eventType away.events.ParserEvent
	 */
	//[Event(name="parseError", type="away3d.events.ParserEvent")]
	/**
	 * Dispatched when an image asset dimensions are not a power of 2
	 *
	 * @eventType away.events.AssetEvent
	 */
	//[Event(name="textureSizeError", type="away3d.events.AssetEvent")]
	/**
	 * Loader can load any file format that away.supports (or for which a third-party parser
	 * has been plugged in) and it's dependencies. Events are dispatched when assets are encountered
	 * and for when the resource (or it's dependencies) have been loaded.
	 *
	 * The Loader will not make assets available in any other way than through the dispatched
	 * events. To store assets and make them available at any point from any module in an application,
	 * use the AssetLibrary to load and manage assets.
	 *
	 * @see away.library.AssetLibrary
	 */
	var Loader = (function (_super) {
	    __extends(Loader, _super);
	    /**
	     * Create a new ResourceLoadSession object.
	     */
	    function Loader(materialMode) {
	        var _this = this;
	        if (materialMode === void 0) { materialMode = 0; }
	        _super.call(this);
	        this._materialMode = materialMode;
	        this._stack = new Array();
	        this._errorHandlers = new Array();
	        this._parseErrorHandlers = new Array();
	        this._onReadyForDependenciesDelegate = function (event) { return _this.onReadyForDependencies(event); };
	        this._onParseCompleteDelegate = function (event) { return _this.onParseComplete(event); };
	        this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
	        this._onLoadCompleteDelegate = function (event) { return _this.onLoadComplete(event); };
	        this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
	        this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
	        this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
	    }
	    /**
	     * Enables a specific parser.
	     * When no specific parser is set for a loading/parsing opperation,
	     * loader3d can autoselect the correct parser to use.
	     * A parser must have been enabled, to be considered when autoselecting the parser.
	     *
	     * @param parser The parser export class to enable.
	     *
	     * @see away.parsers.Parsers
	     */
	    Loader.enableParser = function (parser) {
	        if (Loader._parsers.indexOf(parser) < 0)
	            Loader._parsers.push(parser);
	    };
	    /**
	     * Enables a list of parsers.
	     * When no specific parser is set for a loading/parsing opperation,
	     * Loader can autoselect the correct parser to use.
	     * A parser must have been enabled, to be considered when autoselecting the parser.
	     *
	     * @param parsers A Vector of parser classes to enable.
	     * @see away.parsers.Parsers
	     */
	    Loader.enableParsers = function (parsers) {
	        for (var c = 0; c < parsers.length; c++)
	            Loader.enableParser(parsers[c]);
	    };
	    Object.defineProperty(Loader.prototype, "baseDependency", {
	        /**
	         * Returns the base dependency of the loader
	         */
	        get: function () {
	            return this._baseDependency;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Loader.prototype, "loaderInfo", {
	        /**
	         * Returns a LoaderInfo object corresponding to the object being loaded.
	         * LoaderInfo objects are shared between the Loader object and the loaded
	         * content object. The LoaderInfo object supplies loading progress
	         * information and statistics about the loaded file.
	         *
	         * <p>Events related to the load are dispatched by the LoaderInfo object
	         * referenced by the <code>contentLoaderInfo</code> property of the Loader
	         * object. The <code>contentLoaderInfo</code> property is set to a valid
	         * LoaderInfo object, even before the content is loaded, so that you can add
	         * event listeners to the object prior to the load.</p>
	         *
	         * <p>To detect uncaught errors that happen in a loaded SWF, use the
	         * <code>Loader.uncaughtErrorEvents</code> property, not the
	         * <code>Loader.contentLoaderInfo.uncaughtErrorEvents</code> property.</p>
	         */
	        get: function () {
	            return this._loaderInfo;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Loads a file and (optionally) all of its dependencies.
	     *
	     * @param req The URLRequest object containing the URL of the file to be loaded.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     */
	    Loader.prototype.load = function (req, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this._uri = req.url = req.url.replace(/\\/g, "/");
	        this._context = context;
	        this._namespace = ns;
	        this._baseDependency = new ResourceDependency_1.ResourceDependency('', req, null, parser, null);
	        this.retrieveDependency(this._baseDependency);
	    };
	    /**
	     * Loads a resource from already loaded data.
	     *
	     * @param data The data object containing all resource information.
	     * @param context An optional context object providing additional parameters for loading
	     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
	     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
	     */
	    Loader.prototype.loadData = function (data, id, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        this._uri = id;
	        this._context = context;
	        this._namespace = ns;
	        this._baseDependency = new ResourceDependency_1.ResourceDependency(id, null, data, parser, null);
	        this.retrieveDependency(this._baseDependency);
	    };
	    /**
	     * Recursively retrieves the next to-be-loaded and parsed dependency on the stack, or pops the list off the
	     * stack when complete and continues on the top set.
	     * @param parser The parser that will translate the data into a usable resource.
	     */
	    Loader.prototype.retrieveNext = function (parser) {
	        if (parser === void 0) { parser = null; }
	        if (this._currentDependency.dependencies.length) {
	            var next = this._currentDependency.dependencies.pop();
	            this._stack.push(this._currentDependency);
	            this.retrieveDependency(next);
	        }
	        else if (this._currentDependency.parser && this._currentDependency.parser.parsingPaused) {
	            this._currentDependency.parser._iResumeParsing();
	            this._stack.pop();
	        }
	        else if (this._stack.length) {
	            var prev = this._currentDependency;
	            this._currentDependency = this._stack.pop();
	            if (prev._iSuccess)
	                prev.resolve();
	            this.retrieveNext(parser);
	        }
	        else {
	            this.dispatchEvent(new LoaderEvent_1.LoaderEvent(LoaderEvent_1.LoaderEvent.LOAD_COMPLETE, this._uri, this._baseDependency.parser.content, this._baseDependency.assets));
	        }
	    };
	    /**
	     * Retrieves a single dependency.
	     * @param parser The parser that will translate the data into a usable resource.
	     */
	    Loader.prototype.retrieveDependency = function (dependency) {
	        var data;
	        if (this._context && this._context.materialMode != 0)
	            this._materialMode = this._context.materialMode;
	        this._currentDependency = dependency;
	        dependency._iLoader = new URLLoader_1.URLLoader();
	        this.addEventListeners(dependency._iLoader);
	        // Get already loaded (or mapped) data if available
	        data = dependency.data;
	        if (this._context && dependency.request && this._context._iHasDataForUrl(dependency.request.url))
	            data = this._context._iGetDataForUrl(dependency.request.url);
	        if (data) {
	            if (data.constructor === Function)
	                data = new data();
	            dependency._iSetData(data);
	            if (dependency.retrieveAsRawData) {
	                // No need to parse. The parent parser is expecting this
	                // to be raw data so it can be passed directly.
	                dependency.resolve();
	                // Move on to next dependency
	                this.retrieveNext();
	            }
	            else {
	                this.parseDependency(dependency);
	            }
	        }
	        else {
	            // Resolve URL and start loading
	            dependency.request.url = this.resolveDependencyUrl(dependency);
	            if (dependency.retrieveAsRawData) {
	                // Always use binary for raw data loading
	                dependency._iLoader.dataFormat = URLLoaderDataFormat_1.URLLoaderDataFormat.BINARY;
	            }
	            else {
	                if (!dependency.parser)
	                    dependency._iSetParser(this.getParserFromSuffix(dependency.request.url));
	                if (dependency.parser) {
	                    dependency._iLoader.dataFormat = dependency.parser.dataFormat;
	                }
	                else {
	                    // Always use BINARY for unknown file formats. The thorough
	                    // file type check will determine format after load, and if
	                    // binary, a text load will have broken the file data.
	                    dependency._iLoader.dataFormat = URLLoaderDataFormat_1.URLLoaderDataFormat.BINARY;
	                }
	            }
	            dependency._iLoader.load(dependency.request);
	        }
	    };
	    Loader.prototype.joinUrl = function (base, end) {
	        if (end.charAt(0) == '/' || end.charAt(0) == '\\')
	            end = end.substr(1);
	        if (end.charAt(0) == '.')
	            end = end.substr(2);
	        if (base.length == 0)
	            return end;
	        if (base.charAt(base.length - 1) == '/' || base.charAt(base.length - 1) == '\\')
	            base = base.substr(0, base.length - 1);
	        return base.concat('/', end);
	    };
	    Loader.prototype.resolveDependencyUrl = function (dependency) {
	        var scheme_re;
	        var base;
	        var url = dependency.request.url;
	        // Has the user re-mapped this URL?
	        if (this._context && this._context._iHasMappingForUrl(url))
	            return this._context._iGetRemappedUrl(url);
	        // This is the "base" dependency, i.e. the actual requested asset.
	        // We will not try to resolve this since the user can probably be
	        // thrusted to know this URL better than our automatic resolver. :)
	        if (url == this._uri)
	            return url;
	        // Absolute URL? Check if starts with slash or a URL
	        // scheme definition (e.g. ftp://, http://, file://)
	        scheme_re = new RegExp('/^[a-zA-Z]{3,4}:\/\//');
	        if (url.charAt(0) == '/') {
	            if (this._context && this._context.overrideAbsolutePaths)
	                return this.joinUrl(this._context.dependencyBaseUrl, url);
	            else
	                return url;
	        }
	        else if (scheme_re.test(url)) {
	            // If overriding full URLs, get rid of scheme (e.g. "http://")
	            // and replace with the dependencyBaseUrl defined by user.
	            if (this._context && this._context.overrideFullURLs) {
	                var noscheme_url = url.replace(scheme_re, ''); //url['replace'](scheme_re);
	                return this.joinUrl(this._context.dependencyBaseUrl, noscheme_url);
	            }
	        }
	        // Since not absolute, just get rid of base file name to find it's
	        // folder and then concatenate dynamic URL
	        if (this._context && this._context.dependencyBaseUrl) {
	            base = this._context.dependencyBaseUrl;
	            return this.joinUrl(base, url);
	        }
	        else {
	            base = this._uri.substring(0, this._uri.lastIndexOf('/') + 1);
	            return this.joinUrl(base, url);
	        }
	    };
	    Loader.prototype.retrieveParserDependencies = function () {
	        if (!this._currentDependency)
	            return;
	        var parserDependancies = this._currentDependency.parser.dependencies;
	        var i, len = parserDependancies.length;
	        for (i = 0; i < len; i++)
	            this._currentDependency.dependencies[i] = parserDependancies[i];
	        // Since more dependencies might be added eventually, empty this
	        // list so that the same dependency isn't retrieved more than once.
	        parserDependancies.length = 0;
	        this._stack.push(this._currentDependency);
	        this.retrieveNext();
	    };
	    Loader.prototype.resolveParserDependencies = function () {
	        this._currentDependency._iSuccess = true;
	        // Retrieve any last dependencies remaining on this parser, or
	        // if none exists, just move on.
	        if (this._currentDependency.parser && this._currentDependency.parser.dependencies.length && (!this._context || this._context.includeDependencies))
	            this.retrieveParserDependencies();
	        else
	            this.retrieveNext();
	    };
	    /**
	     * Called when a single dependency loading failed, and pushes further dependencies onto the stack.
	     * @param event
	     */
	    Loader.prototype.onLoadError = function (event) {
	        var handled;
	        var isDependency = (this._currentDependency != this._baseDependency);
	        var loader = event.urlLoader;
	        this.removeEventListeners(loader);
	        if (this.hasEventListener(URLLoaderEvent_1.URLLoaderEvent.LOAD_ERROR)) {
	            this.dispatchEvent(event);
	            handled = true;
	        }
	        else {
	            // TODO: Consider not doing this even when Loader does have it's own LOAD_ERROR listener
	            var i, len = this._errorHandlers.length;
	            for (i = 0; i < len; i++)
	                if (!handled)
	                    handled = this._errorHandlers[i](event);
	        }
	        if (handled) {
	            //if (isDependency && ! event.isDefaultPrevented()) {
	            if (isDependency) {
	                this._currentDependency.resolveFailure();
	                this.retrieveNext();
	            }
	            else {
	                // Either this was the base file (last left in the stack) or
	                // default behavior was prevented by the handlers, and hence
	                // there is nothing more to do than clean up and bail.
	                this.dispose();
	                return;
	            }
	        }
	        else {
	            // Error event was not handled by listeners directly on Loader or
	            // on any of the subscribed loaders (in the list of error handlers.)
	            throw new Error();
	        }
	    };
	    /**
	     * Called when a dependency parsing failed, and dispatches a <code>ParserEvent.PARSE_ERROR</code>
	     * @param event
	     */
	    Loader.prototype.onParseError = function (event) {
	        var handled;
	        var isDependency = (this._currentDependency != this._baseDependency);
	        var loader = event.target;
	        this.removeEventListeners(loader);
	        if (this.hasEventListener(ParserEvent_1.ParserEvent.PARSE_ERROR)) {
	            this.dispatchEvent(event);
	            handled = true;
	        }
	        else {
	            // TODO: Consider not doing this even when Loader does
	            // have it's own LOAD_ERROR listener
	            var i, len = this._parseErrorHandlers.length;
	            for (i = 0; i < len; i++)
	                if (!handled)
	                    handled = this._parseErrorHandlers[i](event);
	        }
	        if (handled) {
	            this.retrieveNext();
	        }
	        else {
	            // Error event was not handled by listeners directly on Loader or
	            // on any of the subscribed loaders (in the list of error handlers.)
	            throw new Error(event.message);
	        }
	    };
	    Loader.prototype.onAssetComplete = function (event) {
	        // Add loaded asset to list of assets retrieved as part
	        // of the current dependency. This list will be inspected
	        // by the parent parser when dependency is resolved
	        if (this._currentDependency)
	            this._currentDependency.assets.push(event.asset);
	        event.asset.resetAssetPath(event.asset.name, this._namespace);
	        if (!this._currentDependency.suppresAssetEvents)
	            this.dispatchEvent(event);
	    };
	    Loader.prototype.onReadyForDependencies = function (event) {
	        var parser = event.target;
	        if (this._context && !this._context.includeDependencies)
	            parser._iResumeParsing();
	        else
	            this.retrieveParserDependencies();
	    };
	    /**
	     * Called when a single dependency was parsed, and pushes further dependencies onto the stack.
	     * @param event
	     */
	    Loader.prototype.onLoadComplete = function (event) {
	        var loader = event.urlLoader;
	        this.removeEventListeners(loader);
	        // Resolve this dependency
	        this._currentDependency._iSetData(loader.data);
	        if (this._currentDependency.retrieveAsRawData) {
	            // No need to parse this data, which should be returned as is
	            this.resolveParserDependencies();
	        }
	        else {
	            this.parseDependency(this._currentDependency);
	        }
	    };
	    /**
	     * Called when parsing is complete.
	     */
	    Loader.prototype.onParseComplete = function (event) {
	        var parser = event.target;
	        this.resolveParserDependencies(); //resolve in front of removing listeners to allow any remaining asset events to propagate
	        parser.removeEventListener(ParserEvent_1.ParserEvent.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
	        parser.removeEventListener(ParserEvent_1.ParserEvent.PARSE_COMPLETE, this._onParseCompleteDelegate);
	        parser.removeEventListener(ParserEvent_1.ParserEvent.PARSE_ERROR, this._onParseErrorDelegate);
	        parser.removeEventListener(AssetEvent_1.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	        parser.removeEventListener(AssetEvent_1.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	    };
	    /**
	     * Called when an image is too large or it's dimensions are not a power of 2
	     * @param event
	     */
	    Loader.prototype.onTextureSizeError = function (event) {
	        event.asset.name = this._currentDependency.resolveName(event.asset);
	        this.dispatchEvent(event);
	    };
	    Loader.prototype.addEventListeners = function (loader) {
	        loader.addEventListener(URLLoaderEvent_1.URLLoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
	        loader.addEventListener(URLLoaderEvent_1.URLLoaderEvent.LOAD_ERROR, this._onLoadErrorDelegate);
	    };
	    Loader.prototype.removeEventListeners = function (loader) {
	        loader.removeEventListener(URLLoaderEvent_1.URLLoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
	        loader.removeEventListener(URLLoaderEvent_1.URLLoaderEvent.LOAD_ERROR, this._onLoadErrorDelegate);
	    };
	    Loader.prototype.stop = function () {
	        this.dispose();
	    };
	    Loader.prototype.dispose = function () {
	        this._errorHandlers = null;
	        this._parseErrorHandlers = null;
	        this._context = null;
	        this._stack = null;
	        if (this._currentDependency && this._currentDependency._iLoader)
	            this.removeEventListeners(this._currentDependency._iLoader);
	        this._currentDependency = null;
	    };
	    /**
	     * @private
	     * This method is used by other loader classes (e.g. Loader3D and AssetLibraryBundle) to
	     * add error event listeners to the Loader instance. This system is used instead of
	     * the regular EventDispatcher system so that the AssetLibrary error handler can be sure
	     * that if hasEventListener() returns true, it's client code that's listening for the
	     * event. Secondly, functions added as error handler through this custom method are
	     * expected to return a boolean value indicating whether the event was handled (i.e.
	     * whether they in turn had any client code listening for the event.) If no handlers
	     * return true, the Loader knows that the event wasn't handled and will throw an RTE.
	     */
	    Loader.prototype._iAddParseErrorHandler = function (handler) {
	        if (this._parseErrorHandlers.indexOf(handler) < 0)
	            this._parseErrorHandlers.push(handler);
	    };
	    Loader.prototype._iAddErrorHandler = function (handler) {
	        if (this._errorHandlers.indexOf(handler) < 0)
	            this._errorHandlers.push(handler);
	    };
	    /**
	     * Guesses the parser to be used based on the file contents.
	     * @param data The data to be parsed.
	     * @param uri The url or id of the object to be parsed.
	     * @return An instance of the guessed parser.
	     */
	    Loader.prototype.getParserFromData = function (data) {
	        var len = Loader._parsers.length;
	        // go in reverse order to allow application override of default parser added in away.proper
	        for (var i = len - 1; i >= 0; i--)
	            if (Loader._parsers[i].supportsData(data))
	                return new Loader._parsers[i]();
	        return null;
	    };
	    /**
	     * Initiates parsing of the loaded dependency.
	     *
	     * @param The dependency to be parsed.
	     */
	    Loader.prototype.parseDependency = function (dependency) {
	        var parser = dependency.parser;
	        // If no parser has been defined, try to find one by letting
	        // all plugged in parsers inspect the actual data.
	        if (!parser)
	            dependency._iSetParser(parser = this.getParserFromData(dependency.data));
	        if (parser) {
	            parser.addEventListener(ParserEvent_1.ParserEvent.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
	            parser.addEventListener(ParserEvent_1.ParserEvent.PARSE_COMPLETE, this._onParseCompleteDelegate);
	            parser.addEventListener(ParserEvent_1.ParserEvent.PARSE_ERROR, this._onParseErrorDelegate);
	            parser.addEventListener(AssetEvent_1.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
	            parser.addEventListener(AssetEvent_1.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
	            if (dependency.request && dependency.request.url)
	                parser._iFileName = dependency.request.url;
	            parser.materialMode = this._materialMode;
	            parser.parseAsync(dependency.data);
	        }
	        else {
	            var handled;
	            var message = "No parser defined. To enable all parsers for auto-detection, use Parsers.enableAllBundled()";
	            var event = new ParserEvent_1.ParserEvent(ParserEvent_1.ParserEvent.PARSE_ERROR, message);
	            if (this.hasEventListener(ParserEvent_1.ParserEvent.PARSE_ERROR)) {
	                this.dispatchEvent(event);
	                handled = true;
	            }
	            else {
	                // TODO: Consider not doing this even when Loader does
	                // have it's own LOAD_ERROR listener
	                var i, len = this._parseErrorHandlers.length;
	                for (i = 0; i < len; i++)
	                    if (!handled)
	                        handled = this._parseErrorHandlers[i](event);
	            }
	            if (handled) {
	                this.retrieveNext();
	            }
	            else {
	                // Error event was not handled by listeners directly on Loader or
	                // on any of the subscribed loaders (in the list of error handlers.)
	                throw new Error(message);
	            }
	        }
	    };
	    /**
	     * Guesses the parser to be used based on the file extension.
	     * @return An instance of the guessed parser.
	     */
	    Loader.prototype.getParserFromSuffix = function (url) {
	        // Get rid of query string if any and extract extension
	        var base = (url.indexOf('?') > 0) ? url.split('?')[0] : url;
	        var fileExtension = base.substr(base.lastIndexOf('.') + 1).toLowerCase();
	        var len = Loader._parsers.length;
	        // go in reverse order to allow application override of default parser added in away.proper
	        for (var i = len - 1; i >= 0; i--) {
	            var parserClass = Loader._parsers[i];
	            if (parserClass.supportsType(fileExtension))
	                return new parserClass();
	        }
	        return null;
	    };
	    // Image parser only parser that is added by default, to save file size.
	    Loader._parsers = new Array();
	    return Loader;
	}(EventDispatcher_1.EventDispatcher));
	exports.Loader = Loader;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequestMethod_1 = __webpack_require__(164);
	var URLVariables_1 = __webpack_require__(165);
	var EventDispatcher_1 = __webpack_require__(11);
	var URLLoaderEvent_1 = __webpack_require__(166);
	/**
	 * The URLLoader is used to load a single file, as part of a resource.
	 *
	 * While URLLoader can be used directly, e.g. to create a third-party asset
	 * management system, it's recommended to use any of the classes Loader3D, Loader
	 * and AssetLibrary instead in most cases.
	 *
	 * @see Loader
	 * @see away.library.AssetLibrary
	 */
	var URLLoader = (function (_super) {
	    __extends(URLLoader, _super);
	    /**
	     * Creates a new URLLoader object.
	     */
	    function URLLoader() {
	        _super.call(this);
	        this._bytesLoaded = 0;
	        this._bytesTotal = 0;
	        this._dataFormat = URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT;
	        this._loadError = false;
	    }
	    Object.defineProperty(URLLoader.prototype, "url", {
	        /**
	         *
	         */
	        get: function () {
	            return this._request ? this._request.url : '';
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "data", {
	        /**
	         *
	         */
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "dataFormat", {
	        get: function () {
	            return this._dataFormat;
	        },
	        /**
	         *
	         * URLLoaderDataFormat.BINARY
	         * URLLoaderDataFormat.TEXT
	         * URLLoaderDataFormat.VARIABLES
	         *
	         * @param format
	         */
	        set: function (format) {
	            this._dataFormat = format;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._bytesLoaded;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLLoader.prototype, "bytesTotal", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._bytesTotal;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Load a resource from a file.
	     *
	     * @param request The URLRequest object containing the URL of the object to be loaded.
	     */
	    URLLoader.prototype.load = function (request) {
	        this._request = request;
	        this.initXHR();
	        if (request.method === URLRequestMethod_1.URLRequestMethod.POST)
	            this.postRequest(request);
	        else
	            this.getRequest(request);
	    };
	    URLLoader.prototype.isSupported = function () {
	        return window != null;
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.close = function () {
	        this._XHR.abort();
	        this.disposeXHR();
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.dispose = function () {
	        if (this._XHR)
	            this._XHR.abort();
	        this.disposeXHR();
	    };
	    /**
	     *
	     * @param xhr
	     * @param responseType
	     */
	    URLLoader.prototype.setResponseType = function (xhr, responseType) {
	        switch (responseType) {
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.ARRAY_BUFFER:
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.BLOB:
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT:
	                xhr.responseType = responseType;
	                break;
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.VARIABLES:
	                xhr.responseType = URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT;
	                break;
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.BINARY:
	                xhr.responseType = '';
	                break;
	            default:
	        }
	    };
	    /**
	     *
	     * @param request {URLRequest}
	     */
	    URLLoader.prototype.getRequest = function (request) {
	        try {
	            this._XHR.open(request.method, request.url, request.async);
	            this.setResponseType(this._XHR, this._dataFormat);
	            this._XHR.send(); // No data to send
	        }
	        catch (e /* <XMLHttpRequestException> */) {
	            this.handleXmlHttpRequestException(e);
	        }
	    };
	    /**
	     *
	     * @param request {URLRequest}
	     */
	    URLLoader.prototype.postRequest = function (request) {
	        this._loadError = false;
	        this._XHR.open(request.method, request.url, request.async);
	        if (request.data != null) {
	            if (request.data instanceof URLVariables_1.URLVariables) {
	                var urlVars = request.data;
	                try {
	                    this._XHR.responseType = 'text';
	                    this._XHR.send(urlVars.formData);
	                }
	                catch (e /* <XMLHttpRequestException> */) {
	                    this.handleXmlHttpRequestException(e);
	                }
	            }
	            else {
	                this.setResponseType(this._XHR, this._dataFormat);
	                if (request.data)
	                    this._XHR.send(request.data); // TODO: Test
	                else
	                    this._XHR.send(); // no data to send
	            }
	        }
	        else {
	            this._XHR.send(); // No data to send
	        }
	    };
	    /**
	     *
	     * @param error {XMLHttpRequestException}
	     */
	    URLLoader.prototype.handleXmlHttpRequestException = function (error /* <XMLHttpRequestException> */) {
	        switch (error.code) {
	            /******************************************************************************************************************************************************************************************************
	             *
	             *  XMLHttpRequestException { message: "NETWORK_ERR: XMLHttpRequest Exception 101", name: "NETWORK_ERR", code: 101, stack: "Error: A network error occurred in synchronous req…",NETWORK_ERR: 101… }
	             *  code: 101 , message: "NETWORK_ERR: XMLHttpRequest Exception 101" ,  name: "NETWORK_ERR"
	             *
	             ******************************************************************************************************************************************************************************************************/
	            case 101:
	                // Note: onLoadError event throws IO_ERROR event - this case is already Covered
	                break;
	        }
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.initXHR = function () {
	        var _this = this;
	        if (!this._XHR) {
	            this._XHR = new XMLHttpRequest();
	            this._XHR.onloadstart = function (event) { return _this.onLoadStart(event); }; // loadstart	        - When the request starts.
	            this._XHR.onprogress = function (event) { return _this.onProgress(event); }; // progress	            - While loading and sending data.
	            this._XHR.onabort = function (event) { return _this.onAbort(event); }; // abort	            - When the request has been aborted, either by invoking the abort() method or navigating away from the page.
	            this._XHR.onerror = function (event) { return _this.onLoadError(event); }; // error	            - When the request has failed.
	            this._XHR.onload = function (event) { return _this.onLoadComplete(event); }; // load	                - When the request has successfully completed.
	            this._XHR.ontimeout = function (event) { return _this.onTimeOut(event); }; // timeout	            - When the author specified timeout has passed before the request could complete.
	            this._XHR.onloadend = function (event) { return _this.onLoadEnd(event); }; // loadend	            - When the request has completed, regardless of whether or not it was successful.
	            this._XHR.onreadystatechange = function (event) { return _this.onReadyStateChange(event); }; // onreadystatechange   - When XHR state changes
	        }
	    };
	    /**
	     *
	     */
	    URLLoader.prototype.disposeXHR = function () {
	        if (this._XHR !== null) {
	            this._XHR.onloadstart = null;
	            this._XHR.onprogress = null;
	            this._XHR.onabort = null;
	            this._XHR.onerror = null;
	            this._XHR.onload = null;
	            this._XHR.ontimeout = null;
	            this._XHR.onloadend = null;
	            this._XHR = null;
	        }
	    };
	    /**
	     *
	     * @param source
	     */
	    URLLoader.prototype.decodeURLVariables = function (source) {
	        var result = new Object();
	        source = source.split("+").join(" ");
	        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
	        while (tokens = re.exec(source))
	            result[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
	        return result;
	    };
	    // XMLHttpRequest - Event Handlers
	    /**
	     * When XHR state changes
	     * @param event
	     */
	    URLLoader.prototype.onReadyStateChange = function (event) {
	        if (this._XHR.readyState == 4) {
	            this._status = this._XHR.status;
	            if (this._status == 404) {
	                this._loadError = true;
	                this.dispatchEvent(this._loadErrorEvent || (this._loadErrorEvent = new URLLoaderEvent_1.URLLoaderEvent(URLLoaderEvent_1.URLLoaderEvent.LOAD_ERROR, this)));
	            }
	            this.dispatchEvent(this._statusEvent || (this._statusEvent = new URLLoaderEvent_1.URLLoaderEvent(URLLoaderEvent_1.URLLoaderEvent.HTTP_STATUS, this)));
	        }
	    };
	    /**
	     * When the request has completed, regardless of whether or not it was successful.
	     * @param event
	     */
	    URLLoader.prototype.onLoadEnd = function (event) {
	        if (this._loadError === true)
	            return;
	    };
	    /**
	     * When the author specified timeout has passed before the request could complete.
	     * @param event
	     */
	    URLLoader.prototype.onTimeOut = function (event) {
	        //TODO: Timeout not currently implemented ( also not part of AS3 API )
	    };
	    /**
	     * When the request has been aborted, either by invoking the abort() method or navigating away from the page.
	     * @param event
	     */
	    URLLoader.prototype.onAbort = function (event) {
	        // TODO: investigate whether this needs to be an IOError
	    };
	    /**
	     * While loading and sending data.
	     * @param event
	     */
	    URLLoader.prototype.onProgress = function (event) {
	        this._bytesTotal = event.total;
	        this._bytesLoaded = event.loaded;
	        this.dispatchEvent(this._progressEvent || (this._progressEvent = new URLLoaderEvent_1.URLLoaderEvent(URLLoaderEvent_1.URLLoaderEvent.LOAD_PROGRESS, this)));
	    };
	    /**
	     * When the request starts.
	     * @param event
	     */
	    URLLoader.prototype.onLoadStart = function (event) {
	        this.dispatchEvent(this._loadStartEvent || (this._loadStartEvent = new URLLoaderEvent_1.URLLoaderEvent(URLLoaderEvent_1.URLLoaderEvent.LOAD_START, this)));
	    };
	    /**
	     * When the request has successfully completed.
	     * @param event
	     */
	    URLLoader.prototype.onLoadComplete = function (event) {
	        if (this._loadError === true)
	            return;
	        switch (this._dataFormat) {
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT:
	                this._data = this._XHR.responseText;
	                break;
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.VARIABLES:
	                this._data = this.decodeURLVariables(this._XHR.responseText);
	                break;
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.BLOB:
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.ARRAY_BUFFER:
	            case URLLoaderDataFormat_1.URLLoaderDataFormat.BINARY:
	                this._data = this._XHR.response;
	                break;
	            default:
	                this._data = this._XHR.responseText;
	                break;
	        }
	        this.dispatchEvent(this._loadCompleteEvent || (this._loadCompleteEvent = new URLLoaderEvent_1.URLLoaderEvent(URLLoaderEvent_1.URLLoaderEvent.LOAD_COMPLETE, this)));
	    };
	    /**
	     * When the request has failed. ( due to network issues ).
	     * @param event
	     */
	    URLLoader.prototype.onLoadError = function (event) {
	        this._loadError = true;
	        this.dispatchEvent(this._loadErrorEvent || (this._loadErrorEvent = new URLLoaderEvent_1.URLLoaderEvent(URLLoaderEvent_1.URLLoaderEvent.LOAD_ERROR, this)));
	    };
	    return URLLoader;
	}(EventDispatcher_1.EventDispatcher));
	exports.URLLoader = URLLoader;


/***/ },
/* 163 */
/***/ function(module, exports) {

	"use strict";
	var URLLoaderDataFormat = (function () {
	    function URLLoaderDataFormat() {
	    }
	    /**
	     * TEXT
	     * @type {string}
	     */
	    URLLoaderDataFormat.TEXT = "text";
	    /**
	     * Variables / Value Pairs
	     * @type {string}
	     */
	    URLLoaderDataFormat.VARIABLES = "variables";
	    /**
	     *
	     * @type {string}
	     */
	    URLLoaderDataFormat.BLOB = "blob";
	    /**
	     *
	     * @type {string}
	     */
	    URLLoaderDataFormat.ARRAY_BUFFER = "arraybuffer";
	    /**
	     *
	     * @type {string}
	     */
	    URLLoaderDataFormat.BINARY = "binary";
	    return URLLoaderDataFormat;
	}());
	exports.URLLoaderDataFormat = URLLoaderDataFormat;


/***/ },
/* 164 */
/***/ function(module, exports) {

	"use strict";
	var URLRequestMethod = (function () {
	    function URLRequestMethod() {
	    }
	    /**
	     *
	     * @type {string}
	     */
	    URLRequestMethod.POST = 'POST';
	    /**
	     *
	     * @type {string}
	     */
	    URLRequestMethod.GET = 'GET';
	    return URLRequestMethod;
	}());
	exports.URLRequestMethod = URLRequestMethod;


/***/ },
/* 165 */
/***/ function(module, exports) {

	"use strict";
	var URLVariables = (function () {
	    /**
	     *
	     * @param source
	     */
	    function URLVariables(source) {
	        if (source === void 0) { source = null; }
	        this._variables = new Object();
	        if (source !== null)
	            this.decode(source);
	    }
	    /**
	     *
	     * @param source
	     */
	    URLVariables.prototype.decode = function (source) {
	        source = source.split("+").join(" ");
	        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
	        while (tokens = re.exec(source))
	            this._variables[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
	    };
	    /**
	     *
	     * @returns {string}
	     */
	    URLVariables.prototype.toString = function () {
	        return '';
	    };
	    Object.defineProperty(URLVariables.prototype, "variables", {
	        /**
	         *
	         * @returns {Object}
	         */
	        get: function () {
	            return this._variables;
	        },
	        /**
	         *
	         * @returns {Object}
	         */
	        set: function (obj) {
	            this._variables = obj;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(URLVariables.prototype, "formData", {
	        /**
	         *
	         * @returns {Object}
	         */
	        get: function () {
	            var fd = new FormData();
	            for (var s in this._variables)
	                fd.append(s, this._variables[s]);
	            return fd;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return URLVariables;
	}());
	exports.URLVariables = URLVariables;


/***/ },
/* 166 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var URLLoaderEvent = (function (_super) {
	    __extends(URLLoaderEvent, _super);
	    function URLLoaderEvent(type, urlLoader) {
	        _super.call(this, type);
	        this._urlLoader = urlLoader;
	    }
	    Object.defineProperty(URLLoaderEvent.prototype, "urlLoader", {
	        /**
	         *
	         */
	        get: function () {
	            return this._urlLoader;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    URLLoaderEvent.prototype.clone = function () {
	        return new URLLoaderEvent(this.type, this._urlLoader);
	    };
	    URLLoaderEvent.HTTP_STATUS = "httpStatus";
	    URLLoaderEvent.LOAD_ERROR = "loadError";
	    URLLoaderEvent.LOAD_PROGRESS = "loadProgress";
	    URLLoaderEvent.LOAD_START = "loadStart";
	    URLLoaderEvent.LOAD_COMPLETE = "loadComplete";
	    return URLLoaderEvent;
	}(EventBase_1.EventBase));
	exports.URLLoaderEvent = URLLoaderEvent;


/***/ },
/* 167 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var LoaderEvent = (function (_super) {
	    __extends(LoaderEvent, _super);
	    /**
	     * Create a new LoaderEvent object.
	     *
	     * @param type The event type.
	     * @param url The url of the loaded resource.
	     * @param assets The assets of the loaded resource.
	     */
	    function LoaderEvent(type, url, content, assets) {
	        if (url === void 0) { url = null; }
	        if (content === void 0) { content = null; }
	        if (assets === void 0) { assets = null; }
	        _super.call(this, type);
	        this._url = url;
	        this._content = content;
	        this._assets = assets;
	    }
	    Object.defineProperty(LoaderEvent.prototype, "content", {
	        /**
	         * The content returned if the resource has been loaded inside a <code>Loader</code> object.
	         */
	        get: function () {
	            return this._content;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderEvent.prototype, "url", {
	        /**
	         * The url of the loaded resource.
	         */
	        get: function () {
	            return this._url;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderEvent.prototype, "assets", {
	        /**
	         * The error string on loadError.
	         */
	        get: function () {
	            return this._assets;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the current event.
	     * @return An exact duplicate of the current event.
	     */
	    LoaderEvent.prototype.clone = function () {
	        return new LoaderEvent(this.type, this._url, this._content, this._assets);
	    };
	    /**
	     * Dispatched when the loading of a session and all of its dependencies is complete.
	     */
	    LoaderEvent.LOAD_COMPLETE = "loadComplete";
	    return LoaderEvent;
	}(EventBase_1.EventBase));
	exports.LoaderEvent = LoaderEvent;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var ParserEvent = (function (_super) {
	    __extends(ParserEvent, _super);
	    function ParserEvent(type, message) {
	        if (message === void 0) { message = ''; }
	        _super.call(this, type);
	        this._message = message;
	    }
	    Object.defineProperty(ParserEvent.prototype, "message", {
	        /**
	         * Additional human-readable message. Usually supplied for ParserEvent.PARSE_ERROR events.
	         */
	        get: function () {
	            return this._message;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParserEvent.prototype.clone = function () {
	        return new ParserEvent(this.type, this._message);
	    };
	    /**
	     * Dispatched when parsing of an asset completed.
	     */
	    ParserEvent.PARSE_COMPLETE = 'parseComplete';
	    /**
	     * Dispatched when an error occurs while parsing the data (e.g. because it's
	     * incorrectly formatted.)
	     */
	    ParserEvent.PARSE_ERROR = 'parseError';
	    /**
	     * Dispatched when a parser is ready to have dependencies retrieved and resolved.
	     * This is an internal event that should rarely (if ever) be listened for by
	     * external classes.
	     */
	    ParserEvent.READY_FOR_DEPENDENCIES = 'readyForDependencies';
	    return ParserEvent;
	}(EventBase_1.EventBase));
	exports.ParserEvent = ParserEvent;


/***/ },
/* 169 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * ResourceDependency represents the data required to load, parse and resolve additional files ("dependencies")
	 * required by a parser, used by ResourceLoadSession.
	 *
	 */
	var ResourceDependency = (function () {
	    function ResourceDependency(id, request, data, parser, parentParser, retrieveAsRawData, suppressAssetEvents, sub_id) {
	        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
	        if (suppressAssetEvents === void 0) { suppressAssetEvents = false; }
	        if (sub_id === void 0) { sub_id = 0; }
	        this._id = id;
	        this._sub_id = sub_id;
	        this._request = request;
	        this._data = data;
	        this._parser = parser;
	        this._parentParser = parentParser;
	        this._retrieveAsRawData = retrieveAsRawData;
	        this._suppressAssetEvents = suppressAssetEvents;
	        this._assets = new Array();
	        this._dependencies = new Array();
	    }
	    Object.defineProperty(ResourceDependency.prototype, "id", {
	        /**
	         *
	         */
	        get: function () {
	            return this._id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "sub_id", {
	        get: function () {
	            return this._sub_id;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "request", {
	        /**
	         *
	         */
	        get: function () {
	            return this._request;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "data", {
	        /**
	         * The data containing the dependency to be parsed, if the resource was already loaded.
	         */
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "parser", {
	        /**
	         *
	         */
	        get: function () {
	            return this._parser;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "parentParser", {
	        /**
	         * The parser which is dependent on this ResourceDependency object.
	         */
	        get: function () {
	            return this._parentParser;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "retrieveAsRawData", {
	        /**
	         *
	         */
	        get: function () {
	            return this._retrieveAsRawData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "suppresAssetEvents", {
	        /**
	         *
	         */
	        get: function () {
	            return this._suppressAssetEvents;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "assets", {
	        /**
	         *
	         */
	        get: function () {
	            return this._assets;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResourceDependency.prototype, "dependencies", {
	        /**
	         *
	         */
	        get: function () {
	            return this._dependencies;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @private
	     * Method to set data after having already created the dependency object, e.g. after load.
	     */
	    ResourceDependency.prototype._iSetData = function (data) {
	        this._data = data;
	    };
	    /**
	     * @private
	     *
	     */
	    ResourceDependency.prototype._iSetParser = function (parser) {
	        this._parser = parser;
	    };
	    /**
	     * Resolve the dependency when it's loaded with the parent parser. For example, a dependency containing an
	     * ImageResource would be assigned to a Mesh instance as a BitmapMaterial, a scene graph object would be added
	     * to its intended parent. The dependency should be a member of the dependencies property.
	     */
	    ResourceDependency.prototype.resolve = function () {
	        if (this._parentParser)
	            this._parentParser._iResolveDependency(this);
	    };
	    /**
	     * Resolve a dependency failure. For example, map loading failure from a 3d file
	     */
	    ResourceDependency.prototype.resolveFailure = function () {
	        if (this._parentParser)
	            this._parentParser._iResolveDependencyFailure(this);
	    };
	    /**
	     * Resolve the dependencies name
	     */
	    ResourceDependency.prototype.resolveName = function (asset) {
	        if (this._parentParser)
	            return this._parentParser._iResolveDependencyName(this, asset);
	        return asset.name;
	    };
	    return ResourceDependency;
	}());
	exports.ResourceDependency = ResourceDependency;


/***/ },
/* 170 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Enumaration export class for precedence when resolving naming conflicts in the library.
	 *
	 * @see away.library.AssetLibrary.conflictPrecedence
	 * @see away.library.AssetLibrary.conflictStrategy
	 * @see away.library.naming.ConflictStrategy
	 */
	var ConflictPrecedence = (function () {
	    function ConflictPrecedence() {
	    }
	    /**
	     * Signals that in a conflict, the previous owner of the conflicting name
	     * should be favored (and keep it's name) and that the newly renamed asset
	     * is reverted to a non-conflicting name.
	     */
	    ConflictPrecedence.FAVOR_OLD = 'favorOld';
	    /**
	     * Signales that in a conflict, the newly renamed asset is favored (and keeps
	     * it's newly defined name) and that the previous owner of that name gets
	     * renamed to a non-conflicting name.
	     */
	    ConflictPrecedence.FAVOR_NEW = 'favorNew';
	    return ConflictPrecedence;
	}());
	exports.ConflictPrecedence = ConflictPrecedence;


/***/ },
/* 171 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ErrorConflictStrategy_1 = __webpack_require__(172);
	var IgnoreConflictStrategy_1 = __webpack_require__(174);
	var NumSuffixConflictStrategy_1 = __webpack_require__(175);
	/**
	 * Enumeration export class for bundled conflict strategies. Set one of these values (or an
	 * instance of a self-defined sub-export class of ConflictStrategyBase) to the conflictStrategy
	 * property on an AssetLibrary to define how that library resolves naming conflicts.
	 *
	 * The value of the <code>AssetLibrary.conflictPrecedence</code> property defines which
	 * of the conflicting assets will get to keep it's name, and which is renamed (if any.)
	 *
	 * @see away.library.AssetLibrary.conflictStrategy
	 * @see away.library.naming.ConflictStrategyBase
	 */
	var ConflictStrategy = (function () {
	    function ConflictStrategy(include) {
	        //TODO: find out why typescript d.ts files do not include this class
	    }
	    /**
	     * Specifies that in case of a naming conflict, one of the assets will be renamed and
	     * a numeric suffix appended to the base name.
	     */
	    ConflictStrategy.APPEND_NUM_SUFFIX = new NumSuffixConflictStrategy_1.NumSuffixConflictStrategy();
	    /**
	     * Specifies that naming conflicts should be ignored. This is not recommended in most
	     * cases, unless it can be 100% guaranteed that the application does not cause naming
	     * conflicts in the library (i.e. when an app-level system is in place to prevent this.)
	     */
	    ConflictStrategy.IGNORE = new IgnoreConflictStrategy_1.IgnoreConflictStrategy();
	    /**
	     * Specifies that an error should be thrown if a naming conflict is discovered. Use this
	     * to be 100% sure that naming conflicts never occur unnoticed, and when it's undesirable
	     * to have the library automatically rename assets to avoid such conflicts.
	     */
	    ConflictStrategy.THROW_ERROR = new ErrorConflictStrategy_1.ErrorConflictStrategy();
	    return ConflictStrategy;
	}());
	exports.ConflictStrategy = ConflictStrategy;


/***/ },
/* 172 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ConflictStrategyBase_1 = __webpack_require__(173);
	var ErrorBase_1 = __webpack_require__(8);
	var ErrorConflictStrategy = (function (_super) {
	    __extends(ErrorConflictStrategy, _super);
	    function ErrorConflictStrategy() {
	        _super.call(this);
	    }
	    ErrorConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        throw new ErrorBase_1.ErrorBase('Asset name collision while AssetLibrary.namingStrategy set to AssetLibrary.THROW_ERROR. Asset path: ' + changedAsset.assetFullPath);
	    };
	    ErrorConflictStrategy.prototype.create = function () {
	        return new ErrorConflictStrategy();
	    };
	    return ErrorConflictStrategy;
	}(ConflictStrategyBase_1.ConflictStrategyBase));
	exports.ErrorConflictStrategy = ErrorConflictStrategy;


/***/ },
/* 173 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ConflictPrecedence_1 = __webpack_require__(170);
	var AbstractMethodError_1 = __webpack_require__(7);
	var AssetEvent_1 = __webpack_require__(9);
	/**
	 * Abstract base export class for naming conflict resolution classes. Extend this to create a
	 * strategy export class which the asset library can use to resolve asset naming conflicts, or
	 * use one of the bundled concrete strategy classes:
	 *
	 * <ul>
	 *   <li>IgnoreConflictStrategy (ConflictStrategy.IGNORE)</li>
	 *   <li>ErrorConflictStrategy (ConflictStrategy.THROW_ERROR)</li>
	 *   <li>NumSuffixConflictStrategy (ConflictStrategy.APPEND_NUM_SUFFIX)</li>
	 * </ul>
	 *
	 * @see away.library.AssetLibrary.conflictStrategy
	 * @see away.library.ConflictStrategy
	 * @see away.library.IgnoreConflictStrategy
	 * @see away.library.ErrorConflictStrategy
	 * @see away.library.NumSuffixConflictStrategy
	 */
	var ConflictStrategyBase = (function () {
	    function ConflictStrategyBase() {
	    }
	    /**
	     * Resolve a naming conflict between two assets. Must be implemented by concrete strategy
	     * classes.
	     */
	    ConflictStrategyBase.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Create instance of this conflict strategy. Used internally by the AssetLibrary to
	     * make sure the same strategy instance is not used in all AssetLibrary instances, which
	     * would break any state caching that happens inside the strategy class.
	     */
	    ConflictStrategyBase.prototype.create = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Provided as a convenience method for all conflict strategy classes, as a way to finalize
	     * the conflict resolution by applying the new names and dispatching the correct events.
	     */
	    ConflictStrategyBase.prototype._pUpdateNames = function (ns, nonConflictingName, oldAsset, newAsset, assetsDictionary, precedence) {
	        var loser_prev_name;
	        var winner;
	        var loser;
	        winner = (precedence === ConflictPrecedence_1.ConflictPrecedence.FAVOR_NEW) ? newAsset : oldAsset;
	        loser = (precedence === ConflictPrecedence_1.ConflictPrecedence.FAVOR_NEW) ? oldAsset : newAsset;
	        loser_prev_name = loser.name;
	        assetsDictionary[winner.name] = winner;
	        assetsDictionary[nonConflictingName] = loser;
	        loser.resetAssetPath(nonConflictingName, ns, false);
	        loser.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.ASSET_CONFLICT_RESOLVED, loser, loser_prev_name));
	    };
	    return ConflictStrategyBase;
	}());
	exports.ConflictStrategyBase = ConflictStrategyBase;


/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ConflictStrategyBase_1 = __webpack_require__(173);
	var IgnoreConflictStrategy = (function (_super) {
	    __extends(IgnoreConflictStrategy, _super);
	    function IgnoreConflictStrategy() {
	        _super.call(this);
	    }
	    IgnoreConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        // Do nothing, ignore the fact that there is a conflict.
	        return;
	    };
	    IgnoreConflictStrategy.prototype.create = function () {
	        return new IgnoreConflictStrategy();
	    };
	    return IgnoreConflictStrategy;
	}(ConflictStrategyBase_1.ConflictStrategyBase));
	exports.IgnoreConflictStrategy = IgnoreConflictStrategy;


/***/ },
/* 175 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ConflictStrategyBase_1 = __webpack_require__(173);
	var NumSuffixConflictStrategy = (function (_super) {
	    __extends(NumSuffixConflictStrategy, _super);
	    function NumSuffixConflictStrategy(separator) {
	        if (separator === void 0) { separator = '.'; }
	        _super.call(this);
	        this._separator = separator;
	        this._next_suffix = {};
	    }
	    NumSuffixConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
	        var orig;
	        var new_name;
	        var base;
	        var suffix;
	        orig = changedAsset.name;
	        if (orig.indexOf(this._separator) >= 0) {
	            // Name has an ocurrence of the separator, so get base name and suffix,
	            // unless suffix is non-numerical, in which case revert to zero and
	            // use entire name as base
	            base = orig.substring(0, orig.lastIndexOf(this._separator));
	            suffix = parseInt(orig.substring(base.length - 1));
	            if (isNaN(suffix)) {
	                base = orig;
	                suffix = 0;
	            }
	        }
	        else {
	            base = orig;
	            suffix = 0;
	        }
	        if (suffix == 0 && this._next_suffix.hasOwnProperty(base)) {
	            suffix = this._next_suffix[base];
	        }
	        // Find the first suffixed name that does
	        // not collide with other names.
	        do {
	            suffix++;
	            new_name = base.concat(this._separator, suffix.toString());
	        } while (assetsDictionary.hasOwnProperty(new_name));
	        this._next_suffix[base] = suffix;
	        this._pUpdateNames(oldAsset.assetNamespace, new_name, oldAsset, changedAsset, assetsDictionary, precedence);
	    };
	    NumSuffixConflictStrategy.prototype.create = function () {
	        return new NumSuffixConflictStrategy(this._separator);
	    };
	    return NumSuffixConflictStrategy;
	}(ConflictStrategyBase_1.ConflictStrategyBase));
	exports.NumSuffixConflictStrategy = NumSuffixConflictStrategy;


/***/ },
/* 176 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var Sprite_1 = __webpack_require__(177);
	var TextField_1 = __webpack_require__(191);
	var MouseEvent_1 = __webpack_require__(195);
	var Timeline_1 = __webpack_require__(26);
	var FrameScriptManager_1 = __webpack_require__(29);
	var MovieClip = (function (_super) {
	    __extends(MovieClip, _super);
	    function MovieClip(timeline) {
	        var _this = this;
	        if (timeline === void 0) { timeline = null; }
	        _super.call(this);
	        this._isButton = false;
	        this._time = 0; // the current time inside the animation
	        this._currentFrameIndex = -1; // the current frame
	        this._isPlaying = true; // false if paused or stopped
	        this._isInit = true;
	        this._potentialInstances = [];
	        this._depth_sessionIDs = {};
	        this._sessionID_childs = {};
	        /**
	         *
	         */
	        this.loop = true;
	        /**
	         * the current index of the current active frame
	         */
	        this.constructedKeyFrameIndex = -1;
	        this._enterFrame = new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.ENTER_FRAME, this);
	        this.inheritColorTransform = true;
	        this._onMouseOver = function (event) { return _this.currentFrameIndex = 1; };
	        this._onMouseOut = function (event) { return _this.currentFrameIndex = 0; };
	        this._onMouseDown = function (event) { return _this.currentFrameIndex = 2; };
	        this._onMouseUp = function (event) { return _this.currentFrameIndex = _this.currentFrameIndex == 0 ? 0 : 1; };
	        this._timeline = timeline || new Timeline_1.Timeline();
	    }
	    Object.defineProperty(MovieClip.prototype, "adapter", {
	        /**
	         * adapter is used to provide MovieClip to scripts taken from different platforms
	         * setter typically managed by factory
	         */
	        get: function () {
	            return this._adapter;
	        },
	        set: function (value) {
	            this._adapter = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MovieClip.prototype.dispose = function () {
	        this.disposeValues();
	        MovieClip._movieClips.push(this);
	    };
	    MovieClip.prototype.disposeValues = function () {
	        _super.prototype.disposeValues.call(this);
	        this._potentialInstances = [];
	        this._depth_sessionIDs = {};
	        this._sessionID_childs = {};
	    };
	    MovieClip.prototype.reset_textclones = function () {
	        if (this.timeline) {
	            var len = this._potentialInstances.length;
	            for (var i = 0; i < len; i++) {
	                if (this._potentialInstances[i] != null) {
	                    if (this._potentialInstances[i].isAsset(TextField_1.TextField))
	                        this._potentialInstances[i].text = this.timeline.getPotentialChildPrototype(i).text;
	                    else if (this._potentialInstances[i].isAsset(MovieClip))
	                        this._potentialInstances[i].reset_textclones();
	                }
	            }
	        }
	    };
	    Object.defineProperty(MovieClip.prototype, "isInit", {
	        get: function () {
	            return this._isInit;
	        },
	        set: function (value) {
	            this._isInit = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MovieClip.prototype, "timeline", {
	        get: function () {
	            return this._timeline;
	        },
	        set: function (value) {
	            this._timeline = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MovieClip.prototype, "numFrames", {
	        get: function () {
	            return this._timeline.numFrames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MovieClip.prototype.jumpToLabel = function (label) {
	        // the timeline.jumpTolabel will set currentFrameIndex
	        this._timeline.jumpToLabel(this, label);
	    };
	    MovieClip.prototype.reset = function () {
	        _super.prototype.reset.call(this);
	        // time only is relevant for the root mc, as it is the only one that executes the update function
	        this._time = 0;
	        if (this.adapter)
	            this.adapter.freeFromScript();
	        this.constructedKeyFrameIndex = -1;
	        for (var i = this.numChildren - 1; i >= 0; i--)
	            this.removeChildAt(i);
	        this._skipAdvance = MovieClip._skipAdvance;
	        var numFrames = this._timeline.keyframe_indices.length;
	        this._isPlaying = Boolean(numFrames > 1);
	        if (numFrames) {
	            this._currentFrameIndex = 0;
	            this._timeline.constructNextFrame(this, true, true);
	        }
	        else {
	            this._currentFrameIndex = -1;
	        }
	    };
	    MovieClip.prototype.resetSessionIDs = function () {
	        this._depth_sessionIDs = {};
	    };
	    Object.defineProperty(MovieClip.prototype, "currentFrameIndex", {
	        /*
	        * Setting the currentFrameIndex will move the playhead for this movieclip to the new position
	         */
	        get: function () {
	            return this._currentFrameIndex;
	        },
	        set: function (value) {
	            //if currentFrame is set greater than the available number of
	            //frames, the playhead is moved to the last frame in the timeline.
	            //But because the frame specified was not a keyframe, no scripts are
	            //executed, even if they exist on the last frame.
	            var skip_script = false;
	            var numFrames = this._timeline.keyframe_indices.length;
	            if (!numFrames)
	                return;
	            if (value < 0) {
	                value = 0;
	            }
	            else if (value >= numFrames) {
	                value = numFrames - 1;
	                skip_script = true;
	            }
	            if (this._currentFrameIndex == value)
	                return;
	            this._currentFrameIndex = value;
	            //changing current frame will ignore advance command for that
	            //update's advanceFrame function, unless advanceFrame has
	            //already been executed
	            this._skipAdvance = MovieClip._skipAdvance;
	            this._timeline.gotoFrame(this, value, skip_script);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MovieClip.prototype.addButtonListeners = function () {
	        this._isButton = true;
	        this.stop();
	        this.addEventListener(MouseEvent_1.MouseEvent.MOUSE_OVER, this._onMouseOver);
	        this.addEventListener(MouseEvent_1.MouseEvent.MOUSE_OUT, this._onMouseOut);
	        this.addEventListener(MouseEvent_1.MouseEvent.MOUSE_DOWN, this._onMouseDown);
	        this.addEventListener(MouseEvent_1.MouseEvent.MOUSE_UP, this._onMouseUp);
	    };
	    MovieClip.prototype.removeButtonListeners = function () {
	        this.removeEventListener(MouseEvent_1.MouseEvent.MOUSE_OVER, this._onMouseOver);
	        this.removeEventListener(MouseEvent_1.MouseEvent.MOUSE_OUT, this._onMouseOut);
	        this.removeEventListener(MouseEvent_1.MouseEvent.MOUSE_DOWN, this._onMouseDown);
	        this.removeEventListener(MouseEvent_1.MouseEvent.MOUSE_UP, this._onMouseUp);
	    };
	    MovieClip.prototype.getChildAtSessionID = function (sessionID) {
	        return this._sessionID_childs[sessionID];
	    };
	    MovieClip.prototype.getSessionIDDepths = function () {
	        return this._depth_sessionIDs;
	    };
	    MovieClip.prototype.addChildAtDepth = function (child, depth, replace) {
	        if (replace === void 0) { replace = true; }
	        //this should be implemented for all display objects
	        child.inheritColorTransform = true;
	        child.reset(); // this takes care of transform and visibility
	        return _super.prototype.addChildAtDepth.call(this, child, depth, replace);
	    };
	    MovieClip.prototype._addTimelineChildAt = function (child, depth, sessionID) {
	        this._depth_sessionIDs[depth] = child._sessionID = sessionID;
	        this._sessionID_childs[sessionID] = child;
	        return this.addChildAtDepth(child, depth);
	    };
	    MovieClip.prototype.removeChildAtInternal = function (index) {
	        var child = this._children[index];
	        if (child.adapter)
	            child.adapter.freeFromScript();
	        this.adapter.unregisterScriptObject(child);
	        //check to make sure _depth_sessionIDs wasn't modified with a new child
	        if (this._depth_sessionIDs[child._depthID] == child._sessionID)
	            delete this._depth_sessionIDs[child._depthID];
	        delete this._sessionID_childs[child._sessionID];
	        child._sessionID = -1;
	        return _super.prototype.removeChildAtInternal.call(this, index);
	    };
	    Object.defineProperty(MovieClip.prototype, "assetType", {
	        get: function () {
	            return MovieClip.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Starts playback of animation from current position
	     */
	    MovieClip.prototype.play = function () {
	        if (this._timeline.keyframe_indices.length > 1)
	            this._isPlaying = true;
	    };
	    /**
	     * should be called right before the call to away3d-render.
	     */
	    MovieClip.prototype.update = function () {
	        MovieClip._skipAdvance = true;
	        this.advanceFrame();
	        MovieClip._skipAdvance = false;
	        // after we advanced the scenegraph, we might have some script that needs executing
	        FrameScriptManager_1.FrameScriptManager.execute_queue();
	        // now we want to execute the onEnter
	        this.dispatchEvent(this._enterFrame);
	        // after we executed the onEnter, we might have some script that needs executing
	        FrameScriptManager_1.FrameScriptManager.execute_queue();
	        // now we execute any intervals queued
	        FrameScriptManager_1.FrameScriptManager.execute_intervals();
	        // finally, we execute any scripts that were added from intervals
	        FrameScriptManager_1.FrameScriptManager.execute_queue();
	        //execute any disposes as a result of framescripts
	        FrameScriptManager_1.FrameScriptManager.execute_dispose();
	    };
	    MovieClip.prototype.getPotentialChildInstance = function (id) {
	        if (!this._potentialInstances[id])
	            this._potentialInstances[id] = this._timeline.getPotentialChildInstance(id);
	        return this._potentialInstances[id];
	    };
	    /**
	     * Stop playback of animation and hold current position
	     */
	    MovieClip.prototype.stop = function () {
	        this._isPlaying = false;
	    };
	    MovieClip.prototype.clone = function () {
	        var newInstance = (MovieClip._movieClips.length) ? MovieClip._movieClips.pop() : new MovieClip(this._timeline);
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    MovieClip.prototype.copyTo = function (newInstance) {
	        _super.prototype.copyTo.call(this, newInstance);
	        newInstance.timeline = this._timeline;
	        newInstance.loop = this.loop;
	    };
	    MovieClip.prototype.advanceFrame = function () {
	        if (this._isPlaying && !this._skipAdvance) {
	            if (this._currentFrameIndex == this._timeline.keyframe_indices.length - 1) {
	                if (this.loop)
	                    this.currentFrameIndex = 0;
	                else
	                    this._isPlaying = false;
	            }
	            else {
	                this._currentFrameIndex++;
	                this._timeline.constructNextFrame(this);
	            }
	        }
	        var len = this._children.length;
	        var child;
	        for (var i = 0; i < len; ++i) {
	            child = this._children[i];
	            if (child.isAsset(MovieClip))
	                child.advanceFrame();
	        }
	        this._skipAdvance = false;
	    };
	    // DEBUG CODE:
	    MovieClip.prototype.logHierarchy = function (depth) {
	        if (depth === void 0) { depth = 0; }
	        this.printHierarchyName(depth, this);
	        var len = this._children.length;
	        var child;
	        for (var i = 0; i < len; i++) {
	            child = this._children[i];
	            if (child.isAsset(MovieClip))
	                child.logHierarchy(depth + 1);
	            else
	                this.printHierarchyName(depth + 1, child);
	        }
	    };
	    MovieClip.prototype.printHierarchyName = function (depth, target) {
	        var str = "";
	        for (var i = 0; i < depth; ++i)
	            str += "--";
	        str += " " + target.name + " = " + target.id;
	        console.log(str);
	    };
	    MovieClip.prototype.clear = function () {
	        //clear out potential instances
	        var len = this._potentialInstances.length;
	        for (var i = 0; i < len; i++) {
	            var instance = this._potentialInstances[i];
	            //only dispose instances that are not used in script ie. do not have an instance name
	            if (instance && instance.name == "") {
	                FrameScriptManager_1.FrameScriptManager.add_child_to_dispose(instance);
	                delete this._potentialInstances[i];
	            }
	        }
	        _super.prototype.clear.call(this);
	    };
	    MovieClip._movieClips = new Array();
	    MovieClip.assetType = "[asset MovieClip]";
	    return MovieClip;
	}(Sprite_1.Sprite));
	exports.MovieClip = MovieClip;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MovieClip;


/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var Point_1 = __webpack_require__(58);
	var Vector3D_1 = __webpack_require__(34);
	var Graphics_1 = __webpack_require__(178);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	/**
	 * Sprite is an instance of a Graphics, augmenting it with a presence in the scene graph, a material, and an animation
	 * state. It consists out of Graphices, which in turn correspond to SubGeometries. Graphices allow different parts
	 * of the graphics to be assigned different materials.
	 */
	var Sprite = (function (_super) {
	    __extends(Sprite, _super);
	    /**
	     * Create a new Sprite object.
	     *
	     * @param material    [optional]        The material with which to render the Sprite.
	     */
	    function Sprite(material) {
	        var _this = this;
	        if (material === void 0) { material = null; }
	        _super.call(this);
	        //temp point used in hit testing
	        this._tempPoint = new Point_1.Point();
	        this._onGraphicsInvalidateDelegate = function (event) { return _this._onGraphicsInvalidate(event); };
	        this._graphics = new Graphics_1.Graphics(); //unique graphics object for each Sprite
	        this._graphics.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onGraphicsInvalidateDelegate);
	        this.material = material;
	    }
	    Object.defineProperty(Sprite.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Sprite.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "graphics", {
	        /**
	         * Specifies the Graphics object belonging to this Sprite object, where
	         * drawing commands can occur.
	         */
	        get: function () {
	            if (this._iSourcePrefab)
	                this._iSourcePrefab._iValidate();
	            return this._graphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "animator", {
	        /**
	         * Defines the animator of the graphics object.  Default value is <code>null</code>.
	         */
	        get: function () {
	            return this._graphics.animator;
	        },
	        set: function (value) {
	            if (this._graphics.animator)
	                this._graphics.animator.removeOwner(this);
	            this._graphics.animator = value;
	            if (this._graphics.animator)
	                this._graphics.animator.addOwner(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "material", {
	        /**
	         * The material with which to render the Sprite.
	         */
	        get: function () {
	            return this._graphics.material;
	        },
	        set: function (value) {
	            this._graphics.material = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Sprite.prototype, "style", {
	        /**
	         *
	         */
	        get: function () {
	            return this._graphics.style;
	        },
	        set: function (value) {
	            this._graphics.style = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    Sprite.prototype.bakeTransformations = function () {
	        this._graphics.applyTransformation(this.transform.matrix3D);
	        this.transform.clearMatrix3D();
	    };
	    /**
	     * @inheritDoc
	     */
	    Sprite.prototype.dispose = function () {
	        this.disposeValues();
	        Sprite._sprites.push(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    Sprite.prototype.disposeValues = function () {
	        _super.prototype.disposeValues.call(this);
	        this._graphics.dispose();
	    };
	    /**
	     * Clones this Sprite instance along with all it's children, while re-using the same
	     * material, graphics and animation set. The returned result will be a copy of this sprite,
	     * containing copies of all of it's children.
	     *
	     * Properties that are re-used (i.e. not cloned) by the new copy include name,
	     * graphics, and material. Properties that are cloned or created anew for the copy
	     * include subSpritees, children of the sprite, and the animator.
	     *
	     * If you want to copy just the sprite, reusing it's graphics and material while not
	     * cloning it's children, the simplest way is to create a new sprite manually:
	     *
	     * <code>
	     * var clone : Sprite = new Sprite(original.graphics, original.material);
	     * </code>
	     */
	    Sprite.prototype.clone = function () {
	        var newInstance = (Sprite._sprites.length) ? Sprite._sprites.pop() : new Sprite();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    Sprite.prototype.copyTo = function (sprite) {
	        _super.prototype.copyTo.call(this, sprite);
	        this._graphics.copyTo(sprite.graphics);
	    };
	    /**
	     * //TODO
	     *
	     * @protected
	     */
	    Sprite.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        this._pBoxBounds.union(this._graphics.getBoxBounds(), this._pBoxBounds);
	    };
	    Sprite.prototype._pUpdateSphereBounds = function () {
	        _super.prototype._pUpdateSphereBounds.call(this);
	        var box = this.getBox();
	        if (!this._center)
	            this._center = new Vector3D_1.Vector3D();
	        this._center.x = box.x + box.width / 2;
	        this._center.y = box.y + box.height / 2;
	        this._center.z = box.z + box.depth / 2;
	        this._pSphereBounds = this._graphics.getSphereBounds(this._center, this._pSphereBounds);
	    };
	    /**
	     * //TODO
	     *
	     * @private
	     */
	    Sprite.prototype._onGraphicsInvalidate = function (event) {
	        if (this._pIsEntity != Boolean(this._graphics.count)) {
	            if (this._pScene)
	                this._pScene._iUnregisterObject(this);
	            this._pIsEntity = Boolean(this._graphics.count);
	            if (this._pScene)
	                this._pScene._iRegisterObject(this);
	        }
	        this._pInvalidateBounds();
	    };
	    /**
	     *
	     * @param renderer
	     *
	     * @internal
	     */
	    Sprite.prototype._acceptTraverser = function (traverser) {
	        this.graphics.acceptTraverser(traverser);
	    };
	    Sprite.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
	        if (this._graphics.count) {
	            this._tempPoint.setTo(x, y);
	            var local = this.globalToLocal(this._tempPoint, this._tempPoint);
	            var box;
	            //early out for box test
	            if (!(box = this.getBox()).contains(local.x, local.y, 0))
	                return false;
	            //early out for non-shape tests
	            if (!shapeFlag)
	                return true;
	            //ok do the graphics thing
	            if (this._graphics._hitTestPointInternal(local.x, local.y))
	                return true;
	        }
	        return _super.prototype._hitTestPointInternal.call(this, x, y, shapeFlag, masksFlag);
	    };
	    Sprite.prototype.clear = function () {
	        _super.prototype.clear.call(this);
	        this._graphics.clear();
	    };
	    Sprite._sprites = new Array();
	    Sprite.assetType = "[asset Sprite]";
	    return Sprite;
	}(DisplayObjectContainer_1.DisplayObjectContainer));
	exports.Sprite = Sprite;


/***/ },
/* 178 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Point_1 = __webpack_require__(58);
	var Box_1 = __webpack_require__(33);
	var Matrix_1 = __webpack_require__(102);
	var AssetBase_1 = __webpack_require__(6);
	var Sampler2D_1 = __webpack_require__(121);
	var AttributesView_1 = __webpack_require__(4);
	var Byte4Attributes_1 = __webpack_require__(12);
	var Float2Attributes_1 = __webpack_require__(14);
	var TriangleElements_1 = __webpack_require__(179);
	var Graphic_1 = __webpack_require__(138);
	var Style_1 = __webpack_require__(24);
	var ElementsEvent_1 = __webpack_require__(127);
	var StyleEvent_1 = __webpack_require__(25);
	var GraphicsPath_1 = __webpack_require__(180);
	var GraphicsFactoryFills_1 = __webpack_require__(187);
	var GraphicsFactoryStrokes_1 = __webpack_require__(189);
	var PartialImplementationError_1 = __webpack_require__(190);
	var JointStyle_1 = __webpack_require__(185);
	var CapsStyle_1 = __webpack_require__(186);
	var GraphicsStrokeStyle_1 = __webpack_require__(184);
	var GraphicsFillStyle_1 = __webpack_require__(183);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	;
	/**
	 *
	 * Graphics is a collection of SubGeometries, each of which contain the actual geometrical data such as vertices,
	 * normals, uvs, etc. It also contains a reference to an animation class, which defines how the geometry moves.
	 * A Graphics object is assigned to a Sprite, a scene graph occurence of the geometry, which in turn assigns
	 * the SubGeometries to its respective TriangleGraphic objects.
	 *
	 *
	 *
	 * @see away.core.base.SubGraphics
	 * @see away.entities.Sprite
	 *
	 * @class Graphics
	 */
	var Graphics = (function (_super) {
	    __extends(Graphics, _super);
	    /**
	     * Creates a new Graphics object.
	     */
	    function Graphics() {
	        var _this = this;
	        _super.call(this);
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	        this._graphics = [];
	        this._current_position = new Point_1.Point();
	        this._current_position = new Point_1.Point();
	        this._queued_fill_pathes = [];
	        this._queued_stroke_pathes = [];
	        this._active_fill_path = null;
	        this._active_stroke_path = null;
	        this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
	        this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
	    }
	    Object.defineProperty(Graphics.prototype, "assetType", {
	        get: function () {
	            return Graphics.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "count", {
	        get: function () {
	            return this._graphics.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "animator", {
	        /**
	         * Defines the animator of the graphics object.  Default value is <code>null</code>.
	         */
	        get: function () {
	            return this._animator;
	        },
	        set: function (value) {
	            this._animator = value;
	            var len = this._graphics.length;
	            var graphic;
	            for (var i = 0; i < len; ++i) {
	                graphic = this._graphics[i];
	                // cause material to be unregistered and registered again to work with the new animation type (if possible)
	                if (graphic.material) {
	                    graphic.material.iRemoveOwner(graphic);
	                    graphic.material.iAddOwner(graphic);
	                }
	                //invalidate any existing graphic objects in case they need to pull new elements
	                graphic.invalidateElements();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "style", {
	        /**
	         *
	         */
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            if (this._style == value)
	                return;
	            if (this._style)
	                this._style.removeEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._style = value;
	            if (this._style)
	                this._style.addEventListener(StyleEvent_1.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
	            this._iInvalidateSurfaces();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "queued_stroke_pathes", {
	        get: function () {
	            return this._queued_stroke_pathes;
	        },
	        set: function (value) {
	            this._queued_stroke_pathes = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "queued_fill_pathes", {
	        get: function () {
	            return this._queued_fill_pathes;
	        },
	        set: function (value) {
	            this._queued_fill_pathes = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Graphics.prototype, "material", {
	        /**
	         * The material with which to render the Graphics.
	         */
	        get: function () {
	            return this._material;
	        },
	        set: function (value) {
	            if (value == this._material)
	                return;
	            var i;
	            var len = this._graphics.length;
	            var graphic;
	            if (this._material)
	                for (i = 0; i < len; i++)
	                    if (!(graphic = this._graphics[i])._iGetExplicitMaterial())
	                        this._material.iRemoveOwner(graphic);
	            this._material = value;
	            if (this._material)
	                for (i = 0; i < len; i++)
	                    if (!(graphic = this._graphics[i])._iGetExplicitMaterial())
	                        this._material.iAddOwner(graphic);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a GraphicBase wrapping a Elements.
	     *
	     * @param elements
	     */
	    Graphics.prototype.addGraphic = function (elements, material, style, count, offset, idx_count, idx_offset) {
	        if (material === void 0) { material = null; }
	        if (style === void 0) { style = null; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        var graphic;
	        if (Graphic_1.Graphic._available.length) {
	            graphic = Graphic_1.Graphic._available.pop();
	            graphic._iIndex = this._graphics.length;
	            graphic.parent = this;
	            graphic.elements = elements;
	            graphic.material = material;
	            graphic.style = style;
	            graphic.count = count;
	            graphic.offset = offset;
	            graphic.idx_count = idx_count;
	            graphic.idx_offset = idx_offset;
	        }
	        else {
	            graphic = new Graphic_1.Graphic(this._graphics.length, this, elements, material, style, count, offset, idx_count, idx_offset);
	        }
	        this._graphics.push(graphic);
	        graphic.addEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	        this.invalidate();
	        return graphic;
	    };
	    Graphics.prototype.removeGraphic = function (graphic) {
	        this._graphics.splice(this._graphics.indexOf(graphic), 1);
	        graphic.removeEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	        graphic.elements = null;
	        graphic.material = null;
	        graphic.style = null;
	        graphic.clear();
	        this.invalidate();
	    };
	    Graphics.prototype.getGraphicAt = function (index) {
	        return this._graphics[index];
	    };
	    Graphics.prototype.applyTransformation = function (transform) {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i) {
	            this._graphics[i].applyTransformation(transform);
	        }
	    };
	    Graphics.prototype.copyTo = function (graphics) {
	        graphics.material = this._material;
	        graphics.style = this.style;
	        graphics.particles = this.particles;
	        graphics.numParticles = this.numParticles;
	        var graphic;
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i) {
	            graphic = this._graphics[i];
	            graphics.addGraphic(graphic.elements, graphic._iGetExplicitMaterial(), graphic._iGetExplicitStyle(), graphic.count, graphic.offset, graphic.idx_count, graphic.idx_offset);
	        }
	        if (this._animator)
	            graphics.animator = this._animator.clone();
	    };
	    Graphics.prototype.clone = function () {
	        var newInstance = new Graphics();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    /**
	     * Scales the geometry.
	     * @param scale The amount by which to scale.
	     */
	    Graphics.prototype.scale = function (scale) {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].scale(scale);
	    };
	    Graphics.prototype.clear = function () {
	        for (var i = this._graphics.length - 1; i >= 0; i--) {
	            this._graphics[i].clear();
	        }
	    };
	    /**
	     * Clears all resources used by the Graphics object, including SubGeometries.
	     */
	    Graphics.prototype.dispose = function () {
	        this.material = null;
	        for (var i = this._graphics.length - 1; i >= 0; i--)
	            this._graphics[i].dispose();
	        if (this._animator)
	            this._animator.dispose();
	    };
	    /**
	     * Scales the uv coordinates (tiling)
	     * @param scaleU The amount by which to scale on the u axis. Default is 1;
	     * @param scaleV The amount by which to scale on the v axis. Default is 1;
	     */
	    Graphics.prototype.scaleUV = function (scaleU, scaleV) {
	        if (scaleU === void 0) { scaleU = 1; }
	        if (scaleV === void 0) { scaleV = 1; }
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].scaleUV(scaleU, scaleV);
	    };
	    Graphics.prototype.getBoxBounds = function () {
	        if (this._boxBoundsInvalid) {
	            this._boxBoundsInvalid = false;
	            if (!this._boxBounds)
	                this._boxBounds = new Box_1.Box();
	            if (this._graphics.length) {
	                this._boxBounds.setBoundIdentity();
	                var len = this._graphics.length;
	                for (var i = 0; i < len; i++) {
	                    this._boxBounds = this._boxBounds.union(this._graphics[i].getBoxBounds(), this._boxBounds);
	                }
	            }
	            else {
	                this._boxBounds.setEmpty();
	            }
	        }
	        return this._boxBounds;
	    };
	    Graphics.prototype.getSphereBounds = function (center, target) {
	        if (target === void 0) { target = null; }
	        var len = this._graphics.length;
	        for (var i = 0; i < len; i++) {
	            target = this._graphics[i].getSphereBounds(center, target);
	        }
	        return target;
	    };
	    Graphics.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._boxBoundsInvalid = true;
	        this._sphereBoundsInvalid = true;
	    };
	    Graphics.prototype._iInvalidateSurfaces = function () {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].invalidateSurface();
	    };
	    Graphics.prototype.invalidateElements = function () {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; ++i)
	            this._graphics[i].invalidateElements();
	    };
	    Graphics.prototype._hitTestPointInternal = function (x, y) {
	        //TODO: handle lines as well
	        var len = this._graphics.length;
	        for (var i = 0; i < len; i++)
	            if (this._graphics[i].hitTestPoint(x, y, 0))
	                return true;
	        return false;
	    };
	    Graphics.prototype.acceptTraverser = function (traverser) {
	        var len = this._graphics.length;
	        for (var i = 0; i < len; i++)
	            traverser.applyRenderable(this._graphics[i]);
	    };
	    Graphics.prototype._onInvalidateProperties = function (event) {
	        this._iInvalidateSurfaces();
	    };
	    Graphics.prototype._onInvalidateVertices = function (event) {
	        if (event.attributesView != event.target.positions)
	            return;
	        this.invalidate();
	    };
	    Graphics.prototype.draw_fills = function () {
	        GraphicsFactoryFills_1.GraphicsFactoryFills.draw_pathes(this);
	    };
	    Graphics.prototype.draw_strokes = function () {
	        var final_vert_list = [];
	        GraphicsFactoryStrokes_1.GraphicsFactoryStrokes.draw_pathes(this.queued_stroke_pathes, final_vert_list);
	        this.queued_stroke_pathes.length = 0;
	        var attributesView = new AttributesView_1.AttributesView(Float32Array, 3);
	        attributesView.set(final_vert_list);
	        var attributesBuffer = attributesView.attributesBuffer;
	        attributesView.dispose();
	        var elements = new TriangleElements_1.TriangleElements(attributesBuffer);
	        elements.setPositions(new Float2Attributes_1.Float2Attributes(attributesBuffer));
	        elements.setCustomAttributes("curves", new Byte4Attributes_1.Byte4Attributes(attributesBuffer, false));
	        //elements.setUVs(new Float2Attributes(attributesBuffer));
	        //curve_sub_geom.setUVs(new Float2Attributes(attributesBuffer));
	        var material = DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial();
	        material.bothSides = true;
	        material.useColorTransform = true;
	        material.curves = true;
	        var sampler = new Sampler2D_1.Sampler2D();
	        var graphic = this.addGraphic(elements, material);
	        if (graphic) {
	            graphic.style = new Style_1.Style();
	            graphic.style.addSamplerAt(sampler, graphic.material.getTextureAt(0));
	            //sampler.imageRect = new Rectangle(0, 0, 0.5, 0.5);
	            graphic.style.uvMatrix = new Matrix_1.Matrix(0, 0, 0, 0, 0.126, 0);
	            graphic.material.animateUVs = true;
	        }
	    };
	    /**
	     * Fills a drawing area with a bitmap image. The bitmap can be repeated or
	     * tiled to fill the area. The fill remains in effect until you call the
	     * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	     * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	     * method. Calling the <code>clear()</code> method clears the fill.
	     *
	     * <p>The application renders the fill whenever three or more points are
	     * drawn, or when the <code>endFill()</code> method is called. </p>
	     *
	     * @param bitmap A transparent or opaque bitmap image that contains the bits
	     *               to be displayed.
	     * @param matrix A matrix object(of the flash.geom.Matrix class), which you
	     *               can use to define transformations on the bitmap. For
	     *               example, you can use the following matrix to rotate a bitmap
	     *               by 45 degrees(pi/4 radians):
	     * @param repeat If <code>true</code>, the bitmap image repeats in a tiled
	     *               pattern. If <code>false</code>, the bitmap image does not
	     *               repeat, and the edges of the bitmap are used for any fill
	     *               area that extends beyond the bitmap.
	     *
	     *               <p>For example, consider the following bitmap(a 20 x
	     *               20-pixel checkerboard pattern):</p>
	     *
	     *               <p>When <code>repeat</code> is set to <code>true</code>(as
	     *               in the following example), the bitmap fill repeats the
	     *               bitmap:</p>
	     *
	     *               <p>When <code>repeat</code> is set to <code>false</code>,
	     *               the bitmap fill uses the edge pixels for the fill area
	     *               outside the bitmap:</p>
	     * @param smooth If <code>false</code>, upscaled bitmap images are rendered
	     *               by using a nearest-neighbor algorithm and look pixelated. If
	     *               <code>true</code>, upscaled bitmap images are rendered by
	     *               using a bilinear algorithm. Rendering by using the nearest
	     *               neighbor algorithm is faster.
	     */
	    Graphics.prototype.beginBitmapFill = function (bitmap, matrix, repeat, smooth) {
	        if (matrix === void 0) { matrix = null; }
	        if (repeat === void 0) { repeat = true; }
	        if (smooth === void 0) { smooth = false; }
	        this.draw_fills();
	        // start a new fill path
	        this._active_fill_path = new GraphicsPath_1.GraphicsPath();
	        // todo: create bitmap fill style
	        this._active_fill_path.style = new GraphicsFillStyle_1.GraphicsFillStyle(0xffffff, 1);
	        if (this._current_position.x != 0 || this._current_position.y != 0)
	            this._active_fill_path.moveTo(this._current_position.x, this._current_position.y);
	        this._queued_fill_pathes.push(this._active_fill_path);
	    };
	    /**
	     * Specifies a simple one-color fill that subsequent calls to other Graphics
	     * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) use
	     * when drawing. The fill remains in effect until you call the
	     * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	     * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	     * method. Calling the <code>clear()</code> method clears the fill.
	     *
	     * <p>The application renders the fill whenever three or more points are
	     * drawn, or when the <code>endFill()</code> method is called.</p>
	     *
	     * @param color The color of the fill(0xRRGGBB).
	     * @param alpha The alpha value of the fill(0.0 to 1.0).
	     */
	    Graphics.prototype.beginFill = function (color /*int*/, alpha) {
	        if (alpha === void 0) { alpha = 1; }
	        this.draw_fills();
	        // start a new fill path
	        this._active_fill_path = new GraphicsPath_1.GraphicsPath();
	        this._active_fill_path.style = new GraphicsFillStyle_1.GraphicsFillStyle(color, alpha);
	        if (this._current_position.x != 0 || this._current_position.y != 0)
	            this._active_fill_path.moveTo(this._current_position.x, this._current_position.y);
	        this._queued_fill_pathes.push(this._active_fill_path);
	    };
	    /**
	     * Specifies a gradient fill used by subsequent calls to other Graphics
	     * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) for
	     * the object. The fill remains in effect until you call the
	     * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
	     * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
	     * method. Calling the <code>clear()</code> method clears the fill.
	     *
	     * <p>The application renders the fill whenever three or more points are
	     * drawn, or when the <code>endFill()</code> method is called. </p>
	     *
	     * @param type                A value from the GradientType class that
	     *                            specifies which gradient type to use:
	     *                            <code>GradientType.LINEAR</code> or
	     *                            <code>GradientType.RADIAL</code>.
	     * @param colors              An array of RGB hexadecimal color values used
	     *                            in the gradient; for example, red is 0xFF0000,
	     *                            blue is 0x0000FF, and so on. You can specify
	     *                            up to 15 colors. For each color, specify a
	     *                            corresponding value in the alphas and ratios
	     *                            parameters.
	     * @param alphas              An array of alpha values for the corresponding
	     *                            colors in the colors array; valid values are 0
	     *                            to 1. If the value is less than 0, the default
	     *                            is 0. If the value is greater than 1, the
	     *                            default is 1.
	     * @param ratios              An array of color distribution ratios; valid
	     *                            values are 0-255. This value defines the
	     *                            percentage of the width where the color is
	     *                            sampled at 100%. The value 0 represents the
	     *                            left position in the gradient box, and 255
	     *                            represents the right position in the gradient
	     *                            box.
	     * @param matrix              A transformation matrix as defined by the
	     *                            flash.geom.Matrix class. The flash.geom.Matrix
	     *                            class includes a
	     *                            <code>createGradientBox()</code> method, which
	     *                            lets you conveniently set up the matrix for use
	     *                            with the <code>beginGradientFill()</code>
	     *                            method.
	     * @param spreadMethod        A value from the SpreadMethod class that
	     *                            specifies which spread method to use, either:
	     *                            <code>SpreadMethod.PAD</code>,
	     *                            <code>SpreadMethod.REFLECT</code>, or
	     *                            <code>SpreadMethod.REPEAT</code>.
	     *
	     *                            <p>For example, consider a simple linear
	     *                            gradient between two colors:</p>
	     *
	     *                            <p>This example uses
	     *                            <code>SpreadMethod.PAD</code> for the spread
	     *                            method, and the gradient fill looks like the
	     *                            following:</p>
	     *
	     *                            <p>If you use <code>SpreadMethod.REFLECT</code>
	     *                            for the spread method, the gradient fill looks
	     *                            like the following:</p>
	     *
	     *                            <p>If you use <code>SpreadMethod.REPEAT</code>
	     *                            for the spread method, the gradient fill looks
	     *                            like the following:</p>
	     * @param interpolationMethod A value from the InterpolationMethod class that
	     *                            specifies which value to use:
	     *                            <code>InterpolationMethod.LINEAR_RGB</code> or
	     *                            <code>InterpolationMethod.RGB</code>
	     *
	     *                            <p>For example, consider a simple linear
	     *                            gradient between two colors(with the
	     *                            <code>spreadMethod</code> parameter set to
	     *                            <code>SpreadMethod.REFLECT</code>). The
	     *                            different interpolation methods affect the
	     *                            appearance as follows: </p>
	     * @param focalPointRatio     A number that controls the location of the
	     *                            focal point of the gradient. 0 means that the
	     *                            focal point is in the center. 1 means that the
	     *                            focal point is at one border of the gradient
	     *                            circle. -1 means that the focal point is at the
	     *                            other border of the gradient circle. A value
	     *                            less than -1 or greater than 1 is rounded to -1
	     *                            or 1. For example, the following example shows
	     *                            a <code>focalPointRatio</code> set to 0.75:
	     * @throws ArgumentError If the <code>type</code> parameter is not valid.
	     */
	    Graphics.prototype.beginGradientFill = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
	        if (matrix === void 0) { matrix = null; }
	        if (spreadMethod === void 0) { spreadMethod = "pad"; }
	        if (interpolationMethod === void 0) { interpolationMethod = "rgb"; }
	        if (focalPointRatio === void 0) { focalPointRatio = 0; }
	        this.draw_fills();
	        // start a new fill path
	        this._active_fill_path = new GraphicsPath_1.GraphicsPath();
	        // todo: create gradient fill style
	        this._active_fill_path.style = new GraphicsFillStyle_1.GraphicsFillStyle(colors[0], alphas[0]);
	        if (this._current_position.x != 0 || this._current_position.y != 0)
	            this._active_fill_path.moveTo(this._current_position.x, this._current_position.y);
	        this._queued_fill_pathes.push(this._active_fill_path);
	    };
	    /**
	     * Copies all of drawing commands from the source Graphics object into the
	     * calling Graphics object.
	     *
	     * @param sourceGraphics The Graphics object from which to copy the drawing
	     *                       commands.
	     */
	    Graphics.prototype.copyFrom = function (sourceGraphics) {
	        sourceGraphics.copyTo(this);
	    };
	    /**
	     * Draws a cubic Bezier curve from the current drawing position to the
	     * specified anchor point. Cubic Bezier curves consist of two anchor points
	     * and two control points. The curve interpolates the two anchor points and
	     * curves toward the two control points.
	     *
	     * The four points you use to draw a cubic Bezier curve with the
	     * <code>cubicCurveTo()</code> method are as follows:
	     *
	     * <ul>
	     *   <li>The current drawing position is the first anchor point. </li>
	     *   <li>The anchorX and anchorY parameters specify the second anchor point.
	     *   </li>
	     *   <li>The <code>controlX1</code> and <code>controlY1</code> parameters
	     *   specify the first control point.</li>
	     *   <li>The <code>controlX2</code> and <code>controlY2</code> parameters
	     *   specify the second control point.</li>
	     * </ul>
	     *
	     * If you call the <code>cubicCurveTo()</code> method before calling the
	     * <code>moveTo()</code> method, your curve starts at position (0, 0).
	     *
	     * If the <code>cubicCurveTo()</code> method succeeds, the Flash runtime sets
	     * the current drawing position to (<code>anchorX</code>,
	     * <code>anchorY</code>). If the <code>cubicCurveTo()</code> method fails,
	     * the current drawing position remains unchanged.
	     *
	     * If your movie clip contains content created with the Flash drawing tools,
	     * the results of calls to the <code>cubicCurveTo()</code> method are drawn
	     * underneath that content.
	     *
	     * @param controlX1 Specifies the horizontal position of the first control
	     *                  point relative to the registration point of the parent
	     *                  display object.
	     * @param controlY1 Specifies the vertical position of the first control
	     *                  point relative to the registration point of the parent
	     *                  display object.
	     * @param controlX2 Specifies the horizontal position of the second control
	     *                  point relative to the registration point of the parent
	     *                  display object.
	     * @param controlY2 Specifies the vertical position of the second control
	     *                  point relative to the registration point of the parent
	     *                  display object.
	     * @param anchorX   Specifies the horizontal position of the anchor point
	     *                  relative to the registration point of the parent display
	     *                  object.
	     * @param anchorY   Specifies the vertical position of the anchor point
	     *                  relative to the registration point of the parent display
	     *                  object.
	     */
	    Graphics.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
	        throw new PartialImplementationError_1.PartialImplementationError("cubicCurveTo");
	        /*
	         t = 0.5; // given example value
	         x = (1 - t) * (1 - t) * p[0].x + 2 * (1 - t) * t * p[1].x + t * t * p[2].x;
	         y = (1 - t) * (1 - t) * p[0].y + 2 * (1 - t) * t * p[1].y + t * t * p[2].y;
	
	         this.queued_command_types.push(Graphics.CMD_BEZIER);
	         this.queued_command_data.push(controlX1);
	         this.queued_command_data.push(controlY1);
	         this.queued_command_data.push(controlX2);
	         this.queued_command_data.push(controlY2);
	         this.queued_command_data.push(anchorX);
	         this.queued_command_data.push(anchorY);
	
	         // todo: somehow convert cubic bezier curve into 2 quadric curves...
	
	         this.draw_direction+=0;
	         */
	    };
	    /**
	     * Draws a curve using the current line style from the current drawing
	     * position to(anchorX, anchorY) and using the control point that
	     * (<code>controlX</code>, <code>controlY</code>) specifies. The current
	     * drawing position is then set to(<code>anchorX</code>,
	     * <code>anchorY</code>). If the movie clip in which you are drawing contains
	     * content created with the Flash drawing tools, calls to the
	     * <code>curveTo()</code> method are drawn underneath this content. If you
	     * call the <code>curveTo()</code> method before any calls to the
	     * <code>moveTo()</code> method, the default of the current drawing position
	     * is(0, 0). If any of the parameters are missing, this method fails and the
	     * current drawing position is not changed.
	     *
	     * <p>The curve drawn is a quadratic Bezier curve. Quadratic Bezier curves
	     * consist of two anchor points and one control point. The curve interpolates
	     * the two anchor points and curves toward the control point. </p>
	     *
	     * @param controlX A number that specifies the horizontal position of the
	     *                 control point relative to the registration point of the
	     *                 parent display object.
	     * @param controlY A number that specifies the vertical position of the
	     *                 control point relative to the registration point of the
	     *                 parent display object.
	     * @param anchorX  A number that specifies the horizontal position of the
	     *                 next anchor point relative to the registration point of
	     *                 the parent display object.
	     * @param anchorY  A number that specifies the vertical position of the next
	     *                 anchor point relative to the registration point of the
	     *                 parent display object.
	     */
	    Graphics.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
	        if (this._active_fill_path != null) {
	            this._active_fill_path.curveTo(controlX, controlY, anchorX, anchorY);
	        }
	        if (this._active_stroke_path != null) {
	            this._active_stroke_path.curveTo(controlX, controlY, anchorX, anchorY);
	        }
	        this._current_position.x = anchorX;
	        this._current_position.y = anchorY;
	    };
	    /**
	     * Draws a circle. Set the line style, fill, or both before you call the
	     * <code>drawCircle()</code> method, by calling the <code>linestyle()</code>,
	     * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
	     * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	     * method.
	     *
	     * @param x      The <i>x</i> location of the center of the circle relative
	     *               to the registration point of the parent display object(in
	     *               pixels).
	     * @param y      The <i>y</i> location of the center of the circle relative
	     *               to the registration point of the parent display object(in
	     *               pixels).
	     * @param radius The radius of the circle(in pixels).
	     */
	    Graphics.prototype.drawCircle = function (x, y, radius) {
	        // todo: directly create triangles instead of draw commands ?
	        var radius2 = radius * 1.065;
	        if (this._active_fill_path != null) {
	            this._active_fill_path.moveTo(x - radius, y);
	            for (var i = 8; i >= 0; i--) {
	                var degree = (i) * (360 / 8) * Math.PI / 180;
	                var degree2 = degree + ((360 / 16) * Math.PI / 180);
	                this._active_fill_path.curveTo(x - (Math.cos(degree2) * radius2), y + (Math.sin(degree2) * radius2), x - (Math.cos(degree) * radius), y + (Math.sin(degree) * radius));
	            }
	        }
	        if (this._active_stroke_path != null) {
	            this._active_stroke_path.moveTo(x, y + radius);
	            var radius2 = radius * 0.93;
	            this._active_stroke_path.curveTo(x - (radius2), y + (radius2), x - radius, y);
	            this._active_stroke_path.curveTo(x - (radius2), y - (radius2), x, y - radius);
	            this._active_stroke_path.curveTo(x + (radius2), y - (radius2), x + radius, y);
	            this._active_stroke_path.curveTo(x + (radius2), y + (radius2), x, y + radius);
	        }
	    };
	    /**
	     * Draws an ellipse. Set the line style, fill, or both before you call the
	     * <code>drawEllipse()</code> method, by calling the
	     * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
	     * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	     * <code>beginBitmapFill()</code> method.
	     *
	     * @param x      The <i>x</i> location of the top-left of the bounding-box of
	     *               the ellipse relative to the registration point of the parent
	     *               display object(in pixels).
	     * @param y      The <i>y</i> location of the top left of the bounding-box of
	     *               the ellipse relative to the registration point of the parent
	     *               display object(in pixels).
	     * @param width  The width of the ellipse(in pixels).
	     * @param height The height of the ellipse(in pixels).
	     */
	    Graphics.prototype.drawEllipse = function (x, y, width, height) {
	        width /= 2;
	        height /= 2;
	        if (this._active_fill_path != null) {
	            this._active_fill_path.moveTo(x, y + height);
	            this._active_fill_path.curveTo(x - (width), y + (height), x - width, y);
	            this._active_fill_path.curveTo(x - (width), y - (height), x, y - height);
	            this._active_fill_path.curveTo(x + (width), y - (height), x + width, y);
	            this._active_fill_path.curveTo(x + (width), y + (height), x, y + height);
	        }
	        if (this._active_stroke_path != null) {
	            this._active_stroke_path.moveTo(x, y + height);
	            this._active_stroke_path.curveTo(x - (width), y + (height), x - width, y);
	            this._active_stroke_path.curveTo(x - (width), y - (height), x, y - height);
	            this._active_stroke_path.curveTo(x + (width), y - (height), x + width, y);
	            this._active_stroke_path.curveTo(x + (width), y + (height), x, y + height);
	        }
	    };
	    /**
	     * Submits a series of IGraphicsData instances for drawing. This method
	     * accepts a Vector containing objects including paths, fills, and strokes
	     * that implement the IGraphicsData interface. A Vector of IGraphicsData
	     * instances can refer to a part of a shape, or a complex fully defined set
	     * of data for rendering a complete shape.
	     *
	     * <p> Graphics paths can contain other graphics paths. If the
	     * <code>graphicsData</code> Vector includes a path, that path and all its
	     * sub-paths are rendered during this operation. </p>
	     *
	     */
	    Graphics.prototype.drawGraphicsData = function (graphicsData) {
	        //this.draw_fills();
	        /*
	         for (var i:number=0; i<graphicsData.length; i++){
	         //todo
	         if(graphicsData[i].dataType=="beginFill"){
	
	         }
	         else if(graphicsData[i].dataType=="endFill"){
	
	         }
	         else if(graphicsData[i].dataType=="endFill"){
	
	         }
	         else if(graphicsData[i].dataType=="Path"){
	
	         }
	
	         }
	         */
	    };
	    /**
	     * Submits a series of commands for drawing. The <code>drawPath()</code>
	     * method uses vector arrays to consolidate individual <code>moveTo()</code>,
	     * <code>lineTo()</code>, and <code>curveTo()</code> drawing commands into a
	     * single call. The <code>drawPath()</code> method parameters combine drawing
	     * commands with x- and y-coordinate value pairs and a drawing direction. The
	     * drawing commands are values from the GraphicsPathCommand class. The x- and
	     * y-coordinate value pairs are Numbers in an array where each pair defines a
	     * coordinate location. The drawing direction is a value from the
	     * GraphicsPathWinding class.
	     *
	     * <p> Generally, drawings render faster with <code>drawPath()</code> than
	     * with a series of individual <code>lineTo()</code> and
	     * <code>curveTo()</code> methods. </p>
	     *
	     * <p> The <code>drawPath()</code> method uses a uses a floating computation
	     * so rotation and scaling of shapes is more accurate and gives better
	     * results. However, curves submitted using the <code>drawPath()</code>
	     * method can have small sub-pixel alignment errors when used in conjunction
	     * with the <code>lineTo()</code> and <code>curveTo()</code> methods. </p>
	     *
	     * <p> The <code>drawPath()</code> method also uses slightly different rules
	     * for filling and drawing lines. They are: </p>
	     *
	     * <ul>
	     *   <li>When a fill is applied to rendering a path:
	     * <ul>
	     *   <li>A sub-path of less than 3 points is not rendered.(But note that the
	     * stroke rendering will still occur, consistent with the rules for strokes
	     * below.)</li>
	     *   <li>A sub-path that isn't closed(the end point is not equal to the
	     * begin point) is implicitly closed.</li>
	     * </ul>
	     * </li>
	     *   <li>When a stroke is applied to rendering a path:
	     * <ul>
	     *   <li>The sub-paths can be composed of any number of points.</li>
	     *   <li>The sub-path is never implicitly closed.</li>
	     * </ul>
	     * </li>
	     * </ul>
	     *
	     * @param winding Specifies the winding rule using a value defined in the
	     *                GraphicsPathWinding class.
	     */
	    Graphics.prototype.drawPath = function (commands, data, winding) {
	        //todo
	        /*
	         if(this._active_fill_path!=null){
	         this._active_fill_path.curveTo(controlX, controlY, anchorX, anchorY);
	         }
	         if(this._active_stroke_path!=null){
	         this._active_stroke_path.curveTo(controlX, controlY, anchorX, anchorY);
	         }
	         this._current_position.x=anchorX;
	         this._current_position.y=anchorY;
	         */
	    };
	    /**
	     * Draws a rectangle. Set the line style, fill, or both before you call the
	     * <code>drawRect()</code> method, by calling the <code>linestyle()</code>,
	     * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
	     * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	     * method.
	     *
	     * @param x      A number indicating the horizontal position relative to the
	     *               registration point of the parent display object(in pixels).
	     * @param y      A number indicating the vertical position relative to the
	     *               registration point of the parent display object(in pixels).
	     * @param width  The width of the rectangle(in pixels).
	     * @param height The height of the rectangle(in pixels).
	     * @throws ArgumentError If the <code>width</code> or <code>height</code>
	     *                       parameters are not a number
	     *                      (<code>Number.NaN</code>).
	     */
	    Graphics.prototype.drawRect = function (x, y, width, height) {
	        //todo: directly create triangles instead of drawing commands ?
	        if (this._active_fill_path != null) {
	            this._active_fill_path.moveTo(x, y);
	            this._active_fill_path.lineTo(x + width, y);
	            this._active_fill_path.lineTo(x + width, y + height);
	            this._active_fill_path.lineTo(x, y + height);
	            this._active_fill_path.lineTo(x, y);
	        }
	        if (this._active_stroke_path != null) {
	            this._active_stroke_path.moveTo(x, y);
	            this._active_stroke_path.lineTo(x + width, y);
	            this._active_stroke_path.lineTo(x + width, y + height);
	            this._active_stroke_path.lineTo(x, y + height);
	            this._active_stroke_path.lineTo(x, y);
	        }
	    };
	    /**
	     * Draws a rounded rectangle. Set the line style, fill, or both before you
	     * call the <code>drawRoundRect()</code> method, by calling the
	     * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
	     * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	     * <code>beginBitmapFill()</code> method.
	     *
	     * @param x             A number indicating the horizontal position relative
	     *                      to the registration point of the parent display
	     *                      object(in pixels).
	     * @param y             A number indicating the vertical position relative to
	     *                      the registration point of the parent display object
	     *                     (in pixels).
	     * @param width         The width of the round rectangle(in pixels).
	     * @param height        The height of the round rectangle(in pixels).
	     * @param ellipseWidth  The width of the ellipse used to draw the rounded
	     *                      corners(in pixels).
	     * @param ellipseHeight The height of the ellipse used to draw the rounded
	     *                      corners(in pixels). Optional; if no value is
	     *                      specified, the default value matches that provided
	     *                      for the <code>ellipseWidth</code> parameter.
	     * @throws ArgumentError If the <code>width</code>, <code>height</code>,
	     *                       <code>ellipseWidth</code> or
	     *                       <code>ellipseHeight</code> parameters are not a
	     *                       number(<code>Number.NaN</code>).
	     */
	    Graphics.prototype.drawRoundRect = function (x, y, width, height, ellipseWidth, ellipseHeight) {
	        if (ellipseHeight === void 0) { ellipseHeight = NaN; }
	        //todo: directly create triangles instead of drawing commands ?
	        if (!ellipseHeight) {
	            ellipseHeight = ellipseWidth;
	        }
	        if (this._active_fill_path != null) {
	            this._active_fill_path.moveTo(x + ellipseWidth, y);
	            this._active_fill_path.lineTo(x + width - ellipseWidth, y);
	            this._active_fill_path.curveTo(x + width, y, x + width, y + ellipseHeight);
	            this._active_fill_path.lineTo(x + width, y + height - ellipseHeight);
	            this._active_fill_path.curveTo(x + width, y + height, x + width - ellipseWidth, y + height);
	            this._active_fill_path.lineTo(x + ellipseWidth, y + height);
	            this._active_fill_path.curveTo(x, y + height, x, y + height - ellipseHeight);
	            this._active_fill_path.lineTo(x, y + ellipseHeight);
	            this._active_fill_path.curveTo(x, y, x + ellipseWidth, y);
	        }
	        if (this._active_stroke_path != null) {
	            this._active_stroke_path.moveTo(x + ellipseWidth, y);
	            this._active_stroke_path.lineTo(x + width - ellipseWidth, y);
	            this._active_stroke_path.curveTo(x + width, y, x + width, y + ellipseHeight);
	            this._active_stroke_path.lineTo(x + width, y + height - ellipseHeight);
	            this._active_stroke_path.curveTo(x + width, y + height, x + width - ellipseWidth, y + height);
	            this._active_stroke_path.lineTo(x + ellipseWidth, y + height);
	            this._active_stroke_path.curveTo(x, y + height, x, y + height - ellipseHeight);
	            this._active_stroke_path.lineTo(x, y + ellipseHeight);
	            this._active_stroke_path.curveTo(x, y, x + ellipseWidth, y);
	        }
	    };
	    //public drawRoundRectComplex(x:Float, y:Float, width:Float, height:Float, topLeftRadius:Float, topRightRadius:Float, bottomLeftRadius:Float, bottomRightRadius:Float):Void;
	    /**
	     * Renders a set of triangles, typically to distort bitmaps and give them a
	     * three-dimensional appearance. The <code>drawTriangles()</code> method maps
	     * either the current fill, or a bitmap fill, to the triangle faces using a
	     * set of(u,v) coordinates.
	     *
	     * <p> Any type of fill can be used, but if the fill has a transform matrix
	     * that transform matrix is ignored. </p>
	     *
	     * <p> A <code>uvtData</code> parameter improves texture mapping when a
	     * bitmap fill is used. </p>
	     *
	     * @param culling Specifies whether to render triangles that face in a
	     *                specified direction. This parameter prevents the rendering
	     *                of triangles that cannot be seen in the current view. This
	     *                parameter can be set to any value defined by the
	     *                TriangleCulling class.
	     */
	    Graphics.prototype.drawTriangles = function (vertices, indices, uvtData, culling) {
	        if (indices === void 0) { indices = null; }
	        if (uvtData === void 0) { uvtData = null; }
	        if (culling === void 0) { culling = null; }
	        if (this._active_fill_path != null) {
	        }
	        if (this._active_stroke_path != null) {
	        }
	    };
	    /**
	     * Applies a fill to the lines and curves that were added since the last call
	     * to the <code>beginFill()</code>, <code>beginGradientFill()</code>, or
	     * <code>beginBitmapFill()</code> method. Flash uses the fill that was
	     * specified in the previous call to the <code>beginFill()</code>,
	     * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
	     * method. If the current drawing position does not equal the previous
	     * position specified in a <code>moveTo()</code> method and a fill is
	     * defined, the path is closed with a line and then filled.
	     *
	     */
	    Graphics.prototype.endFill = function () {
	        this.draw_strokes();
	        this.draw_fills();
	        this._active_fill_path = null;
	        this._active_stroke_path = null;
	    };
	    /**
	     * Specifies a bitmap to use for the line stroke when drawing lines.
	     *
	     * <p>The bitmap line style is used for subsequent calls to Graphics methods
	     * such as the <code>lineTo()</code> method or the <code>drawCircle()</code>
	     * method. The line style remains in effect until you call the
	     * <code>lineStyle()</code> or <code>lineGradientStyle()</code> methods, or
	     * the <code>lineBitmapStyle()</code> method again with different parameters.
	     * </p>
	     *
	     * <p>You can call the <code>lineBitmapStyle()</code> method in the middle of
	     * drawing a path to specify different styles for different line segments
	     * within a path. </p>
	     *
	     * <p>Call the <code>lineStyle()</code> method before you call the
	     * <code>lineBitmapStyle()</code> method to enable a stroke, or else the
	     * value of the line style is <code>undefined</code>.</p>
	     *
	     * <p>Calls to the <code>clear()</code> method set the line style back to
	     * <code>undefined</code>. </p>
	     *
	     * @param bitmap The bitmap to use for the line stroke.
	     * @param matrix An optional transformation matrix as defined by the
	     *               flash.geom.Matrix class. The matrix can be used to scale or
	     *               otherwise manipulate the bitmap before applying it to the
	     *               line style.
	     * @param repeat Whether to repeat the bitmap in a tiled fashion.
	     * @param smooth Whether smoothing should be applied to the bitmap.
	     */
	    Graphics.prototype.lineBitmapStyle = function (bitmap, matrix, repeat, smooth) {
	        if (matrix === void 0) { matrix = null; }
	        if (repeat === void 0) { repeat = true; }
	        if (smooth === void 0) { smooth = false; }
	        // start a new stroke path
	        this._active_stroke_path = new GraphicsPath_1.GraphicsPath();
	        if (this._current_position.x != 0 || this._current_position.y != 0)
	            this._active_stroke_path.moveTo(this._current_position.x, this._current_position.y);
	        this._queued_stroke_pathes.push(this._active_stroke_path);
	    };
	    /**
	     * Specifies a gradient to use for the stroke when drawing lines.
	     *
	     * <p>The gradient line style is used for subsequent calls to Graphics
	     * methods such as the <code>lineTo()</code> methods or the
	     * <code>drawCircle()</code> method. The line style remains in effect until
	     * you call the <code>lineStyle()</code> or <code>lineBitmapStyle()</code>
	     * methods, or the <code>lineGradientStyle()</code> method again with
	     * different parameters. </p>
	     *
	     * <p>You can call the <code>lineGradientStyle()</code> method in the middle
	     * of drawing a path to specify different styles for different line segments
	     * within a path. </p>
	     *
	     * <p>Call the <code>lineStyle()</code> method before you call the
	     * <code>lineGradientStyle()</code> method to enable a stroke, or else the
	     * value of the line style is <code>undefined</code>.</p>
	     *
	     * <p>Calls to the <code>clear()</code> method set the line style back to
	     * <code>undefined</code>. </p>
	     *
	     * @param type                A value from the GradientType class that
	     *                            specifies which gradient type to use, either
	     *                            GradientType.LINEAR or GradientType.RADIAL.
	     * @param colors              An array of RGB hexadecimal color values used
	     *                            in the gradient; for example, red is 0xFF0000,
	     *                            blue is 0x0000FF, and so on. You can specify
	     *                            up to 15 colors. For each color, specify a
	     *                            corresponding value in the alphas and ratios
	     *                            parameters.
	     * @param alphas              An array of alpha values for the corresponding
	     *                            colors in the colors array; valid values are 0
	     *                            to 1. If the value is less than 0, the default
	     *                            is 0. If the value is greater than 1, the
	     *                            default is 1.
	     * @param ratios              An array of color distribution ratios; valid
	     *                            values are 0-255. This value defines the
	     *                            percentage of the width where the color is
	     *                            sampled at 100%. The value 0 represents the
	     *                            left position in the gradient box, and 255
	     *                            represents the right position in the gradient
	     *                            box.
	     * @param matrix              A transformation matrix as defined by the
	     *                            flash.geom.Matrix class. The flash.geom.Matrix
	     *                            class includes a
	     *                            <code>createGradientBox()</code> method, which
	     *                            lets you conveniently set up the matrix for use
	     *                            with the <code>lineGradientStyle()</code>
	     *                            method.
	     * @param spreadMethod        A value from the SpreadMethod class that
	     *                            specifies which spread method to use:
	     * @param interpolationMethod A value from the InterpolationMethod class that
	     *                            specifies which value to use. For example,
	     *                            consider a simple linear gradient between two
	     *                            colors(with the <code>spreadMethod</code>
	     *                            parameter set to
	     *                            <code>SpreadMethod.REFLECT</code>). The
	     *                            different interpolation methods affect the
	     *                            appearance as follows:
	     * @param focalPointRatio     A number that controls the location of the
	     *                            focal point of the gradient. The value 0 means
	     *                            the focal point is in the center. The value 1
	     *                            means the focal point is at one border of the
	     *                            gradient circle. The value -1 means that the
	     *                            focal point is at the other border of the
	     *                            gradient circle. Values less than -1 or greater
	     *                            than 1 are rounded to -1 or 1. The following
	     *                            image shows a gradient with a
	     *                            <code>focalPointRatio</code> of -0.75:
	     */
	    Graphics.prototype.lineGradientStyle = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
	        if (matrix === void 0) { matrix = null; }
	        if (spreadMethod === void 0) { spreadMethod = null; }
	        if (interpolationMethod === void 0) { interpolationMethod = null; }
	        if (focalPointRatio === void 0) { focalPointRatio = 0; }
	        // start a new stroke path
	        this._active_stroke_path = new GraphicsPath_1.GraphicsPath();
	        if (this._current_position.x != 0 || this._current_position.y != 0)
	            this._active_stroke_path.moveTo(this._current_position.x, this._current_position.y);
	        this._queued_stroke_pathes.push(this._active_stroke_path);
	    };
	    /**
	     * Specifies a shader to use for the line stroke when drawing lines.
	     *
	     * <p>The shader line style is used for subsequent calls to Graphics methods
	     * such as the <code>lineTo()</code> method or the <code>drawCircle()</code>
	     * method. The line style remains in effect until you call the
	     * <code>lineStyle()</code> or <code>lineGradientStyle()</code> methods, or
	     * the <code>lineBitmapStyle()</code> method again with different parameters.
	     * </p>
	     *
	     * <p>You can call the <code>lineShaderStyle()</code> method in the middle of
	     * drawing a path to specify different styles for different line segments
	     * within a path. </p>
	     *
	     * <p>Call the <code>lineStyle()</code> method before you call the
	     * <code>lineShaderStyle()</code> method to enable a stroke, or else the
	     * value of the line style is <code>undefined</code>.</p>
	     *
	     * <p>Calls to the <code>clear()</code> method set the line style back to
	     * <code>undefined</code>. </p>
	     *
	     * @param shader The shader to use for the line stroke.
	     * @param matrix An optional transformation matrix as defined by the
	     *               flash.geom.Matrix class. The matrix can be used to scale or
	     *               otherwise manipulate the bitmap before applying it to the
	     *               line style.
	     */
	    //		public lineShaderStyle(shader:Shader, matrix:Matrix = null)
	    //		{
	    //
	    //		}
	    /**
	     * Specifies a line style used for subsequent calls to Graphics methods such
	     * as the <code>lineTo()</code> method or the <code>drawCircle()</code>
	     * method. The line style remains in effect until you call the
	     * <code>lineGradientStyle()</code> method, the
	     * <code>lineBitmapStyle()</code> method, or the <code>lineStyle()</code>
	     * method with different parameters.
	     *
	     * <p>You can call the <code>lineStyle()</code> method in the middle of
	     * drawing a path to specify different styles for different line segments
	     * within the path.</p>
	     *
	     * <p><b>Note: </b>Calls to the <code>clear()</code> method set the line
	     * style back to <code>undefined</code>.</p>
	     *
	     * <p><b>Note: </b>Flash Lite 4 supports only the first three parameters
	     * (<code>thickness</code>, <code>color</code>, and <code>alpha</code>).</p>
	     *
	     * @param thickness    An integer that indicates the thickness of the line in
	     *                     points; valid values are 0-255. If a number is not
	     *                     specified, or if the parameter is undefined, a line is
	     *                     not drawn. If a value of less than 0 is passed, the
	     *                     default is 0. The value 0 indicates hairline
	     *                     thickness; the maximum thickness is 255. If a value
	     *                     greater than 255 is passed, the default is 255.
	     * @param color        A hexadecimal color value of the line; for example,
	     *                     red is 0xFF0000, blue is 0x0000FF, and so on. If a
	     *                     value is not indicated, the default is 0x000000
	     *                    (black). Optional.
	     * @param alpha        A number that indicates the alpha value of the color
	     *                     of the line; valid values are 0 to 1. If a value is
	     *                     not indicated, the default is 1(solid). If the value
	     *                     is less than 0, the default is 0. If the value is
	     *                     greater than 1, the default is 1.
	     * @param pixelHinting(Not supported in Flash Lite 4) A Boolean value that
	     *                     specifies whether to hint strokes to full pixels. This
	     *                     affects both the position of anchors of a curve and
	     *                     the line stroke size itself. With
	     *                     <code>pixelHinting</code> set to <code>true</code>,
	     *                     line widths are adjusted to full pixel widths. With
	     *                     <code>pixelHinting</code> set to <code>false</code>,
	     *                     disjoints can appear for curves and straight lines.
	     *                     For example, the following illustrations show how
	     *                     Flash Player or Adobe AIR renders two rounded
	     *                     rectangles that are identical, except that the
	     *                     <code>pixelHinting</code> parameter used in the
	     *                     <code>lineStyle()</code> method is set differently
	     *                    (the images are scaled by 200%, to emphasize the
	     *                     difference):
	     *
	     *                     <p>If a value is not supplied, the line does not use
	     *                     pixel hinting.</p>
	     * @param scaleMode   (Not supported in Flash Lite 4) A value from the
	     *                     LineScaleMode class that specifies which scale mode to
	     *                     use:
	     *                     <ul>
	     *                       <li> <code>LineScaleMode.NORMAL</code> - Always
	     *                     scale the line thickness when the object is scaled
	     *                    (the default). </li>
	     *                       <li> <code>LineScaleMode.NONE</code> - Never scale
	     *                     the line thickness. </li>
	     *                       <li> <code>LineScaleMode.VERTICAL</code> - Do not
	     *                     scale the line thickness if the object is scaled
	     *                     vertically <i>only</i>. For example, consider the
	     *                     following circles, drawn with a one-pixel line, and
	     *                     each with the <code>scaleMode</code> parameter set to
	     *                     <code>LineScaleMode.VERTICAL</code>. The circle on the
	     *                     left is scaled vertically only, and the circle on the
	     *                     right is scaled both vertically and horizontally:
	     *                     </li>
	     *                       <li> <code>LineScaleMode.HORIZONTAL</code> - Do not
	     *                     scale the line thickness if the object is scaled
	     *                     horizontally <i>only</i>. For example, consider the
	     *                     following circles, drawn with a one-pixel line, and
	     *                     each with the <code>scaleMode</code> parameter set to
	     *                     <code>LineScaleMode.HORIZONTAL</code>. The circle on
	     *                     the left is scaled horizontally only, and the circle
	     *                     on the right is scaled both vertically and
	     *                     horizontally:   </li>
	     *                     </ul>
	     * @param caps        (Not supported in Flash Lite 4) A value from the
	     *                     CapsStyle class that specifies the type of caps at the
	     *                     end of lines. Valid values are:
	     *                     <code>CapsStyle.NONE</code>,
	     *                     <code>CapsStyle.ROUND</code>, and
	     *                     <code>CapsStyle.SQUARE</code>. If a value is not
	     *                     indicated, Flash uses round caps.
	     *
	     *                     <p>For example, the following illustrations show the
	     *                     different <code>capsStyle</code> settings. For each
	     *                     setting, the illustration shows a blue line with a
	     *                     thickness of 30(for which the <code>capsStyle</code>
	     *                     applies), and a superimposed black line with a
	     *                     thickness of 1(for which no <code>capsStyle</code>
	     *                     applies): </p>
	     * @param joints      (Not supported in Flash Lite 4) A value from the
	     *                     JointStyle class that specifies the type of joint
	     *                     appearance used at angles. Valid values are:
	     *                     <code>JointStyle.BEVEL</code>,
	     *                     <code>JointStyle.MITER</code>, and
	     *                     <code>JointStyle.ROUND</code>. If a value is not
	     *                     indicated, Flash uses round joints.
	     *
	     *                     <p>For example, the following illustrations show the
	     *                     different <code>joints</code> settings. For each
	     *                     setting, the illustration shows an angled blue line
	     *                     with a thickness of 30(for which the
	     *                     <code>jointStyle</code> applies), and a superimposed
	     *                     angled black line with a thickness of 1(for which no
	     *                     <code>jointStyle</code> applies): </p>
	     *
	     *                     <p><b>Note:</b> For <code>joints</code> set to
	     *                     <code>JointStyle.MITER</code>, you can use the
	     *                     <code>miterLimit</code> parameter to limit the length
	     *                     of the miter.</p>
	     * @param miterLimit  (Not supported in Flash Lite 4) A number that
	     *                     indicates the limit at which a miter is cut off. Valid
	     *                     values range from 1 to 255(and values outside that
	     *                     range are rounded to 1 or 255). This value is only
	     *                     used if the <code>jointStyle</code> is set to
	     *                     <code>"miter"</code>. The <code>miterLimit</code>
	     *                     value represents the length that a miter can extend
	     *                     beyond the point at which the lines meet to form a
	     *                     joint. The value expresses a factor of the line
	     *                     <code>thickness</code>. For example, with a
	     *                     <code>miterLimit</code> factor of 2.5 and a
	     *                     <code>thickness</code> of 10 pixels, the miter is cut
	     *                     off at 25 pixels.
	     *
	     *                     <p>For example, consider the following angled lines,
	     *                     each drawn with a <code>thickness</code> of 20, but
	     *                     with <code>miterLimit</code> set to 1, 2, and 4.
	     *                     Superimposed are black reference lines showing the
	     *                     meeting points of the joints:</p>
	     *
	     *                     <p>Notice that a given <code>miterLimit</code> value
	     *                     has a specific maximum angle for which the miter is
	     *                     cut off. The following table lists some examples:</p>
	     */
	    Graphics.prototype.lineStyle = function (thickness, color, alpha, pixelHinting, scaleMode, capstyle, jointstyle, miterLimit) {
	        if (thickness === void 0) { thickness = 0; }
	        if (color === void 0) { color = 0; }
	        if (alpha === void 0) { alpha = 1; }
	        if (pixelHinting === void 0) { pixelHinting = false; }
	        if (scaleMode === void 0) { scaleMode = null; }
	        if (capstyle === void 0) { capstyle = CapsStyle_1.CapsStyle.NONE; }
	        if (jointstyle === void 0) { jointstyle = JointStyle_1.JointStyle.MITER; }
	        if (miterLimit === void 0) { miterLimit = 100; }
	        // start a new stroke path
	        this._active_stroke_path = new GraphicsPath_1.GraphicsPath();
	        this._active_stroke_path.style = new GraphicsStrokeStyle_1.GraphicsStrokeStyle(color, alpha, thickness, jointstyle, capstyle, miterLimit);
	        if (this._current_position.x != 0 || this._current_position.y != 0)
	            this._active_stroke_path.moveTo(this._current_position.x, this._current_position.y);
	        this._queued_stroke_pathes.push(this._active_stroke_path);
	    };
	    /**
	     * Draws a line using the current line style from the current drawing
	     * position to(<code>x</code>, <code>y</code>); the current drawing position
	     * is then set to(<code>x</code>, <code>y</code>). If the display object in
	     * which you are drawing contains content that was created with the Flash
	     * drawing tools, calls to the <code>lineTo()</code> method are drawn
	     * underneath the content. If you call <code>lineTo()</code> before any calls
	     * to the <code>moveTo()</code> method, the default position for the current
	     * drawing is(<i>0, 0</i>). If any of the parameters are missing, this
	     * method fails and the current drawing position is not changed.
	     *
	     * @param x A number that indicates the horizontal position relative to the
	     *          registration point of the parent display object(in pixels).
	     * @param y A number that indicates the vertical position relative to the
	     *          registration point of the parent display object(in pixels).
	     */
	    Graphics.prototype.lineTo = function (x, y) {
	        if (this._active_fill_path != null) {
	            this._active_fill_path.lineTo(x, y);
	        }
	        if (this._active_stroke_path != null) {
	            this._active_stroke_path.lineTo(x, y);
	        }
	        this._current_position.x = x;
	        this._current_position.y = y;
	    };
	    /**
	     * Moves the current drawing position to(<code>x</code>, <code>y</code>). If
	     * any of the parameters are missing, this method fails and the current
	     * drawing position is not changed.
	     *
	     * @param x A number that indicates the horizontal position relative to the
	     *          registration point of the parent display object(in pixels).
	     * @param y A number that indicates the vertical position relative to the
	     *          registration point of the parent display object(in pixels).
	     */
	    Graphics.prototype.moveTo = function (x, y) {
	        if (this._active_fill_path != null) {
	            this._active_fill_path.moveTo(x, y);
	        }
	        if (this._active_stroke_path != null) {
	            this._active_stroke_path.moveTo(x, y);
	        }
	        this._current_position.x = x;
	        this._current_position.y = y;
	    };
	    Graphics.assetType = "[asset Graphics]";
	    return Graphics;
	}(AssetBase_1.AssetBase));
	exports.Graphics = Graphics;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Float3Attributes_1 = __webpack_require__(15);
	var Float2Attributes_1 = __webpack_require__(14);
	var ElementsBase_1 = __webpack_require__(126);
	var ElementsUtils_1 = __webpack_require__(128);
	/**
	 * @class away.base.TriangleElements
	 */
	var TriangleElements = (function (_super) {
	    __extends(TriangleElements, _super);
	    function TriangleElements() {
	        _super.apply(this, arguments);
	        this._faceNormalsDirty = true;
	        this._faceTangentsDirty = true;
	        this._autoDeriveNormals = true;
	        this._autoDeriveTangents = true;
	        //used for hittesting geometry
	        this.hitTestCache = new Object();
	    }
	    Object.defineProperty(TriangleElements.prototype, "assetType", {
	        get: function () {
	            return TriangleElements.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "useCondensedIndices", {
	        /**
	         * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
	         * by condensing the number of joint index values required per sprite. Only applicable to
	         * skeleton animations that utilise more than one sprite object. Defaults to false.
	         */
	        get: function () {
	            return this._useCondensedIndices;
	        },
	        set: function (value) {
	            if (this._useCondensedIndices == value)
	                return;
	            this._useCondensedIndices = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "jointsPerVertex", {
	        /**
	         *
	         */
	        get: function () {
	            return this._jointsPerVertex;
	        },
	        set: function (value) {
	            if (this._jointsPerVertex == value)
	                return;
	            this._jointsPerVertex = value;
	            if (this._jointIndices)
	                this._jointIndices.dimensions = this._jointsPerVertex;
	            if (this._jointWeights)
	                this._jointWeights.dimensions = this._jointsPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "autoDeriveNormals", {
	        /**
	         * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
	         * explicitly.
	         */
	        get: function () {
	            return this._autoDeriveNormals;
	        },
	        set: function (value) {
	            if (this._autoDeriveNormals == value)
	                return;
	            this._autoDeriveNormals = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "autoDeriveTangents", {
	        /**
	         * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
	         * explicitly.
	         */
	        get: function () {
	            return this._autoDeriveTangents;
	        },
	        set: function (value) {
	            if (this._autoDeriveTangents == value)
	                return;
	            this._autoDeriveTangents = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "positions", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._positions)
	                this.setPositions(new Float3Attributes_1.Float3Attributes(this._concatenatedBuffer));
	            return this._positions;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "normals", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._normals || this._verticesDirty[this._normals.id])
	                this.setNormals(this._normals);
	            return this._normals;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "tangents", {
	        /**
	         *
	         */
	        get: function () {
	            if (!this._tangents || this._verticesDirty[this._tangents.id])
	                this.setTangents(this._tangents);
	            return this._tangents;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "faceNormals", {
	        /**
	         * The raw data of the face normals, in the same order as the faces are listed in the index list.
	         */
	        get: function () {
	            if (this._faceNormalsDirty)
	                this.updateFaceNormals();
	            return this._faceNormals;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "faceTangents", {
	        /**
	         * The raw data of the face tangets, in the same order as the faces are listed in the index list.
	         */
	        get: function () {
	            if (this._faceTangentsDirty)
	                this.updateFaceTangents();
	            return this._faceTangents;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "uvs", {
	        /**
	         *
	         */
	        get: function () {
	            return this._uvs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "jointIndices", {
	        /**
	         *
	         */
	        get: function () {
	            return this._jointIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "jointWeights", {
	        /**
	         *
	         */
	        get: function () {
	            return this._jointWeights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TriangleElements.prototype, "condensedIndexLookUp", {
	        get: function () {
	            return this._condensedIndexLookUp;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TriangleElements.prototype.getBoxBounds = function (target, count, offset, idx_count, idx_offset) {
	        if (target === void 0) { target = null; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        if (this.indices) {
	            return ElementsUtils_1.ElementsUtils.getTriangleGraphicsBoxBoundsIndices(this.positions, this.indices, target, idx_count / 3 || this.numElements, idx_offset / 3);
	        }
	        return ElementsUtils_1.ElementsUtils.getTriangleGraphicsBoxBounds(this.positions, target, count || this._numVertices, offset);
	    };
	    TriangleElements.prototype.getSphereBounds = function (center, target, count, offset) {
	        if (target === void 0) { target = null; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        return ElementsUtils_1.ElementsUtils.getTriangleGraphicsSphereBounds(this.positions, center, target, count || this._numVertices, offset);
	    };
	    TriangleElements.prototype.hitTestPoint = function (x, y, z, box, count, offset, idx_count, idx_offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        if (this.indices) {
	            return ElementsUtils_1.ElementsUtils.hitTestTriangleElementsIndices(x, y, 0, box, this, idx_count / 3 || this.numElements, idx_offset / 3);
	        }
	        return ElementsUtils_1.ElementsUtils.hitTestTriangleElements(x, y, 0, box, this, count || this._numVertices, offset);
	    };
	    TriangleElements.prototype.setPositions = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._positions)
	            return;
	        if (values instanceof AttributesView_1.AttributesView) {
	            this.clearVertices(this._positions);
	            this._positions = values;
	        }
	        else if (values) {
	            if (!this._positions)
	                this._positions = new Float3Attributes_1.Float3Attributes(this._concatenatedBuffer);
	            this._positions.set(values, offset);
	        }
	        else {
	            this.clearVertices(this._positions);
	            this._positions = new Float3Attributes_1.Float3Attributes(this._concatenatedBuffer); //positions cannot be null
	        }
	        this._numVertices = this._positions.count;
	        if (this._autoDeriveNormals)
	            this.invalidateVertices(this._normals);
	        if (this._autoDeriveTangents)
	            this.invalidateVertices(this._tangents);
	        this.invalidateVertices(this._positions);
	        this._verticesDirty[this._positions.id] = false;
	    };
	    TriangleElements.prototype.setNormals = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (!this._autoDeriveNormals) {
	            if (values == this._normals)
	                return;
	            if (values instanceof Float3Attributes_1.Float3Attributes) {
	                this.clearVertices(this._normals);
	                this._normals = values;
	            }
	            else if (values) {
	                if (!this._normals)
	                    this._normals = new Float3Attributes_1.Float3Attributes(this._concatenatedBuffer);
	                this._normals.set(values, offset);
	            }
	            else if (this._normals) {
	                this.clearVertices(this._normals);
	                this._normals = null;
	                return;
	            }
	        }
	        else {
	            this._normals = ElementsUtils_1.ElementsUtils.generateNormals(this.indices, this.faceNormals, this._normals, this._concatenatedBuffer);
	        }
	        this.invalidateVertices(this._normals);
	        this._verticesDirty[this._normals.id] = false;
	    };
	    TriangleElements.prototype.setTangents = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (!this._autoDeriveTangents) {
	            if (values == this._tangents)
	                return;
	            if (values instanceof Float3Attributes_1.Float3Attributes) {
	                this.clearVertices(this._tangents);
	                this._tangents = values;
	            }
	            else if (values) {
	                if (!this._tangents)
	                    this._tangents = new Float3Attributes_1.Float3Attributes(this._concatenatedBuffer);
	                this._tangents.set(values, offset);
	            }
	            else if (this._tangents) {
	                this.clearVertices(this._tangents);
	                this._tangents = null;
	                return;
	            }
	        }
	        else {
	            this._tangents = ElementsUtils_1.ElementsUtils.generateTangents(this.indices, this.faceTangents, this.faceNormals, this._tangents, this._concatenatedBuffer);
	        }
	        this.invalidateVertices(this._tangents);
	        this._verticesDirty[this._tangents.id] = false;
	    };
	    TriangleElements.prototype.setUVs = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._uvs)
	            return;
	        if (values instanceof AttributesView_1.AttributesView) {
	            this.clearVertices(this._uvs);
	            this._uvs = values;
	        }
	        else if (values) {
	            if (!this._uvs)
	                this._uvs = new Float2Attributes_1.Float2Attributes(this._concatenatedBuffer);
	            this._uvs.set(values, offset);
	        }
	        else if (this._uvs) {
	            this.clearVertices(this._uvs);
	            this._uvs = null;
	            return;
	        }
	        this.invalidateVertices(this._uvs);
	        this._verticesDirty[this._uvs.id] = false;
	    };
	    TriangleElements.prototype.setJointIndices = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._jointIndices)
	            return;
	        if (values instanceof AttributesView_1.AttributesView) {
	            this.clearVertices(this._jointIndices);
	            this._jointIndices = values;
	        }
	        else if (values) {
	            if (!this._jointIndices)
	                this._jointIndices = new AttributesView_1.AttributesView(Float32Array, this._jointsPerVertex, this._concatenatedBuffer);
	            if (this._useCondensedIndices) {
	                var i = 0;
	                var oldIndex;
	                var newIndex = 0;
	                var dic = new Object();
	                this._condensedIndexLookUp = new Array();
	                while (i < values.length) {
	                    oldIndex = values[i];
	                    // if we encounter a new index, assign it a new condensed index
	                    if (dic[oldIndex] == undefined) {
	                        dic[oldIndex] = newIndex;
	                        this._condensedIndexLookUp[newIndex++] = oldIndex;
	                    }
	                    //reset value to dictionary lookup
	                    values[i++] = dic[oldIndex];
	                }
	            }
	            this._jointIndices.set(values, offset);
	        }
	        else if (this._jointIndices) {
	            this.clearVertices(this._jointIndices);
	            this._jointIndices = null;
	            return;
	        }
	        this.invalidateVertices(this._jointIndices);
	        this._verticesDirty[this._jointIndices.id] = false;
	    };
	    TriangleElements.prototype.setJointWeights = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        if (values == this._jointWeights)
	            return;
	        if (values instanceof AttributesView_1.AttributesView) {
	            this.clearVertices(this._jointWeights);
	            this._jointWeights = values;
	        }
	        else if (values) {
	            if (!this._jointWeights)
	                this._jointWeights = new AttributesView_1.AttributesView(Float32Array, this._jointsPerVertex, this._concatenatedBuffer);
	            this._jointWeights.set(values, offset);
	        }
	        else if (this._jointWeights) {
	            this.clearVertices(this._jointWeights);
	            this._jointWeights = null;
	            return;
	        }
	        this.invalidateVertices(this._jointWeights);
	        this._verticesDirty[this._jointWeights.id] = false;
	    };
	    /**
	     *
	     */
	    TriangleElements.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        if (this._positions) {
	            this._positions.dispose();
	            this._positions = null;
	        }
	        if (this._normals) {
	            this._normals.dispose();
	            this._normals = null;
	        }
	        if (this._tangents) {
	            this._tangents.dispose();
	            this._tangents = null;
	        }
	        if (this._uvs) {
	            this._uvs.dispose();
	            this._uvs = null;
	        }
	        if (this._jointIndices) {
	            this._jointIndices.dispose();
	            this._jointIndices = null;
	        }
	        if (this._jointWeights) {
	            this._jointWeights.dispose();
	            this._jointWeights = null;
	        }
	        if (this._faceNormals) {
	            this._faceNormals.dispose();
	            this._faceNormals = null;
	        }
	        if (this._faceTangents) {
	            this._faceTangents.dispose();
	            this._faceTangents = null;
	        }
	    };
	    TriangleElements.prototype.setIndices = function (values, offset) {
	        if (offset === void 0) { offset = 0; }
	        _super.prototype.setIndices.call(this, values, offset);
	        this._faceNormalsDirty = true;
	        this._faceTangentsDirty = true;
	        if (this._autoDeriveNormals)
	            this.invalidateVertices(this._normals);
	        if (this._autoDeriveTangents)
	            this.invalidateVertices(this._tangents);
	    };
	    TriangleElements.prototype.copyTo = function (elements) {
	        _super.prototype.copyTo.call(this, elements);
	        //temp disable auto derives
	        var autoDeriveNormals = this._autoDeriveNormals;
	        var autoDeriveTangents = this._autoDeriveTangents;
	        elements.autoDeriveNormals = this._autoDeriveNormals = false;
	        elements.autoDeriveTangents = this._autoDeriveTangents = false;
	        elements.setPositions(this.positions.clone());
	        if (this.normals)
	            elements.setNormals(this.normals.clone());
	        if (this.tangents)
	            elements.setTangents(this.tangents.clone());
	        if (this.uvs)
	            elements.setUVs(this.uvs.clone());
	        elements.jointsPerVertex = this._jointsPerVertex;
	        if (this.jointIndices)
	            elements.setJointIndices(this.jointIndices.clone());
	        if (this.jointWeights)
	            elements.setJointWeights(this.jointWeights.clone());
	        //return auto derives to cloned values
	        elements.autoDeriveNormals = this._autoDeriveNormals = autoDeriveNormals;
	        elements.autoDeriveTangents = this._autoDeriveTangents = autoDeriveTangents;
	    };
	    /**
	     * Clones the current object
	     * @return An exact duplicate of the current object.
	     */
	    TriangleElements.prototype.clone = function () {
	        var clone = new TriangleElements(this._concatenatedBuffer ? this._concatenatedBuffer.clone() : null);
	        this.copyTo(clone);
	        return clone;
	    };
	    TriangleElements.prototype.scaleUV = function (scaleU, scaleV, count, offset) {
	        if (scaleU === void 0) { scaleU = 1; }
	        if (scaleV === void 0) { scaleV = 1; }
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        if (this.uvs)
	            ElementsUtils_1.ElementsUtils.scale(scaleU, scaleV, 0, this.uvs, count || this._numVertices, offset);
	    };
	    /**
	     * Scales the geometry.
	     * @param scale The amount by which to scale.
	     */
	    TriangleElements.prototype.scale = function (scale, count, offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        ElementsUtils_1.ElementsUtils.scale(scale, scale, scale, this.positions, count || this._numVertices, offset);
	    };
	    TriangleElements.prototype.applyTransformation = function (transform, count, offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        ElementsUtils_1.ElementsUtils.applyTransformation(transform, this.positions, this.normals, this.tangents, count || this._numVertices, offset);
	    };
	    /**
	     * Updates the tangents for each face.
	     */
	    TriangleElements.prototype.updateFaceTangents = function () {
	        this._faceTangents = ElementsUtils_1.ElementsUtils.generateFaceTangents(this.indices, this.positions, this.uvs || this.positions, this._faceTangents, this.numElements);
	        this._faceTangentsDirty = false;
	    };
	    /**
	     * Updates the normals for each face.
	     */
	    TriangleElements.prototype.updateFaceNormals = function () {
	        this._faceNormals = ElementsUtils_1.ElementsUtils.generateFaceNormals(this.indices, this.positions, this._faceNormals, this.numElements);
	        this._faceNormalsDirty = false;
	    };
	    TriangleElements.prototype._iTestCollision = function (pickingCollider, material, pickingCollision, count, offset) {
	        if (count === void 0) { count = 0; }
	        if (offset === void 0) { offset = 0; }
	        return pickingCollider.testTriangleCollision(this, material, pickingCollision, count || this._numVertices, offset);
	    };
	    TriangleElements.assetType = "[asset TriangleElements]";
	    return TriangleElements;
	}(ElementsBase_1.ElementsBase));
	exports.TriangleElements = TriangleElements;


/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var GraphicsPathWinding_1 = __webpack_require__(181);
	var GraphicsPathCommand_1 = __webpack_require__(182);
	var GraphicsFillStyle_1 = __webpack_require__(183);
	var GraphicsStrokeStyle_1 = __webpack_require__(184);
	var Point_1 = __webpack_require__(58);
	/**
	
	 * Defines the values to use for specifying path-drawing commands.
	 * The values in this class are used by the Graphics.drawPath() method,
	 *or stored in the commands vector of a GraphicsPath object.
	 */
	var GraphicsPath = (function () {
	    function GraphicsPath(commands, data, winding_rule) {
	        if (commands === void 0) { commands = null; }
	        if (data === void 0) { data = null; }
	        if (winding_rule === void 0) { winding_rule = GraphicsPathWinding_1.GraphicsPathWinding.EVEN_ODD; }
	        this._data = [];
	        this._commands = [];
	        this._style = null;
	        if (commands != null && data != null) {
	            this._data[0] = data;
	            this._commands[0] = commands;
	        }
	        else {
	            this._data[0] = [];
	            this._commands[0] = [];
	        }
	        this._startPoint = new Point_1.Point();
	        this._cur_point = new Point_1.Point();
	        this._winding_rule = winding_rule;
	        this._winding_directions = [];
	    }
	    Object.defineProperty(GraphicsPath.prototype, "data_type", {
	        get: function () {
	            return GraphicsPath.data_type;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsPath.prototype, "style", {
	        get: function () {
	            return this._style;
	        },
	        set: function (value) {
	            this._style = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GraphicsPath.prototype.fill = function () {
	        if (this._style == null)
	            return null;
	        if (this._style.data_type == GraphicsFillStyle_1.GraphicsFillStyle.data_type)
	            return this._style;
	        return null;
	    };
	    GraphicsPath.prototype.stroke = function () {
	        if (this._style == null)
	            return null;
	        if (this._style.data_type == GraphicsStrokeStyle_1.GraphicsStrokeStyle.data_type)
	            return this._style;
	        return null;
	    };
	    Object.defineProperty(GraphicsPath.prototype, "commands", {
	        get: function () {
	            return this._commands;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsPath.prototype, "data", {
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GraphicsPath.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
	        // if controlpoint and anchor are same, we add lineTo command
	        if ((controlX == anchorX) && (controlY == anchorY)) {
	            this.lineTo(controlX, controlY);
	            this.moveTo(anchorX, anchorY);
	            return;
	        }
	        // if anchor is current point, but controlpoint is different, we lineto controlpoint
	        if (((this._cur_point.x == anchorX) && (this._cur_point.y == anchorY)) && ((this._cur_point.x != controlX) || (this._cur_point.y != controlY))) {
	            this.lineTo(controlX, controlY);
	            this.moveTo(anchorX, anchorY);
	            return;
	        }
	        // if controlpoint is current point, but anchor is different, we lineto anchor
	        if (((this._cur_point.x != anchorX) || (this._cur_point.y != anchorY)) && ((this._cur_point.x == controlX) && (this._cur_point.y == controlY))) {
	            this.lineTo(anchorX, anchorY);
	            return;
	        }
	        // if controlpoint and anchor are same as current point
	        if (((this._cur_point.x == anchorX) && (this._cur_point.y == anchorY)) && ((this._cur_point.x == controlX) && (this._cur_point.y == controlY))) {
	            console.log("curveTo command not added because startpoint and endpoint are the same.");
	            this.lineTo(anchorX, anchorY);
	            return;
	        }
	        if (this._commands[this._commands.length - 1].length == 0) {
	            // every contour must start with a moveTo command, so we make sure we have correct startpoint
	            this._commands[this._commands.length - 1].push(GraphicsPathCommand_1.GraphicsPathCommand.MOVE_TO);
	            this._data[this._data.length - 1].push(this._cur_point.x);
	            this._data[this._data.length - 1].push(this._cur_point.y);
	        }
	        this._commands[this._commands.length - 1].push(GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO);
	        this._data[this._data.length - 1].push(controlX);
	        this._data[this._data.length - 1].push(controlY);
	        this._data[this._data.length - 1].push(anchorX);
	        this._data[this._data.length - 1].push(anchorY);
	        this._cur_point.x = anchorX;
	        this._cur_point.y = anchorY;
	    };
	    GraphicsPath.prototype.cubicCurveTo = function (controlX, controlY, control2X, control2Y, anchorX, anchorY) {
	        console.log("cubicCurveTo not yet fully supported.");
	        if ((this._cur_point.x == anchorX) && (this._cur_point.y == anchorY)) {
	            console.log("curveTo command not added because startpoint and endpoint are the same.");
	            return;
	        }
	        if (this._commands[this._commands.length - 1].length == 0) {
	            // every contour must start with a moveTo command, so we make sure we have correct startpoint
	            this._commands[this._commands.length - 1].push(GraphicsPathCommand_1.GraphicsPathCommand.MOVE_TO);
	            this._data[this._data.length - 1].push(this._cur_point.x);
	            this._data[this._data.length - 1].push(this._cur_point.y);
	        }
	        this._commands[this._commands.length - 1].push(GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO);
	        this._data[this._data.length - 1].push(controlX);
	        this._data[this._data.length - 1].push(controlY);
	        this._data[this._data.length - 1].push(anchorX);
	        this._data[this._data.length - 1].push(anchorY);
	        this._cur_point.x = anchorX;
	        this._cur_point.y = anchorY;
	    };
	    GraphicsPath.prototype.lineTo = function (x, y) {
	        if ((this._cur_point.x == x) && (this._cur_point.y == y)) {
	            console.log("lineTo command not added because startpoint and endpoint are the same.");
	            return;
	        }
	        if (this._commands[this._commands.length - 1].length == 0) {
	            // every contour must start with a moveTo command, so we make sure we have correct startpoint
	            this._commands[this._commands.length - 1].push(GraphicsPathCommand_1.GraphicsPathCommand.MOVE_TO);
	            this._data[this._data.length - 1].push(this._cur_point.x);
	            this._data[this._data.length - 1].push(this._cur_point.y);
	        }
	        this._commands[this._commands.length - 1].push(GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO);
	        this._data[this._data.length - 1].push(x);
	        this._data[this._data.length - 1].push(y);
	        this._cur_point.x = x;
	        this._cur_point.y = y;
	    };
	    GraphicsPath.prototype.moveTo = function (x, y) {
	        if ((this._cur_point.x == x) && (this._cur_point.y == y)) {
	            console.log("moveTo command not added because startpoint and endpoint are the same.");
	            return;
	        }
	        // whenever a moveTo command apears, we start a new contour
	        if (this._commands[this._commands.length - 1].length > 0) {
	            this._commands.push([GraphicsPathCommand_1.GraphicsPathCommand.MOVE_TO]);
	            this._data.push([x, y]);
	        }
	        this._startPoint.x = x;
	        this._startPoint.y = y;
	        this._cur_point.x = x;
	        this._cur_point.y = y;
	    };
	    GraphicsPath.prototype.wideLineTo = function (x, y) {
	        // not used
	        /*
	         this._commands.push(GraphicsPathCommand.WIDE_LINE_TO);
	         this._data.push(0);
	         this._data.push(0);
	         this._data.push(x);
	         this._data.push(y);
	         */
	    };
	    GraphicsPath.prototype.wideMoveTo = function (x, y) {
	        // not used
	        /*
	         this._commands.push(GraphicsPathCommand.WIDE_MOVE_TO);
	         this._data.push(0);
	         this._data.push(0);
	         this._data.push(x);
	         this._data.push(y);
	         */
	    };
	    GraphicsPath.data_type = "[graphicsdata path]";
	    return GraphicsPath;
	}());
	exports.GraphicsPath = GraphicsPath;


/***/ },
/* 181 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The GraphicsPathWinding class provides values for the
	 * <code>flash.display.GraphicsPath.winding</code> property and the
	 * <code>flash.display.Graphics.drawPath()</code> method to determine the
	 * direction to draw a path. A clockwise path is positively wound, and a
	 * counter-clockwise path is negatively wound:
	 *
	 * <p> When paths intersect or overlap, the winding direction determines the
	 * rules for filling the areas created by the intersection or overlap:</p>
	 */
	var GraphicsPathWinding = (function () {
	    function GraphicsPathWinding() {
	    }
	    GraphicsPathWinding.EVEN_ODD = "evenOdd";
	    GraphicsPathWinding.NON_ZERO = "nonZero";
	    return GraphicsPathWinding;
	}());
	exports.GraphicsPathWinding = GraphicsPathWinding;


/***/ },
/* 182 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Defines the values to use for specifying path-drawing commands.
	 * The values in this class are used by the Graphics.drawPath() method,
	 *or stored in the commands vector of a GraphicsPath object.
	 */
	var GraphicsPathCommand = (function () {
	    function GraphicsPathCommand() {
	    }
	    /**
	     * Represents the default "do nothing" command.
	     */
	    GraphicsPathCommand.NO_OP = 0;
	    /**
	     * Specifies a drawing command that moves the current drawing position
	     * to the x- and y-coordinates specified in the data vector.
	     */
	    GraphicsPathCommand.MOVE_TO = 1;
	    /**
	     * Specifies a drawing command that draws a line from the current drawing position
	     * to the x- and y-coordinates specified in the data vector.
	     */
	    GraphicsPathCommand.LINE_TO = 2;
	    /**
	     *  Specifies a drawing command that draws a curve from the current drawing position
	     *  to the x- and y-coordinates specified in the data vector, using a control point.
	     */
	    GraphicsPathCommand.CURVE_TO = 3;
	    /**
	     *  Specifies a drawing command that draws a curve from the current drawing position
	     *  to the x- and y-coordinates specified in the data vector, using a control point.
	     */
	    GraphicsPathCommand.BUILD_JOINT = 13;
	    GraphicsPathCommand.BUILD_ROUND_JOINT = 14;
	    /**
	     * Specifies a "line to" drawing command,
	     * but uses two sets of coordinates (four values) instead of one set.
	     */
	    GraphicsPathCommand.WIDE_LINE_TO = 4;
	    /**
	     *   Specifies a "move to" drawing command,
	     *   but uses two sets of coordinates (four values) instead of one set.
	     */
	    GraphicsPathCommand.WIDE_MOVE_TO = 5;
	    /**
	     * Specifies a drawing command that draws a curve from the current drawing position
	     * to the x- and y-coordinates specified in the data vector, using 2 control points.
	     */
	    GraphicsPathCommand.CUBIC_CURVE = 6;
	    return GraphicsPathCommand;
	}());
	exports.GraphicsPathCommand = GraphicsPathCommand;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = GraphicsPathCommand;


/***/ },
/* 183 */
/***/ function(module, exports) {

	"use strict";
	var GraphicsFillStyle = (function () {
	    function GraphicsFillStyle(color, alpha) {
	        if (color === void 0) { color = 0xffffff; }
	        if (alpha === void 0) { alpha = 1; }
	        this._color = color;
	        this._alpha = alpha;
	    }
	    Object.defineProperty(GraphicsFillStyle.prototype, "data_type", {
	        get: function () {
	            return GraphicsFillStyle.data_type;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GraphicsFillStyle.data_type = "[graphicsdata FillStyle]";
	    return GraphicsFillStyle;
	}());
	exports.GraphicsFillStyle = GraphicsFillStyle;


/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var JointStyle_1 = __webpack_require__(185);
	var CapsStyle_1 = __webpack_require__(186);
	var GraphicsStrokeStyle = (function () {
	    function GraphicsStrokeStyle(color, alpha, thickness, jointstyle, capstyle, miter_limit) {
	        if (color === void 0) { color = 0xffffff; }
	        if (alpha === void 0) { alpha = 1; }
	        if (thickness === void 0) { thickness = 10; }
	        if (jointstyle === void 0) { jointstyle = JointStyle_1.JointStyle.ROUND; }
	        if (capstyle === void 0) { capstyle = CapsStyle_1.CapsStyle.SQUARE; }
	        if (miter_limit === void 0) { miter_limit = 10; }
	        this._color = color;
	        this._alpha = alpha;
	        this._thickness = thickness;
	        this._jointstyle = jointstyle;
	        this._capstyle = capstyle;
	        this._miter_limit = miter_limit;
	    }
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "data_type", {
	        get: function () {
	            return GraphicsStrokeStyle.data_type;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "color", {
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            this._color = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "alpha", {
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            this._alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "half_thickness", {
	        get: function () {
	            return this._thickness / 2;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "thickness", {
	        get: function () {
	            return this._thickness;
	        },
	        set: function (value) {
	            this._thickness = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "jointstyle", {
	        get: function () {
	            return this._jointstyle;
	        },
	        set: function (value) {
	            this._jointstyle = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "miter_limit", {
	        get: function () {
	            return this._miter_limit;
	        },
	        set: function (value) {
	            this._miter_limit = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GraphicsStrokeStyle.prototype, "capstyle", {
	        get: function () {
	            return this._capstyle;
	        },
	        set: function (value) {
	            this._capstyle = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GraphicsStrokeStyle.data_type = "[graphicsdata StrokeStyle]";
	    return GraphicsStrokeStyle;
	}());
	exports.GraphicsStrokeStyle = GraphicsStrokeStyle;


/***/ },
/* 185 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The JointStyle class is an enumeration of constant values that specify the
	 * joint style to use in drawing lines. These constants are provided for use
	 * as values in the <code>joints</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method. The method supports
	 * three types of joints: miter, round, and bevel, as the following example
	 * shows:
	 */
	var JointStyle = (function () {
	    function JointStyle() {
	    }
	    /**
	     * Specifies beveled joints in the <code>joints</code> parameter of the
	     * <code>flash.display.Graphics.lineStyle()</code> method.
	     */
	    JointStyle.BEVEL = 2;
	    /**
	     * Specifies mitered joints in the <code>joints</code> parameter of the
	     * <code>flash.display.Graphics.lineStyle()</code> method.
	     */
	    JointStyle.MITER = 0;
	    /**
	     * Specifies round joints in the <code>joints</code> parameter of the
	     * <code>flash.display.Graphics.lineStyle()</code> method.
	     */
	    JointStyle.ROUND = 1;
	    return JointStyle;
	}());
	exports.JointStyle = JointStyle;


/***/ },
/* 186 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The CapsStyle class is an enumeration of constant values that specify the
	 * caps style to use in drawing lines. The constants are provided for use as
	 * values in the <code>caps</code> parameter of the
	 * <code>flash.display.Graphics.lineStyle()</code> method. You can specify the
	 * following three types of caps:
	 */
	var CapsStyle = (function () {
	    function CapsStyle() {
	    }
	    /**
	     * Used to specify round caps in the <code>caps</code> parameter of the
	     * <code>flash.display.Graphics.lineStyle()</code> method.
	     */
	    CapsStyle.ROUND = 1;
	    /**
	     * Used to specify no caps in the <code>caps</code> parameter of the
	     * <code>flash.display.Graphics.lineStyle()</code> method.
	     */
	    CapsStyle.NONE = 0;
	    /**
	     * Used to specify square caps in the <code>caps</code> parameter of the
	     * <code>flash.display.Graphics.lineStyle()</code> method.
	     */
	    CapsStyle.SQUARE = 2;
	    return CapsStyle;
	}());
	exports.CapsStyle = CapsStyle;


/***/ },
/* 187 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var GraphicsPathCommand_1 = __webpack_require__(182);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var Point_1 = __webpack_require__(58);
	var AttributesView_1 = __webpack_require__(4);
	var Float3Attributes_1 = __webpack_require__(15);
	var Float2Attributes_1 = __webpack_require__(14);
	var MathConsts_1 = __webpack_require__(35);
	var GraphicsFactoryHelper_1 = __webpack_require__(188);
	var TriangleElements_1 = __webpack_require__(179);
	/**
	 * The Graphics class contains a set of methods that you can use to create a
	 * vector shape. Display objects that support drawing include Sprite and Shape
	 * objects. Each of these classes includes a <code>graphics</code> property
	 * that is a Graphics object. The following are among those helper functions
	 * provided for ease of use: <code>drawRect()</code>,
	 * <code>drawRoundRect()</code>, <code>drawCircle()</code>, and
	 * <code>drawEllipse()</code>.
	 *
	 * <p>You cannot create a Graphics object directly from ActionScript code. If
	 * you call <code>new Graphics()</code>, an exception is thrown.</p>
	 *
	 * <p>The Graphics class is final; it cannot be subclassed.</p>
	 */
	var GraphicsFactoryFills = (function () {
	    function GraphicsFactoryFills() {
	    }
	    GraphicsFactoryFills.draw_pathes = function (targetGraphic) {
	        var len = targetGraphic.queued_fill_pathes.length;
	        var cp = 0;
	        for (cp = 0; cp < len; cp++) {
	            var one_path = targetGraphic.queued_fill_pathes[cp];
	            //one_path.finalizeContour();
	            var contour_commands = one_path.commands;
	            var contour_data = one_path.data;
	            var commands;
	            var data;
	            var i = 0;
	            var k = 0;
	            var vert_cnt = 0;
	            var data_cnt = 0;
	            var draw_direction = 0;
	            var contours_vertices = [[]];
	            var final_vert_list = [];
	            var final_vert_cnt = 0;
	            var lastPoint = new Point_1.Point();
	            var last_dir_vec = new Point_1.Point();
	            var end_point = new Point_1.Point();
	            for (k = 0; k < contour_commands.length; k++) {
	                contours_vertices.push([]);
	                vert_cnt = 0;
	                data_cnt = 0;
	                commands = contour_commands[k];
	                data = contour_data[k];
	                draw_direction = 0;
	                var new_dir = 0;
	                var new_dir_1 = 0;
	                var new_dir_2 = 0;
	                var dir_delta = 0;
	                var last_direction = 0;
	                var tmp_dir_point = new Point_1.Point();
	                if ((data[0] != data[data.length - 2]) || (data[1] != data[data.length - 1])) {
	                    data[data.length] == data[0];
	                    data[data.length] == data[1];
	                }
	                lastPoint.x = data[0];
	                lastPoint.y = data[1];
	                if (commands[1] == GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO) {
	                    last_dir_vec.x = data[2] - lastPoint.x;
	                    last_dir_vec.y = data[3] - lastPoint.y;
	                }
	                else if (commands[1] == GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO) {
	                    last_dir_vec.x = data[4] - lastPoint.x;
	                    last_dir_vec.y = data[5] - lastPoint.y;
	                }
	                data_cnt = 2;
	                last_dir_vec.normalize();
	                last_direction = Math.atan2(last_dir_vec.y, last_dir_vec.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                for (i = 1; i < commands.length; i++) {
	                    end_point = new Point_1.Point(data[data_cnt++], data[data_cnt++]);
	                    if (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.MOVE_TO) {
	                        console.log("ERROR ! ONLY THE FIRST COMMAND FOR A CONTOUR IS ALLOWED TO BE A 'MOVE_TO' COMMAND");
	                    }
	                    else if (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO) {
	                        end_point = new Point_1.Point(data[data_cnt++], data[data_cnt++]);
	                    }
	                    //get the directional vector and the direction for this segment
	                    tmp_dir_point.x = end_point.x - lastPoint.x;
	                    tmp_dir_point.y = end_point.y - lastPoint.y;
	                    tmp_dir_point.normalize();
	                    new_dir = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                    // get the difference in angle to the last segment
	                    dir_delta = new_dir - last_direction;
	                    if (dir_delta > 180) {
	                        dir_delta -= 360;
	                    }
	                    if (dir_delta < -180) {
	                        dir_delta += 360;
	                    }
	                    draw_direction += dir_delta;
	                    last_direction = new_dir;
	                    lastPoint.x = end_point.x;
	                    lastPoint.y = end_point.y;
	                }
	                lastPoint.x = data[0];
	                lastPoint.y = data[1];
	                data_cnt = 2;
	                contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.x;
	                contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.y;
	                //console.log("Draw directions complete: "+draw_direction);
	                for (i = 1; i < commands.length; i++) {
	                    switch (commands[i]) {
	                        case GraphicsPathCommand_1.GraphicsPathCommand.MOVE_TO:
	                            console.log("ERROR ! ONLY THE FIRST COMMAND FOR A CONTOUR IS ALLOWED TO BE A 'MOVE_TO' COMMAND");
	                            break;
	                        case GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO:
	                            lastPoint.x = data[data_cnt++];
	                            lastPoint.y = data[data_cnt++];
	                            contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.x;
	                            contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.y;
	                            break;
	                        case GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO:
	                            var control_x = data[data_cnt++];
	                            var control_y = data[data_cnt++];
	                            var end_x = data[data_cnt++];
	                            var end_y = data[data_cnt++];
	                            tmp_dir_point.x = control_x - lastPoint.x;
	                            tmp_dir_point.y = control_y - lastPoint.y;
	                            tmp_dir_point.normalize();
	                            new_dir_1 = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                            tmp_dir_point.x = end_x - lastPoint.x;
	                            tmp_dir_point.y = end_y - lastPoint.y;
	                            tmp_dir_point.normalize();
	                            new_dir_2 = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                            // get the difference in angle to the last segment
	                            var curve_direction = new_dir_2 - new_dir_1;
	                            if (curve_direction > 180) {
	                                curve_direction -= 360;
	                            }
	                            if (curve_direction < -180) {
	                                curve_direction += 360;
	                            }
	                            if ((curve_direction == 0) && (curve_direction == 180) && (curve_direction == -180)) {
	                                lastPoint.x = end_x;
	                                lastPoint.y = end_y;
	                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.x;
	                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.y;
	                                break;
	                            }
	                            var curve_attr_1 = -1;
	                            if (draw_direction < 0) {
	                                if (curve_direction > 0) {
	                                    //convex
	                                    //console.log("convex");
	                                    curve_attr_1 = 1;
	                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_x;
	                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_y;
	                                }
	                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_x;
	                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_y;
	                            }
	                            else {
	                                if (curve_direction < 0) {
	                                    //convex
	                                    //console.log("convex");
	                                    curve_attr_1 = 1;
	                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_x;
	                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_y;
	                                }
	                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_x;
	                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_y;
	                            }
	                            if (GraphicsFactoryHelper_1.GraphicsFactoryHelper.isClockWiseXY(end_x, end_y, control_x, control_y, lastPoint.x, lastPoint.y)) {
	                                final_vert_list[final_vert_cnt++] = end_x;
	                                final_vert_list[final_vert_cnt++] = end_y;
	                                final_vert_list[final_vert_cnt++] = curve_attr_1;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = control_x;
	                                final_vert_list[final_vert_cnt++] = control_y;
	                                final_vert_list[final_vert_cnt++] = curve_attr_1;
	                                final_vert_list[final_vert_cnt++] = 0.5;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = lastPoint.x;
	                                final_vert_list[final_vert_cnt++] = lastPoint.y;
	                                final_vert_list[final_vert_cnt++] = curve_attr_1;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                            }
	                            else {
	                                final_vert_list[final_vert_cnt++] = lastPoint.x;
	                                final_vert_list[final_vert_cnt++] = lastPoint.y;
	                                final_vert_list[final_vert_cnt++] = curve_attr_1;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = control_x;
	                                final_vert_list[final_vert_cnt++] = control_y;
	                                final_vert_list[final_vert_cnt++] = curve_attr_1;
	                                final_vert_list[final_vert_cnt++] = 0.5;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = end_x;
	                                final_vert_list[final_vert_cnt++] = end_y;
	                                final_vert_list[final_vert_cnt++] = curve_attr_1;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                                final_vert_list[final_vert_cnt++] = 1.0;
	                                final_vert_list[final_vert_cnt++] = 0.0;
	                            }
	                            lastPoint.x = end_x;
	                            lastPoint.y = end_y;
	                            break;
	                        case GraphicsPathCommand_1.GraphicsPathCommand.CUBIC_CURVE:
	                            //todo
	                            break;
	                    }
	                }
	            }
	            var verts = [];
	            var all_verts = [];
	            var vertIndicess = [];
	            var elems = [];
	            for (k = 0; k < contours_vertices.length; k++) {
	                var vertices = contours_vertices[k];
	                //for (i = 0; i < vertices.length / 2; ++i)
	                //console.log("vert collected" + i + " = " + vertices[i * 2] + " / " + vertices[i * 2 + 1]);
	                var verticesF32 = new Float32Array(vertices);
	                //var verticesF32 = new Float32Array([0,0, 100,0, 100,100, 0,100]);
	                //console.log("in vertices", vertices);
	                //var tess = new TESS();
	                if (GraphicsFactoryHelper_1.GraphicsFactoryHelper._tess_obj == null) {
	                    console.log("No libtess2 tesselator available.\nMake it available using Graphics._tess_obj=new TESS();");
	                    return;
	                }
	                GraphicsFactoryHelper_1.GraphicsFactoryHelper._tess_obj.addContour(verticesF32, 2, 8, vertices.length / 2);
	            }
	            GraphicsFactoryHelper_1.GraphicsFactoryHelper._tess_obj.tesselate(0 /*TESS.WINDING_ODD*/, 0 /*TESS.ELEMENT_POLYGONS*/, 3, 2, null);
	            //console.log("out vertices", Graphics._tess_obj.getVertices());
	            verts = GraphicsFactoryHelper_1.GraphicsFactoryHelper._tess_obj.getVertices();
	            elems = GraphicsFactoryHelper_1.GraphicsFactoryHelper._tess_obj.getElements();
	            //console.log("out elements", Graphics._tess_obj.getElements());
	            var numVerts = verts.length / 2;
	            var numElems = elems.length / 3;
	            for (i = 0; i < numVerts; ++i)
	                all_verts.push(new Point_1.Point(verts[i * 2], verts[i * 2 + 1]));
	            for (i = 0; i < numElems; ++i) {
	                var p1 = elems[i * 3];
	                var p2 = elems[i * 3 + 1];
	                var p3 = elems[i * 3 + 2];
	                final_vert_list[final_vert_cnt++] = all_verts[p3].x;
	                final_vert_list[final_vert_cnt++] = all_verts[p3].y;
	                final_vert_list[final_vert_cnt++] = 1;
	                final_vert_list[final_vert_cnt++] = 2.0;
	                final_vert_list[final_vert_cnt++] = 0.0;
	                final_vert_list[final_vert_cnt++] = 1.0;
	                final_vert_list[final_vert_cnt++] = 0.0;
	                final_vert_list[final_vert_cnt++] = all_verts[p2].x;
	                final_vert_list[final_vert_cnt++] = all_verts[p2].y;
	                final_vert_list[final_vert_cnt++] = 1;
	                final_vert_list[final_vert_cnt++] = 2.0;
	                final_vert_list[final_vert_cnt++] = 0.0;
	                final_vert_list[final_vert_cnt++] = 1.0;
	                final_vert_list[final_vert_cnt++] = 0.0;
	                final_vert_list[final_vert_cnt++] = all_verts[p1].x;
	                final_vert_list[final_vert_cnt++] = all_verts[p1].y;
	                final_vert_list[final_vert_cnt++] = 1;
	                final_vert_list[final_vert_cnt++] = 2.0;
	                final_vert_list[final_vert_cnt++] = 0.0;
	                final_vert_list[final_vert_cnt++] = 1.0;
	                final_vert_list[final_vert_cnt++] = 0.0;
	            }
	            //for (i = 0; i < final_vert_list.length/7; ++i)
	            //	console.log("final verts "+i+" = "+final_vert_list[i*7]+" / "+final_vert_list[i*7+1]);
	            var attributesView = new AttributesView_1.AttributesView(Float32Array, 7);
	            attributesView.set(final_vert_list);
	            var attributesBuffer = attributesView.attributesBuffer;
	            attributesView.dispose();
	            var elements = new TriangleElements_1.TriangleElements(attributesBuffer);
	            elements.setPositions(new Float2Attributes_1.Float2Attributes(attributesBuffer));
	            elements.setCustomAttributes("curves", new Float3Attributes_1.Float3Attributes(attributesBuffer));
	            elements.setUVs(new Float2Attributes_1.Float2Attributes(attributesBuffer));
	            var material = DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial();
	            material.bothSides = true;
	            material.useColorTransform = true;
	            material.curves = true;
	            var thisGraphic = targetGraphic.addGraphic(elements, material);
	        }
	        targetGraphic.queued_fill_pathes.length = 0;
	    };
	    return GraphicsFactoryFills;
	}());
	exports.GraphicsFactoryFills = GraphicsFactoryFills;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CapsStyle_1 = __webpack_require__(186);
	var Point_1 = __webpack_require__(58);
	var MathConsts_1 = __webpack_require__(35);
	var GraphicsFactoryHelper = (function () {
	    function GraphicsFactoryHelper() {
	    }
	    GraphicsFactoryHelper.isClockWiseXY = function (point1x, point1y, point2x, point2y, point3x, point3y) {
	        var num = (point1x - point2x) * (point3y - point2y) - (point1y - point2y) * (point3x - point2x);
	        if (num < 0)
	            return false;
	        return true;
	    };
	    GraphicsFactoryHelper.getSign = function (ax, ay, cx, cy, bx, by) {
	        return (ax - bx) * (cy - by) - (ay - by) * (cx - bx);
	    };
	    GraphicsFactoryHelper.pointInTri = function (ax, ay, bx, by, cx, cy, xx, xy) {
	        var b1 = GraphicsFactoryHelper.getSign(ax, ay, xx, xy, bx, by) > 0;
	        var b2 = GraphicsFactoryHelper.getSign(bx, by, xx, xy, cx, cy) > 0;
	        var b3 = GraphicsFactoryHelper.getSign(cx, cy, xx, xy, ax, ay) > 0;
	        return ((b1 == b2) && (b2 == b3));
	    };
	    GraphicsFactoryHelper.getControlXForCurveX = function (a, c, b) {
	        return c;
	    };
	    GraphicsFactoryHelper.getControlYForCurveY = function (a, c, b) {
	        return c;
	    };
	    GraphicsFactoryHelper.drawPoint = function (startX, startY, vertices) {
	        GraphicsFactoryHelper.addTriangle(startX - 2, startY - 2, startX + 2, startY - 2, startX + 2, startY + 2, 0, vertices);
	        GraphicsFactoryHelper.addTriangle(startX - 2, startY - 2, startX - 2, startY + 2, startX + 2, startY + 2, 0, vertices);
	    };
	    GraphicsFactoryHelper.addTriangle = function (startX, startY, controlX, controlY, endX, endY, tri_type, vertices) {
	        var final_vert_cnt = vertices.length;
	        if (tri_type == 0) {
	            vertices[final_vert_cnt++] = startX;
	            vertices[final_vert_cnt++] = startY;
	            vertices[final_vert_cnt++] = 4.5736980577097704e-41; // ((127<<24)+(127<<16)+0+0)
	            vertices[final_vert_cnt++] = controlX;
	            vertices[final_vert_cnt++] = controlY;
	            vertices[final_vert_cnt++] = 4.5736980577097704e-41; // ((127<<24)+(127<<16)+0+0)
	            vertices[final_vert_cnt++] = endX;
	            vertices[final_vert_cnt++] = endY;
	            vertices[final_vert_cnt++] = 4.5736980577097704e-41; // ((127<<24)+(127<<16)+0+0)
	        }
	        else if (tri_type < 0) {
	            vertices[final_vert_cnt++] = startX;
	            vertices[final_vert_cnt++] = startY;
	            vertices[final_vert_cnt++] = 1.1708844992641982e-38; // ((127<<24)+(127<<16)+0+0)
	            vertices[final_vert_cnt++] = controlX;
	            vertices[final_vert_cnt++] = controlY;
	            vertices[final_vert_cnt++] = 2.2778106537599901e-41; // ((127<<24)+(63<<16)+0+0)
	            vertices[final_vert_cnt++] = endX;
	            vertices[final_vert_cnt++] = endY;
	            vertices[final_vert_cnt++] = 1.7796490496925177e-43; // ((127<<24)+0+0+0)
	        }
	        else if (tri_type > 0) {
	            vertices[final_vert_cnt++] = startX;
	            vertices[final_vert_cnt++] = startY;
	            vertices[final_vert_cnt++] = 1.1708846393940446e-38; // ((-128<<24)+(127<<16)+0+0)
	            vertices[final_vert_cnt++] = controlX;
	            vertices[final_vert_cnt++] = controlY;
	            vertices[final_vert_cnt++] = 2.2779507836064226e-41; // ((-128<<24)+(63<<16)+0+0)
	            vertices[final_vert_cnt++] = endX;
	            vertices[final_vert_cnt++] = endY;
	            vertices[final_vert_cnt++] = 1.793662034335766e-43; // ((-128<<24)+0+0+0)
	        }
	    };
	    GraphicsFactoryHelper.createCap = function (startX, startY, start_le, start_ri, dir_vec, capstyle, cap_position, thickness, vertices) {
	        if (capstyle == CapsStyle_1.CapsStyle.ROUND) {
	            //console.log("add round cap");
	            var tmp1_x = startX + (cap_position * (dir_vec.x * thickness));
	            var tmp1_y = startY + (cap_position * (dir_vec.y * thickness));
	            tmp1_x = tmp1_x * 2 - start_le.x / 2 - start_ri.x / 2;
	            tmp1_y = tmp1_y * 2 - start_le.y / 2 - start_ri.y / 2;
	            GraphicsFactoryHelper.addTriangle(start_le.x, start_le.y, tmp1_x, tmp1_y, start_ri.x, start_ri.y, -1, vertices);
	        }
	        else if (capstyle == CapsStyle_1.CapsStyle.SQUARE) {
	            //console.log("add square cap");
	            var tmp1_x = start_le.x + (cap_position * (dir_vec.x * thickness));
	            var tmp1_y = start_le.y + (cap_position * (dir_vec.y * thickness));
	            var tmp2_x = start_ri.x + (cap_position * (dir_vec.x * thickness));
	            var tmp2_y = start_ri.y + (cap_position * (dir_vec.y * thickness));
	            GraphicsFactoryHelper.addTriangle(tmp2_x, tmp2_y, tmp1_x, tmp1_y, start_le.x, start_le.y, 0, vertices);
	            GraphicsFactoryHelper.addTriangle(tmp2_x, tmp2_y, start_le.x, start_le.y, start_ri.x, start_ri.y, 0, vertices);
	        }
	    };
	    GraphicsFactoryHelper.getLineFormularData = function (a, b) {
	        var tmp_x = b.x - a.x;
	        var tmp_y = b.y - a.y;
	        var return_point = new Point_1.Point();
	        if ((tmp_x != 0) && (tmp_y != 0))
	            return_point.x = tmp_y / tmp_x;
	        return_point.y = -(return_point.x * a.x - a.y);
	        return return_point;
	    };
	    GraphicsFactoryHelper.getQuadricBezierPosition = function (t, start, control, end) {
	        var xt = 1 - t;
	        return xt * xt * start + 2 * xt * t * control + t * t * end;
	    };
	    GraphicsFactoryHelper.subdivideCurve = function (startx, starty, cx, cy, endx, endy, startx2, starty2, cx2, cy2, endx2, endy2, array_out, array2_out) {
	        var angle_1 = Math.atan2(cy - starty, cx - startx) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	        var angle_2 = Math.atan2(endy - cy, endx - cx) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	        var angle_delta = angle_2 - angle_1;
	        //console.log("angle_delta "+angle_delta);
	        if (angle_delta > 180) {
	            angle_delta -= 360;
	        }
	        if (angle_delta < -180) {
	            angle_delta += 360;
	        }
	        if (Math.abs(angle_delta) >= 150) {
	            array_out.push(startx, starty, cx, cy, endx, endy);
	            array2_out.push(startx2, starty2, cx2, cy2, endx2, endy2);
	            return;
	        }
	        var b1 = false;
	        var b2 = false;
	        if (angle_delta < 0) {
	            // curve is curved to right side. right side is convex
	            b1 = GraphicsFactoryHelper.getSign(startx, starty, cx2, cy2, endx, endy) > 0;
	            b2 = GraphicsFactoryHelper.getSign(startx, starty, cx, cy, endx, endy) > 0;
	            b1 = (((starty - endy) * (cx - startx) + (endx - startx) * (cy - starty)) * ((starty - endy) * (cx2 - startx) + (endx - startx) * (cy2 - starty))) < 0;
	        }
	        else {
	            // curve is curved to left side. left side is convex
	            b1 = GraphicsFactoryHelper.getSign(startx2, starty2, cx2, cy2, endx2, endy2) > 0;
	            b2 = GraphicsFactoryHelper.getSign(startx2, starty2, cx, cy, endx2, endy2) > 0;
	            b1 = (((starty2 - endy) * (cx - startx2) + (endx2 - startx2) * (cy - starty2)) * ((starty2 - endy2) * (cx2 - startx2) + (endx2 - startx2) * (cy2 - starty2))) < 0;
	        }
	        if (b1) {
	            array_out.push(startx, starty, cx, cy, endx, endy);
	            array2_out.push(startx2, starty2, cx2, cy2, endx2, endy2);
	            return;
	        }
	        // triangles overlap. we must subdivide:
	        var c1x = startx + (cx - startx) * 0.5; // new controlpoint 1.1
	        var c1y = starty + (cy - starty) * 0.5;
	        var c2x = cx + (endx - cx) * 0.5; // new controlpoint 1.2
	        var c2y = cy + (endy - cy) * 0.5;
	        var ax = c1x + (c2x - c1x) * 0.5; // new middlepoint 1
	        var ay = c1y + (c2y - c1y) * 0.5;
	        var c1x2 = startx2 + (cx2 - startx2) * 0.5; // new controlpoint 2.1
	        var c1y2 = starty2 + (cy2 - starty2) * 0.5;
	        var c2x2 = cx2 + (endx2 - cx2) * 0.5; // new controlpoint 2.2
	        var c2y2 = cy2 + (endy2 - cy2) * 0.5;
	        var ax2 = c1x2 + (c2x2 - c1x2) * 0.5; // new middlepoint 2
	        var ay2 = c1y2 + (c2y2 - c1y2) * 0.5;
	        GraphicsFactoryHelper.subdivideCurve(startx, starty, c1x, c1y, ax, ay, startx2, starty2, c1x2, c1y2, ax2, ay2, array_out, array2_out);
	        GraphicsFactoryHelper.subdivideCurve(ax, ay, c2x, c2y, endx, endy, ax2, ay2, c2x2, c2y2, endx2, endy2, array_out, array2_out);
	    };
	    return GraphicsFactoryHelper;
	}());
	exports.GraphicsFactoryHelper = GraphicsFactoryHelper;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var MathConsts_1 = __webpack_require__(35);
	var JointStyle_1 = __webpack_require__(185);
	var GraphicsPathCommand_1 = __webpack_require__(182);
	var Point_1 = __webpack_require__(58);
	var GraphicsFactoryHelper_1 = __webpack_require__(188);
	/**
	 * The Graphics class contains a set of methods that you can use to create a
	 * vector shape. Display objects that support drawing include Sprite and Shape
	 * objects. Each of these classes includes a <code>graphics</code> property
	 * that is a Graphics object. The following are among those helper functions
	 * provided for ease of use: <code>drawRect()</code>,
	 * <code>drawRoundRect()</code>, <code>drawCircle()</code>, and
	 * <code>drawEllipse()</code>.
	 *
	 * <p>You cannot create a Graphics object directly from ActionScript code. If
	 * you call <code>new Graphics()</code>, an exception is thrown.</p>
	 *
	 * <p>The Graphics class is final; it cannot be subclassed.</p>
	 */
	var GraphicsFactoryStrokes = (function () {
	    function GraphicsFactoryStrokes() {
	    }
	    GraphicsFactoryStrokes.draw_pathes = function (graphic_pathes, final_vert_list) {
	        var len = graphic_pathes.length;
	        var contour_commands;
	        var contour_data;
	        var strokeStyle;
	        var one_path;
	        var commands;
	        var data;
	        var i = 0;
	        var k = 0;
	        var vert_cnt = 0;
	        var data_cnt = 0;
	        var final_vert_cnt = 0;
	        var lastPoint = new Point_1.Point();
	        var start_point = new Point_1.Point();
	        var end_point = new Point_1.Point();
	        var start_left = new Point_1.Point();
	        var start_right = new Point_1.Point();
	        var ctr_left = new Point_1.Point();
	        var ctr_right = new Point_1.Point();
	        var ctr_left2 = new Point_1.Point();
	        var ctr_right2 = new Point_1.Point();
	        var end_left = new Point_1.Point();
	        var end_right = new Point_1.Point();
	        var tmp_point = new Point_1.Point();
	        var tmp_point2 = new Point_1.Point();
	        var tmp_point3 = new Point_1.Point();
	        var closed = false;
	        var last_dir_vec = new Point_1.Point();
	        var cp = 0;
	        for (cp = 0; cp < len; cp++) {
	            one_path = graphic_pathes[cp];
	            contour_commands = one_path.commands;
	            contour_data = one_path.data;
	            strokeStyle = one_path.stroke();
	            for (k = 0; k < contour_commands.length; k++) {
	                commands = contour_commands[k];
	                data = contour_data[k];
	                vert_cnt = 0;
	                data_cnt = 0;
	                var new_dir = 0;
	                var dir_delta = 0;
	                var last_direction = 0;
	                var tmp_dir_point = new Point_1.Point();
	                closed = true;
	                if ((data[0] != data[data.length - 2]) || (data[1] != data[data.length - 1]))
	                    closed = false;
	                else {
	                    last_dir_vec.x = data[data.length - 2] - data[data.length - 4];
	                    last_dir_vec.y = data[data.length - 1] - data[data.length - 3];
	                    last_dir_vec.normalize();
	                    last_direction = Math.atan2(last_dir_vec.y, last_dir_vec.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                }
	                data_cnt = 0;
	                lastPoint.x = data[data_cnt++];
	                lastPoint.y = data[data_cnt++];
	                var new_cmds = [];
	                var new_pnts = [];
	                var new_cmds_cnt = 0;
	                var new_pnts_cnt = 0;
	                var prev_normal = new Point_1.Point();
	                var le_point = new Point_1.Point();
	                var curve_end_point = new Point_1.Point();
	                var ri_point = new Point_1.Point();
	                var ctr_point = new Point_1.Point();
	                prev_normal.x = -1 * last_dir_vec.y;
	                prev_normal.y = last_dir_vec.x;
	                for (i = 1; i < commands.length; i++) {
	                    if (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.MOVE_TO) {
	                        console.log("ERROR ! ONLY THE FIRST COMMAND FOR A CONTOUR IS ALLOWED TO BE A 'MOVE_TO' COMMAND");
	                        continue;
	                    }
	                    //console.log("");
	                    //console.log("segment "+i+"lastPoint x = "+lastPoint.x+" y = "+lastPoint.y)
	                    end_point = new Point_1.Point(data[data_cnt++], data[data_cnt++]);
	                    //console.log("segment "+i+"end_point x = "+end_point.x+" y = "+end_point.y)
	                    if (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO) {
	                        curve_end_point = new Point_1.Point(data[data_cnt++], data[data_cnt++]);
	                    }
	                    //get the directional vector and the direction for this segment
	                    tmp_dir_point.x = end_point.x - lastPoint.x;
	                    tmp_dir_point.y = end_point.y - lastPoint.y;
	                    tmp_dir_point.normalize();
	                    new_dir = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                    // get the difference in angle to the last segment
	                    dir_delta = new_dir - last_direction;
	                    if (dir_delta > 180) {
	                        dir_delta -= 360;
	                    }
	                    if (dir_delta < -180) {
	                        dir_delta += 360;
	                    }
	                    //console.log("DIRECTION DELTA: "+dir_delta);
	                    last_direction = new_dir;
	                    //console.log("segment "+i+" direction: "+dir_delta);
	                    // rotate direction around 90 degree
	                    tmp_point.x = -1 * tmp_dir_point.y;
	                    tmp_point.y = tmp_dir_point.x;
	                    ri_point = new Point_1.Point(lastPoint.x + (tmp_point.x * strokeStyle.half_thickness), lastPoint.y + (tmp_point.y * strokeStyle.half_thickness));
	                    le_point = new Point_1.Point(lastPoint.x - (tmp_point.x * strokeStyle.half_thickness), lastPoint.y - (tmp_point.y * strokeStyle.half_thickness));
	                    var add_segment = false;
	                    // check if this is the first segment, and the path is not closed
	                    // in this case, we can just set the points to the contour points
	                    if ((i == 1) && (!closed)) {
	                        //console.log("segment "+i+"Path is not closed, we can just add the first segment")
	                        add_segment = true;
	                    }
	                    else {
	                        // we need to figure out if we need to add a joint or not
	                        if ((dir_delta == 0) || (dir_delta == 180)) {
	                            // check if this and the prev segment was a line. if yes, than they can be merged
	                            if ((i != 1) && (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO) && (new_cmds[new_cmds.length - 1] == GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO)) {
	                                //console.log("straight line can be merged in prev straight line");
	                                add_segment = false;
	                            }
	                            else {
	                                add_segment = true;
	                            }
	                        }
	                        if (Math.abs(dir_delta) == 180) {
	                            add_segment = true;
	                        }
	                        else if (dir_delta != 0) {
	                            add_segment = true;
	                            var half_angle = (180 - (dir_delta));
	                            if (dir_delta < 0) {
	                                half_angle = (-180 - (dir_delta));
	                            }
	                            half_angle = half_angle * -0.5 * MathConsts_1.MathConsts.DEGREES_TO_RADIANS;
	                            var distance = strokeStyle.half_thickness / Math.sin(half_angle);
	                            tmp_point2.x = tmp_dir_point.x * Math.cos(half_angle) + tmp_dir_point.y * Math.sin(half_angle);
	                            tmp_point2.y = tmp_dir_point.y * Math.cos(half_angle) - tmp_dir_point.x * Math.sin(half_angle);
	                            tmp_point2.normalize();
	                            var merged_pnt_ri = new Point_1.Point(lastPoint.x - (tmp_point2.x * distance), lastPoint.y - (tmp_point2.y * distance));
	                            var merged_pnt_le = new Point_1.Point(lastPoint.x + (tmp_point2.x * distance), lastPoint.y + (tmp_point2.y * distance));
	                            if (dir_delta > 0) {
	                                ri_point = merged_pnt_ri;
	                                var contour_le = new Point_1.Point(lastPoint.x - (tmp_point.x * strokeStyle.half_thickness), lastPoint.y - (tmp_point.y * strokeStyle.half_thickness));
	                                var contour_prev_le = new Point_1.Point(lastPoint.x - (prev_normal.x * strokeStyle.half_thickness), lastPoint.y - (prev_normal.y * strokeStyle.half_thickness));
	                                le_point = contour_le;
	                            }
	                            else {
	                                le_point = merged_pnt_le;
	                                var contour_ri = new Point_1.Point(lastPoint.x + (tmp_point.x * strokeStyle.half_thickness), lastPoint.y + (tmp_point.y * strokeStyle.half_thickness));
	                                var contour_prev_ri = new Point_1.Point(lastPoint.x + (prev_normal.x * strokeStyle.half_thickness), lastPoint.y + (prev_normal.y * strokeStyle.half_thickness));
	                                ri_point = contour_ri;
	                            }
	                            var addJoints = true;
	                            if (strokeStyle.jointstyle == JointStyle_1.JointStyle.MITER) {
	                                var distance_miter = (Math.sqrt((distance * distance) - (strokeStyle.half_thickness * strokeStyle.half_thickness)) / strokeStyle.half_thickness);
	                                if (distance_miter <= strokeStyle.miter_limit) {
	                                    addJoints = false;
	                                    ri_point = merged_pnt_ri;
	                                    le_point = merged_pnt_le;
	                                }
	                                else {
	                                    if (dir_delta > 0) {
	                                        contour_le.x = contour_le.x - (tmp_dir_point.x * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                        contour_le.y = contour_le.y - (tmp_dir_point.y * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                        tmp_point3.x = prev_normal.y * -1;
	                                        tmp_point3.y = prev_normal.x;
	                                        contour_prev_le.x = contour_prev_le.x - (tmp_point3.x * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                        contour_prev_le.y = contour_prev_le.y - (tmp_point3.y * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                    }
	                                    else {
	                                        contour_ri.x = contour_ri.x - (tmp_dir_point.x * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                        contour_ri.y = contour_ri.y - (tmp_dir_point.y * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                        tmp_point3.x = prev_normal.y * -1;
	                                        tmp_point3.y = prev_normal.x;
	                                        contour_prev_ri.x = contour_prev_ri.x - (tmp_point3.x * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                        contour_prev_ri.y = contour_prev_ri.y - (tmp_point3.y * (strokeStyle.miter_limit * strokeStyle.half_thickness));
	                                    }
	                                }
	                            }
	                            if (addJoints) {
	                                new_cmds[new_cmds_cnt++] = (strokeStyle.jointstyle != JointStyle_1.JointStyle.ROUND) ? GraphicsPathCommand_1.GraphicsPathCommand.BUILD_JOINT : GraphicsPathCommand_1.GraphicsPathCommand.BUILD_ROUND_JOINT;
	                                if (dir_delta > 0) {
	                                    new_pnts[new_pnts_cnt++] = merged_pnt_ri;
	                                    new_pnts[new_pnts_cnt++] = contour_prev_le;
	                                    new_pnts[new_pnts_cnt++] = contour_le;
	                                }
	                                else {
	                                    new_pnts[new_pnts_cnt++] = contour_prev_ri;
	                                    new_pnts[new_pnts_cnt++] = merged_pnt_le;
	                                    new_pnts[new_pnts_cnt++] = contour_ri;
	                                }
	                                if (strokeStyle.jointstyle == JointStyle_1.JointStyle.ROUND) {
	                                    new_pnts[new_pnts_cnt++] = new Point_1.Point(lastPoint.x - (tmp_point2.x * Math.abs(distance)), lastPoint.y - (tmp_point2.y * Math.abs(distance)));
	                                    if (dir_delta > 0) {
	                                        new_pnts[new_pnts_cnt++] = contour_prev_le;
	                                        new_pnts[new_pnts_cnt++] = contour_le;
	                                    }
	                                    else {
	                                        new_pnts[new_pnts_cnt++] = contour_prev_ri;
	                                        new_pnts[new_pnts_cnt++] = contour_ri;
	                                    }
	                                }
	                            }
	                        }
	                    }
	                    prev_normal.x = tmp_point.x;
	                    prev_normal.y = tmp_point.y;
	                    if (add_segment) {
	                        if (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO) {
	                            new_cmds[new_cmds_cnt++] = GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO;
	                            new_pnts[new_pnts_cnt++] = ri_point;
	                            new_pnts[new_pnts_cnt++] = le_point;
	                        }
	                        else if (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO) {
	                            tmp_dir_point.x = curve_end_point.x - end_point.x;
	                            tmp_dir_point.y = curve_end_point.y - end_point.y;
	                            tmp_dir_point.normalize();
	                            new_dir = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                            dir_delta = new_dir - last_direction;
	                            last_direction = new_dir;
	                            tmp_point.x = -1 * tmp_dir_point.y;
	                            tmp_point.y = tmp_dir_point.x;
	                            if ((dir_delta != 0) && (dir_delta != 180)) {
	                                new_cmds[new_cmds_cnt++] = GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO;
	                                new_pnts[new_pnts_cnt++] = ri_point;
	                                new_pnts[new_pnts_cnt++] = le_point;
	                                new_pnts[new_pnts_cnt++] = new Point_1.Point(lastPoint.x, lastPoint.y);
	                                new_pnts[new_pnts_cnt++] = new Point_1.Point(end_point.x, end_point.y);
	                                new_pnts[new_pnts_cnt++] = curve_end_point;
	                            }
	                            else {
	                                new_cmds[new_cmds_cnt++] = GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO;
	                                new_pnts[new_pnts_cnt++] = ri_point;
	                                new_pnts[new_pnts_cnt++] = le_point;
	                            }
	                            prev_normal.x = tmp_point.x;
	                            prev_normal.y = tmp_point.y;
	                            lastPoint = curve_end_point;
	                        }
	                    }
	                    if (commands[i] == GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO) {
	                        lastPoint = end_point;
	                    }
	                    if (i == commands.length - 1) {
	                        if (!closed) {
	                            new_cmds[new_cmds_cnt++] = GraphicsPathCommand_1.GraphicsPathCommand.NO_OP;
	                            new_pnts[new_pnts_cnt++] = new Point_1.Point(lastPoint.x + (tmp_point.x * strokeStyle.half_thickness), lastPoint.y + (tmp_point.y * strokeStyle.half_thickness));
	                            new_pnts[new_pnts_cnt++] = new Point_1.Point(lastPoint.x - (tmp_point.x * strokeStyle.half_thickness), lastPoint.y - (tmp_point.y * strokeStyle.half_thickness));
	                        }
	                        else {
	                            new_cmds[new_cmds_cnt++] = GraphicsPathCommand_1.GraphicsPathCommand.NO_OP;
	                            new_pnts[new_pnts_cnt++] = new_pnts[0];
	                            new_pnts[new_pnts_cnt++] = new_pnts[1];
	                        }
	                    }
	                }
	                // first we draw all the curves:
	                new_cmds_cnt = 0;
	                new_pnts_cnt = 0;
	                for (i = 0; i < new_cmds.length; i++) {
	                    if (new_cmds[i] == GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO) {
	                        new_pnts_cnt += 2;
	                    }
	                    else if (new_cmds[i] == GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO) {
	                        start_right = new_pnts[new_pnts_cnt++];
	                        start_left = new_pnts[new_pnts_cnt++];
	                        start_point = new_pnts[new_pnts_cnt++];
	                        ctr_point = new_pnts[new_pnts_cnt++];
	                        end_point = new_pnts[new_pnts_cnt++];
	                        end_right = new_pnts[new_pnts_cnt];
	                        end_left = new_pnts[new_pnts_cnt + 1];
	                        // get the directional vector for the first part of the curve
	                        tmp_dir_point.x = ctr_point.x - start_point.x;
	                        tmp_dir_point.y = ctr_point.y - start_point.y;
	                        tmp_point3.x = ctr_point.x - start_point.x;
	                        tmp_point3.y = ctr_point.y - start_point.y;
	                        var length1 = tmp_point3.length;
	                        tmp_dir_point.normalize();
	                        // get the directional vector for the second part of the curve
	                        tmp_point2.x = end_point.x - ctr_point.x;
	                        tmp_point2.y = end_point.y - ctr_point.y;
	                        var length2 = tmp_point2.length;
	                        tmp_point2.normalize();
	                        var length_calc = 0.5 - ((length2 - length1) / length1) * 0.5;
	                        if (length1 > length2) {
	                            length_calc = 0.5 + ((length1 - length2) / length2) * 0.5;
	                        }
	                        // get angle to positive x-axis for both dir-vectors, than get the difference between those
	                        var angle_1 = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                        var angle_2 = Math.atan2(tmp_point2.y, tmp_point2.x) * MathConsts_1.MathConsts.RADIANS_TO_DEGREES;
	                        dir_delta = angle_2 - angle_1;
	                        if (dir_delta > 180)
	                            dir_delta -= 360;
	                        if (dir_delta < -180)
	                            dir_delta += 360;
	                        //var half_angle:number=dir_delta*0.5*MathConsts.DEGREES_TO_RADIANS;
	                        //var distance:number=strokeStyle.half_thickness / Math.sin(half_angle);
	                        //tmp_point3.x = tmp_point2.x * Math.cos(half_angle) + tmp_point2.y * Math.sin(half_angle);
	                        //tmp_point3.y = tmp_point2.y * Math.cos(half_angle) - tmp_point2.x * Math.sin(half_angle);
	                        //tmp_point3.normalize();
	                        //var merged_pnt_ri:Point = new Point(ctr_point.x - (tmp_point3.x * distance), ctr_point.y - (tmp_point3.y * distance));
	                        //var merged_pnt_le:Point = new Point(ctr_point.x + (tmp_point3.x * distance), ctr_point.y + (tmp_point3.y * distance));
	                        var curve_x = GraphicsFactoryHelper_1.GraphicsFactoryHelper.getQuadricBezierPosition(0.5, start_point.x, ctr_point.x, end_point.x);
	                        var curve_y = GraphicsFactoryHelper_1.GraphicsFactoryHelper.getQuadricBezierPosition(0.5, start_point.y, ctr_point.y, end_point.y);
	                        var curve_2x = GraphicsFactoryHelper_1.GraphicsFactoryHelper.getQuadricBezierPosition(0.501, start_point.x, ctr_point.x, end_point.x);
	                        var curve_2y = GraphicsFactoryHelper_1.GraphicsFactoryHelper.getQuadricBezierPosition(0.501, start_point.y, ctr_point.y, end_point.y);
	                        tmp_point3.x = -1 * (curve_y - curve_2y);
	                        tmp_point3.y = curve_x - curve_2x;
	                        tmp_point3.normalize();
	                        //GraphicsFactoryHelper.drawPoint(curve_x,curve_y, final_vert_list);
	                        // move the point on the curve to use correct thickness
	                        ctr_right.x = curve_x - (tmp_point3.x * strokeStyle.half_thickness);
	                        ctr_right.y = curve_y - (tmp_point3.y * strokeStyle.half_thickness);
	                        ctr_left.x = curve_x + (tmp_point3.x * strokeStyle.half_thickness);
	                        ctr_left.y = curve_y + (tmp_point3.y * strokeStyle.half_thickness);
	                        //GraphicsFactoryHelper.drawPoint(ctr_right.x, ctr_right.y , final_vert_list);
	                        //GraphicsFactoryHelper.drawPoint(ctr_left.x, ctr_left.y , final_vert_list);
	                        // calculate the actual controlpoints
	                        ctr_right.x = ctr_right.x * 2 - start_right.x / 2 - end_right.x / 2;
	                        ctr_right.y = ctr_right.y * 2 - start_right.y / 2 - end_right.y / 2;
	                        ctr_left.x = ctr_left.x * 2 - start_left.x / 2 - end_left.x / 2;
	                        ctr_left.y = ctr_left.y * 2 - start_left.y / 2 - end_left.y / 2;
	                        //ctr_right=merged_pnt_ri;
	                        //ctr_left=merged_pnt_le;
	                        /*
	                         // controlpoints version2:
	                         tmp_dir_point.x = start_left.x-start_right.x;
	                         tmp_dir_point.y = start_left.y-start_right.y;
	                         tmp_point2.x = end_left.x-end_right.x;
	                         tmp_point2.y = end_left.y-end_right.y;
	
	                         ctr_right.x = ctr_point.x-(tmp_dir_point.x/2);
	                         ctr_right.y = ctr_point.y-(tmp_dir_point.y/2);
	                         var new_end_ri:Point = new Point(end_point.x+(tmp_dir_point.x/2), end_point.y+(tmp_dir_point.y/2));
	
	                         ctr_left.x = ctr_point.x+(tmp_dir_point.x/2);
	                         ctr_left.y = ctr_point.y+(tmp_dir_point.y/2);
	                         var new_end_le:Point = new Point(end_point.x-(tmp_dir_point.x/2), end_point.y-(tmp_dir_point.y/2));
	
	                         */
	                        /*
	                         tmp_point2.x=ctr_point.x-start_point.x;
	                         tmp_point2.y=ctr_point.y-start_point.y;
	                         var m1:number=tmp_point2.y/tmp_point2.x;
	                         tmp_point2.x=end_point.x-ctr_point.x;
	                         tmp_point2.y=end_point.y-ctr_point.y;
	                         var m2:number=tmp_point2.y/tmp_point2.x;
	
	                         if(m1==m2){
	                         console.log("lines for curve are parallel - this should not be possible!")
	                         }
	                         if((!isFinite(m1))&&(!isFinite(m2))){
	                         console.log("both lines are vertical - this should not be possible!")
	                         }
	                         else if((isFinite(m1))&&(isFinite(m2))) {
	                         var b_r1:number = start_right.y - (m1 * start_right.x);
	                         var b_l1:number = start_left.y - (m1 * start_left.x);
	                         var b_r2:number = end_right.y - (m2 * end_right.x);
	                         var b_l2:number = end_left.y - (m2 * end_left.x);
	                         ctr_right.x = (b_r2 - b_r1) / (m1 - m2);
	                         ctr_right.y = m1 * ctr_right.x + b_r1;
	                         ctr_left.x = (b_l2 - b_l1) / (m1 - m2);
	                         ctr_left.y = m1 * ctr_left.x + b_l1;
	                         }
	                         else if((!isFinite(m1))&&(isFinite(m2))) {
	                         console.log("second part of curve is vertical line");
	                         var b_r2:number = end_right.y - (m2 * end_right.x);
	                         var b_l2:number = end_left.y - (m2 * end_left.x);
	                         ctr_right.x =  start_right.x;
	                         ctr_right.y = m2 * ctr_right.x + b_r2;
	                         ctr_left.x =  start_left.x;
	                         ctr_left.y = m2 * ctr_left.x + b_l2;
	                         }
	                         else if((isFinite(m1))&&(!isFinite(m2))) {
	                         console.log("first part of curve is vertical line");
	                         var b_r1:number = start_right.y - (m1 * start_right.x);
	                         var b_l1:number = start_left.y - (m1 * start_left.x);
	                         ctr_right.x =  end_right.x;
	                         ctr_right.y = m1 * ctr_right.x + b_r1;
	                         ctr_left.x =  end_left.x;
	                         ctr_left.y = m1 * ctr_left.x + b_l1;
	                         }
	                         */
	                        /*
	                         tmp_point2.x=ctr_right.x-ctr_left.x;
	                         tmp_point2.y=ctr_right.y-ctr_left.y;
	                         if(tmp_point2.length!=strokeStyle.thickness){
	
	                         tmp_point.x=ctr_left.x+tmp_point2.x*0.5;
	                         tmp_point.y=ctr_left.y+tmp_point2.y*0.5;
	                         tmp_point2.normalize();
	                         ctr_left.x=tmp_point.x-tmp_point2.x*strokeStyle.half_thickness;
	                         ctr_left.y=tmp_point.y-tmp_point2.y*strokeStyle.half_thickness;
	                         ctr_right.x=tmp_point.x+tmp_point2.x*strokeStyle.half_thickness;
	                         ctr_right.y=tmp_point.y+tmp_point2.y*strokeStyle.half_thickness;
	                         }
	                         */
	                        //ctr_right=ctr_point;
	                        //ctr_left=ctr_point;
	                        //console.log(start_point.x);
	                        //console.log(start_point.y);
	                        //console.log(ctr_point.x);
	                        //console.log(ctr_point.y);
	                        //console.log(end_point.x);
	                        //console.log(end_point.y);
	                        var subdivided = [];
	                        var subdivided2 = [];
	                        GraphicsFactoryHelper_1.GraphicsFactoryHelper.subdivideCurve(start_right.x, start_right.y, ctr_right.x, ctr_right.y, end_right.x, end_right.y, start_left.x, start_left.y, ctr_left.x, ctr_left.y, end_left.x, end_left.y, subdivided, subdivided2);
	                        if (dir_delta > 0) {
	                            for (var sc = 0; sc < subdivided.length / 6; sc++) {
	                                // right curved
	                                // concave curves:
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], -128, final_vert_list);
	                                // fills
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], 0, final_vert_list);
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], 0, final_vert_list);
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], 0, final_vert_list);
	                                // convex curves:
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], 127, final_vert_list);
	                            }
	                        }
	                        else {
	                            for (var sc = 0; sc < subdivided.length / 6; sc++) {
	                                // left curved
	                                // convex curves:
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], 127, final_vert_list);
	                                // fills
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], 0, final_vert_list);
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], 0, final_vert_list);
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], 0, final_vert_list);
	                                // concave curves:
	                                GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], -128, final_vert_list);
	                            }
	                        }
	                    }
	                    else if (new_cmds[i] >= GraphicsPathCommand_1.GraphicsPathCommand.BUILD_JOINT) {
	                        new_pnts_cnt += 3;
	                        if (new_cmds[i] == GraphicsPathCommand_1.GraphicsPathCommand.BUILD_ROUND_JOINT) {
	                            end_left = new_pnts[new_pnts_cnt++]; // concave curves:
	                            start_right = new_pnts[new_pnts_cnt++];
	                            start_left = new_pnts[new_pnts_cnt++];
	                            GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(start_right.x, start_right.y, end_left.x, end_left.y, start_left.x, start_left.y, -1, final_vert_list);
	                        }
	                    }
	                }
	                // now we draw all the normal triangles.
	                // we do it in 2 steps, to prevent curves cut anything out of underlying normal tris
	                new_cmds_cnt = 0;
	                new_pnts_cnt = 0;
	                for (i = 0; i < new_cmds.length; i++) {
	                    if (new_cmds[i] == GraphicsPathCommand_1.GraphicsPathCommand.LINE_TO) {
	                        start_right = new_pnts[new_pnts_cnt++];
	                        start_left = new_pnts[new_pnts_cnt++];
	                        end_right = new_pnts[new_pnts_cnt];
	                        end_left = new_pnts[new_pnts_cnt + 1];
	                        GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(start_right.x, start_right.y, start_left.x, start_left.y, end_right.x, end_right.y, 0, final_vert_list);
	                        GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(start_left.x, start_left.y, end_left.x, end_left.y, end_right.x, end_right.y, 0, final_vert_list);
	                    }
	                    else if (new_cmds[i] == GraphicsPathCommand_1.GraphicsPathCommand.CURVE_TO) {
	                        new_pnts_cnt += 5;
	                    }
	                    else if (new_cmds[i] >= GraphicsPathCommand_1.GraphicsPathCommand.BUILD_JOINT) {
	                        end_right = new_pnts[new_pnts_cnt++];
	                        start_right = new_pnts[new_pnts_cnt++];
	                        start_left = new_pnts[new_pnts_cnt++];
	                        GraphicsFactoryHelper_1.GraphicsFactoryHelper.addTriangle(start_right.x, start_right.y, start_left.x, start_left.y, end_right.x, end_right.y, 0, final_vert_list);
	                        if (new_cmds[i] == GraphicsPathCommand_1.GraphicsPathCommand.BUILD_ROUND_JOINT) {
	                            new_pnts_cnt += 3;
	                        }
	                    }
	                }
	                if (!closed) {
	                    last_dir_vec.x = data[2] - data[0];
	                    last_dir_vec.y = data[3] - data[1];
	                    last_dir_vec.normalize();
	                    GraphicsFactoryHelper_1.GraphicsFactoryHelper.createCap(data[0], data[1], new_pnts[0], new_pnts[1], last_dir_vec, strokeStyle.capstyle, -128, strokeStyle.half_thickness, final_vert_list);
	                    last_dir_vec.x = data[data.length - 2] - data[data.length - 4];
	                    last_dir_vec.y = data[data.length - 1] - data[data.length - 3];
	                    last_dir_vec.normalize();
	                    GraphicsFactoryHelper_1.GraphicsFactoryHelper.createCap(data[data.length - 2], data[data.length - 1], new_pnts[new_pnts.length - 2], new_pnts[new_pnts.length - 1], last_dir_vec, strokeStyle.capstyle, 127, strokeStyle.half_thickness, final_vert_list);
	                }
	            }
	        }
	        //targetGraphic.queued_stroke_pathes.length=0;
	    };
	    return GraphicsFactoryStrokes;
	}());
	exports.GraphicsFactoryStrokes = GraphicsFactoryStrokes;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	/**
	 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
	 * by a concrete subclass.
	 */
	var PartialImplementationError = (function (_super) {
	    __extends(PartialImplementationError, _super);
	    /**
	     * Create a new AbstractMethodError.
	     * @param message An optional message to override the default error message.
	     * @param id The id of the error.
	     */
	    function PartialImplementationError(dependency, id) {
	        if (dependency === void 0) { dependency = ''; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, "PartialImplementationError - this function is in development. Required Dependency: " + dependency, id);
	    }
	    return PartialImplementationError;
	}(ErrorBase_1.ErrorBase));
	exports.PartialImplementationError = PartialImplementationError;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesView_1 = __webpack_require__(4);
	var Float2Attributes_1 = __webpack_require__(14);
	var ColorTransform_1 = __webpack_require__(27);
	var HierarchicalProperties_1 = __webpack_require__(22);
	var TextFieldType_1 = __webpack_require__(192);
	var Sprite_1 = __webpack_require__(177);
	var TriangleElements_1 = __webpack_require__(179);
	var BitmapFontTable_1 = __webpack_require__(193);
	/**
	 * The TextField class is used to create display objects for text display and
	 * input. <ph outputclass="flexonly">You can use the TextField class to
	 * perform low-level text rendering. However, in Flex, you typically use the
	 * Label, Text, TextArea, and TextInput controls to process text. <ph
	 * outputclass="flashonly">You can give a text field an instance name in the
	 * Property inspector and use the methods and properties of the TextField
	 * class to manipulate it with ActionScript. TextField instance names are
	 * displayed in the Movie Explorer and in the Insert Target Path dialog box in
	 * the Actions panel.
	 *
	 * <p>To create a text field dynamically, use the <code>TextField()</code>
	 * constructor.</p>
	 *
	 * <p>The methods of the TextField class let you set, select, and manipulate
	 * text in a dynamic or input text field that you create during authoring or
	 * at runtime. </p>
	 *
	 * <p>ActionScript provides several ways to format your text at runtime. The
	 * TextFormat class lets you set character and paragraph formatting for
	 * TextField objects. You can apply Cascading Style Sheets(CSS) styles to
	 * text fields by using the <code>TextField.styleSheet</code> property and the
	 * StyleSheet class. You can use CSS to style built-in HTML tags, define new
	 * formatting tags, or apply styles. You can assign HTML formatted text, which
	 * optionally uses CSS styles, directly to a text field. HTML text that you
	 * assign to a text field can contain embedded media(movie clips, SWF files,
	 * GIF files, PNG files, and JPEG files). The text wraps around the embedded
	 * media in the same way that a web browser wraps text around media embedded
	 * in an HTML document. </p>
	 *
	 * <p>Flash Player supports a subset of HTML tags that you can use to format
	 * text. See the list of supported HTML tags in the description of the
	 * <code>htmlText</code> property.</p>
	 *
	 * @event change                    Dispatched after a control value is
	 *                                  modified, unlike the
	 *                                  <code>textInput</code> event, which is
	 *                                  dispatched before the value is modified.
	 *                                  Unlike the W3C DOM Event Model version of
	 *                                  the <code>change</code> event, which
	 *                                  dispatches the event only after the
	 *                                  control loses focus, the ActionScript 3.0
	 *                                  version of the <code>change</code> event
	 *                                  is dispatched any time the control
	 *                                  changes. For example, if a user types text
	 *                                  into a text field, a <code>change</code>
	 *                                  event is dispatched after every keystroke.
	 * @event link                      Dispatched when a user clicks a hyperlink
	 *                                  in an HTML-enabled text field, where the
	 *                                  URL begins with "event:". The remainder of
	 *                                  the URL after "event:" is placed in the
	 *                                  text property of the LINK event.
	 *
	 *                                  <p><b>Note:</b> The default behavior,
	 *                                  adding the text to the text field, occurs
	 *                                  only when Flash Player generates the
	 *                                  event, which in this case happens when a
	 *                                  user attempts to input text. You cannot
	 *                                  put text into a text field by sending it
	 *                                  <code>textInput</code> events.</p>
	 * @event scroll                    Dispatched by a TextField object
	 *                                  <i>after</i> the user scrolls.
	 * @event textInput                 Flash Player dispatches the
	 *                                  <code>textInput</code> event when a user
	 *                                  enters one or more characters of text.
	 *                                  Various text input methods can generate
	 *                                  this event, including standard keyboards,
	 *                                  input method editors(IMEs), voice or
	 *                                  speech recognition systems, and even the
	 *                                  act of pasting plain text with no
	 *                                  formatting or style information.
	 * @event textInteractionModeChange Flash Player dispatches the
	 *                                  <code>textInteractionModeChange</code>
	 *                                  event when a user changes the interaction
	 *                                  mode of a text field. for example on
	 *                                  Android, one can toggle from NORMAL mode
	 *                                  to SELECTION mode using context menu
	 *                                  options
	 */
	var TextField = (function (_super) {
	    __extends(TextField, _super);
	    /**
	     * Creates a new TextField instance. After you create the TextField instance,
	     * call the <code>addChild()</code> or <code>addChildAt()</code> method of
	     * the parent DisplayObjectContainer object to add the TextField instance to
	     * the display list.
	     *
	     * <p>The default size for a text field is 100 x 100 pixels.</p>
	     */
	    function TextField() {
	        _super.call(this);
	        this._line_indices = [];
	        this._text = "";
	        this.type = TextFieldType_1.TextFieldType.STATIC;
	    }
	    Object.defineProperty(TextField.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return TextField.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "bottomScrollV", {
	        /**
	         * An integer(1-based index) that indicates the bottommost line that is
	         * currently visible in the specified text field. Think of the text field as
	         * a window onto a block of text. The <code>scrollV</code> property is the
	         * 1-based index of the topmost visible line in the window.
	         *
	         * <p>All the text between the lines indicated by <code>scrollV</code> and
	         * <code>bottomScrollV</code> is currently visible in the text field.</p>
	         */
	        get: function () {
	            return this._bottomScrollV;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "caretIndex", {
	        /**
	         * The index of the insertion point(caret) position. If no insertion point
	         * is displayed, the value is the position the insertion point would be if
	         * you restored focus to the field(typically where the insertion point last
	         * was, or 0 if the field has not had focus).
	         *
	         * <p>Selection span indexes are zero-based(for example, the first position
	         * is 0, the second position is 1, and so on).</p>
	         */
	        get: function () {
	            return this._caretIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "length", {
	        /**
	         * The number of characters in a text field. A character such as tab
	         * (<code>\t</code>) counts as one character.
	         */
	        get: function () {
	            return this._length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * The maximum value of <code>scrollH</code>.
	     */
	    TextField.prototype.maxScrollH = function () {
	        return this._maxScrollH;
	    };
	    /**
	     * The maximum value of <code>scrollV</code>.
	     */
	    TextField.prototype.maxScrollV = function () {
	        return this._maxScrollV;
	    };
	    Object.defineProperty(TextField.prototype, "numLines", {
	        /**
	         * Defines the number of text lines in a multiline text field. If
	         * <code>wordWrap</code> property is set to <code>true</code>, the number of
	         * lines increases when text wraps.
	         */
	        get: function () {
	            return this._numLines;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "selectionBeginIndex", {
	        /**
	         * The zero-based character index value of the first character in the current
	         * selection. For example, the first character is 0, the second character is
	         * 1, and so on. If no text is selected, this property is the value of
	         * <code>caretIndex</code>.
	         */
	        get: function () {
	            return this._selectionBeginIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "selectionEndIndex", {
	        /**
	         * The zero-based character index value of the last character in the current
	         * selection. For example, the first character is 0, the second character is
	         * 1, and so on. If no text is selected, this property is the value of
	         * <code>caretIndex</code>.
	         */
	        get: function () {
	            return this._selectionEndIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "text", {
	        /**
	         * A string that is the current text in the text field. Lines are separated
	         * by the carriage return character(<code>'\r'</code>, ASCII 13). This
	         * property contains unformatted text in the text field, without HTML tags.
	         *
	         * <p>To get the text in HTML form, use the <code>htmlText</code>
	         * property.</p>
	         */
	        get: function () {
	            return this._text;
	        },
	        set: function (value) {
	            value = value.toString();
	            if (this._text == value)
	                return;
	            this._text = value;
	            this._textGraphicsDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textFormat", {
	        get: function () {
	            return this._textFormat;
	        },
	        set: function (value) {
	            if (this._textFormat == value)
	                return;
	            this._textFormat = value;
	            this._textGraphicsDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "graphics", {
	        /**
	         * The graphics used by the sprite that provides it with its shape.
	         */
	        get: function () {
	            if (this._textGraphicsDirty)
	                this.reConstruct();
	            if (this._textFormat) {
	                var new_ct = this.transform.colorTransform || (this.transform.colorTransform = new ColorTransform_1.ColorTransform());
	                //if(new_ct.color==0xffffff){
	                this.transform.colorTransform.color = this._textFormat.color;
	                this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM);
	            }
	            return this._graphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textColor", {
	        get: function () {
	            return this._textColor;
	        },
	        set: function (value) {
	            this._textColor = value;
	            this._textFormat.color = value;
	            if (!this.transform.colorTransform)
	                this.transform.colorTransform = new ColorTransform_1.ColorTransform();
	            this.transform.colorTransform.color = value;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textInteractionMode", {
	        /**
	         * The interaction mode property, Default value is
	         * TextInteractionMode.NORMAL. On mobile platforms, the normal mode implies
	         * that the text can be scrolled but not selected. One can switch to the
	         * selectable mode through the in-built context menu on the text field. On
	         * Desktop, the normal mode implies that the text is in scrollable as well as
	         * selection mode.
	         */
	        get: function () {
	            return this._textInteractionMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textWidth", {
	        /**
	         * The width of the text in pixels.
	         */
	        get: function () {
	            return this._textWidth;
	        },
	        set: function (value) {
	            this._textWidth = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "textHeight", {
	        /**
	         * The width of the text in pixels.
	         */
	        get: function () {
	            return this._textHeight;
	        },
	        set: function (value) {
	            this._textHeight = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextField.prototype, "isEntity", {
	        /**
	         *
	         */
	        get: function () {
	            return true; //TODO do this better
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextField.prototype.clear = function () {
	        _super.prototype.clear.call(this);
	        if (this._textElements)
	            this._textElements.clear();
	    };
	    /**
	     * @inheritDoc
	     */
	    TextField.prototype.dispose = function () {
	        this.disposeValues();
	        TextField._textFields.push(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    TextField.prototype.disposeValues = function () {
	        _super.prototype.disposeValues.call(this);
	        this._textFormat = null;
	        this._textGraphic = null;
	        this._textGraphic2 = null;
	        if (this._textElements) {
	            this._textElements.dispose();
	            this._textElements = null;
	        }
	        if (this._textElements2) {
	            this._textElements2.dispose();
	            this._textElements2 = null;
	        }
	    };
	    /**
	     * Reconstructs the Graphics for this Text-field.
	     */
	    TextField.prototype.reConstruct = function () {
	        this._textGraphicsDirty = false;
	        if (this._textFormat == null)
	            return;
	        if (this._textGraphic) {
	            this._textGraphic.dispose();
	            this._textGraphic = null;
	            this._textElements.clear();
	            this._textElements.dispose();
	            this._textElements = null;
	        }
	        if (this._textGraphic2) {
	            this._textGraphic2.dispose();
	            this._textGraphic2 = null;
	            this._textElements2.clear();
	            this._textElements2.dispose();
	            this._textElements2 = null;
	        }
	        if (this._text == "")
	            return;
	        var activeFormat = this._textFormat;
	        activeFormat.font_table.initFontSize(activeFormat.size);
	        var textlines = this.text.toString().split("\\n");
	        var maxlineWidth = this.textWidth - (4 + this._textFormat.leftMargin + this._textFormat.rightMargin + this._textFormat.indent);
	        var tl_char_codes = [];
	        var tl_char_widths = [];
	        var tl_char_heights = [];
	        var tl_formatIdx = [];
	        var tl_width = [];
	        var tl_height = [];
	        var tl_cnt = 0;
	        var w = 0;
	        var c = 0;
	        var tl = 0;
	        var words;
	        var char_cnt = 0;
	        var char_width = 0;
	        var numVertices = 0;
	        var numVertices2 = 0;
	        this._line_indices = [];
	        // sort all chars into final lines
	        for (tl = 0; tl < textlines.length; tl++) {
	            this._line_indices[tl_cnt] = char_cnt;
	            tl_char_codes[tl_cnt] = [];
	            tl_char_widths[tl_cnt] = [];
	            tl_char_heights[tl_cnt] = [];
	            tl_formatIdx[tl_cnt] = [];
	            tl_width[tl_cnt] = 0;
	            tl_height[tl_cnt] = 0;
	            tl_cnt++;
	            words = textlines[tl].split(" ");
	            for (w = 0; w < words.length; w++) {
	                var word_width = 0;
	                var char_widths = [];
	                var char_heights = [];
	                var formatIdx = [];
	                var max_word_height = 0;
	                for (c = 0; c < words[w].length; c++) {
	                    var lineHeight = activeFormat.font_table.getLineHeight();
	                    if (lineHeight > max_word_height)
	                        max_word_height = lineHeight;
	                    char_width = 0;
	                    if (activeFormat.font_table.hasChar(words[w].charCodeAt(c).toString())) {
	                        char_width = activeFormat.font_table.getCharWidth(words[w].charCodeAt(c).toString());
	                        formatIdx[c] = 0;
	                        numVertices += activeFormat.font_table.getCharVertCnt(words[w].charCodeAt(c).toString());
	                    }
	                    else if (activeFormat.font_table.fallbackTable && activeFormat.font_table.fallbackTable.hasChar(words[w].charCodeAt(c).toString())) {
	                        formatIdx[c] = 1;
	                        char_width = activeFormat.font_table.fallbackTable.getCharWidth(words[w].charCodeAt(c).toString());
	                        numVertices2 += activeFormat.font_table.fallbackTable.getCharVertCnt(words[w].charCodeAt(c).toString());
	                        lineHeight = activeFormat.font_table.fallbackTable.getLineHeight();
	                        if (lineHeight > max_word_height)
	                            max_word_height = lineHeight;
	                    }
	                    else {
	                        formatIdx[c] = -1;
	                    }
	                    char_widths[c] = char_width;
	                    char_heights[c] = lineHeight;
	                    word_width += char_width + this._textFormat.letterSpacing;
	                    char_cnt++;
	                }
	                // word fits into line, just add it to the last line
	                if ((tl_width[tl_cnt - 1] + word_width) <= maxlineWidth) {
	                    if (tl_width[tl_cnt - 1] != 0) {
	                        // there is already a word in this line. we want to add a space
	                        tl_char_codes[tl_cnt - 1].push(32);
	                        tl_formatIdx[tl_cnt - 1].push(1);
	                        tl_char_widths[tl_cnt - 1].push(activeFormat.font_table.getCharWidth("32") + this._textFormat.letterSpacing);
	                        tl_width[tl_cnt - 1] += activeFormat.font_table.getCharWidth("32") + this._textFormat.letterSpacing;
	                    }
	                    for (c = 0; c < words[w].length; c++) {
	                        tl_formatIdx[tl_cnt - 1].push(formatIdx[c]);
	                        tl_char_codes[tl_cnt - 1].push(words[w].charCodeAt(c));
	                        tl_char_widths[tl_cnt - 1].push(char_widths[c]);
	                    }
	                    tl_width[tl_cnt - 1] += word_width;
	                    if (tl_height[tl_cnt - 1] < max_word_height)
	                        tl_height[tl_cnt - 1] = max_word_height;
	                }
	                else if (tl_width[tl_cnt - 1] == 0) {
	                    for (c = 0; c < words[w].length; c++) {
	                        tl_formatIdx[tl_cnt - 1].push(formatIdx[c]);
	                        tl_char_codes[tl_cnt - 1].push(words[w].charCodeAt(c));
	                        tl_char_widths[tl_cnt - 1].push(char_widths[c]);
	                    }
	                    tl_width[tl_cnt - 1] += word_width;
	                    if (tl_height[tl_cnt - 1] < max_word_height)
	                        tl_height[tl_cnt - 1] = max_word_height;
	                }
	                else {
	                    tl_char_codes[tl_cnt] = [];
	                    tl_char_widths[tl_cnt] = [];
	                    tl_formatIdx[tl_cnt] = [];
	                    tl_width[tl_cnt] = 0;
	                    tl_height[tl_cnt] = 0;
	                    tl_cnt++;
	                    for (c = 0; c < words[w].length; c++) {
	                        tl_char_codes[tl_cnt - 1].push(words[w].charCodeAt(c));
	                        tl_char_widths[tl_cnt - 1].push(char_widths[c]);
	                        tl_formatIdx[tl_cnt - 1].push(formatIdx[c]);
	                    }
	                    tl_width[tl_cnt - 1] += word_width;
	                    if (tl_height[tl_cnt - 1] < max_word_height)
	                        tl_height[tl_cnt - 1] = max_word_height;
	                }
	            }
	        }
	        var tl_startx = [];
	        // calculate the final positions of the chars
	        for (tl = 0; tl < tl_width.length; tl++) {
	            var x_offset = 2 + this._textFormat.leftMargin + this._textFormat.indent;
	            var justify_addion = 0;
	            if (this._textFormat.align == "center") {
	                x_offset = 2 + this._textFormat.leftMargin + this._textFormat.indent + (maxlineWidth - tl_width[tl]) / 2;
	            }
	            else if (this._textFormat.align == "justify") {
	            }
	            else if (this._textFormat.align == "right") {
	                x_offset = (this._textWidth - tl_width[tl]) - (2 + this._textFormat.rightMargin);
	            }
	            tl_startx[tl] = [];
	            this.textHeight = 0;
	            for (var c = 0; c < tl_char_codes[tl].length; c++) {
	                this.textHeight += tl_height[tl];
	                tl_startx[tl][c] = x_offset;
	                x_offset += tl_char_widths[tl][c] + this._textFormat.letterSpacing;
	                // if this is a whitespace, we add the justify additional spacer
	                if (tl_char_codes[tl][c] == 32) {
	                    x_offset += justify_addion;
	                }
	            }
	        }
	        if (this._textFormat.font_table.assetType == BitmapFontTable_1.BitmapFontTable.assetType) {
	            //console.log("contruct bitmap text = "+this._text);
	            var bitmap_fontTable = this._textFormat.font_table;
	            var vertices = new Float32Array(numVertices * 7);
	            var vertices2 = new Float32Array(numVertices2 * 7);
	            var vert_cnt = 0;
	            var vert_cnt2 = 0;
	            var y_offset = 2; //2+(tess_fontTable.ascent-tess_fontTable.get_font_em_size())*char_scale;
	            for (tl = 0; tl < tl_width.length; tl++) {
	                y_offset += tl_height[tl];
	                for (var c = 0; c < tl_char_codes[tl].length; c++) {
	                    if (tl_char_codes[tl][c] == 32) {
	                        continue;
	                    }
	                    if (tl_formatIdx[tl][c] < 0) {
	                        continue;
	                    }
	                    var char_data;
	                    if (tl_formatIdx[tl][c] == 0) {
	                        char_data = bitmap_fontTable.getCharData(tl_char_codes[tl][c].toString());
	                        vertices[vert_cnt++] = tl_startx[tl][c] + char_data[4];
	                        vertices[vert_cnt++] = y_offset - activeFormat.font_table.getLineHeight() + char_data[5];
	                        vertices[vert_cnt++] = char_data[0];
	                        vertices[vert_cnt++] = char_data[1];
	                        vertices[vert_cnt++] = tl_startx[tl][c] + char_data[4] + char_data[7];
	                        vertices[vert_cnt++] = y_offset - activeFormat.font_table.getLineHeight() + char_data[5];
	                        vertices[vert_cnt++] = char_data[0] + char_data[2];
	                        vertices[vert_cnt++] = char_data[1];
	                        vertices[vert_cnt++] = tl_startx[tl][c] + char_data[4] + char_data[7];
	                        vertices[vert_cnt++] = y_offset - activeFormat.font_table.getLineHeight() + char_data[5] + char_data[6];
	                        vertices[vert_cnt++] = char_data[0] + char_data[2];
	                        vertices[vert_cnt++] = char_data[1] + char_data[3];
	                        vertices[vert_cnt++] = tl_startx[tl][c] + char_data[4] + char_data[7];
	                        vertices[vert_cnt++] = y_offset - activeFormat.font_table.getLineHeight() + char_data[5] + char_data[6];
	                        vertices[vert_cnt++] = char_data[0] + char_data[2];
	                        vertices[vert_cnt++] = char_data[1] + char_data[3];
	                        vertices[vert_cnt++] = tl_startx[tl][c] + char_data[4];
	                        vertices[vert_cnt++] = y_offset - activeFormat.font_table.getLineHeight() + char_data[5] + char_data[6];
	                        vertices[vert_cnt++] = char_data[0];
	                        vertices[vert_cnt++] = char_data[1] + char_data[3];
	                        vertices[vert_cnt++] = tl_startx[tl][c] + char_data[4];
	                        vertices[vert_cnt++] = y_offset - activeFormat.font_table.getLineHeight() + char_data[5];
	                        vertices[vert_cnt++] = char_data[0];
	                        vertices[vert_cnt++] = char_data[1];
	                    }
	                    if (tl_formatIdx[tl][c] == 1) {
	                        char_data = bitmap_fontTable.fallbackTable.getCharData(tl_char_codes[tl][c].toString());
	                        vertices2[vert_cnt2++] = tl_startx[tl][c] + char_data[4];
	                        vertices2[vert_cnt2++] = y_offset - activeFormat.font_table.fallbackTable.getLineHeight() + char_data[5];
	                        vertices2[vert_cnt2++] = char_data[0];
	                        vertices2[vert_cnt2++] = char_data[1];
	                        vertices2[vert_cnt2++] = tl_startx[tl][c] + tl_char_widths[tl][c] + char_data[4];
	                        vertices2[vert_cnt2++] = y_offset - activeFormat.font_table.fallbackTable.getLineHeight() + char_data[5];
	                        vertices2[vert_cnt2++] = char_data[0] + char_data[2];
	                        vertices2[vert_cnt2++] = char_data[1];
	                        vertices2[vert_cnt2++] = tl_startx[tl][c] + tl_char_widths[tl][c] + char_data[4];
	                        vertices2[vert_cnt2++] = y_offset;
	                        vertices2[vert_cnt2++] = char_data[0] + char_data[2];
	                        vertices2[vert_cnt2++] = char_data[1] + char_data[3];
	                        vertices2[vert_cnt2++] = tl_startx[tl][c] + tl_char_widths[tl][c] + char_data[4];
	                        vertices2[vert_cnt2++] = y_offset;
	                        vertices2[vert_cnt2++] = char_data[0] + char_data[2];
	                        vertices2[vert_cnt2++] = char_data[1] + char_data[3];
	                        vertices2[vert_cnt2++] = tl_startx[tl][c] + char_data[4];
	                        vertices2[vert_cnt2++] = y_offset;
	                        vertices2[vert_cnt2++] = char_data[0];
	                        vertices2[vert_cnt2++] = char_data[1] + char_data[3];
	                        vertices2[vert_cnt2++] = tl_startx[tl][c] + char_data[4];
	                        vertices2[vert_cnt2++] = y_offset - activeFormat.font_table.fallbackTable.getLineHeight() + char_data[5];
	                        vertices2[vert_cnt2++] = char_data[0];
	                        vertices2[vert_cnt2++] = char_data[1];
	                    }
	                }
	                y_offset += this._textFormat.leading;
	            }
	            if (vert_cnt > 0) {
	                var attributesView = new AttributesView_1.AttributesView(Float32Array, 4);
	                attributesView.set(vertices);
	                var vertexBuffer = attributesView.attributesBuffer;
	                attributesView.dispose();
	                this._textElements = new TriangleElements_1.TriangleElements(vertexBuffer);
	                this._textElements.setPositions(new Float2Attributes_1.Float2Attributes(vertexBuffer));
	                this._textElements.setUVs(new Float2Attributes_1.Float2Attributes(vertexBuffer));
	                this._textGraphic = this._graphics.addGraphic(this._textElements);
	                this._textGraphic.material = bitmap_fontTable.getMaterial();
	            }
	            if (vert_cnt2 > 0) {
	                var attributesView2 = new AttributesView_1.AttributesView(Float32Array, 4);
	                attributesView2.set(vertices2);
	                var vertexBuffer2 = attributesView2.attributesBuffer;
	                attributesView2.dispose();
	                this._textElements2 = new TriangleElements_1.TriangleElements(vertexBuffer2);
	                this._textElements2.setPositions(new Float2Attributes_1.Float2Attributes(vertexBuffer2));
	                this._textElements2.setUVs(new Float2Attributes_1.Float2Attributes(vertexBuffer2));
	                this._textGraphic2 = this._graphics.addGraphic(this._textElements2);
	                this._textGraphic2.material = bitmap_fontTable.fallbackTable.getMaterial();
	            }
	            var new_ct = this.transform.colorTransform || (this.transform.colorTransform = new ColorTransform_1.ColorTransform());
	            this.transform.colorTransform.color = activeFormat.color;
	            this.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM);
	        }
	        //todo: render tesselated fonts
	        /*
	         var numVertices:number = 0;
	         var elements:TriangleElements;
	         var char_vertices:AttributesBuffer;
	         var thisFormat:TesselatedFontTable=<TesselatedFontTable>this._textFormat.font_table;
	
	         var fallbackFormat:TesselatedFontTable=null;
	         if (this._textFormat.fallback_font_table)
	         fallbackFormat = <TesselatedFontTable>this._textFormat.fallback_font_table;
	
	
	         var char_scale:number=this._textFormat.size/thisFormat.get_font_em_size();
	         var y_offset:number=0;
	         var prev_char:TesselatedFontChar = null;
	         var j:number = 0;
	         var k:number = 0;
	         var whitespace_width=(thisFormat.get_whitespace_width() * char_scale)+this._textFormat.letterSpacing;
	         var textlines:Array<string> = this.text.toString().split("\\n");
	         var final_lines_chars:Array<Array<TesselatedFontChar>> = [];
	         var final_lines_char_scale:Array<Array<number>> = [];
	         var final_lines_width:Array<number> = [];
	         var final_lines_justify_bool:Array<boolean> = [];
	         var final_isParagraph:Array<boolean> = [];
	         var final_lines_justify:Array<number> = [];
	         var maxlineWidth:number;
	         for (var tl = 0; tl < textlines.length; tl++) {
	
	         maxlineWidth=this.textWidth - (4 + this._textFormat.leftMargin + this._textFormat.rightMargin + this._textFormat.indent);
	         final_lines_chars.push([]);
	         final_lines_char_scale.push([]);
	         final_lines_width.push(0);
	         final_lines_justify.push(0);
	         final_lines_justify_bool.push(false);
	         final_isParagraph.push(true);
	
	
	         var words:Array<string> = textlines[tl].split(" ");
	         for (var i = 0; i < words.length; i++) {
	         var word_width:number = 0;
	         var word_chars:Array<TesselatedFontChar> = [];
	         var word_chars_scale:Array<number> = [];
	         var c_cnt:number = 0;
	         for (var w = 0; w < words[i].length; w++) {
	         char_scale = this._textFormat.size / thisFormat.get_font_em_size();
	         var this_char:TesselatedFontChar = <TesselatedFontChar> thisFormat.getChar(words[i].charCodeAt(w).toString());
	         if (this_char == null) {
	         if (fallbackFormat) {
	         char_scale = this._textFormat.size / fallbackFormat.get_font_em_size();
	         this_char = fallbackFormat.getChar(words[i].charCodeAt(w).toString());
	         }
	         }
	         if (this_char != null) {
	         char_vertices = this_char.fill_data;
	         if (char_vertices != null) {
	         numVertices += char_vertices.count;
	         // find kerning value that has been set for this char_code on previous char (if non exists, kerning_value will stay 0)
	         var kerning_value:number = 0;
	         if (prev_char != null) {
	         for (var k:number = 0; k < prev_char.kerningCharCodes.length; k++) {
	         if (prev_char.kerningCharCodes[k] == words[i].charCodeAt(w)) {
	         kerning_value = prev_char.kerningValues[k];
	         break;
	         }
	         }
	         }
	         word_width += ((2 + this_char.char_width + kerning_value) * char_scale) + this._textFormat.letterSpacing;
	         }
	         else {
	         // if no char-elements was found, we insert a "space"
	         word_width += whitespace_width;
	         }
	         }
	         else {
	         // if no char-elements was found, we insert a "space"
	         //x_offset += thisFormat.get_font_em_size() * char_scale;
	         word_width += whitespace_width;
	         }
	         word_chars_scale[c_cnt] = char_scale;
	         word_chars[c_cnt++] = this_char;
	         }
	
	         if (((final_lines_width[final_lines_width.length - 1] + word_width) <= maxlineWidth)||(final_lines_chars[final_lines_chars.length - 1].length==0)) {
	         // if line can hold this word without breaking the bounds, we can just add all chars
	         for (var fw:number = 0; fw < word_chars_scale.length; fw++) {
	         final_lines_chars[final_lines_chars.length - 1].push(word_chars[fw]);
	         final_lines_char_scale[final_lines_char_scale.length - 1].push(word_chars_scale[fw]);
	         }
	         final_lines_width[final_lines_width.length - 1] += word_width;
	         }
	         else {
	         // word does not fit
	         // todo respect autowrapping properties.
	         // right now we just pretend everything has autowrapping and multiline
	         if(final_lines_chars[final_lines_chars.length - 1][final_lines_chars[final_lines_chars.length - 1].length-1]==null){
	         final_lines_chars[final_lines_chars.length - 1].pop();
	         final_lines_char_scale[final_lines_char_scale.length - 1].pop();
	         final_lines_width[final_lines_width.length - 1] -= whitespace_width;
	         final_lines_justify[final_lines_justify.length - 1]-=1;
	         }
	         final_lines_justify_bool[final_lines_justify_bool.length - 1]=true;
	         final_lines_chars.push([]);
	         final_lines_char_scale.push([]);
	         final_lines_width.push(0);
	         final_lines_justify.push(0);
	         final_lines_justify_bool.push(false);
	         final_isParagraph.push(false);
	         for (var fw:number = 0; fw < word_chars_scale.length; fw++) {
	         final_lines_chars[final_lines_chars.length - 1].push(word_chars[fw]);
	         final_lines_char_scale[final_lines_char_scale.length - 1].push(word_chars_scale[fw]);
	         }
	         final_lines_width[final_lines_width.length - 1] = word_width;
	         maxlineWidth=this.textWidth - (4 + this._textFormat.leftMargin + this._textFormat.rightMargin);
	         }
	         if (i < (words.length - 1)) {
	         if ((final_lines_width[final_lines_width.length - 1]) <= maxlineWidth) {
	         final_lines_chars[final_lines_chars.length - 1].push(null);
	         final_lines_char_scale[final_lines_char_scale.length - 1].push(char_scale);
	         final_lines_width[final_lines_width.length - 1] += whitespace_width;
	         final_lines_justify[final_lines_justify.length - 1]+=1;
	         }
	         }
	         }
	         }
	
	         y_offset=2+(thisFormat.ascent-thisFormat.get_font_em_size())*char_scale;
	
	         var vertices:Float32Array = new Float32Array(numVertices*3);
	
	         for (var i = 0; i < final_lines_chars.length; i++) {
	
	         var intent:number=0;
	         if(final_isParagraph[i]){intent=this._textFormat.indent;}
	         maxlineWidth=this.textWidth - (4 + this._textFormat.leftMargin + this._textFormat.rightMargin + intent);
	         var x_offset:number= 2 + this._textFormat.leftMargin + intent;
	         var justify_addion:number=0;
	         if(this._textFormat.align=="center"){
	         x_offset=2 + this._textFormat.leftMargin + intent+(maxlineWidth-final_lines_width[i])/2;
	         }
	         else if(this._textFormat.align=="justify"){
	         if(final_lines_justify_bool[i]){
	         justify_addion=((maxlineWidth)-final_lines_width[i])/final_lines_justify[i];
	         }
	         }
	         else if(this._textFormat.align=="right"){
	         x_offset=(this._textWidth-final_lines_width[i])-(2 + this._textFormat.rightMargin);
	         }
	         //console.log("this._textFormat.align="+this._textFormat.align);
	         //console.log("this._width="+this._width);
	         for (var t = 0; t < final_lines_chars[i].length; t++) {
	         var this_char:TesselatedFontChar = final_lines_chars[i][t];
	         char_scale = final_lines_char_scale[i][t];
	         if (this_char != null) {
	         char_vertices = this_char.fill_data;
	         if (char_vertices != null) {
	         var buffer:Float32Array = new Float32Array(char_vertices.buffer);
	         for (var v:number = 0; v < char_vertices.count; v++) {
	         vertices[j++] = buffer[v*3]*char_scale + x_offset;
	         vertices[j++] = buffer[v*3 + 1]*char_scale + y_offset;
	         vertices[j++] = buffer[v*3 + 2];
	         }
	         // find kerning value that has been set for this char_code on previous char (if non exists, kerning_value will stay 0)
	         var kerning_value:number = 0;
	         if (prev_char != null) {
	         for (var k:number = 0; k < prev_char.kerningCharCodes.length; k++) {
	         if (prev_char.kerningCharCodes[k] == this._text.charCodeAt(i)) {
	         kerning_value = prev_char.kerningValues[k];
	         break;
	         }
	         }
	         }
	         x_offset += ((this_char.char_width + kerning_value) * char_scale) + this._textFormat.letterSpacing;
	
	         }
	         else {
	         // if no char-elements was found, we insert a "space"
	         x_offset+=whitespace_width+justify_addion;
	         }
	         }
	         else{
	         x_offset+=whitespace_width+justify_addion;
	         }
	         }
	         // hack for multiline textfield in icycle.
	
	         y_offset+=(thisFormat.ascent + thisFormat.descent)*char_scale;
	         //y_offset+=(thisFormat.get_font_em_size()-thisFormat.descent)*char_scale;
	         y_offset+= this._textFormat.leading;
	
	
	         }
	
	
	
	         var attributesView:AttributesView = new AttributesView(Float32Array, 3);
	         attributesView.set(vertices);
	         var vertexBuffer:AttributesBuffer = attributesView.attributesBuffer;
	         attributesView.dispose();
	
	         this._textElements = new TriangleElements(vertexBuffer);
	         this._textElements.setPositions(new Float2Attributes(vertexBuffer));
	         this._textElements.setCustomAttributes("curves", new Byte4Attributes(vertexBuffer, false));
	
	         this._textGraphic = this._graphics.addGraphic(this._textElements);
	
	         var sampler:Sampler2D = new Sampler2D();
	         this._textGraphic.style = new Style();
	         if(this._textFormat.material){
	         this._textGraphic.material = this._textFormat.material;
	         this._textGraphic.style.addSamplerAt(sampler, this._textGraphic.material.getTextureAt(0));
	         this._textGraphic.material.animateUVs = true;
	         this._textGraphic.style.uvMatrix = new Matrix(0,0,0,0, this._textFormat.uv_values[0], this._textFormat.uv_values[1]);
	         }
	         else{
	
	         this._textGraphic.material = DefaultMaterialManager.getDefaultMaterial();
	         this._textGraphic.material.bothSides = true;
	         //this._textGraphic.material.useColorTransform = true;
	         this._textGraphic.material.curves = true;
	         this._textGraphic.style.addSamplerAt(sampler, this._textGraphic.material.getTextureAt(0));
	         //sampler.imageRect = new Rectangle(0, 0, 0.5, 0.5);
	         this._textGraphic.style.uvMatrix = new Matrix(0, 0, 0, 0, 0.126, 0);
	         this._textGraphic.material.animateUVs = true;
	         //graphic.material.imageRect = true;
	         }
	         this.material=this._textGraphic.material;
	         */
	    };
	    /**
	     * Appends the string specified by the <code>newText</code> parameter to the
	     * end of the text of the text field. This method is more efficient than an
	     * addition assignment(<code>+=</code>) on a <code>text</code> property
	     * (such as <code>someTextField.text += moreText</code>), particularly for a
	     * text field that contains a significant amount of content.
	     *
	     * @param newText The string to append to the existing text.
	     */
	    TextField.prototype.appendText = function (newText) {
	        this._text += newText;
	    };
	    /**
	     * *tells the Textfield that a paragraph is defined completly.
	     * e.g. the textfield will start a new line for future added text.
	     */
	    TextField.prototype.closeParagraph = function () {
	        //TODO
	    };
	    /**
	     * Returns a rectangle that is the bounding box of the character.
	     *
	     * @param charIndex The zero-based index value for the character(for
	     *                  example, the first position is 0, the second position is
	     *                  1, and so on).
	     * @return A rectangle with <code>x</code> and <code>y</code> minimum and
	     *         maximum values defining the bounding box of the character.
	     */
	    TextField.prototype.getCharBoundaries = function (charIndex) {
	        return this._charBoundaries;
	    };
	    /**
	     * Returns the zero-based index value of the character at the point specified
	     * by the <code>x</code> and <code>y</code> parameters.
	     *
	     * @param x The <i>x</i> coordinate of the character.
	     * @param y The <i>y</i> coordinate of the character.
	     * @return The zero-based index value of the character(for example, the
	     *         first position is 0, the second position is 1, and so on). Returns
	     *         -1 if the point is not over any character.
	     */
	    TextField.prototype.getCharIndexAtPoint = function (x, y) {
	        return this._charIndexAtPoint;
	    };
	    /**
	     * Given a character index, returns the index of the first character in the
	     * same paragraph.
	     *
	     * @param charIndex The zero-based index value of the character(for example,
	     *                  the first character is 0, the second character is 1, and
	     *                  so on).
	     * @return The zero-based index value of the first character in the same
	     *         paragraph.
	     * @throws RangeError The character index specified is out of range.
	     */
	    TextField.prototype.getFirstCharInParagraph = function (charIndex /*int*/) {
	        return this._firstCharInParagraph;
	    };
	    /**
	     * Returns a DisplayObject reference for the given <code>id</code>, for an
	     * image or SWF file that has been added to an HTML-formatted text field by
	     * using an <code><img></code> tag. The <code><img></code> tag is in the
	     * following format:
	     *
	     * <p><pre xml:space="preserve"><code> <img src = 'filename.jpg' id =
	     * 'instanceName' ></code></pre></p>
	     *
	     * @param id The <code>id</code> to match(in the <code>id</code> attribute
	     *           of the <code><img></code> tag).
	     * @return The display object corresponding to the image or SWF file with the
	     *         matching <code>id</code> attribute in the <code><img></code> tag
	     *         of the text field. For media loaded from an external source, this
	     *         object is a Loader object, and, once loaded, the media object is a
	     *         child of that Loader object. For media embedded in the SWF file,
	     *         it is the loaded object. If no <code><img></code> tag with the
	     *         matching <code>id</code> exists, the method returns
	     *         <code>null</code>.
	     */
	    TextField.prototype.getImageReference = function (id) {
	        return this._imageReference;
	    };
	    /**
	     * Returns the zero-based index value of the line at the point specified by
	     * the <code>x</code> and <code>y</code> parameters.
	     *
	     * @param x The <i>x</i> coordinate of the line.
	     * @param y The <i>y</i> coordinate of the line.
	     * @return The zero-based index value of the line(for example, the first
	     *         line is 0, the second line is 1, and so on). Returns -1 if the
	     *         point is not over any line.
	     */
	    TextField.prototype.getLineIndexAtPoint = function (x, y) {
	        return this._lineIndexAtPoint;
	    };
	    /**
	     * Returns the zero-based index value of the line containing the character
	     * specified by the <code>charIndex</code> parameter.
	     *
	     * @param charIndex The zero-based index value of the character(for example,
	     *                  the first character is 0, the second character is 1, and
	     *                  so on).
	     * @return The zero-based index value of the line.
	     * @throws RangeError The character index specified is out of range.
	     */
	    TextField.prototype.getLineIndexOfChar = function (charIndex /*int*/) {
	        return this._lineIndexOfChar;
	    };
	    /**
	     * Returns the number of characters in a specific text line.
	     *
	     * @param lineIndex The line number for which you want the length.
	     * @return The number of characters in the line.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineLength = function (lineIndex /*int*/) {
	        return this._lineLength;
	    };
	    /**
	     * Returns metrics information about a given text line.
	     *
	     * @param lineIndex The line number for which you want metrics information.
	     * @return A TextLineMetrics object.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineMetrics = function (lineIndex /*int*/) {
	        return this._lineMetrics;
	    };
	    /**
	     * Returns the character index of the first character in the line that the
	     * <code>lineIndex</code> parameter specifies.
	     *
	     * @param lineIndex The zero-based index value of the line(for example, the
	     *                  first line is 0, the second line is 1, and so on).
	     * @return The zero-based index value of the first character in the line.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineOffset = function (lineIndex /*int*/) {
	        return this._lineOffset;
	    };
	    /**
	     * Returns the text of the line specified by the <code>lineIndex</code>
	     * parameter.
	     *
	     * @param lineIndex The zero-based index value of the line(for example, the
	     *                  first line is 0, the second line is 1, and so on).
	     * @return The text string contained in the specified line.
	     * @throws RangeError The line number specified is out of range.
	     */
	    TextField.prototype.getLineText = function (lineIndex /*int*/) {
	        return this._lineText;
	    };
	    /**
	     * Given a character index, returns the length of the paragraph containing
	     * the given character. The length is relative to the first character in the
	     * paragraph(as returned by <code>getFirstCharInParagraph()</code>), not to
	     * the character index passed in.
	     *
	     * @param charIndex The zero-based index value of the character(for example,
	     *                  the first character is 0, the second character is 1, and
	     *                  so on).
	     * @return Returns the number of characters in the paragraph.
	     * @throws RangeError The character index specified is out of range.
	     */
	    TextField.prototype.getParagraphLength = function (charIndex /*int*/) {
	        return this._paragraphLength;
	    };
	    /**
	     * Returns a TextFormat object that contains formatting information for the
	     * range of text that the <code>beginIndex</code> and <code>endIndex</code>
	     * parameters specify. Only properties that are common to the entire text
	     * specified are set in the resulting TextFormat object. Any property that is
	     * <i>mixed</i>, meaning that it has different values at different points in
	     * the text, has a value of <code>null</code>.
	     *
	     * <p>If you do not specify values for these parameters, this method is
	     * applied to all the text in the text field. </p>
	     *
	     * <p>The following table describes three possible usages:</p>
	     *
	     * @return The TextFormat object that represents the formatting properties
	     *         for the specified text.
	     * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
	     *                    specified is out of range.
	     */
	    TextField.prototype.getTextFormat = function (beginIndex, endIndex) {
	        if (beginIndex === void 0) { beginIndex = -1; }
	        if (endIndex === void 0) { endIndex = -1; }
	        return this._textFormat;
	    };
	    /**
	     * Replaces the current selection with the contents of the <code>value</code>
	     * parameter. The text is inserted at the position of the current selection,
	     * using the current default character format and default paragraph format.
	     * The text is not treated as HTML.
	     *
	     * <p>You can use the <code>replaceSelectedText()</code> method to insert and
	     * delete text without disrupting the character and paragraph formatting of
	     * the rest of the text.</p>
	     *
	     * <p><b>Note:</b> This method does not work if a style sheet is applied to
	     * the text field.</p>
	     *
	     * @param value The string to replace the currently selected text.
	     * @throws Error This method cannot be used on a text field with a style
	     *               sheet.
	     */
	    TextField.prototype.replaceSelectedText = function (value) {
	    };
	    /**
	     * Replaces the range of characters that the <code>beginIndex</code> and
	     * <code>endIndex</code> parameters specify with the contents of the
	     * <code>newText</code> parameter. As designed, the text from
	     * <code>beginIndex</code> to <code>endIndex-1</code> is replaced.
	     *
	     * <p><b>Note:</b> This method does not work if a style sheet is applied to
	     * the text field.</p>
	     *
	     * @param beginIndex The zero-based index value for the start position of the
	     *                   replacement range.
	     * @param endIndex   The zero-based index position of the first character
	     *                   after the desired text span.
	     * @param newText    The text to use to replace the specified range of
	     *                   characters.
	     * @throws Error This method cannot be used on a text field with a style
	     *               sheet.
	     */
	    TextField.prototype.replaceText = function (beginIndex /*int*/, endIndex /*int*/, newText) {
	    };
	    /**
	     * Sets as selected the text designated by the index values of the first and
	     * last characters, which are specified with the <code>beginIndex</code> and
	     * <code>endIndex</code> parameters. If the two parameter values are the
	     * same, this method sets the insertion point, as if you set the
	     * <code>caretIndex</code> property.
	     *
	     * @param beginIndex The zero-based index value of the first character in the
	     *                   selection(for example, the first character is 0, the
	     *                   second character is 1, and so on).
	     * @param endIndex   The zero-based index value of the last character in the
	     *                   selection.
	     */
	    TextField.prototype.setSelection = function (beginIndex /*int*/, endIndex /*int*/) {
	    };
	    /**
	     * Applies the text formatting that the <code>format</code> parameter
	     * specifies to the specified text in a text field. The value of
	     * <code>format</code> must be a TextFormat object that specifies the desired
	     * text formatting changes. Only the non-null properties of
	     * <code>format</code> are applied to the text field. Any property of
	     * <code>format</code> that is set to <code>null</code> is not applied. By
	     * default, all of the properties of a newly created TextFormat object are
	     * set to <code>null</code>.
	     *
	     * <p><b>Note:</b> This method does not work if a style sheet is applied to
	     * the text field.</p>
	     *
	     * <p>The <code>setTextFormat()</code> method changes the text formatting
	     * applied to a range of characters or to the entire body of text in a text
	     * field. To apply the properties of format to all text in the text field, do
	     * not specify values for <code>beginIndex</code> and <code>endIndex</code>.
	     * To apply the properties of the format to a range of text, specify values
	     * for the <code>beginIndex</code> and the <code>endIndex</code> parameters.
	     * You can use the <code>length</code> property to determine the index
	     * values.</p>
	     *
	     * <p>The two types of formatting information in a TextFormat object are
	     * character level formatting and paragraph level formatting. Each character
	     * in a text field can have its own character formatting settings, such as
	     * font name, font size, bold, and italic.</p>
	     *
	     * <p>For paragraphs, the first character of the paragraph is examined for
	     * the paragraph formatting settings for the entire paragraph. Examples of
	     * paragraph formatting settings are left margin, right margin, and
	     * indentation.</p>
	     *
	     * <p>Any text inserted manually by the user, or replaced by the
	     * <code>replaceSelectedText()</code> method, receives the default text field
	     * formatting for new text, and not the formatting specified for the text
	     * insertion point. To set the default formatting for new text, use
	     * <code>defaultTextFormat</code>.</p>
	     *
	     * @param format A TextFormat object that contains character and paragraph
	     *               formatting information.
	     * @throws Error      This method cannot be used on a text field with a style
	     *                    sheet.
	     * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
	     *                    specified is out of range.
	     */
	    TextField.prototype.setTextFormat = function (format, beginIndex, endIndex) {
	        if (beginIndex === void 0) { beginIndex = -1; }
	        if (endIndex === void 0) { endIndex = -1; }
	    };
	    /**
	     * Returns true if an embedded font is available with the specified
	     * <code>fontName</code> and <code>fontStyle</code> where
	     * <code>Font.fontType</code> is <code>flash.text.FontType.EMBEDDED</code>.
	     * Starting with Flash Player 10, two kinds of embedded fonts can appear in a
	     * SWF file. Normal embedded fonts are only used with TextField objects. CFF
	     * embedded fonts are only used with the flash.text.engine classes. The two
	     * types are distinguished by the <code>fontType</code> property of the
	     * <code>Font</code> class, as returned by the <code>enumerateFonts()</code>
	     * function.
	     *
	     * <p>TextField cannot use a font of type <code>EMBEDDED_CFF</code>. If
	     * <code>embedFonts</code> is set to <code>true</code> and the only font
	     * available at run time with the specified name and style is of type
	     * <code>EMBEDDED_CFF</code>, Flash Player fails to render the text, as if no
	     * embedded font were available with the specified name and style.</p>
	     *
	     * <p>If both <code>EMBEDDED</code> and <code>EMBEDDED_CFF</code> fonts are
	     * available with the same name and style, the <code>EMBEDDED</code> font is
	     * selected and text renders with the <code>EMBEDDED</code> font.</p>
	     *
	     * @param fontName  The name of the embedded font to check.
	     * @param fontStyle Specifies the font style to check. Use
	     *                  <code>flash.text.FontStyle</code>
	     * @return <code>true</code> if a compatible embedded font is available,
	     *         otherwise <code>false</code>.
	     * @throws ArgumentError The <code>fontStyle</code> specified is not a member
	     *                       of <code>flash.text.FontStyle</code>.
	     */
	    TextField.isFontCompatible = function (fontName, fontStyle) {
	        return false;
	    };
	    TextField.prototype.clone = function () {
	        var newInstance = (TextField._textFields.length) ? TextField._textFields.pop() : new TextField();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    TextField.prototype.copyTo = function (newInstance) {
	        _super.prototype.copyTo.call(this, newInstance);
	        newInstance.textWidth = this._textWidth;
	        newInstance.textHeight = this._textHeight;
	        newInstance.textFormat = this._textFormat;
	        //newInstance.textColor = this._textColor;
	        newInstance.text = this._text;
	    };
	    TextField._textFields = [];
	    TextField.assetType = "[asset TextField]";
	    return TextField;
	}(Sprite_1.Sprite));
	exports.TextField = TextField;


/***/ },
/* 192 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextFieldType class is an enumeration of constant values used in setting the
	 * <code>type</code> property of the TextField class.
	 *
	 * @see away.entities.TextField#type
	 */
	var TextFieldType = (function () {
	    function TextFieldType() {
	    }
	    /**
	     * Used to specify a <code>dynamic</code> TextField.
	     */
	    TextFieldType.DYNAMIC = "dynamic";
	    /**
	     * Used to specify an <code>input</code> TextField.
	     */
	    TextFieldType.INPUT = "input";
	    /**
	     * Used to specify an <code>static</code> TextField.
	     */
	    TextFieldType.STATIC = "input";
	    return TextFieldType;
	}());
	exports.TextFieldType = TextFieldType;


/***/ },
/* 193 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var BitmapFontChar_1 = __webpack_require__(194);
	/**
	 * GraphicBase wraps a TriangleElements as a scene graph instantiation. A GraphicBase is owned by a Sprite object.
	 *
	 *
	 * @see away.base.TriangleElements
	 * @see away.entities.Sprite
	 *
	 * @class away.base.GraphicBase
	 */
	var BitmapFontTable = (function (_super) {
	    __extends(BitmapFontTable, _super);
	    //TODO test shader picking
	    //		public get shaderPickingDetails():boolean
	    //		{
	    //
	    //			return this.sourceEntity.shaderPickingDetails;
	    //		}
	    /**
	     * Creates a new TesselatedFont object
	     */
	    function BitmapFontTable() {
	        _super.call(this);
	        this._font_chars = [];
	        this._materials = [];
	        this._font_chars_dic = new Object();
	        this._ascent = 0;
	        this._descent = 0;
	        this._current_size = 0;
	        this._size_multiply = 0;
	        this._init_size = 0;
	        this._texture_width = 0;
	        this._texture_height = 0;
	        this._adjust_size = 0;
	    }
	    Object.defineProperty(BitmapFontTable.prototype, "assetType", {
	        get: function () {
	            return BitmapFontTable.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BitmapFontTable.prototype.initFontSize = function (font_size) {
	        if (this.fallbackTable)
	            this.fallbackTable.initFontSize(font_size);
	        if (this._adjust_size)
	            font_size *= this._adjust_size;
	        if (this._current_size == font_size)
	            return;
	        this._current_size = font_size;
	        this._size_multiply = font_size / this._init_size;
	    };
	    BitmapFontTable.prototype.getCharDataCanvas = function (char_code) {
	        var this_char = this._font_chars_dic[char_code];
	        if (this_char) {
	            //console.log("this_char found");
	            return [this_char.x, this_char.y, this_char.width, this_char.height, this_char.x_offset * this._size_multiply, this_char.y_offset * this._size_multiply];
	        }
	        //console.log("this_char not found" + char_code);
	        return [];
	    };
	    BitmapFontTable.prototype.getCharData = function (char_code) {
	        var this_char = this._font_chars_dic[char_code];
	        if (this_char) {
	            var realheight = (this_char.height / this._init_size) * this._current_size;
	            var realWidth = (this_char.width / this._init_size) * this._current_size;
	            //console.log("this_char found");
	            return [this_char.x / this._texture_width, this_char.y / this._texture_height, this_char.width / this._texture_width, this_char.height / this._texture_height, this_char.x_offset * this._size_multiply, this_char.y_offset * this._size_multiply, realheight, realWidth];
	        }
	        //console.log("this_char not found" + char_code);
	        return [];
	    };
	    BitmapFontTable.prototype.getCharVertCnt = function (char_code) {
	        return 6 * 4;
	    };
	    Object.defineProperty(BitmapFontTable.prototype, "texture_width", {
	        get: function () {
	            return this._texture_width;
	        },
	        set: function (value) {
	            this._texture_width = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapFontTable.prototype, "texture_height", {
	        get: function () {
	            return this._texture_height;
	        },
	        set: function (value) {
	            this._texture_height = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BitmapFontTable.prototype.hasChar = function (char_code) {
	        return this._font_chars_dic[char_code] != null;
	    };
	    BitmapFontTable.prototype.getCharWidth = function (char_code) {
	        var this_char = this._font_chars_dic[char_code];
	        if (this_char)
	            return this._size_multiply * (this_char.x_advance);
	        return 0;
	    };
	    BitmapFontTable.prototype.getLineHeight = function () {
	        return this._current_size;
	    };
	    /**
	     *
	     */
	    BitmapFontTable.prototype.dispose = function () {
	    };
	    BitmapFontTable.prototype.addMaterial = function (material) {
	        this._materials.push(material);
	    };
	    BitmapFontTable.prototype.getMaterial = function (idx) {
	        if (idx === void 0) { idx = 0; }
	        return this._materials[idx];
	    };
	    Object.defineProperty(BitmapFontTable.prototype, "ascent", {
	        get: function () {
	            return this._ascent;
	        },
	        set: function (value) {
	            this._ascent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapFontTable.prototype, "descent", {
	        get: function () {
	            return this._descent;
	        },
	        set: function (value) {
	            this._descent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapFontTable.prototype, "offset_x", {
	        get: function () {
	            return this._offset_x;
	        },
	        set: function (value) {
	            this._offset_x = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BitmapFontTable.prototype, "offset_y", {
	        get: function () {
	            return this._offset_y;
	        },
	        set: function (value) {
	            this._offset_y = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BitmapFontTable.prototype.get_font_chars = function () {
	        return this._font_chars;
	    };
	    BitmapFontTable.prototype.get_font_em_size = function () {
	        return this._font_em_size;
	    };
	    BitmapFontTable.prototype.set_whitespace_width = function (value) {
	        this._whitespace_width = value;
	    };
	    BitmapFontTable.prototype.get_whitespace_width = function () {
	        return this._whitespace_width;
	    };
	    BitmapFontTable.prototype.set_font_em_size = function (font_em_size) {
	        this._font_em_size = font_em_size;
	    };
	    /**
	     *
	     */
	    BitmapFontTable.prototype.getChar = function (name) {
	        return this._font_chars_dic[name];
	    };
	    /**
	     *
	     */
	    BitmapFontTable.prototype.setChar = function (id, x, y, width, height, xoff, yoff, xadv, page, channel) {
	        var bitmap_font_char = new BitmapFontChar_1.BitmapFontChar(id, x, y, width, height, xoff, yoff, xadv, page, channel);
	        this._font_chars.push(bitmap_font_char);
	        this._font_chars_dic[id] = bitmap_font_char;
	    };
	    BitmapFontTable.assetType = "[asset BitmapFontTable]";
	    return BitmapFontTable;
	}(AssetBase_1.AssetBase));
	exports.BitmapFontTable = BitmapFontTable;


/***/ },
/* 194 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextFormat class represents character formatting information. Use the
	 * TextFormat class to create specific text formatting for text fields. You
	 * can apply text formatting to both static and dynamic text fields. The
	 * properties of the TextFormat class apply to device and embedded fonts.
	 * However, for embedded fonts, bold and italic text actually require specific
	 * fonts. If you want to display bold or italic text with an embedded font,
	 * you need to embed the bold and italic variations of that font.
	 *
	 * <p> You must use the constructor <code>new TextFormat()</code> to create a
	 * TextFormat object before setting its properties. When you apply a
	 * TextFormat object to a text field using the
	 * <code>TextField.defaultTextFormat</code> property or the
	 * <code>TextField.setTextFormat()</code> method, only its defined properties
	 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
	 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
	 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
	 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
	 * by default because if you don't provide values for the properties, Flash
	 * Player uses its own default formatting. The default formatting that Flash
	 * Player uses for each property(if property's value is <code>null</code>) is
	 * as follows:</p>
	 *
	 * <p>The default formatting for each property is also described in each
	 * property description.</p>
	 */
	var BitmapFontChar = (function () {
	    function BitmapFontChar(id, x, y, width, height, xoff, yoff, xadv, page, channel) {
	        this.id = id;
	        this.x = x;
	        this.y = y;
	        this.width = width;
	        this.height = height;
	        this.x_offset = xoff;
	        this.y_offset = yoff;
	        this.x_advance = xadv;
	        this.page = page;
	        this.channel = channel;
	    }
	    return BitmapFontChar;
	}());
	exports.BitmapFontChar = BitmapFontChar;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	/**
	 * A MouseEvent is dispatched when a mouse event occurs over a mouseEnabled object in View.
	 * TODO: we don't have screenZ data, tho this should be easy to implement
	 */
	var MouseEvent = (function (_super) {
	    __extends(MouseEvent, _super);
	    /**
	     * Create a new MouseEvent object.
	     * @param type The type of the MouseEvent.
	     */
	    function MouseEvent(type) {
	        _super.call(this, type);
	        // Private.
	        this._iAllowedToPropagate = true;
	    }
	    Object.defineProperty(MouseEvent.prototype, "bubbles", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            var doesBubble = this._iAllowedToPropagate;
	            this._iAllowedToPropagate = true;
	            // Don't bubble if propagation has been stopped.
	            return doesBubble;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    MouseEvent.prototype.stopPropagation = function () {
	        this._iAllowedToPropagate = false;
	        if (this._iParentEvent)
	            this._iParentEvent.stopPropagation();
	    };
	    /**
	     * @inheritDoc
	     */
	    MouseEvent.prototype.stopImmediatePropagation = function () {
	        this._iAllowedToPropagate = false;
	        if (this._iParentEvent)
	            this._iParentEvent.stopImmediatePropagation();
	    };
	    /**
	     * Creates a copy of the MouseEvent object and sets the value of each property to match that of the original.
	     */
	    MouseEvent.prototype.clone = function () {
	        var result = new MouseEvent(this.type);
	        /* TODO: Debug / test - look into isDefaultPrevented
	         if (isDefaultPrevented())
	         result.preventDefault();
	         */
	        result.screenX = this.screenX;
	        result.screenY = this.screenY;
	        result.view = this.view;
	        result.entity = this.entity;
	        result.renderable = this.renderable;
	        result.material = this.material;
	        result.uv = this.uv;
	        result.position = this.position;
	        result.normal = this.normal;
	        result.elementIndex = this.elementIndex;
	        result.delta = this.delta;
	        result.ctrlKey = this.ctrlKey;
	        result.shiftKey = this.shiftKey;
	        result._iParentEvent = this;
	        result._iAllowedToPropagate = this._iAllowedToPropagate;
	        return result;
	    };
	    Object.defineProperty(MouseEvent.prototype, "scenePosition", {
	        /**
	         * The position in scene space where the event took place
	         */
	        get: function () {
	            return this.entity.sceneTransform.transformVector(this.position);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MouseEvent.prototype, "sceneNormal", {
	        /**
	         * The normal in scene space where the event took place
	         */
	        get: function () {
	            var sceneNormal = this.entity.sceneTransform.deltaTransformVector(this.normal);
	            sceneNormal.normalize();
	            return sceneNormal;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Defines the value of the type property of a mouseOver3d event object.
	     */
	    MouseEvent.MOUSE_OVER = "mouseOver3d";
	    /**
	     * Defines the value of the type property of a mouseOut3d event object.
	     */
	    MouseEvent.MOUSE_OUT = "mouseOut3d";
	    /**
	     * Defines the value of the type property of a mouseUp3d event object.
	     */
	    MouseEvent.MOUSE_UP = "mouseUp3d";
	    /**
	     * Defines the value of the type property of a mouseDown3d event object.
	     */
	    MouseEvent.MOUSE_DOWN = "mouseDown3d";
	    /**
	     * Defines the value of the type property of a mouseMove3d event object.
	     */
	    MouseEvent.MOUSE_MOVE = "mouseMove3d";
	    /**
	     * Defines the value of the type property of a rollOver3d event object.
	     */
	    //		public static ROLL_OVER : string = "rollOver3d";
	    /**
	     * Defines the value of the type property of a rollOut3d event object.
	     */
	    //		public static ROLL_OUT : string = "rollOut3d";
	    /**
	     * Defines the value of the type property of a click3d event object.
	     */
	    MouseEvent.CLICK = "click3d";
	    /**
	     * Defines the value of the type property of a doubleClick3d event object.
	     */
	    MouseEvent.DOUBLE_CLICK = "doubleClick3d";
	    /**
	     * Defines the value of the type property of a mouseWheel3d event object.
	     */
	    MouseEvent.MOUSE_WHEEL = "mouseWheel3d";
	    return MouseEvent;
	}(EventBase_1.EventBase));
	exports.MouseEvent = MouseEvent;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Vector3D_1 = __webpack_require__(34);
	var LightBase_1 = __webpack_require__(150);
	var BoundsType_1 = __webpack_require__(115);
	var CubeMapShadowMapper_1 = __webpack_require__(197);
	var PointLight = (function (_super) {
	    __extends(PointLight, _super);
	    function PointLight() {
	        _super.call(this);
	        this._pRadius = 90000;
	        this._pFallOff = 100000;
	        this._pIsEntity = true;
	        this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
	        //default bounds type
	        this._boundsType = BoundsType_1.BoundsType.SPHERE;
	    }
	    Object.defineProperty(PointLight.prototype, "assetType", {
	        get: function () {
	            return PointLight.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointLight.prototype.pCreateShadowMapper = function () {
	        return new CubeMapShadowMapper_1.CubeMapShadowMapper();
	    };
	    Object.defineProperty(PointLight.prototype, "radius", {
	        get: function () {
	            return this._pRadius;
	        },
	        set: function (value) {
	            this._pRadius = value;
	            if (this._pRadius < 0) {
	                this._pRadius = 0;
	            }
	            else if (this._pRadius > this._pFallOff) {
	                this._pFallOff = this._pRadius;
	                this._pInvalidateBounds();
	            }
	            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointLight.prototype.iFallOffFactor = function () {
	        return this._pFallOffFactor;
	    };
	    Object.defineProperty(PointLight.prototype, "fallOff", {
	        get: function () {
	            return this._pFallOff;
	        },
	        set: function (value) {
	            this._pFallOff = value;
	            if (this._pFallOff < 0)
	                this._pFallOff = 0;
	            if (this._pFallOff < this._pRadius)
	                this._pRadius = this._pFallOff;
	            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
	            this._pInvalidateBounds();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PointLight.prototype._pUpdateSphereBounds = function () {
	        _super.prototype._pUpdateSphereBounds.call(this);
	        this._pSphereBounds.radius = this._pFallOff;
	    };
	    PointLight.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
	        if (target === void 0) { target = null; }
	        var raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        var m = new Matrix3D_1.Matrix3D();
	        // todo: do not use lookAt on Light
	        m.copyFrom(entity.getRenderSceneTransform(cameraTransform));
	        m.append(this._pParent.inverseSceneTransform);
	        this.lookAt(m.position);
	        m.copyFrom(entity.getRenderSceneTransform(cameraTransform));
	        m.append(this.inverseSceneTransform);
	        var box = entity.getBox();
	        var v1 = m.deltaTransformVector(new Vector3D_1.Vector3D(box.left, box.bottom, box.front));
	        var v2 = m.deltaTransformVector(new Vector3D_1.Vector3D(box.right, box.top, box.back));
	        var d1 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
	        var d2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
	        var d = Math.sqrt(d1 > d2 ? d1 : d2);
	        var zMin;
	        var zMax;
	        var z = m.rawData[14];
	        zMin = z - d;
	        zMax = z + d;
	        raw[5] = raw[0] = zMin / d;
	        raw[10] = zMax / (zMax - zMin);
	        raw[11] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[12] = raw[13] = raw[15] = 0;
	        raw[14] = -zMin * raw[10];
	        if (!target)
	            target = new Matrix3D_1.Matrix3D();
	        target.copyRawDataFrom(raw);
	        target.prepend(m);
	        return target;
	    };
	    PointLight.assetType = "[light PointLight]";
	    return PointLight;
	}(LightBase_1.LightBase));
	exports.PointLight = PointLight;


/***/ },
/* 197 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ImageCube_1 = __webpack_require__(124);
	var Camera_1 = __webpack_require__(139);
	var ShadowMapperBase_1 = __webpack_require__(154);
	var SingleCubeTexture_1 = __webpack_require__(132);
	var CubeMapShadowMapper = (function (_super) {
	    __extends(CubeMapShadowMapper, _super);
	    function CubeMapShadowMapper() {
	        _super.call(this);
	        this._pDepthMapSize = 512;
	        this._needsRender = new Array();
	        this.initCameras();
	    }
	    CubeMapShadowMapper.prototype.initCameras = function () {
	        this._depthCameras = new Array();
	        this._projections = new Array();
	        // posX, negX, posY, negY, posZ, negZ
	        this.addCamera(0, 90, 0);
	        this.addCamera(0, -90, 0);
	        this.addCamera(-90, 0, 0);
	        this.addCamera(90, 0, 0);
	        this.addCamera(0, 0, 0);
	        this.addCamera(0, 180, 0);
	    };
	    CubeMapShadowMapper.prototype.addCamera = function (rotationX, rotationY, rotationZ) {
	        var cam = new Camera_1.Camera();
	        cam.rotationX = rotationX;
	        cam.rotationY = rotationY;
	        cam.rotationZ = rotationZ;
	        cam.projection.near = .01;
	        var projection = cam.projection;
	        projection.fieldOfView = 90;
	        this._projections.push(projection);
	        cam.projection._iAspectRatio = 1;
	        this._depthCameras.push(cam);
	    };
	    //@override
	    CubeMapShadowMapper.prototype.pCreateDepthTexture = function () {
	        return new SingleCubeTexture_1.SingleCubeTexture(new ImageCube_1.ImageCube(this._pDepthMapSize));
	    };
	    //@override
	    CubeMapShadowMapper.prototype.pUpdateDepthProjection = function (camera) {
	        var light = (this._pLight);
	        var maxDistance = light._pFallOff;
	        var pos = this._pLight.scenePosition;
	        // todo: faces outside frustum which are pointing away from camera need not be rendered!
	        for (var i = 0; i < 6; ++i) {
	            this._projections[i].far = maxDistance;
	            this._depthCameras[i].transform.moveTo(pos.x, pos.y, pos.z);
	            this._needsRender[i] = true;
	        }
	    };
	    //@override
	    CubeMapShadowMapper.prototype.pDrawDepthMap = function (view, target, renderer) {
	        for (var i = 0; i < 6; ++i)
	            if (this._needsRender[i])
	                renderer._iRender(this._depthCameras[i], view, target.imageCube, null, i);
	    };
	    return CubeMapShadowMapper;
	}(ShadowMapperBase_1.ShadowMapperBase));
	exports.CubeMapShadowMapper = CubeMapShadowMapper;


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var Scene = (function (_super) {
	    __extends(Scene, _super);
	    function Scene() {
	        _super.call(this);
	        this._objects = new Array();
	        this._views = new Array();
	        this._iCollectionMark = 0;
	        this._iIsRoot = true;
	        this._iIsPartition = true;
	        this._pScene = this;
	        this._pPartition = this;
	    }
	    Object.defineProperty(Scene.prototype, "objects", {
	        get: function () {
	            return this._objects;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @internal
	     */
	    Scene.prototype._iRegisterObject = function (displayObject) {
	        this._objects.push(displayObject);
	        var len = this._views.length;
	        for (var i = 0; i < len; i++)
	            this._views[i].registerObject(displayObject);
	    };
	    /**
	     * @internal
	     */
	    Scene.prototype._iUnregisterObject = function (displayObject) {
	        this._objects.splice(this._objects.indexOf(displayObject), 1);
	        var len = this._views.length;
	        for (var i = 0; i < len; i++)
	            this._views[i].unRegisterObject(displayObject);
	    };
	    /**
	     * @internal
	     */
	    Scene.prototype._iRegisterView = function (view) {
	        this._views.push(view);
	        var len = this._objects.length;
	        for (var i = 0; i < len; i++)
	            view.registerObject(this._objects[i]);
	    };
	    /**
	     * @internal
	     */
	    Scene.prototype._iUnregisterView = function (view) {
	        this._views.splice(this._views.indexOf(view), 1);
	        var len = this._objects.length;
	        for (var i = 0; i < len; i++)
	            view.unRegisterObject(this._objects[i]);
	    };
	    return Scene;
	}(DisplayObjectContainer_1.DisplayObjectContainer));
	exports.Scene = Scene;


/***/ },
/* 199 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var Point_1 = __webpack_require__(58);
	var Vector3D_1 = __webpack_require__(34);
	var DisplayObject_1 = __webpack_require__(113);
	var Graphics_1 = __webpack_require__(178);
	/**
	 * This class is used to create lightweight shapes using the ActionScript
	 * drawing application program interface(API). The Shape class includes a
	 * <code>graphics</code> property, which lets you access methods from the
	 * Graphics class.
	 *
	 * <p>The Shape class also includes a <code>graphics</code>property, and it
	 * includes other features not available to the Shape class. For example, a
	 * Shape object is a display object container, whereas a Shape object is not
	 * (and cannot contain child display objects). For this reason, Shape objects
	 * consume less memory than Shape objects that contain the same graphics.
	 * However, a Shape object supports user input events, while a Shape object
	 * does not.</p>
	 */
	var Shape = (function (_super) {
	    __extends(Shape, _super);
	    /**
	     * Create a new Shape object.
	     *
	     * @param material    [optional]        The material with which to render the Shape.
	     */
	    function Shape(material) {
	        var _this = this;
	        if (material === void 0) { material = null; }
	        _super.call(this);
	        //temp point used in hit testing
	        this._tempPoint = new Point_1.Point();
	        this._onGraphicsInvalidateDelegate = function (event) { return _this._onGraphicsInvalidate(event); };
	        this._graphics = new Graphics_1.Graphics(); //unique graphics object for each Sprite
	        this._graphics.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onGraphicsInvalidateDelegate);
	        this.material = material;
	    }
	    Object.defineProperty(Shape.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Shape.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Shape.prototype, "graphics", {
	        /**
	         * Specifies the Graphics object belonging to this Shape object, where
	         * drawing commands can occur.
	         */
	        get: function () {
	            if (this._iSourcePrefab)
	                this._iSourcePrefab._iValidate();
	            return this._graphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Shape.prototype, "animator", {
	        /**
	         * Defines the animator of the graphics object.  Default value is <code>null</code>.
	         */
	        get: function () {
	            return this._graphics.animator;
	        },
	        set: function (value) {
	            if (this._graphics.animator)
	                this._graphics.animator.removeOwner(this);
	            this._graphics.animator = value;
	            if (this._graphics.animator)
	                this._graphics.animator.addOwner(this);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Shape.prototype, "material", {
	        /**
	         * The material with which to render the Shape.
	         */
	        get: function () {
	            return this._graphics.material;
	        },
	        set: function (value) {
	            this._graphics.material = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Shape.prototype, "style", {
	        /**
	         *
	         */
	        get: function () {
	            return this._graphics.style;
	        },
	        set: function (value) {
	            this._graphics.style = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    Shape.prototype.bakeTransformations = function () {
	        this._graphics.applyTransformation(this.transform.matrix3D);
	        this.transform.clearMatrix3D();
	    };
	    /**
	     * @inheritDoc
	     */
	    Shape.prototype.dispose = function () {
	        this.disposeValues();
	        Shape._shapes.push(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    Shape.prototype.disposeValues = function () {
	        _super.prototype.disposeValues.call(this);
	        this._graphics.dispose();
	    };
	    /**
	     * Clones this Shape instance along with all it's children, while re-using the same
	     * material, graphics and animation set. The returned result will be a copy of this shape,
	     * containing copies of all of it's children.
	     *
	     * Properties that are re-used (i.e. not cloned) by the new copy include name,
	     * graphics, and material. Properties that are cloned or created anew for the copy
	     * include subShapees, children of the shape, and the animator.
	     *
	     * If you want to copy just the shape, reusing it's graphics and material while not
	     * cloning it's children, the simplest way is to create a new shape manually:
	     *
	     * <code>
	     * var clone : Shape = new Shape(original.graphics, original.material);
	     * </code>
	     */
	    Shape.prototype.clone = function () {
	        var newInstance = (Shape._shapes.length) ? Shape._shapes.pop() : new Shape();
	        this.copyTo(newInstance);
	        return newInstance;
	    };
	    Shape.prototype.copyTo = function (shape) {
	        _super.prototype.copyTo.call(this, shape);
	        this._graphics.copyTo(shape.graphics);
	    };
	    /**
	     * //TODO
	     *
	     * @protected
	     */
	    Shape.prototype._pUpdateBoxBounds = function () {
	        _super.prototype._pUpdateBoxBounds.call(this);
	        this._pBoxBounds.union(this._graphics.getBoxBounds(), this._pBoxBounds);
	    };
	    Shape.prototype._pUpdateSphereBounds = function () {
	        _super.prototype._pUpdateSphereBounds.call(this);
	        var box = this.getBox();
	        if (!this._center)
	            this._center = new Vector3D_1.Vector3D();
	        this._center.x = box.x + box.width / 2;
	        this._center.y = box.y + box.height / 2;
	        this._center.z = box.z + box.depth / 2;
	        this._pSphereBounds = this._graphics.getSphereBounds(this._center, this._pSphereBounds);
	    };
	    /**
	     * //TODO
	     *
	     * @private
	     */
	    Shape.prototype._onGraphicsInvalidate = function (event) {
	        if (this._pIsEntity != Boolean(this._graphics.count)) {
	            if (this._pScene)
	                this._pScene._iUnregisterObject(this);
	            this._pIsEntity = Boolean(this._graphics.count);
	            if (this._pScene)
	                this._pScene._iRegisterObject(this);
	        }
	        this._pInvalidateBounds();
	    };
	    /**
	     *
	     * @param renderer
	     *
	     * @internal
	     */
	    Shape.prototype._acceptTraverser = function (traverser) {
	        this.graphics.acceptTraverser(traverser);
	    };
	    Shape.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
	        if (this._graphics.count) {
	            this._tempPoint.setTo(x, y);
	            var local = this.globalToLocal(this._tempPoint, this._tempPoint);
	            var box;
	            //early out for box test
	            if (!(box = this.getBox()).contains(local.x, local.y, 0))
	                return false;
	            //early out for non-shape tests
	            if (!shapeFlag)
	                return true;
	            //ok do the graphics thing
	            if (this._graphics._hitTestPointInternal(local.x, local.y))
	                return true;
	        }
	        return false;
	    };
	    Shape.prototype.clear = function () {
	        _super.prototype.clear.call(this);
	        this._graphics.clear();
	    };
	    Shape._shapes = new Array();
	    Shape.assetType = "[asset Shape]";
	    return Shape;
	}(DisplayObject_1.DisplayObject));
	exports.Shape = Shape;


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ProjectionEvent_1 = __webpack_require__(142);
	var Matrix3D_1 = __webpack_require__(32);
	var PerspectiveProjection_1 = __webpack_require__(143);
	var HierarchicalProperties_1 = __webpack_require__(22);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	/**
	 * TextureProjector is an object in the scene that can be used to project textures onto geometry. To do so,
	 * the object's material must have a ProjectiveTextureMethod method added to it with a TextureProjector object
	 * passed in the constructor.
	 * This can be used for various effects apart from acting like a normal projector, such as projecting fake shadows
	 * unto a surface, the impact of light coming through a stained glass window, ...
	 *
	 * @see away3d.materials.methods.ProjectiveTextureMethod
	 */
	var TextureProjector = (function (_super) {
	    __extends(TextureProjector, _super);
	    /**
	     * Creates a new TextureProjector object.
	     * @param texture The texture to be projected on the geometry. Since any point that is projected out of the range
	     * of the projector's cone is clamped to the texture's edges, the edges should be entirely neutral.
	     */
	    function TextureProjector(texture) {
	        var _this = this;
	        _super.call(this);
	        this._viewProjectionInvalid = true;
	        this._viewProjection = new Matrix3D_1.Matrix3D();
	        this._onProjectionMatrixChangedDelegate = function (event) { return _this.onProjectionMatrixChanged(event); };
	        this._projection = new PerspectiveProjection_1.PerspectiveProjection();
	        //this._projection.preserveFocalLength = true;
	        this._projection.addEventListener(ProjectionEvent_1.ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	        this._texture = texture;
	        var width = texture.getImageAt(0).width;
	        var height = texture.getImageAt(0).height;
	        this._projection._iAspectRatio = width / height;
	        this._projection._iUpdateScissorRect(0, 0, width, height);
	        this._projection._iUpdateViewport(0, 0, width, height);
	    }
	    Object.defineProperty(TextureProjector.prototype, "aspectRatio", {
	        /**
	         * The aspect ratio of the texture or projection. By default this is the same aspect ratio of the texture (width/height)
	         */
	        get: function () {
	            return this._projection._iAspectRatio;
	        },
	        set: function (value) {
	            this._projection._iAspectRatio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureProjector.prototype, "fieldOfView", {
	        /**
	         * The vertical field of view of the projection, or the angle of the cone.
	         */
	        get: function () {
	            return this._projection.fieldOfView;
	        },
	        set: function (value) {
	            this._projection.fieldOfView = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureProjector.prototype, "focalLength", {
	        /**
	         * The focal length of the projection, or the distance to the viewing plance from the camera.
	         */
	        get: function () {
	            return this._projection.focalLength;
	        },
	        set: function (value) {
	            this._projection.focalLength = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureProjector.prototype, "assetType", {
	        get: function () {
	            return TextureProjector.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureProjector.prototype, "texture", {
	        /**
	         * The texture to be projected on the geometry.
	         * IMPORTANT: Since any point that is projected out of the range of the projector's cone is clamped to the texture's edges,
	         * the edges should be entirely neutral. Depending on the blend mode, the neutral color is:
	         * White for MULTIPLY,
	         * Black for ADD,
	         * Transparent for MIX
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (value == this._texture)
	                return;
	            this._texture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TextureProjector.prototype, "viewProjection", {
	        /**
	         * The matrix that projects a point in scene space into the texture coordinates.
	         */
	        get: function () {
	            if (this._viewProjectionInvalid) {
	                this._viewProjection.copyFrom(this.inverseSceneTransform);
	                this._viewProjection.append(this._projection.matrix);
	                this._viewProjectionInvalid = false;
	            }
	            return this._viewProjection;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    TextureProjector.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
	        if (_super.prototype.pInvalidateHierarchicalProperties.call(this, propDirty))
	            return true;
	        if (propDirty & HierarchicalProperties_1.HierarchicalProperties.SCENE_TRANSFORM)
	            this._viewProjectionInvalid = true;
	        return false;
	    };
	    TextureProjector.prototype.onProjectionMatrixChanged = function (event) {
	        this._viewProjectionInvalid = true;
	    };
	    TextureProjector.assetType = "[asset TextureProjector]";
	    return TextureProjector;
	}(DisplayObjectContainer_1.DisplayObjectContainer));
	exports.TextureProjector = TextureProjector;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(202));


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ElementsBase_1 = __webpack_require__(126);
	exports.ElementsBase = ElementsBase_1.ElementsBase;
	var ElementsType_1 = __webpack_require__(203);
	exports.ElementsType = ElementsType_1.ElementsType;
	var Graphic_1 = __webpack_require__(138);
	exports.Graphic = Graphic_1.Graphic;
	var Graphics_1 = __webpack_require__(178);
	exports.Graphics = Graphics_1.Graphics;
	var LineElements_1 = __webpack_require__(125);
	exports.LineElements = LineElements_1.LineElements;
	var TriangleElements_1 = __webpack_require__(179);
	exports.TriangleElements = TriangleElements_1.TriangleElements;


/***/ },
/* 203 */
/***/ function(module, exports) {

	"use strict";
	var ElementsType = (function () {
	    function ElementsType() {
	    }
	    /**
	     *
	     */
	    ElementsType.TRIANGLE = "triangle";
	    /**
	     *
	     */
	    ElementsType.LINE = "line";
	    return ElementsType;
	}());
	exports.ElementsType = ElementsType;


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(205));


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImage2D_1 = __webpack_require__(95);
	exports.BitmapImage2D = BitmapImage2D_1.BitmapImage2D;
	var BitmapImageChannel_1 = __webpack_require__(206);
	exports.BitmapImageChannel = BitmapImageChannel_1.BitmapImageChannel;
	var BitmapImageCube_1 = __webpack_require__(123);
	exports.BitmapImageCube = BitmapImageCube_1.BitmapImageCube;
	var BlendMode_1 = __webpack_require__(131);
	exports.BlendMode = BlendMode_1.BlendMode;
	var CPUCanvas_1 = __webpack_require__(100);
	exports.CPUCanvas = CPUCanvas_1.CPUCanvas;
	var CPURenderingContext2D_1 = __webpack_require__(101);
	exports.CPURenderingContext2D = CPURenderingContext2D_1.CPURenderingContext2D;
	var Image2D_1 = __webpack_require__(96);
	exports.Image2D = Image2D_1.Image2D;
	var ImageBase_1 = __webpack_require__(97);
	exports.ImageBase = ImageBase_1.ImageBase;
	var ImageCube_1 = __webpack_require__(124);
	exports.ImageCube = ImageCube_1.ImageCube;
	var ImageData_1 = __webpack_require__(103);
	exports.ImageData = ImageData_1.ImageData;
	var Sampler2D_1 = __webpack_require__(121);
	exports.Sampler2D = Sampler2D_1.Sampler2D;
	var SamplerBase_1 = __webpack_require__(122);
	exports.SamplerBase = SamplerBase_1.SamplerBase;
	var SamplerCube_1 = __webpack_require__(156);
	exports.SamplerCube = SamplerCube_1.SamplerCube;
	var SpecularImage2D_1 = __webpack_require__(207);
	exports.SpecularImage2D = SpecularImage2D_1.SpecularImage2D;


/***/ },
/* 206 */
/***/ function(module, exports) {

	"use strict";
	var BitmapImageChannel = (function () {
	    function BitmapImageChannel() {
	    }
	    BitmapImageChannel.ALPHA = 8;
	    BitmapImageChannel.BLUE = 4;
	    BitmapImageChannel.GREEN = 2;
	    BitmapImageChannel.RED = 1;
	    return BitmapImageChannel;
	}());
	exports.BitmapImageChannel = BitmapImageChannel;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImage2D_1 = __webpack_require__(95);
	var BitmapImageChannel_1 = __webpack_require__(206);
	var Image2D_1 = __webpack_require__(96);
	var Point_1 = __webpack_require__(58);
	/**
	 *
	 */
	var SpecularImage2D = (function (_super) {
	    __extends(SpecularImage2D, _super);
	    /**
	     *
	     */
	    function SpecularImage2D(specularSource, glossSource) {
	        if (specularSource === void 0) { specularSource = null; }
	        if (glossSource === void 0) { glossSource = null; }
	        _super.call(this, 1, 1);
	        this._specularSource = specularSource;
	        this._glossSource = glossSource;
	        this._output = new BitmapImage2D_1.BitmapImage2D(1, 1, false, 0xffffff);
	        this._testSize();
	    }
	    Object.defineProperty(SpecularImage2D.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return SpecularImage2D.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularImage2D.prototype, "specularSource", {
	        get: function () {
	            return this._specularSource;
	        },
	        set: function (value) {
	            if (this._specularSource == value)
	                return;
	            this._specularSource = value;
	            this.invalidate();
	            this._testSize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularImage2D.prototype, "glossSource", {
	        get: function () {
	            return this._glossSource;
	        },
	        set: function (value) {
	            if (this._glossSource == value)
	                return;
	            this._glossSource = value;
	            this.invalidate();
	            this._testSize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns a new SpecularImage2D object that is a clone of the original instance
	     * with an exact copy of the contained bitmap.
	     *
	     * @return A new SpecularImage2D object that is identical to the original.
	     */
	    SpecularImage2D.prototype.clone = function () {
	        return new SpecularImage2D(this._specularSource, this._glossSource);
	    };
	    /**
	     * Frees memory that is used to store the SpecularImage2D object.
	     *
	     * <p>When the <code>dispose()</code> method is called on an image, the width
	     * and height of the image are set to 0. All subsequent calls to methods or
	     * properties of this SpecularImage2D instance fail, and an exception is thrown.
	     * </p>
	     *
	     * <p><code>SpecularImage2D.dispose()</code> releases the memory occupied by the
	     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
	     * memory). After using <code>SpecularImage2D.dispose()</code>, the SpecularImage2D
	     * object is no longer usable and an exception may be thrown if
	     * you call functions on the SpecularImage2D object. However,
	     * <code>SpecularImage2D.dispose()</code> does not garbage collect the SpecularImage2D
	     * object(approximately 128 bytes); the memory occupied by the actual
	     * SpecularImage2D object is released at the time the SpecularImage2D object is
	     * collected by the garbage collector.</p>
	     *
	     */
	    SpecularImage2D.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this._rect = null;
	        this._output.dispose();
	    };
	    /**
	     *
	     * @returns {ImageData}
	     */
	    SpecularImage2D.prototype.getImageData = function () {
	        var origin = new Point_1.Point();
	        this._output.fillRect(this._rect, 0xffffff);
	        if (this._glossSource)
	            this._output.copyChannel(this._glossSource, this._rect, origin, BitmapImageChannel_1.BitmapImageChannel.GREEN, BitmapImageChannel_1.BitmapImageChannel.GREEN);
	        if (this._specularSource)
	            this._output.copyChannel(this._specularSource, this._rect, origin, BitmapImageChannel_1.BitmapImageChannel.RED, BitmapImageChannel_1.BitmapImageChannel.RED);
	        return this._output.getImageData();
	    };
	    /**
	     *
	     * @returns {HTMLCanvasElement}
	     */
	    SpecularImage2D.prototype.getCanvas = function () {
	        return this._output.getCanvas();
	    };
	    /**
	     *
	     * @param width
	     * @param height
	     * @private
	     */
	    SpecularImage2D.prototype._setSize = function (width, height) {
	        _super.prototype._setSize.call(this, width, height);
	        this._output._setSize(width, height);
	    };
	    SpecularImage2D.prototype._testSize = function () {
	        var w, h;
	        if (this._specularSource) {
	            w = this._specularSource.width;
	            h = this._specularSource.height;
	        }
	        else if (this._glossSource) {
	            w = this._glossSource.width;
	            h = this._glossSource.height;
	        }
	        else {
	            w = 1;
	            h = 1;
	        }
	        if (w != this._output.width && h != this._output.height) {
	            this._output.dispose();
	            this._output = new BitmapImage2D_1.BitmapImage2D(w, h, false, 0xffffff);
	        }
	        this._setSize(w, h);
	    };
	    SpecularImage2D.assetType = "[asset SpecularImage2D]";
	    return SpecularImage2D;
	}(Image2D_1.Image2D));
	exports.SpecularImage2D = SpecularImage2D;


/***/ },
/* 208 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(209));


/***/ },
/* 209 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractionBase_1 = __webpack_require__(210);
	exports.AbstractionBase = AbstractionBase_1.AbstractionBase;
	var AssetBase_1 = __webpack_require__(6);
	exports.AssetBase = AssetBase_1.AssetBase;
	var AssetLibrary_1 = __webpack_require__(211);
	exports.AssetLibrary = AssetLibrary_1.AssetLibrary;
	var AssetLibraryBundle_1 = __webpack_require__(159);
	exports.AssetLibraryBundle = AssetLibraryBundle_1.AssetLibraryBundle;
	var AssetLibraryIterator_1 = __webpack_require__(160);
	exports.AssetLibraryIterator = AssetLibraryIterator_1.AssetLibraryIterator;
	var ConflictPrecedence_1 = __webpack_require__(170);
	exports.ConflictPrecedence = ConflictPrecedence_1.ConflictPrecedence;
	var ConflictStrategy_1 = __webpack_require__(171);
	exports.ConflictStrategy = ConflictStrategy_1.ConflictStrategy;
	var ConflictStrategyBase_1 = __webpack_require__(173);
	exports.ConflictStrategyBase = ConflictStrategyBase_1.ConflictStrategyBase;
	var ErrorConflictStrategy_1 = __webpack_require__(172);
	exports.ErrorConflictStrategy = ErrorConflictStrategy_1.ErrorConflictStrategy;
	var IDUtil_1 = __webpack_require__(212);
	exports.IDUtil = IDUtil_1.IDUtil;
	var IgnoreConflictStrategy_1 = __webpack_require__(174);
	exports.IgnoreConflictStrategy = IgnoreConflictStrategy_1.IgnoreConflictStrategy;
	var Loader_1 = __webpack_require__(161);
	exports.Loader = Loader_1.Loader;
	var LoaderContext_1 = __webpack_require__(213);
	exports.LoaderContext = LoaderContext_1.LoaderContext;
	var LoaderInfo_1 = __webpack_require__(214);
	exports.LoaderInfo = LoaderInfo_1.LoaderInfo;
	var NumSuffixConflictStrategy_1 = __webpack_require__(175);
	exports.NumSuffixConflictStrategy = NumSuffixConflictStrategy_1.NumSuffixConflictStrategy;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var EventDispatcher_1 = __webpack_require__(11);
	/**
	 *
	 * @export class away.pool.AbstractionBase
	 */
	var AbstractionBase = (function (_super) {
	    __extends(AbstractionBase, _super);
	    function AbstractionBase(asset, pool) {
	        var _this = this;
	        _super.call(this);
	        this._invalid = true;
	        this._asset = asset;
	        this._pool = pool;
	        this._onClearDelegate = function (event) { return _this.onClear(event); };
	        this._onInvalidateDelegate = function (event) { return _this.onInvalidate(event); };
	        this._asset.addEventListener(AssetEvent_1.AssetEvent.CLEAR, this._onClearDelegate);
	        this._asset.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onInvalidateDelegate);
	    }
	    /**
	     *
	     */
	    AbstractionBase.prototype.onClear = function (event) {
	        this._asset.removeEventListener(AssetEvent_1.AssetEvent.CLEAR, this._onClearDelegate);
	        this._asset.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onInvalidateDelegate);
	        this._pool.clearAbstraction(this._asset);
	        this._pool = null;
	        this._asset = null;
	    };
	    /**
	     *
	     */
	    AbstractionBase.prototype.onInvalidate = function (event) {
	        this._invalid = true;
	    };
	    return AbstractionBase;
	}(EventDispatcher_1.EventDispatcher));
	exports.AbstractionBase = AbstractionBase;


/***/ },
/* 211 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AssetLibraryBundle_1 = __webpack_require__(159);
	var Loader_1 = __webpack_require__(161);
	/**
	 * AssetLibrary enforces a singleton pattern and is not intended to be instanced.
	 * It's purpose is to allow access to the default library bundle through a set of static shortcut methods.
	 * If you are interested in creating multiple library bundles, please use the <code>getBundle()</code> method.
	 */
	var AssetLibrary = (function () {
	    /**
	     * Creates a new <code>AssetLibrary</code> object.
	     *
	     */
	    function AssetLibrary() {
	    }
	    //*/
	    /**
	     * Returns an AssetLibrary bundle instance. If no key is given, returns the default bundle (which is
	     * similar to using the AssetLibraryBundle as a singleton). To keep several separated library bundles,
	     * pass a string key to this method to define which bundle should be returned. This is
	     * referred to as using the AssetLibraryBundle as a multiton.
	     *
	     * @param key Defines which multiton instance should be returned.
	     * @return An instance of the asset library
	     */
	    AssetLibrary.getBundle = function (key) {
	        if (key === void 0) { key = 'default'; }
	        return AssetLibraryBundle_1.AssetLibraryBundle.getInstance(key);
	    };
	    /**
	     *
	     */
	    AssetLibrary.enableParser = function (parserClass) {
	        Loader_1.Loader.enableParser(parserClass);
	    };
	    /**
	     *
	     */
	    AssetLibrary.enableParsers = function (parserClasses) {
	        Loader_1.Loader.enableParsers(parserClasses);
	    };
	    Object.defineProperty(AssetLibrary, "conflictStrategy", {
	        /**
	         * Short-hand for conflictStrategy property on default asset library bundle.
	         *
	         * @see AssetLibraryBundle.conflictStrategy
	         */
	        get: function () {
	            return AssetLibrary.getBundle().conflictStrategy;
	        },
	        set: function (val) {
	            AssetLibrary.getBundle().conflictStrategy = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AssetLibrary, "conflictPrecedence", {
	        /**
	         * Short-hand for conflictPrecedence property on default asset library bundle.
	         *
	         * @see AssetLibraryBundle.conflictPrecedence
	         */
	        get: function () {
	            return AssetLibrary.getBundle().conflictPrecedence;
	        },
	        set: function (val) {
	            AssetLibrary.getBundle().conflictPrecedence = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Short-hand for createIterator() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.createIterator()
	     */
	    AssetLibrary.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
	        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
	        if (namespaceFilter === void 0) { namespaceFilter = null; }
	        if (filterFunc === void 0) { filterFunc = null; }
	        return AssetLibrary.getBundle().createIterator(assetTypeFilter, namespaceFilter, filterFunc);
	    };
	    /**
	     * Short-hand for load() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.load()
	     */
	    AssetLibrary.load = function (req, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        AssetLibrary.getBundle().load(req, context, ns, parser);
	    };
	    /**
	     * Short-hand for loadData() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.loadData()
	     */
	    AssetLibrary.loadData = function (data, context, ns, parser) {
	        if (context === void 0) { context = null; }
	        if (ns === void 0) { ns = null; }
	        if (parser === void 0) { parser = null; }
	        AssetLibrary.getBundle().loadData(data, context, ns, parser);
	    };
	    AssetLibrary.stopLoad = function () {
	        AssetLibrary.getBundle().stopAllLoaders();
	    };
	    AssetLibrary.getLoader = function () {
	        return AssetLibrary.getBundle().getLoader();
	    };
	    /**
	     * Short-hand for getAsset() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.getAsset()
	     */
	    AssetLibrary.getAsset = function (name, ns) {
	        if (ns === void 0) { ns = null; }
	        return AssetLibrary.getBundle().getAsset(name, ns);
	    };
	    /**
	     * Short-hand for getAsset() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.getAsset()
	     */
	    AssetLibrary.getAllAssets = function () {
	        return AssetLibrary.getBundle().getAllAssets();
	    };
	    /**
	     * Short-hand for addEventListener() method on default asset library bundle.
	     */
	    AssetLibrary.addEventListener = function (type, listener) {
	        AssetLibrary.getBundle().addEventListener(type, listener);
	    };
	    /**
	     * Short-hand for removeEventListener() method on default asset library bundle.
	     */
	    AssetLibrary.removeEventListener = function (type, listener) {
	        AssetLibrary.getBundle().removeEventListener(type, listener);
	    };
	    /**
	     * Short-hand for hasEventListener() method on default asset library bundle.
	
	     public static hasEventListener(type:string):boolean
	     {
	        return AssetLibrary.getBundle().hasEventListener(type);
	    }
	
	     public static willTrigger(type:string):boolean
	     {
	        return getBundle().willTrigger(type);
	    }
	     */
	    /**
	     * Short-hand for addAsset() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.addAsset()
	     */
	    AssetLibrary.addAsset = function (asset) {
	        AssetLibrary.getBundle().addAsset(asset);
	    };
	    /**
	     * Short-hand for removeAsset() method on default asset library bundle.
	     *
	     * @param asset The asset which should be removed from the library.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see AssetLibraryBundle.removeAsset()
	     */
	    AssetLibrary.removeAsset = function (asset, dispose) {
	        if (dispose === void 0) { dispose = true; }
	        AssetLibrary.getBundle().removeAsset(asset, dispose);
	    };
	    /**
	     * Short-hand for removeAssetByName() method on default asset library bundle.
	     *
	     * @param name The name of the asset to be removed.
	     * @param ns The namespace to which the desired asset belongs.
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see AssetLibraryBundle.removeAssetByName()
	     */
	    AssetLibrary.removeAssetByName = function (name, ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        return AssetLibrary.getBundle().removeAssetByName(name, ns, dispose);
	    };
	    /**
	     * Short-hand for removeAllAssets() method on default asset library bundle.
	     *
	     * @param dispose Defines whether the assets should also be disposed.
	     *
	     * @see AssetLibraryBundle.removeAllAssets()
	     */
	    AssetLibrary.removeAllAssets = function (dispose) {
	        if (dispose === void 0) { dispose = true; }
	        AssetLibrary.getBundle().removeAllAssets(dispose);
	    };
	    /**
	     * Short-hand for removeNamespaceAssets() method on default asset library bundle.
	     *
	     * @see AssetLibraryBundle.removeNamespaceAssets()
	     */
	    AssetLibrary.removeNamespaceAssets = function (ns, dispose) {
	        if (ns === void 0) { ns = null; }
	        if (dispose === void 0) { dispose = true; }
	        AssetLibrary.getBundle().removeNamespaceAssets(ns, dispose);
	    };
	    return AssetLibrary;
	}());
	exports.AssetLibrary = AssetLibrary;


/***/ },
/* 212 */
/***/ function(module, exports) {

	"use strict";
	var IDUtil = (function () {
	    function IDUtil() {
	    }
	    /**
	     *  Generates a UID (unique identifier) based on ActionScript's
	     *  pseudo-random number generator and the current time.
	     *
	     *  <p>The UID has the form
	     *  <code>"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"</code>
	     *  where X is a hexadecimal digit (0-9, A-F).</p>
	     *
	     *  <p>This UID will not be truly globally unique; but it is the best
	     *  we can do without player support for UID generation.</p>
	     *
	     *  @return The newly-generated UID.
	     *
	     *  @langversion 3.0
	     *  @playerversion Flash 9
	     *  @playerversion AIR 1.1
	     *  @productversion Flex 3
	     */
	    IDUtil.createUID = function () {
	        var uid = new Array(36);
	        var index = 0;
	        var i;
	        var j;
	        for (i = 0; i < 8; i++)
	            uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];
	        for (i = 0; i < 3; i++) {
	            uid[index++] = 45; // charCode for "-"
	            for (j = 0; j < 4; j++)
	                uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];
	        }
	        uid[index++] = 45; // charCode for "-"
	        var time = new Date().getTime();
	        // Note: time is the number of milliseconds since 1970,
	        // which is currently more than one trillion.
	        // We use the low 8 hex digits of this number in the UID.
	        // Just in case the system clock has been reset to
	        // Jan 1-4, 1970 (in which case this number could have only
	        // 1-7 hex digits), we pad on the left with 7 zeros
	        // before taking the low digits.
	        var timeString = ("0000000" + time.toString(16).toUpperCase()).substr(-8);
	        for (i = 0; i < 8; i++)
	            uid[index++] = timeString.charCodeAt(i);
	        for (i = 0; i < 4; i++)
	            uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];
	        return String.fromCharCode.apply(null, uid);
	    };
	    /**
	     *  @private
	     *  Char codes for 0123456789ABCDEF
	     */
	    IDUtil.ALPHA_CHAR_CODES = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70];
	    return IDUtil;
	}());
	exports.IDUtil = IDUtil;


/***/ },
/* 213 */
/***/ function(module, exports) {

	"use strict";
	var LoaderContext = (function () {
	    /**
	     * LoaderContext provides configuration for the Loader load() and parse() operations.
	     * Use it to configure how (and if) dependencies are loaded, or to map dependency URLs to
	     * embedded data.
	     *
	     * @see away.loading.Loader
	     */
	    function LoaderContext(includeDependencies, dependencyBaseUrl) {
	        if (includeDependencies === void 0) { includeDependencies = true; }
	        if (dependencyBaseUrl === void 0) { dependencyBaseUrl = null; }
	        this._includeDependencies = includeDependencies;
	        this._dependencyBaseUrl = dependencyBaseUrl || '';
	        this._embeddedDataByUrl = {};
	        this._remappedUrls = {};
	        this._materialMode = LoaderContext.UNDEFINED;
	    }
	    Object.defineProperty(LoaderContext.prototype, "includeDependencies", {
	        /**
	         * Defines whether dependencies (all files except the one at the URL given to the load() or
	         * parseData() operations) should be automatically loaded. Defaults to true.
	         */
	        get: function () {
	            return this._includeDependencies;
	        },
	        set: function (val) {
	            this._includeDependencies = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderContext.prototype, "materialMode", {
	        /**
	         * MaterialMode defines, if the Parser should create SinglePass or MultiPass Materials
	         * Options:
	         * 0 (Default / undefined) - All Parsers will create SinglePassMaterials, but the AWD2.1parser will create Materials as they are defined in the file
	         * 1 (Force SinglePass) - All Parsers create SinglePassMaterials
	         * 2 (Force MultiPass) - All Parsers will create MultiPassMaterials
	         *
	         */
	        get: function () {
	            return this._materialMode;
	        },
	        set: function (materialMode) {
	            this._materialMode = materialMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderContext.prototype, "dependencyBaseUrl", {
	        /**
	         * A base URL that will be prepended to all relative dependency URLs found in a loaded resource.
	         * Absolute paths will not be affected by the value of this property.
	         */
	        get: function () {
	            return this._dependencyBaseUrl;
	        },
	        set: function (val) {
	            this._dependencyBaseUrl = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderContext.prototype, "overrideAbsolutePaths", {
	        /**
	         * Defines whether absolute paths (defined as paths that begin with a "/") should be overridden
	         * with the dependencyBaseUrl defined in this context. If this is true, and the base path is
	         * "base", /path/to/asset.jpg will be resolved as base/path/to/asset.jpg.
	         */
	        get: function () {
	            return this._overrideAbsPath;
	        },
	        set: function (val) {
	            this._overrideAbsPath = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderContext.prototype, "overrideFullURLs", {
	        /**
	         * Defines whether "full" URLs (defined as a URL that includes a scheme, e.g. http://) should be
	         * overridden with the dependencyBaseUrl defined in this context. If this is true, and the base
	         * path is "base", http://example.com/path/to/asset.jpg will be resolved as base/path/to/asset.jpg.
	         */
	        get: function () {
	            return this._overrideFullUrls;
	        },
	        set: function (val) {
	            this._overrideFullUrls = val;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Map a URL to another URL, so that files that are referred to by the original URL will instead
	     * be loaded from the new URL. Use this when your file structure does not match the one that is
	     * expected by the loaded file.
	     *
	     * @param originalUrl The original URL which is referenced in the loaded resource.
	     * @param newUrl The URL from which away.should load the resource instead.
	     *
	     * @see mapUrlToData()
	     */
	    LoaderContext.prototype.mapUrl = function (originalUrl, newUrl) {
	        this._remappedUrls[originalUrl] = newUrl;
	    };
	    /**
	     * Map a URL to embedded data, so that instead of trying to load a dependency from the URL at
	     * which it's referenced, the dependency data will be retrieved straight from the memory instead.
	     *
	     * @param originalUrl The original URL which is referenced in the loaded resource.
	     * @param data The embedded data. Can be ByteArray or a export class which can be used to create a bytearray.
	     */
	    LoaderContext.prototype.mapUrlToData = function (originalUrl, data) {
	        this._embeddedDataByUrl[originalUrl] = data;
	    };
	    /**
	     * @private
	     * Defines whether embedded data has been mapped to a particular URL.
	     */
	    LoaderContext.prototype._iHasDataForUrl = function (url) {
	        return this._embeddedDataByUrl.hasOwnProperty(url);
	    };
	    /**
	     * @private
	     * Returns embedded data for a particular URL.
	     */
	    LoaderContext.prototype._iGetDataForUrl = function (url) {
	        return this._embeddedDataByUrl[url];
	    };
	    /**
	     * @private
	     * Defines whether a replacement URL has been mapped to a particular URL.
	     */
	    LoaderContext.prototype._iHasMappingForUrl = function (url) {
	        return this._remappedUrls.hasOwnProperty(url);
	    };
	    /**
	     * @private
	     * Returns new (replacement) URL for a particular original URL.
	     */
	    LoaderContext.prototype._iGetRemappedUrl = function (originalUrl) {
	        return this._remappedUrls[originalUrl];
	    };
	    LoaderContext.UNDEFINED = 0;
	    LoaderContext.SINGLEPASS_MATERIALS = 1;
	    LoaderContext.MULTIPASS_MATERIALS = 2;
	    return LoaderContext;
	}());
	exports.LoaderContext = LoaderContext;


/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(11);
	/**
	 * The LoaderInfo export class provides information about a loaded SWF file or a
	 * loaded image file(JPEG, GIF, or PNG). LoaderInfo objects are available for
	 * any display object. The information provided includes load progress, the
	 * URLs of the loader and loaded content, the number of bytes total for the
	 * media, and the nominal height and width of the media.
	 *
	 * <p>You can access LoaderInfo objects in two ways: </p>
	 *
	 * <ul>
	 *   <li>The <code>contentLoaderInfo</code> property of a flash.display.Loader
	 * object -  The <code>contentLoaderInfo</code> property is always available
	 * for any Loader object. For a Loader object that has not called the
	 * <code>load()</code> or <code>loadBytes()</code> method, or that has not
	 * sufficiently loaded, attempting to access many of the properties of the
	 * <code>contentLoaderInfo</code> property throws an error.</li>
	 *   <li>The <code>loaderInfo</code> property of a display object. </li>
	 * </ul>
	 *
	 * <p>The <code>contentLoaderInfo</code> property of a Loader object provides
	 * information about the content that the Loader object is loading, whereas
	 * the <code>loaderInfo</code> property of a DisplayObject provides
	 * information about the root SWF file for that display object. </p>
	 *
	 * <p>When you use a Loader object to load a display object(such as a SWF
	 * file or a bitmap), the <code>loaderInfo</code> property of the display
	 * object is the same as the <code>contentLoaderInfo</code> property of the
	 * Loader object(<code>DisplayObject.loaderInfo =
	 * Loader.contentLoaderInfo</code>). Because the instance of the main export class of
	 * the SWF file has no Loader object, the <code>loaderInfo</code> property is
	 * the only way to access the LoaderInfo for the instance of the main export class of
	 * the SWF file.</p>
	 *
	 * <p>The following diagram shows the different uses of the LoaderInfo
	 * object - for the instance of the main export class of the SWF file, for the
	 * <code>contentLoaderInfo</code> property of a Loader object, and for the
	 * <code>loaderInfo</code> property of a loaded object:</p>
	 *
	 * <p>When a loading operation is not complete, some properties of the
	 * <code>contentLoaderInfo</code> property of a Loader object are not
	 * available. You can obtain some properties, such as
	 * <code>bytesLoaded</code>, <code>bytesTotal</code>, <code>url</code>,
	 * <code>loaderURL</code>, and <code>applicationDomain</code>. When the
	 * <code>loaderInfo</code> object dispatches the <code>init</code> event, you
	 * can access all properties of the <code>loaderInfo</code> object and the
	 * loaded image or SWF file.</p>
	 *
	 * <p><b>Note:</b> All properties of LoaderInfo objects are read-only.</p>
	 *
	 * <p>The <code>EventDispatcher.dispatchEvent()</code> method is not
	 * applicable to LoaderInfo objects. If you call <code>dispatchEvent()</code>
	 * on a LoaderInfo object, an IllegalOperationError exception is thrown.</p>
	 *
	 * @event complete   Dispatched when data has loaded successfully. In other
	 *                   words, it is dispatched when all the content has been
	 *                   downloaded and the loading has finished. The
	 *                   <code>complete</code> event is always dispatched after
	 *                   the <code>init</code> event. The <code>init</code> event
	 *                   is dispatched when the object is ready to access, though
	 *                   the content may still be downloading.
	 * @event httpStatus Dispatched when a network request is made over HTTP and
	 *                   an HTTP status code can be detected.
	 * @event init       Dispatched when the properties and methods of a loaded
	 *                   SWF file are accessible and ready for use. The content,
	 *                   however, can still be downloading. A LoaderInfo object
	 *                   dispatches the <code>init</code> event when the following
	 *                   conditions exist:
	 *                   <ul>
	 *                     <li>All properties and methods associated with the
	 *                   loaded object and those associated with the LoaderInfo
	 *                   object are accessible.</li>
	 *                     <li>The constructors for all child objects have
	 *                   completed.</li>
	 *                     <li>All ActionScript code in the first frame of the
	 *                   loaded SWF's main timeline has been executed.</li>
	 *                   </ul>
	 *
	 *                   <p>For example, an <code>Event.INIT</code> is dispatched
	 *                   when the first frame of a movie or animation is loaded.
	 *                   The movie is then accessible and can be added to the
	 *                   display list. The complete movie, however, can take
	 *                   longer to download. The <code>Event.COMPLETE</code> is
	 *                   only dispatched once the full movie is loaded.</p>
	 *
	 *                   <p>The <code>init</code> event always precedes the
	 *                   <code>complete</code> event.</p>
	 * @event ioError    Dispatched when an input or output error occurs that
	 *                   causes a load operation to fail.
	 * @event open       Dispatched when a load operation starts.
	 * @event progress   Dispatched when data is received as the download
	 *                   operation progresses.
	 * @event unload     Dispatched by a LoaderInfo object whenever a loaded
	 *                   object is removed by using the <code>unload()</code>
	 *                   method of the Loader object, or when a second load is
	 *                   performed by the same Loader object and the original
	 *                   content is removed prior to the load beginning.
	 */
	var LoaderInfo = (function (_super) {
	    __extends(LoaderInfo, _super);
	    function LoaderInfo() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(LoaderInfo.prototype, "bytes", {
	        /**
	         * The bytes associated with a LoaderInfo object.
	         *
	         * @throws SecurityError If the object accessing this API is prevented from
	         *                       accessing the loaded object due to security
	         *                       restrictions. This situation can occur, for
	         *                       instance, when a Loader object attempts to access
	         *                       the <code>contentLoaderInfo.content</code> property
	         *                       and it is not granted security permission to access
	         *                       the loaded content.
	         *
	         *                       <p>For more information related to security, see the
	         *                       Flash Player Developer Center Topic: <a
	         *                       href="http://www.adobe.com/go/devnet_security_en"
	         *                       scope="external">Security</a>.</p>
	         */
	        get: function () {
	            return this._bytes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderInfo.prototype, "bytesLoaded", {
	        /**
	         * The number of bytes that are loaded for the media. When this number equals
	         * the value of <code>bytesTotal</code>, all of the bytes are loaded.
	         */
	        get: function () {
	            return this._bytesLoaded;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderInfo.prototype, "bytesTotal", {
	        /**
	         * The number of compressed bytes in the entire media file.
	         *
	         * <p>Before the first <code>progress</code> event is dispatched by this
	         * LoaderInfo object's corresponding Loader object, <code>bytesTotal</code>
	         * is 0. After the first <code>progress</code> event from the Loader object,
	         * <code>bytesTotal</code> reflects the actual number of bytes to be
	         * downloaded.</p>
	         */
	        get: function () {
	            return this._bytesTotal;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderInfo.prototype, "content", {
	        /**
	         * The loaded object associated with this LoaderInfo object.
	         *
	         * @throws SecurityError If the object accessing this API is prevented from
	         *                       accessing the loaded object due to security
	         *                       restrictions. This situation can occur, for
	         *                       instance, when a Loader object attempts to access
	         *                       the <code>contentLoaderInfo.content</code> property
	         *                       and it is not granted security permission to access
	         *                       the loaded content.
	         *
	         *                       <p>For more information related to security, see the
	         *                       Flash Player Developer Center Topic: <a
	         *                       href="http://www.adobe.com/go/devnet_security_en"
	         *                       scope="external">Security</a>.</p>
	         */
	        get: function () {
	            return this._content;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderInfo.prototype, "contentType", {
	        /**
	         * The MIME type of the loaded file. The value is <code>null</code> if not
	         * enough of the file has loaded in order to determine the type. The
	         * following list gives the possible values:
	         * <ul>
	         *   <li><code>"application/x-shockwave-flash"</code></li>
	         *   <li><code>"image/jpeg"</code></li>
	         *   <li><code>"image/gif"</code></li>
	         *   <li><code>"image/png"</code></li>
	         * </ul>
	         */
	        get: function () {
	            return this._contentType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderInfo.prototype, "loader", {
	        /**
	         * The Loader object associated with this LoaderInfo object. If this
	         * LoaderInfo object is the <code>loaderInfo</code> property of the instance
	         * of the main export class of the SWF file, no Loader object is associated.
	         *
	         * @throws SecurityError If the object accessing this API is prevented from
	         *                       accessing the Loader object because of security
	         *                       restrictions. This can occur, for instance, when a
	         *                       loaded SWF file attempts to access its
	         *                       <code>loaderInfo.loader</code> property and it is
	         *                       not granted security permission to access the
	         *                       loading SWF file.
	         *
	         *                       <p>For more information related to security, see the
	         *                       Flash Player Developer Center Topic: <a
	         *                       href="http://www.adobe.com/go/devnet_security_en"
	         *                       scope="external">Security</a>.</p>
	         */
	        get: function () {
	            return this._loader;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LoaderInfo.prototype, "url", {
	        /**
	         * The URL of the media being loaded.
	         *
	         * <p>Before the first <code>progress</code> event is dispatched by this
	         * LoaderInfo object's corresponding Loader object, the value of the
	         * <code>url</code> property might reflect only the initial URL specified in
	         * the call to the <code>load()</code> method of the Loader object. After the
	         * first <code>progress</code> event, the <code>url</code> property reflects
	         * the media's final URL, after any redirects and relative URLs are
	         * resolved.</p>
	         *
	         * <p>In some cases, the value of the <code>url</code> property is truncated;
	         * see the <code>isURLInaccessible</code> property for details.</p>
	         */
	        get: function () {
	            return this._url;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return LoaderInfo;
	}(EventDispatcher_1.EventDispatcher));
	exports.LoaderInfo = LoaderInfo;


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(216));
	__export(__webpack_require__(222));
	__export(__webpack_require__(224));
	__export(__webpack_require__(268));
	var MethodMaterial_1 = __webpack_require__(285);
	exports.MethodMaterial = MethodMaterial_1.MethodMaterial;
	var MethodMaterialMode_1 = __webpack_require__(284);
	exports.MethodMaterialMode = MethodMaterialMode_1.MethodMaterialMode;


/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var LightPickerBase_1 = __webpack_require__(217);
	exports.LightPickerBase = LightPickerBase_1.LightPickerBase;
	var StaticLightPicker_1 = __webpack_require__(218);
	exports.StaticLightPicker = StaticLightPicker_1.StaticLightPicker;
	var CascadeShadowMapper_1 = __webpack_require__(219);
	exports.CascadeShadowMapper = CascadeShadowMapper_1.CascadeShadowMapper;
	var CubeMapShadowMapper_1 = __webpack_require__(197);
	exports.CubeMapShadowMapper = CubeMapShadowMapper_1.CubeMapShadowMapper;
	var DirectionalShadowMapper_1 = __webpack_require__(152);
	exports.DirectionalShadowMapper = DirectionalShadowMapper_1.DirectionalShadowMapper;
	var NearDirectionalShadowMapper_1 = __webpack_require__(220);
	exports.NearDirectionalShadowMapper = NearDirectionalShadowMapper_1.NearDirectionalShadowMapper;
	var ShadowMapperBase_1 = __webpack_require__(154);
	exports.ShadowMapperBase = ShadowMapperBase_1.ShadowMapperBase;
	var BasicMaterial_1 = __webpack_require__(134);
	exports.BasicMaterial = BasicMaterial_1.BasicMaterial;
	var LightSources_1 = __webpack_require__(221);
	exports.LightSources = LightSources_1.LightSources;
	var MaterialBase_1 = __webpack_require__(135);
	exports.MaterialBase = MaterialBase_1.MaterialBase;


/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	/**
	 * LightPickerBase provides an abstract base clase for light picker classes. These classes are responsible for
	 * feeding materials with relevant lights. Usually, StaticLightPicker can be used, but LightPickerBase can be
	 * extended to provide more application-specific dynamic selection of lights.
	 *
	 * @see StaticLightPicker
	 */
	var LightPickerBase = (function (_super) {
	    __extends(LightPickerBase, _super);
	    /**
	     * Creates a new LightPickerBase object.
	     */
	    function LightPickerBase() {
	        _super.call(this);
	        this._pNumPointLights = 0;
	        this._pNumDirectionalLights = 0;
	        this._pNumCastingPointLights = 0;
	        this._pNumCastingDirectionalLights = 0;
	        this._pNumLightProbes = 0;
	    }
	    /**
	     * Disposes resources used by the light picker.
	     */
	    LightPickerBase.prototype.dispose = function () {
	    };
	    Object.defineProperty(LightPickerBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return LightPickerBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
	        /**
	         * The maximum amount of directional lights that will be provided.
	         */
	        get: function () {
	            return this._pNumDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
	        /**
	         * The maximum amount of point lights that will be provided.
	         */
	        get: function () {
	            return this._pNumPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numCastingDirectionalLights", {
	        /**
	         * The maximum amount of directional lights that cast shadows.
	         */
	        get: function () {
	            return this._pNumCastingDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numCastingPointLights", {
	        /**
	         * The amount of point lights that cast shadows.
	         */
	        get: function () {
	            return this._pNumCastingPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "numLightProbes", {
	        /**
	         * The maximum amount of light probes that will be provided.
	         */
	        get: function () {
	            return this._pNumLightProbes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "pointLights", {
	        /**
	         * The collected point lights to be used for shading.
	         */
	        get: function () {
	            return this._pPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
	        /**
	         * The collected directional lights to be used for shading.
	         */
	        get: function () {
	            return this._pDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "castingPointLights", {
	        /**
	         * The collected point lights that cast shadows to be used for shading.
	         */
	        get: function () {
	            return this._pCastingPointLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "castingDirectionalLights", {
	        /**
	         * The collected directional lights that cast shadows to be used for shading.
	         */
	        get: function () {
	            return this._pCastingDirectionalLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "lightProbes", {
	        /**
	         * The collected light probes to be used for shading.
	         */
	        get: function () {
	            return this._pLightProbes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "lightProbeWeights", {
	        /**
	         * The weights for each light probe, defining their influence on the object.
	         */
	        get: function () {
	            return this._pLightProbeWeights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
	        /**
	         * A collection of all the collected lights.
	         */
	        get: function () {
	            return this._pAllPickedLights;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Updates set of lights for a given renderable and EntityCollector. Always call super.collectLights() after custom overridden code.
	     */
	    LightPickerBase.prototype.collectLights = function (entity) {
	        this.updateProbeWeights(entity);
	    };
	    /**
	     * Updates the weights for the light probes, based on the renderable's position relative to them.
	     * @param renderable The renderble for which to calculate the light probes' influence.
	     */
	    LightPickerBase.prototype.updateProbeWeights = function (entity) {
	        // todo: this will cause the same calculations to occur per TriangleGraphic. See if this can be improved.
	        var objectPos = entity.scenePosition;
	        var lightPos;
	        var rx = objectPos.x, ry = objectPos.y, rz = objectPos.z;
	        var dx, dy, dz;
	        var w, total = 0;
	        var i;
	        // calculates weights for probes
	        for (i = 0; i < this._pNumLightProbes; ++i) {
	            lightPos = this._pLightProbes[i].scenePosition;
	            dx = rx - lightPos.x;
	            dy = ry - lightPos.y;
	            dz = rz - lightPos.z;
	            // weight is inversely proportional to square of distance
	            w = dx * dx + dy * dy + dz * dz;
	            // just... huge if at the same spot
	            w = w > .00001 ? 1 / w : 50000000;
	            this._pLightProbeWeights[i] = w;
	            total += w;
	        }
	        // normalize
	        total = 1 / total;
	        for (i = 0; i < this._pNumLightProbes; ++i)
	            this._pLightProbeWeights[i] *= total;
	    };
	    LightPickerBase.assetType = "[asset LightPicker]";
	    return LightPickerBase;
	}(AssetBase_1.AssetBase));
	exports.LightPickerBase = LightPickerBase;


/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var DirectionalLight_1 = __webpack_require__(149);
	var LightProbe_1 = __webpack_require__(155);
	var PointLight_1 = __webpack_require__(196);
	var LightEvent_1 = __webpack_require__(151);
	var LightPickerBase_1 = __webpack_require__(217);
	/**
	 * StaticLightPicker is a light picker that provides a static set of lights. The lights can be reassigned, but
	 * if the configuration changes (number of directional lights, point lights, etc), a material recompilation may
	 * occur.
	 */
	var StaticLightPicker = (function (_super) {
	    __extends(StaticLightPicker, _super);
	    /**
	     * Creates a new StaticLightPicker object.
	     * @param lights The lights to be used for shading.
	     */
	    function StaticLightPicker(lights) {
	        var _this = this;
	        _super.call(this);
	        this._onCastShadowChangeDelegate = function (event) { return _this.onCastShadowChange(event); };
	        this.lights = lights;
	    }
	    Object.defineProperty(StaticLightPicker.prototype, "lights", {
	        /**
	         * The lights used for shading.
	         */
	        get: function () {
	            return this._lights;
	        },
	        set: function (value) {
	            var numPointLights = 0;
	            var numDirectionalLights = 0;
	            var numCastingPointLights = 0;
	            var numCastingDirectionalLights = 0;
	            var numLightProbes = 0;
	            var light;
	            if (this._lights)
	                this.clearListeners();
	            this._lights = value;
	            this._pAllPickedLights = value;
	            this._pPointLights = new Array();
	            this._pCastingPointLights = new Array();
	            this._pDirectionalLights = new Array();
	            this._pCastingDirectionalLights = new Array();
	            this._pLightProbes = new Array();
	            var len = value.length;
	            for (var i = 0; i < len; ++i) {
	                light = value[i];
	                light.addEventListener(LightEvent_1.LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
	                if (light instanceof PointLight_1.PointLight) {
	                    if (light.shadowsEnabled)
	                        this._pCastingPointLights[numCastingPointLights++] = light;
	                    else
	                        this._pPointLights[numPointLights++] = light;
	                }
	                else if (light instanceof DirectionalLight_1.DirectionalLight) {
	                    if (light.shadowsEnabled)
	                        this._pCastingDirectionalLights[numCastingDirectionalLights++] = light;
	                    else
	                        this._pDirectionalLights[numDirectionalLights++] = light;
	                }
	                else if (light instanceof LightProbe_1.LightProbe) {
	                    this._pLightProbes[numLightProbes++] = light;
	                }
	            }
	            if (this._pNumDirectionalLights == numDirectionalLights && this._pNumPointLights == numPointLights && this._pNumLightProbes == numLightProbes && this._pNumCastingPointLights == numCastingPointLights && this._pNumCastingDirectionalLights == numCastingDirectionalLights)
	                return;
	            this._pNumDirectionalLights = numDirectionalLights;
	            this._pNumCastingDirectionalLights = numCastingDirectionalLights;
	            this._pNumPointLights = numPointLights;
	            this._pNumCastingPointLights = numCastingPointLights;
	            this._pNumLightProbes = numLightProbes;
	            // MUST HAVE MULTIPLE OF 4 ELEMENTS!
	            this._pLightProbeWeights = new Array(Math.ceil(numLightProbes / 4) * 4);
	            // notify material lights have changed
	            this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.INVALIDATE, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Remove configuration change listeners on the lights.
	     */
	    StaticLightPicker.prototype.clearListeners = function () {
	        var len = this._lights.length;
	        for (var i = 0; i < len; ++i)
	            this._lights[i].removeEventListener(LightEvent_1.LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
	    };
	    /**
	     * Notifies the material of a configuration change.
	     */
	    StaticLightPicker.prototype.onCastShadowChange = function (event) {
	        // TODO: Assign to special caster collections, just append it to the lights in SinglePass
	        // But keep seperated in multipass
	        var light = event.target;
	        if (light instanceof PointLight_1.PointLight)
	            this.updatePointCasting(light);
	        else if (light instanceof DirectionalLight_1.DirectionalLight)
	            this.updateDirectionalCasting(light);
	        this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.INVALIDATE, this));
	    };
	    /**
	     * Called when a directional light's shadow casting configuration changes.
	     */
	    StaticLightPicker.prototype.updateDirectionalCasting = function (light) {
	        var dl = light;
	        if (light.shadowsEnabled) {
	            --this._pNumDirectionalLights;
	            ++this._pNumCastingDirectionalLights;
	            this._pDirectionalLights.splice(this._pDirectionalLights.indexOf(dl), 1);
	            this._pCastingDirectionalLights.push(light);
	        }
	        else {
	            ++this._pNumDirectionalLights;
	            --this._pNumCastingDirectionalLights;
	            this._pCastingDirectionalLights.splice(this._pCastingDirectionalLights.indexOf(dl), 1);
	            this._pDirectionalLights.push(light);
	        }
	    };
	    /**
	     * Called when a point light's shadow casting configuration changes.
	     */
	    StaticLightPicker.prototype.updatePointCasting = function (light) {
	        var pl = light;
	        if (light.shadowsEnabled) {
	            --this._pNumPointLights;
	            ++this._pNumCastingPointLights;
	            this._pPointLights.splice(this._pPointLights.indexOf(pl), 1);
	            this._pCastingPointLights.push(light);
	        }
	        else {
	            ++this._pNumPointLights;
	            --this._pNumCastingPointLights;
	            this._pCastingPointLights.splice(this._pCastingPointLights.indexOf(pl), 1);
	            this._pPointLights.push(light);
	        }
	    };
	    return StaticLightPicker;
	}(LightPickerBase_1.LightPickerBase));
	exports.StaticLightPicker = StaticLightPicker;


/***/ },
/* 219 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Rectangle_1 = __webpack_require__(57);
	var AssetEvent_1 = __webpack_require__(9);
	var FreeMatrixProjection_1 = __webpack_require__(153);
	var Camera_1 = __webpack_require__(139);
	var DirectionalShadowMapper_1 = __webpack_require__(152);
	var CascadeShadowMapper = (function (_super) {
	    __extends(CascadeShadowMapper, _super);
	    function CascadeShadowMapper(numCascades) {
	        if (numCascades === void 0) { numCascades = 3; }
	        _super.call(this);
	        this._pScissorRectsInvalid = true;
	        if (numCascades < 1 || numCascades > 4)
	            throw new Error("numCascades must be an integer between 1 and 4");
	        this._numCascades = numCascades;
	        this.init();
	    }
	    CascadeShadowMapper.prototype.getSplitRatio = function (index /*uint*/) {
	        return this._splitRatios[index];
	    };
	    CascadeShadowMapper.prototype.setSplitRatio = function (index /*uint*/, value) {
	        if (value < 0)
	            value = 0;
	        else if (value > 1)
	            value = 1;
	        if (index >= this._numCascades)
	            throw new Error("index must be smaller than the number of cascades!");
	        this._splitRatios[index] = value;
	    };
	    CascadeShadowMapper.prototype.getDepthProjections = function (partition /*uint*/) {
	        return this._depthCameras[partition].viewProjection;
	    };
	    CascadeShadowMapper.prototype.init = function () {
	        this._splitRatios = new Array(this._numCascades);
	        this._nearPlaneDistances = new Array(this._numCascades);
	        var s = 1;
	        for (var i = this._numCascades - 1; i >= 0; --i) {
	            this._splitRatios[i] = s;
	            s *= .4;
	        }
	        this._texOffsetsX = Array(-1, 1, -1, 1);
	        this._texOffsetsY = Array(1, 1, -1, -1);
	        this._pScissorRects = new Array(4);
	        this._depthLenses = new Array();
	        this._depthCameras = new Array();
	        for (i = 0; i < this._numCascades; ++i) {
	            this._depthLenses[i] = new FreeMatrixProjection_1.FreeMatrixProjection();
	            this._depthCameras[i] = new Camera_1.Camera(this._depthLenses[i]);
	        }
	    };
	    CascadeShadowMapper.prototype._pSetDepthMapSize = function (value /*uint*/) {
	        _super.prototype._pSetDepthMapSize.call(this, value);
	        this.invalidateScissorRects();
	    };
	    CascadeShadowMapper.prototype.invalidateScissorRects = function () {
	        this._pScissorRectsInvalid = true;
	    };
	    Object.defineProperty(CascadeShadowMapper.prototype, "numCascades", {
	        get: function () {
	            return this._numCascades;
	        },
	        set: function (value /*int*/) {
	            if (value == this._numCascades)
	                return;
	            if (value < 1 || value > 4)
	                throw new Error("numCascades must be an integer between 1 and 4");
	            this._numCascades = value;
	            this.invalidateScissorRects();
	            this.init();
	            this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.INVALIDATE, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    CascadeShadowMapper.prototype.pDrawDepthMap = function (view, target, renderer) {
	        if (this._pScissorRectsInvalid)
	            this.updateScissorRects();
	        renderer.cullPlanes = this._pCullPlanes;
	        renderer._iRenderCascades(this._pOverallDepthCamera, view, target.image2D, this._numCascades, this._pScissorRects, this._depthCameras);
	    };
	    CascadeShadowMapper.prototype.updateScissorRects = function () {
	        var half = this._pDepthMapSize * .5;
	        this._pScissorRects[0] = new Rectangle_1.Rectangle(0, 0, half, half);
	        this._pScissorRects[1] = new Rectangle_1.Rectangle(half, 0, half, half);
	        this._pScissorRects[2] = new Rectangle_1.Rectangle(0, half, half, half);
	        this._pScissorRects[3] = new Rectangle_1.Rectangle(half, half, half, half);
	        this._pScissorRectsInvalid = false;
	    };
	    CascadeShadowMapper.prototype.pUpdateDepthProjection = function (camera) {
	        var matrix;
	        var projection = camera.projection;
	        var projectionNear = projection.near;
	        var projectionRange = projection.far - projectionNear;
	        this.pUpdateProjectionFromFrustumCorners(camera, camera.projection.frustumCorners, this._pMatrix);
	        this._pMatrix.appendScale(.96, .96, 1);
	        this._pOverallDepthProjection.matrix = this._pMatrix;
	        this.pUpdateCullPlanes(camera);
	        for (var i = 0; i < this._numCascades; ++i) {
	            matrix = this._depthLenses[i].matrix;
	            this._nearPlaneDistances[i] = projectionNear + this._splitRatios[i] * projectionRange;
	            this._depthCameras[i].transform.matrix3D = this._pOverallDepthCamera.transform.matrix3D;
	            this.updateProjectionPartition(matrix, this._splitRatios[i], this._texOffsetsX[i], this._texOffsetsY[i]);
	            this._depthLenses[i].matrix = matrix;
	        }
	    };
	    CascadeShadowMapper.prototype.updateProjectionPartition = function (matrix, splitRatio, texOffsetX, texOffsetY) {
	        var raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        var xN, yN, zN;
	        var xF, yF, zF;
	        var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, minZ;
	        var maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, maxZ = Number.NEGATIVE_INFINITY;
	        var i = 0;
	        while (i < 12) {
	            xN = this._pLocalFrustum[i];
	            yN = this._pLocalFrustum[i + 1];
	            zN = this._pLocalFrustum[i + 2];
	            xF = xN + (this._pLocalFrustum[i + 12] - xN) * splitRatio;
	            yF = yN + (this._pLocalFrustum[i + 13] - yN) * splitRatio;
	            zF = zN + (this._pLocalFrustum[i + 14] - zN) * splitRatio;
	            if (xN < minX)
	                minX = xN;
	            if (xN > maxX)
	                maxX = xN;
	            if (yN < minY)
	                minY = yN;
	            if (yN > maxY)
	                maxY = yN;
	            if (zN > maxZ)
	                maxZ = zN;
	            if (xF < minX)
	                minX = xF;
	            if (xF > maxX)
	                maxX = xF;
	            if (yF < minY)
	                minY = yF;
	            if (yF > maxY)
	                maxY = yF;
	            if (zF > maxZ)
	                maxZ = zF;
	            i += 3;
	        }
	        minZ = 1;
	        var w = (maxX - minX);
	        var h = (maxY - minY);
	        var d = 1 / (maxZ - minZ);
	        if (minX < 0)
	            minX -= this._pSnap; // because int() rounds up for < 0
	        if (minY < 0)
	            minY -= this._pSnap;
	        minX = Math.floor(minX / this._pSnap) * this._pSnap;
	        minY = Math.floor(minY / this._pSnap) * this._pSnap;
	        var snap2 = 2 * this._pSnap;
	        w = Math.floor(w / snap2 + 1) * snap2;
	        h = Math.floor(h / snap2 + 1) * snap2;
	        maxX = minX + w;
	        maxY = minY + h;
	        w = 1 / w;
	        h = 1 / h;
	        raw[0] = 2 * w;
	        raw[5] = 2 * h;
	        raw[10] = d;
	        raw[12] = -(maxX + minX) * w;
	        raw[13] = -(maxY + minY) * h;
	        raw[14] = -minZ * d;
	        raw[15] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	        matrix.copyRawDataFrom(raw);
	        matrix.appendScale(.96, .96, 1);
	        matrix.appendTranslation(texOffsetX, texOffsetY, 0);
	        matrix.appendScale(.5, .5, 1);
	    };
	    Object.defineProperty(CascadeShadowMapper.prototype, "_iNearPlaneDistances", {
	        get: function () {
	            return this._nearPlaneDistances;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CascadeShadowMapper;
	}(DirectionalShadowMapper_1.DirectionalShadowMapper));
	exports.CascadeShadowMapper = CascadeShadowMapper;


/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DirectionalShadowMapper_1 = __webpack_require__(152);
	var NearDirectionalShadowMapper = (function (_super) {
	    __extends(NearDirectionalShadowMapper, _super);
	    function NearDirectionalShadowMapper(coverageRatio) {
	        if (coverageRatio === void 0) { coverageRatio = .5; }
	        _super.call(this);
	        this.coverageRatio = coverageRatio;
	    }
	    Object.defineProperty(NearDirectionalShadowMapper.prototype, "coverageRatio", {
	        /**
	         * A value between 0 and 1 to indicate the ratio of the view frustum that needs to be covered by the shadow map.
	         */
	        get: function () {
	            return this._coverageRatio;
	        },
	        set: function (value) {
	            if (value > 1)
	                value = 1;
	            else if (value < 0)
	                value = 0;
	            this._coverageRatio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    NearDirectionalShadowMapper.prototype.pUpdateDepthProjection = function (camera) {
	        var corners = camera.projection.frustumCorners;
	        for (var i = 0; i < 12; ++i) {
	            var v = corners[i];
	            this._pLocalFrustum[i] = v;
	            this._pLocalFrustum[i + 12] = v + (corners[i + 12] - v) * this._coverageRatio;
	        }
	        this.pUpdateProjectionFromFrustumCorners(camera, this._pLocalFrustum, this._pMatrix);
	        this._pOverallDepthProjection.matrix = this._pMatrix;
	    };
	    return NearDirectionalShadowMapper;
	}(DirectionalShadowMapper_1.DirectionalShadowMapper));
	exports.NearDirectionalShadowMapper = NearDirectionalShadowMapper;


/***/ },
/* 221 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Enumeration class for defining which lighting types affect the specific material
	 * lighting component (diffuse and specular). This can be useful if, for example, you
	 * want to use light probes for diffuse global lighting, but want specular reflections from
	 * traditional light sources without those affecting the diffuse light.
	 *
	 * @see away.materials.ColorMaterial.diffuseLightSources
	 * @see away.materials.ColorMaterial.specularLightSources
	 * @see away.materials.TextureMaterial.diffuseLightSources
	 * @see away.materials.TextureMaterial.specularLightSources
	 */
	var LightSources = (function () {
	    function LightSources() {
	    }
	    /**
	     * Defines normal lights are to be used as the source for the lighting
	     * component.
	     */
	    LightSources.LIGHTS = 0x01;
	    /**
	     * Defines that global lighting probes are to be used as the source for the
	     * lighting component.
	     */
	    LightSources.PROBES = 0x02;
	    /**
	     * Defines that both normal and global lighting probes  are to be used as the
	     * source for the lighting component. This is equivalent to LightSources.LIGHTS | LightSources.PROBES.
	     */
	    LightSources.ALL = 0x03;
	    return LightSources;
	}());
	exports.LightSources = LightSources;


/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var MethodVO_1 = __webpack_require__(223);
	exports.MethodVO = MethodVO_1.MethodVO;


/***/ },
/* 223 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * MethodVO contains data for a given shader object for the use within a single material.
	 * This allows shader methods to be shared across materials while their non-public state differs.
	 */
	var MethodVO = (function () {
	    /**
	     * Creates a new MethodVO object.
	     */
	    function MethodVO(method, pass) {
	        this.useMethod = true;
	        this.method = method;
	        this.pass = pass;
	    }
	    /**
	     * Resets the values of the value object to their "unused" state.
	     */
	    MethodVO.prototype.reset = function () {
	        this.method.iReset();
	        this.vertexConstantsIndex = -1;
	        this.secondaryVertexConstantsIndex = -1;
	        this.fragmentConstantsIndex = -1;
	        this.secondaryFragmentConstantsIndex = -1;
	        this.needsProjection = false;
	        this.needsView = false;
	        this.needsNormals = false;
	        this.needsTangents = false;
	        this.needsGlobalVertexPos = false;
	        this.needsGlobalFragmentPos = false;
	    };
	    return MethodVO;
	}());
	exports.MethodVO = MethodVO;


/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AmbientBasicMethod_1 = __webpack_require__(225);
	exports.AmbientBasicMethod = AmbientBasicMethod_1.AmbientBasicMethod;
	var AmbientEnvMapMethod_1 = __webpack_require__(228);
	exports.AmbientEnvMapMethod = AmbientEnvMapMethod_1.AmbientEnvMapMethod;
	var CurveBasicMethod_1 = __webpack_require__(229);
	exports.CurveBasicMethod = CurveBasicMethod_1.CurveBasicMethod;
	var DiffuseBasicMethod_1 = __webpack_require__(230);
	exports.DiffuseBasicMethod = DiffuseBasicMethod_1.DiffuseBasicMethod;
	var DiffuseCelMethod_1 = __webpack_require__(232);
	exports.DiffuseCelMethod = DiffuseCelMethod_1.DiffuseCelMethod;
	var DiffuseCompositeMethod_1 = __webpack_require__(233);
	exports.DiffuseCompositeMethod = DiffuseCompositeMethod_1.DiffuseCompositeMethod;
	var DiffuseDepthMethod_1 = __webpack_require__(234);
	exports.DiffuseDepthMethod = DiffuseDepthMethod_1.DiffuseDepthMethod;
	var DiffuseGradientMethod_1 = __webpack_require__(235);
	exports.DiffuseGradientMethod = DiffuseGradientMethod_1.DiffuseGradientMethod;
	var DiffuseLightMapMethod_1 = __webpack_require__(236);
	exports.DiffuseLightMapMethod = DiffuseLightMapMethod_1.DiffuseLightMapMethod;
	var DiffuseSubSurfaceMethod_1 = __webpack_require__(237);
	exports.DiffuseSubSurfaceMethod = DiffuseSubSurfaceMethod_1.DiffuseSubSurfaceMethod;
	var DiffuseWrapMethod_1 = __webpack_require__(238);
	exports.DiffuseWrapMethod = DiffuseWrapMethod_1.DiffuseWrapMethod;
	var EffectAlphaMaskMethod_1 = __webpack_require__(239);
	exports.EffectAlphaMaskMethod = EffectAlphaMaskMethod_1.EffectAlphaMaskMethod;
	var EffectColorMatrixMethod_1 = __webpack_require__(241);
	exports.EffectColorMatrixMethod = EffectColorMatrixMethod_1.EffectColorMatrixMethod;
	var EffectColorTransformMethod_1 = __webpack_require__(242);
	exports.EffectColorTransformMethod = EffectColorTransformMethod_1.EffectColorTransformMethod;
	var EffectEnvMapMethod_1 = __webpack_require__(243);
	exports.EffectEnvMapMethod = EffectEnvMapMethod_1.EffectEnvMapMethod;
	var EffectFogMethod_1 = __webpack_require__(244);
	exports.EffectFogMethod = EffectFogMethod_1.EffectFogMethod;
	var EffectFresnelEnvMapMethod_1 = __webpack_require__(245);
	exports.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod_1.EffectFresnelEnvMapMethod;
	var EffectLightMapMethod_1 = __webpack_require__(246);
	exports.EffectLightMapMethod = EffectLightMapMethod_1.EffectLightMapMethod;
	var EffectMethodBase_1 = __webpack_require__(240);
	exports.EffectMethodBase = EffectMethodBase_1.EffectMethodBase;
	var EffectProjectiveTextureMethod_1 = __webpack_require__(247);
	exports.EffectProjectiveTextureMethod = EffectProjectiveTextureMethod_1.EffectProjectiveTextureMethod;
	var EffectRefractionEnvMapMethod_1 = __webpack_require__(248);
	exports.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod_1.EffectRefractionEnvMapMethod;
	var EffectRimLightMethod_1 = __webpack_require__(249);
	exports.EffectRimLightMethod = EffectRimLightMethod_1.EffectRimLightMethod;
	var LightingMethodBase_1 = __webpack_require__(231);
	exports.LightingMethodBase = LightingMethodBase_1.LightingMethodBase;
	var NormalBasicMethod_1 = __webpack_require__(250);
	exports.NormalBasicMethod = NormalBasicMethod_1.NormalBasicMethod;
	var NormalHeightMapMethod_1 = __webpack_require__(251);
	exports.NormalHeightMapMethod = NormalHeightMapMethod_1.NormalHeightMapMethod;
	var NormalSimpleWaterMethod_1 = __webpack_require__(252);
	exports.NormalSimpleWaterMethod = NormalSimpleWaterMethod_1.NormalSimpleWaterMethod;
	var ShadingMethodBase_1 = __webpack_require__(226);
	exports.ShadingMethodBase = ShadingMethodBase_1.ShadingMethodBase;
	var ShadowCascadeMethod_1 = __webpack_require__(253);
	exports.ShadowCascadeMethod = ShadowCascadeMethod_1.ShadowCascadeMethod;
	var ShadowDitheredMethod_1 = __webpack_require__(255);
	exports.ShadowDitheredMethod = ShadowDitheredMethod_1.ShadowDitheredMethod;
	var ShadowFilteredMethod_1 = __webpack_require__(257);
	exports.ShadowFilteredMethod = ShadowFilteredMethod_1.ShadowFilteredMethod;
	var ShadowHardMethod_1 = __webpack_require__(258);
	exports.ShadowHardMethod = ShadowHardMethod_1.ShadowHardMethod;
	var ShadowMapMethodBase_1 = __webpack_require__(254);
	exports.ShadowMapMethodBase = ShadowMapMethodBase_1.ShadowMapMethodBase;
	var ShadowMethodBase_1 = __webpack_require__(256);
	exports.ShadowMethodBase = ShadowMethodBase_1.ShadowMethodBase;
	var ShadowNearMethod_1 = __webpack_require__(259);
	exports.ShadowNearMethod = ShadowNearMethod_1.ShadowNearMethod;
	var ShadowSoftMethod_1 = __webpack_require__(260);
	exports.ShadowSoftMethod = ShadowSoftMethod_1.ShadowSoftMethod;
	var SpecularAnisotropicMethod_1 = __webpack_require__(262);
	exports.SpecularAnisotropicMethod = SpecularAnisotropicMethod_1.SpecularAnisotropicMethod;
	var SpecularBasicMethod_1 = __webpack_require__(263);
	exports.SpecularBasicMethod = SpecularBasicMethod_1.SpecularBasicMethod;
	var SpecularCelMethod_1 = __webpack_require__(264);
	exports.SpecularCelMethod = SpecularCelMethod_1.SpecularCelMethod;
	var SpecularCompositeMethod_1 = __webpack_require__(265);
	exports.SpecularCompositeMethod = SpecularCompositeMethod_1.SpecularCompositeMethod;
	var SpecularFresnelMethod_1 = __webpack_require__(266);
	exports.SpecularFresnelMethod = SpecularFresnelMethod_1.SpecularFresnelMethod;
	var SpecularPhongMethod_1 = __webpack_require__(267);
	exports.SpecularPhongMethod = SpecularPhongMethod_1.SpecularPhongMethod;


/***/ },
/* 225 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var ShadingMethodBase_1 = __webpack_require__(226);
	/**
	 * AmbientBasicMethod provides the default shading method for uniform ambient lighting.
	 */
	var AmbientBasicMethod = (function (_super) {
	    __extends(AmbientBasicMethod, _super);
	    /**
	     * Creates a new AmbientBasicMethod object.
	     */
	    function AmbientBasicMethod() {
	        _super.call(this);
	        this._alpha = 1;
	        this._colorR = 1;
	        this._colorG = 1;
	        this._colorB = 1;
	        this._strength = 1;
	    }
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._texture));
	            methodVO.textureGL = null;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iInitConstants = function (shader, methodVO) {
	        if (!methodVO.textureGL) {
	            this._color = shader.numLights ? 0xFFFFFF : methodVO.pass._surface.style.color;
	            this.updateColor();
	        }
	    };
	    Object.defineProperty(AmbientBasicMethod.prototype, "strength", {
	        /**
	         * The strength of the ambient reflection of the surface.
	         */
	        get: function () {
	            return this._strength;
	        },
	        set: function (value) {
	            if (this._strength == value)
	                return;
	            this._strength = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AmbientBasicMethod.prototype, "alpha", {
	        /**
	         * The alpha component of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            if (this._alpha == value)
	                return;
	            this._alpha = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AmbientBasicMethod.prototype, "texture", {
	        /**
	         * The texture to use to define the diffuse reflection color per texel.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.copyFrom = function (method) {
	        var m = method;
	        var b = m;
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        if (methodVO.textureGL) {
	            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	            if (shader.alphaThreshold > 0) {
	                var cutOffReg = registerCache.getFreeFragmentConstant();
	                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;
	                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" +
	                    "kil " + targetReg + ".w\n" +
	                    "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
	            }
	        }
	        else {
	            var ambientInputRegister = registerCache.getFreeFragmentConstant();
	            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;
	            code += "mov " + targetReg + ", " + ambientInputRegister + "\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (methodVO.textureGL) {
	            methodVO.textureGL.activate(methodVO.pass._render);
	            if (shader.alphaThreshold > 0)
	                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;
	        }
	        else {
	            var index = methodVO.fragmentConstantsIndex;
	            var data = shader.fragmentConstantData;
	            data[index] = this._colorR;
	            data[index + 1] = this._colorG;
	            data[index + 2] = this._colorB;
	            data[index + 3] = this._alpha;
	        }
	    };
	    AmbientBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (methodVO.textureGL)
	            methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Updates the ambient color data used by the render state.
	     */
	    AmbientBasicMethod.prototype.updateColor = function () {
	        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._strength;
	        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._strength;
	        this._colorB = (this._color & 0xff) / 0xff * this._strength;
	    };
	    return AmbientBasicMethod;
	}(ShadingMethodBase_1.ShadingMethodBase));
	exports.AmbientBasicMethod = AmbientBasicMethod;


/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var ShadingMethodEvent_1 = __webpack_require__(227);
	/**
	 * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
	 * the final shading program.
	 */
	var ShadingMethodBase = (function (_super) {
	    __extends(ShadingMethodBase, _super);
	    /**
	     * Create a new ShadingMethodBase object.
	     */
	    function ShadingMethodBase() {
	        _super.call(this);
	        this._textures = new Array();
	        this._owners = new Array();
	        this._counts = new Array();
	    }
	    Object.defineProperty(ShadingMethodBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return ShadingMethodBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadingMethodBase.prototype.iIsUsed = function (shader) {
	        return true;
	    };
	    /**
	     * Initializes the properties for a MethodVO, including register and texture indices.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iInitVO = function (shader, methodVO) {
	    };
	    /**
	     * Initializes unchanging shader constants using the data from a MethodVO.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iInitConstants = function (shader, methodVO) {
	    };
	    /**
	     * Indicates whether or not this method expects normals in tangent space. Override for object-space normals.
	     */
	    ShadingMethodBase.prototype.iUsesTangentSpace = function () {
	        return true;
	    };
	    /**
	     * Cleans up any resources used by the current object.
	     */
	    ShadingMethodBase.prototype.dispose = function () {
	    };
	    ShadingMethodBase.prototype.iAddOwner = function (owner) {
	        //a method can be used more than once in the same material, so we check for this
	        var index = this._owners.indexOf(owner);
	        if (index != -1) {
	            this._counts[index]++;
	        }
	        else {
	            this._owners.push(owner);
	            this._counts.push(1);
	            //add textures
	            var len = this._textures.length;
	            for (var i = 0; i < len; i++)
	                owner.addTexture(this._textures[i]);
	        }
	    };
	    ShadingMethodBase.prototype.iRemoveOwner = function (owner) {
	        var index = this._owners.indexOf(owner);
	        if (this._counts[index] != 1) {
	            this._counts[index]--;
	        }
	        else {
	            this._owners.splice(index, 1);
	            this._counts.splice(index, 1);
	            //remove textures
	            var len = this._textures.length;
	            for (var i = 0; i < len; i++)
	                owner.removeTexture(this._textures[i]);
	        }
	    };
	    /**
	     *
	     */
	    ShadingMethodBase.prototype.iAddTexture = function (texture) {
	        this._textures.push(texture);
	        var len = this._owners.length;
	        for (var i = 0; i < len; i++)
	            this._owners[i].addTexture(texture);
	    };
	    /**
	     *
	     */
	    ShadingMethodBase.prototype.iRemoveTexture = function (texture) {
	        this._textures.splice(this._textures.indexOf(texture), 1);
	        var len = this._owners.length;
	        for (var i = 0; i < len; i++)
	            this._owners[i].removeTexture(texture);
	    };
	    /**
	     * Resets the compilation state of the method.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iReset = function () {
	        this.iCleanCompilationData();
	    };
	    /**
	     * Resets the method's state for compilation.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iCleanCompilationData = function () {
	    };
	    /**
	     * Get the vertex shader code for this method.
	     * @param vo The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadingMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return null;
	    };
	    /**
	     * Sets the render state for this method.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param stage The Stage object currently used for rendering.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iActivate = function (shader, methodVO, stage) {
	    };
	    /**
	     * Sets the render state for a single renderable.
	     *
	     * @param vo The MethodVO object linking this method with the pass currently being compiled.
	     * @param renderable The renderable currently being rendered.
	     * @param stage The Stage object currently used for rendering.
	     * @param camera The camera from which the scene is currently rendered.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	    };
	    /**
	     * Clears the render state for this method.
	     * @param vo The MethodVO object linking this method with the pass currently being compiled.
	     * @param stage The Stage object currently used for rendering.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iDeactivate = function (shader, methodVO, stage) {
	    };
	    /**
	     * Marks the shader program as invalid, so it will be recompiled before the next render.
	     *
	     * @internal
	     */
	    ShadingMethodBase.prototype.iInvalidateShaderProgram = function () {
	        this.dispatchEvent(new ShadingMethodEvent_1.ShadingMethodEvent(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED));
	    };
	    /**
	     * Copies the state from a ShadingMethodBase object into the current object.
	     */
	    ShadingMethodBase.prototype.copyFrom = function (method) {
	    };
	    ShadingMethodBase.assetType = "[asset ShadingMethod]";
	    return ShadingMethodBase;
	}(AssetBase_1.AssetBase));
	exports.ShadingMethodBase = ShadingMethodBase;


/***/ },
/* 227 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var ShadingMethodEvent = (function (_super) {
	    __extends(ShadingMethodEvent, _super);
	    function ShadingMethodEvent(type) {
	        _super.call(this, type);
	    }
	    ShadingMethodEvent.SHADER_INVALIDATED = "ShaderInvalidated";
	    return ShadingMethodEvent;
	}(EventBase_1.EventBase));
	exports.ShadingMethodEvent = ShadingMethodEvent;


/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var AmbientBasicMethod_1 = __webpack_require__(225);
	/**
	 * AmbientEnvMapMethod provides a diffuse shading method that uses a diffuse irradiance environment map to
	 * approximate global lighting rather than lights.
	 */
	var AmbientEnvMapMethod = (function (_super) {
	    __extends(AmbientEnvMapMethod, _super);
	    /**
	     * Creates a new <code>AmbientEnvMapMethod</code> object.
	     *
	     * @param envMap The cube environment map to use for the ambient lighting.
	     */
	    function AmbientEnvMapMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    AmbientEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._texture));
	            methodVO.textureGL = null;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AmbientEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        return (this._texture) ? methodVO.textureGL._iGetFragmentCode(targetReg, regCache, sharedRegisters, sharedRegisters.normalFragment) : "";
	    };
	    return AmbientEnvMapMethod;
	}(AmbientBasicMethod_1.AmbientBasicMethod));
	exports.AmbientEnvMapMethod = AmbientEnvMapMethod;


/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var ShadingMethodBase_1 = __webpack_require__(226);
	/**
	 * AmbientBasicMethod provides the default shading method for uniform ambient lighting.
	 */
	var CurveBasicMethod = (function (_super) {
	    __extends(CurveBasicMethod, _super);
	    /**
	     * Creates a new AmbientBasicMethod object.
	     */
	    function CurveBasicMethod() {
	        _super.call(this);
	        this._color = 0xffffff;
	        this._alpha = 1;
	        this._colorR = 1;
	        this._colorG = 1;
	        this._colorB = 1;
	        this._ambient = 1;
	    }
	    /**
	     * @inheritDoc
	     */
	    CurveBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._texture));
	            methodVO.textureGL = null;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    CurveBasicMethod.prototype.iInitConstants = function (shader, methodVO) {
	        if (!methodVO.textureGL) {
	            this._color = methodVO.pass._surface.style.color;
	            this.updateColor();
	        }
	    };
	    Object.defineProperty(CurveBasicMethod.prototype, "ambient", {
	        /**
	         * The strength of the ambient reflection of the surface.
	         */
	        get: function () {
	            return this._ambient;
	        },
	        set: function (value) {
	            if (this._ambient == value)
	                return;
	            this._ambient = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CurveBasicMethod.prototype, "alpha", {
	        /**
	         * The alpha component of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            if (this._alpha == value)
	                return;
	            this._alpha = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CurveBasicMethod.prototype, "texture", {
	        /**
	         * The texture to use to define the diffuse reflection color per texel.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    CurveBasicMethod.prototype.copyFrom = function (method) {
	        var m = method;
	        var b = m;
	    };
	    /**
	     * @inheritDoc
	     */
	    /*
	    public iGeVertexCode(shader:ShaderBase, methodVO:MethodVO, targetReg:ShaderRegisterElement, registerCache:ShaderRegisterCache, sharedRegisters:ShaderRegisterData):string {
	        var code:string = "";
	        code = "mov " + sharedRegisters.uvVarying + " " + registerCache.uv +  " \n";
	    }*/
	    CurveBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var ambientInputRegister;
	        if (methodVO.textureGL) {
	            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	            if (shader.alphaThreshold > 0) {
	                var cutOffReg = registerCache.getFreeFragmentConstant();
	                methodVO.fragmentConstantsIndex = cutOffReg.index * 4;
	                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" +
	                    "kil " + targetReg + ".w\n" +
	                    "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
	            }
	        }
	        else {
	            ambientInputRegister = registerCache.getFreeFragmentConstant();
	            methodVO.fragmentConstantsIndex = ambientInputRegister.index * 4;
	            code += "mov " + targetReg + ", " + ambientInputRegister + "\n";
	        }
	        code = "mov " + targetReg + ", " + sharedRegisters.uvVarying + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    CurveBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (methodVO.textureGL) {
	            methodVO.textureGL.activate(methodVO.pass._render);
	            if (shader.alphaThreshold > 0)
	                shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = shader.alphaThreshold;
	        }
	        else {
	            var index = methodVO.fragmentConstantsIndex;
	            var data = shader.fragmentConstantData;
	            data[index] = this._colorR;
	            data[index + 1] = this._colorG;
	            data[index + 2] = this._colorB;
	            data[index + 3] = this._alpha;
	        }
	    };
	    CurveBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (methodVO.textureGL)
	            methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Updates the ambient color data used by the render state.
	     */
	    CurveBasicMethod.prototype.updateColor = function () {
	        this._colorR = ((this._color >> 16) & 0xff) / 0xff * this._ambient;
	        this._colorG = ((this._color >> 8) & 0xff) / 0xff * this._ambient;
	        this._colorB = (this._color & 0xff) / 0xff * this._ambient;
	    };
	    return CurveBasicMethod;
	}(ShadingMethodBase_1.ShadingMethodBase));
	exports.CurveBasicMethod = CurveBasicMethod;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = CurveBasicMethod;


/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var LightingMethodBase_1 = __webpack_require__(231);
	/**
	 * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.
	 */
	var DiffuseBasicMethod = (function (_super) {
	    __extends(DiffuseBasicMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     */
	    function DiffuseBasicMethod() {
	        _super.call(this);
	        this._multiply = true;
	        this._ambientColorR = 1;
	        this._ambientColorG = 1;
	        this._ambientColorB = 1;
	        this._color = 0xffffff;
	        this._colorR = 1;
	        this._colorG = 1;
	        this._colorB = 1;
	    }
	    DiffuseBasicMethod.prototype.iIsUsed = function (shader) {
	        if (!shader.numLights)
	            return false;
	        return true;
	    };
	    Object.defineProperty(DiffuseBasicMethod.prototype, "multiply", {
	        /**
	         * Set internally if diffuse color component multiplies or replaces the ambient color
	         */
	        get: function () {
	            return this._multiply;
	        },
	        set: function (value) {
	            if (this._multiply == value)
	                return;
	            this._multiply = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    DiffuseBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, null));
	            methodVO.textureGL = null;
	        }
	        if (shader.numLights > 0) {
	            shader.usesCommonData = true;
	            methodVO.needsNormals = true;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iInitConstants = function (shader, methodVO) {
	        if (shader.numLights > 0) {
	            this._ambientColor = methodVO.pass._surface.style.color;
	            this.updateAmbientColor();
	        }
	        else {
	            this._ambientColor = null;
	        }
	    };
	    Object.defineProperty(DiffuseBasicMethod.prototype, "color", {
	        /**
	         * The color of the diffuse reflection when not using a texture.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            if (this._color == value)
	                return;
	            this._color = value;
	            this.updateColor();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseBasicMethod.prototype, "texture", {
	        /**
	         * The texture to use to define the diffuse reflection color per texel.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.dispose = function () {
	        this._texture = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.copyFrom = function (method) {
	        var diff = method;
	        this.texture = diff.texture;
	        this.multiply = diff.multiply;
	        this.color = diff.color;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._pTotalLightColorReg = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = "";
	        this._pIsFirstLight = true;
	        registerCache.addFragmentTempUsages(this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "dp3 " + t + ".x, " + lightDirReg + ", " + sharedRegisters.normalFragment + "\n" +
	            "max " + t + ".w, " + t + ".x, " + sharedRegisters.commons + ".y\n";
	        if (shader.usesLightFallOff)
	            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ", " + t + ".w, " + lightColReg + "\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "tex " + t + ", " + sharedRegisters.normalFragment + ", " + cubeMapReg + " <cube,linear,miplinear>\n" +
	            "mul " + t + ".xyz, " + t + ".xyz, " + weightRegister + "\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var diffuseColor;
	        var cutOffReg;
	        // incorporate input from ambient
	        if (sharedRegisters.shadowTarget)
	            code += this.pApplyShadow(shader, methodVO, registerCache, sharedRegisters);
	        registerCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);
	        var ambientColorRegister = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = ambientColorRegister.index * 4;
	        if (this._texture) {
	            code += methodVO.textureGL._iGetFragmentCode(diffuseColor, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	        }
	        else {
	            var diffuseInputRegister = registerCache.getFreeFragmentConstant();
	            code += "mov " + diffuseColor + ", " + diffuseInputRegister + "\n";
	        }
	        code += "sat " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + "\n" +
	            "mul " + diffuseColor + ".xyz, " + diffuseColor + ", " + this._pTotalLightColorReg + "\n";
	        if (this._multiply) {
	            code += "add " + diffuseColor + ".xyz, " + diffuseColor + ", " + ambientColorRegister + "\n" +
	                "mul " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n";
	        }
	        else if (this._texture) {
	            code += "mul " + targetReg + ".xyz, " + targetReg + ", " + ambientColorRegister + "\n" +
	                "mul " + this._pTotalLightColorReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" +
	                "sub " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n" +
	                "add " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n"; //add diffuse color and ambient color
	        }
	        else {
	            code += "mul " + this._pTotalLightColorReg + ".xyz, " + ambientColorRegister + ", " + this._pTotalLightColorReg + "\n" +
	                "sub " + this._pTotalLightColorReg + ".xyz, " + ambientColorRegister + ", " + this._pTotalLightColorReg + "\n" +
	                "add " + diffuseColor + ".xyz, " + diffuseColor + ", " + this._pTotalLightColorReg + "\n" +
	                "mul " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n"; // multiply by target which could be texture or white
	        }
	        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
	        registerCache.removeFragmentTempUsage(diffuseColor);
	        return code;
	    };
	    /**
	     * Generate the code that applies the calculated shadow to the diffuse light
	     * @param methodVO The MethodVO object for which the compilation is currently happening.
	     * @param regCache The register cache the compiler is currently using for the register management.
	     */
	    DiffuseBasicMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {
	        return "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (this._texture) {
	            methodVO.textureGL.activate(methodVO.pass._render);
	        }
	        else {
	            var index = methodVO.fragmentConstantsIndex;
	            var data = shader.fragmentConstantData;
	            if (this._multiply) {
	                data[index + 4] = this._colorR * this._ambientColorR;
	                data[index + 5] = this._colorG * this._ambientColorG;
	                data[index + 6] = this._colorB * this._ambientColorB;
	            }
	            else {
	                data[index + 4] = this._colorR;
	                data[index + 5] = this._colorG;
	                data[index + 6] = this._colorB;
	            }
	            data[index + 7] = 1;
	        }
	    };
	    /**
	     * Updates the diffuse color data used by the render state.
	     */
	    DiffuseBasicMethod.prototype.updateColor = function () {
	        this._colorR = ((this._color >> 16) & 0xff) / 0xff;
	        this._colorG = ((this._color >> 8) & 0xff) / 0xff;
	        this._colorB = (this._color & 0xff) / 0xff;
	    };
	    /**
	     * Updates the ambient color data used by the render state.
	     */
	    DiffuseBasicMethod.prototype.updateAmbientColor = function () {
	        this._ambientColorR = ((this._ambientColor >> 16) & 0xff) / 0xff;
	        this._ambientColorG = ((this._ambientColor >> 8) & 0xff) / 0xff;
	        this._ambientColorB = (this._ambientColor & 0xff) / 0xff;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (this._texture)
	            methodVO.textureGL._setRenderState(renderable);
	        //TODO move this to Activate (ambientR/G/B currently calc'd in render state)
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = shader.ambientR * this._ambientColorR;
	        data[index + 1] = shader.ambientG * this._ambientColorG;
	        data[index + 2] = shader.ambientB * this._ambientColorB;
	        data[index + 3] = 1;
	    };
	    return DiffuseBasicMethod;
	}(LightingMethodBase_1.LightingMethodBase));
	exports.DiffuseBasicMethod = DiffuseBasicMethod;


/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodBase_1 = __webpack_require__(226);
	/**
	 * LightingMethodBase provides an abstract base method for shading methods that uses lights.
	 * Used for diffuse and specular shaders only.
	 */
	var LightingMethodBase = (function (_super) {
	    __extends(LightingMethodBase, _super);
	    /**
	     * Creates a new LightingMethodBase.
	     */
	    function LightingMethodBase() {
	        _super.call(this);
	    }
	    /**
	     * Get the fragment shader code that will be needed before any per-light code is added.
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param regCache The register cache used during the compilation.
	     * @private
	     */
	    LightingMethodBase.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * Get the fragment shader code that will generate the code relevant to a single light.
	     *
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param lightDirReg The register containing the light direction vector.
	     * @param lightColReg The register containing the light colour.
	     * @param regCache The register cache used during the compilation.
	     */
	    LightingMethodBase.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * Get the fragment shader code that will generate the code relevant to a single light probe object.
	     *
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param cubeMapReg The register containing the cube map for the current probe
	     * @param weightRegister A string representation of the register + component containing the current weight
	     * @param regCache The register cache providing any necessary registers to the shader
	     */
	    LightingMethodBase.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        return "";
	    };
	    /**
	     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
	     *
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register containing the final shading output.
	     * @private
	     */
	    LightingMethodBase.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return "";
	    };
	    return LightingMethodBase;
	}(ShadingMethodBase_1.ShadingMethodBase));
	exports.LightingMethodBase = LightingMethodBase;


/***/ },
/* 232 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseCompositeMethod_1 = __webpack_require__(233);
	/**
	 * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.
	 */
	var DiffuseCelMethod = (function (_super) {
	    __extends(DiffuseCelMethod, _super);
	    /**
	     * Creates a new DiffuseCelMethod object.
	     * @param levels The amount of shadow gradations.
	     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.
	     */
	    function DiffuseCelMethod(levels, baseMethod) {
	        var _this = this;
	        if (levels === void 0) { levels = 3; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this, null, baseMethod);
	        this._smoothness = .1;
	        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampDiffuse(shader, methodVO, targetReg, registerCache, sharedRegisters); };
	        this._levels = levels;
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        data[index + 1] = 1;
	        data[index + 2] = 0;
	    };
	    Object.defineProperty(DiffuseCelMethod.prototype, "levels", {
	        /**
	         * The amount of shadow gradations.
	         */
	        get: function () {
	            return this._levels;
	        },
	        set: function (value /*uint*/) {
	            this._levels = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseCelMethod.prototype, "smoothness", {
	        /**
	         * The smoothness of the edge between 2 shading levels.
	         */
	        get: function () {
	            return this._smoothness;
	        },
	        set: function (value) {
	            this._smoothness = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._dataReg = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        this._dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
	        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCelMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        data[index] = this._levels;
	        data[index + 3] = this._smoothness;
	    };
	    /**
	     * Snaps the diffuse shading of the wrapped method to one of the levels.
	     * @param vo The MethodVO used to compile the current shader.
	     * @param t The register containing the diffuse strength in the "w" component.
	     * @param regCache The register cache used for the shader compilation.
	     * @param sharedRegisters The shared register data for this shader.
	     * @return The AGAL fragment code for the method.
	     */
	    DiffuseCelMethod.prototype.clampDiffuse = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return "mul " + targetReg + ".w, " + targetReg + ".w, " + this._dataReg + ".x\n" +
	            "frc " + targetReg + ".z, " + targetReg + ".w\n" +
	            "sub " + targetReg + ".y, " + targetReg + ".w, " + targetReg + ".z\n" +
	            "mov " + targetReg + ".x, " + this._dataReg + ".x\n" +
	            "sub " + targetReg + ".x, " + targetReg + ".x, " + this._dataReg + ".y\n" +
	            "rcp " + targetReg + ".x," + targetReg + ".x\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".y, " + targetReg + ".x\n" +
	            // previous clamped strength
	            "sub " + targetReg + ".y, " + targetReg + ".w, " + targetReg + ".x\n" +
	            // fract/epsilon (so 0 - epsilon will become 0 - 1)
	            "div " + targetReg + ".z, " + targetReg + ".z, " + this._dataReg + ".w\n" +
	            "sat " + targetReg + ".z, " + targetReg + ".z\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".z\n" +
	            // 1-z
	            "sub " + targetReg + ".z, " + this._dataReg + ".y, " + targetReg + ".z\n" +
	            "mul " + targetReg + ".y, " + targetReg + ".y, " + targetReg + ".z\n" +
	            "add " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n" +
	            "sat " + targetReg + ".w, " + targetReg + ".w\n";
	    };
	    return DiffuseCelMethod;
	}(DiffuseCompositeMethod_1.DiffuseCompositeMethod));
	exports.DiffuseCelMethod = DiffuseCelMethod;


/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodEvent_1 = __webpack_require__(227);
	var DiffuseBasicMethod_1 = __webpack_require__(230);
	/**
	 * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
	 * calculated diffuse reflection strength.
	 */
	var DiffuseCompositeMethod = (function (_super) {
	    __extends(DiffuseCompositeMethod, _super);
	    /**
	     * Creates a new <code>DiffuseCompositeMethod</code> object.
	     *
	     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.
	     * @param baseMethod The base diffuse method on which this method's shading is based.
	     */
	    function DiffuseCompositeMethod(modulateMethod, baseMethod) {
	        var _this = this;
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this);
	        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
	        this.pBaseMethod = baseMethod || new DiffuseBasicMethod_1.DiffuseBasicMethod();
	        this.pBaseMethod._iModulateMethod = modulateMethod;
	        this.pBaseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    }
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "baseMethod", {
	        /**
	         * The base diffuse method on which this method's shading is based.
	         */
	        get: function () {
	            return this.pBaseMethod;
	        },
	        set: function (value) {
	            if (this.pBaseMethod == value)
	                return;
	            this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.pBaseMethod = value;
	            this.pBaseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iInitVO = function (shader, methodVO) {
	        this.pBaseMethod.iInitVO(shader, methodVO);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {
	        this.pBaseMethod.iInitConstants(shader, methodVO);
	    };
	    DiffuseCompositeMethod.prototype.iAddOwner = function (owner) {
	        _super.prototype.iAddOwner.call(this, owner);
	        this.pBaseMethod.iAddOwner(owner);
	    };
	    DiffuseCompositeMethod.prototype.iRemoveOwner = function (owner) {
	        _super.prototype.iRemoveOwner.call(this, owner);
	        this.pBaseMethod.iRemoveOwner(owner);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.dispose = function () {
	        this.pBaseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	        this.pBaseMethod.dispose();
	    };
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "texture", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.pBaseMethod.texture;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this.pBaseMethod.texture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "color", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.pBaseMethod.color;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this.pBaseMethod.color = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseCompositeMethod.prototype, "multiply", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this.pBaseMethod.multiply;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this.pBaseMethod.multiply = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this.pBaseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = this.pBaseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);
	        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        var code = this.pBaseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);
	        this._pTotalLightColorReg = this.pBaseMethod._pTotalLightColorReg;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        this.pBaseMethod.iActivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        this.pBaseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {
	        this.pBaseMethod.iDeactivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this.pBaseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return this.pBaseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iReset = function () {
	        this.pBaseMethod.iReset();
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseCompositeMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this.pBaseMethod.iCleanCompilationData();
	    };
	    /**
	     * Called when the base method's shader code is invalidated.
	     */
	    DiffuseCompositeMethod.prototype.onShaderInvalidated = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    return DiffuseCompositeMethod;
	}(DiffuseBasicMethod_1.DiffuseBasicMethod));
	exports.DiffuseCompositeMethod = DiffuseCompositeMethod;


/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseBasicMethod_1 = __webpack_require__(230);
	/**
	 * DiffuseDepthMethod provides a debug method to visualise depth maps
	 */
	var DiffuseDepthMethod = (function (_super) {
	    __extends(DiffuseDepthMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     */
	    function DiffuseDepthMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseDepthMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index] = 1.0;
	        data[index + 1] = 1 / 255.0;
	        data[index + 2] = 1 / 65025.0;
	        data[index + 3] = 1 / 16581375.0;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseDepthMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var temp;
	        var decReg;
	        if (!this._texture)
	            throw new Error("DiffuseDepthMethod requires texture!");
	        // incorporate input from ambient
	        if (shader.numLights > 0) {
	            if (sharedRegisters.shadowTarget)
	                code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + sharedRegisters.shadowTarget + ".w\n";
	            code += "add " + targetReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + targetReg + ".xyz\n" +
	                "sat " + targetReg + ".xyz, " + targetReg + ".xyz\n";
	            registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
	            registerCache.addFragmentTempUsages(temp = registerCache.getFreeFragmentVectorTemp(), 1);
	        }
	        else {
	            temp = targetReg;
	        }
	        decReg = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        code += methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
	            "dp4 " + temp + ".x, " + temp + ", " + decReg + "\n" +
	            "mov " + temp + ".yz, " + temp + ".xx			\n" +
	            "mov " + temp + ".w, " + decReg + ".x\n" +
	            "sub " + temp + ".xyz, " + decReg + ".xxx, " + temp + ".xyz\n";
	        if (shader.numLights == 0)
	            return code;
	        code += "mul " + targetReg + ".xyz, " + temp + ".xyz, " + targetReg + ".xyz\n" +
	            "mov " + targetReg + ".w, " + temp + ".w\n";
	        if (shader.numLights > 0)
	            registerCache.removeFragmentTempUsage(temp);
	        return code;
	    };
	    return DiffuseDepthMethod;
	}(DiffuseBasicMethod_1.DiffuseBasicMethod));
	exports.DiffuseDepthMethod = DiffuseDepthMethod;


/***/ },
/* 235 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseBasicMethod_1 = __webpack_require__(230);
	/**
	 * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient
	 * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude
	 * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate
	 * scattered light within the skin attributing to the final colour)
	 */
	var DiffuseGradientMethod = (function (_super) {
	    __extends(DiffuseGradientMethod, _super);
	    /**
	     * Creates a new DiffuseGradientMethod object.
	     * @param gradient A texture that contains the light colour based on the angle. This can be used to change
	     * the light colour due to subsurface scattering when the surface faces away from the light.
	     */
	    function DiffuseGradientMethod(gradient) {
	        _super.call(this);
	        this._gradient = gradient;
	        if (this._gradient)
	            this.iAddTexture(this._gradient);
	    }
	    DiffuseGradientMethod.prototype.iInitVO = function (shader, methodVO) {
	        _super.prototype.iInitVO.call(this, shader, methodVO);
	        methodVO.secondaryTextureGL = shader.getAbstraction(this._gradient);
	    };
	    Object.defineProperty(DiffuseGradientMethod.prototype, "gradient", {
	        /**
	         * A texture that contains the light colour based on the angle. This can be used to change the light colour
	         * due to subsurface scattering when the surface faces away from the light.
	         */
	        get: function () {
	            return this._gradient;
	        },
	        set: function (value) {
	            if (this._gradient == value)
	                return;
	            if (this._gradient)
	                this.iRemoveTexture(this._gradient);
	            this._gradient = value;
	            if (this._gradient)
	                this.iAddTexture(this._gradient);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	        this._pIsFirstLight = true;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight)
	            t = this._pTotalLightColorReg;
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "dp3 " + t + ".w, " + lightDirReg + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "mul " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".x\n" +
	            "add " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".x\n" +
	            "mul " + t + ".xyz, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += methodVO.secondaryTextureGL._iGetFragmentCode(t, registerCache, sharedRegisters, t) +
	            //					"mul " + t + ".xyz, " + t + ".xyz, " + t + ".w\n" +
	            "mul " + t + ".xyz, " + t + ".xyz, " + lightColReg + ".xyz\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.pApplyShadow = function (shader, methodVO, regCache, sharedRegisters) {
	        var t = regCache.getFreeFragmentVectorTemp();
	        return "mov " + t + ", " + sharedRegisters.shadowTarget + ".wwww\n" +
	            methodVO.secondaryTextureGL._iGetFragmentCode(t, regCache, sharedRegisters, sharedRegisters.uvVarying) +
	            "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseGradientMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        if (shader.numLights > 0)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    return DiffuseGradientMethod;
	}(DiffuseBasicMethod_1.DiffuseBasicMethod));
	exports.DiffuseGradientMethod = DiffuseGradientMethod;


/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseCompositeMethod_1 = __webpack_require__(233);
	/**
	 * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse
	 * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather
	 * than only the diffuse lighting value.
	 */
	var DiffuseLightMapMethod = (function (_super) {
	    __extends(DiffuseLightMapMethod, _super);
	    /**
	     * Creates a new DiffuseLightMapMethod method.
	     *
	     * @param lightMap The texture containing the light map.
	     * @param blendMode The blend mode with which the light map should be applied to the lighting result.
	     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
	     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.
	     */
	    function DiffuseLightMapMethod(lightMap, blendMode, useSecondaryUV, baseMethod) {
	        if (blendMode === void 0) { blendMode = "multiply"; }
	        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this, null, baseMethod);
	        this._useSecondaryUV = useSecondaryUV;
	        this._lightMap = lightMap;
	        this.blendMode = blendMode;
	        if (this._lightMap)
	            this.iAddTexture(this._lightMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.secondaryTextureGL = shader.getAbstraction(this._lightMap);
	        if (this._useSecondaryUV)
	            shader.secondaryUVDependencies++;
	        else
	            shader.uvDependencies++;
	    };
	    Object.defineProperty(DiffuseLightMapMethod.prototype, "blendMode", {
	        /**
	         * The blend mode with which the light map should be applied to the lighting result.
	         *
	         * @see DiffuseLightMapMethod.ADD
	         * @see DiffuseLightMapMethod.MULTIPLY
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        set: function (value) {
	            if (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)
	                throw new Error("Unknown blendmode!");
	            if (this._blendMode == value)
	                return;
	            this._blendMode = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseLightMapMethod.prototype, "lightMap", {
	        /**
	         * The texture containing the light map data.
	         */
	        get: function () {
	            return this._lightMap;
	        },
	        set: function (value) {
	            if (this._lightMap == value)
	                return;
	            if (this._lightMap)
	                this.iRemoveTexture(this._lightMap);
	            this._lightMap = value;
	            if (this._lightMap)
	                this.iAddTexture(this._lightMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseLightMapMethod.prototype, "useSecondaryUV", {
	        /**
	         * Indicates whether the secondary UV set should be used to map the light map.
	         */
	        get: function () {
	            return this._useSecondaryUV;
	        },
	        set: function (value) {
	            if (this._useSecondaryUV == value)
	                return;
	            this._useSecondaryUV = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);
	        switch (this._blendMode) {
	            case DiffuseLightMapMethod.MULTIPLY:
	                code += "mul " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + ", " + temp + "\n";
	                break;
	            case DiffuseLightMapMethod.ADD:
	                code += "add " + this._pTotalLightColorReg + ", " + this._pTotalLightColorReg + ", " + temp + "\n";
	                break;
	        }
	        code += _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * Indicates the light map should be multiplied with the calculated shading result.
	     * This can be used to add pre-calculated shadows or occlusion.
	     */
	    DiffuseLightMapMethod.MULTIPLY = "multiply";
	    /**
	     * Indicates the light map should be added into the calculated shading result.
	     * This can be used to add pre-calculated lighting or global illumination.
	     */
	    DiffuseLightMapMethod.ADD = "add";
	    return DiffuseLightMapMethod;
	}(DiffuseCompositeMethod_1.DiffuseCompositeMethod));
	exports.DiffuseLightMapMethod = DiffuseLightMapMethod;


/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseCompositeMethod_1 = __webpack_require__(233);
	/**
	 * DiffuseSubSurfaceMethod provides a depth map-based diffuse shading method that mimics the scattering of
	 * light inside translucent surfaces. It allows light to shine through an object and to soften the diffuse shading.
	 * It can be used for candle wax, ice, skin, ...
	 */
	var DiffuseSubSurfaceMethod = (function (_super) {
	    __extends(DiffuseSubSurfaceMethod, _super);
	    /**
	     * Creates a new <code>DiffuseSubSurfaceMethod</code> object.
	     *
	     * @param depthMapSize The size of the depth map used.
	     * @param depthMapOffset The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
	     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.
	     */
	    function DiffuseSubSurfaceMethod(depthMapSize, depthMapOffset, baseMethod) {
	        var _this = this;
	        if (depthMapSize === void 0) { depthMapSize = 512; }
	        if (depthMapOffset === void 0) { depthMapOffset = 15; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this, null, baseMethod);
	        this._translucency = 1;
	        this._scatterColor = 0xffffff;
	        this._scatterR = 1.0;
	        this._scatterG = 1.0;
	        this._scatterB = 1.0;
	        this.pBaseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.scatterLight(shader, methodVO, targetReg, registerCache, sharedRegisters); };
	        //this._passes = new Array<MaterialPassGLBase>();
	        //this._depthPass = new SingleObjectDepthPass();
	        //this._depthPass.textureSize = depthMapSize;
	        //this._depthPass.polyOffset = depthMapOffset;
	        //this._passes.push(this._depthPass);
	        this._scattering = 0.2;
	        this._translucency = 1;
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseSubSurfaceMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        var data = shader.vertexConstantData;
	        var index = methodVO.secondaryVertexConstantsIndex;
	        data[index] = .5;
	        data[index + 1] = -.5;
	        data[index + 2] = 0;
	        data[index + 3] = 1;
	        data = shader.fragmentConstantData;
	        index = methodVO.secondaryFragmentConstantsIndex;
	        data[index + 3] = 1.0;
	        data[index + 4] = 1.0;
	        data[index + 5] = 1 / 255;
	        data[index + 6] = 1 / 65025;
	        data[index + 7] = 1 / 16581375;
	        data[index + 10] = .5;
	        data[index + 11] = -.1;
	    };
	    DiffuseSubSurfaceMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._lightProjVarying = null;
	        this._propReg = null;
	        this._lightColorReg = null;
	        this._colorReg = null;
	        this._decReg = null;
	        this._targetReg = null;
	    };
	    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, "scattering", {
	        /**
	         * The amount by which the light scatters. It can be used to set the translucent surface's thickness. Use low
	         * values for skin.
	         */
	        get: function () {
	            return this._scattering;
	        },
	        set: function (value) {
	            this._scattering = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, "translucency", {
	        /**
	         * The translucency of the object.
	         */
	        get: function () {
	            return this._translucency;
	        },
	        set: function (value) {
	            this._translucency = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DiffuseSubSurfaceMethod.prototype, "scatterColor", {
	        /**
	         * The colour of the "insides" of the object, ie: the colour the light becomes after leaving the object.
	         */
	        get: function () {
	            return this._scatterColor;
	        },
	        set: function (scatterColor /*uint*/) {
	            this._scatterColor = scatterColor;
	            this._scatterR = ((scatterColor >> 16) & 0xff) / 0xff;
	            this._scatterG = ((scatterColor >> 8) & 0xff) / 0xff;
	            this._scatterB = (scatterColor & 0xff) / 0xff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseSubSurfaceMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = _super.prototype.iGetVertexCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	        var lightProjection;
	        var toTexRegister;
	        var temp = registerCache.getFreeVertexVectorTemp();
	        toTexRegister = registerCache.getFreeVertexConstant();
	        methodVO.secondaryVertexConstantsIndex = toTexRegister.index * 4;
	        this._lightProjVarying = registerCache.getFreeVarying();
	        lightProjection = registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        code += "m44 " + temp + ", vt0, " + lightProjection + "\n" +
	            "div " + temp + ".xyz, " + temp + ".xyz, " + temp + ".w\n" +
	            "mul " + temp + ".xy, " + temp + ".xy, " + toTexRegister + ".xy\n" +
	            "add " + temp + ".xy, " + temp + ".xy, " + toTexRegister + ".xx\n" +
	            "mov " + this._lightProjVarying + ".xyz, " + temp + ".xyz\n" +
	            "mov " + this._lightProjVarying + ".w, va0.w\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseSubSurfaceMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        this._colorReg = registerCache.getFreeFragmentConstant();
	        this._decReg = registerCache.getFreeFragmentConstant();
	        this._propReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._colorReg.index * 4;
	        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseSubSurfaceMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        this._pIsFirstLight = true;
	        this._lightColorReg = lightColReg;
	        return _super.prototype.iGetFragmentCodePerLight.call(this, shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseSubSurfaceMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = _super.prototype.iGetFragmentPostLightingCode.call(this, shader, methodVO, targetReg, registerCache, sharedRegisters);
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code += "mul " + temp + ".xyz, " + this._lightColorReg + ".xyz, " + this._targetReg + ".w\n" +
	            "mul " + temp + ".xyz, " + temp + ".xyz, " + this._colorReg + ".xyz\n" +
	            "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
	        if (this._targetReg != sharedRegisters.viewDirFragment)
	            registerCache.removeFragmentTempUsage(targetReg);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseSubSurfaceMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._scatterR;
	        data[index + 1] = this._scatterG;
	        data[index + 2] = this._scatterB;
	        data[index + 8] = this._scattering;
	        data[index + 9] = this._translucency;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseSubSurfaceMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.secondaryTextureGL = shader.getAbstraction(this._depthPass._iGetDepthMap(renderable));
	        methodVO.secondaryTextureGL._setRenderState(renderable);
	        this._depthPass._iGetProjection(renderable).copyRawDataTo(shader.vertexConstantData, methodVO.secondaryVertexConstantsIndex + 4, true);
	    };
	    /**
	     * Generates the code for this method
	     */
	    DiffuseSubSurfaceMethod.prototype.scatterLight = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        // only scatter first light
	        if (!this._pIsFirstLight)
	            return "";
	        this._pIsFirstLight = false;
	        var code = "";
	        if (sharedRegisters.viewDirFragment)
	            this._targetReg = sharedRegisters.viewDirFragment;
	        else
	            registerCache.addFragmentTempUsages(this._targetReg = registerCache.getFreeFragmentVectorTemp(), 1);
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._lightProjVarying) +
	            // reencode RGBA
	            "dp4 " + targetReg + ".z, " + temp + ", " + this._decReg + "\n";
	        // currentDistanceToLight - closestDistanceToLight
	        code += "sub " + targetReg + ".z, " + this._lightProjVarying + ".z, " + targetReg + ".z\n" +
	            "sub " + targetReg + ".z, " + this._propReg + ".x, " + targetReg + ".z\n" +
	            "mul " + targetReg + ".z, " + this._propReg + ".y, " + targetReg + ".z\n" +
	            "sat " + targetReg + ".z, " + targetReg + ".z\n" +
	            // targetReg.x contains dot(lightDir, normal)
	            // modulate according to incident light angle (scatter = scatter*(-.5*dot(light, normal) + .5)
	            "neg " + targetReg + ".y, " + targetReg + ".x\n" +
	            "mul " + targetReg + ".y, " + targetReg + ".y, " + this._propReg + ".z\n" +
	            "add " + targetReg + ".y, " + targetReg + ".y, " + this._propReg + ".z\n" +
	            "mul " + this._targetReg + ".w, " + targetReg + ".z, " + targetReg + ".y\n" +
	            // blend diffuse: d' = (1-s)*d + s*1
	            "sub " + targetReg + ".y, " + this._colorReg + ".w, " + this._targetReg + ".w\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";
	        return code;
	    };
	    return DiffuseSubSurfaceMethod;
	}(DiffuseCompositeMethod_1.DiffuseCompositeMethod));
	exports.DiffuseSubSurfaceMethod = DiffuseSubSurfaceMethod;


/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DiffuseBasicMethod_1 = __webpack_require__(230);
	/**
	 * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be "wrapped around" the normally dark area, to some extent.
	 * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.
	 */
	var DiffuseWrapMethod = (function (_super) {
	    __extends(DiffuseWrapMethod, _super);
	    /**
	     * Creates a new DiffuseWrapMethod object.
	     * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap
	     */
	    function DiffuseWrapMethod(wrapFactor) {
	        if (wrapFactor === void 0) { wrapFactor = .5; }
	        _super.call(this);
	        this.wrapFactor = wrapFactor;
	    }
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._wrapDataRegister = null;
	    };
	    Object.defineProperty(DiffuseWrapMethod.prototype, "wrapFactor", {
	        /**
	         * A factor to indicate the amount by which the light is allowed to wrap.
	         */
	        get: function () {
	            return this._wrapFactor;
	        },
	        set: function (value) {
	            this._wrapFactor = value;
	            this._wrapFactor = 1 / (value + 1);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	        this._pIsFirstLight = true;
	        this._wrapDataRegister = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._wrapDataRegister.index * 4;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        code += "dp3 " + t + ".x, " + lightDirReg + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "add " + t + ".y, " + t + ".x, " + this._wrapDataRegister + ".x\n" +
	            "mul " + t + ".y, " + t + ".y, " + this._wrapDataRegister + ".y\n" +
	            "sat " + t + ".w, " + t + ".y\n" +
	            "mul " + t + ".xz, " + t + ".w, " + lightDirReg + ".wz\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, lightDirReg, registerCache, sharedRegisters);
	        code += "mul " + t + ", " + t + ".x, " + lightColReg + "\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    DiffuseWrapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._wrapFactor;
	        data[index + 1] = 1 / (this._wrapFactor + 1);
	    };
	    return DiffuseWrapMethod;
	}(DiffuseBasicMethod_1.DiffuseBasicMethod));
	exports.DiffuseWrapMethod = DiffuseWrapMethod;


/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used
	 * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water
	 * etc).
	 */
	var EffectAlphaMaskMethod = (function (_super) {
	    __extends(EffectAlphaMaskMethod, _super);
	    /**
	     * Creates a new EffectAlphaMaskMethod object.
	     *
	     * @param texture The texture to use as the alpha mask.
	     * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.
	     */
	    function EffectAlphaMaskMethod(texture, useSecondaryUV) {
	        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
	        _super.call(this);
	        this._texture = texture;
	        this._useSecondaryUV = useSecondaryUV;
	        if (this._texture)
	            this.iAddTexture(this._texture);
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectAlphaMaskMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.textureGL = shader.getAbstraction(this._texture);
	        if (this._useSecondaryUV)
	            shader.secondaryUVDependencies++;
	        else
	            shader.uvDependencies++;
	    };
	    Object.defineProperty(EffectAlphaMaskMethod.prototype, "useSecondaryUV", {
	        /**
	         * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for
	         * instance to tile the main texture and normal map while providing untiled alpha, for example to define the
	         * transparency over a tiled water surface.
	         */
	        get: function () {
	            return this._useSecondaryUV;
	        },
	        set: function (value) {
	            if (this._useSecondaryUV == value)
	                return;
	            this._useSecondaryUV = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectAlphaMaskMethod.prototype, "texture", {
	        /**
	         * The texture to use as the alpha mask.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectAlphaMaskMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +
	            "mul " + targetReg + ", " + targetReg + ", " + temp + ".x\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectAlphaMaskMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    EffectAlphaMaskMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    return EffectAlphaMaskMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectAlphaMaskMethod = EffectAlphaMaskMethod;


/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var ShadingMethodBase_1 = __webpack_require__(226);
	/**
	 * EffectMethodBase forms an abstract base class for shader methods that are not dependent on light sources,
	 * and are in essence post-process effects on the materials.
	 */
	var EffectMethodBase = (function (_super) {
	    __extends(EffectMethodBase, _super);
	    function EffectMethodBase() {
	        _super.call(this);
	    }
	    Object.defineProperty(EffectMethodBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return EffectMethodBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Get the fragment shader code that should be added after all per-light code. Usually composits everything to the target register.
	     * @param methodVO The MethodVO object containing the method data for the currently compiled material pass.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register that will be containing the method's output.
	     * @private
	     */
	    EffectMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    EffectMethodBase.assetType = "[asset EffectMethod]";
	    return EffectMethodBase;
	}(ShadingMethodBase_1.ShadingMethodBase));
	exports.EffectMethodBase = EffectMethodBase;


/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.
	 */
	var EffectColorMatrixMethod = (function (_super) {
	    __extends(EffectColorMatrixMethod, _super);
	    /**
	     * Creates a new EffectColorTransformMethod.
	     *
	     * @param matrix An array of 20 items for 4 x 5 color transform.
	     */
	    function EffectColorMatrixMethod(matrix) {
	        _super.call(this);
	        if (matrix.length != 20)
	            throw new Error("Matrix length must be 20!");
	        this._matrix = matrix;
	    }
	    Object.defineProperty(EffectColorMatrixMethod.prototype, "colorMatrix", {
	        /**
	         * The 4 x 5 matrix to transform the color of the material.
	         */
	        get: function () {
	            return this._matrix;
	        },
	        set: function (value) {
	            this._matrix = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectColorMatrixMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var colorMultReg = registerCache.getFreeFragmentConstant();
	        registerCache.getFreeFragmentConstant();
	        registerCache.getFreeFragmentConstant();
	        registerCache.getFreeFragmentConstant();
	        var colorOffsetReg = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code += "m44 " + temp + ", " + targetReg + ", " + colorMultReg + "\n" +
	            "add " + targetReg + ", " + temp + ", " + colorOffsetReg + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectColorMatrixMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var matrix = this._matrix;
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        // r
	        data[index] = matrix[0];
	        data[index + 1] = matrix[1];
	        data[index + 2] = matrix[2];
	        data[index + 3] = matrix[3];
	        // g
	        data[index + 4] = matrix[5];
	        data[index + 5] = matrix[6];
	        data[index + 6] = matrix[7];
	        data[index + 7] = matrix[8];
	        // b
	        data[index + 8] = matrix[10];
	        data[index + 9] = matrix[11];
	        data[index + 10] = matrix[12];
	        data[index + 11] = matrix[13];
	        // a
	        data[index + 12] = matrix[15];
	        data[index + 13] = matrix[16];
	        data[index + 14] = matrix[17];
	        data[index + 15] = matrix[18];
	        // rgba offset
	        data[index + 16] = matrix[4];
	        data[index + 17] = matrix[9];
	        data[index + 18] = matrix[14];
	        data[index + 19] = matrix[19];
	    };
	    return EffectColorMatrixMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectColorMatrixMethod = EffectColorMatrixMethod;


/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a
	 * ColorTransform object.
	 */
	var EffectColorTransformMethod = (function (_super) {
	    __extends(EffectColorTransformMethod, _super);
	    /**
	     * Creates a new EffectColorTransformMethod.
	     */
	    function EffectColorTransformMethod() {
	        _super.call(this);
	    }
	    Object.defineProperty(EffectColorTransformMethod.prototype, "colorTransform", {
	        /**
	         * The ColorTransform object to transform the colour of the material with.
	         */
	        get: function () {
	            return this._colorTransform;
	        },
	        set: function (value) {
	            this._colorTransform = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectColorTransformMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var colorMultReg = registerCache.getFreeFragmentConstant();
	        var colorOffsReg = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = colorMultReg.index * 4;
	        //TODO: AGAL <> GLSL
	        code += "mul " + targetReg + ", " + targetReg + ", " + colorMultReg + "\n" + "add " + targetReg + ", " + targetReg + ", " + colorOffsReg + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectColorTransformMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var inv = 1 / 0xff;
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._colorTransform.redMultiplier;
	        data[index + 1] = this._colorTransform.greenMultiplier;
	        data[index + 2] = this._colorTransform.blueMultiplier;
	        data[index + 3] = this._colorTransform.alphaMultiplier;
	        data[index + 4] = this._colorTransform.redOffset * inv;
	        data[index + 5] = this._colorTransform.greenOffset * inv;
	        data[index + 6] = this._colorTransform.blueOffset * inv;
	        data[index + 7] = this._colorTransform.alphaOffset * inv;
	    };
	    return EffectColorTransformMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectColorTransformMethod = EffectColorTransformMethod;


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.
	 */
	var EffectEnvMapMethod = (function (_super) {
	    __extends(EffectEnvMapMethod, _super);
	    /**
	     * Creates an EffectEnvMapMethod object.
	     * @param envMap The environment map containing the reflected scene.
	     * @param alpha The reflectivity of the surface.
	     */
	    function EffectEnvMapMethod(envMap, alpha) {
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this);
	        this._envMap = envMap;
	        this._alpha = alpha;
	        if (this._envMap)
	            this.iAddTexture(this._envMap);
	    }
	    Object.defineProperty(EffectEnvMapMethod.prototype, "mask", {
	        /**
	         * An optional texture to modulate the reflectivity of the surface.
	         */
	        get: function () {
	            return this._mask;
	        },
	        set: function (value) {
	            if (value == this._mask)
	                return;
	            if (this._mask)
	                this.iRemoveTexture(this._mask);
	            this._mask = value;
	            if (this._mask)
	                this.iAddTexture(this._mask);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        methodVO.needsView = true;
	        if (this._envMap)
	            methodVO.textureGL = shader.getAbstraction(this._envMap);
	        if (this._mask) {
	            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);
	            shader.uvDependencies++;
	        }
	    };
	    Object.defineProperty(EffectEnvMapMethod.prototype, "envMap", {
	        /**
	         * The cubic environment map containing the reflected scene.
	         */
	        get: function () {
	            return this._envMap;
	        },
	        set: function (value) {
	            if (this._envMap == value)
	                return;
	            if (this._envMap)
	                this.iRemoveTexture(this._envMap);
	            this._envMap = value;
	            if (this._envMap)
	                this.iAddTexture(this._envMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.dispose = function () {
	    };
	    Object.defineProperty(EffectEnvMapMethod.prototype, "alpha", {
	        /**
	         * The reflectivity of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            this._alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex] = this._alpha;
	        methodVO.textureGL.activate(methodVO.pass._render);
	        if (this._mask)
	            methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    EffectEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	        if (this._mask)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var dataRegister = registerCache.getFreeFragmentConstant();
	        var code = "";
	        methodVO.fragmentConstantsIndex = dataRegister.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        // r = I - 2(I.N)*N
	        code += "dp3 " + temp + ".w, " + sharedRegisters.viewDirFragment + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "add " + temp + ".w, " + temp + ".w, " + temp + ".w\n" +
	            "mul " + temp + ".xyz, " + sharedRegisters.normalFragment + ".xyz, " + temp + ".w\n" +
	            "sub " + temp + ".xyz, " + temp + ".xyz, " + sharedRegisters.viewDirFragment + ".xyz\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +
	            "sub " + temp2 + ".w, " + temp + ".w, fc0.x\n" +
	            "kil " + temp2 + ".w\n" +
	            "sub " + temp + ", " + temp + ", " + targetReg + "\n";
	        if (this._mask) {
	            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
	                "mul " + temp + ", " + temp2 + ", " + temp + "\n";
	        }
	        code += "mul " + temp + ", " + temp + ", " + dataRegister + ".x\n" +
	            "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
	        registerCache.removeFragmentTempUsage(temp);
	        registerCache.removeFragmentTempUsage(temp2);
	        return code;
	    };
	    return EffectEnvMapMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectEnvMapMethod = EffectEnvMapMethod;


/***/ },
/* 244 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectFogMethod provides a method to add distance-based fog to a material.
	 */
	var EffectFogMethod = (function (_super) {
	    __extends(EffectFogMethod, _super);
	    /**
	     * Creates a new EffectFogMethod object.
	     * @param minDistance The distance from which the fog starts appearing.
	     * @param maxDistance The distance at which the fog is densest.
	     * @param fogColor The colour of the fog.
	     */
	    function EffectFogMethod(minDistance, maxDistance, fogColor) {
	        if (fogColor === void 0) { fogColor = 0x808080; }
	        _super.call(this);
	        this._minDistance = 0;
	        this._maxDistance = 1000;
	        this.minDistance = minDistance;
	        this.maxDistance = maxDistance;
	        this.fogColor = fogColor;
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsProjection = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index + 3] = 1;
	        data[index + 6] = 0;
	        data[index + 7] = 0;
	    };
	    Object.defineProperty(EffectFogMethod.prototype, "minDistance", {
	        /**
	         * The distance from which the fog starts appearing.
	         */
	        get: function () {
	            return this._minDistance;
	        },
	        set: function (value) {
	            this._minDistance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFogMethod.prototype, "maxDistance", {
	        /**
	         * The distance at which the fog is densest.
	         */
	        get: function () {
	            return this._maxDistance;
	        },
	        set: function (value) {
	            this._maxDistance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFogMethod.prototype, "fogColor", {
	        /**
	         * The colour of the fog.
	         */
	        get: function () {
	            return this._fogColor;
	        },
	        set: function (value /*uint*/) {
	            this._fogColor = value;
	            this._fogR = ((value >> 16) & 0xff) / 0xff;
	            this._fogG = ((value >> 8) & 0xff) / 0xff;
	            this._fogB = (value & 0xff) / 0xff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index] = this._fogR;
	        data[index + 1] = this._fogG;
	        data[index + 2] = this._fogB;
	        data[index + 4] = this._minDistance;
	        data[index + 5] = 1 / (this._maxDistance - this._minDistance);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFogMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var fogColor = registerCache.getFreeFragmentConstant();
	        var fogData = registerCache.getFreeFragmentConstant();
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        var code = "";
	        methodVO.fragmentConstantsIndex = fogColor.index * 4;
	        code += "sub " + temp2 + ".w, " + sharedRegisters.projectionFragment + ".z, " + fogData + ".x\n" +
	            "mul " + temp2 + ".w, " + temp2 + ".w, " + fogData + ".y\n" +
	            "sat " + temp2 + ".w, " + temp2 + ".w\n" +
	            "sub " + temp + ", " + fogColor + ", " + targetReg + "\n" +
	            "mul " + temp + ", " + temp + ", " + temp2 + ".w\n" +
	            "add " + targetReg + ", " + targetReg + ", " + temp + "\n"; // fogRatio*(fogColor- col) + col
	        registerCache.removeFragmentTempUsage(temp);
	        return code;
	    };
	    return EffectFogMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectFogMethod = EffectFogMethod;


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets
	 * stronger as the viewing angle becomes more grazing.
	 */
	var EffectFresnelEnvMapMethod = (function (_super) {
	    __extends(EffectFresnelEnvMapMethod, _super);
	    /**
	     * Creates a new <code>EffectFresnelEnvMapMethod</code> object.
	     *
	     * @param envMap The environment map containing the reflected scene.
	     * @param alpha The reflectivity of the material.
	     */
	    function EffectFresnelEnvMapMethod(envMap, alpha) {
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this);
	        this._fresnelPower = 5;
	        this._normalReflectance = 0;
	        this._envMap = envMap;
	        this._alpha = alpha;
	        if (this._envMap)
	            this.iAddTexture(this._envMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        methodVO.needsView = true;
	        methodVO.textureGL = shader.getAbstraction(this._envMap);
	        if (this._mask != null) {
	            methodVO.secondaryTextureGL = shader.getAbstraction(this._mask);
	            shader.uvDependencies++;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;
	    };
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "mask", {
	        /**
	         * An optional texture to modulate the reflectivity of the surface.
	         */
	        get: function () {
	            return this._mask;
	        },
	        set: function (value) {
	            if (this._mask == value)
	                return;
	            if (this._mask)
	                this.iRemoveTexture(this._mask);
	            this._mask = value;
	            if (this._mask)
	                this.iAddTexture(this._mask);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "fresnelPower", {
	        /**
	         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
	         */
	        get: function () {
	            return this._fresnelPower;
	        },
	        set: function (value) {
	            this._fresnelPower = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "envMap", {
	        /**
	         * The cubic environment map containing the reflected scene.
	         */
	        get: function () {
	            return this._envMap;
	        },
	        set: function (value) {
	            if (this._envMap == value)
	                return;
	            if (this._envMap)
	                this.iRemoveTexture(this._envMap);
	            this._envMap = value;
	            if (this._envMap)
	                this.iAddTexture(this._envMap);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "alpha", {
	        /**
	         * The reflectivity of the surface.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            this._alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "normalReflectance", {
	        /**
	         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
	         */
	        get: function () {
	            return this._normalReflectance;
	        },
	        set: function (value) {
	            this._normalReflectance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index] = this._alpha;
	        data[index + 1] = this._normalReflectance;
	        data[index + 2] = this._fresnelPower;
	        methodVO.textureGL.activate(methodVO.pass._render);
	        if (this._mask)
	            methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    EffectFresnelEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	        if (this._mask)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectFresnelEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var dataRegister = registerCache.getFreeFragmentConstant();
	        var code = "";
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        var normalReg = sharedRegisters.normalFragment;
	        methodVO.fragmentConstantsIndex = dataRegister.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        // r = V - 2(V.N)*N
	        code += "dp3 " + temp + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
	            "add " + temp + ".w, " + temp + ".w, " + temp + ".w\n" +
	            "mul " + temp + ".xyz, " + normalReg + ".xyz, " + temp + ".w\n" +
	            "sub " + temp + ".xyz, " + temp + ".xyz, " + viewDirReg + ".xyz\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +
	            "sub " + temp2 + ".w, " + temp + ".w, fc0.x\n" +
	            "kil " + temp2 + ".w\n" +
	            "sub " + temp + ", " + temp + ", " + targetReg + "\n";
	        // calculate fresnel term
	        code += "dp3 " + viewDirReg + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
	            "sub " + viewDirReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" +
	            "pow " + viewDirReg + ".w, " + viewDirReg + ".w, " + dataRegister + ".z\n" +
	            "sub " + normalReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" +
	            "mul " + normalReg + ".w, " + dataRegister + ".y, " + normalReg + ".w\n" +
	            "add " + viewDirReg + ".w, " + viewDirReg + ".w, " + normalReg + ".w\n" +
	            // total alpha
	            "mul " + viewDirReg + ".w, " + dataRegister + ".x, " + viewDirReg + ".w\n";
	        if (this._mask) {
	            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
	                "mul " + viewDirReg + ".w, " + temp2 + ".x, " + viewDirReg + ".w\n";
	        }
	        // blend
	        code += "mul " + temp + ", " + temp + ", " + viewDirReg + ".w\n" +
	            "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
	        registerCache.removeFragmentTempUsage(temp);
	        registerCache.removeFragmentTempUsage(temp2);
	        return code;
	    };
	    return EffectFresnelEnvMapMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod;


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.
	 * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather
	 * than the whole pixel colour.
	 */
	var EffectLightMapMethod = (function (_super) {
	    __extends(EffectLightMapMethod, _super);
	    /**
	     * Creates a new EffectLightMapMethod object.
	     *
	     * @param lightMap The texture containing the light map.
	     * @param blendMode The blend mode with which the light map should be applied to the lighting result.
	     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
	     */
	    function EffectLightMapMethod(lightMap, blendMode, useSecondaryUV) {
	        if (blendMode === void 0) { blendMode = "multiply"; }
	        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
	        _super.call(this);
	        if (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)
	            throw new Error("Unknown blendmode!");
	        this._lightMap = lightMap;
	        this._blendMode = blendMode;
	        this._useSecondaryUV = useSecondaryUV;
	        if (this._lightMap)
	            this.iAddTexture(this._lightMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectLightMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.textureGL = shader.getAbstraction(this._lightMap);
	        if (this._useSecondaryUV)
	            shader.secondaryUVDependencies++;
	        else
	            shader.uvDependencies++;
	    };
	    Object.defineProperty(EffectLightMapMethod.prototype, "blendMode", {
	        /**
	         * The blend mode with which the light map should be applied to the lighting result.
	         *
	         * @see EffectLightMapMethod.ADD
	         * @see EffectLightMapMethod.MULTIPLY
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        set: function (value) {
	            if (this._blendMode == value)
	                return;
	            if (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)
	                throw new Error("Unknown blendmode!");
	            this._blendMode = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectLightMapMethod.prototype, "lightMap", {
	        /**
	         * The lightMap containing the light map.
	         */
	        get: function () {
	            return this._lightMap;
	        },
	        set: function (value) {
	            if (this._lightMap == value)
	                return;
	            if (this._lightMap)
	                this.iRemoveTexture(this._lightMap);
	            this._lightMap = value;
	            if (this._lightMap)
	                this.iAddTexture(this._lightMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectLightMapMethod.prototype, "useSecondaryUV", {
	        /**
	         * Indicates whether the secondary UV set should be used to map the light map.
	         */
	        get: function () {
	            return this._useSecondaryUV;
	        },
	        set: function (value) {
	            if (this._useSecondaryUV == value)
	                return;
	            this._useSecondaryUV = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectLightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        code = methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, this._useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);
	        switch (this._blendMode) {
	            case EffectLightMapMethod.MULTIPLY:
	                code += "mul " + targetReg + ", " + targetReg + ", " + temp + "\n";
	                break;
	            case EffectLightMapMethod.ADD:
	                code += "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
	                break;
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectLightMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    EffectLightMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Indicates the light map should be multiplied with the calculated shading result.
	     */
	    EffectLightMapMethod.MULTIPLY = "multiply";
	    /**
	     * Indicates the light map should be added into the calculated shading result.
	     */
	    EffectLightMapMethod.ADD = "add";
	    return EffectLightMapMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectLightMapMethod = EffectLightMapMethod;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	var Matrix3D_1 = __webpack_require__(32);
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * ProjectiveTextureMethod is a material method used to project a texture unto the surface of an object.
	 * This can be used for various effects apart from acting like a normal projector, such as projecting fake shadows
	 * unto a surface, the impact of light coming through a stained glass window, ...
	 */
	var EffectProjectiveTextureMethod = (function (_super) {
	    __extends(EffectProjectiveTextureMethod, _super);
	    /**
	     * Creates a new ProjectiveTextureMethod object.
	     *
	     * @param projector The TextureProjector object that defines the projection properties as well as the texture.
	     * @param mode The blend mode with which the texture is blended unto the surface.
	     *
	     * @see away3d.entities.TextureProjector
	     */
	    function EffectProjectiveTextureMethod(projector, mode, exposure) {
	        if (mode === void 0) { mode = "multiply"; }
	        if (exposure === void 0) { exposure = 1; }
	        _super.call(this);
	        this._projMatrix = new Matrix3D_1.Matrix3D();
	        this.projector = projector;
	        this._exposure = exposure;
	        this._mode = mode;
	    }
	    EffectProjectiveTextureMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._projector.texture)
	            methodVO.textureGL = shader.getAbstraction(this._projector.texture);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectProjectiveTextureMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._exposure;
	        data[index + 1] = 0.5;
	        data[index + 2] = 4;
	        data[index + 3] = -1;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectProjectiveTextureMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._uvVarying = null;
	    };
	    Object.defineProperty(EffectProjectiveTextureMethod.prototype, "mode", {
	        /**
	         * The blend mode with which the texture is blended unto the object.
	         * ProjectiveTextureMethod.MULTIPLY can be used to project shadows. To prevent clamping, the texture's alpha should be white!
	         * ProjectiveTextureMethod.ADD can be used to project light, such as a slide projector or light coming through stained glass. To prevent clamping, the texture's alpha should be black!
	         * ProjectiveTextureMethod.MIX provides normal alpha blending. To prevent clamping, the texture's alpha should be transparent!
	         */
	        get: function () {
	            return this._mode;
	        },
	        set: function (value) {
	            if (this._mode == value)
	                return;
	            this._mode = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectProjectiveTextureMethod.prototype, "projector", {
	        /**
	         * The TextureProjector object that defines the projection properties as well as the texture.
	         *
	         * @see away3d.entities.TextureProjector
	         */
	        get: function () {
	            return this._projector;
	        },
	        set: function (value) {
	            if (this._projector)
	                this.iRemoveTexture(this._projector.texture);
	            this._projector = value;
	            if (this._projector)
	                this.iAddTexture(this._projector.texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectProjectiveTextureMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = "";
	        var projReg = registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        methodVO.vertexConstantsIndex = projReg.index * 4;
	        this._uvVarying = registerCache.getFreeVarying();
	        code += "m44 " + this._uvVarying + ", " + sharedRegisters.animatedPosition + ", " + projReg + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectProjectiveTextureMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var col = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(col, 1);
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        //var toTexReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();
	        //methodVO.fragmentConstantsIndex = toTexReg.index*4;
	        var exposure = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = exposure.index * 4;
	        // code += "mul " + col + ".xy, " + this._uvVarying + ".xy, " + toTexReg + ".xy	\n" +
	        // 	"add " + col + ".xy, " + col + ".xy, " + toTexReg + ".xx	\n";
	        code += methodVO.textureGL._iGetFragmentCode(col, registerCache, sharedRegisters, this._uvVarying);
	        code += "mul " + col + ", " + col + ", " + exposure + ".xxx\n" +
	            "add " + col + ", " + col + ", " + exposure + ".xxx\n";
	        if (this._mode == EffectProjectiveTextureMethod.MULTIPLY)
	            code += "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + col + ".xyz			\n";
	        else if (this._mode == EffectProjectiveTextureMethod.ADD)
	            code += "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + col + ".xyz			\n";
	        else if (this._mode == EffectProjectiveTextureMethod.MIX) {
	            code += "sub " + col + ".xyz, " + col + ".xyz, " + targetReg + ".xyz				\n" +
	                "mul " + col + ".xyz, " + col + ".xyz, " + col + ".w						\n" +
	                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + col + ".xyz			\n";
	        }
	        else if (this._mode == EffectProjectiveTextureMethod.OVERLAY) {
	            code += "sge " + temp + ", " + targetReg + ", " + exposure + ".yyy\n"; // temp = (base >= 0.5)? 1 : 0
	            code += "sub " + targetReg + ", " + targetReg + ", " + temp + "\n"; // base = temp? (base - 1 : base)
	            code += "sub " + col + ", " + col + ", " + temp + "\n"; // blend = temp? (blend - 1 : blend)
	            code += "mul " + col + ", " + col + ", " + targetReg + "\n"; // blend = blend * base
	            code += "sub " + targetReg + ", " + exposure + ".yyy, " + temp + "\n"; // base = temp? -0.5 : 0.5
	            code += "mul " + targetReg + ", " + exposure + ".zzz, " + targetReg + "\n"; // base = temp? -2 : 2
	            code += "mul " + col + ", " + col + ", " + targetReg + "\n"; // blend = blend * ( -2 : 2)
	            code += "add " + targetReg + ", " + col + ", " + temp + "\n"; //blend = temp? (blend + 1 : blend)
	        }
	        else
	            throw new ErrorBase_1.ErrorBase("Unknown mode \"" + this._mode + "\"");
	        registerCache.removeFragmentTempUsage(col);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectProjectiveTextureMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        this._projMatrix.copyFrom(this._projector.viewProjection);
	        //this._projMatrix.prependScale(this._projector.texture.width, .001, 1);
	        this._projMatrix.prepend(renderable.renderSceneTransform);
	        this._projMatrix.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex, true);
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectProjectiveTextureMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    EffectProjectiveTextureMethod.OVERLAY = "overlay";
	    EffectProjectiveTextureMethod.MULTIPLY = "multiply";
	    EffectProjectiveTextureMethod.ADD = "add";
	    EffectProjectiveTextureMethod.MIX = "mix";
	    return EffectProjectiveTextureMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectProjectiveTextureMethod = EffectProjectiveTextureMethod;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.
	 */
	var EffectRefractionEnvMapMethod = (function (_super) {
	    __extends(EffectRefractionEnvMapMethod, _super);
	    /**
	     * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015
	     *
	     * @param envMap The environment map containing the refracted scene.
	     * @param refractionIndex The refractive index of the material.
	     * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).
	     * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).
	     * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).
	     */
	    function EffectRefractionEnvMapMethod(envMap, refractionIndex, dispersionR, dispersionG, dispersionB) {
	        if (refractionIndex === void 0) { refractionIndex = .1; }
	        if (dispersionR === void 0) { dispersionR = 0; }
	        if (dispersionG === void 0) { dispersionG = 0; }
	        if (dispersionB === void 0) { dispersionB = 0; }
	        _super.call(this);
	        this._dispersionR = 0;
	        this._dispersionG = 0;
	        this._dispersionB = 0;
	        this._alpha = 1;
	        this._envMap = envMap;
	        this._dispersionR = dispersionR;
	        this._dispersionG = dispersionG;
	        this._dispersionB = dispersionB;
	        this._useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
	        this._refractionIndex = refractionIndex;
	        if (this._envMap)
	            this.iAddTexture(this._envMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectRefractionEnvMapMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index + 4] = 1;
	        data[index + 5] = 0;
	        data[index + 7] = 1;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectRefractionEnvMapMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        methodVO.needsView = true;
	        methodVO.textureGL = shader.getAbstraction(this._envMap);
	    };
	    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "envMap", {
	        /**
	         * The cube environment map to use for the refraction.
	         */
	        get: function () {
	            return this._envMap;
	        },
	        set: function (value) {
	            if (this._envMap == value)
	                return;
	            if (this._envMap)
	                this.iRemoveTexture(this._envMap);
	            this._envMap = value;
	            if (this._envMap)
	                this.iAddTexture(this._envMap);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "refractionIndex", {
	        /**
	         * The refractive index of the material.
	         */
	        get: function () {
	            return this._refractionIndex;
	        },
	        set: function (value) {
	            this._refractionIndex = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionR", {
	        /**
	         * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).
	         */
	        get: function () {
	            return this._dispersionR;
	        },
	        set: function (value) {
	            this._dispersionR = value;
	            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
	            if (this._useDispersion != useDispersion) {
	                this.iInvalidateShaderProgram();
	                this._useDispersion = useDispersion;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionG", {
	        /**
	         * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).
	         */
	        get: function () {
	            return this._dispersionG;
	        },
	        set: function (value) {
	            this._dispersionG = value;
	            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
	            if (this._useDispersion != useDispersion) {
	                this.iInvalidateShaderProgram();
	                this._useDispersion = useDispersion;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionB", {
	        /**
	         * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).
	         */
	        get: function () {
	            return this._dispersionB;
	        },
	        set: function (value) {
	            this._dispersionB = value;
	            var useDispersion = !(this._dispersionR == this._dispersionB && this._dispersionR == this._dispersionG);
	            if (this._useDispersion != useDispersion) {
	                this.iInvalidateShaderProgram();
	                this._useDispersion = useDispersion;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "alpha", {
	        /**
	         * The amount of transparency of the object. Warning: the alpha applies to the refracted color, not the actual
	         * material. A value of 1 will make it appear fully transparent.
	         */
	        get: function () {
	            return this._alpha;
	        },
	        set: function (value) {
	            this._alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectRefractionEnvMapMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._dispersionR + this._refractionIndex;
	        if (this._useDispersion) {
	            data[index + 1] = this._dispersionG + this._refractionIndex;
	            data[index + 2] = this._dispersionB + this._refractionIndex;
	        }
	        data[index + 3] = this._alpha;
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    EffectRefractionEnvMapMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectRefractionEnvMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        // todo: data2.x could use common reg, so only 1 reg is used
	        var data = registerCache.getFreeFragmentConstant();
	        var data2 = registerCache.getFreeFragmentConstant();
	        var code = "";
	        var refractionDir;
	        var refractionColor;
	        var temp;
	        methodVO.fragmentConstantsIndex = data.index * 4;
	        refractionDir = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(refractionDir, 1);
	        refractionColor = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(refractionColor, 1);
	        temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        var normalReg = sharedRegisters.normalFragment;
	        code += "neg " + viewDirReg + ".xyz, " + viewDirReg + ".xyz\n";
	        code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
	            "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" +
	            "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
	            "mul " + temp + ".w, " + data + ".x, " + temp + ".w\n" +
	            "mul " + temp + ".w, " + data + ".x, " + temp + ".w\n" +
	            "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
	            "sqt " + temp + ".y, " + temp + ".w\n" +
	            "mul " + temp + ".x, " + data + ".x, " + temp + ".x\n" +
	            "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" +
	            "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" +
	            "mul " + refractionDir + ", " + data + ".x, " + viewDirReg + "\n" +
	            "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" +
	            "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n" +
	            methodVO.textureGL._iGetFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +
	            "sub " + refractionColor + ".w, " + refractionColor + ".w, fc0.x	\n" +
	            "kil " + refractionColor + ".w\n";
	        if (this._useDispersion) {
	            // GREEN
	            code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
	                "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" +
	                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
	                "mul " + temp + ".w, " + data + ".y, " + temp + ".w\n" +
	                "mul " + temp + ".w, " + data + ".y, " + temp + ".w\n" +
	                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
	                "sqt " + temp + ".y, " + temp + ".w\n" +
	                "mul " + temp + ".x, " + data + ".y, " + temp + ".x\n" +
	                "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" +
	                "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" +
	                "mul " + refractionDir + ", " + data + ".y, " + viewDirReg + "\n" +
	                "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" +
	                "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n" +
	                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +
	                "mov " + refractionColor + ".y, " + temp + ".y\n";
	            // BLUE
	            code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
	                "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" +
	                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
	                "mul " + temp + ".w, " + data + ".z, " + temp + ".w\n" +
	                "mul " + temp + ".w, " + data + ".z, " + temp + ".w\n" +
	                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
	                "sqt " + temp + ".y, " + temp + ".w\n" +
	                "mul " + temp + ".x, " + data + ".z, " + temp + ".x\n" +
	                "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" +
	                "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" +
	                "mul " + refractionDir + ", " + data + ".z, " + viewDirReg + "\n" +
	                "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" +
	                "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n" +
	                methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +
	                "mov " + refractionColor + ".z, " + temp + ".z\n";
	        }
	        code += "sub " + refractionColor + ".xyz, " + refractionColor + ".xyz, " + targetReg + ".xyz\n" +
	            "mul " + refractionColor + ".xyz, " + refractionColor + ".xyz, " + data + ".w\n" +
	            "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + refractionColor + ".xyz\n";
	        registerCache.removeFragmentTempUsage(temp);
	        registerCache.removeFragmentTempUsage(refractionDir);
	        registerCache.removeFragmentTempUsage(refractionColor);
	        // restore
	        code += "neg " + viewDirReg + ".xyz, " + viewDirReg + ".xyz\n";
	        return code;
	    };
	    return EffectRefractionEnvMapMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EffectMethodBase_1 = __webpack_require__(240);
	/**
	 * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.
	 */
	var EffectRimLightMethod = (function (_super) {
	    __extends(EffectRimLightMethod, _super);
	    /**
	     * Creates a new <code>EffectRimLightMethod</code> object.
	     *
	     * @param color The colour of the rim light.
	     * @param strength The strength of the rim light.
	     * @param power The power of the rim light. Higher values will result in a higher edge fall-off.
	     * @param blend The blend mode with which to add the light to the object.
	     */
	    function EffectRimLightMethod(color, strength, power, blend) {
	        if (color === void 0) { color = 0xffffff; }
	        if (strength === void 0) { strength = .4; }
	        if (power === void 0) { power = 2; }
	        if (blend === void 0) { blend = "mix"; }
	        _super.call(this);
	        this._blendMode = blend;
	        this._strength = strength;
	        this._power = power;
	        this.color = color;
	    }
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iInitConstants = function (shader, methodVO) {
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 3] = 1;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = true;
	        methodVO.needsView = true;
	    };
	    Object.defineProperty(EffectRimLightMethod.prototype, "blendMode", {
	        /**
	         * The blend mode with which to add the light to the object.
	         *
	         * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.
	         * EffectRimLightMethod.ADD adds the rim light with the material's colour.
	         * EffectRimLightMethod.MIX provides normal alpha blending.
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        set: function (value) {
	            if (this._blendMode == value)
	                return;
	            this._blendMode = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRimLightMethod.prototype, "color", {
	        /**
	         * The color of the rim light.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value /*uint*/) {
	            this._color = value;
	            this._colorR = ((value >> 16) & 0xff) / 0xff;
	            this._colorG = ((value >> 8) & 0xff) / 0xff;
	            this._colorB = (value & 0xff) / 0xff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRimLightMethod.prototype, "strength", {
	        /**
	         * The strength of the rim light.
	         */
	        get: function () {
	            return this._strength;
	        },
	        set: function (value) {
	            this._strength = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(EffectRimLightMethod.prototype, "power", {
	        /**
	         * The power of the rim light. Higher values will result in a higher edge fall-off.
	         */
	        get: function () {
	            return this._power;
	        },
	        set: function (value) {
	            this._power = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._colorR;
	        data[index + 1] = this._colorG;
	        data[index + 2] = this._colorB;
	        data[index + 4] = this._strength;
	        data[index + 5] = this._power;
	    };
	    /**
	     * @inheritDoc
	     */
	    EffectRimLightMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var dataRegister = registerCache.getFreeFragmentConstant();
	        var dataRegister2 = registerCache.getFreeFragmentConstant();
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        var code = "";
	        methodVO.fragmentConstantsIndex = dataRegister.index * 4;
	        code += "dp3 " + temp + ".x, " + sharedRegisters.viewDirFragment + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
	            "sat " + temp + ".x, " + temp + ".x\n" +
	            "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x\n" +
	            "pow " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".y\n" +
	            "mul " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".x\n" +
	            "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x\n" +
	            "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".x\n" +
	            "sub " + temp + ".w, " + dataRegister + ".w, " + temp + ".x\n";
	        if (this._blendMode == EffectRimLightMethod.ADD) {
	            code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz\n" +
	                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
	        }
	        else if (this._blendMode == EffectRimLightMethod.MULTIPLY) {
	            code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz\n" +
	                "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
	        }
	        else {
	            code += "sub " + temp + ".xyz, " + dataRegister + ".xyz, " + targetReg + ".xyz\n" +
	                "mul " + temp + ".xyz, " + temp + ".xyz, " + temp + ".w\n" +
	                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
	        }
	        return code;
	    };
	    EffectRimLightMethod.ADD = "add";
	    EffectRimLightMethod.MULTIPLY = "multiply";
	    EffectRimLightMethod.MIX = "mix";
	    return EffectRimLightMethod;
	}(EffectMethodBase_1.EffectMethodBase));
	exports.EffectRimLightMethod = EffectRimLightMethod;


/***/ },
/* 250 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodBase_1 = __webpack_require__(226);
	/**
	 * NormalBasicMethod is the default method for standard tangent-space normal mapping.
	 */
	var NormalBasicMethod = (function (_super) {
	    __extends(NormalBasicMethod, _super);
	    /**
	     * Creates a new NormalBasicMethod object.
	     */
	    function NormalBasicMethod(texture) {
	        if (texture === void 0) { texture = null; }
	        _super.call(this);
	        this._texture = texture;
	        if (this._texture)
	            this.iAddTexture(this._texture);
	    }
	    NormalBasicMethod.prototype.iIsUsed = function (shader) {
	        if (this._texture && shader.normalDependencies)
	            return true;
	        return false;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	    };
	    /**
	     * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.
	     */
	    NormalBasicMethod.prototype.iOutputsTangentNormals = function () {
	        return true;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.copyFrom = function (method) {
	        var s = method;
	        var bnm = method;
	        if (bnm.texture != null)
	            this.texture = bnm.texture;
	    };
	    Object.defineProperty(NormalBasicMethod.prototype, "texture", {
	        /**
	         * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects
	         * tangent-space normal maps, but others could expect object-space maps.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.dispose = function () {
	        if (this._texture)
	            this._texture = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (this._texture)
	            methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    NormalBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (this._texture)
	            methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalBasicMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        if (this._texture)
	            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	        code += "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + sharedRegisters.commons + ".xxx\n" +
	            "nrm " + targetReg + ".xyz, " + targetReg + "\n";
	        return code;
	    };
	    return NormalBasicMethod;
	}(ShadingMethodBase_1.ShadingMethodBase));
	exports.NormalBasicMethod = NormalBasicMethod;


/***/ },
/* 251 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var NormalBasicMethod_1 = __webpack_require__(250);
	/**
	 * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.
	 */
	var NormalHeightMapMethod = (function (_super) {
	    __extends(NormalHeightMapMethod, _super);
	    /**
	     * Creates a new NormalHeightMapMethod method.
	     *
	     * @param heightMap The texture containing the height data. 0 means low, 1 means high.
	     * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.
	     * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.
	     * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.
	     */
	    function NormalHeightMapMethod(heightMap, worldWidth, worldHeight, worldDepth) {
	        _super.call(this);
	        this.texture = heightMap;
	        this._worldXYRatio = worldWidth / worldHeight;
	        this._worldXZRatio = worldDepth / worldHeight;
	    }
	    /**
	     * @inheritDoc
	     */
	    NormalHeightMapMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = 1 / this.texture.image2D.width;
	        data[index + 1] = 1 / this.texture.image2D.height;
	        data[index + 2] = 0;
	        data[index + 3] = 1;
	        data[index + 4] = this._worldXYRatio;
	        data[index + 5] = this._worldXZRatio;
	    };
	    Object.defineProperty(NormalHeightMapMethod.prototype, "tangentSpace", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    NormalHeightMapMethod.prototype.copyFrom = function (method) {
	        _super.prototype.copyFrom.call(this, method);
	        this._worldXYRatio = method._worldXYRatio;
	        this._worldXZRatio = method._worldXZRatio;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalHeightMapMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var dataReg = registerCache.getFreeFragmentConstant();
	        var dataReg2 = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = dataReg.index * 4;
	        code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
	            "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg + ".xzzz\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +
	            "sub " + targetReg + ".x, " + targetReg + ".x, " + temp + ".x\n" +
	            "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg + ".zyzz\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp) +
	            "sub " + targetReg + ".z, " + targetReg + ".z, " + temp + ".x\n" +
	            "mov " + targetReg + ".y, " + dataReg + ".w\n" +
	            "mul " + targetReg + ".xz, " + targetReg + ".xz, " + dataReg2 + ".xy\n" +
	            "nrm " + targetReg + ".xyz, " + targetReg + ".xyz\n";
	        registerCache.removeFragmentTempUsage(temp);
	        return code;
	    };
	    return NormalHeightMapMethod;
	}(NormalBasicMethod_1.NormalBasicMethod));
	exports.NormalHeightMapMethod = NormalHeightMapMethod;


/***/ },
/* 252 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var NormalBasicMethod_1 = __webpack_require__(250);
	/**
	 * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.
	 */
	var NormalSimpleWaterMethod = (function (_super) {
	    __extends(NormalSimpleWaterMethod, _super);
	    /**
	     * Creates a new NormalSimpleWaterMethod object.
	     * @param waveMap1 A normal map containing one layer of a wave structure.
	     * @param waveMap2 A normal map containing a second layer of a wave structure.
	     */
	    function NormalSimpleWaterMethod(normalMap, secondaryNormalMap) {
	        if (normalMap === void 0) { normalMap = null; }
	        if (secondaryNormalMap === void 0) { secondaryNormalMap = null; }
	        _super.call(this, normalMap);
	        this._water1OffsetX = 0;
	        this._water1OffsetY = 0;
	        this._water2OffsetX = 0;
	        this._water2OffsetY = 0;
	        this._secondaryNormalMap = secondaryNormalMap;
	        if (this._secondaryNormalMap)
	            this.iAddTexture(this._secondaryNormalMap);
	    }
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = .5;
	        data[index + 1] = 0;
	        data[index + 2] = 0;
	        data[index + 3] = 1;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iInitVO = function (shader, methodVO) {
	        _super.prototype.iInitVO.call(this, shader, methodVO);
	        if (this._secondaryNormalMap) {
	            methodVO.secondaryTextureGL = shader.getAbstraction(this._secondaryNormalMap);
	            shader.uvDependencies++;
	        }
	    };
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetX", {
	        /**
	         * The translation of the first wave layer along the X-axis.
	         */
	        get: function () {
	            return this._water1OffsetX;
	        },
	        set: function (value) {
	            this._water1OffsetX = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetY", {
	        /**
	         * The translation of the first wave layer along the Y-axis.
	         */
	        get: function () {
	            return this._water1OffsetY;
	        },
	        set: function (value) {
	            this._water1OffsetY = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetX", {
	        /**
	         * The translation of the second wave layer along the X-axis.
	         */
	        get: function () {
	            return this._water2OffsetX;
	        },
	        set: function (value) {
	            this._water2OffsetX = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetY", {
	        /**
	         * The translation of the second wave layer along the Y-axis.
	         */
	        get: function () {
	            return this._water2OffsetY;
	        },
	        set: function (value) {
	            this._water2OffsetY = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NormalSimpleWaterMethod.prototype, "secondaryNormalMap", {
	        /**
	         * A second normal map that will be combined with the first to create a wave-like animation pattern.
	         */
	        get: function () {
	            return this._secondaryNormalMap;
	        },
	        set: function (value) {
	            if (this._secondaryNormalMap == value)
	                return;
	            if (this._secondaryNormalMap)
	                this.iRemoveTexture(this._secondaryNormalMap);
	            this._secondaryNormalMap = value;
	            if (this._secondaryNormalMap)
	                this.iAddTexture(this._secondaryNormalMap);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this._secondaryNormalMap = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index + 4] = this._water1OffsetX;
	        data[index + 5] = this._water1OffsetY;
	        data[index + 6] = this._water2OffsetX;
	        data[index + 7] = this._water2OffsetY;
	        if (this._secondaryNormalMap)
	            methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        if (this._secondaryNormalMap)
	            methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    NormalSimpleWaterMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var dataReg = registerCache.getFreeFragmentConstant();
	        var dataReg2 = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = dataReg.index * 4;
	        code += "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg2 + ".xyxy\n";
	        if (this.texture)
	            code += methodVO.textureGL._iGetFragmentCode(targetReg, registerCache, sharedRegisters, temp);
	        code += "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg2 + ".zwzw\n";
	        if (this._secondaryNormalMap)
	            code += methodVO.secondaryTextureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, temp);
	        code += "add " + targetReg + ", " + targetReg + ", " + temp + "		\n" +
	            "mul " + targetReg + ", " + targetReg + ", " + dataReg + ".x	\n" +
	            "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + sharedRegisters.commons + ".xxx	\n" +
	            "nrm " + targetReg + ".xyz, " + targetReg + ".xyz							\n";
	        return code;
	    };
	    return NormalSimpleWaterMethod;
	}(NormalBasicMethod_1.NormalBasicMethod));
	exports.NormalSimpleWaterMethod = NormalSimpleWaterMethod;


/***/ },
/* 253 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var DirectionalLight_1 = __webpack_require__(149);
	var ShadingMethodEvent_1 = __webpack_require__(227);
	var MethodVO_1 = __webpack_require__(223);
	var ShadowMapMethodBase_1 = __webpack_require__(254);
	/**
	 * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.
	 * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.
	 *
	 * @see away.lights.CascadeShadowMapper
	 */
	var ShadowCascadeMethod = (function (_super) {
	    __extends(ShadowCascadeMethod, _super);
	    /**
	     * Creates a new ShadowCascadeMethod object.
	     *
	     * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
	     */
	    function ShadowCascadeMethod(shadowMethodBase) {
	        var _this = this;
	        _super.call(this, shadowMethodBase.castingLight);
	        this._baseMethod = shadowMethodBase;
	        if (!(this._pCastingLight instanceof DirectionalLight_1.DirectionalLight))
	            throw new Error("ShadowCascadeMethod is only compatible with DirectionalLight");
	        this._cascadeShadowMapper = this._pCastingLight.shadowMapper;
	        if (!this._cascadeShadowMapper)
	            throw new Error("ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.");
	        this._cascadeShadowMapper.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, function (event) { return _this.onCascadeChange(event); });
	        this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });
	    }
	    Object.defineProperty(ShadowCascadeMethod.prototype, "baseMethod", {
	        /**
	         * The shadow map sampling method used to sample individual cascades. These are typically those used in conjunction
	         * with a DirectionalShadowMapper.
	         *
	         * @see ShadowHardMethod
	         * @see ShadowSoftMethod
	         */
	        get: function () {
	            return this._baseMethod;
	        },
	        set: function (value) {
	            var _this = this;
	            if (this._baseMethod == value)
	                return;
	            this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });
	            this._baseMethod = value;
	            this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, function (event) { return _this.onShaderInvalidated(event); });
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowCascadeMethod.prototype.iInitVO = function (shader, methodVO) {
	        var tempVO = new MethodVO_1.MethodVO(this._baseMethod, methodVO.pass);
	        this._baseMethod.iInitVO(shader, tempVO);
	        methodVO.needsGlobalVertexPos = true;
	        methodVO.needsProjection = true;
	        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowCascadeMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var fragmentData = shader.fragmentConstantData;
	        var vertexData = shader.vertexConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        fragmentData[index] = 1.0;
	        fragmentData[index + 1] = 1 / 255.0;
	        fragmentData[index + 2] = 1 / 65025.0;
	        fragmentData[index + 3] = 1 / 16581375.0;
	        fragmentData[index + 6] = .5;
	        fragmentData[index + 7] = -.5;
	        index = methodVO.vertexConstantsIndex;
	        vertexData[index] = .5;
	        vertexData[index + 1] = -.5;
	        vertexData[index + 2] = 0;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowCascadeMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._cascadeProjections = null;
	        this._depthMapCoordVaryings = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowCascadeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = "";
	        var dataReg = registerCache.getFreeVertexConstant();
	        this.initProjectionsRegs(registerCache);
	        methodVO.vertexConstantsIndex = dataReg.index * 4;
	        var temp = registerCache.getFreeVertexVectorTemp();
	        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {
	            code += "m44 " + temp + ", " + sharedRegisters.globalPositionVertex + ", " + this._cascadeProjections[i] + "\n" +
	                "add " + this._depthMapCoordVaryings[i] + ", " + temp + ", " + dataReg + ".zzwz\n";
	        }
	        return code;
	    };
	    /**
	     * Creates the registers for the cascades' projection coordinates.
	     */
	    ShadowCascadeMethod.prototype.initProjectionsRegs = function (registerCache) {
	        this._cascadeProjections = new Array(this._cascadeShadowMapper.numCascades);
	        this._depthMapCoordVaryings = new Array(this._cascadeShadowMapper.numCascades);
	        for (var i = 0; i < this._cascadeShadowMapper.numCascades; ++i) {
	            this._depthMapCoordVaryings[i] = registerCache.getFreeVarying();
	            this._cascadeProjections[i] = registerCache.getFreeVertexConstant();
	            registerCache.getFreeVertexConstant();
	            registerCache.getFreeVertexConstant();
	            registerCache.getFreeVertexConstant();
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowCascadeMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var numCascades = this._cascadeShadowMapper.numCascades;
	        var decReg = registerCache.getFreeFragmentConstant();
	        var dataReg = registerCache.getFreeFragmentConstant();
	        var planeDistanceReg = registerCache.getFreeFragmentConstant();
	        var planeDistances = Array(planeDistanceReg + ".x", planeDistanceReg + ".y", planeDistanceReg + ".z", planeDistanceReg + ".w");
	        var code;
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        var inQuad = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(inQuad, 1);
	        var uvCoord = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(uvCoord, 1);
	        // assume lowest partition is selected, will be overwritten later otherwise
	        code = "mov " + uvCoord + ", " + this._depthMapCoordVaryings[numCascades - 1] + "\n";
	        for (var i = numCascades - 2; i >= 0; --i) {
	            var uvProjection = this._depthMapCoordVaryings[i];
	            // calculate if in texturemap (result == 0 or 1, only 1 for a single partition)
	            code += "slt " + inQuad + ".z, " + sharedRegisters.projectionFragment + ".z, " + planeDistances[i] + "\n"; // z = x > minX, w = y > minY
	            var temp = registerCache.getFreeFragmentVectorTemp();
	            // linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)
	            code += "sub " + temp + ", " + uvProjection + ", " + uvCoord + "\n" +
	                "mul " + temp + ", " + temp + ", " + inQuad + ".z\n" +
	                "add " + uvCoord + ", " + uvCoord + ", " + temp + "\n";
	        }
	        registerCache.removeFragmentTempUsage(inQuad);
	        code += "div " + uvCoord + ", " + uvCoord + ", " + uvCoord + ".w\n" +
	            "mul " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zw\n" +
	            "add " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zz\n";
	        code += this._baseMethod._iGetCascadeFragmentCode(shader, methodVO, decReg, uvCoord, targetReg, registerCache, sharedRegisters) +
	            "add " + targetReg + ".w, " + targetReg + ".w, " + dataReg + ".y\n";
	        registerCache.removeFragmentTempUsage(uvCoord);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowCascadeMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        methodVO.textureGL.activate(methodVO.pass._render);
	        var vertexData = shader.vertexConstantData;
	        var vertexIndex = methodVO.vertexConstantsIndex;
	        shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._cascadeShadowMapper.depth * this._pEpsilon);
	        var numCascades = this._cascadeShadowMapper.numCascades;
	        vertexIndex += 4;
	        for (var k = 0; k < numCascades; ++k) {
	            this._cascadeShadowMapper.getDepthProjections(k).copyRawDataTo(vertexData, vertexIndex, true);
	            vertexIndex += 16;
	        }
	        var fragmentData = shader.fragmentConstantData;
	        var fragmentIndex = methodVO.fragmentConstantsIndex;
	        fragmentData[fragmentIndex + 5] = 1 - this._pAlpha;
	        var nearPlaneDistances = this._cascadeShadowMapper._iNearPlaneDistances;
	        fragmentIndex += 8;
	        for (var i = 0; i < numCascades; ++i)
	            fragmentData[fragmentIndex + i] = nearPlaneDistances[i];
	        this._baseMethod.iActivateForCascade(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowCascadeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	    };
	    /**
	     * Called when the shadow mappers cascade configuration changes.
	     */
	    ShadowCascadeMethod.prototype.onCascadeChange = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    /**
	     * Called when the base method's shader code is invalidated.
	     */
	    ShadowCascadeMethod.prototype.onShaderInvalidated = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    return ShadowCascadeMethod;
	}(ShadowMapMethodBase_1.ShadowMapMethodBase));
	exports.ShadowCascadeMethod = ShadowCascadeMethod;


/***/ },
/* 254 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodBase_1 = __webpack_require__(226);
	/**
	 * ShadowMapMethodBase provides an abstract base method for shadow map methods.
	 */
	var ShadowMapMethodBase = (function (_super) {
	    __extends(ShadowMapMethodBase, _super);
	    /**
	     * Creates a new ShadowMapMethodBase object.
	     * @param castingLight The light used to cast shadows.
	     */
	    function ShadowMapMethodBase(castingLight) {
	        _super.call(this);
	        this._pEpsilon = .02;
	        this._pAlpha = 1;
	        this._pCastingLight = castingLight;
	        castingLight.shadowsEnabled = true;
	        this._pShadowMapper = castingLight.shadowMapper;
	        this.iAddTexture(castingLight.shadowMapper.depthMap);
	    }
	    Object.defineProperty(ShadowMapMethodBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return ShadowMapMethodBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapMethodBase.prototype, "alpha", {
	        /**
	         * The "transparency" of the shadows. This allows making shadows less strong.
	         */
	        get: function () {
	            return this._pAlpha;
	        },
	        set: function (value) {
	            this._pAlpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapMethodBase.prototype, "castingLight", {
	        /**
	         * The light casting the shadows.
	         */
	        get: function () {
	            return this._pCastingLight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowMapMethodBase.prototype, "epsilon", {
	        /**
	         * A small value to counter floating point precision errors when comparing values in the shadow map with the
	         * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
	         */
	        get: function () {
	            return this._pEpsilon;
	        },
	        set: function (value) {
	            this._pEpsilon = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShadowMapMethodBase.assetType = "[asset ShadowMapMethod]";
	    return ShadowMapMethodBase;
	}(ShadingMethodBase_1.ShadingMethodBase));
	exports.ShadowMapMethodBase = ShadowMapMethodBase;


/***/ },
/* 255 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImage2D_1 = __webpack_require__(95);
	var Single2DTexture_1 = __webpack_require__(136);
	var ShadowMethodBase_1 = __webpack_require__(256);
	/**
	 * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.
	 */
	var ShadowDitheredMethod = (function (_super) {
	    __extends(ShadowDitheredMethod, _super);
	    /**
	     * Creates a new ShadowDitheredMethod object.
	     * @param castingLight The light casting the shadows
	     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.
	     */
	    function ShadowDitheredMethod(castingLight, numSamples, range) {
	        if (numSamples === void 0) { numSamples = 4; }
	        if (range === void 0) { range = 1; }
	        _super.call(this, castingLight);
	        this._depthMapSize = this._pCastingLight.shadowMapper.depthMapSize;
	        this.numSamples = numSamples;
	        this.range = range;
	        ++ShadowDitheredMethod._grainUsages;
	        if (!ShadowDitheredMethod._grainTexture)
	            this.initGrainTexture();
	    }
	    Object.defineProperty(ShadowDitheredMethod.prototype, "numSamples", {
	        /**
	         * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the
	         * complexity of the shader.
	         */
	        get: function () {
	            return this._numSamples;
	        },
	        set: function (value) {
	            if (value < 1)
	                value = 1;
	            else if (value > 24)
	                value = 24;
	            if (this._numSamples == value)
	                return;
	            this._numSamples = value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iInitVO = function (shader, methodVO) {
	        _super.prototype.iInitVO.call(this, shader, methodVO);
	        methodVO.needsProjection = true;
	        methodVO.secondaryTextureGL = shader.getAbstraction(ShadowDitheredMethod._grainTexture);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        fragmentData[index + 8] = 1 / this._numSamples;
	    };
	    Object.defineProperty(ShadowDitheredMethod.prototype, "range", {
	        /**
	         * The range in the shadow map in which to distribute the samples.
	         */
	        get: function () {
	            return this._range * 2;
	        },
	        set: function (value) {
	            this._range = value / 2;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Creates a texture containing the dithering noise texture.
	     */
	    ShadowDitheredMethod.prototype.initGrainTexture = function () {
	        ShadowDitheredMethod._grainBitmapImage2D = new BitmapImage2D_1.BitmapImage2D(64, 64, false);
	        var vec = new Array();
	        var len = 4096;
	        var step = 1 / (this._depthMapSize * this._range);
	        var r, g;
	        for (var i = 0; i < len; ++i) {
	            r = 2 * (Math.random() - .5);
	            g = 2 * (Math.random() - .5);
	            if (r < 0)
	                r -= step;
	            else
	                r += step;
	            if (g < 0)
	                g -= step;
	            else
	                g += step;
	            if (r > 1)
	                r = 1;
	            else if (r < -1)
	                r = -1;
	            if (g > 1)
	                g = 1;
	            else if (g < -1)
	                g = -1;
	            vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);
	        }
	        ShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);
	        ShadowDitheredMethod._grainTexture = new Single2DTexture_1.Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.dispose = function () {
	        if (--ShadowDitheredMethod._grainUsages == 0) {
	            ShadowDitheredMethod._grainTexture.dispose();
	            ShadowDitheredMethod._grainBitmapImage2D.dispose();
	            ShadowDitheredMethod._grainTexture = null;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        data[index + 9] = (stage.width - 1) / 63;
	        data[index + 10] = (stage.height - 1) / 63;
	        data[index + 11] = 2 * this._range / this._depthMapSize;
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        _super.prototype.iSetRenderState.call(this, shader, methodVO, renderable, stage, camera);
	        methodVO.secondaryTextureGL._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var decReg = regCache.getFreeFragmentConstant();
	        var dataReg = regCache.getFreeFragmentConstant();
	        var customDataReg = regCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        return this.getSampleCode(shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters);
	    };
	    /**
	     * Get the actual shader code for shadow mapping
	     * @param regCache The register cache managing the registers.
	     * @param depthMapRegister The texture register containing the depth map.
	     * @param decReg The register containing the depth map decoding data.
	     * @param targetReg The target register to add the shadow coverage.
	     */
	    ShadowDitheredMethod.prototype.getSampleCode = function (shader, methodVO, customDataReg, decReg, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var numSamples = this._numSamples;
	        var uvReg = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(uvReg, 1);
	        var temp = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(temp, 1);
	        var projectionReg = sharedRegisters.projectionFragment;
	        code += "div " + uvReg + ", " + projectionReg + ", " + projectionReg + ".w\n" +
	            "mul " + uvReg + ".xy, " + uvReg + ".xy, " + customDataReg + ".yz\n";
	        while (numSamples > 0) {
	            if (numSamples == this._numSamples) {
	                code += methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, uvReg);
	            }
	            else {
	                code += "mov " + temp + ", " + uvReg + ".zwxy \n" +
	                    methodVO.secondaryTextureGL._iGetFragmentCode(uvReg, regCache, sharedRegisters, temp);
	            }
	            // keep grain in uvReg.zw
	            code += "sub " + uvReg + ".zw, " + uvReg + ".xy, fc0.xx\n" +
	                "mul " + uvReg + ".zw, " + uvReg + ".zw, " + customDataReg + ".w\n"; // (tex unpack scale and tex scale in one)
	            if (numSamples == this._numSamples) {
	                // first sample
	                code += "add " + uvReg + ".xy, " + uvReg + ".zw, " + this._pDepthMapCoordReg + ".xy\n" +
	                    methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +
	                    "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" +
	                    "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow
	            }
	            else {
	                code += this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            }
	            if (numSamples > 4)
	                code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 1)
	                code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".zw\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 5)
	                code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 2) {
	                code += "neg " + uvReg + ".w, " + uvReg + ".w\n"; // will be rotated 90 degrees when being accessed as wz
	                code += "add " + uvReg + ".xy, " + uvReg + ".wz, " + this._pDepthMapCoordReg + ".xy\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            }
	            if (numSamples > 6)
	                code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 3)
	                code += "sub " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + uvReg + ".wz\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            if (numSamples > 7)
	                code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this.addSample(shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters);
	            numSamples -= 8;
	        }
	        regCache.removeFragmentTempUsage(temp);
	        regCache.removeFragmentTempUsage(uvReg);
	        code += "mul " + targetReg + ".w, " + targetReg + ".w, " + customDataReg + ".x\n"; // average
	        return code;
	    };
	    /**
	     * Adds the code for another tap to the shader code.
	     * @param uvReg The uv register for the tap.
	     * @param depthMapRegister The texture register containing the depth map.
	     * @param decReg The register containing the depth map decoding data.
	     * @param targetReg The target register to add the tap comparison result.
	     * @param regCache The register cache managing the registers.
	     * @return
	     */
	    ShadowDitheredMethod.prototype.addSample = function (shader, methodVO, uvReg, decReg, targetReg, regCache, sharedRegisters) {
	        var temp = regCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, regCache, sharedRegisters, uvReg) +
	            "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" +
	            "slt " + temp + ".z, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" +
	            "add " + targetReg + ".w, " + targetReg + ".w, " + temp + ".z\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        data[index] = 1 / this._numSamples;
	        data[index + 1] = (stage.width - 1) / 63;
	        data[index + 2] = (stage.height - 1) / 63;
	        data[index + 3] = 2 * this._range / this._depthMapSize;
	        methodVO.secondaryTextureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowDitheredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        this._pDepthMapCoordReg = depthProjection;
	        var dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        return this.getSampleCode(shader, methodVO, dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);
	    };
	    return ShadowDitheredMethod;
	}(ShadowMethodBase_1.ShadowMethodBase));
	exports.ShadowDitheredMethod = ShadowDitheredMethod;


/***/ },
/* 256 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var PointLight_1 = __webpack_require__(196);
	var ShadowMapMethodBase_1 = __webpack_require__(254);
	/**
	 * ShadowMethodBase provides an abstract method for simple (non-wrapping) shadow map methods.
	 */
	var ShadowMethodBase = (function (_super) {
	    __extends(ShadowMethodBase, _super);
	    /**
	     * Creates a new ShadowMethodBase object.
	     * @param castingLight The light used to cast shadows.
	     */
	    function ShadowMethodBase(castingLight) {
	        _super.call(this, castingLight);
	        this._pUsePoint = (castingLight instanceof PointLight_1.PointLight);
	    }
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsView = true;
	        methodVO.needsGlobalVertexPos = true;
	        methodVO.needsGlobalFragmentPos = this._pUsePoint;
	        methodVO.needsNormals = shader.numLights > 0;
	        methodVO.textureGL = shader.getAbstraction(this._pCastingLight.shadowMapper.depthMap);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iInitConstants = function (shader, methodVO) {
	        var fragmentData = shader.fragmentConstantData;
	        var vertexData = shader.vertexConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        fragmentData[index] = 1.0;
	        fragmentData[index + 1] = 1 / 255.0;
	        fragmentData[index + 2] = 1 / 65025.0;
	        fragmentData[index + 3] = 1 / 16581375.0;
	        fragmentData[index + 6] = 0;
	        fragmentData[index + 7] = 1;
	        if (this._pUsePoint) {
	            fragmentData[index + 8] = 0;
	            fragmentData[index + 9] = 0;
	            fragmentData[index + 10] = 0;
	            fragmentData[index + 11] = 1;
	        }
	        index = methodVO.vertexConstantsIndex;
	        if (index != -1) {
	            vertexData[index] = .5;
	            vertexData[index + 1] = .5;
	            vertexData[index + 2] = 0.0;
	            vertexData[index + 3] = 1.0;
	        }
	    };
	    Object.defineProperty(ShadowMethodBase.prototype, "_iDepthMapCoordReg", {
	        /**
	         * Wrappers that override the vertex shader need to set this explicitly
	         */
	        get: function () {
	            return this._pDepthMapCoordReg;
	        },
	        set: function (value) {
	            this._pDepthMapCoordReg = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._pDepthMapCoordReg = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iGetVertexCode = function (shader, methodVO, regCache, sharedRegisters) {
	        return this._pUsePoint ? this._pGetPointVertexCode(methodVO, regCache, sharedRegisters) : this.pGetPlanarVertexCode(methodVO, regCache, sharedRegisters);
	    };
	    /**
	     * Gets the vertex code for shadow mapping with a point light.
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     */
	    ShadowMethodBase.prototype._pGetPointVertexCode = function (methodVO, regCache, sharedRegisters) {
	        methodVO.vertexConstantsIndex = -1;
	        return "";
	    };
	    /**
	     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
	     *
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     */
	    ShadowMethodBase.prototype.pGetPlanarVertexCode = function (methodVO, regCache, sharedRegisters) {
	        var code = "";
	        var temp = regCache.getFreeVertexVectorTemp();
	        var dataReg = regCache.getFreeVertexConstant();
	        var depthMapProj = regCache.getFreeVertexConstant();
	        regCache.getFreeVertexConstant();
	        regCache.getFreeVertexConstant();
	        regCache.getFreeVertexConstant();
	        this._pDepthMapCoordReg = regCache.getFreeVarying();
	        methodVO.vertexConstantsIndex = dataReg.index * 4;
	        // todo: can epsilon be applied here instead of fragment shader?
	        code += "m44 " + temp + ", " + sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" +
	            "div " + temp + ", " + temp + ", " + temp + ".w\n" +
	            "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" +
	            "add " + this._pDepthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";
	        //"sub " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".z, " + this._pDepthMapCoordReg + ".w\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = this._pUsePoint ? this._pGetPointFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters) : this._pGetPlanarFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	        code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (methodVO.fragmentConstantsIndex / 4 + 1) + ".y\n" +
	            "sat " + targetReg + ".w, " + targetReg + ".w\n";
	        return code;
	    };
	    /**
	     * Gets the fragment code for shadow mapping with a planar shadow map.
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register to contain the shadow coverage
	     * @return
	     */
	    ShadowMethodBase.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Gets the fragment code for shadow mapping with a point light.
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     * @param targetReg The register to contain the shadow coverage
	     * @return
	     */
	    ShadowMethodBase.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (!this._pUsePoint)
	            this._pShadowMapper.iDepthProjection.copyRawDataTo(shader.vertexConstantData, methodVO.vertexConstantsIndex + 4, true);
	        methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Gets the fragment code for combining this method with a cascaded shadow map method.
	     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
	     * @param regCache The register cache used during the compilation.
	     * @param decodeRegister The register containing the data to decode the shadow map depth value.
	     * @param depthTexture The texture containing the shadow map.
	     * @param depthProjection The projection of the fragment relative to the light.
	     * @param targetRegister The register to contain the shadow coverage
	     * @return
	     */
	    ShadowMethodBase.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        throw new Error("This shadow method is incompatible with cascade shadows");
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowMethodBase.prototype.iActivate = function (shader, methodVO, stage) {
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        if (this._pUsePoint)
	            fragmentData[index + 4] = -Math.pow(1 / (this._pCastingLight.fallOff * this._pEpsilon), 2);
	        else
	            shader.vertexConstantData[methodVO.vertexConstantsIndex + 3] = -1 / (this._pShadowMapper.depth * this._pEpsilon);
	        fragmentData[index + 5] = 1 - this._pAlpha;
	        if (this._pUsePoint) {
	            var pos = this._pCastingLight.scenePosition;
	            fragmentData[index + 8] = pos.x;
	            fragmentData[index + 9] = pos.y;
	            fragmentData[index + 10] = pos.z;
	            // used to decompress distance
	            var f = this._pCastingLight.fallOff;
	            fragmentData[index + 11] = 1 / (2 * f * f);
	        }
	        methodVO.textureGL.activate(methodVO.pass._render);
	    };
	    /**
	     * Sets the method state for cascade shadow mapping.
	     */
	    ShadowMethodBase.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        throw new Error("This shadow method is incompatible with cascade shadows");
	    };
	    return ShadowMethodBase;
	}(ShadowMapMethodBase_1.ShadowMapMethodBase));
	exports.ShadowMethodBase = ShadowMethodBase;


/***/ },
/* 257 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadowMethodBase_1 = __webpack_require__(256);
	/**
	 * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison
	 * results of neighbouring pixels.
	 */
	var ShadowFilteredMethod = (function (_super) {
	    __extends(ShadowFilteredMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     *
	     * @param castingLight The light casting the shadow
	     */
	    function ShadowFilteredMethod(castingLight) {
	        _super.call(this, castingLight);
	    }
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex;
	        fragmentData[index + 8] = .5;
	        var size = this.castingLight.shadowMapper.depthMapSize;
	        fragmentData[index + 9] = size;
	        fragmentData[index + 10] = 1 / size;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var decReg = regCache.getFreeFragmentConstant();
	        regCache.getFreeFragmentConstant();
	        var customDataReg = regCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        var depthCol = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(depthCol, 1);
	        var uvReg = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(uvReg, 1);
	        code += "mov " + uvReg + ", " + this._pDepthMapCoordReg + "\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" +
	            "frc " + depthCol + ".x, " + depthCol + ".x\n" +
	            "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" +
	            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
	            "add " + targetReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" +
	            "mov " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x\n" +
	            "add " + uvReg + ".y, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".z\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".z, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            "add " + uvReg + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".z\n" +
	            methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n" +
	            // recalculate fraction, since we ran out of registers :(
	            "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".x, " + customDataReg + ".y\n" +
	            "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" +
	            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
	            "add " + uvReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" +
	            "mul " + depthCol + ".x, " + this._pDepthMapCoordReg + ".y, " + customDataReg + ".y\n" +
	            "frc " + depthCol + ".x, " + depthCol + ".x\n" +
	            "sub " + uvReg + ".w, " + uvReg + ".w, " + targetReg + ".w\n" +
	            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
	            "add " + targetReg + ".w, " + targetReg + ".w, " + uvReg + ".w\n";
	        regCache.removeFragmentTempUsage(depthCol);
	        regCache.removeFragmentTempUsage(uvReg);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        var size = this.castingLight.shadowMapper.depthMapSize;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = size;
	        data[index + 1] = 1 / size;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowFilteredMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        var code;
	        var dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp, 1);
	        var predicate = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(predicate, 1);
	        code = methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".x, " + depthProjection + ".z, " + temp + ".z\n" +
	            "add " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".z, " + depthProjection + ".z, " + temp + ".z\n" +
	            "add " + depthProjection + ".y, " + depthProjection + ".y, " + dataReg + ".y\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".w, " + depthProjection + ".z, " + temp + ".z\n" +
	            "sub " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" +
	            methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + predicate + ".y, " + depthProjection + ".z, " + temp + ".z\n" +
	            "mul " + temp + ".xy, " + depthProjection + ".xy, " + dataReg + ".x\n" +
	            "frc " + temp + ".xy, " + temp + ".xy\n" +
	            // some strange register juggling to prevent agal bugging out
	            "sub " + depthProjection + ", " + predicate + ".xyzw, " + predicate + ".zwxy\n" +
	            "mul " + depthProjection + ", " + depthProjection + ", " + temp + ".x\n" +
	            "add " + predicate + ".xy, " + predicate + ".xy, " + depthProjection + ".zw\n" +
	            "sub " + predicate + ".y, " + predicate + ".y, " + predicate + ".x\n" +
	            "mul " + predicate + ".y, " + predicate + ".y, " + temp + ".y\n" +
	            "add " + targetRegister + ".w, " + predicate + ".x, " + predicate + ".y\n";
	        registerCache.removeFragmentTempUsage(temp);
	        registerCache.removeFragmentTempUsage(predicate);
	        return code;
	    };
	    return ShadowFilteredMethod;
	}(ShadowMethodBase_1.ShadowMethodBase));
	exports.ShadowFilteredMethod = ShadowFilteredMethod;


/***/ },
/* 258 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadowMethodBase_1 = __webpack_require__(256);
	/**
	 * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.
	 */
	var ShadowHardMethod = (function (_super) {
	    __extends(ShadowHardMethod, _super);
	    /**
	     * Creates a new ShadowHardMethod object.
	     */
	    function ShadowHardMethod(castingLight) {
	        _super.call(this, castingLight);
	    }
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var decReg = regCache.getFreeFragmentConstant();
	        regCache.getFreeFragmentConstant();
	        var depthCol = regCache.getFreeFragmentVectorTemp();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        code += methodVO.textureGL._iGetFragmentCode(depthCol, regCache, sharedRegisters, this._pDepthMapCoordReg) +
	            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
	            "slt " + targetReg + ".w, " + this._pDepthMapCoordReg + ".z, " + depthCol + ".z\n"; // 0 if in shadow
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype._pGetPointFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        var code = "";
	        var decReg = regCache.getFreeFragmentConstant();
	        var epsReg = regCache.getFreeFragmentConstant();
	        var posReg = regCache.getFreeFragmentConstant();
	        var depthSampleCol = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(depthSampleCol, 1);
	        var lightDir = regCache.getFreeFragmentVectorTemp();
	        regCache.addFragmentTempUsages(lightDir, 1);
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        code += "sub " + lightDir + ", " + sharedRegisters.globalPositionVarying + ", " + posReg + "\n" +
	            "dp3 " + lightDir + ".w, " + lightDir + ".xyz, " + lightDir + ".xyz\n" +
	            "mul " + lightDir + ".w, " + lightDir + ".w, " + posReg + ".w\n" +
	            "nrm " + lightDir + ".xyz, " + lightDir + ".xyz\n" +
	            methodVO.textureGL._iGetFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +
	            "dp4 " + depthSampleCol + ".z, " + depthSampleCol + ", " + decReg + "\n" +
	            "add " + targetReg + ".w, " + lightDir + ".w, " + epsReg + ".x\n" +
	            "slt " + targetReg + ".w, " + targetReg + ".w, " + depthSampleCol + ".z\n"; // 0 if in shadow
	        regCache.removeFragmentTempUsage(lightDir);
	        regCache.removeFragmentTempUsage(depthSampleCol);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + targetRegister + ".w, " + depthProjection + ".z, " + temp + ".z\n"; // 0 if in shadow
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowHardMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	    };
	    return ShadowHardMethod;
	}(ShadowMethodBase_1.ShadowMethodBase));
	exports.ShadowHardMethod = ShadowHardMethod;


/***/ },
/* 259 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodEvent_1 = __webpack_require__(227);
	var ShadowMethodBase_1 = __webpack_require__(256);
	// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work
	/**
	 * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize
	 * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.
	 *
	 * @see away.lights.NearDirectionalShadowMapper
	 */
	var ShadowNearMethod = (function (_super) {
	    __extends(ShadowNearMethod, _super);
	    /**
	     * Creates a new ShadowNearMethod object.
	     * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
	     * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
	     */
	    function ShadowNearMethod(baseMethod, fadeRatio) {
	        var _this = this;
	        if (fadeRatio === void 0) { fadeRatio = .1; }
	        _super.call(this, baseMethod.castingLight);
	        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
	        this._baseMethod = baseMethod;
	        this._fadeRatio = fadeRatio;
	        this._nearShadowMapper = this._pCastingLight.shadowMapper;
	        if (!this._nearShadowMapper)
	            throw new Error("ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.");
	        this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    }
	    Object.defineProperty(ShadowNearMethod.prototype, "baseMethod", {
	        /**
	         * The base shadow map method on which this method's shading is based.
	         */
	        get: function () {
	            return this._baseMethod;
	        },
	        set: function (value) {
	            if (this._baseMethod == value)
	                return;
	            this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this._baseMethod = value;
	            this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        this._baseMethod.iInitConstants(shader, methodVO);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        fragmentData[index + 2] = 0;
	        fragmentData[index + 3] = 1;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iInitVO = function (shader, methodVO) {
	        this._baseMethod.iInitVO(shader, methodVO);
	        methodVO.needsProjection = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.dispose = function () {
	        this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    };
	    Object.defineProperty(ShadowNearMethod.prototype, "alpha", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.alpha;
	        },
	        set: function (value) {
	            this._baseMethod.alpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowNearMethod.prototype, "epsilon", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.epsilon;
	        },
	        set: function (value) {
	            this._baseMethod.epsilon = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowNearMethod.prototype, "fadeRatio", {
	        /**
	         * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
	         */
	        get: function () {
	            return this._fadeRatio;
	        },
	        set: function (value) {
	            this._fadeRatio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iGetFragmentCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = this._baseMethod.iGetFragmentCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	        var dataReg = registerCache.getFreeFragmentConstant();
	        var temp = registerCache.getFreeFragmentSingleTemp();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        code += "abs " + temp + ", " + sharedRegisters.projectionFragment + ".w\n" +
	            "sub " + temp + ", " + temp + ", " + dataReg + ".x\n" +
	            "mul " + temp + ", " + temp + ", " + dataReg + ".y\n" +
	            "sat " + temp + ", " + temp + "\n" +
	            "sub " + temp + ", " + dataReg + ".w," + temp + "\n" +
	            "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + temp + "\n" +
	            "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        this._baseMethod.iActivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iDeactivate = function (shader, methodVO, stage) {
	        this._baseMethod.iDeactivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        // todo: move this to activate (needs camera)
	        var near = camera.projection.near;
	        var d = camera.projection.far - near;
	        var maxDistance = this._nearShadowMapper.coverageRatio;
	        var minDistance = maxDistance * (1 - this._fadeRatio);
	        maxDistance = near + maxDistance * d;
	        minDistance = near + minDistance * d;
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        fragmentData[index] = minDistance;
	        fragmentData[index + 1] = 1 / (maxDistance - minDistance);
	        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iReset = function () {
	        this._baseMethod.iReset();
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowNearMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._baseMethod.iCleanCompilationData();
	    };
	    /**
	     * Called when the base method's shader code is invalidated.
	     */
	    ShadowNearMethod.prototype.onShaderInvalidated = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    return ShadowNearMethod;
	}(ShadowMethodBase_1.ShadowMethodBase));
	exports.ShadowNearMethod = ShadowNearMethod;


/***/ },
/* 260 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PoissonLookup_1 = __webpack_require__(261);
	var ShadowMethodBase_1 = __webpack_require__(256);
	/**
	 * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.
	 */
	var ShadowSoftMethod = (function (_super) {
	    __extends(ShadowSoftMethod, _super);
	    /**
	     * Creates a new DiffuseBasicMethod object.
	     *
	     * @param castingLight The light casting the shadows
	     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.
	     */
	    function ShadowSoftMethod(castingLight, numSamples, range) {
	        if (numSamples === void 0) { numSamples = 5; }
	        if (range === void 0) { range = 1; }
	        _super.call(this, castingLight);
	        this._range = 1;
	        this.numSamples = numSamples;
	        this.range = range;
	    }
	    Object.defineProperty(ShadowSoftMethod.prototype, "numSamples", {
	        /**
	         * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the
	         * complexity of the shader.
	         */
	        get: function () {
	            return this._numSamples;
	        },
	        set: function (value) {
	            this._numSamples = value;
	            if (this._numSamples < 1)
	                this._numSamples = 1;
	            else if (this._numSamples > 32)
	                this._numSamples = 32;
	            this._offsets = PoissonLookup_1.PoissonLookup.getDistribution(this._numSamples);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShadowSoftMethod.prototype, "range", {
	        /**
	         * The range in the shadow map in which to distribute the samples.
	         */
	        get: function () {
	            return this._range;
	        },
	        set: function (value) {
	            this._range = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype.iInitConstants = function (shader, methodVO) {
	        _super.prototype.iInitConstants.call(this, shader, methodVO);
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 8] = 1 / this._numSamples;
	        shader.fragmentConstantData[methodVO.fragmentConstantsIndex + 9] = 0;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var texRange = .5 * this._range / this._pCastingLight.shadowMapper.depthMapSize;
	        var data = shader.fragmentConstantData;
	        var index = methodVO.fragmentConstantsIndex + 10;
	        var len = this._numSamples << 1;
	        for (var i = 0; i < len; ++i)
	            data[index + i] = this._offsets[i] * texRange;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype._pGetPlanarFragmentCode = function (shader, methodVO, targetReg, regCache, sharedRegisters) {
	        // todo: move some things to super
	        var decReg = regCache.getFreeFragmentConstant();
	        regCache.getFreeFragmentConstant();
	        var dataReg = regCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = decReg.index * 4;
	        return this.getSampleCode(shader, methodVO, decReg, targetReg, regCache, sharedRegisters, dataReg);
	    };
	    /**
	     * Adds the code for another tap to the shader code.
	     * @param uv The uv register for the tap.
	     * @param texture The texture register containing the depth map.
	     * @param decode The register containing the depth map decoding data.
	     * @param target The target register to add the tap comparison result.
	     * @param regCache The register cache managing the registers.
	     * @return
	     */
	    ShadowSoftMethod.prototype.addSample = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg) {
	        var temp = registerCache.getFreeFragmentVectorTemp();
	        return methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +
	            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	            "slt " + uvReg + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n" +
	            "add " + targetRegister + ".w, " + targetRegister + ".w, " + uvReg + ".w\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype.iActivateForCascade = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var texRange = this._range / this._pCastingLight.shadowMapper.depthMapSize;
	        var data = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var len = this._numSamples << 1;
	        data[index] = 1 / this._numSamples;
	        data[index + 1] = 0;
	        index += 2;
	        for (var i = 0; i < len; ++i)
	            data[index + i] = this._offsets[i] * texRange;
	        if (len % 4 == 0) {
	            data[index + len] = 0;
	            data[index + len + 1] = 0;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ShadowSoftMethod.prototype._iGetCascadeFragmentCode = function (shader, methodVO, decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
	        this._pDepthMapCoordReg = depthProjection;
	        var dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = dataReg.index * 4;
	        return this.getSampleCode(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);
	    };
	    /**
	     * Get the actual shader code for shadow mapping
	     * @param regCache The register cache managing the registers.
	     * @param depthTexture The texture register containing the depth map.
	     * @param decodeRegister The register containing the depth map decoding data.
	     * @param targetReg The target register to add the shadow coverage.
	     * @param dataReg The register containing additional data.
	     */
	    ShadowSoftMethod.prototype.getSampleCode = function (shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg) {
	        var code;
	        var uvReg = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(uvReg, 1);
	        var offsets = new Array(dataReg + ".zw");
	        var numRegs = this._numSamples >> 1;
	        for (var i = 0; i < numRegs; ++i) {
	            var reg = registerCache.getFreeFragmentConstant();
	            offsets.push(reg + ".xy");
	            offsets.push(reg + ".zw");
	        }
	        for (i = 0; i < this._numSamples; ++i) {
	            if (i == 0) {
	                var temp = registerCache.getFreeFragmentVectorTemp();
	                code = "add " + uvReg + ", " + this._pDepthMapCoordReg + ", " + dataReg + ".zwyy\n" +
	                    methodVO.textureGL._iGetFragmentCode(temp, registerCache, sharedRegisters, uvReg) +
	                    "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
	                    "slt " + targetRegister + ".w, " + this._pDepthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow;
	            }
	            else {
	                code += "add " + uvReg + ".xy, " + this._pDepthMapCoordReg + ".xy, " + offsets[i] + "\n" +
	                    this.addSample(shader, methodVO, decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);
	            }
	        }
	        registerCache.removeFragmentTempUsage(uvReg);
	        code += "mul " + targetRegister + ".w, " + targetRegister + ".w, " + dataReg + ".x\n"; // average
	        return code;
	    };
	    return ShadowSoftMethod;
	}(ShadowMethodBase_1.ShadowMethodBase));
	exports.ShadowSoftMethod = ShadowSoftMethod;


/***/ },
/* 261 */
/***/ function(module, exports) {

	"use strict";
	var PoissonLookup = (function () {
	    function PoissonLookup() {
	    }
	    PoissonLookup.initDistributions = function () {
	        // precalculated for best control
	        this._distributions = new Array();
	        this._distributions[0] = new Array(0.3082841, 0.4320919);
	        this._distributions[1] = new Array(0.3082841, 0.4320919, -0.2274942, -0.6640266);
	        this._distributions[2] = new Array(0.8742689, 0.0009265686, -0.6864116, -0.5536607, -0.2325206, 0.7678371);
	        this._distributions[3] = new Array(0.3913446, -0.7084417, -0.7511101, -0.5935929, -0.2323436, 0.5320091, 0.8435315, 0.5035911);
	        this._distributions[4] = new Array(0.2122471, -0.5771395, -0.8543506, -0.1763534, 0.5189021, 0.8323698, -0.3616908, 0.5865368, 0.9523004, -0.04948437);
	        this._distributions[5] = new Array(0.5791035, 0.3496495, 0.2959551, -0.6006749, -0.2419119, -0.06879545, -0.7403072, 0.6110353, -0.04555973, 0.8059174, -0.5275017, -0.737129);
	        this._distributions[6] = new Array(0.06941478, 0.8519508, -0.7441907, 0.2426432, 0.6439992, -0.2405252, -0.1007523, -0.2327587, -0.6427067, -0.7248485, 0.8050759, 0.5492936, 0.3573822, -0.8824506);
	        this._distributions[7] = new Array(0.8509863, 0.4452587, -0.09507271, 0.2073005, 0.1706571, -0.6434793, 0.8029777, -0.2718274, -0.4401725, 0.8196304, 0.2715359, 0.8598521, -0.8121575, -0.006447683, -0.6486837, -0.7237598);
	        this._distributions[8] = new Array(0.6951686, -0.2680728, -0.04933243, 0.3710589, 0.6592212, 0.3661054, -0.01579228, -0.6909603, -0.3275101, -0.1756866, 0.3811549, 0.9218544, -0.216032, 0.9755028, -0.7065172, 0.3355389, -0.6579109, -0.6798355);
	        this._distributions[9] = new Array(0.6181276, -0.09790418, -0.2537868, -0.5570995, -0.1964931, 0.3459414, 0.3474613, -0.8885581, 0.5135743, 0.5753114, -0.9549091, 0.1480672, -0.8711916, -0.4293123, -0.6928071, 0.6190156, -0.13369, 0.8892705, 0.0548224, -0.1246777);
	        this._distributions[10] = new Array(0.4853027, -0.5080479, -0.1331675, -0.506597, 0.139575, 0.01316885, 0.803486, -0.07568797, 0.5240274, 0.4883182, -0.4334005, 0.1207938, -0.7794577, -0.3985141, 0.1576432, -0.9861221, -0.3712867, 0.6959021, 0.1517378, 0.9847429, -0.9762396, 0.1661073);
	        this._distributions[11] = new Array(-0.2790166, -0.01252619, 0.3389016, 0.3921154, 0.2408341, -0.313211, -0.8151779, -0.3898362, -0.6347761, 0.3486495, 0.09471484, -0.7722448, -0.1385674, 0.6364574, 0.2456331, 0.9295807, -0.3864306, -0.8247881, 0.6111673, -0.7164014, 0.8287669, 0.05466961, 0.837706, 0.5415626);
	        this._distributions[12] = new Array(0.056417, 0.3185693, -0.8245888, 0.1882799, 0.8575996, 0.1136829, 0.1070375, 0.875332, 0.4076743, -0.06000621, -0.4311306, 0.7239349, 0.2677574, -0.538472, -0.08486642, -0.2083647, -0.888989, -0.3906443, -0.4768958, -0.6664082, 0.09334993, -0.9861541, 0.808736, -0.455949, 0.5889823, 0.7660807);
	        this._distributions[13] = new Array(-0.2681346, -0.3955857, -0.1315102, -0.8852947, -0.5143692, 0.09551838, 0.4344836, -0.546945, -0.8620899, -0.3813288, 0.1650431, 0.02034803, -0.1543657, 0.3842218, -0.828457, 0.5376903, -0.6145, -0.7818927, -0.2639062, 0.8784655, 0.1912684, 0.9720125, 0.3135219, 0.5224229, 0.7850655, 0.4592297, 0.7465045, -0.1368916);
	        this._distributions[14] = new Array(0.4241029, 0.695281, 0.150511, -0.02304107, -0.2482675, 0.9120338, 0.8057325, 0.2622084, -0.2445909, 0.2765962, 0.8588713, -0.1772072, 0.3117845, -0.4385471, -0.3923851, -0.3298936, -0.1751254, -0.7405846, 0.6926506, -0.684163, -0.9304563, -0.3254691, -0.8533293, 0.1523024, 0.2510415, -0.917345, -0.6239773, -0.7105472, -0.6104624, 0.6041355);
	        this._distributions[15] = new Array(0.5844554, 0.06651045, 0.1343258, 0.6756578, 0.3799674, -0.6301104, 0.5590436, 0.7940555, 0.09574714, 0.02262517, 0.8697868, 0.393301, 0.003945862, -0.421735, 0.9043913, -0.2432393, -0.4844007, 0.7190998, -0.3201078, 0.2972371, -0.3852352, -0.6341155, -0.5413069, -0.09223081, -0.8468984, -0.5126905, 0.004156174, -0.8633173, -0.9681889, -0.03305046, -0.846509, 0.4414353);
	        this._distributions[16] = new Array(0.4506488, 0.657668, 0.4621297, 0.07441051, -0.2782125, 0.6201044, 0.9750003, 0.09110117, 0.1019436, 0.2986514, 0.03457398, 0.9631706, 0.542098, -0.5505635, 0.8675668, 0.4938077, -0.5414361, 0.2655292, -0.7941836, 0.6003053, -0.09847672, -0.1001604, -0.9316511, -0.08572888, 0.07286467, -0.611899, -0.5232627, -0.4082253, -0.5481608, -0.827938, -0.1551939, -0.9621193, 0.9220031, -0.3315949);
	        this._distributions[17] = new Array(0.197908, -0.4697656, -0.4474689, -0.3428435, 0.8529873, -0.2228634, 0.6022478, -0.5469642, 0.2545276, -0.931133, -0.1507547, -0.7855865, -0.07606658, 0.1011628, 0.3046715, 0.2785755, 0.4698432, -0.1064076, 0.6831254, 0.4152522, 0.1374381, 0.8363233, -0.2166121, 0.6682042, 0.5511393, 0.7996449, -0.4278994, 0.28836, -0.8875198, 0.2181732, -0.8772842, -0.2818254, -0.7000262, 0.5762185, -0.6062385, -0.7439126);
	        this._distributions[18] = new Array(0.6645703, -0.05678739, 0.5720971, 0.4533803, -0.07660709, 0.08802763, 0.5163431, -0.4426552, 0.1163455, -0.3404382, -0.4004807, -0.5046007, 0.2932099, -0.8201418, -0.5322125, 0.03834766, -0.1490209, -0.8817304, -0.8000439, -0.3509448, 0.5260983, 0.8421043, 0.1197811, 0.6963812, 0.9498612, 0.3122156, -0.9285746, 0.02120355, -0.6670724, 0.7217396, 0.9155889, -0.3510147, -0.271941, 0.4727852, 0.318879, 0.1634057, -0.2686755, 0.9253026);
	        this._distributions[19] = new Array(0.5064292, 0.422527, 0.8935515, -0.06610427, 0.1199719, 0.175568, 0.403388, -0.2003276, 0.1657927, 0.8154403, 0.9301245, 0.2929218, -0.1644068, 0.6201534, 0.7113559, -0.6589743, -0.3364046, -0.1799502, 0.02109996, -0.392765, -0.382213, 0.3219992, -0.9201946, 0.1207967, -0.726185, 0.4291916, -0.7443482, -0.2480059, -0.5147594, 0.7418784, 0.1935272, -0.7406143, -0.3643523, -0.5559214, -0.7147766, -0.6326278, -0.2524151, -0.9096627, 0.5161405, 0.7908453);
	        this._distributions[20] = new Array(0.7921003, -0.3032096, 0.5992879, -0.009052323, 0.2538549, -0.1872749, 0.7053444, 0.3677175, 0.5417761, -0.8170255, 0.9749611, 0.1210478, 0.1969143, -0.6117041, -0.1824499, -0.4634196, -0.1181338, -0.8668742, -0.3050112, -0.1352596, -0.4409327, -0.7082354, -0.03225285, 0.1171548, 0.3113096, 0.3250439, -0.8166144, -0.463995, -0.01014475, 0.4715334, -0.6868284, 0.05091889, -0.4011163, 0.2717285, -0.06756835, 0.8307694, -0.7938535, 0.4352129, -0.4663842, 0.7165329, 0.559729, 0.8093995);
	        this._distributions[21] = new Array(0.07832243, 0.426151, -0.3856795, 0.5799953, 0.01970797, 0.06706189, 0.4822682, 0.3014512, -0.1532982, 0.87485, -0.4959527, 0.07888043, 0.260601, -0.2304784, 0.4996209, 0.7167382, 0.585986, -0.04265174, -0.7679967, 0.5509416, -0.9041753, 0.1802134, -0.8407655, -0.4442826, -0.2058258, -0.2636995, -0.4984115, -0.5928579, 0.2926032, -0.7886473, -0.06933882, -0.621177, 0.578115, -0.4813387, 0.8981777, -0.3291056, 0.1942733, 0.9255584, 0.8084362, 0.5066984, 0.9920095, 0.03103104, -0.2403206, -0.9389018);
	        this._distributions[22] = new Array(-0.5691095, 0.1014316, -0.7788262, 0.384012, -0.8253665, -0.1645582, -0.1830993, 0.002997211, -0.2555013, -0.4177977, -0.6640869, -0.4794711, -0.2351242, 0.5850121, 0.02436554, 0.2825883, 0.006061143, -0.8200245, 0.1618791, -0.3063331, -0.3765897, -0.7249815, 0.6092919, -0.6769328, -0.5956934, 0.6957655, 0.5383642, 0.4522677, -0.1489165, 0.9125596, 0.4167473, 0.1335986, 0.1898309, 0.5874342, 0.2288171, 0.9624356, 0.7540846, -0.07672304, 0.8986252, 0.2788797, 0.3555991, -0.9262139, 0.8454325, -0.4027667, 0.4945236, -0.2935512);
	        this._distributions[23] = new Array(-0.4481403, -0.3758374, -0.8877251, 0.08739938, 0.05015831, -0.1339983, -0.4070427, -0.8534173, 0.1019274, -0.5503222, -0.445998, 0.1997541, -0.8686263, -0.2788867, -0.7695944, -0.6033704, -0.05515742, -0.885711, -0.7714347, 0.5790485, 0.3466263, -0.8799297, 0.4487582, -0.5321087, -0.2461368, 0.6053771, -0.05568117, 0.2457351, -0.4668669, 0.8523816, 0.8103387, -0.4255538, 0.4054182, -0.175663, -0.2802011, -0.08920153, 0.2665959, 0.382935, 0.555679, 0.1621837, 0.105246, 0.8420411, 0.6921161, 0.6902903, 0.880946, 0.2483067, 0.9699264, -0.1021767);
	        this._distributions[24] = new Array(-0.1703323, -0.3119385, 0.2916039, -0.2988263, -0.008472982, -0.9277695, -0.7730271, -0.3277904, 0.3440474, -0.6815342, -0.2910278, 0.03461745, -0.6764899, -0.657078, -0.3505501, -0.7311988, -0.03478927, 0.3258755, -0.6048835, 0.159423, 0.2035525, 0.02212214, 0.5116573, 0.2226856, 0.6664805, -0.2500189, 0.7147882, -0.6609634, 0.03030632, -0.5763278, -0.2516585, 0.6116219, -0.9434413, -0.0116792, 0.9061816, 0.2491155, 0.182867, 0.6076167, 0.286593, 0.9485695, -0.5992439, 0.6970096, -0.2082874, 0.9416641, 0.9880044, -0.1541709, -0.9122881, 0.331555, 0.7324886, 0.6725098);
	        this._distributions[25] = new Array(0.3869598, -0.04974834, 0.7168844, -0.0693711, -0.07166742, 0.1725325, 0.4599592, 0.3232779, 0.5872094, -0.4198674, 0.2442266, -0.625667, 0.1254557, 0.4500048, -0.2290154, -0.1803567, 0.890583, 0.3373493, 0.1256081, 0.7853789, -0.2676466, 0.5305805, -0.7063224, 0.252168, -0.3989835, 0.1189921, 0.09617215, -0.2451447, 0.6302541, 0.6085876, 0.9380925, -0.3234899, 0.5086241, -0.8573482, 0.03576187, -0.9876697, -0.0876712, -0.6365195, -0.5276513, 0.823456, -0.6935764, -0.2240411, -0.5212318, -0.5383121, -0.2116208, 0.9639363, -0.9840096, 0.02743555, -0.3991577, -0.8994547, -0.7830126, 0.614068);
	        this._distributions[26] = new Array(-0.8366601, 0.4464895, -0.5917366, -0.02073906, -0.9845258, 0.1635625, -0.3097973, 0.4379579, -0.5478154, 0.7173221, -0.1685888, 0.9261969, 0.01503595, 0.6046097, 0.4452421, 0.5449086, 0.0315687, 0.1944619, 0.3753404, 0.8688548, 0.4143643, 0.1396648, 0.8711032, 0.4304703, 0.7328773, 0.1461501, 0.6374492, -0.3521495, 0.145613, -0.1341466, 0.9040975, -0.135123, -0.7839059, -0.5450199, -0.516019, -0.3320859, -0.206158, -0.4431106, -0.9703014, -0.2368356, -0.2473119, -0.0864351, 0.2130725, -0.4604077, -0.003726701, -0.7122303, -0.4072131, -0.6833169, 0.1632999, -0.9776646, 0.4686888, -0.680495, -0.2293511, -0.9509777);
	        this._distributions[27] = new Array(0.107311, -0.1311369, -0.4194764, -0.3148777, 0.6171439, -0.2745973, 0.2796618, 0.1937153, -0.09106886, 0.4180236, 0.6044006, 0.05577846, 0.02927299, -0.6738263, -0.2580845, 0.1179939, -0.09023564, -0.3830024, 0.3570953, -0.5000587, 0.81591, -0.5518309, 0.9300217, -0.1257987, 0.4904627, -0.8381903, -0.3163182, -0.8632009, 0.1137595, -0.9875998, 0.8390043, 0.3538185, 0.2149114, 0.4993694, 0.5191584, 0.3833552, 0.5002763, 0.7061465, -0.2567276, 0.9068756, -0.5197366, 0.3467845, 0.03668867, 0.9734009, -0.5347553, 0.66747, -0.9028882, 0.1023768, -0.8967977, 0.412834, -0.5821944, 0.0426479, -0.8032165, -0.2397038, -0.5597343, -0.6358021);
	        this._distributions[28] = new Array(-0.6562496, -0.1781036, -0.9301494, 0.1185208, -0.3861143, -0.4153562, -0.1560799, -0.1099607, -0.5587025, 0.395218, -0.5322112, -0.699701, -0.5008639, 0.08726846, -0.970524, -0.1963461, -0.813577, -0.5185111, -0.1644458, 0.298, -0.3216791, 0.639982, 0.3315373, 0.3339162, 0.2383235, -0.00105722, 0.1137828, 0.5450742, -0.01899921, 0.8798413, 0.2849685, 0.8255596, 0.6974412, 0.2123175, 0.7588523, 0.5470437, 0.5102502, -0.1687844, 0.5853448, 0.8033476, 0.2590716, -0.5262504, 0.5607718, -0.6342825, 0.8666443, -0.1491841, 0.8341052, -0.4935003, -0.1568441, -0.6634066, 0.2512113, -0.8769391, -0.2559827, -0.9572457, -0.01928852, -0.3966542, -0.750667, 0.6409678);
	        this._distributions[29] = new Array(0.3454786, -0.04837726, 0.2649553, 0.2406852, 0.5599093, -0.3839145, -0.1111814, -0.05502108, 0.7586042, -0.05818377, 0.2519488, -0.4665135, -0.1264972, 0.2602723, -0.08766216, -0.3671907, 0.6428129, 0.3999204, -0.6105871, -0.1246869, -0.4589451, -0.7646643, -0.03021116, -0.7899352, -0.6036922, -0.4293956, -0.2481938, 0.6534185, 0.102798, 0.6784465, -0.6392644, 0.4821358, -0.6789002, 0.1779133, -0.9140783, -0.1989647, -0.9262617, 0.3381507, 0.4794891, -0.8093274, 0.3959447, 0.668478, 0.9602883, 0.2272305, -0.123672, 0.9210883, 0.2375148, 0.9523395, -0.52898, 0.7973378, -0.382433, 0.1228794, 0.695015, 0.6948439, 0.7530277, -0.6458191, 0.8777987, -0.3272956, 0.2318525, -0.962768);
	        this._distributions[30] = new Array(0.4518921, -0.1146195, 0.4720805, -0.4238748, 0.3655423, 0.1806341, 0.1589939, -0.23568, 0.7673324, -0.5149941, 0.01163658, 0.09045836, 0.7010971, 0.1245747, 0.7518286, -0.1855433, 0.4960719, 0.4601022, 0.2566979, -0.6308268, -0.0654714, -0.5126389, -0.1823319, -0.1343282, -0.1464312, 0.4883236, -0.3858738, 0.203523, 0.1484799, 0.4432284, -0.477109, -0.116241, 0.2719092, 0.7208626, 0.9104174, 0.3578536, -0.5956199, 0.7662588, -0.6996251, 0.3678654, -0.2514512, 0.9251933, 0.1275825, -0.9478135, -0.204608, -0.8611552, 0.4264838, -0.877443, 0.9854161, 0.05521112, 0.5912951, 0.7997434, 0.1140349, 0.982093, -0.9324368, -0.2094094, -0.42436, -0.6441524, -0.6722705, -0.3554261, -0.7844236, 0.08587621);
	        this._distributions[31] = new Array(-0.4206714, -0.5613642, -0.8733016, -0.3373051, -0.1046226, -0.2902999, -0.1318562, -0.8434365, 0.1145093, -0.5962623, -0.4965627, -0.1873259, -0.5011808, -0.8546229, -0.7165636, -0.5743566, 0.1090901, 0.2017643, 0.3404809, -0.220455, -0.1989015, 0.2372122, -0.4538706, 0.0979171, 0.4514146, -0.572846, 0.2314168, -0.8514503, -0.4247236, 0.5650803, -0.943347, 0.04514639, -0.1309718, 0.5221877, -0.7004157, 0.4561877, 0.6306441, 0.04448673, 0.4301621, 0.5766876, 0.1078042, 0.7245752, 0.3875354, 0.2794483, 0.702876, -0.2924213, 0.7360667, -0.6210318, 0.7486517, 0.6531103, 0.4898235, 0.8591025, 0.6549174, 0.3854057, -0.2596106, 0.7916998, 0.9251194, -0.05296265, -0.5620695, 0.820877, -0.01228026, 0.9937211, 0.9612103, 0.2628758);
	    };
	    PoissonLookup.getDistribution = function (n /*int*/) {
	        if (!this._distributions)
	            this.initDistributions();
	        if (n < 2 || n > 32)
	            return null;
	        return this._distributions[n - 1];
	    };
	    return PoissonLookup;
	}());
	exports.PoissonLookup = PoissonLookup;


/***/ },
/* 262 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularBasicMethod_1 = __webpack_require__(263);
	/**
	 * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for
	 * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.
	 * The tangent vectors are used as the surface groove directions.
	 */
	var SpecularAnisotropicMethod = (function (_super) {
	    __extends(SpecularAnisotropicMethod, _super);
	    /**
	     * Creates a new SpecularAnisotropicMethod object.
	     */
	    function SpecularAnisotropicMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularAnisotropicMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsTangents = true;
	        methodVO.needsView = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularAnisotropicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        if (this._pIsFirstLight)
	            t = this._pTotalLightColorReg;
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        // (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k
	        code += "nrm " + t + ".xyz, " + sharedRegisters.tangentVarying + ".xyz\n" +
	            "dp3 " + t + ".w, " + t + ".xyz, " + lightDirReg + ".xyz\n" +
	            "dp3 " + t + ".z, " + t + ".xyz, " + sharedRegisters.viewDirFragment + ".xyz\n";
	        // (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k
	        code += "sin " + t + ".x, " + t + ".w\n" +
	            "sin " + t + ".y, " + t + ".z\n" +
	            // (t.x * t.y - cos(t.w)*cos(t.z)) ^ k
	            "mul " + t + ".x, " + t + ".x, " + t + ".y\n" +
	            // (t.x - cos(t.w)*cos(t.z)) ^ k
	            "cos " + t + ".z, " + t + ".z\n" +
	            "cos " + t + ".w, " + t + ".w\n" +
	            // (t.x - t.w*t.z) ^ k
	            "mul " + t + ".w, " + t + ".w, " + t + ".z\n" +
	            // (t.x - t.w) ^ k
	            "sub " + t + ".w, " + t + ".x, " + t + ".w\n";
	        if (this.texture) {
	            // apply gloss modulation from texture
	            code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" +
	                "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
	        }
	        else
	            code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
	        // attenuate
	        code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    return SpecularAnisotropicMethod;
	}(SpecularBasicMethod_1.SpecularBasicMethod));
	exports.SpecularAnisotropicMethod = SpecularAnisotropicMethod;


/***/ },
/* 263 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var LightingMethodBase_1 = __webpack_require__(231);
	/**
	 * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
	 * version of Phong specularity).
	 */
	var SpecularBasicMethod = (function (_super) {
	    __extends(SpecularBasicMethod, _super);
	    /**
	     * Creates a new SpecularBasicMethod object.
	     */
	    function SpecularBasicMethod() {
	        _super.call(this);
	        this._gloss = 50;
	        this._strength = 1;
	        this._color = 0xffffff;
	        this._iSpecularR = 1;
	        this._iSpecularG = 1;
	        this._iSpecularB = 1;
	    }
	    SpecularBasicMethod.prototype.iIsUsed = function (shader) {
	        if (!shader.numLights)
	            return false;
	        return true;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iInitVO = function (shader, methodVO) {
	        methodVO.needsNormals = shader.numLights > 0;
	        methodVO.needsView = shader.numLights > 0;
	        if (this._texture) {
	            methodVO.textureGL = shader.getAbstraction(this._texture);
	            shader.uvDependencies++;
	        }
	        else if (methodVO.textureGL) {
	            methodVO.textureGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, null));
	            methodVO.textureGL = null;
	        }
	    };
	    Object.defineProperty(SpecularBasicMethod.prototype, "gloss", {
	        /**
	         * The glossiness of the material (sharpness of the specular highlight).
	         */
	        get: function () {
	            return this._gloss;
	        },
	        set: function (value) {
	            this._gloss = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularBasicMethod.prototype, "strength", {
	        /**
	         * The overall strength of the specular highlights.
	         */
	        get: function () {
	            return this._strength;
	        },
	        set: function (value) {
	            if (value == this._strength)
	                return;
	            this._strength = value;
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularBasicMethod.prototype, "color", {
	        /**
	         * The colour of the specular reflection of the surface.
	         */
	        get: function () {
	            return this._color;
	        },
	        set: function (value) {
	            if (this._color == value)
	                return;
	            // specular is now either enabled or disabled
	            if (this._color == 0 || value == 0)
	                this.iInvalidateShaderProgram();
	            this._color = value;
	            this.updateSpecular();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularBasicMethod.prototype, "texture", {
	        /**
	         * A texture that defines the strength of specular reflections for each texel in the red channel,
	         * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set
	         * specular and gloss maps from grayscale images, but correctly authored images are preferred.
	         */
	        get: function () {
	            return this._texture;
	        },
	        set: function (value) {
	            if (this._texture == value)
	                return;
	            if (this._texture)
	                this.iRemoveTexture(this._texture);
	            this._texture = value;
	            if (this._texture)
	                this.iAddTexture(this._texture);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.copyFrom = function (method) {
	        var m = method;
	        var bsm = method;
	        var spec = bsm; //SpecularBasicMethod(method);
	        this.texture = spec.texture;
	        this.strength = spec.strength;
	        this.color = spec.color;
	        this.gloss = spec.gloss;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._pTotalLightColorReg = null;
	        this._pSpecularTexData = null;
	        this._pSpecularDataRegister = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        var code = "";
	        this._pIsFirstLight = true;
	        this._pSpecularDataRegister = registerCache.getFreeFragmentConstant();
	        methodVO.fragmentConstantsIndex = this._pSpecularDataRegister.index * 4;
	        if (this._texture) {
	            this._pSpecularTexData = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(this._pSpecularTexData, 1);
	            code += methodVO.textureGL._iGetFragmentCode(this._pSpecularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	        }
	        this._pTotalLightColorReg = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(this._pTotalLightColorReg, 1);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        var normalReg = sharedRegisters.normalFragment;
	        // blinn-phong half vector model
	        code += "add " + t + ", " + lightDirReg + ", " + viewDirReg + "\n" +
	            "nrm " + t + ".xyz, " + t + "\n" +
	            "dp3 " + t + ".w, " + normalReg + ", " + t + "\n" +
	            "sat " + t + ".w, " + t + ".w\n";
	        if (this._texture) {
	            // apply gloss modulation from texture
	            code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" +
	                "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
	        }
	        else {
	            code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
	        }
	        // attenuate
	        if (shader.usesLightFallOff)
	            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ".xyz, " + lightColReg + ", " + t + ".w\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        // write in temporary if not first light, so we can add to total diffuse colour
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        var normalReg = sharedRegisters.normalFragment;
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        code += "dp3 " + t + ".w, " + normalReg + ", " + viewDirReg + "\n" +
	            "add " + t + ".w, " + t + ".w, " + t + ".w\n" +
	            "mul " + t + ", " + t + ".w, " + normalReg + "\n" +
	            "sub " + t + ", " + t + ", " + viewDirReg + "\n" +
	            "tex " + t + ", " + t + ", " + cubeMapReg + " <cube," + "linear" + ",miplinear>\n" +
	            "mul " + t + ".xyz, " + t + ", " + weightRegister + "\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + t + "\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code = "";
	        if (sharedRegisters.shadowTarget)
	            code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
	        if (this._texture) {
	            // apply strength modulation from texture
	            code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularTexData + ".x\n";
	            registerCache.removeFragmentTempUsage(this._pSpecularTexData);
	        }
	        // apply material's specular reflection
	        code += "mul " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ", " + this._pSpecularDataRegister + "\n" +
	            "add " + targetReg + ".xyz, " + targetReg + ", " + this._pTotalLightColorReg + "\n";
	        registerCache.removeFragmentTempUsage(this._pTotalLightColorReg);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularBasicMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        if (this._texture)
	            methodVO.textureGL.activate(methodVO.pass._render);
	        var index = methodVO.fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._iSpecularR;
	        data[index + 1] = this._iSpecularG;
	        data[index + 2] = this._iSpecularB;
	        data[index + 3] = this._gloss;
	    };
	    SpecularBasicMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        if (this._texture)
	            methodVO.textureGL._setRenderState(renderable);
	    };
	    /**
	     * Updates the specular color data used by the render state.
	     */
	    SpecularBasicMethod.prototype.updateSpecular = function () {
	        this._iSpecularR = ((this._color >> 16) & 0xff) / 0xff * this._strength;
	        this._iSpecularG = ((this._color >> 8) & 0xff) / 0xff * this._strength;
	        this._iSpecularB = (this._color & 0xff) / 0xff * this._strength;
	    };
	    return SpecularBasicMethod;
	}(LightingMethodBase_1.LightingMethodBase));
	exports.SpecularBasicMethod = SpecularBasicMethod;


/***/ },
/* 264 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularCompositeMethod_1 = __webpack_require__(265);
	/**
	 * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.
	 */
	var SpecularCelMethod = (function (_super) {
	    __extends(SpecularCelMethod, _super);
	    /**
	     * Creates a new SpecularCelMethod object.
	     * @param specularCutOff The threshold at which the specular highlight should be shown.
	     * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.
	     */
	    function SpecularCelMethod(specularCutOff, baseMethod) {
	        var _this = this;
	        if (specularCutOff === void 0) { specularCutOff = .5; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this, null, baseMethod);
	        this._smoothness = .1;
	        this._specularCutOff = .1;
	        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.clampSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };
	        this._specularCutOff = specularCutOff;
	    }
	    Object.defineProperty(SpecularCelMethod.prototype, "smoothness", {
	        /**
	         * The smoothness of the highlight edge.
	         */
	        get: function () {
	            return this._smoothness;
	        },
	        set: function (value) {
	            this._smoothness = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCelMethod.prototype, "specularCutOff", {
	        /**
	         * The threshold at which the specular highlight should be shown.
	         */
	        get: function () {
	            return this._specularCutOff;
	        },
	        set: function (value) {
	            this._specularCutOff = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularCelMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = this._smoothness;
	        data[index + 1] = this._specularCutOff;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCelMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._dataReg = null;
	    };
	    /**
	     * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff
	     * @param vo The MethodVO used to compile the current shader.
	     * @param t The register containing the specular strength in the "w" component, and either the half-vector or the reflection vector in "xyz".
	     * @param regCache The register cache used for the shader compilation.
	     * @param sharedRegisters The shared register data for this shader.
	     * @return The AGAL fragment code for the method.
	     */
	    SpecularCelMethod.prototype.clampSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return "sub " + targetReg + ".y, " + targetReg + ".w, " + this._dataReg + ".y\n" +
	            "div " + targetReg + ".y, " + targetReg + ".y, " + this._dataReg + ".x\n" +
	            "sat " + targetReg + ".y, " + targetReg + ".y\n" +
	            "sge " + targetReg + ".w, " + targetReg + ".w, " + this._dataReg + ".y\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        this._dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
	        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	    };
	    return SpecularCelMethod;
	}(SpecularCompositeMethod_1.SpecularCompositeMethod));
	exports.SpecularCelMethod = SpecularCelMethod;


/***/ },
/* 265 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ShadingMethodEvent_1 = __webpack_require__(227);
	var SpecularBasicMethod_1 = __webpack_require__(263);
	/**
	 * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the
	 * calculated specular reflection strength.
	 */
	var SpecularCompositeMethod = (function (_super) {
	    __extends(SpecularCompositeMethod, _super);
	    /**
	     * Creates a new <code>SpecularCompositeMethod</code> object.
	     *
	     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature modSpecular(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the specular strength and t.xyz will contain the half-vector or the reflection vector.
	     * @param baseMethod The base specular method on which this method's shading is based.
	     */
	    function SpecularCompositeMethod(modulateMethod, baseMethod) {
	        var _this = this;
	        if (baseMethod === void 0) { baseMethod = null; }
	        _super.call(this);
	        this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
	        this._baseMethod = baseMethod || new SpecularBasicMethod_1.SpecularBasicMethod();
	        this._baseMethod._iModulateMethod = modulateMethod;
	        this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iInitVO = function (shader, methodVO) {
	        this._baseMethod.iInitVO(shader, methodVO);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iInitConstants = function (shader, methodVO) {
	        this._baseMethod.iInitConstants(shader, methodVO);
	    };
	    SpecularCompositeMethod.prototype.iAddOwner = function (owner) {
	        _super.prototype.iAddOwner.call(this, owner);
	        this._baseMethod.iAddOwner(owner);
	    };
	    SpecularCompositeMethod.prototype.iRemoveOwner = function (owner) {
	        _super.prototype.iRemoveOwner.call(this, owner);
	        this._baseMethod.iRemoveOwner(owner);
	    };
	    Object.defineProperty(SpecularCompositeMethod.prototype, "baseMethod", {
	        /**
	         * The base specular method on which this method's shading is based.
	         */
	        get: function () {
	            return this._baseMethod;
	        },
	        set: function (value) {
	            if (this._baseMethod == value)
	                return;
	            this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this._baseMethod = value;
	            this._baseMethod.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCompositeMethod.prototype, "gloss", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.gloss;
	        },
	        set: function (value) {
	            this._baseMethod.gloss = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCompositeMethod.prototype, "strength", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.strength;
	        },
	        set: function (value) {
	            this._baseMethod.strength = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularCompositeMethod.prototype, "color", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.color;
	        },
	        /**
	         * @inheritDoc
	         */
	        set: function (value) {
	            this._baseMethod.color = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.dispose = function () {
	        this._baseMethod.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
	        this._baseMethod.dispose();
	    };
	    Object.defineProperty(SpecularCompositeMethod.prototype, "texture", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return this._baseMethod.texture;
	        },
	        set: function (value) {
	            this._baseMethod.texture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        this._baseMethod.iActivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iSetRenderState = function (shader, methodVO, renderable, stage, camera) {
	        this._baseMethod.iSetRenderState(shader, methodVO, renderable, stage, camera);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iDeactivate = function (shader, methodVO, stage) {
	        this._baseMethod.iDeactivate(shader, methodVO, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetVertexCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetVertexCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentPreLightingCode(shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentCodePerLight(shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     * @return
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentCodePerProbe = function (shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentCodePerProbe(shader, methodVO, cubeMapReg, weightRegister, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iGetFragmentPostLightingCode = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        return this._baseMethod.iGetFragmentPostLightingCode(shader, methodVO, targetReg, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iReset = function () {
	        this._baseMethod.iReset();
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularCompositeMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._baseMethod.iCleanCompilationData();
	    };
	    /**
	     * Called when the base method's shader code is invalidated.
	     */
	    SpecularCompositeMethod.prototype.onShaderInvalidated = function (event) {
	        this.iInvalidateShaderProgram();
	    };
	    return SpecularCompositeMethod;
	}(SpecularBasicMethod_1.SpecularBasicMethod));
	exports.SpecularCompositeMethod = SpecularCompositeMethod;


/***/ },
/* 266 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularCompositeMethod_1 = __webpack_require__(265);
	/**
	 * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.
	 */
	var SpecularFresnelMethod = (function (_super) {
	    __extends(SpecularFresnelMethod, _super);
	    /**
	     * Creates a new SpecularFresnelMethod object.
	     * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
	     * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.
	     */
	    function SpecularFresnelMethod(basedOnSurface, baseMethod) {
	        var _this = this;
	        if (basedOnSurface === void 0) { basedOnSurface = true; }
	        if (baseMethod === void 0) { baseMethod = null; }
	        // may want to offer diff speculars
	        _super.call(this, null, baseMethod);
	        this._fresnelPower = 5;
	        this._normalReflectance = .028; // default value for skin
	        this.baseMethod._iModulateMethod = function (shader, methodVO, targetReg, registerCache, sharedRegisters) { return _this.modulateSpecular(shader, methodVO, targetReg, registerCache, sharedRegisters); };
	        this._incidentLight = !basedOnSurface;
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iInitConstants = function (shader, methodVO) {
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        shader.fragmentConstantData[index + 2] = 1;
	        shader.fragmentConstantData[index + 3] = 0;
	    };
	    Object.defineProperty(SpecularFresnelMethod.prototype, "basedOnSurface", {
	        /**
	         * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
	         */
	        get: function () {
	            return !this._incidentLight;
	        },
	        set: function (value) {
	            if (this._incidentLight != value)
	                return;
	            this._incidentLight = !value;
	            this.iInvalidateShaderProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SpecularFresnelMethod.prototype, "fresnelPower", {
	        /**
	         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
	         */
	        get: function () {
	            return this._fresnelPower;
	        },
	        set: function (value) {
	            this._fresnelPower = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iCleanCompilationData = function () {
	        _super.prototype.iCleanCompilationData.call(this);
	        this._dataReg = null;
	    };
	    Object.defineProperty(SpecularFresnelMethod.prototype, "normalReflectance", {
	        /**
	         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
	         */
	        get: function () {
	            return this._normalReflectance;
	        },
	        set: function (value) {
	            this._normalReflectance = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iActivate = function (shader, methodVO, stage) {
	        _super.prototype.iActivate.call(this, shader, methodVO, stage);
	        var fragmentData = shader.fragmentConstantData;
	        var index = methodVO.secondaryFragmentConstantsIndex;
	        fragmentData[index] = this._normalReflectance;
	        fragmentData[index + 1] = this._fresnelPower;
	    };
	    /**
	     * @inheritDoc
	     */
	    SpecularFresnelMethod.prototype.iGetFragmentPreLightingCode = function (shader, methodVO, registerCache, sharedRegisters) {
	        this._dataReg = registerCache.getFreeFragmentConstant();
	        methodVO.secondaryFragmentConstantsIndex = this._dataReg.index * 4;
	        return _super.prototype.iGetFragmentPreLightingCode.call(this, shader, methodVO, registerCache, sharedRegisters);
	    };
	    /**
	     * Applies the fresnel effect to the specular strength.
	     *
	     * @param vo The MethodVO object containing the method data for the currently compiled material pass.
	     * @param target The register containing the specular strength in the "w" component, and the half-vector/reflection vector in "xyz".
	     * @param regCache The register cache used for the shader compilation.
	     * @param sharedRegisters The shared registers created by the compiler.
	     * @return The AGAL fragment code for the method.
	     */
	    SpecularFresnelMethod.prototype.modulateSpecular = function (shader, methodVO, targetReg, registerCache, sharedRegisters) {
	        var code;
	        code = "dp3 " + targetReg + ".y, " + sharedRegisters.viewDirFragment + ".xyz, " + (this._incidentLight ? targetReg : sharedRegisters.normalFragment) + ".xyz\n" +
	            "sub " + targetReg + ".y, " + this._dataReg + ".z, " + targetReg + ".y\n" +
	            "pow " + targetReg + ".x, " + targetReg + ".y, " + this._dataReg + ".y\n" +
	            "sub " + targetReg + ".y, " + this._dataReg + ".z, " + targetReg + ".y\n" +
	            "mul " + targetReg + ".y, " + this._dataReg + ".x, " + targetReg + ".y\n" +
	            "add " + targetReg + ".y, " + targetReg + ".x, " + targetReg + ".y\n" +
	            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";
	        return code;
	    };
	    return SpecularFresnelMethod;
	}(SpecularCompositeMethod_1.SpecularCompositeMethod));
	exports.SpecularFresnelMethod = SpecularFresnelMethod;


/***/ },
/* 267 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SpecularBasicMethod_1 = __webpack_require__(263);
	/**
	 * SpecularPhongMethod provides a specular method that provides Phong highlights.
	 */
	var SpecularPhongMethod = (function (_super) {
	    __extends(SpecularPhongMethod, _super);
	    /**
	     * Creates a new SpecularPhongMethod object.
	     */
	    function SpecularPhongMethod() {
	        _super.call(this);
	    }
	    /**
	     * @inheritDoc
	     */
	    SpecularPhongMethod.prototype.iGetFragmentCodePerLight = function (shader, methodVO, lightDirReg, lightColReg, registerCache, sharedRegisters) {
	        var code = "";
	        var t;
	        if (this._pIsFirstLight) {
	            t = this._pTotalLightColorReg;
	        }
	        else {
	            t = registerCache.getFreeFragmentVectorTemp();
	            registerCache.addFragmentTempUsages(t, 1);
	        }
	        var viewDirReg = sharedRegisters.viewDirFragment;
	        var normalReg = sharedRegisters.normalFragment;
	        // phong model
	        code += "dp3 " + t + ".w, " + lightDirReg + ", " + normalReg + "\n" +
	            //find the reflected light vector R
	            "add " + t + ".w, " + t + ".w, " + t + ".w\n" +
	            "mul " + t + ".xyz, " + normalReg + ", " + t + ".w\n" +
	            "sub " + t + ".xyz, " + t + ", " + lightDirReg + "\n" +
	            //smooth the edge as incidence angle approaches 90
	            "add " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".w\n" +
	            "sat " + t + ".w, " + t + ".w\n" +
	            "mul " + t + ".xyz, " + t + ", " + t + ".w\n" +
	            //find the dot product between R and V
	            "dp3 " + t + ".w, " + t + ", " + viewDirReg + "\n" +
	            "sat " + t + ".w, " + t + ".w\n";
	        if (this.texture) {
	            // apply gloss modulation from texture
	            code += "mul " + this._pSpecularTexData + ".w, " + this._pSpecularTexData + ".y, " + this._pSpecularDataRegister + ".w\n" +
	                "pow " + t + ".w, " + t + ".w, " + this._pSpecularTexData + ".w\n";
	        }
	        else
	            code += "pow " + t + ".w, " + t + ".w, " + this._pSpecularDataRegister + ".w\n";
	        // attenuate
	        if (shader.usesLightFallOff)
	            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
	        if (this._iModulateMethod != null)
	            code += this._iModulateMethod(shader, methodVO, t, registerCache, sharedRegisters);
	        code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";
	        if (!this._pIsFirstLight) {
	            code += "add " + this._pTotalLightColorReg + ".xyz, " + this._pTotalLightColorReg + ".xyz, " + t + ".xyz\n";
	            registerCache.removeFragmentTempUsage(t);
	        }
	        this._pIsFirstLight = false;
	        return code;
	    };
	    return SpecularPhongMethod;
	}(SpecularBasicMethod_1.SpecularBasicMethod));
	exports.SpecularPhongMethod = SpecularPhongMethod;


/***/ },
/* 268 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var MethodPass_1 = __webpack_require__(269);
	exports.MethodPass = MethodPass_1.MethodPass;
	var MethodPassMode_1 = __webpack_require__(280);
	exports.MethodPassMode = MethodPassMode_1.MethodPassMode;
	var SingleObjectDepthPass_1 = __webpack_require__(281);
	exports.SingleObjectDepthPass = SingleObjectDepthPass_1.SingleObjectDepthPass;
	var GL_MethodMaterialSurface_1 = __webpack_require__(282);
	exports.GL_MethodMaterialSurface = GL_MethodMaterialSurface_1.GL_MethodMaterialSurface;


/***/ },
/* 269 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var LightSources_1 = __webpack_require__(221);
	var LightingShader_1 = __webpack_require__(270);
	var ShadingMethodEvent_1 = __webpack_require__(227);
	var ShaderBase_1 = __webpack_require__(271);
	var PassBase_1 = __webpack_require__(278);
	var MethodVO_1 = __webpack_require__(223);
	var EffectColorTransformMethod_1 = __webpack_require__(242);
	var MethodPassMode_1 = __webpack_require__(280);
	/**
	 * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
	 * using material methods to define their appearance.
	 */
	var MethodPass = (function (_super) {
	    __extends(MethodPass, _super);
	    /**
	     * Creates a new CompiledPass object.
	     *
	     * @param material The material to which this pass belongs.
	     */
	    function MethodPass(mode, render, renderOwner, elementsClass, stage) {
	        var _this = this;
	        _super.call(this, render, renderOwner, elementsClass, stage);
	        this._maxLights = 3;
	        this._mode = 0x03;
	        this._includeCasters = true;
	        this._iMethodVOs = new Array();
	        this._numEffectDependencies = 0;
	        this.numDirectionalLights = 0;
	        this.numPointLights = 0;
	        this.numLightProbes = 0;
	        this.pointLightsOffset = 0;
	        this.directionalLightsOffset = 0;
	        this.lightProbesOffset = 0;
	        this._mode = mode;
	        this._material = renderOwner;
	        this._onLightsChangeDelegate = function (event) { return _this.onLightsChange(event); };
	        this._onMethodInvalidatedDelegate = function (event) { return _this.onMethodInvalidated(event); };
	        this.lightPicker = renderOwner.lightPicker;
	        if (this._shader == null)
	            this._updateShader();
	    }
	    Object.defineProperty(MethodPass.prototype, "mode", {
	        /**
	         *
	         */
	        get: function () {
	            return this._mode;
	        },
	        set: function (value) {
	            if (this._mode == value)
	                return;
	            this._mode = value;
	            this._updateLights();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "includeCasters", {
	        /**
	         * Indicates whether or not shadow casting lights need to be included.
	         */
	        get: function () {
	            return this._includeCasters;
	        },
	        set: function (value) {
	            if (this._includeCasters == value)
	                return;
	            this._includeCasters = value;
	            this._updateLights();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "lightPicker", {
	        /**
	         *
	         * @returns {LightPickerBase}
	         */
	        get: function () {
	            return this._lightPicker;
	        },
	        set: function (value) {
	            //if (this._lightPicker == value)
	            //	return;
	            if (this._lightPicker)
	                this._lightPicker.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);
	            this._lightPicker = value;
	            if (this._lightPicker)
	                this._lightPicker.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);
	            this._updateLights();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "enableLightFallOff", {
	        /**
	         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
	         * compatibility for constrained mode.
	         */
	        get: function () {
	            return this._material.enableLightFallOff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "diffuseLightSources", {
	        /**
	         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
	         * and/or light probes for diffuse reflections.
	         *
	         * @see away3d.materials.LightSources
	         */
	        get: function () {
	            return this._material.diffuseLightSources;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "specularLightSources", {
	        /**
	         * Define which light source types to use for specular reflections. This allows choosing between regular lights
	         * and/or light probes for specular reflections.
	         *
	         * @see away3d.materials.LightSources
	         */
	        get: function () {
	            return this._material.specularLightSources;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MethodPass.prototype._updateShader = function () {
	        if ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof LightingShader_1.LightingShader)) {
	            if (this._shader != null)
	                this._shader.dispose();
	            this._shader = new LightingShader_1.LightingShader(this._elementsClass, this, this._stage);
	        }
	        else if (!(this._shader instanceof ShaderBase_1.ShaderBase)) {
	            if (this._shader != null)
	                this._shader.dispose();
	            this._shader = new ShaderBase_1.ShaderBase(this._elementsClass, this, this._stage);
	        }
	    };
	    /**
	     * Initializes the unchanging constant data for this material.
	     */
	    MethodPass.prototype._iInitConstantData = function (shader) {
	        _super.prototype._iInitConstantData.call(this, shader);
	        //Updates method constants if they have changed.
	        var len = this._iMethodVOs.length;
	        for (var i = 0; i < len; ++i)
	            this._iMethodVOs[i].method.iInitConstants(shader, this._iMethodVOs[i]);
	    };
	    Object.defineProperty(MethodPass.prototype, "colorTransform", {
	        /**
	         * The ColorTransform object to transform the colour of the material with. Defaults to null.
	         */
	        get: function () {
	            return this.colorTransformMethod ? this.colorTransformMethod.colorTransform : null;
	        },
	        set: function (value) {
	            if (value) {
	                if (this.colorTransformMethod == null)
	                    this.colorTransformMethod = new EffectColorTransformMethod_1.EffectColorTransformMethod();
	                this.colorTransformMethod.colorTransform = value;
	            }
	            else if (!value) {
	                if (this.colorTransformMethod)
	                    this.colorTransformMethod = null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "colorTransformMethod", {
	        /**
	         * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.
	         */
	        get: function () {
	            return this._iColorTransformMethodVO ? this._iColorTransformMethodVO.method : null;
	        },
	        set: function (value) {
	            if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.method == value)
	                return;
	            if (this._iColorTransformMethodVO) {
	                this._removeDependency(this._iColorTransformMethodVO);
	                this._iColorTransformMethodVO = null;
	            }
	            if (value) {
	                this._iColorTransformMethodVO = new MethodVO_1.MethodVO(value, this);
	                this._addDependency(this._iColorTransformMethodVO);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    MethodPass.prototype._removeDependency = function (methodVO, effectsDependency) {
	        if (effectsDependency === void 0) { effectsDependency = false; }
	        var index = this._iMethodVOs.indexOf(methodVO);
	        if (!effectsDependency)
	            this._numEffectDependencies--;
	        methodVO.method.removeEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);
	        this._iMethodVOs.splice(index, 1);
	        this.invalidate();
	    };
	    MethodPass.prototype._addDependency = function (methodVO, effectsDependency, index) {
	        if (effectsDependency === void 0) { effectsDependency = false; }
	        if (index === void 0) { index = -1; }
	        methodVO.method.addEventListener(ShadingMethodEvent_1.ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);
	        if (effectsDependency) {
	            if (index != -1)
	                this._iMethodVOs.splice(index + this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);
	            else
	                this._iMethodVOs.push(methodVO);
	            this._numEffectDependencies++;
	        }
	        else {
	            this._iMethodVOs.splice(this._iMethodVOs.length - this._numEffectDependencies, 0, methodVO);
	        }
	        this.invalidate();
	    };
	    /**
	     * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
	     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
	     * methods added prior.
	     */
	    MethodPass.prototype.addEffectMethod = function (method) {
	        this._addDependency(new MethodVO_1.MethodVO(method, this), true);
	    };
	    Object.defineProperty(MethodPass.prototype, "numEffectMethods", {
	        /**
	         * The number of "effect" methods added to the material.
	         */
	        get: function () {
	            return this._numEffectDependencies;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Queries whether a given effects method was added to the material.
	     *
	     * @param method The method to be queried.
	     * @return true if the method was added to the material, false otherwise.
	     */
	    MethodPass.prototype.hasEffectMethod = function (method) {
	        return this.getDependencyForMethod(method) != null;
	    };
	    /**
	     * Returns the method added at the given index.
	     * @param index The index of the method to retrieve.
	     * @return The method at the given index.
	     */
	    MethodPass.prototype.getEffectMethodAt = function (index) {
	        if (index < 0 || index > this._numEffectDependencies - 1)
	            return null;
	        return this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies].method;
	    };
	    /**
	     * Adds an effect method at the specified index amongst the methods already added to the material. Effect
	     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
	     * etc. The method will be applied to the result of the methods with a lower index.
	     */
	    MethodPass.prototype.addEffectMethodAt = function (method, index) {
	        this._addDependency(new MethodVO_1.MethodVO(method, this), true, index);
	    };
	    /**
	     * Removes an effect method from the material.
	     * @param method The method to be removed.
	     */
	    MethodPass.prototype.removeEffectMethod = function (method) {
	        var methodVO = this.getDependencyForMethod(method);
	        if (methodVO != null)
	            this._removeDependency(methodVO, true);
	    };
	    /**
	     * remove an effect method at the specified index from the material.
	     */
	    MethodPass.prototype.removeEffectMethodAt = function (index) {
	        if (index < 0 || index > this._numEffectDependencies - 1)
	            return;
	        var methodVO = this._iMethodVOs[index + this._iMethodVOs.length - this._numEffectDependencies];
	        if (methodVO != null)
	            this._removeDependency(methodVO, true);
	    };
	    MethodPass.prototype.getDependencyForMethod = function (method) {
	        var len = this._iMethodVOs.length;
	        for (var i = 0; i < len; ++i)
	            if (this._iMethodVOs[i].method == method)
	                return this._iMethodVOs[i];
	        return null;
	    };
	    Object.defineProperty(MethodPass.prototype, "normalMethod", {
	        /**
	         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
	         */
	        get: function () {
	            return this._iNormalMethodVO ? this._iNormalMethodVO.method : null;
	        },
	        set: function (value) {
	            if (this._iNormalMethodVO && this._iNormalMethodVO.method == value)
	                return;
	            if (this._iNormalMethodVO) {
	                this._removeDependency(this._iNormalMethodVO);
	                this._iNormalMethodVO = null;
	            }
	            if (value) {
	                this._iNormalMethodVO = new MethodVO_1.MethodVO(value, this);
	                this._addDependency(this._iNormalMethodVO);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "ambientMethod", {
	        /**
	         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
	         */
	        get: function () {
	            return this._iAmbientMethodVO ? this._iAmbientMethodVO.method : null;
	        },
	        set: function (value) {
	            if (this._iAmbientMethodVO && this._iAmbientMethodVO.method == value)
	                return;
	            if (this._iAmbientMethodVO) {
	                this._removeDependency(this._iAmbientMethodVO);
	                this._iAmbientMethodVO = null;
	            }
	            if (value) {
	                this._iAmbientMethodVO = new MethodVO_1.MethodVO(value, this);
	                this._addDependency(this._iAmbientMethodVO);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "shadowMethod", {
	        /**
	         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
	         */
	        get: function () {
	            return this._iShadowMethodVO ? this._iShadowMethodVO.method : null;
	        },
	        set: function (value) {
	            if (this._iShadowMethodVO && this._iShadowMethodVO.method == value)
	                return;
	            if (this._iShadowMethodVO) {
	                this._removeDependency(this._iShadowMethodVO);
	                this._iShadowMethodVO = null;
	            }
	            if (value) {
	                this._iShadowMethodVO = new MethodVO_1.MethodVO(value, this);
	                this._addDependency(this._iShadowMethodVO);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "diffuseMethod", {
	        /**
	         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
	         */
	        get: function () {
	            return this._iDiffuseMethodVO ? this._iDiffuseMethodVO.method : null;
	        },
	        set: function (value) {
	            if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.method == value)
	                return;
	            if (this._iDiffuseMethodVO) {
	                this._removeDependency(this._iDiffuseMethodVO);
	                this._iDiffuseMethodVO = null;
	            }
	            if (value) {
	                this._iDiffuseMethodVO = new MethodVO_1.MethodVO(value, this);
	                this._addDependency(this._iDiffuseMethodVO);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodPass.prototype, "specularMethod", {
	        /**
	         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
	         */
	        get: function () {
	            return this._iSpecularMethodVO ? this._iSpecularMethodVO.method : null;
	        },
	        set: function (value) {
	            if (this._iSpecularMethodVO && this._iSpecularMethodVO.method == value)
	                return;
	            if (this._iSpecularMethodVO) {
	                this._removeDependency(this._iSpecularMethodVO);
	                this._iSpecularMethodVO = null;
	            }
	            if (value) {
	                this._iSpecularMethodVO = new MethodVO_1.MethodVO(value, this);
	                this._addDependency(this._iSpecularMethodVO);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    MethodPass.prototype.dispose = function () {
	        if (this._lightPicker)
	            this._lightPicker.removeEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);
	        while (this._iMethodVOs.length)
	            this._removeDependency(this._iMethodVOs[0]);
	        _super.prototype.dispose.call(this);
	        this._iMethodVOs = null;
	    };
	    /**
	     * Called when any method's shader code is invalidated.
	     */
	    MethodPass.prototype.onMethodInvalidated = function (event) {
	        this.invalidate();
	    };
	    // RENDER LOOP
	    /**
	     * @inheritDoc
	     */
	    MethodPass.prototype._iActivate = function (camera) {
	        _super.prototype._iActivate.call(this, camera);
	        var methodVO;
	        var len = this._iMethodVOs.length;
	        for (var i = 0; i < len; ++i) {
	            methodVO = this._iMethodVOs[i];
	            if (methodVO.useMethod)
	                methodVO.method.iActivate(this._shader, methodVO, this._stage);
	        }
	    };
	    /**
	     *
	     *
	     * @param renderable
	     * @param stage
	     * @param camera
	     */
	    MethodPass.prototype._setRenderState = function (renderable, camera, viewProjection) {
	        _super.prototype._setRenderState.call(this, renderable, camera, viewProjection);
	        var methodVO;
	        var len = this._iMethodVOs.length;
	        for (var i = 0; i < len; ++i) {
	            methodVO = this._iMethodVOs[i];
	            if (methodVO.useMethod)
	                methodVO.method.iSetRenderState(this._shader, methodVO, renderable, this._stage, camera);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    MethodPass.prototype._iDeactivate = function () {
	        _super.prototype._iDeactivate.call(this);
	        var methodVO;
	        var len = this._iMethodVOs.length;
	        for (var i = 0; i < len; ++i) {
	            methodVO = this._iMethodVOs[i];
	            if (methodVO.useMethod)
	                methodVO.method.iDeactivate(this._shader, methodVO, this._stage);
	        }
	    };
	    MethodPass.prototype._iIncludeDependencies = function (shader) {
	        _super.prototype._iIncludeDependencies.call(this, shader);
	        //TODO: fragment animtion should be compatible with lighting pass
	        shader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode_1.MethodPassMode.SUPER_SHADER);
	        if (shader.useAlphaPremultiplied && shader.usesBlending)
	            shader.usesCommonData = true;
	        var i;
	        var len = this._iMethodVOs.length;
	        for (i = 0; i < len; ++i)
	            this.setupAndCountDependencies(shader, this._iMethodVOs[i]);
	        var usesTangentSpace = true;
	        var methodVO;
	        for (i = 0; i < len; ++i) {
	            methodVO = this._iMethodVOs[i];
	            if ((methodVO.useMethod = methodVO.method.iIsUsed(shader)) && !methodVO.method.iUsesTangentSpace())
	                usesTangentSpace = false;
	        }
	        shader.outputsNormals = this._iNormalMethodVO && this._iNormalMethodVO.useMethod;
	        shader.outputsTangentNormals = shader.outputsNormals && this._iNormalMethodVO.method.iOutputsTangentNormals();
	        shader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;
	        if (!shader.usesTangentSpace) {
	            if (shader.viewDirDependencies > 0) {
	                shader.globalPosDependencies++;
	            }
	            else if (this.numPointLights > 0 && shader.usesLights) {
	                shader.globalPosDependencies++;
	                if (Boolean(this._mode & MethodPassMode_1.MethodPassMode.EFFECTS))
	                    shader.usesGlobalPosFragment = true;
	            }
	        }
	    };
	    /**
	     * Counts the dependencies for a given method.
	     * @param method The method to count the dependencies for.
	     * @param methodVO The method's data for this material.
	     */
	    MethodPass.prototype.setupAndCountDependencies = function (shader, methodVO) {
	        methodVO.reset();
	        methodVO.method.iInitVO(shader, methodVO);
	        if (methodVO.needsProjection)
	            shader.projectionDependencies++;
	        if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos) {
	            shader.globalPosDependencies++;
	            if (methodVO.needsGlobalFragmentPos)
	                shader.usesGlobalPosFragment = true;
	        }
	        if (methodVO.needsNormals)
	            shader.normalDependencies++;
	        if (methodVO.needsTangents)
	            shader.tangentDependencies++;
	        if (methodVO.needsView)
	            shader.viewDirDependencies++;
	    };
	    MethodPass.prototype._iGetPreLightingVertexCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod)
	            code += this._iAmbientMethodVO.method.iGetVertexCode(shader, this._iAmbientMethodVO, registerCache, sharedRegisters);
	        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)
	            code += this._iDiffuseMethodVO.method.iGetVertexCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);
	        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)
	            code += this._iSpecularMethodVO.method.iGetVertexCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);
	        return code;
	    };
	    MethodPass.prototype._iGetPreLightingFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        if (this._iAmbientMethodVO && this._iAmbientMethodVO.useMethod) {
	            code += this._iAmbientMethodVO.method.iGetFragmentCode(shader, this._iAmbientMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);
	            if (this._iAmbientMethodVO.needsNormals)
	                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
	            if (this._iAmbientMethodVO.needsView)
	                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
	        }
	        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod)
	            code += this._iDiffuseMethodVO.method.iGetFragmentPreLightingCode(shader, this._iDiffuseMethodVO, registerCache, sharedRegisters);
	        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod)
	            code += this._iSpecularMethodVO.method.iGetFragmentPreLightingCode(shader, this._iSpecularMethodVO, registerCache, sharedRegisters);
	        return code;
	    };
	    MethodPass.prototype._iGetPerLightDiffuseFragmentCode = function (shader, lightDirReg, diffuseColorReg, registerCache, sharedRegisters) {
	        return this._iDiffuseMethodVO.method.iGetFragmentCodePerLight(shader, this._iDiffuseMethodVO, lightDirReg, diffuseColorReg, registerCache, sharedRegisters);
	    };
	    MethodPass.prototype._iGetPerLightSpecularFragmentCode = function (shader, lightDirReg, specularColorReg, registerCache, sharedRegisters) {
	        return this._iSpecularMethodVO.method.iGetFragmentCodePerLight(shader, this._iSpecularMethodVO, lightDirReg, specularColorReg, registerCache, sharedRegisters);
	    };
	    MethodPass.prototype._iGetPerProbeDiffuseFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {
	        return this._iDiffuseMethodVO.method.iGetFragmentCodePerProbe(shader, this._iDiffuseMethodVO, texReg, weightReg, registerCache, sharedRegisters);
	    };
	    MethodPass.prototype._iGetPerProbeSpecularFragmentCode = function (shader, texReg, weightReg, registerCache, sharedRegisters) {
	        return this._iSpecularMethodVO.method.iGetFragmentCodePerProbe(shader, this._iSpecularMethodVO, texReg, weightReg, registerCache, sharedRegisters);
	    };
	    MethodPass.prototype._iGetPostLightingVertexCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        if (this._iShadowMethodVO)
	            code += this._iShadowMethodVO.method.iGetVertexCode(shader, this._iShadowMethodVO, registerCache, sharedRegisters);
	        return code;
	    };
	    MethodPass.prototype._iGetPostLightingFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        if (shader.useAlphaPremultiplied && shader.usesBlending) {
	            code += "add " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.commons + ".z\n" +
	                "div " + sharedRegisters.shadedTarget + ".xyz, " + sharedRegisters.shadedTarget + ", " + sharedRegisters.shadedTarget + ".w\n" +
	                "sub " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.commons + ".z\n" +
	                "sat " + sharedRegisters.shadedTarget + ".xyz, " + sharedRegisters.shadedTarget + "\n";
	        }
	        if (this._iShadowMethodVO)
	            code += this._iShadowMethodVO.method.iGetFragmentCode(shader, this._iShadowMethodVO, sharedRegisters.shadowTarget, registerCache, sharedRegisters);
	        if (this._iDiffuseMethodVO && this._iDiffuseMethodVO.useMethod) {
	            code += this._iDiffuseMethodVO.method.iGetFragmentPostLightingCode(shader, this._iDiffuseMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);
	            // resolve other dependencies as well?
	            if (this._iDiffuseMethodVO.needsNormals)
	                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
	            if (this._iDiffuseMethodVO.needsView)
	                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
	        }
	        if (this._iSpecularMethodVO && this._iSpecularMethodVO.useMethod) {
	            code += this._iSpecularMethodVO.method.iGetFragmentPostLightingCode(shader, this._iSpecularMethodVO, sharedRegisters.shadedTarget, registerCache, sharedRegisters);
	            if (this._iSpecularMethodVO.needsNormals)
	                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
	            if (this._iSpecularMethodVO.needsView)
	                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
	        }
	        if (this._iShadowMethodVO)
	            registerCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);
	        return code;
	    };
	    MethodPass.prototype._iGetNormalVertexCode = function (shader, registerCache, sharedRegisters) {
	        return this._iNormalMethodVO.method.iGetVertexCode(shader, this._iNormalMethodVO, registerCache, sharedRegisters);
	    };
	    MethodPass.prototype._iGetNormalFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code = this._iNormalMethodVO.method.iGetFragmentCode(shader, this._iNormalMethodVO, sharedRegisters.normalFragment, registerCache, sharedRegisters);
	        if (this._iNormalMethodVO.needsView)
	            registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
	        if (this._iNormalMethodVO.needsGlobalFragmentPos || this._iNormalMethodVO.needsGlobalVertexPos)
	            registerCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    MethodPass.prototype._iGetVertexCode = function (shader, regCache, sharedReg) {
	        var code = "";
	        var methodVO;
	        var len = this._iMethodVOs.length;
	        for (var i = len - this._numEffectDependencies; i < len; i++) {
	            methodVO = this._iMethodVOs[i];
	            if (methodVO.useMethod) {
	                code += methodVO.method.iGetVertexCode(shader, methodVO, regCache, sharedReg);
	                if (methodVO.needsGlobalVertexPos || methodVO.needsGlobalFragmentPos)
	                    regCache.removeVertexTempUsage(sharedReg.globalPositionVertex);
	            }
	        }
	        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)
	            code += this._iColorTransformMethodVO.method.iGetVertexCode(shader, this._iColorTransformMethodVO, regCache, sharedReg);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    MethodPass.prototype._iGetFragmentCode = function (shader, regCache, sharedReg) {
	        var code = "";
	        var alphaReg;
	        if (this.preserveAlpha && this._numEffectDependencies > 0) {
	            alphaReg = regCache.getFreeFragmentSingleTemp();
	            regCache.addFragmentTempUsages(alphaReg, 1);
	            code += "mov " + alphaReg + ", " + sharedReg.shadedTarget + ".w\n";
	        }
	        var methodVO;
	        var len = this._iMethodVOs.length;
	        for (var i = len - this._numEffectDependencies; i < len; i++) {
	            methodVO = this._iMethodVOs[i];
	            if (methodVO.useMethod) {
	                code += methodVO.method.iGetFragmentCode(shader, methodVO, sharedReg.shadedTarget, regCache, sharedReg);
	                if (methodVO.needsNormals)
	                    regCache.removeFragmentTempUsage(sharedReg.normalFragment);
	                if (methodVO.needsView)
	                    regCache.removeFragmentTempUsage(sharedReg.viewDirFragment);
	            }
	        }
	        if (this.preserveAlpha && this._numEffectDependencies > 0) {
	            code += "mov " + sharedReg.shadedTarget + ".w, " + alphaReg + "\n";
	            regCache.removeFragmentTempUsage(alphaReg);
	        }
	        if (this._iColorTransformMethodVO && this._iColorTransformMethodVO.useMethod)
	            code += this._iColorTransformMethodVO.method.iGetFragmentCode(shader, this._iColorTransformMethodVO, sharedReg.shadedTarget, regCache, sharedReg);
	        return code;
	    };
	    /**
	     * Indicates whether the shader uses any shadows.
	     */
	    MethodPass.prototype._iUsesShadows = function (shader) {
	        return Boolean(this._iShadowMethodVO && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));
	    };
	    /**
	     * Indicates whether the shader uses any specular component.
	     */
	    MethodPass.prototype._iUsesSpecular = function (shader) {
	        return Boolean(this._iSpecularMethodVO);
	    };
	    /**
	     * Indicates whether the shader uses any specular component.
	     */
	    MethodPass.prototype._iUsesDiffuse = function (shader) {
	        return Boolean(this._iDiffuseMethodVO);
	    };
	    MethodPass.prototype.onLightsChange = function (event) {
	        this._updateLights();
	    };
	    MethodPass.prototype._updateLights = function () {
	        var numDirectionalLightsOld = this.numDirectionalLights;
	        var numPointLightsOld = this.numPointLights;
	        var numLightProbesOld = this.numLightProbes;
	        if (this._lightPicker && (this._mode & MethodPassMode_1.MethodPassMode.LIGHTING)) {
	            this.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);
	            this.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);
	            this.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);
	            if (this._includeCasters) {
	                this.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;
	                this.numPointLights += this._lightPicker.numCastingPointLights;
	            }
	        }
	        else {
	            this.numDirectionalLights = 0;
	            this.numPointLights = 0;
	            this.numLightProbes = 0;
	        }
	        if (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {
	            this._updateShader();
	            this.invalidate();
	        }
	    };
	    /**
	     * Calculates the amount of directional lights this material will support.
	     * @param numDirectionalLights The maximum amount of directional lights to support.
	     * @return The amount of directional lights this material will support, bounded by the amount necessary.
	     */
	    MethodPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {
	        return Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);
	    };
	    /**
	     * Calculates the amount of point lights this material will support.
	     * @param numDirectionalLights The maximum amount of point lights to support.
	     * @return The amount of point lights this material will support, bounded by the amount necessary.
	     */
	    MethodPass.prototype.calculateNumPointLights = function (numPointLights) {
	        var numFree = this._maxLights - this.numDirectionalLights;
	        return Math.min(numPointLights - this.pointLightsOffset, numFree);
	    };
	    /**
	     * Calculates the amount of light probes this material will support.
	     * @param numDirectionalLights The maximum amount of light probes to support.
	     * @return The amount of light probes this material will support, bounded by the amount necessary.
	     */
	    MethodPass.prototype.calculateNumProbes = function (numLightProbes) {
	        var numChannels = 0;
	        if ((this.specularLightSources & LightSources_1.LightSources.PROBES) != 0)
	            ++numChannels;
	        if ((this.diffuseLightSources & LightSources_1.LightSources.PROBES) != 0)
	            ++numChannels;
	        // 4 channels available
	        return Math.min(numLightProbes - this.lightProbesOffset, (4 / numChannels) | 0);
	    };
	    return MethodPass;
	}(PassBase_1.PassBase));
	exports.MethodPass = MethodPass;


/***/ },
/* 270 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var LightSources_1 = __webpack_require__(221);
	var ContextGLProfile_1 = __webpack_require__(46);
	var ShaderBase_1 = __webpack_require__(271);
	var LightingCompiler_1 = __webpack_require__(277);
	/**
	 * ShaderBase keeps track of the number of dependencies for "named registers" used across a pass.
	 * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
	 * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
	 * each time a method has been compiled into the shader.
	 *
	 * @see RegisterPool.addUsage
	 */
	var LightingShader = (function (_super) {
	    __extends(LightingShader, _super);
	    /**
	     * Creates a new MethodCompilerVO object.
	     */
	    function LightingShader(elementsClass, lightingPass, stage) {
	        _super.call(this, elementsClass, lightingPass, stage);
	        this._includeCasters = true;
	        this._lightingPass = lightingPass;
	    }
	    LightingShader.prototype._iIncludeDependencies = function () {
	        this.numPointLights = this._lightingPass.numPointLights;
	        this.numDirectionalLights = this._lightingPass.numDirectionalLights;
	        this.numLightProbes = this._lightingPass.numLightProbes;
	        var numAllLights = this._lightingPass.numPointLights + this._lightingPass.numDirectionalLights;
	        var numLightProbes = this._lightingPass.numLightProbes;
	        var diffuseLightSources = this._lightingPass._iUsesDiffuse(this) ? this._lightingPass.diffuseLightSources : 0x00;
	        var specularLightSources = this._lightingPass._iUsesSpecular(this) ? this._lightingPass.specularLightSources : 0x00;
	        var combinedLightSources = diffuseLightSources | specularLightSources;
	        this.usesLightFallOff = this._lightingPass.enableLightFallOff && this.profile != ContextGLProfile_1.ContextGLProfile.BASELINE_CONSTRAINED;
	        this.usesCommonData = this.usesLightFallOff || this.usesCommonData;
	        this.numLights = numAllLights + numLightProbes;
	        this.usesLights = numAllLights > 0 && (combinedLightSources & LightSources_1.LightSources.LIGHTS) != 0;
	        this.usesProbes = numLightProbes > 0 && (combinedLightSources & LightSources_1.LightSources.PROBES) != 0;
	        this.usesLightsForSpecular = numAllLights > 0 && (specularLightSources & LightSources_1.LightSources.LIGHTS) != 0;
	        this.usesProbesForSpecular = numLightProbes > 0 && (specularLightSources & LightSources_1.LightSources.PROBES) != 0;
	        this.usesLightsForDiffuse = numAllLights > 0 && (diffuseLightSources & LightSources_1.LightSources.LIGHTS) != 0;
	        this.usesProbesForDiffuse = numLightProbes > 0 && (diffuseLightSources & LightSources_1.LightSources.PROBES) != 0;
	        this.usesShadows = this._lightingPass._iUsesShadows(this);
	        //IMPORTANT this must occur after shader lighting initialisation above
	        _super.prototype._iIncludeDependencies.call(this);
	    };
	    /**
	     * Factory method to create a concrete compiler object for this object
	     *
	     * @param materialPassVO
	     * @returns {away.materials.LightingCompiler}
	     */
	    LightingShader.prototype.createCompiler = function (elementsClass, pass) {
	        return new LightingCompiler_1.LightingCompiler(elementsClass, pass, this);
	    };
	    /**
	     *
	     *
	     * @param renderable
	     * @param stage
	     * @param camera
	     */
	    LightingShader.prototype._setRenderState = function (renderable, camera, viewProjection) {
	        _super.prototype._setRenderState.call(this, renderable, camera, viewProjection);
	        if (this._lightingPass.lightPicker)
	            this._lightingPass.lightPicker.collectLights(renderable.sourceEntity);
	        if (this.usesLights)
	            this.updateLights();
	        if (this.usesProbes)
	            this.updateProbes();
	    };
	    /**
	     * Updates constant data render state used by the lights. This method is optional for subclasses to implement.
	     */
	    LightingShader.prototype.updateLights = function () {
	        var dirLight;
	        var pointLight;
	        var i = 0;
	        var k = 0;
	        var len;
	        var dirPos;
	        var total = 0;
	        var numLightTypes = this.usesShadows ? 2 : 1;
	        var l;
	        var offset;
	        this.ambientR = this.ambientG = this.ambientB = 0;
	        l = this.lightVertexConstantIndex;
	        k = this.lightFragmentConstantIndex;
	        var cast = 0;
	        var dirLights = this._lightingPass.lightPicker.directionalLights;
	        offset = this._lightingPass.directionalLightsOffset;
	        len = this._lightingPass.lightPicker.directionalLights.length;
	        if (offset > len) {
	            cast = 1;
	            offset -= len;
	        }
	        for (; cast < numLightTypes; ++cast) {
	            if (cast)
	                dirLights = this._lightingPass.lightPicker.castingDirectionalLights;
	            len = dirLights.length;
	            if (len > this.numDirectionalLights)
	                len = this.numDirectionalLights;
	            for (i = 0; i < len; ++i) {
	                dirLight = dirLights[offset + i];
	                dirPos = dirLight.sceneDirection;
	                this.ambientR += dirLight._iAmbientR;
	                this.ambientG += dirLight._iAmbientG;
	                this.ambientB += dirLight._iAmbientB;
	                if (this.usesTangentSpace) {
	                    var x = -dirPos.x;
	                    var y = -dirPos.y;
	                    var z = -dirPos.z;
	                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z;
	                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z;
	                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z;
	                    this.vertexConstantData[l++] = 1;
	                }
	                else {
	                    this.fragmentConstantData[k++] = -dirPos.x;
	                    this.fragmentConstantData[k++] = -dirPos.y;
	                    this.fragmentConstantData[k++] = -dirPos.z;
	                    this.fragmentConstantData[k++] = 1;
	                }
	                this.fragmentConstantData[k++] = dirLight._iDiffuseR;
	                this.fragmentConstantData[k++] = dirLight._iDiffuseG;
	                this.fragmentConstantData[k++] = dirLight._iDiffuseB;
	                this.fragmentConstantData[k++] = 1;
	                this.fragmentConstantData[k++] = dirLight._iSpecularR;
	                this.fragmentConstantData[k++] = dirLight._iSpecularG;
	                this.fragmentConstantData[k++] = dirLight._iSpecularB;
	                this.fragmentConstantData[k++] = 1;
	                if (++total == this.numDirectionalLights) {
	                    // break loop
	                    i = len;
	                    cast = numLightTypes;
	                }
	            }
	        }
	        // more directional supported than currently picked, need to clamp all to 0
	        if (this.numDirectionalLights > total) {
	            i = k + (this.numDirectionalLights - total) * 12;
	            while (k < i)
	                this.fragmentConstantData[k++] = 0;
	        }
	        total = 0;
	        var pointLights = this._lightingPass.lightPicker.pointLights;
	        offset = this._lightingPass.pointLightsOffset;
	        len = this._lightingPass.lightPicker.pointLights.length;
	        if (offset > len) {
	            cast = 1;
	            offset -= len;
	        }
	        else {
	            cast = 0;
	        }
	        for (; cast < numLightTypes; ++cast) {
	            if (cast)
	                pointLights = this._lightingPass.lightPicker.castingPointLights;
	            len = pointLights.length;
	            for (i = 0; i < len; ++i) {
	                pointLight = pointLights[offset + i];
	                dirPos = pointLight.scenePosition;
	                this.ambientR += pointLight._iAmbientR;
	                this.ambientG += pointLight._iAmbientG;
	                this.ambientB += pointLight._iAmbientB;
	                if (this.usesTangentSpace) {
	                    x = dirPos.x;
	                    y = dirPos.y;
	                    z = dirPos.z;
	                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z + this._pInverseSceneMatrix[12];
	                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z + this._pInverseSceneMatrix[13];
	                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z + this._pInverseSceneMatrix[14];
	                    this.vertexConstantData[l++] = 1;
	                }
	                else if (!this.usesGlobalPosFragment) {
	                    this.vertexConstantData[l++] = dirPos.x;
	                    this.vertexConstantData[l++] = dirPos.y;
	                    this.vertexConstantData[l++] = dirPos.z;
	                    this.vertexConstantData[l++] = 1;
	                }
	                else {
	                    this.fragmentConstantData[k++] = dirPos.x;
	                    this.fragmentConstantData[k++] = dirPos.y;
	                    this.fragmentConstantData[k++] = dirPos.z;
	                    this.fragmentConstantData[k++] = 1;
	                }
	                this.fragmentConstantData[k++] = pointLight._iDiffuseR;
	                this.fragmentConstantData[k++] = pointLight._iDiffuseG;
	                this.fragmentConstantData[k++] = pointLight._iDiffuseB;
	                var radius = pointLight._pRadius;
	                this.fragmentConstantData[k++] = radius * radius;
	                this.fragmentConstantData[k++] = pointLight._iSpecularR;
	                this.fragmentConstantData[k++] = pointLight._iSpecularG;
	                this.fragmentConstantData[k++] = pointLight._iSpecularB;
	                this.fragmentConstantData[k++] = pointLight._pFallOffFactor;
	                if (++total == this.numPointLights) {
	                    // break loop
	                    i = len;
	                    cast = numLightTypes;
	                }
	            }
	        }
	        // more directional supported than currently picked, need to clamp all to 0
	        if (this.numPointLights > total) {
	            i = k + (total - this.numPointLights) * 12;
	            for (; k < i; ++k)
	                this.fragmentConstantData[k] = 0;
	        }
	    };
	    /**
	     * Updates constant data render state used by the light probes. This method is optional for subclasses to implement.
	     */
	    LightingShader.prototype.updateProbes = function () {
	        var probe;
	        var lightProbes = this._lightingPass.lightPicker.lightProbes;
	        var weights = this._lightingPass.lightPicker.lightProbeWeights;
	        var len = lightProbes.length - this._lightingPass.lightProbesOffset;
	        var addDiff = this.usesProbesForDiffuse;
	        var addSpec = this.usesProbesForSpecular;
	        if (!(addDiff || addSpec))
	            return;
	        if (len > this.numLightProbes)
	            len = this.numLightProbes;
	        for (var i = 0; i < len; ++i) {
	            probe = lightProbes[this._lightingPass.lightProbesOffset + i];
	            if (addDiff)
	                this._stage.getAbstraction(probe.diffuseMap).activate(this.lightProbeDiffuseIndices[i], probe.diffuseSampler.mipmap);
	            if (addSpec)
	                this._stage.getAbstraction(probe.specularMap).activate(this.lightProbeSpecularIndices[i], probe.diffuseSampler.mipmap);
	        }
	        for (i = 0; i < len; ++i)
	            this.fragmentConstantData[this.probeWeightsIndex + i] = weights[this._lightingPass.lightProbesOffset + i];
	    };
	    return LightingShader;
	}(ShaderBase_1.ShaderBase));
	exports.LightingShader = LightingShader;


/***/ },
/* 271 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BlendMode_1 = __webpack_require__(131);
	var ArgumentError_1 = __webpack_require__(37);
	var ContextGLBlendFactor_1 = __webpack_require__(41);
	var ContextGLCompareMode_1 = __webpack_require__(43);
	var ContextGLTriangleFace_1 = __webpack_require__(51);
	var CompilerBase_1 = __webpack_require__(272);
	/**
	 * ShaderBase keeps track of the number of dependencies for "named registers" used across a pass.
	 * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
	 * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
	 * each time a method has been compiled into the shader.
	 *
	 * @see RegisterPool.addUsage
	 */
	var ShaderBase = (function () {
	    /**
	     * Creates a new MethodCompilerVO object.
	     */
	    function ShaderBase(elementsClass, pass, stage) {
	        this._abstractionPool = new Object();
	        this._blendFactorSource = ContextGLBlendFactor_1.ContextGLBlendFactor.ONE;
	        this._blendFactorDest = ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO;
	        this._invalidProgram = true;
	        this._animationVertexCode = "";
	        this._animationFragmentCode = "";
	        this.usesBlending = false;
	        this.useImageRect = false;
	        this.usesCurves = false;
	        /**
	         * The depth compare mode used to render the renderables using this material.
	         *
	         * @see away.stagegl.ContextGLCompareMode
	         */
	        this.depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL;
	        /**
	         * Indicate whether the shader should write to the depth buffer or not. Ignored when blending is enabled.
	         */
	        this.writeDepth = true;
	        this._defaultCulling = ContextGLTriangleFace_1.ContextGLTriangleFace.BACK;
	        this._pInverseSceneMatrix = new Float32Array(16);
	        //set ambient values to default
	        this.ambientR = 0xFF;
	        this.ambientG = 0xFF;
	        this.ambientB = 0xFF;
	        /**
	         * Indicates whether there are any dependencies on the world-space position vector.
	         */
	        this.usesGlobalPosFragment = false;
	        /**
	         * Indicates whether there are any dependencies on the local position vector.
	         */
	        this.usesPositionFragment = false;
	        /**
	         *
	         */
	        this.imageIndices = new Array();
	        this._elementsClass = elementsClass;
	        this._pass = pass;
	        this._stage = stage;
	        this.profile = this._stage.profile;
	    }
	    Object.defineProperty(ShaderBase.prototype, "programData", {
	        get: function () {
	            if (this._invalidProgram)
	                this._updateProgram();
	            return this._programData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderBase.prototype, "usesAnimation", {
	        get: function () {
	            return this._usesAnimation;
	        },
	        set: function (value) {
	            if (this._usesAnimation == value)
	                return;
	            this._usesAnimation = value;
	            this.invalidateProgram();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderBase.prototype, "numUsedVertexConstants", {
	        get: function () {
	            if (this._invalidProgram)
	                this._updateProgram();
	            return this._numUsedVertexConstants;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderBase.prototype, "numUsedFragmentConstants", {
	        get: function () {
	            if (this._invalidProgram)
	                this._updateProgram();
	            return this._numUsedFragmentConstants;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderBase.prototype, "numUsedStreams", {
	        /**
	         * The amount of used vertex streams in the vertex code. Used by the animation code generation to know from which index on streams are available.
	         */
	        get: function () {
	            if (this._invalidProgram)
	                this._updateProgram();
	            return this._numUsedStreams;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderBase.prototype, "numUsedTextures", {
	        /**
	         *
	         */
	        get: function () {
	            if (this._invalidProgram)
	                this._updateProgram();
	            return this._numUsedTextures;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShaderBase.prototype.getAbstraction = function (texture) {
	        return (this._abstractionPool[texture.id] || (this._abstractionPool[texture.id] = new ShaderBase._abstractionClassPool[texture.assetType](texture, this)));
	    };
	    /**
	     *
	     * @param image
	     */
	    ShaderBase.prototype.clearAbstraction = function (texture) {
	        this._abstractionPool[texture.id] = null;
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    ShaderBase.registerAbstraction = function (gl_assetClass, assetClass) {
	        ShaderBase._abstractionClassPool[assetClass.assetType] = gl_assetClass;
	    };
	    ShaderBase.prototype.getImageIndex = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        return this._pass.getImageIndex(texture, index);
	    };
	    ShaderBase.prototype._iIncludeDependencies = function () {
	        this._pass._iIncludeDependencies(this);
	        //this.usesCommonData = this.usesCurves || this.usesCommonData;
	    };
	    /**
	     * Factory method to create a concrete compiler object for this object
	     *
	     * @param elementsClass
	     * @param pass
	     * @param stage
	     * @returns {CompilerBase}
	     */
	    ShaderBase.prototype.createCompiler = function (elementsClass, pass) {
	        return new CompilerBase_1.CompilerBase(elementsClass, pass, this);
	    };
	    /**
	     * Clears dependency counts for all registers. Called when recompiling a pass.
	     */
	    ShaderBase.prototype.reset = function () {
	        this.projectionDependencies = 0;
	        this.normalDependencies = 0;
	        this.colorDependencies = 0;
	        this.viewDirDependencies = 0;
	        this.uvDependencies = 0;
	        this.secondaryUVDependencies = 0;
	        this.globalPosDependencies = 0;
	        this.tangentDependencies = 0;
	        this.usesCommonData = false;
	        this.usesGlobalPosFragment = false;
	        this.usesPositionFragment = false;
	        this.usesFragmentAnimation = false;
	        this.usesTangentSpace = false;
	        this.outputsNormals = false;
	        this.outputsTangentNormals = false;
	    };
	    ShaderBase.prototype.pInitRegisterIndices = function () {
	        this.commonsDataIndex = -1;
	        this.cameraPositionIndex = -1;
	        this.curvesIndex = -1;
	        this.uvIndex = -1;
	        this.uvMatrixIndex = -1;
	        this.colorTransformIndex = -1;
	        this.secondaryUVIndex = -1;
	        this.normalIndex = -1;
	        this.colorBufferIndex = -1;
	        this.tangentIndex = -1;
	        this.sceneMatrixIndex = -1;
	        this.sceneNormalMatrixIndex = -1;
	        this.jointIndexIndex = -1;
	        this.jointWeightIndex = -1;
	        this.imageIndices.length = 0;
	    };
	    /**
	     * Initializes the unchanging constant data for this shader object.
	     */
	    ShaderBase.prototype.initConstantData = function (registerCache) {
	        //Updates the amount of used register indices.
	        this._numUsedVertexConstants = registerCache.numUsedVertexConstants;
	        this._numUsedFragmentConstants = registerCache.numUsedFragmentConstants;
	        this._numUsedStreams = registerCache.numUsedStreams;
	        this._numUsedTextures = registerCache.numUsedTextures;
	        this.vertexConstantData = new Float32Array(registerCache.numUsedVertexConstants * 4);
	        this.fragmentConstantData = new Float32Array(registerCache.numUsedFragmentConstants * 4);
	        //Initializes commonly required constant values.
	        if (this.commonsDataIndex >= 0) {
	            this.fragmentConstantData[this.commonsDataIndex] = .5;
	            this.fragmentConstantData[this.commonsDataIndex + 1] = 0;
	            this.fragmentConstantData[this.commonsDataIndex + 2] = 1 / 255;
	            this.fragmentConstantData[this.commonsDataIndex + 3] = 1;
	        }
	        //Initializes the default UV transformation matrix.
	        if (this.uvMatrixIndex >= 0) {
	            this.vertexConstantData[this.uvMatrixIndex] = 1;
	            this.vertexConstantData[this.uvMatrixIndex + 1] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 2] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 3] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 4] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 5] = 1;
	            this.vertexConstantData[this.uvMatrixIndex + 6] = 0;
	            this.vertexConstantData[this.uvMatrixIndex + 7] = 0;
	        }
	        //Initializes the default colorTransform.
	        if (this.colorTransformIndex >= 0) {
	            this.fragmentConstantData[this.colorTransformIndex] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 1] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 2] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 3] = 1;
	            this.fragmentConstantData[this.colorTransformIndex + 4] = 0;
	            this.fragmentConstantData[this.colorTransformIndex + 5] = 0;
	            this.fragmentConstantData[this.colorTransformIndex + 6] = 0;
	            this.fragmentConstantData[this.colorTransformIndex + 7] = 0;
	        }
	        if (this.cameraPositionIndex >= 0)
	            this.vertexConstantData[this.cameraPositionIndex + 3] = 1;
	        // init constant data in pass
	        this._pass._iInitConstantData(this);
	        //init constant data in animation
	        if (this.usesAnimation)
	            this._pass.animationSet.doneAGALCode(this);
	    };
	    /**
	     * The blend mode to use when drawing this renderable. The following blend modes are supported:
	     * <ul>
	     * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
	     * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
	     * <li>BlendMode.MULTIPLY</li>
	     * <li>BlendMode.ADD</li>
	     * <li>BlendMode.ALPHA</li>
	     * </ul>
	     */
	    ShaderBase.prototype.setBlendMode = function (value) {
	        switch (value) {
	            case BlendMode_1.BlendMode.NORMAL:
	                this._blendFactorSource = ContextGLBlendFactor_1.ContextGLBlendFactor.ONE;
	                this._blendFactorDest = ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO;
	                this.usesBlending = false;
	                break;
	            case BlendMode_1.BlendMode.LAYER:
	                this._blendFactorSource = ContextGLBlendFactor_1.ContextGLBlendFactor.SOURCE_ALPHA;
	                this._blendFactorDest = ContextGLBlendFactor_1.ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA;
	                this.usesBlending = true;
	                break;
	            case BlendMode_1.BlendMode.MULTIPLY:
	                this._blendFactorSource = ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO;
	                this._blendFactorDest = ContextGLBlendFactor_1.ContextGLBlendFactor.SOURCE_COLOR;
	                this.usesBlending = true;
	                break;
	            case BlendMode_1.BlendMode.ADD:
	                this._blendFactorSource = ContextGLBlendFactor_1.ContextGLBlendFactor.SOURCE_ALPHA;
	                this._blendFactorDest = ContextGLBlendFactor_1.ContextGLBlendFactor.ONE;
	                this.usesBlending = true;
	                break;
	            case BlendMode_1.BlendMode.ALPHA:
	                this._blendFactorSource = ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO;
	                this._blendFactorDest = ContextGLBlendFactor_1.ContextGLBlendFactor.SOURCE_ALPHA;
	                this.usesBlending = true;
	                break;
	            default:
	                throw new ArgumentError_1.ArgumentError("Unsupported blend mode!");
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ShaderBase.prototype._iActivate = function (camera) {
	        this._stage.context.setCulling(this.useBothSides ? ContextGLTriangleFace_1.ContextGLTriangleFace.NONE : this._defaultCulling, camera.projection.coordinateSystem);
	        if (!this.usesTangentSpace && this.cameraPositionIndex >= 0) {
	            var pos = camera.scenePosition;
	            this.vertexConstantData[this.cameraPositionIndex] = pos.x;
	            this.vertexConstantData[this.cameraPositionIndex + 1] = pos.y;
	            this.vertexConstantData[this.cameraPositionIndex + 2] = pos.z;
	        }
	        this._stage.context.setDepthTest((this.writeDepth && !this.usesBlending), this.depthCompareMode);
	        if (this.usesBlending)
	            this._stage.context.setBlendFactors(this._blendFactorSource, this._blendFactorDest);
	        this.activeElements = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    ShaderBase.prototype._iDeactivate = function () {
	        //For the love of god don't remove this if you want your multi-material shadows to not flicker like shit
	        this._stage.context.setDepthTest(true, ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL);
	        this.activeElements = null;
	    };
	    /**
	     *
	     *
	     * @param renderable
	     * @param stage
	     * @param camera
	     */
	    ShaderBase.prototype._setRenderState = function (renderable, camera, viewProjection) {
	        if (renderable.renderable.animator)
	            renderable.renderable.animator.setRenderState(this, renderable, this._stage, camera);
	        if (this.usesUVTransform) {
	            var uvMatrix = renderable.uvMatrix;
	            if (uvMatrix) {
	                //transpose
	                var rawData = uvMatrix.rawData;
	                this.vertexConstantData[this.uvMatrixIndex] = rawData[0];
	                this.vertexConstantData[this.uvMatrixIndex + 1] = rawData[2];
	                this.vertexConstantData[this.uvMatrixIndex + 3] = rawData[4];
	                this.vertexConstantData[this.uvMatrixIndex + 4] = rawData[1];
	                this.vertexConstantData[this.uvMatrixIndex + 5] = rawData[3];
	                this.vertexConstantData[this.uvMatrixIndex + 7] = rawData[5];
	            }
	            else {
	                this.vertexConstantData[this.uvMatrixIndex] = 1;
	                this.vertexConstantData[this.uvMatrixIndex + 1] = 0;
	                this.vertexConstantData[this.uvMatrixIndex + 3] = 0;
	                this.vertexConstantData[this.uvMatrixIndex + 4] = 0;
	                this.vertexConstantData[this.uvMatrixIndex + 5] = 1;
	                this.vertexConstantData[this.uvMatrixIndex + 7] = 0;
	            }
	        }
	        if (this.usesColorTransform) {
	            var colorTransform = renderable.sourceEntity._iAssignedColorTransform();
	            if (colorTransform) {
	                //TODO: AWDParser to write normalised color offsets
	                this.fragmentConstantData[this.colorTransformIndex] = colorTransform.rawData[0];
	                this.fragmentConstantData[this.colorTransformIndex + 1] = colorTransform.rawData[1];
	                this.fragmentConstantData[this.colorTransformIndex + 2] = colorTransform.rawData[2];
	                this.fragmentConstantData[this.colorTransformIndex + 3] = colorTransform.rawData[3];
	                this.fragmentConstantData[this.colorTransformIndex + 4] = colorTransform.rawData[4] / 255;
	                this.fragmentConstantData[this.colorTransformIndex + 5] = colorTransform.rawData[5] / 255;
	                this.fragmentConstantData[this.colorTransformIndex + 6] = colorTransform.rawData[6] / 255;
	                this.fragmentConstantData[this.colorTransformIndex + 7] = colorTransform.rawData[7] / 255;
	            }
	            else {
	                this.fragmentConstantData[this.colorTransformIndex] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 1] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 2] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 3] = 1;
	                this.fragmentConstantData[this.colorTransformIndex + 4] = 0;
	                this.fragmentConstantData[this.colorTransformIndex + 5] = 0;
	                this.fragmentConstantData[this.colorTransformIndex + 6] = 0;
	                this.fragmentConstantData[this.colorTransformIndex + 7] = 0;
	            }
	        }
	        if (this.sceneNormalMatrixIndex >= 0)
	            renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this.vertexConstantData, this.sceneNormalMatrixIndex, false);
	        if (this.usesTangentSpace && this.cameraPositionIndex >= 0) {
	            renderable.sourceEntity.inverseSceneTransform.copyRawDataTo(this._pInverseSceneMatrix);
	            var pos = camera.scenePosition;
	            var x = pos.x;
	            var y = pos.y;
	            var z = pos.z;
	            this.vertexConstantData[this.cameraPositionIndex] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z + this._pInverseSceneMatrix[12];
	            this.vertexConstantData[this.cameraPositionIndex + 1] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z + this._pInverseSceneMatrix[13];
	            this.vertexConstantData[this.cameraPositionIndex + 2] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z + this._pInverseSceneMatrix[14];
	        }
	    };
	    ShaderBase.prototype.invalidateProgram = function () {
	        this._invalidProgram = true;
	    };
	    ShaderBase.prototype.dispose = function () {
	        this._programData.dispose();
	        this._programData = null;
	    };
	    ShaderBase.prototype._updateProgram = function () {
	        this._invalidProgram = false;
	        var compiler = this.createCompiler(this._elementsClass, this._pass);
	        compiler.compile();
	        this._calcAnimationCode(compiler._pRegisterCache, compiler.shadedTarget, compiler._pSharedRegisters);
	        //initialise the required shader constants
	        this.initConstantData(compiler._pRegisterCache);
	        var programData = this._stage.getProgramData(this._animationVertexCode + compiler.vertexCode, compiler.fragmentCode + this._animationFragmentCode + compiler.postAnimationFragmentCode);
	        //check program data hasn't changed, keep count of program usages
	        if (this._programData != programData) {
	            if (this._programData)
	                this._programData.dispose();
	            this._programData = programData;
	            programData.usages++;
	        }
	    };
	    ShaderBase.prototype._calcAnimationCode = function (registerCache, shadedTarget, sharedRegisters) {
	        //reset code
	        this._animationVertexCode = "";
	        this._animationFragmentCode = "";
	        //check to see if GPU animation is used
	        if (this.usesAnimation) {
	            var animationSet = this._pass.animationSet;
	            this._animationVertexCode += animationSet.getAGALVertexCode(this, registerCache, sharedRegisters);
	            if (this.uvDependencies > 0 && !this.usesUVTransform)
	                this._animationVertexCode += animationSet.getAGALUVCode(this, registerCache, sharedRegisters);
	            if (this.usesFragmentAnimation)
	                this._animationFragmentCode += animationSet.getAGALFragmentCode(this, registerCache, shadedTarget);
	        }
	        else {
	            // simply write attributes to targets, do not animate them
	            // projection will pick up on targets[0] to do the projection
	            var len = sharedRegisters.animatableAttributes.length;
	            for (var i = 0; i < len; ++i)
	                this._animationVertexCode += "mov " + sharedRegisters.animationTargetRegisters[i] + ", " + sharedRegisters.animatableAttributes[i] + "\n";
	            if (this.uvDependencies > 0 && !this.usesUVTransform)
	                this._animationVertexCode += "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
	        }
	    };
	    ShaderBase.prototype.setVertexConst = function (index, x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 0; }
	        index *= 4;
	        this.vertexConstantData[index++] = x;
	        this.vertexConstantData[index++] = y;
	        this.vertexConstantData[index++] = z;
	        this.vertexConstantData[index] = w;
	    };
	    ShaderBase.prototype.setVertexConstFromArray = function (index, data) {
	        index *= 4;
	        for (var i = 0; i < data.length; i++)
	            this.vertexConstantData[index++] = data[i];
	    };
	    ShaderBase.prototype.setVertexConstFromMatrix = function (index, matrix) {
	        index *= 4;
	        var rawData = matrix.rawData;
	        this.vertexConstantData[index++] = rawData[0];
	        this.vertexConstantData[index++] = rawData[4];
	        this.vertexConstantData[index++] = rawData[8];
	        this.vertexConstantData[index++] = rawData[12];
	        this.vertexConstantData[index++] = rawData[1];
	        this.vertexConstantData[index++] = rawData[5];
	        this.vertexConstantData[index++] = rawData[9];
	        this.vertexConstantData[index++] = rawData[13];
	        this.vertexConstantData[index++] = rawData[2];
	        this.vertexConstantData[index++] = rawData[6];
	        this.vertexConstantData[index++] = rawData[10];
	        this.vertexConstantData[index++] = rawData[14];
	        this.vertexConstantData[index++] = rawData[3];
	        this.vertexConstantData[index++] = rawData[7];
	        this.vertexConstantData[index++] = rawData[11];
	        this.vertexConstantData[index] = rawData[15];
	    };
	    ShaderBase.prototype.setFragmentConst = function (index, x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 0; }
	        index *= 4;
	        this.fragmentConstantData[index++] = x;
	        this.fragmentConstantData[index++] = y;
	        this.fragmentConstantData[index++] = z;
	        this.fragmentConstantData[index] = w;
	    };
	    ShaderBase._abstractionClassPool = new Object();
	    return ShaderBase;
	}());
	exports.ShaderBase = ShaderBase;


/***/ },
/* 272 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ShaderRegisterCache_1 = __webpack_require__(273);
	var ShaderRegisterData_1 = __webpack_require__(276);
	/**
	 * CompilerBase is an abstract base class for shader compilers that use modular shader methods to assemble a
	 * material. Concrete subclasses are used by the default materials.
	 *
	 * @see away.materials.ShadingMethodBase
	 */
	var CompilerBase = (function () {
	    /**
	     * Creates a new CompilerBase object.
	     * @param profile The compatibility profile of the renderer.
	     */
	    function CompilerBase(elementsClass, pass, shader) {
	        this._pVertexCode = ''; // Changed to emtpy string- AwayTS
	        this._pFragmentCode = ''; // Changed to emtpy string - AwayTS
	        this._pPostAnimationFragmentCode = ''; // Changed to emtpy string - AwayTS
	        this._pElementsClass = elementsClass;
	        this._pRenderPass = pass;
	        this._pShader = shader;
	        this._pSharedRegisters = new ShaderRegisterData_1.ShaderRegisterData();
	        this._pRegisterCache = new ShaderRegisterCache_1.ShaderRegisterCache(shader.profile);
	    }
	    /**
	     * Compiles the code after all setup on the compiler has finished.
	     */
	    CompilerBase.prototype.compile = function () {
	        this._pShader.reset();
	        this._pShader._iIncludeDependencies();
	        this.pInitRegisterIndices();
	        this.pCompileDependencies();
	        //compile custom vertex & fragment codes
	        this._pVertexCode += this._pRenderPass._iGetVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        this._pPostAnimationFragmentCode += this._pRenderPass._iGetFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        //assign the final output color to the output register
	        this._pPostAnimationFragmentCode += "mov " + this._pRegisterCache.fragmentOutputRegister + ", " + this._pSharedRegisters.shadedTarget + "\n";
	        this._pRegisterCache.removeFragmentTempUsage(this._pSharedRegisters.shadedTarget);
	    };
	    /**
	     * Calculate the transformed colours
	     */
	    CompilerBase.prototype.compileColorTransformCode = function () {
	        // rm, gm, bm, am - multiplier
	        // ro, go, bo, ao - offset
	        var ct1 = this._pRegisterCache.getFreeFragmentConstant();
	        var ct2 = this._pRegisterCache.getFreeFragmentConstant();
	        this._pShader.colorTransformIndex = ct1.index * 4;
	        this._pPostAnimationFragmentCode += "mul " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ", " + ct1 + "\n";
	        this._pPostAnimationFragmentCode += "add " + this._pSharedRegisters.shadedTarget + ", " + this._pSharedRegisters.shadedTarget + ", " + ct2 + "\n";
	    };
	    /**
	     * Compile the code for the methods.
	     */
	    CompilerBase.prototype.pCompileDependencies = function () {
	        this._pSharedRegisters.shadedTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
	        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadedTarget, 1);
	        //compile the world-space position if required
	        if (this._pShader.globalPosDependencies > 0)
	            this.compileGlobalPositionCode();
	        //compile the local-space position if required
	        if (this._pShader.usesPositionFragment)
	            this.compilePositionCode();
	        if (this._pShader.usesCurves)
	            this.compileCurvesCode();
	        if (this._pShader.usesColorTransform)
	            this.compileColorTransformCode();
	        //Calculate the (possibly animated) UV coordinates.
	        if (this._pShader.uvDependencies > 0)
	            this.compileUVCode();
	        if (this._pShader.secondaryUVDependencies > 0)
	            this.compileSecondaryUVCode();
	        if (this._pShader.normalDependencies > 0)
	            this.compileNormalCode();
	        if (this._pShader.viewDirDependencies > 0)
	            this.compileViewDirCode();
	        //collect code from material
	        this._pVertexCode += this._pElementsClass._iGetVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        this._pFragmentCode += this._pElementsClass._iGetFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        //collect code from pass
	        this._pVertexCode += this._pRenderPass._iGetPreLightingVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	        this._pFragmentCode += this._pRenderPass._iGetPreLightingFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	    };
	    CompilerBase.prototype.compileGlobalPositionCode = function () {
	        this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.globalPositionVertex = this._pRegisterCache.getFreeVertexVectorTemp(), this._pShader.globalPosDependencies);
	        var sceneMatrixReg = this._pRegisterCache.getFreeVertexConstant();
	        this._pRegisterCache.getFreeVertexConstant();
	        this._pRegisterCache.getFreeVertexConstant();
	        this._pRegisterCache.getFreeVertexConstant();
	        this._pShader.sceneMatrixIndex = sceneMatrixReg.index * 4;
	        this._pVertexCode += "m44 " + this._pSharedRegisters.globalPositionVertex + ", " + this._pSharedRegisters.animatedPosition + ", " + sceneMatrixReg + "\n";
	        if (this._pShader.usesGlobalPosFragment) {
	            this._pSharedRegisters.globalPositionVarying = this._pRegisterCache.getFreeVarying();
	            this._pVertexCode += "mov " + this._pSharedRegisters.globalPositionVarying + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
	        }
	    };
	    CompilerBase.prototype.compilePositionCode = function () {
	        this._pSharedRegisters.positionVarying = this._pRegisterCache.getFreeVarying();
	        this._pVertexCode += "mov " + this._pSharedRegisters.positionVarying + ", " + this._pSharedRegisters.animatedPosition + "\n";
	    };
	    CompilerBase.prototype.compileCurvesCode = function () {
	        this._pSharedRegisters.curvesInput = this._pRegisterCache.getFreeVertexAttribute();
	        this._pShader.curvesIndex = this._pSharedRegisters.curvesInput.index;
	        this._pSharedRegisters.curvesVarying = this._pRegisterCache.getFreeVarying();
	        this._pVertexCode += "mov " + this._pSharedRegisters.curvesVarying + ", " + this._pSharedRegisters.curvesInput + "\n";
	        var temp = this._pRegisterCache.getFreeFragmentSingleTemp();
	        this._pFragmentCode += "mul " + temp + ", " + this._pSharedRegisters.curvesVarying + ".y, " + this._pSharedRegisters.curvesVarying + ".y\n" +
	            "sub " + temp + ", " + temp + ", " + this._pSharedRegisters.curvesVarying + ".z\n" +
	            "mul " + temp + ", " + temp + ", " + this._pSharedRegisters.curvesVarying + ".x\n" +
	            "kil " + temp + "\n";
	        // var temp:ShaderRegisterElement = this._pRegisterCache.getFreeFragmentVectorTemp();
	        //
	        // this._pPostAnimationFragmentCode += "mul " + temp + ".x, " + this._pSharedRegisters.curvesVarying + ".y, " + this._pSharedRegisters.curvesVarying + ".y\n" +
	        // 					"sub " + temp + ".x, " + temp + ".x, " + this._pSharedRegisters.curvesVarying + ".z\n" +
	        // 					"mul " + temp + ".x, " + temp + ".x, " + this._pSharedRegisters.curvesVarying + ".x\n" +
	        // 					"ddx " + temp + ".y," + temp + ".x\n" +
	        // 					"ddy " + temp + ".z," + temp + ".x\n" +
	        // 					"mul " + temp + ".y, " + temp + ".y, " + temp + ".y\n" +
	        // 					"mul " + temp + ".z, " + temp + ".z, " + temp + ".z\n" +
	        // 					"add " + this._pSharedRegisters.shadedTarget + ".w, " + temp + ".y, " + temp + ".z\n" +
	        // 					"sqt " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w\n" +
	        // 					"div " + this._pSharedRegisters.shadedTarget + ".w, " + temp + ".x, " + this._pSharedRegisters.shadedTarget + ".w\n" +
	        // 					"max " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".y\n" +
	        // 					"min " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.shadedTarget + ".w, " + this._pSharedRegisters.commons + ".w\n";
	    };
	    /**
	     * Calculate the (possibly animated) UV coordinates.
	     */
	    CompilerBase.prototype.compileUVCode = function () {
	        var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
	        this._pShader.uvIndex = uvAttributeReg.index;
	        var varying = this._pSharedRegisters.uvVarying = this._pRegisterCache.getFreeVarying();
	        if (this._pShader.usesUVTransform) {
	            // a, b, 0, tx
	            // c, d, 0, ty
	            var uvTransform1 = this._pRegisterCache.getFreeVertexConstant();
	            var uvTransform2 = this._pRegisterCache.getFreeVertexConstant();
	            this._pShader.uvMatrixIndex = uvTransform1.index * 4;
	            this._pVertexCode += "dp4 " + varying + ".x, " + uvAttributeReg + ", " + uvTransform1 + "\n" +
	                "dp4 " + varying + ".y, " + uvAttributeReg + ", " + uvTransform2 + "\n" +
	                "mov " + varying + ".zw, " + uvAttributeReg + ".zw \n";
	        }
	        else {
	            this._pShader.uvMatrixIndex = -1;
	            this._pSharedRegisters.uvTarget = varying;
	            this._pSharedRegisters.uvSource = uvAttributeReg;
	        }
	    };
	    /**
	     * Provide the secondary UV coordinates.
	     */
	    CompilerBase.prototype.compileSecondaryUVCode = function () {
	        var uvAttributeReg = this._pRegisterCache.getFreeVertexAttribute();
	        this._pShader.secondaryUVIndex = uvAttributeReg.index;
	        this._pSharedRegisters.secondaryUVVarying = this._pRegisterCache.getFreeVarying();
	        this._pVertexCode += "mov " + this._pSharedRegisters.secondaryUVVarying + ", " + uvAttributeReg + "\n";
	    };
	    /**
	     * Calculate the view direction.
	     */
	    CompilerBase.prototype.compileViewDirCode = function () {
	        var cameraPositionReg = this._pRegisterCache.getFreeVertexConstant();
	        this._pSharedRegisters.viewDirVarying = this._pRegisterCache.getFreeVarying();
	        this._pSharedRegisters.viewDirFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
	        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.viewDirFragment, this._pShader.viewDirDependencies);
	        this._pShader.cameraPositionIndex = cameraPositionReg.index * 4;
	        if (this._pShader.usesTangentSpace) {
	            var temp = this._pRegisterCache.getFreeVertexVectorTemp();
	            this._pVertexCode += "sub " + temp + ", " + cameraPositionReg + ", " + this._pSharedRegisters.animatedPosition + "\n" +
	                "m33 " + this._pSharedRegisters.viewDirVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" +
	                "mov " + this._pSharedRegisters.viewDirVarying + ".w, " + this._pSharedRegisters.animatedPosition + ".w\n";
	        }
	        else {
	            this._pVertexCode += "sub " + this._pSharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
	            this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.globalPositionVertex);
	        }
	        //TODO is this required in all cases? (re: distancemappass)
	        this._pFragmentCode += "nrm " + this._pSharedRegisters.viewDirFragment + ".xyz, " + this._pSharedRegisters.viewDirVarying + "\n" +
	            "mov " + this._pSharedRegisters.viewDirFragment + ".w,   " + this._pSharedRegisters.viewDirVarying + ".w\n";
	    };
	    /**
	     * Calculate the normal.
	     */
	    CompilerBase.prototype.compileNormalCode = function () {
	        this._pSharedRegisters.normalFragment = this._pRegisterCache.getFreeFragmentVectorTemp();
	        this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.normalFragment, this._pShader.normalDependencies);
	        //simple normal aquisition if no tangent space is being used
	        if (this._pShader.outputsNormals && !this._pShader.outputsTangentNormals) {
	            this._pVertexCode += this._pRenderPass._iGetNormalVertexCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	            this._pFragmentCode += this._pRenderPass._iGetNormalFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	            return;
	        }
	        var normalMatrix;
	        if (!this._pShader.outputsNormals || !this._pShader.usesTangentSpace) {
	            normalMatrix = new Array(3);
	            normalMatrix[0] = this._pRegisterCache.getFreeVertexConstant();
	            normalMatrix[1] = this._pRegisterCache.getFreeVertexConstant();
	            normalMatrix[2] = this._pRegisterCache.getFreeVertexConstant();
	            this._pRegisterCache.getFreeVertexConstant();
	            this._pShader.sceneNormalMatrixIndex = normalMatrix[0].index * 4;
	            this._pSharedRegisters.normalVarying = this._pRegisterCache.getFreeVarying();
	        }
	        if (this._pShader.outputsNormals) {
	            if (this._pShader.usesTangentSpace) {
	                // normalize normal + tangent vector and generate (approximated) bitangent used in m33 operation for view
	                this._pVertexCode += "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + this._pSharedRegisters.animatedNormal + "\n" +
	                    "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + this._pSharedRegisters.animatedTangent + "\n" +
	                    "crs " + this._pSharedRegisters.bitangent + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n";
	                this._pFragmentCode += this._pRenderPass._iGetNormalFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters);
	            }
	            else {
	                //Compiles the vertex shader code for tangent-space normal maps.
	                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
	                this._pSharedRegisters.bitangentVarying = this._pRegisterCache.getFreeVarying();
	                var temp = this._pRegisterCache.getFreeVertexVectorTemp();
	                this._pVertexCode += "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" +
	                    "nrm " + this._pSharedRegisters.animatedNormal + ".xyz, " + temp + "\n" +
	                    "m33 " + temp + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" +
	                    "nrm " + this._pSharedRegisters.animatedTangent + ".xyz, " + temp + "\n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".x  \n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".x  \n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".y  \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".y  \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".x, " + this._pSharedRegisters.animatedTangent + ".z  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".z, " + this._pSharedRegisters.animatedNormal + ".z  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.normalInput + ".w  \n" +
	                    "crs " + temp + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + this._pSharedRegisters.animatedTangent + "\n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".y, " + temp + ".x    \n" +
	                    "mov " + this._pSharedRegisters.bitangentVarying + ".y, " + temp + ".y  \n" +
	                    "mov " + this._pSharedRegisters.normalVarying + ".y, " + temp + ".z    \n";
	                this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedTangent);
	                //Compiles the fragment shader code for tangent-space normal maps.
	                var t;
	                var b;
	                var n;
	                t = this._pRegisterCache.getFreeFragmentVectorTemp();
	                this._pRegisterCache.addFragmentTempUsages(t, 1);
	                b = this._pRegisterCache.getFreeFragmentVectorTemp();
	                this._pRegisterCache.addFragmentTempUsages(b, 1);
	                n = this._pRegisterCache.getFreeFragmentVectorTemp();
	                this._pRegisterCache.addFragmentTempUsages(n, 1);
	                this._pFragmentCode += "nrm " + t + ".xyz, " + this._pSharedRegisters.tangentVarying + "\n" +
	                    "mov " + t + ".w, " + this._pSharedRegisters.tangentVarying + ".w	\n" +
	                    "nrm " + b + ".xyz, " + this._pSharedRegisters.bitangentVarying + "\n" +
	                    "nrm " + n + ".xyz, " + this._pSharedRegisters.normalVarying + "\n";
	                //compile custom fragment code for normal calcs
	                this._pFragmentCode += this._pRenderPass._iGetNormalFragmentCode(this._pShader, this._pRegisterCache, this._pSharedRegisters) +
	                    "m33 " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalFragment + ", " + t + "\n" +
	                    "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w\n";
	                this._pRegisterCache.removeFragmentTempUsage(b);
	                this._pRegisterCache.removeFragmentTempUsage(t);
	                this._pRegisterCache.removeFragmentTempUsage(n);
	            }
	        }
	        else {
	            // no output, world space is enough
	            this._pVertexCode += "m33 " + this._pSharedRegisters.normalVarying + ".xyz, " + this._pSharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" +
	                "mov " + this._pSharedRegisters.normalVarying + ".w, " + this._pSharedRegisters.animatedNormal + ".w\n";
	            this._pFragmentCode += "nrm " + this._pSharedRegisters.normalFragment + ".xyz, " + this._pSharedRegisters.normalVarying + "\n" +
	                "mov " + this._pSharedRegisters.normalFragment + ".w, " + this._pSharedRegisters.normalVarying + ".w\n";
	            if (this._pShader.tangentDependencies > 0) {
	                this._pSharedRegisters.tangentVarying = this._pRegisterCache.getFreeVarying();
	                this._pVertexCode += "m33 " + this._pSharedRegisters.tangentVarying + ".xyz, " + this._pSharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" +
	                    "mov " + this._pSharedRegisters.tangentVarying + ".w, " + this._pSharedRegisters.animatedTangent + ".w\n";
	            }
	        }
	        if (!this._pShader.usesTangentSpace)
	            this._pRegisterCache.removeVertexTempUsage(this._pSharedRegisters.animatedNormal);
	    };
	    /**
	     * Reset all the indices to "unused".
	     */
	    CompilerBase.prototype.pInitRegisterIndices = function () {
	        this._pShader.pInitRegisterIndices();
	        this._pSharedRegisters.animatedPosition = this._pRegisterCache.getFreeVertexVectorTemp();
	        this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedPosition, 1);
	        this._pSharedRegisters.animatableAttributes.push(this._pRegisterCache.getFreeVertexAttribute());
	        this._pSharedRegisters.animationTargetRegisters.push(this._pSharedRegisters.animatedPosition);
	        this._pVertexCode = "";
	        this._pFragmentCode = "";
	        this._pPostAnimationFragmentCode = "";
	        //create commonly shared constant registers
	        if (this._pShader.usesCommonData || this._pShader.normalDependencies > 0) {
	            this._pSharedRegisters.commons = this._pRegisterCache.getFreeFragmentConstant();
	            this._pShader.commonsDataIndex = this._pSharedRegisters.commons.index * 4;
	        }
	        //Creates the registers to contain the tangent data.
	        //Needs to be created FIRST and in this order (for when using tangent space)
	        if (this._pShader.tangentDependencies > 0 || this._pShader.outputsNormals) {
	            this._pSharedRegisters.tangentInput = this._pRegisterCache.getFreeVertexAttribute();
	            this._pShader.tangentIndex = this._pSharedRegisters.tangentInput.index;
	            this._pSharedRegisters.animatedTangent = this._pRegisterCache.getFreeVertexVectorTemp();
	            this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedTangent, 1);
	            if (this._pShader.usesTangentSpace) {
	                this._pSharedRegisters.bitangent = this._pRegisterCache.getFreeVertexVectorTemp();
	                this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.bitangent, 1);
	            }
	            this._pSharedRegisters.animatableAttributes.push(this._pSharedRegisters.tangentInput);
	            this._pSharedRegisters.animationTargetRegisters.push(this._pSharedRegisters.animatedTangent);
	        }
	        if (this._pShader.normalDependencies > 0) {
	            this._pSharedRegisters.normalInput = this._pRegisterCache.getFreeVertexAttribute();
	            this._pShader.normalIndex = this._pSharedRegisters.normalInput.index;
	            this._pSharedRegisters.animatedNormal = this._pRegisterCache.getFreeVertexVectorTemp();
	            this._pRegisterCache.addVertexTempUsages(this._pSharedRegisters.animatedNormal, 1);
	            this._pSharedRegisters.animatableAttributes.push(this._pSharedRegisters.normalInput);
	            this._pSharedRegisters.animationTargetRegisters.push(this._pSharedRegisters.animatedNormal);
	        }
	        if (this._pShader.colorDependencies > 0) {
	            this._pSharedRegisters.colorInput = this._pRegisterCache.getFreeVertexAttribute();
	            this._pShader.colorBufferIndex = this._pSharedRegisters.colorInput.index;
	            this._pSharedRegisters.colorVarying = this._pRegisterCache.getFreeVarying();
	            this._pVertexCode += "mov " + this._pSharedRegisters.colorVarying + ", " + this._pSharedRegisters.colorInput + "\n";
	        }
	    };
	    /**
	     * Disposes all resources used by the compiler.
	     */
	    CompilerBase.prototype.dispose = function () {
	        this._pRegisterCache.dispose();
	        this._pRegisterCache = null;
	        this._pSharedRegisters = null;
	    };
	    Object.defineProperty(CompilerBase.prototype, "vertexCode", {
	        /**
	         * The generated vertex code.
	         */
	        get: function () {
	            return this._pVertexCode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompilerBase.prototype, "fragmentCode", {
	        /**
	         * The generated fragment code.
	         */
	        get: function () {
	            return this._pFragmentCode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompilerBase.prototype, "postAnimationFragmentCode", {
	        /**
	         * The generated fragment code.
	         */
	        get: function () {
	            return this._pPostAnimationFragmentCode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompilerBase.prototype, "shadedTarget", {
	        /**
	         * The register containing the final shaded colour.
	         */
	        get: function () {
	            return this._pSharedRegisters.shadedTarget;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CompilerBase;
	}());
	exports.CompilerBase = CompilerBase;


/***/ },
/* 273 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RegisterPool_1 = __webpack_require__(274);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * ShaderRegister Cache provides the usage management system for all registers during shading compilers.
	 */
	var ShaderRegisterCache = (function () {
	    /**
	     * Create a new ShaderRegisterCache object.
	     *
	     * @param profile The compatibility profile used by the renderer.
	     */
	    function ShaderRegisterCache(profile) {
	        this._numUsedVertexConstants = 0;
	        this._numUsedFragmentConstants = 0;
	        this._numUsedStreams = 0;
	        this._numUsedTextures = 0;
	        this._numUsedVaryings = 0;
	        this._profile = profile;
	        this.reset();
	    }
	    /**
	     * Resets all registers.
	     */
	    ShaderRegisterCache.prototype.reset = function () {
	        this._fragmentTempCache = new RegisterPool_1.RegisterPool("ft", 8, false);
	        this._vertexTempCache = new RegisterPool_1.RegisterPool("vt", 8, false);
	        this._varyingCache = new RegisterPool_1.RegisterPool("v", 8);
	        this._textureCache = new RegisterPool_1.RegisterPool("fs", 8);
	        this._vertexAttributesCache = new RegisterPool_1.RegisterPool("va", 8);
	        this._fragmentConstantsCache = new RegisterPool_1.RegisterPool("fc", 28);
	        this._vertexConstantsCache = new RegisterPool_1.RegisterPool("vc", 128);
	        this._fragmentOutputRegister = new ShaderRegisterElement_1.ShaderRegisterElement("oc", -1);
	        this._vertexOutputRegister = new ShaderRegisterElement_1.ShaderRegisterElement("op", -1);
	        this._numUsedVertexConstants = 0;
	        this._numUsedStreams = 0;
	        this._numUsedTextures = 0;
	        this._numUsedVaryings = 0;
	        this._numUsedFragmentConstants = 0;
	    };
	    /**
	     * Disposes all resources used.
	     */
	    ShaderRegisterCache.prototype.dispose = function () {
	        this._fragmentTempCache.dispose();
	        this._vertexTempCache.dispose();
	        this._varyingCache.dispose();
	        this._fragmentConstantsCache.dispose();
	        this._vertexAttributesCache.dispose();
	        this._fragmentTempCache = null;
	        this._vertexTempCache = null;
	        this._varyingCache = null;
	        this._fragmentConstantsCache = null;
	        this._vertexAttributesCache = null;
	        this._fragmentOutputRegister = null;
	        this._vertexOutputRegister = null;
	    };
	    /**
	     * Marks a fragment temporary register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
	     * has been called usageCount times again.
	     * @param register The register to mark as used.
	     * @param usageCount The amount of usages to add.
	     */
	    ShaderRegisterCache.prototype.addFragmentTempUsages = function (register, usageCount) {
	        this._fragmentTempCache.addUsage(register, usageCount);
	    };
	    /**
	     * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
	     * @param register The register for which to remove a usage.
	     */
	    ShaderRegisterCache.prototype.removeFragmentTempUsage = function (register) {
	        this._fragmentTempCache.removeUsage(register);
	    };
	    /**
	     * Marks a vertex temporary register as used, so it cannot be retrieved. The register won't be able to be used
	     * until removeUsage has been called usageCount times again.
	     * @param register The register to mark as used.
	     * @param usageCount The amount of usages to add.
	     */
	    ShaderRegisterCache.prototype.addVertexTempUsages = function (register, usageCount) {
	        this._vertexTempCache.addUsage(register, usageCount);
	    };
	    /**
	     * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
	     * @param register The register for which to remove a usage.
	     */
	    ShaderRegisterCache.prototype.removeVertexTempUsage = function (register) {
	        this._vertexTempCache.removeUsage(register);
	    };
	    /**
	     * Retrieve an entire fragment temporary register that's still available. The register won't be able to be used until removeUsage
	     * has been called usageCount times again.
	     */
	    ShaderRegisterCache.prototype.getFreeFragmentVectorTemp = function () {
	        return this._fragmentTempCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve a single component from a fragment temporary register that's still available.
	     */
	    ShaderRegisterCache.prototype.getFreeFragmentSingleTemp = function () {
	        return this._fragmentTempCache.requestFreeRegComponent();
	    };
	    /**
	     * Retrieve an available varying register
	     */
	    ShaderRegisterCache.prototype.getFreeVarying = function () {
	        ++this._numUsedVaryings;
	        return this._varyingCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an available fragment constant register
	     */
	    ShaderRegisterCache.prototype.getFreeFragmentConstant = function () {
	        ++this._numUsedFragmentConstants;
	        return this._fragmentConstantsCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an available vertex constant register
	     */
	    ShaderRegisterCache.prototype.getFreeVertexConstant = function () {
	        ++this._numUsedVertexConstants;
	        return this._vertexConstantsCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an entire vertex temporary register that's still available.
	     */
	    ShaderRegisterCache.prototype.getFreeVertexVectorTemp = function () {
	        return this._vertexTempCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve a single component from a vertex temporary register that's still available.
	     */
	    ShaderRegisterCache.prototype.getFreeVertexSingleTemp = function () {
	        return this._vertexTempCache.requestFreeRegComponent();
	    };
	    /**
	     * Retrieve an available vertex attribute register
	     */
	    ShaderRegisterCache.prototype.getFreeVertexAttribute = function () {
	        ++this._numUsedStreams;
	        return this._vertexAttributesCache.requestFreeVectorReg();
	    };
	    /**
	     * Retrieve an available texture register
	     */
	    ShaderRegisterCache.prototype.getFreeTextureReg = function () {
	        ++this._numUsedTextures;
	        return this._textureCache.requestFreeVectorReg();
	    };
	    Object.defineProperty(ShaderRegisterCache.prototype, "fragmentOutputRegister", {
	        /**
	         * The fragment output register.
	         */
	        get: function () {
	            return this._fragmentOutputRegister;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVertexConstants", {
	        /**
	         * The amount of used vertex constant registers.
	         */
	        get: function () {
	            return this._numUsedVertexConstants;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedFragmentConstants", {
	        /**
	         * The amount of used fragment constant registers.
	         */
	        get: function () {
	            return this._numUsedFragmentConstants;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedStreams", {
	        /**
	         * The amount of used vertex streams.
	         */
	        get: function () {
	            return this._numUsedStreams;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedTextures", {
	        /**
	         * The amount of used texture slots.
	         */
	        get: function () {
	            return this._numUsedTextures;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVaryings", {
	        /**
	         * The amount of used varying registers.
	         */
	        get: function () {
	            return this._numUsedVaryings;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ShaderRegisterCache;
	}());
	exports.ShaderRegisterCache = ShaderRegisterCache;


/***/ },
/* 274 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * RegisterPool is used by the shader compilers process to keep track of which registers of a certain type are
	 * currently used and should not be allowed to be written to. Either entire registers can be requested and locked,
	 * or single components (x, y, z, w) of a single register.
	 * It is used by ShaderRegisterCache to track usages of individual register types.
	 *
	 * @see away.materials.ShaderRegisterCache
	 */
	var RegisterPool = (function () {
	    /**
	     * Creates a new RegisterPool object.
	     * @param regName The base name of the register type ("ft" for fragment temporaries, "vc" for vertex constants, etc)
	     * @param regCount The amount of available registers of this type.
	     * @param persistent Whether or not registers, once reserved, can be freed again. For example, temporaries are not persistent, but constants are.
	     */
	    function RegisterPool(regName, regCount, persistent) {
	        if (persistent === void 0) { persistent = true; }
	        this._regName = regName;
	        this._regCount = regCount;
	        this._persistent = persistent;
	        this.initRegisters(regName, regCount);
	    }
	    /**
	     * Retrieve an entire vector register that's still available.
	     */
	    RegisterPool.prototype.requestFreeVectorReg = function () {
	        for (var i = 0; i < this._regCount; ++i) {
	            if (!this.isRegisterUsed(i)) {
	                if (this._persistent)
	                    this._usedVectorCount[i]++;
	                return this._vectorRegisters[i];
	            }
	        }
	        throw new Error("Register overflow!");
	    };
	    /**
	     * Retrieve a single vector component that's still available.
	     */
	    RegisterPool.prototype.requestFreeRegComponent = function () {
	        for (var i = 0; i < this._regCount; ++i) {
	            if (this._usedVectorCount[i] > 0)
	                continue;
	            for (var j = 0; j < 4; ++j) {
	                if (this._usedSingleCount[j][i] == 0) {
	                    if (this._persistent)
	                        this._usedSingleCount[j][i]++;
	                    return this._registerComponents[j][i];
	                }
	            }
	        }
	        throw new Error("Register overflow!");
	    };
	    /**
	     * Marks a register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
	     * has been called usageCount times again.
	     * @param register The register to mark as used.
	     * @param usageCount The amount of usages to add.
	     */
	    RegisterPool.prototype.addUsage = function (register, usageCount) {
	        if (register._component > -1)
	            this._usedSingleCount[register._component][register.index] += usageCount;
	        else
	            this._usedVectorCount[register.index] += usageCount;
	    };
	    /**
	     * Removes a usage from a register. When usages reach 0, the register is freed again.
	     * @param register The register for which to remove a usage.
	     */
	    RegisterPool.prototype.removeUsage = function (register) {
	        if (register._component > -1) {
	            if (--this._usedSingleCount[register._component][register.index] < 0)
	                throw new Error("More usages removed than exist!");
	        }
	        else {
	            if (--this._usedVectorCount[register.index] < 0)
	                throw new Error("More usages removed than exist!");
	        }
	    };
	    /**
	     * Disposes any resources used by the current RegisterPool object.
	     */
	    RegisterPool.prototype.dispose = function () {
	        this._vectorRegisters = null;
	        this._registerComponents = null;
	        this._usedSingleCount = null;
	        this._usedVectorCount = null;
	    };
	    /**
	     * Indicates whether or not any registers are in use.
	     */
	    RegisterPool.prototype.hasRegisteredRegs = function () {
	        for (var i = 0; i < this._regCount; ++i)
	            if (this.isRegisterUsed(i))
	                return true;
	        return false;
	    };
	    /**
	     * Initializes all registers.
	     */
	    RegisterPool.prototype.initRegisters = function (regName, regCount) {
	        var hash = RegisterPool._initPool(regName, regCount);
	        this._vectorRegisters = RegisterPool._regPool[hash];
	        this._registerComponents = RegisterPool._regCompsPool[hash];
	        this._usedVectorCount = this._initArray(Array(regCount), 0);
	        this._usedSingleCount = new Array(4);
	        this._usedSingleCount[0] = this._initArray(new Array(regCount), 0);
	        this._usedSingleCount[1] = this._initArray(new Array(regCount), 0);
	        this._usedSingleCount[2] = this._initArray(new Array(regCount), 0);
	        this._usedSingleCount[3] = this._initArray(new Array(regCount), 0);
	    };
	    RegisterPool._initPool = function (regName, regCount) {
	        var hash = regName + regCount;
	        if (RegisterPool._regPool[hash] != undefined)
	            return hash;
	        var vectorRegisters = new Array(regCount);
	        RegisterPool._regPool[hash] = vectorRegisters;
	        var registerComponents = [
	            [],
	            [],
	            [],
	            []
	        ];
	        RegisterPool._regCompsPool[hash] = registerComponents;
	        for (var i = 0; i < regCount; ++i) {
	            vectorRegisters[i] = new ShaderRegisterElement_1.ShaderRegisterElement(regName, i);
	            for (var j = 0; j < 4; ++j)
	                registerComponents[j][i] = new ShaderRegisterElement_1.ShaderRegisterElement(regName, i, j);
	        }
	        return hash;
	    };
	    /**
	     * Check if the temp register is either used for single or vector use
	     */
	    RegisterPool.prototype.isRegisterUsed = function (index) {
	        if (this._usedVectorCount[index] > 0)
	            return true;
	        for (var i = 0; i < 4; ++i)
	            if (this._usedSingleCount[i][index] > 0)
	                return true;
	        return false;
	    };
	    RegisterPool.prototype._initArray = function (a, val) {
	        var l = a.length;
	        for (var c = 0; c < l; c++)
	            a[c] = val;
	        return a;
	    };
	    RegisterPool._regPool = new Object();
	    RegisterPool._regCompsPool = new Object();
	    return RegisterPool;
	}());
	exports.RegisterPool = RegisterPool;


/***/ },
/* 275 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A single register element (an entire register or a single register's component) used by the RegisterPool.
	 */
	var ShaderRegisterElement = (function () {
	    /**
	     * Creates a new ShaderRegisterElement object.
	     *
	     * @param regName The name of the register.
	     * @param index The index of the register.
	     * @param component The register's component, if not the entire register is represented.
	     */
	    function ShaderRegisterElement(regName, index, component) {
	        if (component === void 0) { component = -1; }
	        this._component = component;
	        this._regName = regName;
	        this._index = index;
	        this._toStr = this._regName;
	        if (this._index >= 0)
	            this._toStr += this._index;
	        if (component > -1)
	            this._toStr += "." + ShaderRegisterElement.COMPONENTS[component];
	    }
	    /**
	     * Converts the register or the components AGAL string representation.
	     */
	    ShaderRegisterElement.prototype.toString = function () {
	        return this._toStr;
	    };
	    Object.defineProperty(ShaderRegisterElement.prototype, "regName", {
	        /**
	         * The register's name.
	         */
	        get: function () {
	            return this._regName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ShaderRegisterElement.prototype, "index", {
	        /**
	         * The register's index.
	         */
	        get: function () {
	            return this._index;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ShaderRegisterElement.COMPONENTS = ["x", "y", "z", "w"];
	    return ShaderRegisterElement;
	}());
	exports.ShaderRegisterElement = ShaderRegisterElement;


/***/ },
/* 276 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * ShaderRegisterData contains the "named" registers, generated by the compiler and to be passed on to the methods.
	 */
	var ShaderRegisterData = (function () {
	    function ShaderRegisterData() {
	        this.textures = new Array();
	        this.animatableAttributes = new Array();
	        this.animationTargetRegisters = new Array();
	    }
	    return ShaderRegisterData;
	}());
	exports.ShaderRegisterData = ShaderRegisterData;


/***/ },
/* 277 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var CompilerBase_1 = __webpack_require__(272);
	/**
	 * CompilerBase is an abstract base class for shader compilers that use modular shader methods to assemble a
	 * material. Concrete subclasses are used by the default materials.
	 *
	 * @see away.materials.ShadingMethodBase
	 */
	var LightingCompiler = (function (_super) {
	    __extends(LightingCompiler, _super);
	    /**
	     * Creates a new CompilerBase object.
	     * @param profile The compatibility profile of the renderer.
	     */
	    function LightingCompiler(elementsClass, lightingPass, shaderLightingObject) {
	        _super.call(this, elementsClass, lightingPass, shaderLightingObject);
	        this._shaderLightingObject = shaderLightingObject;
	        this._lightingPass = lightingPass;
	    }
	    /**
	     * Compile the code for the methods.
	     */
	    LightingCompiler.prototype.pCompileDependencies = function () {
	        _super.prototype.pCompileDependencies.call(this);
	        //compile the lighting code
	        if (this._shaderLightingObject.usesShadows)
	            this.pCompileShadowCode();
	        if (this._shaderLightingObject.usesLights) {
	            this.initLightRegisters();
	            this.compileLightCode();
	        }
	        if (this._shaderLightingObject.usesProbes)
	            this.compileLightProbeCode();
	        this._pVertexCode += this._lightingPass._iGetPostLightingVertexCode(this._shaderLightingObject, this._pRegisterCache, this._pSharedRegisters);
	        this._pFragmentCode += this._lightingPass._iGetPostLightingFragmentCode(this._shaderLightingObject, this._pRegisterCache, this._pSharedRegisters);
	    };
	    /**
	     * Provides the code to provide shadow mapping.
	     */
	    LightingCompiler.prototype.pCompileShadowCode = function () {
	        if (this._shaderLightingObject.normalDependencies > 0) {
	            this._pSharedRegisters.shadowTarget = this._pSharedRegisters.normalFragment;
	        }
	        else {
	            this._pSharedRegisters.shadowTarget = this._pRegisterCache.getFreeFragmentVectorTemp();
	            this._pRegisterCache.addFragmentTempUsages(this._pSharedRegisters.shadowTarget, 1);
	        }
	    };
	    /**
	     * Initializes constant registers to contain light data.
	     */
	    LightingCompiler.prototype.initLightRegisters = function () {
	        // init these first so we're sure they're in sequence
	        var i, len;
	        if (this._dirLightVertexConstants) {
	            len = this._dirLightVertexConstants.length;
	            for (i = 0; i < len; ++i) {
	                this._dirLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();
	                if (this._shaderLightingObject.lightVertexConstantIndex == -1)
	                    this._shaderLightingObject.lightVertexConstantIndex = this._dirLightVertexConstants[i].index * 4;
	            }
	        }
	        if (this._pointLightVertexConstants) {
	            len = this._pointLightVertexConstants.length;
	            for (i = 0; i < len; ++i) {
	                this._pointLightVertexConstants[i] = this._pRegisterCache.getFreeVertexConstant();
	                if (this._shaderLightingObject.lightVertexConstantIndex == -1)
	                    this._shaderLightingObject.lightVertexConstantIndex = this._pointLightVertexConstants[i].index * 4;
	            }
	        }
	        len = this._dirLightFragmentConstants.length;
	        for (i = 0; i < len; ++i) {
	            this._dirLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();
	            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
	                this._shaderLightingObject.lightFragmentConstantIndex = this._dirLightFragmentConstants[i].index * 4;
	        }
	        len = this._pointLightFragmentConstants.length;
	        for (i = 0; i < len; ++i) {
	            this._pointLightFragmentConstants[i] = this._pRegisterCache.getFreeFragmentConstant();
	            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
	                this._shaderLightingObject.lightFragmentConstantIndex = this._pointLightFragmentConstants[i].index * 4;
	        }
	    };
	    /**
	     * Compiles the shading code for directional and point lights.
	     */
	    LightingCompiler.prototype.compileLightCode = function () {
	        var diffuseColorReg;
	        var specularColorReg;
	        var lightPosReg;
	        var lightDirReg;
	        var vertexRegIndex = 0;
	        var fragmentRegIndex = 0;
	        var addSpec = this._shaderLightingObject.usesLightsForSpecular;
	        var addDiff = this._shaderLightingObject.usesLightsForDiffuse;
	        //compile the shading code for directional lights.
	        for (var i = 0; i < this._shaderLightingObject.numDirectionalLights; ++i) {
	            if (this._shaderLightingObject.usesTangentSpace) {
	                lightDirReg = this._dirLightVertexConstants[vertexRegIndex++];
	                var lightVarying = this._pRegisterCache.getFreeVarying();
	                this._pVertexCode += "m33 " + lightVarying + ".xyz, " + lightDirReg + ", " + this._pSharedRegisters.animatedTangent + "\n" +
	                    "mov " + lightVarying + ".w, " + lightDirReg + ".w\n";
	                lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
	                this._pRegisterCache.addVertexTempUsages(lightDirReg, 1);
	                this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" +
	                    "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
	            }
	            else {
	                lightDirReg = this._dirLightFragmentConstants[fragmentRegIndex++];
	            }
	            diffuseColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
	            specularColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
	            if (addDiff)
	                this._pFragmentCode += this._lightingPass._iGetPerLightDiffuseFragmentCode(this._shaderLightingObject, lightDirReg, diffuseColorReg, this._pRegisterCache, this._pSharedRegisters);
	            if (addSpec)
	                this._pFragmentCode += this._lightingPass._iGetPerLightSpecularFragmentCode(this._shaderLightingObject, lightDirReg, specularColorReg, this._pRegisterCache, this._pSharedRegisters);
	            if (this._shaderLightingObject.usesTangentSpace)
	                this._pRegisterCache.removeVertexTempUsage(lightDirReg);
	        }
	        vertexRegIndex = 0;
	        fragmentRegIndex = 0;
	        //compile the shading code for point lights
	        for (var i = 0; i < this._shaderLightingObject.numPointLights; ++i) {
	            if (this._shaderLightingObject.usesTangentSpace || !this._shaderLightingObject.usesGlobalPosFragment)
	                lightPosReg = this._pointLightVertexConstants[vertexRegIndex++];
	            else
	                lightPosReg = this._pointLightFragmentConstants[fragmentRegIndex++];
	            diffuseColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
	            specularColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
	            lightDirReg = this._pRegisterCache.getFreeFragmentVectorTemp();
	            this._pRegisterCache.addFragmentTempUsages(lightDirReg, 1);
	            var lightVarying;
	            if (this._shaderLightingObject.usesTangentSpace) {
	                lightVarying = this._pRegisterCache.getFreeVarying();
	                var temp = this._pRegisterCache.getFreeVertexVectorTemp();
	                this._pVertexCode += "sub " + temp + ", " + lightPosReg + ", " + this._pSharedRegisters.animatedPosition + "\n" +
	                    "m33 " + lightVarying + ".xyz, " + temp + ", " + this._pSharedRegisters.animatedTangent + "\n" +
	                    "mov " + lightVarying + ".w, " + this._pSharedRegisters.animatedPosition + ".w\n";
	            }
	            else if (!this._shaderLightingObject.usesGlobalPosFragment) {
	                lightVarying = this._pRegisterCache.getFreeVarying();
	                this._pVertexCode += "sub " + lightVarying + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVertex + "\n";
	            }
	            else {
	                lightVarying = lightDirReg;
	                this._pFragmentCode += "sub " + lightDirReg + ", " + lightPosReg + ", " + this._pSharedRegisters.globalPositionVarying + "\n";
	            }
	            if (this._shaderLightingObject.usesLightFallOff) {
	                // calculate attenuation
	                this._pFragmentCode +=
	                    "dp3 " + lightDirReg + ".w, " + lightVarying + ", " + lightVarying + "\n" +
	                        "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" +
	                        "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" +
	                        "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" +
	                        "sub " + lightDirReg + ".w, " + this._pSharedRegisters.commons + ".w, " + lightDirReg + ".w\n" +
	                        "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
	            }
	            else {
	                this._pFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" +
	                    "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
	            }
	            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
	                this._shaderLightingObject.lightFragmentConstantIndex = lightPosReg.index * 4;
	            if (addDiff)
	                this._pFragmentCode += this._lightingPass._iGetPerLightDiffuseFragmentCode(this._shaderLightingObject, lightDirReg, diffuseColorReg, this._pRegisterCache, this._pSharedRegisters);
	            if (addSpec)
	                this._pFragmentCode += this._lightingPass._iGetPerLightSpecularFragmentCode(this._shaderLightingObject, lightDirReg, specularColorReg, this._pRegisterCache, this._pSharedRegisters);
	            this._pRegisterCache.removeFragmentTempUsage(lightDirReg);
	        }
	    };
	    /**
	     * Compiles shading code for light probes.
	     */
	    LightingCompiler.prototype.compileLightProbeCode = function () {
	        var weightReg;
	        var weightComponents = [".x", ".y", ".z", ".w"];
	        var weightRegisters = new Array();
	        var i;
	        var texReg;
	        var addSpec = this._shaderLightingObject.usesProbesForSpecular;
	        var addDiff = this._shaderLightingObject.usesProbesForDiffuse;
	        if (addDiff)
	            this._shaderLightingObject.lightProbeDiffuseIndices = new Array();
	        if (addSpec)
	            this._shaderLightingObject.lightProbeSpecularIndices = new Array();
	        for (i = 0; i < this._pNumProbeRegisters; ++i) {
	            weightRegisters[i] = this._pRegisterCache.getFreeFragmentConstant();
	            if (i == 0)
	                this._shaderLightingObject.probeWeightsIndex = weightRegisters[i].index * 4;
	        }
	        for (i = 0; i < this._shaderLightingObject.numLightProbes; ++i) {
	            weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];
	            if (addDiff) {
	                texReg = this._pRegisterCache.getFreeTextureReg();
	                this._shaderLightingObject.lightProbeDiffuseIndices[i] = texReg.index;
	                this._pFragmentCode += this._lightingPass._iGetPerProbeDiffuseFragmentCode(this._shaderLightingObject, texReg, weightReg, this._pRegisterCache, this._pSharedRegisters);
	            }
	            if (addSpec) {
	                texReg = this._pRegisterCache.getFreeTextureReg();
	                this._shaderLightingObject.lightProbeSpecularIndices[i] = texReg.index;
	                this._pFragmentCode += this._lightingPass._iGetPerProbeSpecularFragmentCode(this._shaderLightingObject, texReg, weightReg, this._pRegisterCache, this._pSharedRegisters);
	            }
	        }
	    };
	    /**
	     * Reset all the indices to "unused".
	     */
	    LightingCompiler.prototype.pInitRegisterIndices = function () {
	        _super.prototype.pInitRegisterIndices.call(this);
	        this._shaderLightingObject.lightVertexConstantIndex = -1;
	        this._shaderLightingObject.lightFragmentConstantIndex = -1;
	        this._shaderLightingObject.probeWeightsIndex = -1;
	        this._pNumProbeRegisters = Math.ceil(this._shaderLightingObject.numLightProbes / 4);
	        //init light data
	        if (this._shaderLightingObject.usesTangentSpace || !this._shaderLightingObject.usesGlobalPosFragment) {
	            this._pointLightVertexConstants = new Array(this._shaderLightingObject.numPointLights);
	            this._pointLightFragmentConstants = new Array(this._shaderLightingObject.numPointLights * 2);
	        }
	        else {
	            this._pointLightFragmentConstants = new Array(this._shaderLightingObject.numPointLights * 3);
	        }
	        if (this._shaderLightingObject.usesTangentSpace) {
	            this._dirLightVertexConstants = new Array(this._shaderLightingObject.numDirectionalLights);
	            this._dirLightFragmentConstants = new Array(this._shaderLightingObject.numDirectionalLights * 2);
	        }
	        else {
	            this._dirLightFragmentConstants = new Array(this._shaderLightingObject.numDirectionalLights * 3);
	        }
	    };
	    return LightingCompiler;
	}(CompilerBase_1.CompilerBase));
	exports.LightingCompiler = LightingCompiler;


/***/ },
/* 278 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(11);
	var PassEvent_1 = __webpack_require__(279);
	/**
	 * PassBase provides an abstract base class for material shader passes. A material pass constitutes at least
	 * a render call per required renderable.
	 */
	var PassBase = (function (_super) {
	    __extends(PassBase, _super);
	    /**
	     * Creates a new PassBase object.
	     */
	    function PassBase(render, surface, elementsClass, stage) {
	        _super.call(this);
	        this._preserveAlpha = true;
	        this._forceSeparateMVP = false;
	        this._render = render;
	        this._surface = surface;
	        this._elementsClass = elementsClass;
	        this._stage = stage;
	    }
	    Object.defineProperty(PassBase.prototype, "shader", {
	        get: function () {
	            return this._shader;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PassBase.prototype, "animationSet", {
	        get: function () {
	            return this._surface.animationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PassBase.prototype, "preserveAlpha", {
	        /**
	         * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
	         */
	        get: function () {
	            return this._preserveAlpha;
	        },
	        set: function (value) {
	            if (this._preserveAlpha == value)
	                return;
	            this._preserveAlpha = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PassBase.prototype, "forceSeparateMVP", {
	        /**
	         * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
	         * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
	         * projection code.
	         */
	        get: function () {
	            return this._forceSeparateMVP;
	        },
	        set: function (value) {
	            if (this._forceSeparateMVP == value)
	                return;
	            this._forceSeparateMVP = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PassBase.prototype.getImageIndex = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        return this._render.getImageIndex(texture, index);
	    };
	    /**
	     * Marks the shader program as invalid, so it will be recompiled before the next render.
	     */
	    PassBase.prototype.invalidate = function () {
	        this._shader.invalidateProgram();
	        this.dispatchEvent(new PassEvent_1.PassEvent(PassEvent_1.PassEvent.INVALIDATE, this));
	    };
	    /**
	     * Cleans up any resources used by the current object.
	     * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
	     */
	    PassBase.prototype.dispose = function () {
	        this._render = null;
	        this._surface = null;
	        this._elementsClass = null;
	        this._stage = null;
	        if (this._shader) {
	            this._shader.dispose();
	            this._shader = null;
	        }
	    };
	    /**
	     * Renders the current pass. Before calling pass, activatePass needs to be called with the same index.
	     * @param pass The pass used to render the renderable.
	     * @param renderable The IRenderable object to draw.
	     * @param stage The Stage object used for rendering.
	     * @param entityCollector The EntityCollector object that contains the visible scene data.
	     * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
	     * camera.viewProjection as it includes the scaling factors when rendering to textures.
	     *
	     * @internal
	     */
	    PassBase.prototype._setRenderState = function (renderable, camera, viewProjection) {
	        this._shader._setRenderState(renderable, camera, viewProjection);
	    };
	    /**
	     * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
	     * calling pass. Before activating a pass, the previously used pass needs to be deactivated.
	     * @param stage The Stage object which is currently used for rendering.
	     * @param camera The camera from which the scene is viewed.
	     * @private
	     */
	    PassBase.prototype._iActivate = function (camera) {
	        this._shader._iActivate(camera);
	    };
	    /**
	     * Clears the render state for the pass. This needs to be called before activating another pass.
	     * @param stage The Stage used for rendering
	     *
	     * @private
	     */
	    PassBase.prototype._iDeactivate = function () {
	        this._shader._iDeactivate();
	    };
	    PassBase.prototype._iIncludeDependencies = function (shader) {
	        this._render._iIncludeDependencies(shader);
	        if (this._forceSeparateMVP)
	            shader.globalPosDependencies++;
	    };
	    PassBase.prototype._iInitConstantData = function (shader) {
	    };
	    PassBase.prototype._iGetPreLightingVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    PassBase.prototype._iGetPreLightingFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    PassBase.prototype._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    PassBase.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    PassBase.prototype._iGetNormalVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    PassBase.prototype._iGetNormalFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    return PassBase;
	}(EventDispatcher_1.EventDispatcher));
	exports.PassBase = PassBase;


/***/ },
/* 279 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var PassEvent = (function (_super) {
	    __extends(PassEvent, _super);
	    function PassEvent(type, pass) {
	        _super.call(this, type);
	        this._pass = pass;
	    }
	    Object.defineProperty(PassEvent.prototype, "pass", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pass;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    PassEvent.prototype.clone = function () {
	        return new PassEvent(this.type, this._pass);
	    };
	    /**
	     *
	     */
	    PassEvent.INVALIDATE = "invalidatePass";
	    return PassEvent;
	}(EventBase_1.EventBase));
	exports.PassEvent = PassEvent;


/***/ },
/* 280 */
/***/ function(module, exports) {

	"use strict";
	var MethodPassMode = (function () {
	    function MethodPassMode() {
	    }
	    /**
	     *
	     */
	    MethodPassMode.EFFECTS = 0x01;
	    /**
	     *
	     */
	    MethodPassMode.LIGHTING = 0x02;
	    /**
	     *
	     */
	    MethodPassMode.SUPER_SHADER = 0x03;
	    return MethodPassMode;
	}());
	exports.MethodPassMode = MethodPassMode;


/***/ },
/* 281 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(96);
	var Matrix3D_1 = __webpack_require__(32);
	var Single2DTexture_1 = __webpack_require__(136);
	var PassBase_1 = __webpack_require__(278);
	/**
	 * The SingleObjectDepthPass provides a material pass that renders a single object to a depth map from the point
	 * of view from a light.
	 */
	var SingleObjectDepthPass = (function (_super) {
	    __extends(SingleObjectDepthPass, _super);
	    /**
	     * Creates a new SingleObjectDepthPass object.
	     */
	    function SingleObjectDepthPass(render, renderOwner, elementsClass, stage) {
	        _super.call(this, render, renderOwner, elementsClass, stage);
	        this._textureSize = 512;
	        this._polyOffset = new Float32Array([15, 0, 0, 0]);
	        this._projectionTexturesInvalid = true;
	        //this._pNumUsedStreams = 2;
	        //this._pNumUsedVertexConstants = 7;
	        //this._enc = Array<number>(1.0, 255.0, 65025.0, 16581375.0, 1.0/255.0, 1.0/255.0, 1.0/255.0, 0.0);
	        //
	        //this._pAnimatableAttributes = Array<string>("va0", "va1";
	        //this._pAnimationTargetRegisters = Array<string>("vt0", "vt1";
	    }
	    Object.defineProperty(SingleObjectDepthPass.prototype, "textureSize", {
	        /**
	         * The size of the depth map texture to render to.
	         */
	        get: function () {
	            return this._textureSize;
	        },
	        set: function (value) {
	            this._textureSize = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SingleObjectDepthPass.prototype, "polyOffset", {
	        /**
	         * The amount by which the rendered object will be inflated, to prevent depth map rounding errors.
	         */
	        get: function () {
	            return this._polyOffset[0];
	        },
	        set: function (value) {
	            this._polyOffset[0] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SingleObjectDepthPass.prototype.dispose = function () {
	        if (this._textures) {
	            for (var key in this._textures) {
	                var texture = this._textures[key];
	                texture.dispose();
	            }
	            this._textures = null;
	        }
	    };
	    /**
	     * Updates the projection textures used to contain the depth renders.
	     */
	    SingleObjectDepthPass.prototype.updateProjectionTextures = function () {
	        if (this._textures) {
	            for (var key in this._textures) {
	                var texture = this._textures[key];
	                texture.dispose();
	            }
	        }
	        this._textures = new Object();
	        this._projections = new Object();
	        this._projectionTexturesInvalid = false;
	    };
	    /**
	     * @inheritDoc
	     */
	    SingleObjectDepthPass.prototype._iGetVertexCode = function () {
	        var code;
	        // offset
	        code = "mul vt7, vt1, vc4.x	\n" +
	            "add vt7, vt7, vt0\n" +
	            "mov vt7.w, vt0.w\n";
	        // project
	        code += "m44 vt2, vt7, vc0\n" +
	            "mov op, vt2\n";
	        // perspective divide
	        code += "div v0, vt2, vt2.w\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SingleObjectDepthPass.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        // encode float -> rgba
	        code += "mul ft0, fc0, v0.z\n" +
	            "frc ft0, ft0\n" +
	            "mul ft1, ft0.yzww, fc1\n" +
	            "sub ft0, ft0, ft1\n" +
	            "mov oc, ft0\n";
	        return code;
	    };
	    /**
	     * Gets the depth maps rendered for this object from all lights.
	     * @param renderableGL The renderableGL for which to retrieve the depth maps.
	     * @param stage3DProxy The Stage3DProxy object currently used for rendering.
	     * @return A list of depth map textures for all supported lights.
	     */
	    SingleObjectDepthPass.prototype._iGetDepthMap = function (renderableGL) {
	        return this._textures[renderableGL.renderable.id];
	    };
	    /**
	     * Retrieves the depth map projection maps for all lights.
	     * @param renderableGL The renderableGL for which to retrieve the projection maps.
	     * @return A list of projection maps for all supported lights.
	     */
	    SingleObjectDepthPass.prototype._iGetProjection = function (renderableGL) {
	        return this._projections[renderableGL.renderable.id];
	    };
	    /**
	     * @inheritDoc
	     */
	    SingleObjectDepthPass.prototype._iRender = function (renderableGL, camera, viewProjection) {
	        var matrix;
	        var context = this._stage.context;
	        var len;
	        var light;
	        var lights = this._surface.lightPicker.allPickedLights;
	        var rId = renderableGL.renderable.id;
	        if (!this._textures[rId])
	            this._textures[rId] = new Single2DTexture_1.Single2DTexture(new Image2D_1.Image2D(this._textureSize, this._textureSize));
	        if (!this._projections[rId])
	            this._projections[rId] = new Matrix3D_1.Matrix3D();
	        len = lights.length;
	        // local position = enough
	        light = lights[0];
	        matrix = light.iGetObjectProjectionMatrix(renderableGL.sourceEntity, camera.sceneTransform, this._projections[rId]);
	        this._stage.setRenderTarget(this._textures[rId], true);
	        context.clear(1.0, 1.0, 1.0);
	        //context.setProgramConstantsFromMatrix(ContextGLProgramType.VERTEX, 0, matrix, true);
	        //context.setProgramConstantsFromArray(ContextGLProgramType.FRAGMENT, 0, this._enc, 2);
	        var elementsGL = renderableGL.elementsGL;
	        // elementsGL.activateVertexBufferVO(0, elements.positions);
	        // elementsGL.activateVertexBufferVO(1, elements.normals);
	        // elementsGL.getIndexBufferGL().draw(ContextGLDrawMode.TRIANGLES, 0, elements.numElements);
	    };
	    /**
	     * @inheritDoc
	     */
	    SingleObjectDepthPass.prototype._iActivate = function (camera) {
	        if (this._projectionTexturesInvalid)
	            this.updateProjectionTextures();
	        // never scale
	        _super.prototype._iActivate.call(this, camera);
	        //this._stage.context.setProgramConstantsFromArray(ContextGLProgramType.VERTEX, 4, this._polyOffset, 1);
	    };
	    return SingleObjectDepthPass;
	}(PassBase_1.PassBase));
	exports.SingleObjectDepthPass = SingleObjectDepthPass;


/***/ },
/* 282 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BlendMode_1 = __webpack_require__(131);
	var StaticLightPicker_1 = __webpack_require__(218);
	var ContextGLCompareMode_1 = __webpack_require__(43);
	var GL_SurfaceBase_1 = __webpack_require__(283);
	var MethodMaterialMode_1 = __webpack_require__(284);
	var MethodPassMode_1 = __webpack_require__(280);
	var MethodPass_1 = __webpack_require__(269);
	/**
	 * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
	 * using material methods to define their appearance.
	 */
	var GL_MethodMaterialSurface = (function (_super) {
	    __extends(GL_MethodMaterialSurface, _super);
	    /**
	     * Creates a new CompiledPass object.
	     *
	     * @param material The material to which this pass belongs.
	     */
	    function GL_MethodMaterialSurface(material, elementsClass, pool) {
	        _super.call(this, material, elementsClass, pool);
	        this._material = material;
	    }
	    Object.defineProperty(GL_MethodMaterialSurface.prototype, "numLights", {
	        /**
	         * The maximum total number of lights provided by the light picker.
	         */
	        get: function () {
	            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights + this._material.lightPicker.numCastingDirectionalLights + this._material.lightPicker.numCastingPointLights : 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_MethodMaterialSurface.prototype, "numNonCasters", {
	        /**
	         * The amount of lights that don't cast shadows.
	         */
	        get: function () {
	            return this._material.lightPicker ? this._material.lightPicker.numLightProbes + this._material.lightPicker.numDirectionalLights + this._material.lightPicker.numPointLights : 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    GL_MethodMaterialSurface.prototype._pUpdateRender = function () {
	        _super.prototype._pUpdateRender.call(this);
	        this.initPasses();
	        this.setBlendAndCompareModes();
	        this._pClearPasses();
	        if (this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS) {
	            if (this._casterLightPass)
	                this._pAddPass(this._casterLightPass);
	            if (this._nonCasterLightPasses)
	                for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
	                    this._pAddPass(this._nonCasterLightPasses[i]);
	        }
	        if (this._pass)
	            this._pAddPass(this._pass);
	    };
	    /**
	     * Initializes all the passes and their dependent passes.
	     */
	    GL_MethodMaterialSurface.prototype.initPasses = function () {
	        // let the effects pass handle everything if there are no lights, when there are effect methods applied
	        // after shading, or when the material mode is single pass.
	        if (this.numLights == 0 || this._material.numEffectMethods > 0 || this._material.mode == MethodMaterialMode_1.MethodMaterialMode.SINGLE_PASS)
	            this.initEffectPass();
	        else if (this._pass)
	            this.removeEffectPass();
	        // only use a caster light pass if shadows need to be rendered
	        if (this._material.shadowMethod && this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS)
	            this.initCasterLightPass();
	        else if (this._casterLightPass)
	            this.removeCasterLightPass();
	        // only use non caster light passes if there are lights that don't cast
	        if (this.numNonCasters > 0 && this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS)
	            this.initNonCasterLightPasses();
	        else if (this._nonCasterLightPasses)
	            this.removeNonCasterLightPasses();
	    };
	    /**
	     * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.
	     */
	    GL_MethodMaterialSurface.prototype.setBlendAndCompareModes = function () {
	        var forceSeparateMVP = Boolean(this._casterLightPass || this._pass);
	        // caster light pass is always first if it exists, hence it uses normal blending
	        if (this._casterLightPass) {
	            this._casterLightPass.forceSeparateMVP = forceSeparateMVP;
	            this._casterLightPass.shader.setBlendMode(BlendMode_1.BlendMode.NORMAL);
	            this._casterLightPass.shader.depthCompareMode = this._material.depthCompareMode;
	        }
	        if (this._nonCasterLightPasses) {
	            var firstAdditiveIndex = 0;
	            // if there's no caster light pass, the first non caster light pass will be the first
	            // and should use normal blending
	            if (!this._casterLightPass) {
	                this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;
	                this._nonCasterLightPasses[0].shader.setBlendMode(BlendMode_1.BlendMode.NORMAL);
	                this._nonCasterLightPasses[0].shader.depthCompareMode = this._material.depthCompareMode;
	                firstAdditiveIndex = 1;
	            }
	            // all lighting passes following the first light pass should use additive blending
	            for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {
	                this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;
	                this._nonCasterLightPasses[i].shader.setBlendMode(BlendMode_1.BlendMode.ADD);
	                this._nonCasterLightPasses[i].shader.depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL;
	            }
	        }
	        if (this._casterLightPass || this._nonCasterLightPasses) {
	            //cannot be blended by blendmode property if multipass enabled
	            this._pRequiresBlending = false;
	            // there are light passes, so this should be blended in
	            if (this._pass) {
	                this._pass.mode = MethodPassMode_1.MethodPassMode.EFFECTS;
	                this._pass.forceSeparateMVP = forceSeparateMVP;
	                this._pass.shader.depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL;
	                this._pass.shader.setBlendMode(BlendMode_1.BlendMode.LAYER);
	            }
	        }
	        else if (this._pass) {
	            this._pRequiresBlending = (this._material.blendMode != BlendMode_1.BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));
	            // effects pass is the only pass, so it should just blend normally
	            this._pass.mode = MethodPassMode_1.MethodPassMode.SUPER_SHADER;
	            this._pass.preserveAlpha = this._pRequiresBlending;
	            this._pass.forceSeparateMVP = false;
	            this._pass.colorTransform = this._material.colorTransform;
	            this._pass.shader.setBlendMode((this._material.blendMode == BlendMode_1.BlendMode.NORMAL && this._pRequiresBlending) ? BlendMode_1.BlendMode.LAYER : this._material.blendMode);
	            this._pass.shader.depthCompareMode = this._material.depthCompareMode;
	        }
	    };
	    GL_MethodMaterialSurface.prototype.initCasterLightPass = function () {
	        if (this._casterLightPass == null)
	            this._casterLightPass = new MethodPass_1.MethodPass(MethodPassMode_1.MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);
	        this._casterLightPass.lightPicker = new StaticLightPicker_1.StaticLightPicker([this._material.shadowMethod.castingLight]);
	        this._casterLightPass.shadowMethod = this._material.shadowMethod;
	        this._casterLightPass.diffuseMethod = this._material.diffuseMethod;
	        this._casterLightPass.ambientMethod = this._material.ambientMethod;
	        this._casterLightPass.normalMethod = this._material.normalMethod;
	        this._casterLightPass.specularMethod = this._material.specularMethod;
	    };
	    GL_MethodMaterialSurface.prototype.removeCasterLightPass = function () {
	        this._casterLightPass.dispose();
	        this._pRemovePass(this._casterLightPass);
	        this._casterLightPass = null;
	    };
	    GL_MethodMaterialSurface.prototype.initNonCasterLightPasses = function () {
	        this.removeNonCasterLightPasses();
	        var pass;
	        var numDirLights = this._material.lightPicker.numDirectionalLights;
	        var numPointLights = this._material.lightPicker.numPointLights;
	        var numLightProbes = this._material.lightPicker.numLightProbes;
	        var dirLightOffset = 0;
	        var pointLightOffset = 0;
	        var probeOffset = 0;
	        if (!this._casterLightPass) {
	            numDirLights += this._material.lightPicker.numCastingDirectionalLights;
	            numPointLights += this._material.lightPicker.numCastingPointLights;
	        }
	        this._nonCasterLightPasses = new Array();
	        while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {
	            pass = new MethodPass_1.MethodPass(MethodPassMode_1.MethodPassMode.LIGHTING, this, this._material, this._elementsClass, this._stage);
	            pass.includeCasters = this._material.shadowMethod == null;
	            pass.directionalLightsOffset = dirLightOffset;
	            pass.pointLightsOffset = pointLightOffset;
	            pass.lightProbesOffset = probeOffset;
	            pass.lightPicker = this._material.lightPicker;
	            pass.diffuseMethod = this._material.diffuseMethod;
	            pass.ambientMethod = this._material.ambientMethod;
	            pass.normalMethod = this._material.normalMethod;
	            pass.specularMethod = this._material.specularMethod;
	            this._nonCasterLightPasses.push(pass);
	            dirLightOffset += pass.numDirectionalLights;
	            pointLightOffset += pass.numPointLights;
	            probeOffset += pass.numLightProbes;
	        }
	    };
	    GL_MethodMaterialSurface.prototype.removeNonCasterLightPasses = function () {
	        if (!this._nonCasterLightPasses)
	            return;
	        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
	            this._pRemovePass(this._nonCasterLightPasses[i]);
	        this._nonCasterLightPasses = null;
	    };
	    GL_MethodMaterialSurface.prototype.removeEffectPass = function () {
	        if (this._pass.ambientMethod != this._material.ambientMethod)
	            this._pass.ambientMethod.dispose();
	        if (this._pass.diffuseMethod != this._material.diffuseMethod)
	            this._pass.diffuseMethod.dispose();
	        if (this._pass.specularMethod != this._material.specularMethod)
	            this._pass.specularMethod.dispose();
	        if (this._pass.normalMethod != this._material.normalMethod)
	            this._pass.normalMethod.dispose();
	        this._pRemovePass(this._pass);
	        this._pass = null;
	    };
	    GL_MethodMaterialSurface.prototype.initEffectPass = function () {
	        if (this._pass == null)
	            this._pass = new MethodPass_1.MethodPass(MethodPassMode_1.MethodPassMode.SUPER_SHADER, this, this._material, this._elementsClass, this._stage);
	        if (this._material.mode == MethodMaterialMode_1.MethodMaterialMode.SINGLE_PASS) {
	            this._pass.ambientMethod = this._material.ambientMethod;
	            this._pass.diffuseMethod = this._material.diffuseMethod;
	            this._pass.specularMethod = this._material.specularMethod;
	            this._pass.normalMethod = this._material.normalMethod;
	            this._pass.shadowMethod = this._material.shadowMethod;
	        }
	        else if (this._material.mode == MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS) {
	            if (this.numLights == 0) {
	                this._pass.ambientMethod = this._material.ambientMethod;
	            }
	            else {
	                this._pass.ambientMethod = null;
	            }
	            this._pass.preserveAlpha = false;
	            this._pass.normalMethod = this._material.normalMethod;
	        }
	        //update effect methods
	        var i = 0;
	        var effectMethod;
	        var len = Math.max(this._material.numEffectMethods, this._pass.numEffectMethods);
	        while (i < len) {
	            effectMethod = this._material.getEffectMethodAt(i);
	            if (effectMethod != this._pass.getEffectMethodAt(i)) {
	                this._pass.removeEffectMethodAt(i);
	                if (effectMethod != null) {
	                    if (i < this._pass.numEffectMethods)
	                        this._pass.addEffectMethodAt(effectMethod, i);
	                    else
	                        this._pass.addEffectMethod(effectMethod);
	                }
	            }
	            i++;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_MethodMaterialSurface.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        //TODO
	    };
	    return GL_MethodMaterialSurface;
	}(GL_SurfaceBase_1.GL_SurfaceBase));
	exports.GL_MethodMaterialSurface = GL_MethodMaterialSurface;


/***/ },
/* 283 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractionBase_1 = __webpack_require__(210);
	var SurfaceEvent_1 = __webpack_require__(119);
	var MaterialBase_1 = __webpack_require__(135);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var PassEvent_1 = __webpack_require__(279);
	/**
	 *
	 * @class away.pool.Passes
	 */
	var GL_SurfaceBase = (function (_super) {
	    __extends(GL_SurfaceBase, _super);
	    function GL_SurfaceBase(surface, elementsClass, renderPool) {
	        var _this = this;
	        _super.call(this, surface, renderPool);
	        this.usages = 0;
	        this._forceSeparateMVP = false;
	        this._usesAnimation = true;
	        this._invalidAnimation = true;
	        this._invalidRender = true;
	        this._invalidImages = true;
	        this._passes = new Array();
	        this._imageIndices = new Object();
	        this._pRequiresBlending = false;
	        this.images = new Array();
	        this.samplers = new Array();
	        this._onInvalidateAnimationDelegate = function (event) { return _this.onInvalidateAnimation(event); };
	        this._onInvalidatePassesDelegate = function (event) { return _this.onInvalidatePasses(event); };
	        this.surfaceID = surface.id;
	        this._surface = surface;
	        this._elementsClass = elementsClass;
	        this._stage = renderPool.stage;
	        this._surface.addEventListener(SurfaceEvent_1.SurfaceEvent.INVALIDATE_ANIMATION, this._onInvalidateAnimationDelegate);
	        this._surface.addEventListener(SurfaceEvent_1.SurfaceEvent.INVALIDATE_PASSES, this._onInvalidatePassesDelegate);
	        this._onPassInvalidateDelegate = function (event) { return _this.onPassInvalidate(event); };
	    }
	    Object.defineProperty(GL_SurfaceBase.prototype, "requiresBlending", {
	        /**
	         * Indicates whether or not the renderable requires alpha blending during rendering.
	         */
	        get: function () {
	            return this._pRequiresBlending;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "renderOrderId", {
	        get: function () {
	            if (this._invalidAnimation)
	                this._updateAnimation();
	            return this._renderOrderId;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "passes", {
	        get: function () {
	            if (this._invalidAnimation)
	                this._updateAnimation();
	            return this._passes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "surface", {
	        get: function () {
	            return this._surface;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfaceBase.prototype, "numImages", {
	        get: function () {
	            if (this._invalidImages)
	                this._updateImages();
	            return this._numImages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GL_SurfaceBase.prototype._iIncludeDependencies = function (shader) {
	        this._elementsClass._iIncludeDependencies(shader);
	        shader.alphaThreshold = this._surface.alphaThreshold;
	        shader.useImageRect = this._surface.imageRect;
	        shader.usesCurves = this._surface.curves;
	        if (this._surface instanceof MaterialBase_1.MaterialBase) {
	            var material = this._surface;
	            shader.useAlphaPremultiplied = material.alphaPremultiplied;
	            shader.useBothSides = material.bothSides;
	            shader.usesUVTransform = material.animateUVs;
	            shader.usesColorTransform = material.useColorTransform;
	        }
	    };
	    GL_SurfaceBase.prototype.getImageIndex = function (texture, index) {
	        if (index === void 0) { index = 0; }
	        if (this._invalidImages)
	            this._updateImages();
	        return this._imageIndices[texture.id][index];
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._surface = null;
	        this._elementsClass = null;
	        this._stage = null;
	        var len = this._passes.length;
	        for (var i = 0; i < len; i++) {
	            this._passes[i].removeEventListener(PassEvent_1.PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
	            this._passes[i].dispose();
	        }
	        this._passes = null;
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onInvalidate = function (event) {
	        _super.prototype.onInvalidate.call(this, event);
	        this._invalidRender = true;
	        this._invalidAnimation = true;
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onInvalidatePasses = function (event) {
	        var len = this._passes.length;
	        for (var i = 0; i < len; i++)
	            this._passes[i].invalidate();
	        this._invalidAnimation = true;
	        this._invalidImages = true;
	    };
	    /**
	     *
	     */
	    GL_SurfaceBase.prototype.onInvalidateAnimation = function (event) {
	        this._invalidAnimation = true;
	    };
	    /**
	     *
	     * @param surface
	     */
	    GL_SurfaceBase.prototype._updateAnimation = function () {
	        if (this._invalidRender)
	            this._pUpdateRender();
	        this._invalidAnimation = false;
	        var usesAnimation = this._getEnabledGPUAnimation();
	        var renderOrderId = 0;
	        var mult = 1;
	        var shader;
	        var len = this._passes.length;
	        for (var i = 0; i < len; i++) {
	            shader = this._passes[i].shader;
	            shader.usesAnimation = usesAnimation;
	            renderOrderId += shader.programData.id * mult;
	            mult *= 1000;
	        }
	        if (this._usesAnimation != usesAnimation) {
	            this._usesAnimation = usesAnimation;
	            var renderables = this._surface.iOwners;
	            var numOwners = renderables.length;
	            for (var j = 0; j < numOwners; j++)
	                renderables[j].invalidateElements();
	        }
	        this._renderOrderId = renderOrderId;
	    };
	    GL_SurfaceBase.prototype._updateImages = function () {
	        this._invalidImages = false;
	        var numTextures = this._surface.getNumTextures();
	        var texture;
	        var numImages;
	        var images;
	        var image;
	        var sampler;
	        var index = 0;
	        for (var i = 0; i < numTextures; i++) {
	            texture = this._surface.getTextureAt(i);
	            numImages = texture.getNumImages();
	            images = this._imageIndices[texture.id] = new Array();
	            for (var j = 0; j < numImages; j++) {
	                image = texture.getImageAt(j) || (this._surface.style ? this._surface.style.getImageAt(texture, j) : null) || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultImage2D();
	                this.images[index] = this._stage.getAbstraction(image);
	                sampler = texture.getSamplerAt(j) || (this._surface.style ? this._surface.style.getSamplerAt(texture, j) : null) || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultSampler();
	                this.samplers[index] = this._stage.getAbstraction(sampler);
	                images[j] = index++;
	            }
	        }
	        this._numImages = index;
	    };
	    /**
	     * Performs any processing that needs to occur before any of its passes are used.
	     *
	     * @private
	     */
	    GL_SurfaceBase.prototype._pUpdateRender = function () {
	        this._invalidRender = false;
	        //overrride to update shader object properties
	    };
	    /**
	     * Removes a pass from the surface.
	     * @param pass The pass to be removed.
	     */
	    GL_SurfaceBase.prototype._pRemovePass = function (pass) {
	        pass.removeEventListener(PassEvent_1.PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
	        this._passes.splice(this._passes.indexOf(pass), 1);
	    };
	    /**
	     * Removes all passes from the surface
	     */
	    GL_SurfaceBase.prototype._pClearPasses = function () {
	        var len = this._passes.length;
	        for (var i = 0; i < len; ++i)
	            this._passes[i].removeEventListener(PassEvent_1.PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
	        this._passes.length = 0;
	    };
	    /**
	     * Adds a pass to the surface
	     * @param pass
	     */
	    GL_SurfaceBase.prototype._pAddPass = function (pass) {
	        this._passes.push(pass);
	        pass.addEventListener(PassEvent_1.PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
	    };
	    /**
	     * Listener for when a pass's shader code changes. It recalculates the render order id.
	     */
	    GL_SurfaceBase.prototype.onPassInvalidate = function (event) {
	        this._invalidAnimation = true;
	    };
	    /**
	     * test if animation will be able to run on gpu BEFORE compiling materials
	     * test if the shader objects supports animating the animation set in the vertex shader
	     * if any object using this material fails to support accelerated animations for any of the shader objects,
	     * we should do everything on cpu (otherwise we have the cost of both gpu + cpu animations)
	     */
	    GL_SurfaceBase.prototype._getEnabledGPUAnimation = function () {
	        if (this._surface.animationSet) {
	            this._surface.animationSet.resetGPUCompatibility();
	            var renderables = this._surface.iOwners;
	            var numOwners = renderables.length;
	            var len = this._passes.length;
	            var shader;
	            for (var i = 0; i < len; i++) {
	                shader = this._passes[i].shader;
	                shader.usesAnimation = false;
	                for (var j = 0; j < numOwners; j++)
	                    if (renderables[j].animator)
	                        renderables[j].animator.testGPUCompatibility(shader);
	            }
	            return !this._surface.animationSet.usesCPU;
	        }
	        return false;
	    };
	    return GL_SurfaceBase;
	}(AbstractionBase_1.AbstractionBase));
	exports.GL_SurfaceBase = GL_SurfaceBase;


/***/ },
/* 284 */
/***/ function(module, exports) {

	"use strict";
	var MethodMaterialMode = (function () {
	    function MethodMaterialMode() {
	    }
	    /**
	     *
	     */
	    MethodMaterialMode.SINGLE_PASS = "singlePass";
	    /**
	     *
	     */
	    MethodMaterialMode.MULTI_PASS = "multiPass";
	    return MethodMaterialMode;
	}());
	exports.MethodMaterialMode = MethodMaterialMode;


/***/ },
/* 285 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Image2D_1 = __webpack_require__(96);
	var MaterialBase_1 = __webpack_require__(135);
	var Single2DTexture_1 = __webpack_require__(136);
	var ContextGLCompareMode_1 = __webpack_require__(43);
	var MethodMaterialMode_1 = __webpack_require__(284);
	var AmbientBasicMethod_1 = __webpack_require__(225);
	var DiffuseBasicMethod_1 = __webpack_require__(230);
	var NormalBasicMethod_1 = __webpack_require__(250);
	var SpecularBasicMethod_1 = __webpack_require__(263);
	/**
	 * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var MethodMaterial = (function (_super) {
	    __extends(MethodMaterial, _super);
	    function MethodMaterial(imageColor, alpha) {
	        if (imageColor === void 0) { imageColor = null; }
	        if (alpha === void 0) { alpha = 1; }
	        _super.call(this, imageColor, alpha);
	        this._effectMethods = new Array();
	        this._ambientMethod = new AmbientBasicMethod_1.AmbientBasicMethod();
	        this._diffuseMethod = new DiffuseBasicMethod_1.DiffuseBasicMethod();
	        this._normalMethod = new NormalBasicMethod_1.NormalBasicMethod();
	        this._specularMethod = new SpecularBasicMethod_1.SpecularBasicMethod();
	        this._depthCompareMode = ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL;
	        this._mode = MethodMaterialMode_1.MethodMaterialMode.SINGLE_PASS;
	        //add default methods owners
	        this._ambientMethod.iAddOwner(this);
	        this._diffuseMethod.iAddOwner(this);
	        this._normalMethod.iAddOwner(this);
	        this._specularMethod.iAddOwner(this);
	        //set a texture if an image is present
	        if (imageColor instanceof Image2D_1.Image2D)
	            this._ambientMethod.texture = new Single2DTexture_1.Single2DTexture();
	    }
	    Object.defineProperty(MethodMaterial.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return MethodMaterial.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "mode", {
	        get: function () {
	            return this._mode;
	        },
	        set: function (value) {
	            if (this._mode == value)
	                return;
	            this._mode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "depthCompareMode", {
	        /**
	         * The depth compare mode used to render the renderables using this material.
	         *
	         * @see away.stagegl.ContextGLCompareMode
	         */
	        get: function () {
	            return this._depthCompareMode;
	        },
	        set: function (value) {
	            if (this._depthCompareMode == value)
	                return;
	            this._depthCompareMode = value;
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "diffuseTexture", {
	        /**
	         * The texture object to use for the ambient colour.
	         */
	        get: function () {
	            return this._diffuseMethod.texture;
	        },
	        set: function (value) {
	            this._diffuseMethod.texture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "ambientMethod", {
	        /**
	         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
	         */
	        get: function () {
	            return this._ambientMethod;
	        },
	        set: function (value) {
	            if (this._ambientMethod == value)
	                return;
	            if (this._ambientMethod)
	                this._ambientMethod.iRemoveOwner(this);
	            this._ambientMethod = value;
	            if (this._ambientMethod)
	                this._ambientMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "shadowMethod", {
	        /**
	         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
	         */
	        get: function () {
	            return this._shadowMethod;
	        },
	        set: function (value) {
	            if (this._shadowMethod == value)
	                return;
	            if (this._shadowMethod)
	                this._shadowMethod.iRemoveOwner(this);
	            this._shadowMethod = value;
	            if (this._shadowMethod)
	                this._shadowMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "diffuseMethod", {
	        /**
	         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
	         */
	        get: function () {
	            return this._diffuseMethod;
	        },
	        set: function (value) {
	            if (this._diffuseMethod == value)
	                return;
	            if (this._diffuseMethod)
	                this._diffuseMethod.iRemoveOwner(this);
	            this._diffuseMethod = value;
	            if (this._diffuseMethod)
	                this._diffuseMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "specularMethod", {
	        /**
	         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
	         */
	        get: function () {
	            return this._specularMethod;
	        },
	        set: function (value) {
	            if (this._specularMethod == value)
	                return;
	            if (this._specularMethod)
	                this._specularMethod.iRemoveOwner(this);
	            this._specularMethod = value;
	            if (this._specularMethod)
	                this._specularMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "normalMethod", {
	        /**
	         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
	         */
	        get: function () {
	            return this._normalMethod;
	        },
	        set: function (value) {
	            if (this._normalMethod == value)
	                return;
	            if (this._normalMethod)
	                this._normalMethod.iRemoveOwner(this);
	            this._normalMethod = value;
	            if (this._normalMethod)
	                this._normalMethod.iAddOwner(this);
	            this.invalidate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(MethodMaterial.prototype, "numEffectMethods", {
	        get: function () {
	            return this._effectMethods.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
	     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
	     * methods added prior.
	     */
	    MethodMaterial.prototype.addEffectMethod = function (method) {
	        method.iAddOwner(this);
	        this._effectMethods.push(method);
	        this.invalidate();
	    };
	    /**
	     * Returns the method added at the given index.
	     * @param index The index of the method to retrieve.
	     * @return The method at the given index.
	     */
	    MethodMaterial.prototype.getEffectMethodAt = function (index) {
	        return this._effectMethods[index];
	    };
	    /**
	     * Adds an effect method at the specified index amongst the methods already added to the material. Effect
	     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
	     * etc. The method will be applied to the result of the methods with a lower index.
	     */
	    MethodMaterial.prototype.addEffectMethodAt = function (method, index) {
	        method.iAddOwner(this);
	        this._effectMethods.splice(index, 0, method);
	        this.invalidate();
	    };
	    /**
	     * Removes an effect method from the material.
	     * @param method The method to be removed.
	     */
	    MethodMaterial.prototype.removeEffectMethod = function (method) {
	        method.iRemoveOwner(this);
	        this._effectMethods.splice(this._effectMethods.indexOf(method), 1);
	        this.invalidate();
	    };
	    MethodMaterial.assetType = "[materials MethodMaterial]";
	    return MethodMaterial;
	}(MaterialBase_1.MaterialBase));
	exports.MethodMaterial = MethodMaterial;


/***/ },
/* 286 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(287));
	var AWDParser_1 = __webpack_require__(305);
	exports.AWDParser = AWDParser_1.AWDParser;
	var FNTParser_1 = __webpack_require__(361);
	exports.FNTParser = FNTParser_1.FNTParser;
	var Max3DSParser_1 = __webpack_require__(362);
	exports.Max3DSParser = Max3DSParser_1.Max3DSParser;
	var FontParser_1 = __webpack_require__(363);
	exports.FontParser = FontParser_1.FontParser;
	var MD2Parser_1 = __webpack_require__(364);
	exports.MD2Parser = MD2Parser_1.MD2Parser;
	var MD5AnimParser_1 = __webpack_require__(365);
	exports.MD5AnimParser = MD5AnimParser_1.MD5AnimParser;
	var MD5MeshParser_1 = __webpack_require__(366);
	exports.MD5MeshParser = MD5MeshParser_1.MD5MeshParser;
	var OBJParser_1 = __webpack_require__(367);
	exports.OBJParser = OBJParser_1.OBJParser;
	var Parsers_1 = __webpack_require__(368);
	exports.Parsers = Parsers_1.Parsers;


/***/ },
/* 287 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Image2DParser_1 = __webpack_require__(288);
	exports.Image2DParser = Image2DParser_1.Image2DParser;
	var ImageCubeParser_1 = __webpack_require__(295);
	exports.ImageCubeParser = ImageCubeParser_1.ImageCubeParser;
	var ParserBase_1 = __webpack_require__(289);
	exports.ParserBase = ParserBase_1.ParserBase;
	var ParserDataFormat_1 = __webpack_require__(297);
	exports.ParserDataFormat = ParserDataFormat_1.ParserDataFormat;
	var ParserUtils_1 = __webpack_require__(291);
	exports.ParserUtils = ParserUtils_1.ParserUtils;
	var ResourceDependency_1 = __webpack_require__(169);
	exports.ResourceDependency = ResourceDependency_1.ResourceDependency;
	var TextureAtlasParser_1 = __webpack_require__(298);
	exports.TextureAtlasParser = TextureAtlasParser_1.TextureAtlasParser;
	var WaveAudioParser_1 = __webpack_require__(300);
	exports.WaveAudioParser = WaveAudioParser_1.WaveAudioParser;


/***/ },
/* 288 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var ByteArray_1 = __webpack_require__(292);
	/**
	 * Image2DParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
	 * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
	 * exception cases.
	 */
	var Image2DParser = (function (_super) {
	    __extends(Image2DParser, _super);
	    /**
	     * Creates a new Image2DParser object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function Image2DParser() {
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.BLOB);
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    Image2DParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "jpg" || extension == "jpeg" || extension == "png" || extension == "gif"; //|| extension == "bmp";//|| extension == "atf";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    Image2DParser.supportsData = function (data) {
	        if (data instanceof HTMLImageElement)
	            return true;
	        if (!(data instanceof ByteArray_1.ByteArray))
	            return false;
	        var ba = data;
	        ba.position = 0;
	        if (ba.readUnsignedShort() == 0xd8ff)
	            return true; // JPEG, maybe check for "JFIF" as well?
	        ba.position = 0;
	        if (ba.readShort() == 0x424D)
	            return true; // BMP
	        ba.position = 1;
	        if (ba.readUTFBytes(3) == 'PNG')
	            return true;
	        ba.position = 0;
	        if (ba.readUTFBytes(3) == 'GIF' && ba.readShort() == 0x3839 && ba.readByte() == 0x61)
	            return true;
	        ba.position = 0;
	        if (ba.readUTFBytes(3) == 'ATF')
	            return true;
	        return false;
	    };
	    /**
	     * @inheritDoc
	     */
	    Image2DParser.prototype._pProceedParsing = function () {
	        var _this = this;
	        var asset;
	        var sizeError = false;
	        if (this._loadingImage) {
	            return ParserBase_1.ParserBase.MORE_TO_PARSE;
	        }
	        else if (this._htmlImageElement) {
	            //if (ImageUtils.isHTMLImageElementValid(this._htmlImageElement)) {
	            asset = ParserUtils_1.ParserUtils.imageToBitmapImage2D(this._htmlImageElement, false);
	            this._pFinalizeAsset(asset, this._iFileName);
	        }
	        else if (this.data instanceof HTMLImageElement) {
	            var htmlImageElement = this.data;
	            //if (ImageUtils.isHTMLImageElementValid(htmlImageElement)) {
	            asset = ParserUtils_1.ParserUtils.imageToBitmapImage2D(htmlImageElement, false);
	            this._pFinalizeAsset(asset, this._iFileName);
	        }
	        else if (this.data instanceof ByteArray_1.ByteArray) {
	            var ba = this.data;
	            ba.position = 0;
	            this._htmlImageElement = ParserUtils_1.ParserUtils.byteArrayToImage(this.data);
	            if (!this._htmlImageElement.complete) {
	                this._htmlImageElement.onload = function (event) { return _this.onLoadComplete(event); };
	                this._loadingImage = true;
	                return ParserBase_1.ParserBase.MORE_TO_PARSE;
	            }
	            //if (ImageUtils.isHTMLImageElementValid(this._htmlImageElement)) {
	            asset = ParserUtils_1.ParserUtils.imageToBitmapImage2D(this._htmlImageElement, false);
	            this._pFinalizeAsset(asset, this._iFileName);
	        }
	        else if (this.data instanceof ArrayBuffer) {
	            this._htmlImageElement = ParserUtils_1.ParserUtils.arrayBufferToImage(this.data);
	            asset = ParserUtils_1.ParserUtils.imageToBitmapImage2D(this._htmlImageElement, false);
	            this._pFinalizeAsset(asset, this._iFileName);
	        }
	        else if (this.data instanceof Blob) {
	            this._htmlImageElement = ParserUtils_1.ParserUtils.blobToImage(this.data);
	            this._htmlImageElement.onload = function (event) { return _this.onLoadComplete(event); };
	            this._loadingImage = true;
	            return ParserBase_1.ParserBase.MORE_TO_PARSE;
	        }
	        if (sizeError == true) {
	        }
	        this._pContent = asset;
	        return ParserBase_1.ParserBase.PARSING_DONE;
	    };
	    Image2DParser.prototype.onLoadComplete = function (event) {
	        this._loadingImage = false;
	    };
	    return Image2DParser;
	}(ParserBase_1.ParserBase));
	exports.Image2DParser = Image2DParser;


/***/ },
/* 289 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var AssetEvent_1 = __webpack_require__(9);
	var EventDispatcher_1 = __webpack_require__(11);
	var ParserEvent_1 = __webpack_require__(168);
	var TimerEvent_1 = __webpack_require__(290);
	var ParserUtils_1 = __webpack_require__(291);
	var ResourceDependency_1 = __webpack_require__(169);
	var ImageUtils_1 = __webpack_require__(98);
	var Timer_1 = __webpack_require__(293);
	var getTimer_1 = __webpack_require__(294);
	/**
	 * <code>ParserBase</code> provides an abstract base export class for objects that convert blocks of data to data structures
	 * supported by away.
	 *
	 * If used by <code>Loader</code> to automatically determine the parser type, two public static methods should
	 * be implemented, with the following signatures:
	 *
	 * <code>public static supportsType(extension : string) : boolean</code>
	 * Indicates whether or not a given file extension is supported by the parser.
	 *
	 * <code>public static supportsData(data : *) : boolean</code>
	 * Tests whether a data block can be parsed by the parser.
	 *
	 * Furthermore, for any concrete subtype, the method <code>initHandle</code> should be overridden to immediately
	 * create the object that will contain the parsed data. This allows <code>ResourceManager</code> to return an object
	 * handle regardless of whether the object was loaded or not.
	 *
	 * @see Loader
	 */
	var ParserBase = (function (_super) {
	    __extends(ParserBase, _super);
	    /**
	     * Creates a new ParserBase object
	     * @param format The data format of the file data to be parsed. Can be either <code>ParserDataFormat.BINARY</code> or <code>ParserDataFormat.PLAIN_TEXT</code>, and should be provided by the concrete subtype.
	     *
	     * @see away.loading.parsers.ParserDataFormat
	     */
	    function ParserBase(format) {
	        var _this = this;
	        _super.call(this);
	        this._materialMode = 0;
	        this._dataFormat = format;
	        this._dependencies = new Array();
	        this._pOnIntervalDelegate = function (event) { return _this._pOnInterval(event); };
	    }
	    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
	    // TODO: add error checking for the following ( could cause a problem if this function is not implemented )
	    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
	    // Needs to be implemented in all Parsers (
	    //<code>public static supportsType(extension : string) : boolean</code>
	    //* Indicates whether or not a given file extension is supported by the parser.
	    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
	    ParserBase.supportsType = function (extension) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    Object.defineProperty(ParserBase.prototype, "content", {
	        /* Protected */
	        get: function () {
	            return this._pContent;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Validates a bitmapData loaded before assigning to a default BitmapMaterial
	     */
	    ParserBase.prototype.isBitmapImage2DValid = function (bitmapImage2D) {
	        var isValid = ImageUtils_1.ImageUtils.isImage2DValid(bitmapImage2D);
	        if (!isValid) {
	            console.log(">> Bitmap loaded is not having power of 2 dimensions or is higher than 2048");
	        }
	        return isValid;
	    };
	    Object.defineProperty(ParserBase.prototype, "parsingFailure", {
	        get: function () {
	            return this._parsingFailure;
	        },
	        set: function (b) {
	            this._parsingFailure = b;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "parsingPaused", {
	        get: function () {
	            return this._parsingPaused;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "parsingComplete", {
	        get: function () {
	            return this._parsingComplete;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "materialMode", {
	        get: function () {
	            return this._materialMode;
	        },
	        set: function (newMaterialMode) {
	            this._materialMode = newMaterialMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "data", {
	        get: function () {
	            return this._data;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParserBase.prototype, "dataFormat", {
	        /**
	         * The data format of the file data to be parsed. Options are <code>URLLoaderDataFormat.BINARY</code>, <code>URLLoaderDataFormat.ARRAY_BUFFER</code>, <code>URLLoaderDataFormat.BLOB</code>, <code>URLLoaderDataFormat.VARIABLES</code> or <code>URLLoaderDataFormat.TEXT</code>.
	         */
	        get: function () {
	            return this._dataFormat;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Parse data (possibly containing bytearry, plain text or BitmapAsset) asynchronously, meaning that
	     * the parser will periodically stop parsing so that the AVM may proceed to the
	     * next frame.
	     *
	     * @param data The untyped data object in which the loaded data resides.
	     * @param frameLimit number of milliseconds of parsing allowed per frame. The
	     * actual time spent on a frame can exceed this number since time-checks can
	     * only be performed between logical sections of the parsing procedure.
	     */
	    ParserBase.prototype.parseAsync = function (data, frameLimit) {
	        if (frameLimit === void 0) { frameLimit = 30; }
	        this._data = data;
	        this._pStartParsing(frameLimit);
	    };
	    Object.defineProperty(ParserBase.prototype, "dependencies", {
	        /**
	         * A list of dependencies that need to be loaded and resolved for the object being parsed.
	         */
	        get: function () {
	            return this._dependencies;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Resolve a dependency when it's loaded. For example, a dependency containing an ImageResource would be assigned
	     * to a Mesh instance as a BitmapMaterial, a scene graph object would be added to its intended parent. The
	     * dependency should be a member of the dependencies property.
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    ParserBase.prototype._iResolveDependency = function (resourceDependency) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Resolve a dependency loading failure. Used by parser to eventually provide a default map
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    ParserBase.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Resolve a dependency name
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    ParserBase.prototype._iResolveDependencyName = function (resourceDependency, asset) {
	        return asset.name;
	    };
	    ParserBase.prototype._iResumeParsing = function () {
	        this._parsingPaused = false;
	        if (this._timer)
	            this._timer.start();
	        //get started!
	        if (!this._isParsing)
	            this._pOnInterval();
	    };
	    ParserBase.prototype._pFinalizeAsset = function (asset, name) {
	        if (name === void 0) { name = null; }
	        var type_event;
	        var type_name;
	        if (name != null)
	            asset.name = name;
	        // If the asset has no name, give it
	        // a per-type default name.
	        if (!asset.name)
	            asset.name = asset.assetType;
	        this.dispatchEvent(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.ASSET_COMPLETE, asset));
	    };
	    /**
	     * Parse the next block of data.
	     * @return Whether or not more data needs to be parsed. Can be <code>ParserBase.ParserBase.PARSING_DONE</code> or
	     * <code>ParserBase.ParserBase.MORE_TO_PARSE</code>.
	     */
	    ParserBase.prototype._pProceedParsing = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ParserBase.prototype._pDieWithError = function (message) {
	        if (message === void 0) { message = 'Unknown parsing error'; }
	        if (this._timer) {
	            this._timer.removeEventListener(TimerEvent_1.TimerEvent.TIMER, this._pOnIntervalDelegate);
	            this._timer.stop();
	            this._timer = null;
	        }
	        this.dispatchEvent(new ParserEvent_1.ParserEvent(ParserEvent_1.ParserEvent.PARSE_ERROR, message));
	    };
	    ParserBase.prototype._pAddDependency = function (id, req, retrieveAsRawData, data, suppressErrorEvents, sub_id) {
	        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
	        if (data === void 0) { data = null; }
	        if (suppressErrorEvents === void 0) { suppressErrorEvents = false; }
	        if (sub_id === void 0) { sub_id = 0; }
	        var dependency = new ResourceDependency_1.ResourceDependency(id, req, data, null, this, retrieveAsRawData, suppressErrorEvents, sub_id);
	        this._dependencies.push(dependency);
	        return dependency;
	    };
	    ParserBase.prototype._pPauseAndRetrieveDependencies = function () {
	        this._pPauseParsing();
	        this.dispatchEvent(new ParserEvent_1.ParserEvent(ParserEvent_1.ParserEvent.READY_FOR_DEPENDENCIES));
	    };
	    ParserBase.prototype._pPauseParsing = function () {
	        if (this._timer)
	            this._timer.stop();
	        this._parsingPaused = true;
	    };
	    /**
	     * Tests whether or not there is still time left for parsing within the maximum allowed time frame per session.
	     * @return True if there is still time left, false if the maximum allotted time was exceeded and parsing should be interrupted.
	     */
	    ParserBase.prototype._pHasTime = function () {
	        return ((getTimer_1.getTimer() - this._lastFrameTime) < this._frameLimit);
	    };
	    /**
	     * Called when the parsing pause interval has passed and parsing can proceed.
	     */
	    ParserBase.prototype._pOnInterval = function (event) {
	        if (event === void 0) { event = null; }
	        this._lastFrameTime = getTimer_1.getTimer();
	        this._isParsing = true;
	        if (this._pProceedParsing() && !this._parsingFailure)
	            this._pFinishParsing();
	        this._isParsing = false;
	    };
	    /**
	     * Initializes the parsing of data.
	     * @param frameLimit The maximum duration of a parsing session.
	     */
	    ParserBase.prototype._pStartParsing = function (frameLimit) {
	        this._frameLimit = frameLimit;
	        this._timer = new Timer_1.Timer(this._frameLimit, 0);
	        this._timer.addEventListener(TimerEvent_1.TimerEvent.TIMER, this._pOnIntervalDelegate);
	        this._timer.start();
	        //get started!
	        this._pOnInterval();
	    };
	    /**
	     * Finish parsing the data.
	     */
	    ParserBase.prototype._pFinishParsing = function () {
	        if (this._timer) {
	            this._timer.removeEventListener(TimerEvent_1.TimerEvent.TIMER, this._pOnIntervalDelegate);
	            this._timer.stop();
	        }
	        this._timer = null;
	        this._parsingComplete = true;
	        this._isParsing = false;
	        this.dispatchEvent(new ParserEvent_1.ParserEvent(ParserEvent_1.ParserEvent.PARSE_COMPLETE));
	    };
	    /**
	     *
	     * @returns {string}
	     * @private
	     */
	    ParserBase.prototype._pGetTextData = function () {
	        return ParserUtils_1.ParserUtils.toString(this._data);
	    };
	    /**
	     *
	     * @returns {ByteArray}
	     * @private
	     */
	    ParserBase.prototype._pGetByteData = function () {
	        return ParserUtils_1.ParserUtils.toByteArray(this._data);
	    };
	    /**
	     *
	     * @returns {any}
	     * @private
	     */
	    ParserBase.prototype._pGetData = function () {
	        return this._data;
	    };
	    /**
	     * Returned by <code>proceedParsing</code> to indicate no more parsing is needed.
	     */
	    ParserBase.PARSING_DONE = true;
	    /* Protected */
	    /**
	     * Returned by <code>proceedParsing</code> to indicate more parsing is needed, allowing asynchronous parsing.
	     */
	    ParserBase.MORE_TO_PARSE = false;
	    return ParserBase;
	}(EventDispatcher_1.EventDispatcher));
	exports.ParserBase = ParserBase;


/***/ },
/* 290 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var TimerEvent = (function (_super) {
	    __extends(TimerEvent, _super);
	    function TimerEvent(type) {
	        _super.call(this, type);
	    }
	    /**
	     *
	     */
	    TimerEvent.TIMER = "timer";
	    /**
	     *
	     */
	    TimerEvent.TIMER_COMPLETE = "timerComplete";
	    return TimerEvent;
	}(EventBase_1.EventBase));
	exports.TimerEvent = TimerEvent;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = TimerEvent;


/***/ },
/* 291 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImage2D_1 = __webpack_require__(95);
	var ByteArray_1 = __webpack_require__(292);
	var ParserUtils = (function () {
	    function ParserUtils() {
	    }
	    ParserUtils.arrayBufferToBase64 = function (data, mimeType) {
	        var byteStr = '';
	        var bytes = new Uint8Array(data);
	        var len = bytes.byteLength;
	        for (var i = 0; i < len; i++)
	            byteStr += String.fromCharCode(bytes[i]);
	        var base64Image = window.btoa(byteStr);
	        return 'data:' + mimeType + ';base64,' + base64Image;
	    };
	    ParserUtils.arrayBufferToAudio = function (data, fileType) {
	        var str = ParserUtils.arrayBufferToBase64(data, 'audio/' + fileType);
	        var audio = new Audio();
	        audio.src = str;
	        return audio;
	    };
	    /**
	     * Converts an ArrayBuffer to a base64 string
	     *
	     * @param image data as a ByteArray
	     *
	     * @return HTMLImageElement
	     *
	     */
	    ParserUtils.arrayBufferToImage = function (data) {
	        var str = ParserUtils.arrayBufferToBase64(data, 'image/png');
	        var img = new Image();
	        img.src = str;
	        return img;
	    };
	    /**
	     * Converts an ByteArray to an Image - returns an HTMLImageElement
	     *
	     * @param image data as a ByteArray
	     *
	     * @return HTMLImageElement
	     *
	     */
	    ParserUtils.byteArrayToImage = function (data) {
	        var str = ParserUtils.arrayBufferToBase64(data.arraybytes, 'image/png');
	        var img = new Image();
	        img.src = str;
	        return img;
	    };
	    ParserUtils.byteArrayToAudio = function (data, filetype) {
	        var str = ParserUtils.arrayBufferToBase64(data.arraybytes, 'audio/' + filetype);
	        var audio = new Audio();
	        audio.src = str;
	        return audio;
	    };
	    /**
	     * Converts an Blob to an Image - returns an HTMLImageElement
	     *
	     * @param image data as a Blob
	     *
	     * @return HTMLImageElement
	     *
	     */
	    ParserUtils.blobToImage = function (data) {
	        var URLObj = window['URL'] || window['webkitURL'];
	        var src = URLObj.createObjectURL(data);
	        var img = new Image();
	        img.src = src;
	        return img;
	    };
	    /**
	     * Converts an Blob to audio - returns an HTMLAudioElement
	     *
	     * @param audio data as a Blob
	     *
	     * @return HTMLAudioElement
	     *
	     */
	    ParserUtils.blobToAudio = function (data) {
	        var URLObj = window['URL'] || window['webkitURL'];
	        var src = URLObj.createObjectURL(data);
	        var img = new Audio();
	        img.src = src;
	        return img;
	    };
	    /**
	     *
	     */
	    ParserUtils.imageToBitmapImage2D = function (img, powerOfTwo) {
	        if (powerOfTwo === void 0) { powerOfTwo = true; }
	        var bitmapData = new BitmapImage2D_1.BitmapImage2D(img.width, img.height, true, null, powerOfTwo);
	        bitmapData.draw(img);
	        return bitmapData;
	    };
	    /**
	     * Returns a object as ByteArray, if possible.
	     *
	     * @param data The object to return as ByteArray
	     *
	     * @return The ByteArray or null
	     *
	     */
	    ParserUtils.toByteArray = function (data) {
	        var b = new ByteArray_1.ByteArray();
	        b.setArrayBuffer(data);
	        return b;
	    };
	    /**
	     * Returns a object as String, if possible.
	     *
	     * @param data The object to return as String
	     * @param length The length of the returned String
	     *
	     * @return The String or null
	     *
	     */
	    ParserUtils.toString = function (data, length) {
	        if (length === void 0) { length = 0; }
	        if (typeof data === 'string') {
	            var s = data;
	            if (s['substr'] != null)
	                return s.substr(0, s.length);
	        }
	        if (data instanceof ByteArray_1.ByteArray) {
	            var ba = data;
	            ba.position = 0;
	            return ba.readUTFBytes(Math.min(ba.getBytesAvailable(), length));
	        }
	        return null;
	        /*
	         var ba:ByteArray;
	
	         length ||= uint.MAX_VALUE;
	
	         if (data is String)
	         return String(data).substr(0, length);
	
	         ba = toByteArray(data);
	         if (ba) {
	         ba.position = 0;
	         return ba.readUTFBytes(Math.min(ba.bytesAvailable, length));
	         }
	
	         return null;
	
	         */
	    };
	    return ParserUtils;
	}());
	exports.ParserUtils = ParserUtils;


/***/ },
/* 292 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ByteArrayBase_1 = __webpack_require__(87);
	var ByteArray = (function (_super) {
	    __extends(ByteArray, _super);
	    function ByteArray(maxlength) {
	        if (maxlength === void 0) { maxlength = 4; }
	        _super.call(this);
	        this._mode = "Typed array";
	        this.maxlength = Math.max((maxlength + 255) & (~255), 4);
	        this.arraybytes = new ArrayBuffer(this.maxlength);
	        this.unalignedarraybytestemp = new ArrayBuffer(16);
	    }
	    ByteArray.prototype.ensureWriteableSpace = function (n) {
	        this.ensureSpace(n + this.position);
	    };
	    ByteArray.prototype.setArrayBuffer = function (aBuffer) {
	        this.ensureSpace(aBuffer.byteLength);
	        this.length = aBuffer.byteLength;
	        var inInt8AView = new Int8Array(aBuffer);
	        var localInt8View = new Int8Array(this.arraybytes, 0, this.length);
	        localInt8View.set(inInt8AView);
	        this.position = 0;
	    };
	    ByteArray.prototype.getBytesAvailable = function () {
	        return (this.length) - (this.position);
	    };
	    ByteArray.prototype.ensureSpace = function (n) {
	        if (n > this.maxlength) {
	            var newmaxlength = (n + 255) & (~255);
	            var newarraybuffer = new ArrayBuffer(newmaxlength);
	            var view = new Uint8Array(this.arraybytes, 0, this.length);
	            var newview = new Uint8Array(newarraybuffer, 0, this.length);
	            newview.set(view); // memcpy
	            this.arraybytes = newarraybuffer;
	            this.maxlength = newmaxlength;
	        }
	    };
	    ByteArray.prototype.writeByte = function (b) {
	        this.ensureWriteableSpace(1);
	        var view = new Int8Array(this.arraybytes);
	        view[this.position++] = (~~b); // ~~ is cast to int in js...
	        if (this.position > this.length) {
	            this.length = this.position;
	        }
	    };
	    ByteArray.prototype.readByte = function () {
	        if (this.position >= this.length)
	            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
	        var view = new Int8Array(this.arraybytes);
	        return view[this.position++];
	    };
	    ByteArray.prototype.readBytes = function (bytes, offset, length) {
	        if (offset === void 0) { offset = 0; }
	        if (length === void 0) { length = 0; }
	        if (length == null)
	            length = bytes.length;
	        bytes.ensureWriteableSpace(offset + length);
	        var byteView = new Int8Array(bytes.arraybytes);
	        var localByteView = new Int8Array(this.arraybytes);
	        byteView.set(localByteView.subarray(this.position, this.position + length), offset);
	        this.position += length;
	        if (length + offset > bytes.length)
	            bytes.length += (length + offset) - bytes.length;
	    };
	    ByteArray.prototype.writeUnsignedByte = function (b) {
	        this.ensureWriteableSpace(1);
	        var view = new Uint8Array(this.arraybytes);
	        view[this.position++] = (~~b) & 0xff; // ~~ is cast to int in js...
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readUnsignedByte = function () {
	        if (this.position >= this.length)
	            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
	        var view = new Uint8Array(this.arraybytes);
	        return view[this.position++];
	    };
	    ByteArray.prototype.writeUnsignedShort = function (b) {
	        this.ensureWriteableSpace(2);
	        if ((this.position & 1) == 0) {
	            var view = new Uint16Array(this.arraybytes);
	            view[this.position >> 1] = (~~b) & 0xffff; // ~~ is cast to int in js...
	        }
	        else {
	            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
	            view[0] = (~~b) & 0xffff;
	            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
	            view2.set(view3);
	        }
	        this.position += 2;
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readUTFBytes = function (len) {
	        var value = "";
	        var max = this.position + len;
	        var data = new DataView(this.arraybytes);
	        // utf8-encode
	        while (this.position < max) {
	            var c = data.getUint8(this.position++);
	            if (c < 0x80) {
	                if (c == 0)
	                    break;
	                value += String.fromCharCode(c);
	            }
	            else if (c < 0xE0) {
	                value += String.fromCharCode(((c & 0x3F) << 6) | (data.getUint8(this.position++) & 0x7F));
	            }
	            else if (c < 0xF0) {
	                var c2 = data.getUint8(this.position++);
	                value += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (data.getUint8(this.position++) & 0x7F));
	            }
	            else {
	                var c2 = data.getUint8(this.position++);
	                var c3 = data.getUint8(this.position++);
	                value += String.fromCharCode(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (data.getUint8(this.position++) & 0x7F));
	            }
	        }
	        return value;
	    };
	    ByteArray.prototype.readInt = function () {
	        var data = new DataView(this.arraybytes);
	        var int = data.getInt32(this.position, true);
	        this.position += 4;
	        return int;
	    };
	    ByteArray.prototype.readShort = function () {
	        var data = new DataView(this.arraybytes);
	        var short = data.getInt16(this.position, true);
	        this.position += 2;
	        return short;
	    };
	    ByteArray.prototype.readDouble = function () {
	        var data = new DataView(this.arraybytes);
	        var double = data.getFloat64(this.position, true);
	        this.position += 8;
	        return double;
	    };
	    ByteArray.prototype.readUnsignedShort = function () {
	        if (this.position > this.length + 2)
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        if ((this.position & 1) == 0) {
	            var view = new Uint16Array(this.arraybytes);
	            var pa = this.position >> 1;
	            this.position += 2;
	            return view[pa];
	        }
	        else {
	            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
	            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
	            view3.set(view2);
	            this.position += 2;
	            return view[0];
	        }
	    };
	    ByteArray.prototype.writeUnsignedInt = function (b) {
	        this.ensureWriteableSpace(4);
	        if ((this.position & 3) == 0) {
	            var view = new Uint32Array(this.arraybytes);
	            view[this.position >> 2] = (~~b) & 0xffffffff; // ~~ is cast to int in js...
	        }
	        else {
	            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
	            view[0] = (~~b) & 0xffffffff;
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view2.set(view3);
	        }
	        this.position += 4;
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readUnsignedInt = function () {
	        if (this.position > this.length + 4)
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        if ((this.position & 3) == 0) {
	            var view = new Uint32Array(this.arraybytes);
	            var pa = this.position >> 2;
	            this.position += 4;
	            return view[pa];
	        }
	        else {
	            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view3.set(view2);
	            this.position += 4;
	            return view[0];
	        }
	    };
	    ByteArray.prototype.writeFloat = function (b) {
	        this.ensureWriteableSpace(4);
	        if ((this.position & 3) == 0) {
	            var view = new Float32Array(this.arraybytes);
	            view[this.position >> 2] = b;
	        }
	        else {
	            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
	            view[0] = b;
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view2.set(view3);
	        }
	        this.position += 4;
	        if (this.position > this.length)
	            this.length = this.position;
	    };
	    ByteArray.prototype.readFloat = function () {
	        if (this.position > this.length + 4)
	            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
	        if ((this.position & 3) == 0) {
	            var view = new Float32Array(this.arraybytes);
	            var pa = this.position >> 2;
	            this.position += 4;
	            return view[pa];
	        }
	        else {
	            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
	            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
	            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
	            view3.set(view2);
	            this.position += 4;
	            return view[0];
	        }
	    };
	    return ByteArray;
	}(ByteArrayBase_1.ByteArrayBase));
	exports.ByteArray = ByteArray;


/***/ },
/* 293 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	var EventDispatcher_1 = __webpack_require__(11);
	var TimerEvent_1 = __webpack_require__(290);
	var Timer = (function (_super) {
	    __extends(Timer, _super);
	    function Timer(delay, repeatCount) {
	        if (repeatCount === void 0) { repeatCount = 0; }
	        _super.call(this);
	        this._repeatCount = 0;
	        this._currentCount = 0;
	        this._running = false;
	        this._delay = delay;
	        this._repeatCount = repeatCount;
	        if (isNaN(delay) || delay < 0)
	            throw new ErrorBase_1.ErrorBase("Delay is negative or not a number");
	    }
	    Object.defineProperty(Timer.prototype, "currentCount", {
	        get: function () {
	            return this._currentCount;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Timer.prototype, "delay", {
	        get: function () {
	            return this._delay;
	        },
	        set: function (value) {
	            this._delay = value;
	            if (this._running) {
	                this.stop();
	                this.start();
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Timer.prototype, "repeatCount", {
	        get: function () {
	            return this._repeatCount;
	        },
	        set: function (value) {
	            this._repeatCount = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Timer.prototype.reset = function () {
	        if (this._running)
	            this.stop();
	        this._currentCount = 0;
	    };
	    Object.defineProperty(Timer.prototype, "running", {
	        get: function () {
	            return this._running;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Timer.prototype.start = function () {
	        var _this = this;
	        this._running = true;
	        clearInterval(this._iid);
	        this._iid = setInterval(function () { return _this.tick(); }, this._delay);
	    };
	    Timer.prototype.stop = function () {
	        this._running = false;
	        clearInterval(this._iid);
	    };
	    Timer.prototype.tick = function () {
	        this._currentCount++;
	        if ((this._repeatCount > 0) && this._currentCount >= this._repeatCount) {
	            this.stop();
	            this.dispatchEvent(new TimerEvent_1.TimerEvent(TimerEvent_1.TimerEvent.TIMER));
	            this.dispatchEvent(new TimerEvent_1.TimerEvent(TimerEvent_1.TimerEvent.TIMER_COMPLETE));
	        }
	        else {
	            this.dispatchEvent(new TimerEvent_1.TimerEvent(TimerEvent_1.TimerEvent.TIMER));
	        }
	    };
	    return Timer;
	}(EventDispatcher_1.EventDispatcher));
	exports.Timer = Timer;


/***/ },
/* 294 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 *
	 * @returns {number}
	 */
	function getTimer() {
	    // number milliseconds of 1970/01/01
	    // this different to AS3 implementation which gets the number of milliseconds
	    // since instance of Flash player was initialised
	    return Date.now();
	}
	exports.getTimer = getTimer;


/***/ },
/* 295 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImageCube_1 = __webpack_require__(123);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequest_1 = __webpack_require__(296);
	var ParserBase_1 = __webpack_require__(289);
	/**
	 * ImageCubeParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
	 * a loader object, it wraps it in a BitmapImage2DResource so resource management can happen consistently without
	 * exception cases.
	 */
	var ImageCubeParser = (function (_super) {
	    __extends(ImageCubeParser, _super);
	    /**
	     * Creates a new ImageCubeParser object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function ImageCubeParser() {
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT);
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    ImageCubeParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "cube";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    ImageCubeParser.supportsData = function (data) {
	        try {
	            var obj = JSON.parse(data);
	            if (obj)
	                return true;
	            return false;
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    ImageCubeParser.prototype._iResolveDependency = function (resourceDependency) {
	    };
	    /**
	     * @inheritDoc
	     */
	    ImageCubeParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	    };
	    /**
	     * @inheritDoc
	     */
	    ImageCubeParser.prototype._pProceedParsing = function () {
	        if (this._imgDependencyDictionary != null) {
	            var asset = new BitmapImageCube_1.BitmapImageCube(this._getBitmapImage2D(ImageCubeParser.posX).width);
	            asset.draw(BitmapImageCube_1.BitmapImageCube.posX, this._getBitmapImage2D(ImageCubeParser.posX));
	            asset.draw(BitmapImageCube_1.BitmapImageCube.negX, this._getBitmapImage2D(ImageCubeParser.negX));
	            asset.draw(BitmapImageCube_1.BitmapImageCube.posY, this._getBitmapImage2D(ImageCubeParser.posY));
	            asset.draw(BitmapImageCube_1.BitmapImageCube.negY, this._getBitmapImage2D(ImageCubeParser.negY));
	            asset.draw(BitmapImageCube_1.BitmapImageCube.posZ, this._getBitmapImage2D(ImageCubeParser.posZ));
	            asset.draw(BitmapImageCube_1.BitmapImageCube.negZ, this._getBitmapImage2D(ImageCubeParser.negZ));
	            //clear dictionary
	            this._imgDependencyDictionary = null;
	            asset.name = this._iFileName;
	            this._pFinalizeAsset(asset, this._iFileName);
	            return ParserBase_1.ParserBase.PARSING_DONE;
	        }
	        try {
	            var json = JSON.parse(this.data);
	            var data = json.data;
	            var rec;
	            if (data.length != 6)
	                this._pDieWithError('ImageCubeParser: Error - cube texture should have exactly 6 images');
	            if (json) {
	                this._imgDependencyDictionary = new Object();
	                for (var c = 0; c < data.length; c++) {
	                    rec = data[c];
	                    this._imgDependencyDictionary[rec.id] = this._pAddDependency(rec.id, new URLRequest_1.URLRequest(rec.image.toString()));
	                }
	                if (!this._validateCubeData()) {
	                    this._pDieWithError("ImageCubeParser: JSON data error - cubes require id of:   \n" + ImageCubeParser.posX + ', ' + ImageCubeParser.negX + ',  \n' + ImageCubeParser.posY + ', ' + ImageCubeParser.negY + ',  \n' + ImageCubeParser.posZ + ', ' + ImageCubeParser.negZ);
	                    return ParserBase_1.ParserBase.PARSING_DONE;
	                }
	                this._pPauseAndRetrieveDependencies();
	                return ParserBase_1.ParserBase.MORE_TO_PARSE;
	            }
	        }
	        catch (e) {
	            this._pDieWithError('CubeTexturePaser Error parsing JSON');
	        }
	        return ParserBase_1.ParserBase.PARSING_DONE;
	    };
	    ImageCubeParser.prototype._validateCubeData = function () {
	        return (this._imgDependencyDictionary[ImageCubeParser.posX] != null && this._imgDependencyDictionary[ImageCubeParser.negX] != null && this._imgDependencyDictionary[ImageCubeParser.posY] != null && this._imgDependencyDictionary[ImageCubeParser.negY] != null && this._imgDependencyDictionary[ImageCubeParser.posZ] != null && this._imgDependencyDictionary[ImageCubeParser.negZ] != null);
	    };
	    ImageCubeParser.prototype._getBitmapImage2D = function (name) {
	        var dependency = this._imgDependencyDictionary[name];
	        if (dependency)
	            return dependency.assets[0];
	        return null;
	    };
	    ImageCubeParser.posX = 'posX';
	    ImageCubeParser.negX = 'negX';
	    ImageCubeParser.posY = 'posY';
	    ImageCubeParser.negY = 'negY';
	    ImageCubeParser.posZ = 'posZ';
	    ImageCubeParser.negZ = 'negZ';
	    return ImageCubeParser;
	}(ParserBase_1.ParserBase));
	exports.ImageCubeParser = ImageCubeParser;


/***/ },
/* 296 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var URLRequestMethod_1 = __webpack_require__(164);
	var URLRequest = (function () {
	    /**
	
	     * @param url
	     */
	    function URLRequest(url) {
	        if (url === void 0) { url = null; }
	        /**
	         *
	         * away.net.URLRequestMethod.GET
	         * away.net.URLRequestMethod.POST
	         *
	         * @type {string}
	         */
	        this.method = URLRequestMethod_1.URLRequestMethod.GET;
	        /**
	         * Use asynchronous XMLHttpRequest
	         * @type {boolean}
	         */
	        this.async = true;
	        this._url = url;
	    }
	    Object.defineProperty(URLRequest.prototype, "url", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return this._url;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            this._url = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * dispose
	     */
	    URLRequest.prototype.dispose = function () {
	        this.data = null;
	        this._url = null;
	    };
	    return URLRequest;
	}());
	exports.URLRequest = URLRequest;


/***/ },
/* 297 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * An enumeration providing values to describe the data format of parsed data.
	 */
	var ParserDataFormat = (function () {
	    function ParserDataFormat() {
	    }
	    /**
	     * Describes the format of a binary file.
	     */
	    ParserDataFormat.BINARY = "binary";
	    /**
	     * Describes the format of a plain text file.
	     */
	    ParserDataFormat.PLAIN_TEXT = "plainText";
	    /**
	     * Describes the format of an image file
	     */
	    ParserDataFormat.IMAGE = "image";
	    return ParserDataFormat;
	}());
	exports.ParserDataFormat = ParserDataFormat;


/***/ },
/* 298 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Sampler2D_1 = __webpack_require__(121);
	var Rectangle_1 = __webpack_require__(57);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequest_1 = __webpack_require__(296);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var XmlUtils_1 = __webpack_require__(299);
	/**
	 * TextureAtlasParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
	 * a loader object, it wraps it in a BitmapImage2DResource so resource management can happen consistently without
	 * exception cases.
	 */
	var TextureAtlasParser = (function (_super) {
	    __extends(TextureAtlasParser, _super);
	    /**
	     * Creates a new TextureAtlasParser object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function TextureAtlasParser() {
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT);
	        this._parseState = 0;
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    TextureAtlasParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "xml";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    TextureAtlasParser.supportsData = function (data) {
	        try {
	            var content = ParserUtils_1.ParserUtils.toString(data);
	            if (content.indexOf("TextureAtlas") != -1 || content.indexOf("textureatlas") != -1)
	                return true;
	            return false;
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    TextureAtlasParser.prototype._iResolveDependency = function (resourceDependency) {
	        if (resourceDependency.assets.length) {
	            this._imageData = resourceDependency.assets[0];
	            this._pFinalizeAsset(this._imageData);
	            this._parseState = TextureAtlasParserState.PARSE_SUBTEXTURES;
	        }
	        else {
	            this._parseState = TextureAtlasParserState.PARSE_COMPLETE;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    TextureAtlasParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        this._parseState = TextureAtlasParserState.PARSE_COMPLETE;
	    };
	    /**
	     * @inheritDoc
	     */
	    TextureAtlasParser.prototype._pProceedParsing = function () {
	        var nodes;
	        switch (this._parseState) {
	            case TextureAtlasParserState.PARSE_XML:
	                try {
	                    this._doc = XmlUtils_1.XmlUtils.getChildrenWithTag(XmlUtils_1.XmlUtils.strToXml(this._pGetTextData()), "TextureAtlas")[0];
	                    this._imagePath = XmlUtils_1.XmlUtils.readAttributeValue(this._doc, "imagePath");
	                    this._subTextureNodes = XmlUtils_1.XmlUtils.getChildrenWithTag(this._doc, "SubTexture");
	                    this._parseState = TextureAtlasParserState.PARSE_IMAGE;
	                }
	                catch (Error) {
	                    return ParserBase_1.ParserBase.PARSING_DONE;
	                }
	                break;
	            case TextureAtlasParserState.PARSE_IMAGE:
	                if (this._imagePath) {
	                    this._pAddDependency(this._imagePath, new URLRequest_1.URLRequest(this._imagePath));
	                    this._pPauseAndRetrieveDependencies();
	                }
	                else {
	                    return ParserBase_1.ParserBase.PARSING_DONE;
	                }
	                break;
	            case TextureAtlasParserState.PARSE_SUBTEXTURES:
	                var sampler;
	                var element;
	                var x;
	                var y;
	                var width;
	                var height;
	                var len = this._subTextureNodes.length;
	                for (var i = 0; i < len; i++) {
	                    element = this._subTextureNodes[i];
	                    sampler = new Sampler2D_1.Sampler2D();
	                    //setup subtexture rect
	                    x = XmlUtils_1.XmlUtils.readAttributeValue(element, "x");
	                    y = XmlUtils_1.XmlUtils.readAttributeValue(element, "y");
	                    width = XmlUtils_1.XmlUtils.readAttributeValue(element, "width");
	                    height = XmlUtils_1.XmlUtils.readAttributeValue(element, "height");
	                    if (x || y || width || height)
	                        sampler.imageRect = new Rectangle_1.Rectangle(parseInt(x) / this._imageData.width, parseInt(y) / this._imageData.height, parseInt(width) / this._imageData.width, parseInt(height) / this._imageData.height);
	                    //setup frame rect
	                    x = XmlUtils_1.XmlUtils.readAttributeValue(element, "frameX");
	                    y = XmlUtils_1.XmlUtils.readAttributeValue(element, "frameY");
	                    width = XmlUtils_1.XmlUtils.readAttributeValue(element, "frameWidth");
	                    height = XmlUtils_1.XmlUtils.readAttributeValue(element, "frameHeight");
	                    if (x || y || width || height)
	                        sampler.frameRect = new Rectangle_1.Rectangle(parseInt(x), parseInt(y), parseInt(width), parseInt(height));
	                    this._pFinalizeAsset(sampler, XmlUtils_1.XmlUtils.readAttributeValue(element, "name"));
	                }
	                this._parseState = TextureAtlasParserState.PARSE_COMPLETE;
	                break;
	            case TextureAtlasParserState.PARSE_COMPLETE:
	                return ParserBase_1.ParserBase.PARSING_DONE;
	        }
	        return ParserBase_1.ParserBase.MORE_TO_PARSE;
	    };
	    return TextureAtlasParser;
	}(ParserBase_1.ParserBase));
	exports.TextureAtlasParser = TextureAtlasParser;
	var TextureAtlasParserState = (function () {
	    function TextureAtlasParserState() {
	    }
	    TextureAtlasParserState.PARSE_XML = 0;
	    TextureAtlasParserState.PARSE_IMAGE = 1;
	    TextureAtlasParserState.PARSE_SUBTEXTURES = 2;
	    TextureAtlasParserState.PARSE_COMPLETE = 3;
	    return TextureAtlasParserState;
	}());
	exports.TextureAtlasParserState = TextureAtlasParserState;


/***/ },
/* 299 */
/***/ function(module, exports) {

	"use strict";
	var XmlUtils = (function () {
	    function XmlUtils() {
	    }
	    XmlUtils.getChildrenWithTag = function (node, tag) {
	        var fragment = document.createDocumentFragment();
	        if (node) {
	            var num = node.childNodes.length;
	            for (var i = 0; i < num; i++) {
	                var child = node.childNodes[i];
	                if (child != null) {
	                    if (child.nodeName == tag) {
	                        fragment.appendChild(child);
	                    }
	                }
	            }
	        }
	        return fragment.childNodes;
	    };
	    XmlUtils.filterListByParam = function (nodes, paramName, paramValue) {
	        var fragment = document.createDocumentFragment();
	        if (nodes) {
	            var num = nodes.length;
	            for (var i = 0; i < num; i++) {
	                var child = nodes[i];
	                if (child != null) {
	                    if (child.attributes.getNamedItem(paramName).value == paramValue) {
	                        fragment.appendChild(child);
	                    }
	                }
	            }
	        }
	        return fragment.childNodes;
	    };
	    XmlUtils.strToXml = function (str) {
	        var parser = new DOMParser();
	        var node = parser.parseFromString(str, "text/xml");
	        return node;
	    };
	    XmlUtils.nodeToString = function (node) {
	        if (!node)
	            return "";
	        var str = (new XMLSerializer()).serializeToString(node);
	        return str;
	    };
	    XmlUtils.readAttributeValue = function (node, attrName) {
	        var attrs = node.attributes;
	        if (attrs == undefined) {
	            return "";
	        }
	        var attribute = attrs.getNamedItem(attrName);
	        if (!attribute) {
	            //console.log("XmlUltils - readAttributeValue() - name: " + attrName + ", attribute does not exist.";
	            return "";
	        }
	        //console.log("XmlUltils - readAttributeValue() - name: " + attrName + ", value: " + attribute.value);
	        return attribute.value;
	    };
	    XmlUtils.writeAttributeValue = function (node, attrName, attrValue) {
	        var attribute = document.createAttribute(attrName);
	        attribute.value = attrValue;
	        attribute = node.attributes.setNamedItem(attribute);
	        console.log("XmlUltils - writeAttributeValue() - name: " + attribute.name + ", value: " + attribute.value);
	    };
	    XmlUtils.hasAttribute = function (node, attrName) {
	        var attrs = node.attributes;
	        if (attrs == undefined) {
	            return false;
	        }
	        var attribute = attrs.getNamedItem(attrName);
	        return attribute != null;
	    };
	    return XmlUtils;
	}());
	exports.XmlUtils = XmlUtils;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = XmlUtils;


/***/ },
/* 300 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var WaveAudio_1 = __webpack_require__(301);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var ParserBase_1 = __webpack_require__(289);
	var ByteArray_1 = __webpack_require__(292);
	var WaveAudioParser = (function (_super) {
	    __extends(WaveAudioParser, _super);
	    function WaveAudioParser() {
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.BLOB);
	    }
	    WaveAudioParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "wav" || extension == "mp3" || extension == "ogg";
	    };
	    WaveAudioParser.supportsData = function (data) {
	        if (!(data instanceof ByteArray_1.ByteArray))
	            return false;
	        var ba = data;
	        var filetype = WaveAudioParser.parseFileType(ba);
	        return filetype ? true : false;
	    };
	    WaveAudioParser.prototype._pStartParsing = function (frameLimit) {
	        //clear content
	        delete this._pContent;
	        this._pContent = null;
	        _super.prototype._pStartParsing.call(this, frameLimit);
	    };
	    WaveAudioParser.prototype._pProceedParsing = function () {
	        if (this.data instanceof ByteArray_1.ByteArray) {
	            this._pContent = new WaveAudio_1.WaveAudio(this.data.arraybytes);
	            this._pFinalizeAsset(this._pContent, this._iFileName);
	        }
	        else if (this.data instanceof ArrayBuffer) {
	            this._pContent = new WaveAudio_1.WaveAudio(this.data);
	            this._pFinalizeAsset(this._pContent, this._iFileName);
	        }
	        return ParserBase_1.ParserBase.PARSING_DONE;
	    };
	    WaveAudioParser.parseFileType = function (ba) {
	        //old mp3 detections
	        // This does not seem to work for all my mp3 files (i tested different mp3 encoders)
	        // I leave it in, because it might work for mp3 data that i do not have here to test
	        ba.position = 0;
	        if ((ba.readUnsignedShort() & 0xFFE0) == 0xFFE0) {
	            return 'mp3'; // test for MP3 syncword
	        }
	        // new mp3 detection
	        // this from is-mp3 npm module,
	        // but still i have mp3 files that are not detected by this
	        // i added the hack: (byte_1 === 255 && byte_2 === 243 && byte_3 === 130) 	to catch those mp3s
	        // todo: find a more foolproof way to detect al mp3 (my hack might collide with detection for other filetypes)
	        ba.position = 0;
	        var byte_1 = ba.readUnsignedByte();
	        var byte_2 = ba.readUnsignedByte();
	        var byte_3 = ba.readUnsignedByte();
	        if ((byte_1 === 73 && byte_2 === 68 && byte_3 === 51)
	            || (byte_1 === 255 && byte_2 === 251)
	            || (byte_1 === 255 && byte_2 === 243 && byte_3 === 130)) {
	            return 'mp3';
	        }
	        ba.position = 0;
	        if (ba.readUTFBytes(4) == 'RIFF')
	            return 'wav';
	        ba.position = 0;
	        if (ba.readUTFBytes(4) == 'OggS')
	            return 'ogg';
	        ba.position = 0;
	        return null;
	    };
	    return WaveAudioParser;
	}(ParserBase_1.ParserBase));
	exports.WaveAudioParser = WaveAudioParser;


/***/ },
/* 301 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AudioManager_1 = __webpack_require__(302);
	var AssetBase_1 = __webpack_require__(6);
	// TODO: Audio should probably be an interface containing play/stop/seek functionality
	var WaveAudio = (function (_super) {
	    __extends(WaveAudio, _super);
	    /**
	     *
	     */
	    function WaveAudio(buffer) {
	        _super.call(this);
	        this._volume = 1;
	        this._buffer = buffer;
	    }
	    Object.defineProperty(WaveAudio.prototype, "assetType", {
	        /**
	         *
	         * @returns {string}
	         */
	        get: function () {
	            return WaveAudio.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WaveAudio.prototype, "volume", {
	        get: function () {
	            return this._volume;
	        },
	        set: function (value) {
	            if (this._volume == value)
	                return;
	            this._volume = value;
	            if (this._audioChannel)
	                this._audioChannel.volume = this._volume;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WaveAudio.prototype, "currentTime", {
	        get: function () {
	            if (this._audioChannel)
	                return this._audioChannel.currentTime;
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WaveAudio.prototype, "duration", {
	        get: function () {
	            if (this._audioChannel)
	                return this._audioChannel.duration;
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    WaveAudio.prototype.dispose = function () {
	        this.stop();
	    };
	    WaveAudio.prototype.play = function (offset, loop) {
	        if (loop === void 0) { loop = false; }
	        this._audioChannel = AudioManager_1.AudioManager.getChannel(this._buffer.byteLength);
	        if (this._audioChannel) {
	            this._audioChannel.volume = this._volume;
	            this._audioChannel.play(this._buffer, offset, loop, this.id);
	        }
	    };
	    WaveAudio.prototype.stop = function () {
	        if (this._audioChannel)
	            this._audioChannel.stop();
	        delete this._audioChannel;
	        this._audioChannel = null;
	    };
	    WaveAudio.prototype.clone = function () {
	        var newInstance = new WaveAudio(this._buffer);
	        newInstance.name = this.name;
	        return newInstance;
	    };
	    WaveAudio.assetType = "[asset WaveAudio]";
	    return WaveAudio;
	}(AssetBase_1.AssetBase));
	exports.WaveAudio = WaveAudio;


/***/ },
/* 302 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var StreamingAudioChannel_1 = __webpack_require__(303);
	var WebAudioChannel_1 = __webpack_require__(304);
	var AudioManager = (function () {
	    function AudioManager() {
	    }
	    AudioManager.setExternalSoundInterface = function (new_obj) {
	        if (new_obj.startSound == null) {
	            console.log("Could not set the externalSoundInterface, because it does not provide a 'startSound' function");
	            return;
	        }
	        if (new_obj.stopSound == null) {
	            console.log("Could not set the externalSoundInterface, because it does not provide a 'stopSound' function");
	            return;
	        }
	        AudioManager._externalSoundInterface = new_obj;
	    };
	    AudioManager.getExternalSoundInterface = function () {
	        return AudioManager._externalSoundInterface;
	    };
	    AudioManager.getChannel = function (byteLength) {
	        //choose best audio channel by bytelength
	        //todo: StreamingAudioChannel doesnt seem to be working. no error, but also no sound is playing
	        var channelClass = (byteLength > 50000) ? StreamingAudioChannel_1.StreamingAudioChannel : WebAudioChannel_1.WebAudioChannel;
	        //var channelClass:IAudioChannelClass = WebAudioChannel;
	        var i = 0;
	        while (channelClass._channels[i] && channelClass._channels[i].isPlaying())
	            i++;
	        if (i == channelClass.maxChannels) {
	            //pick the oldest channel to reuse, ignoring looping channels
	            var channel;
	            var len = channelClass._channels.length;
	            for (var j = 0; j < len; j++) {
	                channel = channelClass._channels[j];
	                if (!channel.isLooping() && !channel.isDecoding()) {
	                    channelClass._channels.push(channelClass._channels.splice(j, 1)[0]);
	                    channel.stop();
	                    return channel;
	                }
	            }
	            //do not return channel until one is freed up
	            return null;
	        }
	        return channelClass._channels[i] || (channelClass._channels[i] = new channelClass());
	    };
	    //todo: make AudioPlaybackManager keep track of active sounds + implement global playback control
	    AudioManager._externalSoundInterface = null;
	    return AudioManager;
	}());
	exports.AudioManager = AudioManager;


/***/ },
/* 303 */
/***/ function(module, exports) {

	"use strict";
	var StreamingAudioChannel = (function () {
	    function StreamingAudioChannel() {
	        var _this = this;
	        this._isPlaying = false;
	        this._isLooping = false;
	        this._startTime = 0;
	        this._sourceOpenDelegate = function (event) { return _this._sourceOpen(event); };
	        this._updateEndDelegate = function (event) { return _this._updateEnd(event); };
	        this._audio = new Audio();
	        this._audio.ontimeupdate = function (event) { return _this._onTimeUpdate(event); };
	        this._updateSource();
	    }
	    Object.defineProperty(StreamingAudioChannel.prototype, "duration", {
	        get: function () {
	            return this._duration;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StreamingAudioChannel.prototype, "currentTime", {
	        get: function () {
	            return this._audio.currentTime - this._startTime;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StreamingAudioChannel.prototype, "volume", {
	        get: function () {
	            return this._volume;
	        },
	        set: function (value) {
	            if (this._volume == value)
	                return;
	            this._volume = value;
	            this._audio.volume = this._volume;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    StreamingAudioChannel.prototype.isPlaying = function () {
	        return this._isPlaying;
	    };
	    StreamingAudioChannel.prototype.isLooping = function () {
	        return this._isLooping;
	    };
	    StreamingAudioChannel.prototype.isDecoding = function () {
	        return false;
	    };
	    StreamingAudioChannel.prototype.play = function (buffer, offset, loop) {
	        if (offset === void 0) { offset = 0; }
	        if (loop === void 0) { loop = false; }
	        this._isPlaying = true;
	        if (this._isLooping || this._isLooping != loop) {
	            this._isLooping = loop;
	            this._sourceDirty = true;
	        }
	        if (this._sourceDirty)
	            this._updateSource();
	        this._buffer = buffer;
	        this._offset = offset;
	        if (!this._isQueuing && !this._isOpening)
	            this._queueBuffer();
	    };
	    StreamingAudioChannel.prototype.stop = function () {
	        this._audio.pause();
	        this._isPlaying = false;
	        this._isLooping = false;
	    };
	    StreamingAudioChannel.prototype._sourceOpen = function (event) {
	        this._isOpening = false;
	        //TODO: find out how in the name of all that is holy how this can be executed more than once on a MediaSource object
	        if (this._mediaSource.activeSourceBuffers.length) {
	            console.log("ERR: double sourceopen event called");
	            return;
	        }
	        this._sourceBuffer = this._mediaSource.addSourceBuffer('audio/mpeg');
	        this._sourceBuffer.addEventListener("updateend", this._updateEndDelegate);
	        if (this._isPlaying)
	            this._queueBuffer();
	    };
	    StreamingAudioChannel.prototype._queueBuffer = function () {
	        this._isQueuing = true;
	        this._startTime = this._sourceBuffer.timestampOffset;
	        this._sourceBuffer.appendBuffer(this._buffer);
	    };
	    StreamingAudioChannel.prototype._updateEnd = function (event) {
	        this._isQueuing = false;
	        if (this._isLooping)
	            this._mediaSource.endOfStream();
	        this._duration = this._sourceBuffer.timestampOffset - this._startTime;
	        this._audio.currentTime = this._startTime + this._offset;
	        this._audio.play();
	    };
	    StreamingAudioChannel.prototype._onTimeUpdate = function (event) {
	        //TODO: more accurate end detection
	        if (!this._isLooping && this._duration < this._audio.currentTime - this._startTime + 0.1)
	            this.stop();
	    };
	    StreamingAudioChannel.prototype._updateSource = function () {
	        if (this._mediaSource)
	            this._disposeSource();
	        this._isQueuing = false;
	        this._isOpening = true;
	        this._mediaSource = new MediaSource();
	        this._mediaSource.addEventListener("sourceopen", this._sourceOpenDelegate);
	        this._urlString = URL.createObjectURL(this._mediaSource);
	        this._audio.src = this._urlString;
	        this._audio.loop = this._isLooping;
	        this._sourceDirty = false;
	    };
	    StreamingAudioChannel.prototype._disposeSource = function () {
	        if (!this._isOpening) {
	            if (this._sourceBuffer.timestampOffset)
	                this._sourceBuffer.remove(0, this._sourceBuffer.timestampOffset);
	            this._sourceBuffer.removeEventListener("updateend", this._updateEndDelegate);
	            this._mediaSource.removeSourceBuffer(this._sourceBuffer);
	            delete this._sourceBuffer;
	            this._sourceBuffer = null;
	        }
	        this._mediaSource.removeEventListener("sourceopen", this._sourceOpenDelegate);
	        URL.revokeObjectURL(this._urlString);
	        delete this._mediaSource;
	        this._mediaSource = null;
	    };
	    StreamingAudioChannel.maxChannels = 4;
	    StreamingAudioChannel._channels = new Array();
	    return StreamingAudioChannel;
	}());
	exports.StreamingAudioChannel = StreamingAudioChannel;


/***/ },
/* 304 */
/***/ function(module, exports) {

	"use strict";
	var WebAudioChannel = (function () {
	    function WebAudioChannel() {
	        var _this = this;
	        this._isPlaying = false;
	        this._isLooping = false;
	        this._isDecoding = false;
	        this._volume = 1;
	        this._startTime = 0;
	        this._audioCtx = WebAudioChannel._audioCtx || (WebAudioChannel._audioCtx = new (window["AudioContext"] || window["webkitAudioContext"])());
	        this._gainNode = this._audioCtx.createGain();
	        this._gainNode.gain.value = this._volume;
	        this._gainNode.connect(this._audioCtx.destination);
	        this._onEndedDelegate = function (event) { return _this._onEnded(event); };
	    }
	    Object.defineProperty(WebAudioChannel.prototype, "duration", {
	        get: function () {
	            return this._duration;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebAudioChannel.prototype, "currentTime", {
	        get: function () {
	            return this._audioCtx.currentTime - this._startTime;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(WebAudioChannel.prototype, "volume", {
	        get: function () {
	            return this._volume;
	        },
	        set: function (value) {
	            if (this._volume == value)
	                return;
	            this._volume = value;
	            this._gainNode.gain.value = this._volume;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    WebAudioChannel.prototype.isPlaying = function () {
	        return this._isPlaying;
	    };
	    WebAudioChannel.prototype.isLooping = function () {
	        return this._isLooping;
	    };
	    WebAudioChannel.prototype.isDecoding = function () {
	        return this._isDecoding;
	    };
	    WebAudioChannel.prototype.play = function (buffer, offset, loop, id) {
	        var _this = this;
	        if (offset === void 0) { offset = 0; }
	        if (loop === void 0) { loop = false; }
	        if (id === void 0) { id = 0; }
	        this._isPlaying = true;
	        this._isLooping = loop;
	        this._currentTime = offset;
	        this._id = id;
	        this._isDecoding = true;
	        //fast path for short sounds
	        if (WebAudioChannel._decodeCache[id])
	            this._onDecodeComplete(WebAudioChannel._decodeCache[id]);
	        else if (!WebAudioChannel._errorCache[id])
	            this._audioCtx.decodeAudioData(buffer, function (buffer) { return _this._onDecodeComplete(buffer); }, function (event) { return _this._onError(event); });
	        else
	            this.stop();
	    };
	    WebAudioChannel.prototype.stop = function () {
	        if (!this._isPlaying)
	            return;
	        this._isPlaying = false;
	        this._isLooping = false;
	        this._isDecoding = false;
	        if (this._source)
	            this._disposeSource();
	    };
	    WebAudioChannel.prototype._onDecodeComplete = function (buffer) {
	        if (!this._isPlaying)
	            return;
	        this._isDecoding = false;
	        //if (buffer.duration < 2) //cache all buffers?
	        WebAudioChannel._decodeCache[this._id] = buffer;
	        if (this._source)
	            this._disposeSource();
	        this._source = this._audioCtx.createBufferSource();
	        this._source.loop = this._isLooping;
	        this._source.connect(this._gainNode);
	        this._source.buffer = buffer;
	        this._duration = buffer.duration;
	        this._startTime = this._audioCtx.currentTime - this._currentTime;
	        this._source.onended = this._onEndedDelegate;
	        try {
	            this._source.start(this._audioCtx.currentTime, this._currentTime);
	        }
	        catch (error) {
	            console.log("Error starting audio: " + error);
	            this._disposeSource();
	        }
	    };
	    WebAudioChannel.prototype._onError = function (event) {
	        console.log("Error with decoding audio data");
	        WebAudioChannel._errorCache[this._id] = true;
	        this.stop();
	    };
	    WebAudioChannel.prototype._onEnded = function (event) {
	        this.stop();
	    };
	    WebAudioChannel.prototype._disposeSource = function () {
	        //clean up
	        this._source.stop(this._audioCtx.currentTime);
	        this._source.onended = null;
	        this._source.disconnect();
	        delete this._source.buffer;
	        delete this._source;
	        this._source = null;
	    };
	    WebAudioChannel.maxChannels = 64;
	    WebAudioChannel._channels = new Array();
	    WebAudioChannel._decodeCache = new Object();
	    WebAudioChannel._errorCache = new Object();
	    return WebAudioChannel;
	}());
	exports.WebAudioChannel = WebAudioChannel;


/***/ },
/* 305 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var Float3Attributes_1 = __webpack_require__(15);
	var Float2Attributes_1 = __webpack_require__(14);
	var Byte4Attributes_1 = __webpack_require__(12);
	var BitmapImageCube_1 = __webpack_require__(123);
	var BlendMode_1 = __webpack_require__(131);
	var Sampler2D_1 = __webpack_require__(121);
	var ColorTransform_1 = __webpack_require__(27);
	var Matrix3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(34);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequest_1 = __webpack_require__(296);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var PerspectiveProjection_1 = __webpack_require__(143);
	var OrthographicProjection_1 = __webpack_require__(306);
	var OrthographicOffCenterProjection_1 = __webpack_require__(307);
	var ByteArray_1 = __webpack_require__(292);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var Graphics_1 = __webpack_require__(178);
	var TriangleElements_1 = __webpack_require__(179);
	var DirectionalLight_1 = __webpack_require__(149);
	var PointLight_1 = __webpack_require__(196);
	var Camera_1 = __webpack_require__(139);
	var Sprite_1 = __webpack_require__(177);
	var Billboard_1 = __webpack_require__(112);
	var Skybox_1 = __webpack_require__(130);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var StaticLightPicker_1 = __webpack_require__(218);
	var CubeMapShadowMapper_1 = __webpack_require__(197);
	var DirectionalShadowMapper_1 = __webpack_require__(152);
	var PrefabBase_1 = __webpack_require__(308);
	var PrimitiveCapsulePrefab_1 = __webpack_require__(309);
	var PrimitiveConePrefab_1 = __webpack_require__(311);
	var PrimitiveCubePrefab_1 = __webpack_require__(313);
	var PrimitiveCylinderPrefab_1 = __webpack_require__(312);
	var PrimitivePlanePrefab_1 = __webpack_require__(314);
	var PrimitiveSpherePrefab_1 = __webpack_require__(315);
	var PrimitiveTorusPrefab_1 = __webpack_require__(316);
	var SingleCubeTexture_1 = __webpack_require__(132);
	var Single2DTexture_1 = __webpack_require__(136);
	var VertexAnimationSet_1 = __webpack_require__(317);
	var VertexAnimator_1 = __webpack_require__(322);
	var SkeletonAnimationSet_1 = __webpack_require__(326);
	var SkeletonAnimator_1 = __webpack_require__(327);
	var JointPose_1 = __webpack_require__(328);
	var Skeleton_1 = __webpack_require__(332);
	var SkeletonPose_1 = __webpack_require__(330);
	var SkeletonJoint_1 = __webpack_require__(333);
	var SkeletonClipNode_1 = __webpack_require__(334);
	var VertexClipNode_1 = __webpack_require__(340);
	var MethodMaterialMode_1 = __webpack_require__(284);
	var MethodMaterial_1 = __webpack_require__(285);
	var AmbientEnvMapMethod_1 = __webpack_require__(228);
	var DiffuseDepthMethod_1 = __webpack_require__(234);
	var DiffuseCelMethod_1 = __webpack_require__(232);
	var DiffuseGradientMethod_1 = __webpack_require__(235);
	var DiffuseLightMapMethod_1 = __webpack_require__(236);
	var DiffuseWrapMethod_1 = __webpack_require__(238);
	var EffectAlphaMaskMethod_1 = __webpack_require__(239);
	var EffectColorMatrixMethod_1 = __webpack_require__(241);
	var EffectColorTransformMethod_1 = __webpack_require__(242);
	var EffectEnvMapMethod_1 = __webpack_require__(243);
	var EffectFogMethod_1 = __webpack_require__(244);
	var EffectFresnelEnvMapMethod_1 = __webpack_require__(245);
	var EffectLightMapMethod_1 = __webpack_require__(246);
	var EffectRimLightMethod_1 = __webpack_require__(249);
	var NormalSimpleWaterMethod_1 = __webpack_require__(252);
	var ShadowDitheredMethod_1 = __webpack_require__(255);
	var ShadowFilteredMethod_1 = __webpack_require__(257);
	var SpecularFresnelMethod_1 = __webpack_require__(266);
	var ShadowHardMethod_1 = __webpack_require__(258);
	var SpecularAnisotropicMethod_1 = __webpack_require__(262);
	var SpecularCelMethod_1 = __webpack_require__(264);
	var SpecularPhongMethod_1 = __webpack_require__(267);
	var ShadowNearMethod_1 = __webpack_require__(259);
	var ShadowSoftMethod_1 = __webpack_require__(260);
	var AS2SceneGraphFactory_1 = __webpack_require__(342);
	var Timeline_1 = __webpack_require__(26);
	var AssetLibrary_1 = __webpack_require__(211);
	var Font_1 = __webpack_require__(354);
	var TesselatedFontTable_1 = __webpack_require__(355);
	var TextFormat_1 = __webpack_require__(358);
	var AWDBlock_1 = __webpack_require__(359);
	var Rectangle_1 = __webpack_require__(57);
	var Style_1 = __webpack_require__(24);
	var Matrix_1 = __webpack_require__(102);
	var MappingMode_1 = __webpack_require__(137);
	var ElementsType_1 = __webpack_require__(203);
	/**
	 * AWDParser provides a parser for the AWD data type.
	 */
	var AWDParser = (function (_super) {
	    __extends(AWDParser, _super);
	    /**
	     * Creates a new AWD3Parserutils object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function AWDParser(view) {
	        if (view === void 0) { view = null; }
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.ARRAY_BUFFER);
	        //set to "true" to have some console.logs in the Console
	        this._debug = false;
	        this._debugTimers = true;
	        this._startedParsing = false;
	        this._texture_users = {};
	        this._parsed_header = false;
	        this._time_all = 0;
	        this._time_graphics = 0;
	        this._time_graphics_bytes = 0;
	        this._time_timeline = 0;
	        this._time_fonts = 0;
	        this._time_textfields = 0;
	        this._time_sounds = 0;
	        this._time_textures = 0;
	        this._time_materials = 0;
	        this._time_sprites = 0;
	        this._num_graphics = 0;
	        this._num_timeline = 0;
	        this._num_fonts = 0;
	        this._num_textfields = 0;
	        this._num_sounds = 0;
	        this._num_textures = 0;
	        this._num_materials = 0;
	        this._num_sprites = 0;
	        //--Parser UTILS---------------------------------------------------------------------------
	        this.shadowMethodListProperties = {
	            1: AWDParser.BADDR,
	            2: AWDParser.BADDR,
	            3: AWDParser.BADDR,
	            101: AWDParser.PROPERTY_NUMBER,
	            102: AWDParser.PROPERTY_NUMBER,
	            103: AWDParser.PROPERTY_NUMBER,
	            201: AWDParser.UINT32,
	            202: AWDParser.UINT32,
	            301: AWDParser.UINT16,
	            302: AWDParser.UINT16,
	            401: AWDParser.UINT8,
	            402: AWDParser.UINT8,
	            601: AWDParser.COLOR,
	            602: AWDParser.COLOR,
	            701: AWDParser.BOOL,
	            702: AWDParser.BOOL,
	            801: AWDParser.MTX4x4 };
	        this.spritePoseAnimationProperties = {
	            1: AWDParser.BOOL,
	            2: AWDParser.BOOL };
	        this.sharedMethodListProperties = {
	            1: AWDParser.BADDR,
	            2: AWDParser.BADDR,
	            3: AWDParser.BADDR,
	            101: AWDParser.PROPERTY_NUMBER,
	            102: AWDParser.PROPERTY_NUMBER,
	            103: AWDParser.PROPERTY_NUMBER,
	            104: AWDParser.PROPERTY_NUMBER,
	            105: AWDParser.PROPERTY_NUMBER,
	            106: AWDParser.PROPERTY_NUMBER,
	            107: AWDParser.PROPERTY_NUMBER,
	            201: AWDParser.UINT32,
	            202: AWDParser.UINT32,
	            301: AWDParser.UINT16,
	            302: AWDParser.UINT16,
	            401: AWDParser.UINT8,
	            402: AWDParser.UINT8,
	            601: AWDParser.COLOR,
	            602: AWDParser.COLOR,
	            701: AWDParser.BOOL,
	            702: AWDParser.BOOL };
	        this._view = view;
	        this._blocks = new Array();
	        this._blocks[0] = new AWDBlock_1.AWDBlock(0, 255);
	        this._blocks[0].data = null; // Zero address means null in AWD
	        this.blendModeDic = new Array(); // used to translate ints to blendMode-strings
	        this.blendModeDic.push(BlendMode_1.BlendMode.NORMAL);
	        this.blendModeDic.push(BlendMode_1.BlendMode.ADD);
	        this.blendModeDic.push(BlendMode_1.BlendMode.ALPHA);
	        this.blendModeDic.push(BlendMode_1.BlendMode.DARKEN);
	        this.blendModeDic.push(BlendMode_1.BlendMode.DIFFERENCE);
	        this.blendModeDic.push(BlendMode_1.BlendMode.ERASE);
	        this.blendModeDic.push(BlendMode_1.BlendMode.HARDLIGHT);
	        this.blendModeDic.push(BlendMode_1.BlendMode.INVERT);
	        this.blendModeDic.push(BlendMode_1.BlendMode.LAYER);
	        this.blendModeDic.push(BlendMode_1.BlendMode.LIGHTEN);
	        this.blendModeDic.push(BlendMode_1.BlendMode.MULTIPLY);
	        this.blendModeDic.push(BlendMode_1.BlendMode.NORMAL);
	        this.blendModeDic.push(BlendMode_1.BlendMode.OVERLAY);
	        this.blendModeDic.push(BlendMode_1.BlendMode.SCREEN);
	        this.blendModeDic.push(BlendMode_1.BlendMode.SHADER);
	        this.blendModeDic.push(BlendMode_1.BlendMode.OVERLAY);
	        this._depthSizeDic = new Array(); // used to translate ints to depthSize-values
	        this._depthSizeDic.push(256);
	        this._depthSizeDic.push(512);
	        this._depthSizeDic.push(2048);
	        this._depthSizeDic.push(1024);
	        this._version = Array(); // will contain 2 int (major-version, minor-version) for awd-version-check
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    AWDParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "awd";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    AWDParser.supportsData = function (data) {
	        return (ParserUtils_1.ParserUtils.toString(data, 3) == 'AWD');
	    };
	    /**
	     * @inheritDoc
	     */
	    AWDParser.prototype._iResolveDependency = function (resourceDependency) {
	        // this will be called when Dependency has finished loading.
	        // the ressource dependecniy has a id that point to the awd_block waiting for it.
	        //console.log("AWDParser resolve dependencies";
	        if (resourceDependency.assets.length == 1) {
	            var this_block = this._blocks[parseInt(resourceDependency.id)];
	            if (this_block.type == 82) {
	                var image_asset = resourceDependency.assets[0];
	                this_block.data = image_asset; // Store finished asset
	                // Finalize texture asset to dispatch texture event, which was
	                // previously suppressed while the dependency was loaded.
	                this._pFinalizeAsset(image_asset, this_block.name);
	                if (this._debug)
	                    console.log("Parsed Texture: Name = " + this_block.name);
	            }
	            else if (this_block.type == 44) {
	                var audio_asset = resourceDependency.assets[0];
	                this_block.data = audio_asset; // Store finished asset
	                // Finalize texture asset to dispatch texture event, which was
	                // previously suppressed while the dependency was loaded.
	                //console.log("Parsing audio " + this_block.name);
	                this._pFinalizeAsset(audio_asset, this_block.name);
	                if (this._debug)
	                    console.log("Parsed WaveAudio: Name = " + this_block.name);
	            }
	            else if (this_block.type == 83) {
	                this_block.loaded_dependencies[resourceDependency.sub_id] = resourceDependency.assets[0];
	                this_block.loaded_dependencies_cnt++;
	                if (this._debug)
	                    console.log("Successfully loaded Bitmap " + resourceDependency.sub_id + " / 6 for Cubetexture");
	                if (this_block.loaded_dependencies_cnt == 6) {
	                    var cube_image_asset = new BitmapImageCube_1.BitmapImageCube(this_block.loaded_dependencies[0].width);
	                    for (var i = 0; i < 6; i++)
	                        cube_image_asset.draw(i, this_block.loaded_dependencies[i]);
	                    this_block.data = cube_image_asset; // Store finished asset
	                    this._pFinalizeAsset(cube_image_asset, this_block.name);
	                    if (this._debug)
	                        console.log("Parsed CubeTexture: Name = " + this_block.name);
	                }
	            }
	            if (this._debugTimers && !this._isParsing)
	                this.updateTimers(this_block.type);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AWDParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        //not used - if a dependcy fails, the awaiting Texture or CubeTexture will never be finalized, and the default-bitmaps will be used.
	        // this means, that if one Bitmap of a CubeTexture fails, the CubeTexture will have the DefaultTexture applied for all six Bitmaps.
	    };
	    /**
	     * Resolve a dependency name
	     *
	     * @param resourceDependency The dependency to be resolved.
	     */
	    AWDParser.prototype._iResolveDependencyName = function (resourceDependency, asset) {
	        var oldName = asset.name;
	        if (asset) {
	            var block = this._blocks[parseInt(resourceDependency.id)];
	            // Reset name of texture to the one defined in the AWD file,
	            // as opposed to whatever the image parser came up with.
	            asset.resetAssetPath(block.name, null, true);
	        }
	        var newName = asset.name;
	        asset.name = oldName;
	        return newName;
	    };
	    /**
	     * @inheritDoc
	     */
	    AWDParser.prototype._pProceedParsing = function () {
	        if (!this._startedParsing) {
	            this._byteData = this._pGetByteData(); //getByteData();
	            this._startedParsing = true;
	        }
	        if (!this._parsed_header) {
	            //----------------------------------------------------------------------------
	            // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
	            //----------------------------------------------------------------------------
	            //this._byteData.endian = Endian.LITTLE_ENDIAN;
	            //----------------------------------------------------------------------------
	            //----------------------------------------------------------------------------
	            // Parse header and decompress body if needed
	            this.parseHeader();
	            switch (this._compression) {
	                case AWDParser.DEFLATE:
	                case AWDParser.LZMA:
	                    this._pDieWithError('Compressed AWD formats not yet supported');
	                    break;
	                case AWDParser.UNCOMPRESSED:
	                    this._body = this._byteData;
	                    break;
	            }
	            this._parsed_header = true;
	        }
	        if (this._body) {
	            while (this._body.getBytesAvailable() > 0 && !this.parsingPaused)
	                this.parseNextBlock();
	            //----------------------------------------------------------------------------
	            // Return complete status
	            if (this._body.getBytesAvailable() == 0) {
	                this.dispose();
	                if (this._debugTimers)
	                    console.log("Parsing total: " + (this._time_all | 0) + "ms", " | graphics: " + this._num_graphics + ", " + (this._time_graphics | 0) + "ms", " | graphics bytes: " + this._num_graphics + ", " + (this._time_graphics_bytes | 0) + "ms", " | timelines: " + this._num_timeline + ", " + (this._time_timeline | 0) + "ms", " | fonts: " + this._num_fonts + ", " + (this._time_fonts | 0) + "ms", " | sounds: " + this._num_sounds + ", " + (this._time_sounds | 0) + "ms", " | mats: " + this._num_materials + ", " + (this._time_materials | 0) + "ms", " | textures: " + this._num_textures + ", " + (this._time_textures | 0) + "ms", " | sprites: " + this._num_sprites + ", " + (this._time_sprites | 0) + "ms");
	                return ParserBase_1.ParserBase.PARSING_DONE;
	            }
	            else {
	                return ParserBase_1.ParserBase.MORE_TO_PARSE;
	            }
	        }
	        else {
	            switch (this._compression) {
	                case AWDParser.DEFLATE:
	                case AWDParser.LZMA:
	                    if (this._debug)
	                        console.log("(!) AWDParser Error: Compressed AWD formats not yet supported (!)");
	                    break;
	            }
	            // Error - most likely _body not set because we do not support compression.
	            return ParserBase_1.ParserBase.PARSING_DONE;
	        }
	    };
	    AWDParser.prototype._pStartParsing = function (frameLimit) {
	        //create a content object for Loaders
	        this._pContent = new DisplayObjectContainer_1.DisplayObjectContainer();
	        _super.prototype._pStartParsing.call(this, frameLimit);
	    };
	    AWDParser.prototype.dispose = function () {
	        for (var c in this._blocks) {
	            var b = this._blocks[c];
	            b.dispose();
	        }
	    };
	    AWDParser.prototype.parseNextBlock = function () {
	        var block;
	        var isParsed = false;
	        var ns;
	        var type;
	        var flags;
	        var len;
	        //*
	        if (this._debugTimers)
	            this.start_timeing = performance.now();
	        //*/
	        this._cur_block_id = this._body.readUnsignedInt();
	        ns = this._body.readUnsignedByte();
	        type = this._body.readUnsignedByte();
	        flags = this._body.readUnsignedByte();
	        len = this._body.readUnsignedInt();
	        var blockCompression = BitFlags.test(flags, BitFlags.FLAG4);
	        var blockCompressionLZMA = BitFlags.test(flags, BitFlags.FLAG5);
	        if (this._accuracyOnBlocks) {
	            this._accuracyMatrix = BitFlags.test(flags, BitFlags.FLAG1);
	            this._accuracyGeo = BitFlags.test(flags, BitFlags.FLAG2);
	            this._accuracyProps = BitFlags.test(flags, BitFlags.FLAG3);
	        }
	        var blockEndAll = this._body.position + len;
	        if (len > this._body.getBytesAvailable()) {
	            this._pDieWithError('AWD2 block length is bigger than the bytes that are available!');
	            this._body.position += this._body.getBytesAvailable();
	            return;
	        }
	        //----------------------------------------------------------------------------
	        // Compressed AWD Formats not yet supported
	        if (blockCompression) {
	            this._pDieWithError('Compressed AWD formats not yet supported');
	            this._newBlockBytes = new ByteArray_1.ByteArray();
	            this._body.readBytes(this._newBlockBytes, 0, len);
	            this._newBlockBytes.position = 0;
	        }
	        else {
	            this._newBlockBytes = this._body;
	        }
	        //----------------------------------------------------------------------------
	        // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
	        //----------------------------------------------------------------------------
	        //this._newBlockBytes.endian = Endian.LITTLE_ENDIAN;
	        //----------------------------------------------------------------------------
	        block = new AWDBlock_1.AWDBlock(this._cur_block_id, type);
	        block.len = len;
	        var blockEndBlock = this._newBlockBytes.position + len;
	        if (blockCompression) {
	            this._pDieWithError('Compressed AWD formats not yet supported');
	        }
	        if (this._debug)
	            console.log("AWDBlock:  ID = " + this._cur_block_id + " | TypeID = " + type + " | Compression = " + blockCompression + " | Matrix-Precision = " + this._accuracyMatrix + " | Graphics-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
	        this._blocks[this._cur_block_id] = block;
	        if ((this._version[0] == 3) && (this._version[1] == 0)) {
	            // probably should contain some info about the type of animation
	            var factory = new AS2SceneGraphFactory_1.AS2SceneGraphFactory(this._view);
	            switch (type) {
	                case 24:
	                    this.parseSpriteLibraryBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 25:
	                    this.parseBillBoardLibraryBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 44:
	                    this.parseAudioBlock(this._cur_block_id, factory);
	                    isParsed = true;
	                    break;
	                case 133:
	                    this.parseMovieClip(this._cur_block_id, factory);
	                    isParsed = true;
	                    break;
	                case 134:
	                    this.parseTextField(this._cur_block_id, factory);
	                    isParsed = true;
	                    break;
	                case 135:
	                    this.parseTesselatedFont(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 136:
	                    this.parseTextFormat(this._cur_block_id);
	                    isParsed = true;
	                    break;
	            }
	        }
	        if ((this._version[0] > 2) || ((this._version[0] >= 2) && (this._version[1] >= 1))) {
	            switch (type) {
	                case 11:
	                    this.parsePrimitves(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 31:
	                    this.parseSkyboxInstance(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 41:
	                    this.parseLight(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 42:
	                    this.parseCamera(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                //  case 43:
	                //      parseTextureProjector(_cur_block_id);
	                //      isParsed = true;
	                //      break;
	                case 51:
	                    this.parseLightPicker(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 81:
	                    this.parseMaterial_v1(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 83:
	                    this.parseCubeTexture(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 91:
	                    this.parseSharedMethodBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 92:
	                    this.parseShadowMethodBlock(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 111:
	                    this.parseSpritePoseAnimation(this._cur_block_id, true);
	                    isParsed = true;
	                    break;
	                case 112:
	                    this.parseSpritePoseAnimation(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 113:
	                    this.parseVertexAnimationSet(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 122:
	                    this.parseAnimatorSet(this._cur_block_id);
	                    isParsed = true;
	                    break;
	                case 253:
	                    this.parseCommand(this._cur_block_id);
	                    isParsed = true;
	                    break;
	            }
	        }
	        if (isParsed == false) {
	            switch (type) {
	                case 1:
	                    this.parseGraphics(this._cur_block_id);
	                    break;
	                case 22:
	                    this.parseContainer(this._cur_block_id);
	                    break;
	                case 23:
	                    this.parseSpriteInstance(this._cur_block_id);
	                    break;
	                case 81:
	                    this.parseMaterial(this._cur_block_id);
	                    break;
	                case 82:
	                    this.parseTexture(this._cur_block_id);
	                    break;
	                case 101:
	                    this.parseSkeleton(this._cur_block_id);
	                    break;
	                case 102:
	                    this.parseSkeletonPose(this._cur_block_id);
	                    break;
	                case 103:
	                    this.parseSkeletonAnimation(this._cur_block_id);
	                    break;
	                case 121:
	                //this.parseUVAnimation(this._cur_block_id);
	                //break;
	                case 254:
	                    this.parseNameSpace(this._cur_block_id);
	                    break;
	                case 255:
	                    this.parseMetaData(this._cur_block_id);
	                    break;
	                default:
	                    if (this._debug)
	                        console.log("AWDBlock:   Unknown BlockType  (BlockID = " + this._cur_block_id + ") - Skip " + len + " bytes");
	                    this._newBlockBytes.position += len;
	                    break;
	            }
	        }
	        if (this._debug) {
	            if (this._newBlockBytes.position != blockEndBlock)
	                console.log("  (!)(!)(!) Error while reading AWDBlock ID " + this._cur_block_id + " = skip to next block");
	            if (block.errorMessages) {
	                var len = block.errorMessages.length;
	                for (var msgCnt = 0; msgCnt < len; msgCnt++)
	                    console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
	            }
	            console.log("\n");
	        }
	        if (this._debugTimers && !this.parsingPaused)
	            this.updateTimers(type);
	        this._body.position = blockEndAll;
	        this._newBlockBytes = null;
	    };
	    AWDParser.prototype.updateTimers = function (type) {
	        var end_timing = performance.now();
	        var time_delta = end_timing - this.start_timeing;
	        this._time_all += time_delta;
	        if (type == 1) {
	            this._time_graphics += time_delta;
	            this._num_graphics++;
	        }
	        else if (type == 133) {
	            this._time_timeline += time_delta;
	            this._num_timeline++;
	        }
	        else if (type == 135) {
	            this._time_fonts += time_delta;
	            this._num_fonts++;
	        }
	        else if (type == 134) {
	            this._time_textfields += time_delta;
	            this._num_textfields++;
	        }
	        else if (type == 44) {
	            this._time_sounds += time_delta;
	            this._num_sounds++;
	        }
	        else if (type == 82) {
	            this._time_textures += time_delta;
	            this._num_textures++;
	        }
	        else if (type == 81) {
	            this._time_materials += time_delta;
	            this._num_materials++;
	        }
	        else if (type == 24) {
	            this._time_sprites += time_delta;
	            this._num_sprites++;
	        }
	    };
	    //--Parser Blocks---------------------------------------------------------------------------
	    AWDParser.prototype.parseTesselatedFont = function (blockID) {
	        var name = this.parseVarStr();
	        this._blocks[blockID].name = name;
	        var new_font = AssetLibrary_1.AssetLibrary.getAsset(this._blocks[blockID].name);
	        var newfont = false;
	        if (new_font == undefined) {
	            new_font = new Font_1.Font();
	            newfont = true;
	        }
	        var font_style_cnt = this._newBlockBytes.readUnsignedInt();
	        var font_style_char_cnt;
	        var font_style_name;
	        var new_font_style;
	        var font_style_char;
	        var attr_count = 0;
	        var sm_len;
	        var sm_end;
	        var str_ftype, str_type, str_len, str_end;
	        for (var i = 0; i < font_style_cnt; ++i) {
	            font_style_name = this.parseVarStr();
	            // dirty hack for icycle
	            // we use bold chars for non-latin chars, but we use regular for � sign,
	            // so the dirty hack is to merge the regular and the bold style
	            if ((this._blocks[blockID].name == "Tahoma") && (font_style_name == "RegularStyle")) {
	                font_style_name = "BoldStyle";
	            }
	            new_font_style = new_font.get_font_table(font_style_name, TesselatedFontTable_1.TesselatedFontTable.assetType);
	            new_font_style.set_font_em_size(this._newBlockBytes.readUnsignedInt());
	            new_font_style.set_whitespace_width(this._newBlockBytes.readUnsignedInt());
	            new_font_style.ascent = this._newBlockBytes.readFloat();
	            new_font_style.descent = this._newBlockBytes.readFloat();
	            //console.log(new_font_style.get_whitespace_width());
	            font_style_char_cnt = this._newBlockBytes.readUnsignedInt();
	            for (var j = 0; j < font_style_char_cnt; ++j) {
	                // todo: this is basically a simplified version of the elements-parsing done in parseGraphics. Make a parseElements() instead (?)
	                font_style_char = this._newBlockBytes.readUnsignedInt();
	                var char_width = this._newBlockBytes.readFloat();
	                sm_len = this._newBlockBytes.readUnsignedInt();
	                sm_end = this._newBlockBytes.position + sm_len;
	                // Loop through data streams
	                while (this._newBlockBytes.position < sm_end) {
	                    // Type, field type, length
	                    str_type = this._newBlockBytes.readUnsignedByte();
	                    str_ftype = this._newBlockBytes.readUnsignedByte();
	                    str_len = this._newBlockBytes.readUnsignedInt();
	                    str_end = this._newBlockBytes.position + str_len;
	                    if (str_type == 2) {
	                        var indices = new Array();
	                        for (var idx = 0; this._newBlockBytes.position < str_end; idx++)
	                            indices[idx] = this._newBlockBytes.readUnsignedShort();
	                    }
	                    else if (str_type == 11) {
	                        attr_count = 20;
	                        var curveData = new ByteArray_1.ByteArray(str_len);
	                        this._newBlockBytes.readBytes(curveData, 0, str_len);
	                    }
	                    else if (str_type == 12) {
	                        attr_count = 12;
	                        var curveData = new ByteArray_1.ByteArray(str_len);
	                        this._newBlockBytes.readBytes(curveData, 0, str_len);
	                    }
	                    else if (str_type == 10) {
	                        attr_count = 28;
	                        var curveData = new ByteArray_1.ByteArray(str_len);
	                        this._newBlockBytes.readBytes(curveData, 0, str_len);
	                    }
	                    else {
	                        this._newBlockBytes.position = str_end;
	                    }
	                }
	                if (curveData) {
	                    var vertexBuffer = new AttributesBuffer_1.AttributesBuffer(attr_count, str_len / attr_count);
	                    vertexBuffer.bufferView = new Uint8Array(curveData.arraybytes);
	                    //console.log("allchars[cnt1++] = ['"+font_style_char.toString()+"',["+vertexBuffer.bufferView.toString()+"]]");
	                    new_font_style.setChar(font_style_char.toString(), char_width, vertexBuffer, null);
	                }
	            }
	        }
	        this.parseProperties(null);
	        this.parseUserAttributes();
	        if (newfont) {
	            this._pFinalizeAsset(new_font, name);
	        }
	        this._blocks[blockID].data = new_font;
	        if (this._debug)
	            console.log("Parsed a font: Name = '" + name);
	    };
	    AWDParser.prototype.parseTextFormat = function (blockID) {
	        var name = this.parseVarStr();
	        this._blocks[blockID].name = name;
	        var font = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var font_style_name = this.parseVarStr();
	        var newTextFormat = new TextFormat_1.TextFormat();
	        newTextFormat.font_name = font.name;
	        // todo:  atm in awd this will always default to get a TesselatedFontTable. need to find a way to request the correct type here
	        var font_table = font.get_font_table(font_style_name);
	        if (font_table != null) {
	            newTextFormat.font_style = font_style_name;
	            newTextFormat.font_table = font_table;
	        }
	        var mat = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        mat.bothSides = true;
	        //mat.curves = true;
	        var num_uv_values = this._newBlockBytes.readUnsignedByte();
	        var uv_values = [];
	        for (var uvcnt = 0; uvcnt < num_uv_values; uvcnt++)
	            uv_values[uvcnt] = this._newBlockBytes.readFloat();
	        newTextFormat.uv_values = uv_values;
	        var format_props = this.parseProperties(AWDParser.textFormatProperties);
	        newTextFormat.size = format_props.get(1, 12);
	        newTextFormat.letterSpacing = format_props.get(2, 0);
	        //newTextFormat.rotated = format_props.get(3,false);
	        newTextFormat.kerning = format_props.get(4, true);
	        //newTextFormat.baseline_shift = format_props.get(5,1);
	        var tf_align_int = format_props.get(6, 0);
	        if (tf_align_int == 1) {
	            newTextFormat.align = "right";
	        }
	        else if (tf_align_int == 2) {
	            newTextFormat.align = "center";
	        }
	        else if (tf_align_int == 3) {
	            newTextFormat.align = "justify";
	        }
	        newTextFormat.indent = format_props.get(7, 0);
	        newTextFormat.leftMargin = format_props.get(8, 0);
	        newTextFormat.rightMargin = format_props.get(9, 0);
	        newTextFormat.leading = format_props.get(10, 0);
	        newTextFormat.color = format_props.get(11, 0);
	        newTextFormat.material = mat;
	        this.parseUserAttributes(); // textformat has no extra-properties
	        //newTextFormat.extra =
	        this._pFinalizeAsset(newTextFormat, name);
	        this._blocks[blockID].data = newTextFormat;
	        if (this._debug)
	            console.log("Parsed a TextFormat: Name = '" + name + " font: " + font.name);
	    };
	    AWDParser.prototype.parseTextField = function (blockID, factory) {
	        var name = this.parseVarStr();
	        this._blocks[blockID].name = name;
	        var newTextField = factory.createTextField();
	        var text_field_type = this._newBlockBytes.readUnsignedByte();
	        newTextField.type = AWDParser.textFieldTypes[text_field_type];
	        if (text_field_type == 3)
	            newTextField.displayAsPassword = true;
	        //
	        newTextField.textWidth = Math.abs(this._newBlockBytes.readFloat());
	        newTextField.textHeight = Math.abs(this._newBlockBytes.readFloat());
	        var num_paragraphs = this._newBlockBytes.readUnsignedInt();
	        var complete_text = "";
	        //console.log("num_paragraphs  '" + num_paragraphs);
	        for (var paracnt = 0; paracnt < num_paragraphs; paracnt++) {
	            var num_textruns = this._newBlockBytes.readUnsignedInt();
	            //console.log("num_textruns  '" + num_textruns);
	            for (var textrun_cnt = 0; textrun_cnt < num_textruns; textrun_cnt++) {
	                var text_format = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	                var txt_length = this._newBlockBytes.readUnsignedInt();
	                //console.log("txt_length  '" + txt_length);
	                if (txt_length > 0) {
	                    var this_txt = this._newBlockBytes.readUTFBytes(txt_length);
	                    //newTextField.appendText(this_txt, text_format);
	                    complete_text += this_txt;
	                }
	            }
	        }
	        newTextField.textFormat = text_format;
	        newTextField.text = complete_text;
	        //newTextField.construct_graphics();
	        // todo: optional matrix etc can be put in properties.
	        var props = this.parseProperties(AWDParser.textFieldProperties);
	        newTextField.selectable = props.get(1, false);
	        newTextField.border = props.get(3, false);
	        //newTextField.renderHTML =  props.get(4, false);
	        //newTextField.scrollable =  props.get(5, false);
	        //newTextField.text_flow =  props.get(7, 0);
	        //newTextField.orientationMode =  props.get(8, 0);
	        //newTextField.line_mode =  props.get(9, 0);
	        newTextField.extra = this.parseUserAttributes();
	        //console.log("Parsed a TextField: Name = '" + name + "| text  = " + complete_text);
	        this._pFinalizeAsset(newTextField, name);
	        this._blocks[blockID].data = newTextField;
	        if (this._debug)
	            console.log("Parsed a TextField: Name = '" + name + "| text  = " + complete_text);
	    };
	    // Block ID = 25
	    AWDParser.prototype.parseBillBoardLibraryBlock = function (blockID) {
	        var name = this.parseVarStr();
	        var mat = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        mat.bothSides = true;
	        var billboard = new Billboard_1.Billboard(mat);
	        // todo: optional matrix etc can be put in properties.
	        this.parseProperties(null);
	        billboard.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(billboard, name);
	        this._blocks[blockID].data = billboard;
	        if (this._debug)
	            console.log("Parsed a Library-Billboard: Name = '" + name + "| Material-Name = " + mat.name);
	    };
	    // Block ID = 24
	    AWDParser.prototype.parseSpriteLibraryBlock = function (blockID) {
	        var name = this.parseVarStr();
	        var data_id = this._newBlockBytes.readUnsignedInt();
	        var graphics = this._blocks[data_id].data;
	        this._blocks[blockID].geoID = data_id;
	        var num_materials = this._newBlockBytes.readUnsignedShort();
	        var materials = new Array();
	        var materialNames = new Array();
	        var mat;
	        for (var materials_parsed = 0; materials_parsed < num_materials; materials_parsed++) {
	            mat = (this._blocks[this._newBlockBytes.readUnsignedInt()].data || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial());
	            //mat.preserveAlpha = true;
	            //mat.alphaBlending = true;
	            mat.useColorTransform = true;
	            materials[materials_parsed] = mat;
	            materialNames[materials_parsed] = mat.name;
	        }
	        var start_timeing = performance.now();
	        var sprite = new Sprite_1.Sprite();
	        graphics.copyTo(sprite.graphics);
	        var end_timing = performance.now();
	        var time_delta = end_timing - start_timeing;
	        this._time_graphics_bytes += time_delta;
	        if (materials.length >= 1 && sprite.graphics.count == 1) {
	            sprite.material = materials[0];
	        }
	        else if (materials.length > 1) {
	            // Assign each sub-sprite in the sprite a material from the list. If more sub-sprites
	            // than materials, repeat the last material for all remaining sub-sprites.
	            for (var i = 0; i < sprite.graphics.count; i++)
	                sprite.graphics.getGraphicAt(i).material = materials[Math.min(materials.length - 1, i)];
	        }
	        var count = this._newBlockBytes.readUnsignedShort();
	        //if(count != sprite.graphics.count)
	        //	throw new Error("num elements does not match num subsprites";
	        for (var i = 0; i < count; i++) {
	            var type = this._newBlockBytes.readUnsignedByte();
	            var sampler = new Sampler2D_1.Sampler2D();
	            var graphic = sprite.graphics.getGraphicAt(i);
	            if (graphic) {
	                graphic.style = new Style_1.Style();
	                graphic.style.addSamplerAt(sampler, graphic.material.getTextureAt(0));
	            }
	            if (type == 3) {
	                var tx = this._newBlockBytes.readFloat();
	                var ty = this._newBlockBytes.readFloat();
	                if (graphic) {
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = new Matrix_1.Matrix(0, 0, 0, 0, tx, ty);
	                }
	            }
	            else if (type == 4) {
	                var matrix = this.parseMatrix32RawData();
	                if (graphic) {
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = new Matrix_1.Matrix(matrix);
	                }
	            }
	            else if (type == 5) {
	                var newMatrix = new Matrix_1.Matrix(this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat(), 0, 0, this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat());
	                if (graphic) {
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = newMatrix;
	                }
	            }
	            else if (type == 6) {
	                var x = this._newBlockBytes.readFloat();
	                var y = this._newBlockBytes.readFloat();
	                var width = this._newBlockBytes.readFloat();
	                var height = this._newBlockBytes.readFloat();
	                var matrix = this.parseMatrix32RawData();
	                if (graphic) {
	                    sampler.imageRect = new Rectangle_1.Rectangle(x, y, width, height);
	                    graphic.material.imageRect = true;
	                    graphic.material.animateUVs = true;
	                    graphic.style.uvMatrix = new Matrix_1.Matrix(matrix);
	                }
	            }
	            if (graphic) {
	                //check if curves are needed
	                if (graphic.elements.getCustomAtributes("curves"))
	                    graphic.material.curves = true;
	            }
	            // todo: finish optional properties (spreadmode + focalpoint)
	            this._newBlockBytes.readUnsignedInt();
	        }
	        this.parseProperties(null);
	        sprite.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(sprite, name);
	        this._blocks[blockID].data = sprite;
	        if (this._debug)
	            console.log("Parsed a Library-Sprite: Name = '" + name + "| Graphics-Name = " + graphics.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
	    };
	    AWDParser.prototype.parseAudioBlock = function (blockID, factory) {
	        //var asset:Audio;todo create asset for audio
	        this._blocks[blockID].name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedByte();
	        var data_len;
	        // External
	        if (type == 0) {
	            data_len = this._newBlockBytes.readUnsignedInt();
	            var url;
	            url = this._newBlockBytes.readUTFBytes(data_len);
	            // todo parser needs to be able to handle mp3 and wav files if we trigger the loading of external ressource
	            this._pAddDependency(this._cur_block_id.toString(), new URLRequest_1.URLRequest(url), false, null, true);
	        }
	        else {
	            // todo: exporter does not export embed sounds yet
	            data_len = this._newBlockBytes.readUnsignedInt();
	            var data = new ByteArray_1.ByteArray(data_len);
	            this._newBlockBytes.readBytes(data, 0, data_len);
	            // todo parse sound from bytes
	            // this._pAddDependency(this._cur_block_id.toString(), null, false, ParserUtils.by(data), true);
	            this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);
	        }
	        // Ignore for now
	        this.parseProperties(null);
	        this._blocks[blockID].extras = this.parseUserAttributes();
	        this._pPauseAndRetrieveDependencies();
	        //this._blocks[blockID].data = asset;todo
	        if (this._debug)
	            console.log("Start parsing a " + ["external", "embed"][type] + " Audio file");
	    };
	    //Block ID = 4
	    AWDParser.prototype.parseMovieClip = function (blockID, factory) {
	        var i;
	        var j;
	        var cmd_asset;
	        var new_timeline = new Timeline_1.Timeline();
	        var new_mc = factory.createMovieClip(new_timeline);
	        var name = this.parseVarStr();
	        // register list of potential childs
	        // a potential child can be reused on a timeline (added / removed / added)
	        // However, for each potential child, we need to register the max-number of instances that a frame contains
	        // we parse 2 lists of potential-childs:
	        // -	the first list contains potential-childs that are only ever instanced once per frame.
	        // -	the second list contains potential-childs that are instanced multiple times on some frames.
	        // on registering a child, the child gets a incremental-id assigned. This is the id, that the commands are using to access the childs.
	        // hence we need to be careful to register all objects in correct order.
	        var num_potential_childs = this._newBlockBytes.readUnsignedShort();
	        for (i = 0; i < num_potential_childs; i++) {
	            cmd_asset = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            if (cmd_asset != null) {
	                new_timeline.registerPotentialChild(cmd_asset);
	            }
	            else {
	                //todo: register a default display object on timeline, so we do not mess up the incremental obj-id
	                //new_mc.registerPotentialChild(cmd_asset);
	                console.log("ERROR when collecting objects for timeline");
	            }
	        }
	        var num_all_display_instances = num_potential_childs;
	        var num_potential_childs_multi_instanced = this._newBlockBytes.readUnsignedShort();
	        for (i = 0; i < num_potential_childs_multi_instanced; i++) {
	            cmd_asset = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            var num_instances = this._newBlockBytes.readUnsignedShort();
	            num_all_display_instances += num_instances;
	            if (cmd_asset != null) {
	                for (j = 0; j < num_instances; j++)
	                    new_timeline.registerPotentialChild(cmd_asset);
	            }
	            else {
	                for (j = 0; j < num_instances; j++) {
	                    //todo: register a default display object on timeline, so we do not mess up the incremental obj-id
	                    //new_mc.registerPotentialChild(cmd_asset);
	                    console.log("ERROR when collecting objects for timeline");
	                }
	            }
	        }
	        if (this._debug)
	            console.log("Parsed " + (num_potential_childs + num_potential_childs_multi_instanced) + " potential childs. They will be used by " + num_all_display_instances + " instances.");
	        // register list of potential sounds - for now we always have 0 sounds
	        var num_potential_sounds = this._newBlockBytes.readUnsignedShort();
	        var str_cnt = this._newBlockBytes.readUnsignedByte();
	        var str_len = 0;
	        var str_data_type = 0;
	        var str_type = 0;
	        var str_counter = 0;
	        for (i = 0; i < str_cnt; i++) {
	            // the first 6 lists are not optional and always in same order
	            // hence we can get type by incremental counter instead of stored uint8
	            if (str_counter < 6)
	                str_type = str_counter;
	            else
	                str_type = this._newBlockBytes.readUnsignedByte();
	            // get the data type for this stream (1:UINT8 - 2:UINT16 - 3:UINT32)
	            str_data_type = this._newBlockBytes.readUnsignedByte();
	            // size of this stream in byte
	            str_len = this._newBlockBytes.readUnsignedInt();
	            if (str_len > 0) {
	                var keyframes_start_indices_data = new ByteArray_1.ByteArray(str_len);
	                this._newBlockBytes.readBytes(keyframes_start_indices_data, 0, str_len);
	                var new_buffer;
	                //console.log("str_data_type = "+str_type);
	                switch (str_data_type) {
	                    case 1:
	                        new_buffer = new Uint8Array(keyframes_start_indices_data.arraybytes);
	                        break;
	                    case 2:
	                        new_buffer = new Uint16Array(keyframes_start_indices_data.arraybytes);
	                        break;
	                    case 4:
	                        new_buffer = new Uint32Array(keyframes_start_indices_data.arraybytes);
	                        break;
	                }
	                switch (str_type) {
	                    case 0:
	                        new_timeline.keyframe_durations = new_buffer;
	                        new_timeline.numKeyFrames = str_len / str_data_type;
	                        break;
	                    case 1:
	                        new_timeline.frame_command_indices = new_buffer;
	                        break;
	                    case 2:
	                        new_timeline.frame_recipe = new_buffer;
	                        break;
	                    case 3:
	                        new_timeline.command_length_stream = new_buffer;
	                        break;
	                    case 4:
	                        new_timeline.command_index_stream = new_buffer;
	                        break;
	                    case 5:
	                        new_timeline.add_child_stream = new_buffer;
	                        break;
	                    case 6:
	                        new_timeline.remove_child_stream = new_buffer;
	                        break;
	                    case 7:
	                        new_timeline.update_child_stream = new_buffer;
	                        break;
	                    case 8:
	                        new_timeline.update_child_props_indices_stream = new_buffer;
	                        break;
	                    case 9:
	                        new_timeline.update_child_props_length_stream = new_buffer;
	                        break;
	                    case 10:
	                        new_timeline.property_type_stream = new_buffer;
	                        break;
	                    case 11:
	                        new_timeline.property_index_stream = new_buffer;
	                        break;
	                    case 12:
	                        new_timeline.properties_stream_int = new_buffer;
	                        break;
	                }
	            }
	            str_counter++;
	        }
	        var lc = 0;
	        var float_array_data;
	        str_cnt = this._newBlockBytes.readUnsignedByte();
	        for (i = 0; i < str_cnt; i++) {
	            str_type = this._newBlockBytes.readUnsignedByte();
	            str_len = this._newBlockBytes.readUnsignedInt();
	            switch (str_type) {
	                case 0:
	                    float_array_data = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_mtx_scale_rot = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 1:
	                    float_array_data = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_mtx_pos = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 2:
	                    float_array_data = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_mtx_all = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 3:
	                    float_array_data = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
	                    new_timeline.properties_stream_f32_ct = new Float32Array(float_array_data.arraybytes);
	                    break;
	                case 4:
	                    str_len = this._newBlockBytes.readUnsignedShort();
	                    //console.log("start reading labels "+str_len);
	                    for (lc = 0; lc < str_len; lc++) {
	                        new_timeline._labels[this.parseVarStr()] = this._newBlockBytes.readUnsignedShort();
	                    }
	                    break;
	                case 5:
	                    str_len = this._newBlockBytes.readUnsignedShort();
	                    var string_props_array = [];
	                    for (lc = 0; lc < str_len; lc++) {
	                        string_props_array.push(this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedShort()));
	                    }
	                    new_timeline.properties_stream_strings = string_props_array;
	                    break;
	                case 6:
	                    str_len = this._newBlockBytes.readUnsignedShort();
	                    for (lc = 0; lc < str_len; lc++) {
	                        var frame_index = this._newBlockBytes.readUnsignedShort();
	                        var one_str_len = this._newBlockBytes.readUnsignedInt();
	                        //this._newBlockBytes.readUTFBytes(one_str_len);
	                        new_timeline.add_framescript(this._newBlockBytes.readUTFBytes(one_str_len), frame_index);
	                    }
	                    break;
	            }
	        }
	        new_timeline.init();
	        var sceneID = 0;
	        var fps = 25;
	        this.parseProperties(AWDParser.movieClipProperties);
	        this.parseUserAttributes();
	        this._pFinalizeAsset(new_mc, name);
	        this._blocks[blockID].data = new_mc;
	        if (this._debug)
	            console.log("Parsed a TIMELINE: Name = " + name + "| sceneID = " + sceneID + "| numFrames = " + new_mc.timeline.numFrames);
	    };
	    //Block ID = 1
	    AWDParser.prototype.parseGraphics = function (blockID) {
	        var graphics = new Graphics_1.Graphics();
	        // Read name and sub count
	        var name = this.parseVarStr();
	        var numElements = this._newBlockBytes.readUnsignedShort();
	        // Read optional properties
	        var props = this.parseProperties(AWDParser.graphicsProperties);
	        var geoScaleU = props.get(1, 1);
	        var geoScaleV = props.get(2, 1);
	        var target_start_idx = 0;
	        var target_vert_cnt = 0;
	        var element_type = ElementType.STANDART_STREAMS;
	        var target_element = null;
	        // Loop through sub sprites
	        target_element = null;
	        for (var elements_parsed = 0; elements_parsed < numElements; elements_parsed++) {
	            var attr_count = 0;
	            var sm_len, sm_end;
	            var w_indices;
	            var weights;
	            target_start_idx = 0;
	            target_vert_cnt = 0;
	            element_type = ElementType.STANDART_STREAMS;
	            sm_len = this._newBlockBytes.readUnsignedInt();
	            sm_end = this._newBlockBytes.position + sm_len;
	            var elementsProps = this.parseProperties(AWDParser.elementsProperties);
	            // Loop through data streams
	            while (this._newBlockBytes.position < sm_end) {
	                var idx = 0;
	                var str_ftype, str_type, str_len, str_end;
	                // Type, field type, length
	                str_type = this._newBlockBytes.readUnsignedByte();
	                str_ftype = this._newBlockBytes.readUnsignedByte();
	                str_len = this._newBlockBytes.readUnsignedInt();
	                str_end = this._newBlockBytes.position + str_len;
	                var x, y, z;
	                if (str_type == 1) {
	                    var verts = [];
	                    while (this._newBlockBytes.position < str_end) {
	                        x = this.readNumber(this._accuracyGeo);
	                        y = this.readNumber(this._accuracyGeo);
	                        z = this.readNumber(this._accuracyGeo);
	                        verts[idx++] = x;
	                        verts[idx++] = y;
	                        verts[idx++] = z;
	                    }
	                }
	                else if (str_type == 2) {
	                    var indices = [];
	                    while (this._newBlockBytes.position < str_end)
	                        indices[idx++] = this._newBlockBytes.readUnsignedShort();
	                }
	                else if (str_type == 3) {
	                    var uvs = [];
	                    while (this._newBlockBytes.position < str_end)
	                        uvs[idx++] = this.readNumber(this._accuracyGeo);
	                }
	                else if (str_type == 4) {
	                    var normals = [];
	                    while (this._newBlockBytes.position < str_end)
	                        normals[idx++] = this.readNumber(this._accuracyGeo);
	                }
	                else if (str_type == 6) {
	                    w_indices = Array();
	                    while (this._newBlockBytes.position < str_end)
	                        w_indices[idx++] = this._newBlockBytes.readUnsignedShort() * 3;
	                }
	                else if (str_type == 7) {
	                    weights = [];
	                    while (this._newBlockBytes.position < str_end)
	                        weights[idx++] = this.readNumber(this._accuracyGeo);
	                }
	                else if (str_type == 8) {
	                    this._newBlockBytes.position = str_end;
	                }
	                else if (str_type == 9) {
	                    this._newBlockBytes.position = str_end;
	                }
	                else if (str_type == 10) {
	                    element_type = ElementType.CONCENATED_STREAMS;
	                    attr_count = 28;
	                    var curveData = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(curveData, 0, str_len);
	                }
	                else if (str_type == 11) {
	                    element_type = ElementType.CONCENATED_STREAMS;
	                    attr_count = 20;
	                    var curveData = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(curveData, 0, str_len);
	                }
	                else if (str_type == 12) {
	                    element_type = ElementType.CONCENATED_STREAMS;
	                    attr_count = 12;
	                    var curveData = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(curveData, 0, str_len);
	                }
	                else if (str_type == 13) {
	                    element_type = ElementType.SHARED_BUFFER;
	                    var targetGraphic = (this._blocks[this._newBlockBytes.readUnsignedInt()].data);
	                    var element_idx = this._newBlockBytes.readUnsignedByte();
	                    target_element = targetGraphic.getGraphicAt(element_idx).elements;
	                    target_start_idx = this._newBlockBytes.readUnsignedInt();
	                    target_vert_cnt = this._newBlockBytes.readUnsignedInt();
	                }
	                else if (str_type == 14) {
	                    element_type = ElementType.CONCATENATED_SUBGEO;
	                    //var verts:Array<number> = [];
	                    attr_count = 8;
	                    var vertData = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(vertData, 0, str_len);
	                }
	                else if (str_type == 15) {
	                    element_type = ElementType.SHARED_INDEXBUFFER;
	                    target_start_idx = this._newBlockBytes.readUnsignedInt();
	                    target_vert_cnt = this._newBlockBytes.readUnsignedInt();
	                }
	                else if (str_type == 16) {
	                    element_type = ElementType.CONCENATED_STREAMS;
	                    attr_count = 8;
	                    var curveData = new ByteArray_1.ByteArray(str_len);
	                    this._newBlockBytes.readBytes(curveData, 0, str_len);
	                }
	                else {
	                    console.log("skipping unknown subgeom stream");
	                    this._newBlockBytes.position = str_end;
	                }
	            }
	            this.parseUserAttributes(); // Ignore sub-sprite attributes for now
	            if (element_type == ElementType.CONCENATED_STREAMS) {
	                //console.log("str_len/attr_count = "+str_len/attr_count)
	                var vertexBuffer = new AttributesBuffer_1.AttributesBuffer(attr_count, str_len / attr_count);
	                vertexBuffer.bufferView = new Uint8Array(curveData.arraybytes);
	                var curve_elements = new TriangleElements_1.TriangleElements(vertexBuffer);
	                curve_elements.setPositions(new Float2Attributes_1.Float2Attributes(vertexBuffer));
	                if (attr_count == 20) {
	                    curve_elements.setCustomAttributes("curves", new Float3Attributes_1.Float3Attributes(vertexBuffer));
	                }
	                else if (attr_count == 12) {
	                    curve_elements.setCustomAttributes("curves", new Byte4Attributes_1.Byte4Attributes(vertexBuffer, false));
	                }
	                if (attr_count == 28)
	                    curve_elements.setUVs(new Float2Attributes_1.Float2Attributes(vertexBuffer));
	                graphics.addGraphic(curve_elements);
	                if (this._debug)
	                    console.log("Parsed a TriangleElements with curves");
	            }
	            else if (element_type == ElementType.STANDART_STREAMS) {
	                var triangle_elements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	                if (weights)
	                    triangle_elements.jointsPerVertex = weights.length / (verts.length / 3);
	                if (normals)
	                    triangle_elements.autoDeriveNormals = false;
	                triangle_elements.autoDeriveTangents = true;
	                triangle_elements.setIndices(indices);
	                triangle_elements.setPositions(verts);
	                triangle_elements.setNormals(normals);
	                triangle_elements.setUVs(uvs);
	                triangle_elements.setJointWeights(weights);
	                triangle_elements.setJointIndices(w_indices);
	                var scaleU = elementsProps.get(1, 1);
	                var scaleV = elementsProps.get(2, 1);
	                var setSubUVs = false; //this should remain false atm, because in AwayBuilder the uv is only scaled by the graphics
	                if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
	                    setSubUVs = true;
	                    scaleU = geoScaleU / scaleU;
	                    scaleV = geoScaleV / scaleV;
	                }
	                if (setSubUVs)
	                    triangle_elements.scaleUV(scaleU, scaleV);
	                graphics.addGraphic(triangle_elements);
	                if (this._debug)
	                    console.log("Parsed a TriangleElements");
	            }
	            else if (element_type == ElementType.CONCATENATED_SUBGEO) {
	                var vertexBuffer = new AttributesBuffer_1.AttributesBuffer(attr_count, str_len / attr_count);
	                vertexBuffer.bufferView = new Uint8Array(vertData.arraybytes);
	                var triangle_elements = new TriangleElements_1.TriangleElements(vertexBuffer);
	                triangle_elements.setPositions(new Float2Attributes_1.Float2Attributes(vertexBuffer));
	                //if (weights)
	                //	triangle_elements.jointsPerVertex = weights.length / (verts.length / 3);
	                //if (normals)
	                //	triangle_elements.autoDeriveNormals = false;
	                //triangle_elements.autoDeriveTangents = true;
	                triangle_elements.setIndices(indices);
	                //triangle_elements.setPositions(verts);
	                //triangle_elements.setNormals(normals);
	                //triangle_elements.setUVs(uvs);
	                //triangle_elements.setJointWeights(weights);
	                //triangle_elements.setJointIndices(w_indices);
	                var scaleU = elementsProps.get(1, 1);
	                var scaleV = elementsProps.get(2, 1);
	                var setSubUVs = false; //this should remain false atm, because in AwayBuilder the uv is only scaled by the graphics
	                if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
	                    setSubUVs = true;
	                    scaleU = geoScaleU / scaleU;
	                    scaleV = geoScaleV / scaleV;
	                }
	                if (setSubUVs)
	                    triangle_elements.scaleUV(scaleU, scaleV);
	                target_element = triangle_elements;
	            }
	            else if (element_type == ElementType.SHARED_INDEXBUFFER) {
	                var graphic = graphics.addGraphic(target_element);
	                graphic.idx_offset = target_start_idx;
	                graphic.idx_count = target_vert_cnt;
	            }
	            else if (element_type == ElementType.SHARED_BUFFER) {
	                var graphic = graphics.addGraphic(target_element);
	                graphic.offset = target_start_idx;
	                graphic.count = target_vert_cnt;
	                if (this._debug)
	                    console.log("Parsed a TriangleElements that shares index buffer from target geom");
	            }
	        }
	        if ((geoScaleU != 1) || (geoScaleV != 1))
	            graphics.scaleUV(geoScaleU, geoScaleV);
	        this.parseUserAttributes();
	        this._pFinalizeAsset(graphics, name);
	        this._blocks[blockID].data = graphics;
	        if (this._debug)
	            console.log("Parsed Graphics: Name = " + name);
	    };
	    //Block ID = 11
	    AWDParser.prototype.parsePrimitves = function (blockID) {
	        var name;
	        var prefab;
	        var primType;
	        var elements_parsed;
	        var props;
	        var bsm;
	        // Read name and sub count
	        name = this.parseVarStr();
	        primType = this._newBlockBytes.readUnsignedByte();
	        props = this.parseProperties(AWDParser.primitiveProperties);
	        // to do, not all properties are set on all primitives
	        switch (primType) {
	            case 1:
	                prefab = new PrimitivePlanePrefab_1.PrimitivePlanePrefab(null, ElementsType_1.ElementsType.TRIANGLE, props.get(101, 100), props.get(102, 100), props.get(301, 1), props.get(302, 1), props.get(701, true), props.get(702, false));
	                break;
	            case 2:
	                prefab = new PrimitiveCubePrefab_1.PrimitiveCubePrefab(null, ElementsType_1.ElementsType.TRIANGLE, props.get(101, 100), props.get(102, 100), props.get(103, 100), props.get(301, 1), props.get(302, 1), props.get(303, 1), props.get(701, true));
	                break;
	            case 3:
	                prefab = new PrimitiveSpherePrefab_1.PrimitiveSpherePrefab(null, ElementsType_1.ElementsType.TRIANGLE, props.get(101, 50), props.get(301, 16), props.get(302, 12), props.get(701, true));
	                break;
	            case 4:
	                prefab = new PrimitiveCylinderPrefab_1.PrimitiveCylinderPrefab(null, ElementsType_1.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 50), props.get(103, 100), props.get(301, 16), props.get(302, 1), true, true, true); // bool701, bool702, bool703, bool704);
	                if (!props.get(701, true))
	                    prefab.topClosed = false;
	                if (!props.get(702, true))
	                    prefab.bottomClosed = false;
	                if (!props.get(703, true))
	                    prefab.yUp = false;
	                break;
	            case 5:
	                prefab = new PrimitiveConePrefab_1.PrimitiveConePrefab(null, ElementsType_1.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 1), props.get(701, true), props.get(702, true));
	                break;
	            case 6:
	                prefab = new PrimitiveCapsulePrefab_1.PrimitiveCapsulePrefab(null, ElementsType_1.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 15), props.get(701, true));
	                break;
	            case 7:
	                prefab = new PrimitiveTorusPrefab_1.PrimitiveTorusPrefab(null, ElementsType_1.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 50), props.get(301, 16), props.get(302, 8), props.get(701, true));
	                break;
	            default:
	                prefab = new PrefabBase_1.PrefabBase();
	                console.log("ERROR: UNSUPPORTED PREFAB_TYPE");
	                break;
	        }
	        if ((props.get(110, 1) != 1) || (props.get(111, 1) != 1)) {
	        }
	        this.parseUserAttributes();
	        prefab.name = name;
	        this._pFinalizeAsset(prefab, name);
	        this._blocks[blockID].data = prefab;
	        if (this._debug) {
	            if ((primType < 0) || (primType > 7))
	                primType = 0;
	            console.log("Parsed a Primivite: Name = " + name + "| type = " + AWDParser.primitiveTypes[primType]);
	        }
	    };
	    // Block ID = 22
	    AWDParser.prototype.parseContainer = function (blockID) {
	        var name;
	        var mtx;
	        var ctr;
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        mtx = this.parseMatrix3D();
	        name = this.parseVarStr();
	        var parentName = "Root (TopLevel)";
	        ctr = new DisplayObjectContainer_1.DisplayObjectContainer();
	        ctr.transform.matrix3D = mtx;
	        if (parent) {
	            parent.addChild(ctr);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(ctr);
	        }
	        // in AWD version 2.1 we read the Container properties
	        if ((this._version[0] == 2) && (this._version[1] == 1)) {
	            var props = this.parseProperties(AWDParser.containerProperties);
	            ctr.pivot = new Vector3D_1.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	        }
	        else {
	            this.parseProperties(null);
	        }
	        // the extraProperties should only be set for AWD2.1-Files, but is read for both versions
	        ctr.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(ctr, name);
	        this._blocks[blockID].data = ctr;
	        if (this._debug)
	            console.log("Parsed a Container: Name = '" + name + "' | Parent-Name = " + parentName);
	    };
	    // Block ID = 23
	    AWDParser.prototype.parseSpriteInstance = function (blockID) {
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var data_id = this._newBlockBytes.readUnsignedInt();
	        var asset = this._blocks[data_id].data;
	        var graphics;
	        var prefab;
	        var isPrefab = false;
	        if (asset.isAsset(Graphics_1.Graphics)) {
	            graphics = asset;
	        }
	        else {
	            isPrefab = true;
	            prefab = asset;
	        }
	        this._blocks[blockID].geoID = data_id;
	        var num_materials = this._newBlockBytes.readUnsignedShort();
	        var materials = new Array();
	        var materialNames = new Array();
	        var mat;
	        for (var materials_parsed = 0; materials_parsed < num_materials; materials_parsed++) {
	            mat = (this._blocks[this._newBlockBytes.readUnsignedInt()].data || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial());
	            materials[materials_parsed] = mat;
	            materialNames[materials_parsed] = mat.name;
	        }
	        var sprite;
	        if (isPrefab) {
	            sprite = prefab.getNewObject();
	        }
	        else {
	            sprite = new Sprite_1.Sprite();
	            graphics.copyTo(sprite.graphics);
	        }
	        sprite.transform.matrix3D = mtx;
	        var parentName = "Root (TopLevel)";
	        if (parent) {
	            parent.addChild(sprite);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(sprite);
	        }
	        if (materials.length >= 1 && sprite.graphics.count == 1) {
	            sprite.material = materials[0];
	        }
	        else if (materials.length > 1) {
	            // Assign each sub-sprite in the sprite a material from the list. If more sub-sprites
	            // than materials, repeat the last material for all remaining sub-sprites.
	            for (var i = 0; i < sprite.graphics.count; i++)
	                sprite.graphics.getGraphicAt(i).material = materials[Math.min(materials.length - 1, i)];
	        }
	        if ((this._version[0] == 2) && (this._version[1] == 1)) {
	            var props = this.parseProperties(AWDParser.spriteInstanceProperties);
	            sprite.pivot = new Vector3D_1.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	            sprite.castsShadows = props.get(5, true);
	        }
	        else {
	            this.parseProperties(null);
	        }
	        sprite.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(sprite, name);
	        this._blocks[blockID].data = sprite;
	        if (this._debug) {
	            if (isPrefab)
	                console.log("Parsed a Sprite for Prefab: Name = '" + name + "' | Parent-Name = " + parentName + "| Prefab-Name = " + prefab.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
	            else
	                console.log("Parsed a Sprite for Graphics: Name = '" + name + "' | Parent-Name = " + parentName + "| Graphics-Name = " + graphics.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
	        }
	    };
	    //Block ID 31
	    AWDParser.prototype.parseSkyboxInstance = function (blockID) {
	        var name = this.parseVarStr();
	        var asset = new Skybox_1.Skybox();
	        var tex = new SingleCubeTexture_1.SingleCubeTexture(this._blocks[this._newBlockBytes.readUnsignedInt()].data || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultImageCube());
	        asset.texture = tex;
	        this.parseProperties(null);
	        asset.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(asset, name);
	        this._blocks[blockID].data = asset;
	        if (this._debug)
	            console.log("Parsed a Skybox: Name = '" + name + "' | CubeTexture-Name = " + tex.name);
	    };
	    //Block ID = 41
	    AWDParser.prototype.parseLight = function (blockID) {
	        var light;
	        var newShadowMapper;
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var lightType = this._newBlockBytes.readUnsignedByte();
	        var props = this.parseProperties(AWDParser.lightProperties);
	        var shadowMapperType = props.get(9, 0);
	        var lightTypes = ["Unsupported LightType", "PointLight", "DirectionalLight"];
	        var shadowMapperTypes = ["No ShadowMapper", "DirectionalShadowMapper", "NearDirectionalShadowMapper", "CascadeShadowMapper", "CubeMapShadowMapper"];
	        if (lightType == 1) {
	            light = new PointLight_1.PointLight();
	            light.radius = props.get(1, 90000);
	            light.fallOff = props.get(2, 100000);
	            if (shadowMapperType > 0) {
	                if (shadowMapperType == 4) {
	                    newShadowMapper = new CubeMapShadowMapper_1.CubeMapShadowMapper();
	                }
	            }
	            light.transform.matrix3D = mtx;
	        }
	        if (lightType == 2) {
	            light = new DirectionalLight_1.DirectionalLight(props.get(21, 0), props.get(22, -1), props.get(23, 1));
	            if (shadowMapperType > 0) {
	                if (shadowMapperType == 1) {
	                    newShadowMapper = new DirectionalShadowMapper_1.DirectionalShadowMapper();
	                }
	            }
	        }
	        light.color = props.get(3, 0xffffff);
	        light.specular = props.get(4, 1.0);
	        light.diffuse = props.get(5, 1.0);
	        light.ambientColor = props.get(7, 0xffffff);
	        light.ambient = props.get(8, 0.0);
	        // if a shadowMapper has been created, adjust the depthMapSize if needed, assign to light and set castShadows to true
	        if (newShadowMapper) {
	            if (newShadowMapper instanceof CubeMapShadowMapper_1.CubeMapShadowMapper) {
	                if (props.get(10, 1) != 1)
	                    newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 1)];
	            }
	            else {
	                if (props.get(10, 2) != 2)
	                    newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 2)];
	            }
	            light.shadowMapper = newShadowMapper;
	            light.castsShadows = true;
	        }
	        var parentName = "Root (TopLevel)";
	        if (parent) {
	            parent.addChild(light);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(light);
	        }
	        this.parseUserAttributes();
	        this._pFinalizeAsset(light, name);
	        this._blocks[blockID].data = light;
	        if (this._debug)
	            console.log("Parsed a Light: Name = '" + name + "' | Type = " + lightTypes[lightType] + " | Parent-Name = " + parentName + " | ShadowMapper-Type = " + shadowMapperTypes[shadowMapperType]);
	    };
	    //Block ID = 43
	    AWDParser.prototype.parseCamera = function (blockID) {
	        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var projection;
	        this._newBlockBytes.readUnsignedByte(); //set as active camera
	        this._newBlockBytes.readShort(); //lengthof lenses - not used yet
	        var projectiontype = this._newBlockBytes.readShort();
	        var props = this.parseProperties(AWDParser.cameraProperties);
	        switch (projectiontype) {
	            case 5001:
	                projection = new PerspectiveProjection_1.PerspectiveProjection(props.get(101, 60));
	                break;
	            case 5002:
	                projection = new OrthographicProjection_1.OrthographicProjection(props.get(101, 500));
	                break;
	            case 5003:
	                projection = new OrthographicOffCenterProjection_1.OrthographicOffCenterProjection(props.get(101, -400), props.get(102, 400), props.get(103, -300), props.get(104, 300));
	                break;
	            default:
	                console.log("unsupportedLenstype");
	                return;
	        }
	        var camera = new Camera_1.Camera(projection);
	        camera.transform.matrix3D = mtx;
	        var parentName = "Root (TopLevel)";
	        if (parent) {
	            parent.addChild(camera);
	            parentName = parent.name;
	        }
	        else {
	            //add to the content property
	            this._pContent.addChild(camera);
	        }
	        camera.name = name;
	        props = this.parseProperties(AWDParser.cameraPivotProperties);
	        camera.pivot = new Vector3D_1.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	        camera.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(camera, name);
	        this._blocks[blockID].data = camera;
	        if (this._debug)
	            console.log("Parsed a Camera: Name = '" + name + "' | Projectiontype = " + projection + " | Parent-Name = " + parentName);
	    };
	    //Block ID = 51
	    AWDParser.prototype.parseLightPicker = function (blockID) {
	        var name = this.parseVarStr();
	        var numLights = this._newBlockBytes.readUnsignedShort();
	        var lightsArray = new Array();
	        var lightsArrayNames = new Array();
	        for (var k = 0; k < numLights; k++) {
	            var light = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            lightsArray.push(light);
	            lightsArrayNames.push(light.name);
	        }
	        if (lightsArray.length == 0) {
	            this._blocks[blockID].addError("Could not create this LightPicker, cause no Light was found.");
	            this.parseUserAttributes();
	            return; //return without any more parsing for this block
	        }
	        var lightPick = new StaticLightPicker_1.StaticLightPicker(lightsArray);
	        lightPick.name = name;
	        this.parseUserAttributes();
	        this._pFinalizeAsset(lightPick, name);
	        this._blocks[blockID].data = lightPick;
	        if (this._debug)
	            console.log("Parsed a StaticLightPicker: Name = '" + name + "' | Texture-Name = " + lightsArrayNames);
	    };
	    //Block ID = 81
	    AWDParser.prototype.parseMaterial = function (blockID) {
	        // TODO: not used
	        ////blockLength = block.len;
	        var name;
	        var type;
	        var props;
	        var mat;
	        var finalize;
	        var num_methods;
	        var methods_parsed;
	        var returnedArray;
	        name = this.parseVarStr();
	        type = this._newBlockBytes.readUnsignedByte();
	        num_methods = this._newBlockBytes.readUnsignedByte();
	        // Read material numerical properties
	        props = this.parseProperties(AWDParser.materialProperties);
	        methods_parsed = 0;
	        while (methods_parsed < num_methods) {
	            var method_type;
	            method_type = this._newBlockBytes.readUnsignedShort();
	            this.parseProperties(null);
	            this.parseUserAttributes();
	            methods_parsed += 1;
	        }
	        var debugString = "";
	        if (type === 1) {
	            debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
	            var color = props.get(1, 0xffffff);
	            if (this.materialMode < 2) {
	                mat = new MethodMaterial_1.MethodMaterial(color, props.get(10, 1.0));
	            }
	            else {
	                mat = new MethodMaterial_1.MethodMaterial(color);
	                mat.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	            }
	        }
	        else if (type === 2) {
	            var texture = new Single2DTexture_1.Single2DTexture(this._blocks[props.get(2, 0)].data);
	            mat = new MethodMaterial_1.MethodMaterial();
	            mat.ambientMethod.texture = texture;
	            if (this.materialMode < 2) {
	                mat.alphaBlending = props.get(11, false);
	                mat.alpha = props.get(10, 1.0);
	                debugString += "Parsed a MethodMaterial(SinglePass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	            }
	            else {
	                mat.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	                debugString += "Parsed a MethodMaterial(MultiPass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	            }
	        }
	        mat.extra = this.parseUserAttributes();
	        mat.alphaThreshold = props.get(12, 0.0);
	        mat.style.sampler = new Sampler2D_1.Sampler2D(props.get(13, false));
	        this._pFinalizeAsset(mat, name);
	        this._blocks[blockID].data = mat;
	        if (this._debug)
	            console.log(debugString);
	    };
	    // Block ID = 81 AWD2.1
	    AWDParser.prototype.parseMaterial_v1 = function (blockID) {
	        var mat;
	        var diffuseImage;
	        var normalImage;
	        var specImage;
	        var name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedByte();
	        var num_methods = this._newBlockBytes.readUnsignedByte();
	        var props = this.parseProperties(AWDParser.material_v1Properties);
	        var spezialType = props.get(4, 0);
	        var debugString = "Parsed Material ";
	        if (spezialType >= 2) {
	            this._blocks[blockID].addError("Material-spezialType '" + spezialType + "' is not supported, can only be 0:singlePass, 1:MultiPass !");
	            return;
	        }
	        if (type <= 2) {
	            if (this.materialMode == 1)
	                spezialType = 0;
	            else if (this.materialMode == 2)
	                spezialType = 1;
	            if (spezialType < 2) {
	                if (type == 1) {
	                    var color = props.get(1, 0xcccccc); //TODO temporarily swapped so that diffuse color goes to ambient
	                    if (spezialType == 1) {
	                        mat = new MethodMaterial_1.MethodMaterial(color);
	                        mat.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	                        debugString += "Parsed a ColorMaterial(MultiPass): Name = '" + name + "' | ";
	                    }
	                    else {
	                        mat = new MethodMaterial_1.MethodMaterial(color, props.get(10, 1.0));
	                        mat.alphaBlending = props.get(11, false);
	                        debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
	                    }
	                }
	                else if (type == 2) {
	                    var texture = new Single2DTexture_1.Single2DTexture(this._blocks[props.get(2, 0)].data);
	                    mat = new MethodMaterial_1.MethodMaterial();
	                    mat.ambientMethod.texture = texture;
	                    if (spezialType == 1) {
	                        mat.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	                        debugString += "Parsed a MethodMaterial(MultiPass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	                    }
	                    else {
	                        mat.alpha = props.get(10, 1.0);
	                        mat.alphaBlending = props.get(11, false);
	                        debugString += "Parsed a MethodMaterial(SinglePass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
	                    }
	                }
	                diffuseImage = this._blocks[props.get(17, 0)].data;
	                normalImage = this._blocks[props.get(3, 0)].data;
	                specImage = this._blocks[props.get(21, 0)].data;
	                mat.lightPicker = this._blocks[props.get(22, 0)].data;
	                mat.style.sampler = new Sampler2D_1.Sampler2D(props.get(13, false), props.get(5, true), props.get(6, true));
	                mat.bothSides = props.get(7, false);
	                mat.alphaPremultiplied = props.get(8, false);
	                mat.blendMode = this.blendModeDic[props.get(9, 0)];
	                if (diffuseImage) {
	                    mat.diffuseTexture = new Single2DTexture_1.Single2DTexture(diffuseImage);
	                    debugString += " | DiffuseTexture-Name = " + diffuseImage.name;
	                }
	                if (normalImage) {
	                    mat.normalMethod.texture = new Single2DTexture_1.Single2DTexture(normalImage);
	                    debugString += " | NormalTexture-Name = " + normalImage.name;
	                }
	                if (specImage) {
	                    mat.specularMethod.texture = new Single2DTexture_1.Single2DTexture(specImage);
	                    debugString += " | SpecularTexture-Name = " + specImage.name;
	                }
	                mat.alphaThreshold = props.get(12, 0.0);
	                mat.ambientMethod.strength = props.get(15, 1.0);
	                mat.diffuseMethod.color = props.get(16, 0xffffff);
	                mat.specularMethod.strength = props.get(18, 1.0);
	                mat.specularMethod.gloss = props.get(19, 50);
	                mat.specularMethod.color = props.get(20, 0xffffff);
	                for (var methods_parsed = 0; methods_parsed < num_methods; methods_parsed++) {
	                    var method_type;
	                    method_type = this._newBlockBytes.readUnsignedShort();
	                    props = this.parseProperties(AWDParser.method_v1Properties);
	                    switch (method_type) {
	                        case 999:
	                            var effectMethod = this._blocks[props.get(1, 0)].data;
	                            mat.addEffectMethod(effectMethod);
	                            debugString += " | EffectMethod-Name = " + effectMethod.name;
	                            break;
	                        case 998:
	                            var shadowMapMethod = this._blocks[props.get(1, 0)].data;
	                            mat.shadowMethod = shadowMapMethod;
	                            debugString += " | ShadowMethod-Name = " + shadowMapMethod.name;
	                            break;
	                        case 1:
	                            var cubeTexture = new SingleCubeTexture_1.SingleCubeTexture(this._blocks[props.get(1, 0)].data);
	                            mat.ambientMethod = new AmbientEnvMapMethod_1.AmbientEnvMapMethod();
	                            mat.ambientMethod.texture = cubeTexture;
	                            debugString += " | AmbientEnvMapMethod | EnvMap-Name =" + cubeTexture.name;
	                            break;
	                        case 51:
	                            mat.diffuseMethod = new DiffuseDepthMethod_1.DiffuseDepthMethod();
	                            debugString += " | DiffuseDepthMethod";
	                            break;
	                        case 52:
	                            var texture = new Single2DTexture_1.Single2DTexture(this._blocks[props.get(1, 0)].data);
	                            mat.diffuseMethod = new DiffuseGradientMethod_1.DiffuseGradientMethod(texture);
	                            debugString += " | DiffuseGradientMethod | GradientDiffuseTexture-Name =" + texture.name;
	                            break;
	                        case 53:
	                            mat.diffuseMethod = new DiffuseWrapMethod_1.DiffuseWrapMethod(props.get(101, 5));
	                            debugString += " | DiffuseWrapMethod";
	                            break;
	                        case 54:
	                            var texture = new Single2DTexture_1.Single2DTexture(this._blocks[props.get(1, 0)].data);
	                            mat.diffuseMethod = new DiffuseLightMapMethod_1.DiffuseLightMapMethod(texture, this.blendModeDic[props.get(401, 10)], false, mat.diffuseMethod);
	                            debugString += " | DiffuseLightMapMethod | LightMapTexture-Name =" + texture.name;
	                            break;
	                        case 55:
	                            mat.diffuseMethod = new DiffuseCelMethod_1.DiffuseCelMethod(props.get(401, 3), mat.diffuseMethod);
	                            mat.diffuseMethod.smoothness = props.get(101, 0.1);
	                            debugString += " | DiffuseCelMethod";
	                            break;
	                        case 56:
	                            //							mat.diffuseMethod = new DiffuseSubSurfaceMethod(); //depthMapSize and depthMapOffset ?
	                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).scattering = props.get(101, 0.2);
	                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).translucency = props.get(102, 1);
	                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).scatterColor = props.get(601, 0xffffff);
	                            //							debugString += " | DiffuseSubSurfaceMethod";
	                            break;
	                        case 101:
	                            mat.specularMethod = new SpecularAnisotropicMethod_1.SpecularAnisotropicMethod();
	                            debugString += " | SpecularAnisotropicMethod";
	                            break;
	                        case 102:
	                            mat.specularMethod = new SpecularPhongMethod_1.SpecularPhongMethod();
	                            debugString += " | SpecularPhongMethod";
	                            break;
	                        case 103:
	                            mat.specularMethod = new SpecularCelMethod_1.SpecularCelMethod(props.get(101, 0.5), mat.specularMethod);
	                            mat.specularMethod.smoothness = props.get(102, 0.1);
	                            debugString += " | SpecularCelMethod";
	                            break;
	                        case 104:
	                            mat.specularMethod = new SpecularFresnelMethod_1.SpecularFresnelMethod(props.get(701, true), mat.specularMethod);
	                            mat.specularMethod.fresnelPower = props.get(101, 5);
	                            mat.specularMethod.normalReflectance = props.get(102, 0.1);
	                            debugString += " | SpecularFresnelMethod";
	                            break;
	                        case 151:
	                            break;
	                        case 152:
	                            var texture = new Single2DTexture_1.Single2DTexture(this._blocks[props.get(1, 0)].data);
	                            mat.normalMethod = new NormalSimpleWaterMethod_1.NormalSimpleWaterMethod(mat.normalMethod.texture || texture, texture);
	                            debugString += " | NormalSimpleWaterMethod | Second-NormalTexture-Name = " + texture.name;
	                            break;
	                    }
	                    this.parseUserAttributes();
	                }
	            }
	        }
	        else if ((type >= 3) && (type <= 7)) {
	            // if this is a basic material, we create it, finalize it, assign it to block-cache and return.
	            var color = props.get(1, 0xcccccc);
	            debugString += color;
	            var diffuseTexture = new Single2DTexture_1.Single2DTexture(this._blocks[props.get(2, 0)].data);
	            if (type == 5) {
	                diffuseTexture.mappingMode = MappingMode_1.MappingMode.LINEAR_GRADIENT;
	            }
	            else if (type == 6) {
	                diffuseTexture.mappingMode = MappingMode_1.MappingMode.RADIAL_GRADIENT;
	            }
	            var basic_mat = new MethodMaterial_1.MethodMaterial();
	            basic_mat.ambientMethod.texture = diffuseTexture;
	            basic_mat.bothSides = true;
	            basic_mat.alphaBlending = props.get(11, false);
	            //basic_mat.preserveAlpha = basic_mat.alphaBlending;
	            //basic_mat.alphaBlending = true;
	            basic_mat.extra = this.parseUserAttributes();
	            this._pFinalizeAsset(basic_mat, name);
	            this._blocks[blockID].data = basic_mat;
	            if (this._debug)
	                console.log(debugString);
	            return;
	        }
	        mat.extra = this.parseUserAttributes();
	        this._pFinalizeAsset(mat, name);
	        this._blocks[blockID].data = mat;
	        if (this._debug)
	            console.log(debugString);
	    };
	    //Block ID = 82
	    AWDParser.prototype.parseTexture = function (blockID) {
	        this._blocks[blockID].name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedByte();
	        this._texture_users[this._cur_block_id] = [];
	        // External
	        if (type == 0) {
	            var url = this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedInt());
	            this._pAddDependency(this._cur_block_id.toString(), new URLRequest_1.URLRequest(url), false, null, true);
	        }
	        else {
	            var data_len = this._newBlockBytes.readUnsignedInt();
	            var data = new ByteArray_1.ByteArray(data_len);
	            this._newBlockBytes.readBytes(data, 0, data_len);
	            //
	            // AWD3Parserutils - Fix for FireFox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=715075 .
	            //
	            // Converting data to image here instead of parser - fix FireFox bug where image width / height is 0 when created from data
	            // This gives the browser time to initialise image width / height.
	            this._pAddDependency(this._cur_block_id.toString(), null, false, data, true);
	        }
	        // Ignore for now
	        this.parseProperties(null);
	        this._blocks[blockID].extras = this.parseUserAttributes();
	        this._pPauseAndRetrieveDependencies();
	        if (this._debug)
	            console.log("Start parsing a " + ["external", "embed"][type] + " Bitmap for Texture");
	    };
	    //Block ID = 83
	    AWDParser.prototype.parseCubeTexture = function (blockID) {
	        //blockLength = block.len;
	        var data_len;
	        var i;
	        this._texture_users[this._cur_block_id] = [];
	        var type = this._newBlockBytes.readUnsignedByte();
	        this._blocks[blockID].name = this.parseVarStr();
	        for (i = 0; i < 6; i++) {
	            this._texture_users[this._cur_block_id] = [];
	            // External
	            if (type == 0) {
	                data_len = this._newBlockBytes.readUnsignedInt();
	                var url;
	                url = this._newBlockBytes.readUTFBytes(data_len);
	                this._pAddDependency(this._cur_block_id.toString(), new URLRequest_1.URLRequest(url), false, null, true, i);
	            }
	            else {
	                data_len = this._newBlockBytes.readUnsignedInt();
	                var data = new ByteArray_1.ByteArray(data_len);
	                this._newBlockBytes.readBytes(data, 0, data_len);
	                this._pAddDependency(this._cur_block_id.toString(), null, false, ParserUtils_1.ParserUtils.byteArrayToImage(data), true, i);
	            }
	        }
	        // Ignore for now
	        this.parseProperties(null);
	        this._blocks[blockID].extras = this.parseUserAttributes();
	        this._pPauseAndRetrieveDependencies();
	        if (this._debug)
	            console.log("Start parsing 6 " + ["external", "embed"][type] + " Bitmaps for CubeTexture");
	    };
	    //Block ID = 91
	    AWDParser.prototype.parseSharedMethodBlock = function (blockID) {
	        var asset;
	        this._blocks[blockID].name = this.parseVarStr();
	        asset = this.parseSharedMethodList(blockID);
	        this.parseUserAttributes();
	        this._blocks[blockID].data = asset;
	        this._pFinalizeAsset(asset, this._blocks[blockID].name);
	        this._blocks[blockID].data = asset;
	        if (this._debug)
	            console.log("Parsed a EffectMethod: Name = " + asset.name + " Type = " + asset);
	    };
	    //Block ID = 92
	    AWDParser.prototype.parseShadowMethodBlock = function (blockID) {
	        this._blocks[blockID].name = this.parseVarStr();
	        var light = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var asset = this.parseShadowMethodList(light, blockID);
	        if (!asset)
	            return;
	        this.parseUserAttributes(); // Ignore for now
	        this._pFinalizeAsset(asset, this._blocks[blockID].name);
	        this._blocks[blockID].data = asset;
	        if (this._debug)
	            console.log("Parsed a ShadowMapMethodMethod: Name = " + asset.name + " | Type = " + asset + " | Light-Name = ", light.name);
	    };
	    //Block ID = 253
	    AWDParser.prototype.parseCommand = function (blockID) {
	        var hasBlocks = (this._newBlockBytes.readUnsignedByte() == 1);
	        var parentObject = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var targetObject;
	        var mtx = this.parseMatrix3D();
	        var name = this.parseVarStr();
	        var numCommands = this._newBlockBytes.readShort();
	        var typeCommand = this._newBlockBytes.readShort();
	        var props = this.parseProperties(AWDParser.commandProperties);
	        switch (typeCommand) {
	            case 1:
	                targetObject = this._blocks[props.get(1, 0)].data;
	                targetObject.transform.matrix3D = mtx;
	                if (parentObject)
	                    parentObject.addChild(targetObject);
	                break;
	        }
	        if (targetObject) {
	            props = this.parseProperties(AWDParser.targetProperties);
	            targetObject.pivot = new Vector3D_1.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
	            targetObject.extra = this.parseUserAttributes();
	        }
	        this._blocks[blockID].data = targetObject;
	        if (this._debug)
	            console.log("Parsed a CommandBlock: Name = '" + name);
	    };
	    //blockID 255
	    AWDParser.prototype.parseMetaData = function (blockID) {
	        var props = this.parseProperties(AWDParser.metaDataProperties);
	        if (this._debug) {
	            console.log("Parsed a MetaDataBlock: TimeStamp         = " + props.get(1, 0));
	            console.log("                        EncoderName       = " + props.get(2, "unknown"));
	            console.log("                        EncoderVersion    = " + props.get(3, "unknown"));
	            console.log("                        GeneratorName     = " + props.get(4, "unknown"));
	            console.log("                        GeneratorVersion  = " + props.get(5, "unknown"));
	        }
	    };
	    //blockID 254
	    AWDParser.prototype.parseNameSpace = function (blockID) {
	        var id = this._newBlockBytes.readUnsignedByte();
	        var nameSpaceString = this.parseVarStr();
	        if (this._debug)
	            console.log("Parsed a NameSpaceBlock: ID = " + id + " | String = " + nameSpaceString);
	    };
	    // this functions reads and creates a ShadowMethodMethod
	    AWDParser.prototype.parseShadowMethodList = function (light, blockID) {
	        var methodType = this._newBlockBytes.readUnsignedShort();
	        var shadowMethod;
	        var props = this.parseProperties(this.shadowMethodListProperties);
	        var targetID;
	        var returnedArray;
	        switch (methodType) {
	            //				case 1001: //CascadeShadowMapMethod
	            //					targetID = props.get(1, 0);
	            //					returnedArray = getAssetByID(targetID, [ShadowMapMethodBase.assetType]);
	            //					if (!returnedArray[0]) {
	            //						_blocks[blockID].addError("Could not find the ShadowBaseMethod (ID = " + targetID + " ) for this CascadeShadowMapMethod - ShadowMethod not created");
	            //						return shadowMethod;
	            //					}
	            //					shadowMethod = new CascadeShadowMapMethod(returnedArray[1]);
	            //					break;
	            case 1002:
	                shadowMethod = new ShadowNearMethod_1.ShadowNearMethod(this._blocks[props.get(1, 0)].data);
	                break;
	            case 1101:
	                shadowMethod = new ShadowFilteredMethod_1.ShadowFilteredMethod(light);
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                break;
	            case 1102:
	                shadowMethod = new ShadowDitheredMethod_1.ShadowDitheredMethod(light, props.get(201, 5));
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                shadowMethod.range = props.get(103, 1);
	                break;
	            case 1103:
	                shadowMethod = new ShadowSoftMethod_1.ShadowSoftMethod(light, props.get(201, 5));
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                shadowMethod.range = props.get(103, 1);
	                break;
	            case 1104:
	                shadowMethod = new ShadowHardMethod_1.ShadowHardMethod(light);
	                shadowMethod.alpha = props.get(101, 1);
	                shadowMethod.epsilon = props.get(102, 0.002);
	                break;
	        }
	        this.parseUserAttributes();
	        return shadowMethod;
	    };
	    //Block ID 101
	    AWDParser.prototype.parseSkeleton = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var num_joints = this._newBlockBytes.readUnsignedShort();
	        var skeleton = new Skeleton_1.Skeleton();
	        this.parseProperties(null); // Discard properties for now
	        for (var joints_parsed = 0; joints_parsed < num_joints; joints_parsed++) {
	            var joint;
	            var ibp;
	            // Ignore joint id
	            this._newBlockBytes.readUnsignedShort();
	            joint = new SkeletonJoint_1.SkeletonJoint();
	            joint.parentIndex = this._newBlockBytes.readUnsignedShort() - 1; // 0=null in AWD
	            joint.name = this.parseVarStr();
	            ibp = this.parseMatrix3D();
	            joint.inverseBindPose = ibp.rawData;
	            // Ignore joint props/attributes for now
	            this.parseProperties(null);
	            this.parseUserAttributes();
	            skeleton.joints.push(joint);
	        }
	        // Discard attributes for now
	        this.parseUserAttributes();
	        this._pFinalizeAsset(skeleton, name);
	        this._blocks[blockID].data = skeleton;
	        if (this._debug)
	            console.log("Parsed a Skeleton: Name = " + skeleton.name + " | Number of Joints = " + joints_parsed);
	    };
	    //Block ID = 102
	    AWDParser.prototype.parseSkeletonPose = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var num_joints = this._newBlockBytes.readUnsignedShort();
	        this.parseProperties(null); // Ignore properties for now
	        var pose = new SkeletonPose_1.SkeletonPose();
	        for (var joints_parsed = 0; joints_parsed < num_joints; joints_parsed++) {
	            var joint_pose;
	            var has_transform;
	            joint_pose = new JointPose_1.JointPose();
	            has_transform = this._newBlockBytes.readUnsignedByte();
	            if (has_transform == 1) {
	                var mtx_data = this.parseMatrix43RawData();
	                var mtx = new Matrix3D_1.Matrix3D(mtx_data);
	                joint_pose.orientation.fromMatrix(mtx);
	                joint_pose.translation.copyFrom(mtx.position);
	                pose.jointPoses[joints_parsed] = joint_pose;
	            }
	        }
	        // Skip attributes for now
	        this.parseUserAttributes();
	        this._pFinalizeAsset(pose, name);
	        this._blocks[blockID].data = pose;
	        if (this._debug)
	            console.log("Parsed a SkeletonPose: Name = " + pose.name + " | Number of Joints = " + joints_parsed);
	    };
	    //blockID 103
	    AWDParser.prototype.parseSkeletonAnimation = function (blockID /*uint*/) {
	        var frame_dur;
	        var pose_id;
	        var name = this.parseVarStr();
	        var clip = new SkeletonClipNode_1.SkeletonClipNode();
	        var num_frames = this._newBlockBytes.readUnsignedShort();
	        this.parseProperties(null); // Ignore properties for now
	        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
	            pose_id = this._newBlockBytes.readUnsignedInt();
	            frame_dur = this._newBlockBytes.readUnsignedShort();
	            clip.addFrame(this._blocks[pose_id].data, frame_dur);
	        }
	        if (clip.frames.length == 0) {
	            this._blocks[blockID].addError("Could not this SkeletonClipNode, because no Frames where set.");
	            return;
	        }
	        // Ignore attributes for now
	        this.parseUserAttributes();
	        this._pFinalizeAsset(clip, name);
	        this._blocks[blockID].data = clip;
	        if (this._debug)
	            console.log("Parsed a SkeletonClipNode: Name = " + clip.name + " | Number of Frames = " + clip.frames.length);
	    };
	    //Block ID = 111 /  Block ID = 112
	    AWDParser.prototype.parseSpritePoseAnimation = function (blockID /*uint*/, poseOnly) {
	        if (poseOnly === void 0) { poseOnly = false; }
	        var subSpriteParsed;
	        var x;
	        var y;
	        var z;
	        var str_len;
	        var str_end;
	        var elements;
	        var idx = 0;
	        var clip = new VertexClipNode_1.VertexClipNode();
	        var indices;
	        var verts;
	        var streamtypes = new Array();
	        var props;
	        var name = this.parseVarStr();
	        var geo_id = this._newBlockBytes.readUnsignedInt();
	        var graphics = this._blocks[geo_id].data;
	        var uvs = this.getUVForVertexAnimation(geo_id);
	        var num_frames = (!poseOnly) ? this._newBlockBytes.readUnsignedShort() : 1;
	        var num_subsprites = this._newBlockBytes.readUnsignedShort();
	        var num_Streams = this._newBlockBytes.readUnsignedShort();
	        for (var streamsParsed = 0; streamsParsed < num_Streams; streamsParsed++)
	            streamtypes.push(this._newBlockBytes.readUnsignedShort());
	        props = this.parseProperties(this.spritePoseAnimationProperties);
	        clip.looping = props.get(1, true);
	        clip.stitchFinalFrame = props.get(2, false);
	        var frame_dur;
	        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
	            frame_dur = this._newBlockBytes.readUnsignedShort();
	            graphics = new Graphics_1.Graphics();
	            subSpriteParsed = 0;
	            while (subSpriteParsed < num_subsprites) {
	                streamsParsed = 0;
	                str_len = this._newBlockBytes.readUnsignedInt();
	                str_end = this._newBlockBytes.position + str_len;
	                while (streamsParsed < num_Streams) {
	                    if (streamtypes[streamsParsed] == 1) {
	                        indices = graphics.getGraphicAt(subSpriteParsed).elements.indices;
	                        verts = new Array();
	                        idx = 0;
	                        while (this._newBlockBytes.position < str_end) {
	                            x = this.readNumber(this._accuracyGeo);
	                            y = this.readNumber(this._accuracyGeo);
	                            z = this.readNumber(this._accuracyGeo);
	                            verts[idx++] = x;
	                            verts[idx++] = y;
	                            verts[idx++] = z;
	                        }
	                        elements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	                        elements.setIndices(indices);
	                        elements.setPositions(verts);
	                        elements.setUVs(uvs[subSpriteParsed]);
	                        elements.setNormals(null);
	                        elements.setTangents(null);
	                        elements.autoDeriveNormals = false;
	                        elements.autoDeriveTangents = false;
	                        subSpriteParsed++;
	                        graphics.addGraphic(elements);
	                    }
	                    else
	                        this._newBlockBytes.position = str_end;
	                    streamsParsed++;
	                }
	            }
	            clip.addFrame(graphics, frame_dur);
	        }
	        this.parseUserAttributes();
	        this._pFinalizeAsset(clip, name);
	        this._blocks[blockID].data = clip;
	        if (this._debug)
	            console.log("Parsed a VertexClipNode: Name = " + clip.name + " | Target-Graphics-Name = " + graphics.name + " | Number of Frames = " + clip.frames.length);
	    };
	    //BlockID 113
	    AWDParser.prototype.parseVertexAnimationSet = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var num_frames = this._newBlockBytes.readUnsignedShort();
	        var props = this.parseProperties(AWDParser.vertexAnimationSetProperties);
	        var skeletonFrames = new Array();
	        var vertexFrames = new Array();
	        var clipNode;
	        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
	            clipNode = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	            if (clipNode instanceof VertexClipNode_1.VertexClipNode)
	                vertexFrames.push(clipNode);
	            else if (clipNode instanceof SkeletonClipNode_1.SkeletonClipNode)
	                skeletonFrames.push(clipNode);
	        }
	        if ((vertexFrames.length == 0) && (skeletonFrames.length == 0)) {
	            this._blocks[blockID].addError("Could not create this AnimationSet, because it contains no animations");
	            return;
	        }
	        this.parseUserAttributes();
	        if (vertexFrames.length > 0) {
	            var newVertexAnimationSet = new VertexAnimationSet_1.VertexAnimationSet();
	            for (var i = 0; i < vertexFrames.length; i++)
	                newVertexAnimationSet.addAnimation(vertexFrames[i]);
	            this._pFinalizeAsset(newVertexAnimationSet, name);
	            this._blocks[blockID].data = newVertexAnimationSet;
	            if (this._debug)
	                console.log("Parsed a VertexAnimationSet: Name = " + name + " | Animations = " + newVertexAnimationSet.animations.length + " | Animation-Names = " + newVertexAnimationSet.animationNames);
	        }
	        else if (skeletonFrames.length > 0) {
	            var newSkeletonAnimationSet = new SkeletonAnimationSet_1.SkeletonAnimationSet(props.get(1, 4)); //props.get(1,4));
	            for (var i = 0; i < skeletonFrames.length; i++)
	                newSkeletonAnimationSet.addAnimation(skeletonFrames[i]);
	            this._pFinalizeAsset(newSkeletonAnimationSet, name);
	            this._blocks[blockID].data = newSkeletonAnimationSet;
	            if (this._debug)
	                console.log("Parsed a SkeletonAnimationSet: Name = " + name + " | Animations = " + newSkeletonAnimationSet.animations.length + " | Animation-Names = " + newSkeletonAnimationSet.animationNames);
	        }
	    };
	    //BlockID 122
	    AWDParser.prototype.parseAnimatorSet = function (blockID /*uint*/) {
	        var name = this.parseVarStr();
	        var type = this._newBlockBytes.readUnsignedShort();
	        var props = this.parseProperties(AWDParser.animatorSetProperties);
	        var targetAnimationSet = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
	        var targetSpritees = new Array();
	        var targetSpriteLength = this._newBlockBytes.readUnsignedShort();
	        for (var i = 0; i < targetSpriteLength; i++)
	            targetSpritees.push(this._blocks[this._newBlockBytes.readUnsignedInt()].data);
	        var activeState = this._newBlockBytes.readUnsignedShort();
	        var autoplay = (this._newBlockBytes.readUnsignedByte() == 1);
	        this.parseUserAttributes();
	        this.parseUserAttributes();
	        var thisAnimator;
	        if (type == 1)
	            thisAnimator = new SkeletonAnimator_1.SkeletonAnimator(targetAnimationSet, this._blocks[props.get(1, 0)].data);
	        else if (type == 2)
	            thisAnimator = new VertexAnimator_1.VertexAnimator(targetAnimationSet);
	        this._pFinalizeAsset(thisAnimator, name);
	        this._blocks[blockID].data = thisAnimator;
	        for (i = 0; i < targetSpritees.length; i++) {
	            if (type == 1)
	                targetSpritees[i].animator = thisAnimator;
	            else if (type == 2)
	                targetSpritees[i].animator = thisAnimator;
	        }
	        if (this._debug)
	            console.log("Parsed a Animator: Name = " + name);
	    };
	    // this functions reads and creates a EffectMethod
	    AWDParser.prototype.parseSharedMethodList = function (blockID) {
	        var methodType = this._newBlockBytes.readUnsignedShort();
	        var effectMethodReturn;
	        var props = this.parseProperties(this.sharedMethodListProperties);
	        switch (methodType) {
	            // Effect Methods
	            case 401:
	                effectMethodReturn = new EffectColorMatrixMethod_1.EffectColorMatrixMethod(props.get(101, new Array(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)));
	                break;
	            case 402:
	                effectMethodReturn = new EffectColorTransformMethod_1.EffectColorTransformMethod();
	                var offCol = props.get(601, 0x00000000);
	                effectMethodReturn.colorTransform = new ColorTransform_1.ColorTransform(props.get(102, 1), props.get(103, 1), props.get(104, 1), props.get(101, 1), ((offCol >> 16) & 0xFF), ((offCol >> 8) & 0xFF), (offCol & 0xFF), ((offCol >> 24) & 0xFF));
	                break;
	            case 403:
	                effectMethodReturn = new EffectEnvMapMethod_1.EffectEnvMapMethod(new SingleCubeTexture_1.SingleCubeTexture(this._blocks[props.get(1, 0)].data), props.get(101, 1));
	                var targetID = props.get(2, 0);
	                if (targetID > 0) {
	                }
	                break;
	            case 404:
	                effectMethodReturn = new EffectLightMapMethod_1.EffectLightMapMethod(this._blocks[props.get(1, 0)].data, this.blendModeDic[props.get(401, 10)]); //usesecondaryUV not set
	                break;
	            //				case 405: //ProjectiveTextureMethod
	            //					targetID = props.get(1, 0);
	            //					returnedArray = getAssetByID(targetID, [TextureProjector.assetType]);
	            //					if (!returnedArray[0])
	            //						_blocks[blockID].addError("Could not find the TextureProjector (ID = " + targetID + " ) for this ProjectiveTextureMethod");
	            //					effectMethodReturn = new ProjectiveTextureMethod(returnedArray[1], blendModeDic[props.get(401, 10)]);
	            //					break;
	            case 406:
	                effectMethodReturn = new EffectRimLightMethod_1.EffectRimLightMethod(props.get(601, 0xffffff), props.get(101, 0.4), props.get(101, 2)); //blendMode
	                break;
	            case 407:
	                effectMethodReturn = new EffectAlphaMaskMethod_1.EffectAlphaMaskMethod(this._blocks[props.get(1, 0)].data, props.get(701, false));
	                break;
	            //				case 408: //RefractionEnvMapMethod
	            //					targetID = props.get(1, 0);
	            //					returnedArray = getAssetByID(targetID, [TextureBase.assetType], "CubeTexture");
	            //					if (!returnedArray[0])
	            //						_blocks[blockID].addError("Could not find the EnvMap (ID = " + targetID + " ) for this RefractionEnvMapMethod");
	            //					effectMethodReturn = new RefractionEnvMapMethod(returnedArray[1], props.get(101, 0.1), props.get(102, 0.01), props.get(103, 0.01), props.get(104, 0.01));
	            //					RefractionEnvMapMethod(effectMethodReturn).alpha = props.get(104, 1);
	            //					break;
	            //				case 409: //OutlineMethod
	            //					effectMethodReturn = new OutlineMethod(props.get(601, 0x00000000), props.get(101, 1), props.get(701, true), props.get(702, false));
	            //					break;
	            case 410:
	                effectMethodReturn = new EffectFresnelEnvMapMethod_1.EffectFresnelEnvMapMethod(this._blocks[props.get(1, 0)].data, props.get(101, 1));
	                break;
	            case 411:
	                effectMethodReturn = new EffectFogMethod_1.EffectFogMethod(props.get(101, 0), props.get(102, 1000), props.get(601, 0x808080));
	                break;
	        }
	        this.parseUserAttributes();
	        return effectMethodReturn;
	    };
	    AWDParser.prototype.parseUserAttributes = function () {
	        var list_len = this._newBlockBytes.readUnsignedInt();
	        if (list_len > 0) {
	            var list_end = this._newBlockBytes.position + list_len;
	            var attributes = {};
	            for (var attibuteCnt = 0; this._newBlockBytes.position < list_end; attibuteCnt++) {
	                var ns_id;
	                var attr_key;
	                var attr_type;
	                var attr_len;
	                var attr_val;
	                // TODO: Properly tend to namespaces in attributes
	                ns_id = this._newBlockBytes.readUnsignedByte();
	                attr_key = this.parseVarStr();
	                attr_type = this._newBlockBytes.readUnsignedByte();
	                attr_len = this._newBlockBytes.readUnsignedInt();
	                if ((this._newBlockBytes.position + attr_len) > list_end) {
	                    console.log("           Error in reading attribute # " + attibuteCnt + " = skipped to end of attribute-list");
	                    this._newBlockBytes.position = list_end;
	                    return attributes;
	                }
	                switch (attr_type) {
	                    case AWDParser.AWDSTRING:
	                        attr_val = this._newBlockBytes.readUTFBytes(attr_len);
	                        break;
	                    case AWDParser.INT8:
	                        attr_val = this._newBlockBytes.readByte();
	                        break;
	                    case AWDParser.INT16:
	                        attr_val = this._newBlockBytes.readShort();
	                        break;
	                    case AWDParser.INT32:
	                        attr_val = this._newBlockBytes.readInt();
	                        break;
	                    case AWDParser.BOOL:
	                    case AWDParser.UINT8:
	                        attr_val = this._newBlockBytes.readUnsignedByte();
	                        break;
	                    case AWDParser.UINT16:
	                        attr_val = this._newBlockBytes.readUnsignedShort();
	                        break;
	                    case AWDParser.UINT32:
	                    case AWDParser.BADDR:
	                        attr_val = this._newBlockBytes.readUnsignedInt();
	                        break;
	                    case AWDParser.FLOAT32:
	                        attr_val = this._newBlockBytes.readFloat();
	                        break;
	                    case AWDParser.FLOAT64:
	                        attr_val = this._newBlockBytes.readDouble();
	                        break;
	                    default:
	                        attr_val = 'unimplemented attribute type ' + attr_type;
	                        this._newBlockBytes.position += attr_len;
	                        break;
	                }
	                attributes[attr_key] = attr_val;
	                if (this._debug)
	                    console.log("attribute = name: " + attr_key + "  / value = " + attr_val);
	            }
	        }
	        return attributes;
	    };
	    AWDParser.prototype.parseProperties = function (expected) {
	        var list_len = this._newBlockBytes.readUnsignedInt();
	        var props = new AWDProperties();
	        var list_end = this._newBlockBytes.position + list_len;
	        if (expected) {
	            var len;
	            var key;
	            var type;
	            for (var propertyCnt = 0; this._newBlockBytes.position < list_end; propertyCnt++) {
	                key = this._newBlockBytes.readUnsignedShort();
	                len = this._newBlockBytes.readUnsignedInt();
	                if ((this._newBlockBytes.position + len) > list_end) {
	                    console.log("           Error in reading property # " + propertyCnt + " = skipped to end of propertie-list");
	                    this._newBlockBytes.position = list_end;
	                    return props;
	                }
	                if (expected[key]) {
	                    type = expected[key];
	                    props.set(key, this.parseAttrValue(type, len));
	                }
	                else {
	                    this._newBlockBytes.position += len;
	                }
	            }
	        }
	        else {
	            this._newBlockBytes.position = list_end;
	        }
	        return props;
	    };
	    AWDParser.prototype.parseAttrValue = function (type, len) {
	        var elem_len;
	        var read_func;
	        var accuracy;
	        switch (type) {
	            case AWDParser.BOOL:
	            case AWDParser.INT8:
	                elem_len = 1;
	                read_func = this._newBlockBytes.readByte;
	                break;
	            case AWDParser.INT16:
	                elem_len = 2;
	                read_func = this._newBlockBytes.readShort;
	                break;
	            case AWDParser.INT32:
	                elem_len = 4;
	                read_func = this._newBlockBytes.readInt;
	                break;
	            case AWDParser.UINT8:
	                elem_len = 1;
	                read_func = this._newBlockBytes.readUnsignedByte;
	                break;
	            case AWDParser.UINT16:
	                elem_len = 2;
	                read_func = this._newBlockBytes.readUnsignedShort;
	                break;
	            case AWDParser.UINT32:
	            case AWDParser.COLOR:
	            case AWDParser.BADDR:
	                elem_len = 4;
	                read_func = this._newBlockBytes.readUnsignedInt;
	                break;
	            case AWDParser.FLOAT32:
	                elem_len = 4;
	                read_func = this._newBlockBytes.readFloat;
	                break;
	            case AWDParser.FLOAT64:
	                elem_len = 8;
	                read_func = this._newBlockBytes.readDouble;
	                break;
	            case AWDParser.AWDSTRING:
	                return this._newBlockBytes.readUTFBytes(len);
	            case AWDParser.VECTOR2x1:
	            case AWDParser.VECTOR3x1:
	            case AWDParser.VECTOR4x1:
	            case AWDParser.MTX3x2:
	            case AWDParser.MTX3x3:
	            case AWDParser.MTX4x3:
	            case AWDParser.MTX4x4:
	                elem_len = 8;
	                read_func = this._newBlockBytes.readDouble;
	                break;
	            case AWDParser.GEO_NUMBER:
	                accuracy = this._accuracyGeo;
	            case AWDParser.MATRIX_NUMBER:
	                accuracy = this._accuracyMatrix;
	            case AWDParser.PROPERTY_NUMBER:
	                accuracy = this._accuracyProps;
	            default:
	                if (accuracy) {
	                    elem_len = 8;
	                    read_func = this._newBlockBytes.readDouble;
	                }
	                else {
	                    elem_len = 4;
	                    read_func = this._newBlockBytes.readFloat;
	                }
	        }
	        if (elem_len < len) {
	            var list = [];
	            var num_elems = len / elem_len;
	            for (var num_read = 0; num_read < num_elems; num_read++)
	                list[num_read] = read_func.call(this._newBlockBytes);
	            return list;
	        }
	        else {
	            return read_func.call(this._newBlockBytes);
	        }
	    };
	    AWDParser.prototype.parseHeader = function () {
	        this._byteData.position = 3; // Skip magic string and parse version
	        this._version[0] = this._byteData.readUnsignedByte();
	        this._version[1] = this._byteData.readUnsignedByte();
	        var flags = this._byteData.readUnsignedShort(); // Parse bit flags
	        this._streaming = BitFlags.test(flags, BitFlags.FLAG1);
	        // if we set _accuracyOnBlocks, the precision-values are read from each block-header.
	        if ((this._version[0] == 2) && (this._version[1] == 1)) {
	            this._accuracyMatrix = BitFlags.test(flags, BitFlags.FLAG2);
	            this._accuracyGeo = BitFlags.test(flags, BitFlags.FLAG3);
	            this._accuracyProps = BitFlags.test(flags, BitFlags.FLAG4);
	        }
	        this._compression = this._byteData.readUnsignedByte(); // compression
	        if (this._debug) {
	            console.log("Import AWDFile of version = " + this._version[0] + " - " + this._version[1]);
	            console.log("Global Settings = Compression = " + this._compression + " | Streaming = " + this._streaming + " | Matrix-Precision = " + this._accuracyMatrix + " | Graphics-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
	        }
	        // Check file integrity
	        var body_len = this._byteData.readUnsignedInt();
	        if (!this._streaming && body_len != this._byteData.getBytesAvailable())
	            this._pDieWithError('AWD2 body length does not match header integrity field');
	    };
	    // Helper - functions
	    AWDParser.prototype.getUVForVertexAnimation = function (spriteID /*uint*/) {
	        if (this._blocks[spriteID].data instanceof Sprite_1.Sprite)
	            spriteID = this._blocks[spriteID].geoID;
	        if (this._blocks[spriteID].uvsForVertexAnimation)
	            return this._blocks[spriteID].uvsForVertexAnimation;
	        var graphics = this._blocks[spriteID].data;
	        var elements;
	        var uvsForVertexAnimation = this._blocks[spriteID].uvsForVertexAnimation = new Array();
	        var len = graphics.count;
	        for (var geoCnt = 0; geoCnt < len; geoCnt++) {
	            elements = graphics.getGraphicAt(geoCnt).elements;
	            uvsForVertexAnimation[geoCnt] = elements.uvs.get(elements.numVertices);
	        }
	        return this._blocks[spriteID].uvsForVertexAnimation;
	    };
	    AWDParser.prototype.parseVarStr = function () {
	        return this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedShort());
	    };
	    AWDParser.prototype.readNumber = function (precision) {
	        if (precision === void 0) { precision = false; }
	        if (precision)
	            return this._newBlockBytes.readDouble();
	        return this._newBlockBytes.readFloat();
	    };
	    AWDParser.prototype.parseMatrix3D = function () {
	        return new Matrix3D_1.Matrix3D(this.parseMatrix43RawData());
	    };
	    AWDParser.prototype.parseMatrix32RawData = function () {
	        var mtx_raw = new Float32Array(6);
	        for (var i = 0; i < 6; i++)
	            mtx_raw[i] = this._newBlockBytes.readFloat();
	        return mtx_raw;
	    };
	    AWDParser.prototype.parseMatrix43RawData = function () {
	        var mtx_raw = new Float32Array(16);
	        mtx_raw[0] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[1] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[2] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[3] = 0.0;
	        mtx_raw[4] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[5] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[6] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[7] = 0.0;
	        mtx_raw[8] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[9] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[10] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[11] = 0.0;
	        mtx_raw[12] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[13] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[14] = this.readNumber(this._accuracyMatrix);
	        mtx_raw[15] = 1.0;
	        //TODO: fix max exporter to remove NaN values in joint 0 inverse bind pose
	        if (isNaN(mtx_raw[0])) {
	            mtx_raw[0] = 1;
	            mtx_raw[1] = 0;
	            mtx_raw[2] = 0;
	            mtx_raw[4] = 0;
	            mtx_raw[5] = 1;
	            mtx_raw[6] = 0;
	            mtx_raw[8] = 0;
	            mtx_raw[9] = 0;
	            mtx_raw[10] = 1;
	            mtx_raw[12] = 0;
	            mtx_raw[13] = 0;
	            mtx_raw[14] = 0;
	        }
	        return mtx_raw;
	    };
	    AWDParser.COMPRESSIONMODE_LZMA = "lzma";
	    AWDParser.UNCOMPRESSED = 0;
	    AWDParser.DEFLATE = 1;
	    AWDParser.LZMA = 2;
	    AWDParser.INT8 = 1;
	    AWDParser.INT16 = 2;
	    AWDParser.INT32 = 3;
	    AWDParser.UINT8 = 4;
	    AWDParser.UINT16 = 5;
	    AWDParser.UINT32 = 6;
	    AWDParser.FLOAT32 = 7;
	    AWDParser.FLOAT64 = 8;
	    AWDParser.BOOL = 21;
	    AWDParser.COLOR = 22;
	    AWDParser.BADDR = 23;
	    AWDParser.AWDSTRING = 31;
	    AWDParser.AWDBYTEARRAY = 32;
	    AWDParser.VECTOR2x1 = 41;
	    AWDParser.VECTOR3x1 = 42;
	    AWDParser.VECTOR4x1 = 43;
	    AWDParser.MTX3x2 = 44;
	    AWDParser.MTX3x3 = 45;
	    AWDParser.MTX4x3 = 46;
	    AWDParser.MTX4x4 = 47;
	    AWDParser.GEO_NUMBER = 48;
	    AWDParser.MATRIX_NUMBER = 49;
	    AWDParser.PROPERTY_NUMBER = 50;
	    AWDParser.textFormatProperties = {
	        1: AWDParser.UINT16,
	        2: AWDParser.FLOAT32,
	        3: AWDParser.UINT8,
	        4: AWDParser.UINT8,
	        5: AWDParser.UINT8,
	        6: AWDParser.UINT8,
	        7: AWDParser.FLOAT32,
	        8: AWDParser.FLOAT32,
	        9: AWDParser.FLOAT32,
	        10: AWDParser.FLOAT32,
	        11: AWDParser.COLOR }; //line spacing
	    AWDParser.textFieldProperties = {
	        1: AWDParser.BOOL,
	        3: AWDParser.BOOL,
	        4: AWDParser.BOOL,
	        5: AWDParser.BOOL,
	        7: AWDParser.UINT8,
	        8: AWDParser.UINT8,
	        9: AWDParser.UINT8 };
	    AWDParser.textFieldTypes = ["static", "dynamic", "input", "input"];
	    AWDParser.movieClipProperties = {
	        1: AWDParser.FLOAT32,
	        2: AWDParser.UINT16,
	        3: AWDParser.UINT8 }; // scripting-language right now its always as2
	    AWDParser.graphicsProperties = {
	        1: AWDParser.GEO_NUMBER,
	        2: AWDParser.GEO_NUMBER };
	    AWDParser.elementsProperties = {
	        1: AWDParser.GEO_NUMBER,
	        2: AWDParser.GEO_NUMBER };
	    AWDParser.primitiveProperties = {
	        101: AWDParser.GEO_NUMBER,
	        102: AWDParser.GEO_NUMBER,
	        103: AWDParser.GEO_NUMBER,
	        110: AWDParser.GEO_NUMBER,
	        111: AWDParser.GEO_NUMBER,
	        301: AWDParser.UINT16,
	        302: AWDParser.UINT16,
	        303: AWDParser.UINT16,
	        701: AWDParser.BOOL,
	        702: AWDParser.BOOL,
	        703: AWDParser.BOOL,
	        704: AWDParser.BOOL };
	    AWDParser.primitiveTypes = ["Unsupported Type-ID", "PrimitivePlanePrefab", "PrimitiveCubePrefab", "PrimitiveSpherePrefab", "PrimitiveCylinderPrefab", "PrimitivesConePrefab", "PrimitivesCapsulePrefab", "PrimitivesTorusPrefab"];
	    AWDParser.containerProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8 };
	    AWDParser.spriteInstanceProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8,
	        5: AWDParser.BOOL };
	    AWDParser.lightProperties = {
	        1: AWDParser.PROPERTY_NUMBER,
	        2: AWDParser.PROPERTY_NUMBER,
	        3: AWDParser.COLOR,
	        4: AWDParser.PROPERTY_NUMBER,
	        5: AWDParser.PROPERTY_NUMBER,
	        6: AWDParser.BOOL,
	        7: AWDParser.COLOR,
	        8: AWDParser.PROPERTY_NUMBER,
	        9: AWDParser.UINT8,
	        10: AWDParser.UINT8,
	        11: AWDParser.PROPERTY_NUMBER,
	        12: AWDParser.UINT16,
	        21: AWDParser.MATRIX_NUMBER,
	        22: AWDParser.MATRIX_NUMBER,
	        23: AWDParser.MATRIX_NUMBER };
	    AWDParser.cameraProperties = {
	        101: AWDParser.PROPERTY_NUMBER,
	        102: AWDParser.PROPERTY_NUMBER,
	        103: AWDParser.PROPERTY_NUMBER,
	        104: AWDParser.PROPERTY_NUMBER };
	    AWDParser.cameraPivotProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8 };
	    // (1=color, 2=bitmap url, 10=alpha, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
	    AWDParser.materialProperties = {
	        1: AWDParser.INT32,
	        2: AWDParser.BADDR,
	        10: AWDParser.PROPERTY_NUMBER,
	        11: AWDParser.BOOL,
	        12: AWDParser.PROPERTY_NUMBER,
	        13: AWDParser.BOOL };
	    AWDParser.material_v1Properties = { 1: AWDParser.UINT32,
	        2: AWDParser.BADDR,
	        3: AWDParser.BADDR,
	        4: AWDParser.UINT8,
	        5: AWDParser.BOOL,
	        6: AWDParser.BOOL,
	        7: AWDParser.BOOL,
	        8: AWDParser.BOOL,
	        9: AWDParser.UINT8,
	        10: AWDParser.PROPERTY_NUMBER,
	        11: AWDParser.BOOL,
	        12: AWDParser.PROPERTY_NUMBER,
	        13: AWDParser.BOOL,
	        15: AWDParser.PROPERTY_NUMBER,
	        16: AWDParser.UINT32,
	        17: AWDParser.BADDR,
	        18: AWDParser.PROPERTY_NUMBER,
	        19: AWDParser.PROPERTY_NUMBER,
	        20: AWDParser.UINT32,
	        21: AWDParser.BADDR,
	        22: AWDParser.BADDR };
	    AWDParser.method_v1Properties = {
	        1: AWDParser.BADDR,
	        2: AWDParser.BADDR,
	        3: AWDParser.BADDR,
	        101: AWDParser.PROPERTY_NUMBER,
	        102: AWDParser.PROPERTY_NUMBER,
	        103: AWDParser.PROPERTY_NUMBER,
	        201: AWDParser.UINT32,
	        202: AWDParser.UINT32,
	        301: AWDParser.UINT16,
	        302: AWDParser.UINT16,
	        401: AWDParser.UINT8,
	        402: AWDParser.UINT8,
	        601: AWDParser.COLOR,
	        602: AWDParser.COLOR,
	        701: AWDParser.BOOL,
	        702: AWDParser.BOOL,
	        801: AWDParser.MTX4x4 };
	    AWDParser.commandProperties = {
	        1: AWDParser.BADDR };
	    AWDParser.targetProperties = {
	        1: AWDParser.MATRIX_NUMBER,
	        2: AWDParser.MATRIX_NUMBER,
	        3: AWDParser.MATRIX_NUMBER,
	        4: AWDParser.UINT8 };
	    AWDParser.metaDataProperties = {
	        1: AWDParser.UINT32,
	        2: AWDParser.AWDSTRING,
	        3: AWDParser.AWDSTRING,
	        4: AWDParser.AWDSTRING,
	        5: AWDParser.AWDSTRING };
	    AWDParser.vertexAnimationSetProperties = {
	        1: AWDParser.UINT16 };
	    AWDParser.animatorSetProperties = { 1: AWDParser.BADDR };
	    return AWDParser;
	}(ParserBase_1.ParserBase));
	exports.AWDParser = AWDParser;
	var ElementType = (function () {
	    function ElementType() {
	    }
	    ElementType.STANDART_STREAMS = 0;
	    ElementType.CONCENATED_STREAMS = 1;
	    ElementType.SHARED_BUFFER = 2;
	    ElementType.CONCATENATED_SUBGEO = 3;
	    ElementType.SHARED_INDEXBUFFER = 4;
	    return ElementType;
	}());
	var AWDProperties = (function () {
	    function AWDProperties() {
	    }
	    AWDProperties.prototype.set = function (key, value) {
	        this[key] = value;
	    };
	    AWDProperties.prototype.get = function (key, fallback) {
	        return (this[key] || fallback);
	    };
	    return AWDProperties;
	}());
	/**
	 *
	 */
	var BitFlags = (function () {
	    function BitFlags() {
	    }
	    BitFlags.test = function (flags, testFlag) {
	        return (flags & testFlag) == testFlag;
	    };
	    BitFlags.FLAG1 = 1;
	    BitFlags.FLAG2 = 2;
	    BitFlags.FLAG3 = 4;
	    BitFlags.FLAG4 = 8;
	    BitFlags.FLAG5 = 16;
	    BitFlags.FLAG6 = 32;
	    BitFlags.FLAG7 = 64;
	    BitFlags.FLAG8 = 128;
	    BitFlags.FLAG9 = 256;
	    BitFlags.FLAG10 = 512;
	    BitFlags.FLAG11 = 1024;
	    BitFlags.FLAG12 = 2048;
	    BitFlags.FLAG13 = 4096;
	    BitFlags.FLAG14 = 8192;
	    BitFlags.FLAG15 = 16384;
	    BitFlags.FLAG16 = 32768;
	    return BitFlags;
	}());


/***/ },
/* 306 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Vector3D_1 = __webpack_require__(34);
	var ProjectionBase_1 = __webpack_require__(145);
	var OrthographicProjection = (function (_super) {
	    __extends(OrthographicProjection, _super);
	    function OrthographicProjection(projectionHeight) {
	        if (projectionHeight === void 0) { projectionHeight = 500; }
	        _super.call(this);
	        this._projectionHeight = projectionHeight;
	    }
	    Object.defineProperty(OrthographicProjection.prototype, "projectionHeight", {
	        get: function () {
	            return this._projectionHeight;
	        },
	        set: function (value) {
	            if (value == this._projectionHeight) {
	                return;
	            }
	            this._projectionHeight = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    OrthographicProjection.prototype.unproject = function (nX, nY, sZ) {
	        var v = new Vector3D_1.Vector3D(nX + this.matrix.rawData[12], -nY + this.matrix.rawData[13], sZ, 1.0);
	        v = this.unprojectionMatrix.transformVector(v);
	        //z is unaffected by transform
	        v.z = sZ;
	        return v;
	    };
	    //@override
	    OrthographicProjection.prototype.clone = function () {
	        var clone = new OrthographicProjection();
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        clone.projectionHeight = this._projectionHeight;
	        return clone;
	    };
	    //@override
	    OrthographicProjection.prototype.pUpdateMatrix = function () {
	        var raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        this._yMax = this._projectionHeight * .5;
	        this._xMax = this._yMax * this._pAspectRatio;
	        var left;
	        var right;
	        var top;
	        var bottom;
	        if (this._pScissorRect.x == 0 && this._pScissorRect.y == 0 && this._pScissorRect.width == this._pViewPort.width && this._pScissorRect.height == this._pViewPort.height) {
	            // assume symmetric frustum
	            left = -this._xMax;
	            right = this._xMax;
	            top = -this._yMax;
	            bottom = this._yMax;
	            raw[0] = 2 / (this._projectionHeight * this._pAspectRatio);
	            raw[5] = 2 / this._projectionHeight;
	            raw[10] = 1 / (this._pFar - this._pNear);
	            raw[14] = this._pNear / (this._pNear - this._pFar);
	            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = raw[12] = raw[13] = 0;
	            raw[15] = 1;
	        }
	        else {
	            var xWidth = this._xMax * (this._pViewPort.width / this._pScissorRect.width);
	            var yHgt = this._yMax * (this._pViewPort.height / this._pScissorRect.height);
	            var center = this._xMax * (this._pScissorRect.x * 2 - this._pViewPort.width) / this._pScissorRect.width + this._xMax;
	            var middle = -this._yMax * (this._pScissorRect.y * 2 - this._pViewPort.height) / this._pScissorRect.height - this._yMax;
	            left = center - xWidth;
	            right = center + xWidth;
	            top = middle - yHgt;
	            bottom = middle + yHgt;
	            raw[0] = 2 * 1 / (right - left);
	            raw[5] = -2 * 1 / (top - bottom);
	            raw[10] = 1 / (this._pFar - this._pNear);
	            raw[12] = (right + left) / (right - left);
	            raw[13] = (bottom + top) / (bottom - top);
	            raw[14] = this._pNear / (this.near - this.far);
	            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	            raw[15] = 1;
	        }
	        this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pFrustumCorners[12] = this._pFrustumCorners[21] = left;
	        this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pFrustumCorners[15] = this._pFrustumCorners[18] = right;
	        this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pFrustumCorners[13] = this._pFrustumCorners[16] = top;
	        this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pFrustumCorners[19] = this._pFrustumCorners[22] = bottom;
	        this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
	        this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;
	        this._pMatrix.copyRawDataFrom(raw);
	        this._pMatrixInvalid = false;
	    };
	    return OrthographicProjection;
	}(ProjectionBase_1.ProjectionBase));
	exports.OrthographicProjection = OrthographicProjection;


/***/ },
/* 307 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Vector3D_1 = __webpack_require__(34);
	var ProjectionBase_1 = __webpack_require__(145);
	var OrthographicOffCenterProjection = (function (_super) {
	    __extends(OrthographicOffCenterProjection, _super);
	    function OrthographicOffCenterProjection(minX, maxX, minY, maxY) {
	        _super.call(this);
	        this._minX = minX;
	        this._maxX = maxX;
	        this._minY = minY;
	        this._maxY = maxY;
	    }
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "minX", {
	        get: function () {
	            return this._minX;
	        },
	        set: function (value) {
	            this._minX = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "maxX", {
	        get: function () {
	            return this._maxX;
	        },
	        set: function (value) {
	            this._maxX = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "minY", {
	        get: function () {
	            return this._minY;
	        },
	        set: function (value) {
	            this._minY = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(OrthographicOffCenterProjection.prototype, "maxY", {
	        get: function () {
	            return this._maxY;
	        },
	        set: function (value) {
	            this._maxY = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    OrthographicOffCenterProjection.prototype.unproject = function (nX, nY, sZ) {
	        var v = new Vector3D_1.Vector3D(nX, -nY, sZ, 1.0);
	        v = this.unprojectionMatrix.transformVector(v);
	        //z is unaffected by transform
	        v.z = sZ;
	        return v;
	    };
	    //@override
	    OrthographicOffCenterProjection.prototype.clone = function () {
	        var clone = new OrthographicOffCenterProjection(this._minX, this._maxX, this._minY, this._maxY);
	        clone._pNear = this._pNear;
	        clone._pFar = this._pFar;
	        clone._pAspectRatio = this._pAspectRatio;
	        return clone;
	    };
	    //@override
	    OrthographicOffCenterProjection.prototype.pUpdateMatrix = function () {
	        var raw = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        var w = 1 / (this._maxX - this._minX);
	        var h = 1 / (this._maxY - this._minY);
	        var d = 1 / (this._pFar - this._pNear);
	        raw[0] = 2 * w;
	        raw[5] = 2 * h;
	        raw[10] = d;
	        raw[12] = -(this._maxX + this._minX) * w;
	        raw[13] = -(this._maxY + this._minY) * h;
	        raw[14] = -this._pNear * d;
	        raw[15] = 1;
	        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
	        this._pMatrix.copyRawDataFrom(raw);
	        this._pFrustumCorners[0] = this._pFrustumCorners[9] = this._pFrustumCorners[12] = this._pFrustumCorners[21] = this._minX;
	        this._pFrustumCorners[3] = this._pFrustumCorners[6] = this._pFrustumCorners[15] = this._pFrustumCorners[18] = this._maxX;
	        this._pFrustumCorners[1] = this._pFrustumCorners[4] = this._pFrustumCorners[13] = this._pFrustumCorners[16] = this._minY;
	        this._pFrustumCorners[7] = this._pFrustumCorners[10] = this._pFrustumCorners[19] = this._pFrustumCorners[22] = this._maxY;
	        this._pFrustumCorners[2] = this._pFrustumCorners[5] = this._pFrustumCorners[8] = this._pFrustumCorners[11] = this._pNear;
	        this._pFrustumCorners[14] = this._pFrustumCorners[17] = this._pFrustumCorners[20] = this._pFrustumCorners[23] = this._pFar;
	        this._pMatrixInvalid = false;
	    };
	    return OrthographicOffCenterProjection;
	}(ProjectionBase_1.ProjectionBase));
	exports.OrthographicOffCenterProjection = OrthographicOffCenterProjection;


/***/ },
/* 308 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var AbstractMethodError_1 = __webpack_require__(7);
	/**
	 * PrefabBase is an abstract base class for prefabs, which are prebuilt display objects that allow easy cloning and updating
	 */
	var PrefabBase = (function (_super) {
	    __extends(PrefabBase, _super);
	    //		public _pBatchObjects:Array<BatchObject> = new Array<BatchObject>();
	    /**
	     * Creates a new PrefabBase object.
	     */
	    function PrefabBase() {
	        _super.call(this);
	        this._pObjects = new Array();
	    }
	    /**
	     * Returns a display object generated from this prefab
	     */
	    PrefabBase.prototype.getNewObject = function () {
	        var object = this._pCreateObject();
	        this._pObjects.push(object);
	        return object;
	    };
	    //		public getNewBatchObject():BatchObject
	    //		{
	    //			var object:BatchObject = this._pCreateBatchObject();
	    //
	    //			this._pBatchObjects.push(object);
	    //
	    //			return object;
	    //		}
	    PrefabBase.prototype._pCreateObject = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    PrefabBase.prototype._iValidate = function () {
	        // To be overridden when necessary
	    };
	    return PrefabBase;
	}(AssetBase_1.AssetBase));
	exports.PrefabBase = PrefabBase;


/***/ },
/* 309 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(203);
	var PrimitivePrefabBase_1 = __webpack_require__(310);
	/**
	 * A Capsule primitive sprite.
	 */
	var PrimitiveCapsulePrefab = (function (_super) {
	    __extends(PrimitiveCapsulePrefab, _super);
	    /**
	     * Creates a new Capsule object.
	     * @param radius The radius of the capsule.
	     * @param height The height of the capsule.
	     * @param segmentsW Defines the number of horizontal segments that make up the capsule. Defaults to 16.
	     * @param segmentsH Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven value.
	     * @param yUp Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveCapsulePrefab(material, elementsType, radius, height, segmentsW, segmentsH, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 15; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._numVertices = 0;
	        this._radius = radius;
	        this._height = height;
	        this._segmentsW = segmentsW;
	        this._segmentsH = (segmentsH % 2 == 0) ? segmentsH + 1 : segmentsH;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "radius", {
	        /**
	         * The radius of the capsule.
	         */
	        get: function () {
	            return this._radius;
	        },
	        set: function (value) {
	            this._radius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "height", {
	        /**
	         * The height of the capsule.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "segmentsW", {
	        /**
	         * Defines the number of horizontal segments that make up the capsule. Defaults to 16.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "segmentsH", {
	        /**
	         * Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = (value % 2 == 0) ? value + 1 : value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "yUp", {
	        /**
	         * Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCapsulePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var stride;
	        var i;
	        var j;
	        var triIndex = 0;
	        var index = 0;
	        var startIndex;
	        var comp1, comp2, t1, t2;
	        var numIndices = 0;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            // evaluate target number of vertices, triangles and indices
	            this._numVertices = (this._segmentsH + 1) * (this._segmentsW + 1); // segmentsH + 1 because of closure, segmentsW + 1 because of closure
	            numIndices = (this._segmentsH - 1) * this._segmentsW * 6; // each level has segmentH quads, each of 2 triangles
	            // need to initialize raw arrays or can be reused?
	            if (this._numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateIndices();
	                triangleGraphics.invalidateVertices(triangleGraphics.positions);
	                triangleGraphics.invalidateVertices(triangleGraphics.normals);
	                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
	            }
	            else {
	                triangleGraphics.setIndices(new Uint16Array(numIndices));
	                triangleGraphics.setPositions(new Float32Array(this._numVertices * 3));
	                triangleGraphics.setNormals(new Float32Array(this._numVertices * 3));
	                triangleGraphics.setTangents(new Float32Array(this._numVertices * 3));
	                this._pInvalidateUVs();
	            }
	            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	            positions = triangleGraphics.positions.get(this._numVertices);
	            normals = triangleGraphics.normals.get(this._numVertices);
	            tangents = triangleGraphics.tangents.get(this._numVertices);
	            stride = triangleGraphics.concatenatedBuffer.stride / 4;
	            for (j = 0; j <= this._segmentsH; ++j) {
	                var horangle = Math.PI * j / this._segmentsH;
	                var z = -this._radius * Math.cos(horangle);
	                var ringradius = this._radius * Math.sin(horangle);
	                startIndex = index;
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    var verangle = 2 * Math.PI * i / this._segmentsW;
	                    var x = ringradius * Math.cos(verangle);
	                    var offset = j > this._segmentsH / 2 ? this._height / 2 : -this._height / 2;
	                    var y = ringradius * Math.sin(verangle);
	                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
	                    var tanLen = Math.sqrt(y * y + x * x);
	                    if (this._yUp) {
	                        t1 = 0;
	                        t2 = tanLen > .007 ? x / tanLen : 0;
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        t1 = tanLen > .007 ? x / tanLen : 0;
	                        t2 = 0;
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._segmentsW) {
	                        positions[index] = positions[startIndex];
	                        positions[index + 1] = positions[startIndex + 1];
	                        positions[index + 2] = positions[startIndex + 2];
	                        normals[index] = (normals[startIndex] + (x * normLen)) * .5;
	                        normals[index + 1] = (normals[startIndex + 1] + (comp1 * normLen)) * .5;
	                        normals[index + 2] = (normals[startIndex + 2] + (comp2 * normLen)) * .5;
	                        tangents[index] = (tangents[startIndex] + (tanLen > .007 ? -y / tanLen : 1)) * .5;
	                        tangents[index + 1] = (tangents[startIndex + 1] + t1) * .5;
	                        tangents[index + 2] = (tangents[startIndex + 2] + t2) * .5;
	                    }
	                    else {
	                        // vertex
	                        positions[index] = x;
	                        positions[index + 1] = (this._yUp) ? comp1 - offset : comp1;
	                        positions[index + 2] = (this._yUp) ? comp2 : comp2 + offset;
	                        // normal
	                        normals[index] = x * normLen;
	                        normals[index + 1] = comp1 * normLen;
	                        normals[index + 2] = comp2 * normLen;
	                        // tangent
	                        tangents[index] = tanLen > .007 ? -y / tanLen : 1;
	                        tangents[index + 1] = t1;
	                        tangents[index + 2] = t2;
	                    }
	                    if (i > 0 && j > 0) {
	                        var a = (this._segmentsW + 1) * j + i;
	                        var b = (this._segmentsW + 1) * j + i - 1;
	                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
	                        var d = (this._segmentsW + 1) * (j - 1) + i;
	                        if (j == this._segmentsH) {
	                            positions[index] = positions[startIndex];
	                            positions[index + 1] = positions[startIndex + 1];
	                            positions[index + 2] = positions[startIndex + 2];
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = c;
	                            indices[triIndex++] = d;
	                        }
	                        else if (j == 1) {
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = b;
	                            indices[triIndex++] = c;
	                        }
	                        else {
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = b;
	                            indices[triIndex++] = c;
	                            indices[triIndex++] = a;
	                            indices[triIndex++] = c;
	                            indices[triIndex++] = d;
	                        }
	                    }
	                    index += stride;
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCapsulePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j;
	        var uvs;
	        var stride;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            // need to initialize raw array or can be reused?
	            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
	            }
	            else {
	                triangleGraphics.setUVs(new Float32Array(this._numVertices * 2));
	            }
	            uvs = triangleGraphics.uvs.get(this._numVertices);
	            stride = triangleGraphics.uvs.stride;
	            // current uv component index
	            var index = 0;
	            // surface
	            for (j = 0; j <= this._segmentsH; ++j) {
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    // revolution vertex
	                    uvs[index] = (i / this._segmentsW) * this._scaleU;
	                    uvs[index + 1] = (j / this._segmentsH) * this._scaleV;
	                    index += stride;
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    return PrimitiveCapsulePrefab;
	}(PrimitivePrefabBase_1.PrimitivePrefabBase));
	exports.PrimitiveCapsulePrefab = PrimitiveCapsulePrefab;


/***/ },
/* 310 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var AbstractMethodError_1 = __webpack_require__(7);
	var ElementsType_1 = __webpack_require__(203);
	var TriangleElements_1 = __webpack_require__(179);
	var LineElements_1 = __webpack_require__(125);
	var Sprite_1 = __webpack_require__(177);
	var PrefabBase_1 = __webpack_require__(308);
	/**
	 * PrimitivePrefabBase is an abstract base class for polytope prefabs, which are simple pre-built geometric shapes
	 */
	var PrimitivePrefabBase = (function (_super) {
	    __extends(PrimitivePrefabBase, _super);
	    /**
	     * Creates a new PrimitivePrefabBase object.
	     *
	     * @param material The material with which to render the object
	     */
	    function PrimitivePrefabBase(material, elementsType) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        _super.call(this);
	        this._primitiveDirty = true;
	        this._uvDirty = true;
	        this._scaleU = 1;
	        this._scaleV = 1;
	        this._material = material;
	        this._elementsType = elementsType;
	        if (this._elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleElements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	            triangleElements.autoDeriveNormals = false;
	            triangleElements.autoDeriveTangents = false;
	            this._elements = triangleElements;
	        }
	        else if (this._elementsType == ElementsType_1.ElementsType.LINE) {
	            this._elements = new LineElements_1.LineElements(new AttributesBuffer_1.AttributesBuffer());
	        }
	    }
	    Object.defineProperty(PrimitivePrefabBase.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return PrimitivePrefabBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "elementsType", {
	        /**
	         *
	         */
	        get: function () {
	            return this._elementsType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "material", {
	        /**
	         * The material with which to render the primitive.
	         */
	        get: function () {
	            return this._material;
	        },
	        set: function (value) {
	            if (value == this._material)
	                return;
	            this._material = value;
	            var len = this._pObjects.length;
	            for (var i = 0; i < len; i++)
	                this._pObjects[i].material = this._material;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "scaleU", {
	        get: function () {
	            return this._scaleU;
	        },
	        set: function (value) {
	            if (this._scaleU = value)
	                return;
	            this._scaleU = value;
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePrefabBase.prototype, "scaleV", {
	        get: function () {
	            return this._scaleV;
	        },
	        set: function (value) {
	            if (this._scaleV = value)
	                return;
	            this._scaleV = value;
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Builds the primitive's geometry when invalid. This method should not be called directly. The calling should
	     * be triggered by the invalidateGraphics method (and in turn by updateGraphics).
	     */
	    PrimitivePrefabBase.prototype._pBuildGraphics = function (target, elementsType) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Builds the primitive's uv coordinates when invalid. This method should not be called directly. The calling
	     * should be triggered by the invalidateUVs method (and in turn by updateUVs).
	     */
	    PrimitivePrefabBase.prototype._pBuildUVs = function (target, elementsType) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Invalidates the primitive, causing it to be updated when requested.
	     */
	    PrimitivePrefabBase.prototype._pInvalidatePrimitive = function () {
	        this._primitiveDirty = true;
	    };
	    /**
	     * Invalidates the primitive's uv coordinates, causing them to be updated when requested.
	     */
	    PrimitivePrefabBase.prototype._pInvalidateUVs = function () {
	        this._uvDirty = true;
	    };
	    /**
	     * Updates the geometry when invalid.
	     */
	    PrimitivePrefabBase.prototype.updateGraphics = function () {
	        this._pBuildGraphics(this._elements, this._elementsType);
	        this._primitiveDirty = false;
	    };
	    /**
	     * Updates the uv coordinates when invalid.
	     */
	    PrimitivePrefabBase.prototype.updateUVs = function () {
	        this._pBuildUVs(this._elements, this._elementsType);
	        this._uvDirty = false;
	    };
	    PrimitivePrefabBase.prototype._iValidate = function () {
	        if (this._primitiveDirty)
	            this.updateGraphics();
	        if (this._uvDirty)
	            this.updateUVs();
	    };
	    PrimitivePrefabBase.prototype._pCreateObject = function () {
	        var sprite = new Sprite_1.Sprite(this._material);
	        sprite.graphics.addGraphic(this._elements);
	        sprite._iSourcePrefab = this;
	        return sprite;
	    };
	    PrimitivePrefabBase.assetType = "[asset PrimitivePrefab]";
	    return PrimitivePrefabBase;
	}(PrefabBase_1.PrefabBase));
	exports.PrimitivePrefabBase = PrimitivePrefabBase;


/***/ },
/* 311 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PrimitiveCylinderPrefab_1 = __webpack_require__(312);
	/**
	 * A UV Cone primitive sprite.
	 */
	var PrimitiveConePrefab = (function (_super) {
	    __extends(PrimitiveConePrefab, _super);
	    /**
	     * Creates a new Cone object.
	     * @param radius The radius of the bottom end of the cone
	     * @param height The height of the cone
	     * @param segmentsW Defines the number of horizontal segments that make up the cone. Defaults to 16.
	     * @param segmentsH Defines the number of vertical segments that make up the cone. Defaults to 1.
	     * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveConePrefab(material, elementsType, radius, height, segmentsW, segmentsH, closed, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (closed === void 0) { closed = true; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType, 0, radius, height, segmentsW, segmentsH, false, closed, true, yUp);
	    }
	    Object.defineProperty(PrimitiveConePrefab.prototype, "radius", {
	        /**
	         * The radius of the bottom end of the cone.
	         */
	        get: function () {
	            return this._pBottomRadius;
	        },
	        set: function (value) {
	            this._pBottomRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PrimitiveConePrefab;
	}(PrimitiveCylinderPrefab_1.PrimitiveCylinderPrefab));
	exports.PrimitiveConePrefab = PrimitiveConePrefab;


/***/ },
/* 312 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(203);
	var PrimitivePrefabBase_1 = __webpack_require__(310);
	/**
	 * A Cylinder primitive sprite.
	 */
	var PrimitiveCylinderPrefab = (function (_super) {
	    __extends(PrimitiveCylinderPrefab, _super);
	    /**
	     * Creates a new Cylinder object.
	     * @param topRadius The radius of the top end of the cylinder.
	     * @param bottomRadius The radius of the bottom end of the cylinder
	     * @param height The radius of the bottom end of the cylinder
	     * @param segmentsW Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
	     * @param segmentsH Defines the number of vertical segments that make up the cylinder. Defaults to 1.
	     * @param topClosed Defines whether the top end of the cylinder is closed (true) or open.
	     * @param bottomClosed Defines whether the bottom end of the cylinder is closed (true) or open.
	     * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveCylinderPrefab(material, elementsType, topRadius, bottomRadius, height, segmentsW, segmentsH, topClosed, bottomClosed, surfaceClosed, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (topRadius === void 0) { topRadius = 50; }
	        if (bottomRadius === void 0) { bottomRadius = 50; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (topClosed === void 0) { topClosed = true; }
	        if (bottomClosed === void 0) { bottomClosed = true; }
	        if (surfaceClosed === void 0) { surfaceClosed = true; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._numVertices = 0;
	        this._topRadius = topRadius;
	        this._pBottomRadius = bottomRadius;
	        this._height = height;
	        this._pSegmentsW = segmentsW;
	        this._pSegmentsH = segmentsH;
	        this._topClosed = topClosed;
	        this._bottomClosed = bottomClosed;
	        this._surfaceClosed = surfaceClosed;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "topRadius", {
	        /**
	         * The radius of the top end of the cylinder.
	         */
	        get: function () {
	            return this._topRadius;
	        },
	        set: function (value) {
	            this._topRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "bottomRadius", {
	        /**
	         * The radius of the bottom end of the cylinder.
	         */
	        get: function () {
	            return this._pBottomRadius;
	        },
	        set: function (value) {
	            this._pBottomRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "height", {
	        /**
	         * The radius of the top end of the cylinder.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "segmentsW", {
	        /**
	         * Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
	         */
	        get: function () {
	            return this._pSegmentsW;
	        },
	        set: function (value) {
	            this.setSegmentsW(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PrimitiveCylinderPrefab.prototype.setSegmentsW = function (value) {
	        this._pSegmentsW = value;
	        this._pInvalidatePrimitive();
	        this._pInvalidateUVs();
	    };
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "segmentsH", {
	        /**
	         * Defines the number of vertical segments that make up the cylinder. Defaults to 1.
	         */
	        get: function () {
	            return this._pSegmentsH;
	        },
	        set: function (value) {
	            this.setSegmentsH(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PrimitiveCylinderPrefab.prototype.setSegmentsH = function (value) {
	        this._pSegmentsH = value;
	        this._pInvalidatePrimitive();
	        this._pInvalidateUVs();
	    };
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "topClosed", {
	        /**
	         * Defines whether the top end of the cylinder is closed (true) or open.
	         */
	        get: function () {
	            return this._topClosed;
	        },
	        set: function (value) {
	            this._topClosed = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "bottomClosed", {
	        /**
	         * Defines whether the bottom end of the cylinder is closed (true) or open.
	         */
	        get: function () {
	            return this._bottomClosed;
	        },
	        set: function (value) {
	            this._bottomClosed = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "yUp", {
	        /**
	         * Defines whether the cylinder poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCylinderPrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var stride;
	        var i;
	        var j;
	        var x;
	        var y;
	        var z;
	        var vidx;
	        var fidx;
	        var radius;
	        var revolutionAngle;
	        var dr;
	        var latNormElev;
	        var latNormBase;
	        var numIndices = 0;
	        var comp1;
	        var comp2;
	        var startIndex = 0;
	        var nextVertexIndex = 0;
	        var centerVertexIndex = 0;
	        var t1;
	        var t2;
	        // reset utility variables
	        this._numVertices = 0;
	        // evaluate revolution steps
	        var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            // evaluate target number of vertices, triangles and indices
	            if (this._surfaceClosed) {
	                this._numVertices += (this._pSegmentsH + 1) * (this._pSegmentsW + 1); // segmentsH + 1 because of closure, segmentsW + 1 because of UV unwrapping
	                numIndices += this._pSegmentsH * this._pSegmentsW * 6; // each level has segmentW quads, each of 2 triangles
	            }
	            if (this._topClosed) {
	                this._numVertices += 2 * (this._pSegmentsW + 1); // segmentsW + 1 because of unwrapping
	                numIndices += this._pSegmentsW * 3; // one triangle for each segment
	            }
	            if (this._bottomClosed) {
	                this._numVertices += 2 * (this._pSegmentsW + 1);
	                numIndices += this._pSegmentsW * 3;
	            }
	            // need to initialize raw arrays or can be reused?
	            if (this._numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateIndices();
	                triangleGraphics.invalidateVertices(triangleGraphics.positions);
	                triangleGraphics.invalidateVertices(triangleGraphics.normals);
	                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
	            }
	            else {
	                triangleGraphics.setIndices(new Uint16Array(numIndices));
	                triangleGraphics.setPositions(new Float32Array(this._numVertices * 3));
	                triangleGraphics.setNormals(new Float32Array(this._numVertices * 3));
	                triangleGraphics.setTangents(new Float32Array(this._numVertices * 3));
	                this._pInvalidateUVs();
	            }
	            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	            positions = triangleGraphics.positions.get(this._numVertices);
	            normals = triangleGraphics.normals.get(this._numVertices);
	            tangents = triangleGraphics.tangents.get(this._numVertices);
	            stride = triangleGraphics.concatenatedBuffer.stride / 4;
	            vidx = 0;
	            fidx = 0;
	            // top
	            if (this._topClosed && this._topRadius > 0) {
	                z = -0.5 * this._height;
	                // central vertex
	                if (this._yUp) {
	                    t1 = 1;
	                    t2 = 0;
	                    comp1 = -z;
	                    comp2 = 0;
	                }
	                else {
	                    t1 = 0;
	                    t2 = -1;
	                    comp1 = 0;
	                    comp2 = z;
	                }
	                positions[vidx] = 0;
	                positions[vidx + 1] = comp1;
	                positions[vidx + 2] = comp2;
	                normals[vidx] = 0;
	                normals[vidx + 1] = t1;
	                normals[vidx + 2] = t2;
	                tangents[vidx] = 1;
	                tangents[vidx + 1] = 0;
	                tangents[vidx + 2] = 0;
	                vidx += stride;
	                nextVertexIndex++;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    // revolution vertex
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = this._topRadius * Math.cos(revolutionAngle);
	                    y = this._topRadius * Math.sin(revolutionAngle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._pSegmentsW) {
	                        positions[vidx] = positions[startIndex + stride];
	                        positions[vidx + 1] = positions[startIndex + stride + 1];
	                        positions[vidx + 2] = positions[startIndex + stride + 2];
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                    }
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = t1;
	                    normals[vidx + 2] = t2;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                    if (i > 0) {
	                        // add triangle
	                        indices[fidx++] = nextVertexIndex - 1;
	                        indices[fidx++] = centerVertexIndex;
	                        indices[fidx++] = nextVertexIndex;
	                    }
	                    nextVertexIndex++;
	                }
	            }
	            // bottom
	            if (this._bottomClosed && this._pBottomRadius > 0) {
	                z = 0.5 * this._height;
	                startIndex = nextVertexIndex * stride;
	                centerVertexIndex = nextVertexIndex;
	                // central vertex
	                if (this._yUp) {
	                    t1 = -1;
	                    t2 = 0;
	                    comp1 = -z;
	                    comp2 = 0;
	                }
	                else {
	                    t1 = 0;
	                    t2 = 1;
	                    comp1 = 0;
	                    comp2 = z;
	                }
	                if (i > 0) {
	                    positions[vidx] = 0;
	                    positions[vidx + 1] = comp1;
	                    positions[vidx + 2] = comp2;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = t1;
	                    normals[vidx + 2] = t2;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                }
	                nextVertexIndex++;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    // revolution vertex
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = this._pBottomRadius * Math.cos(revolutionAngle);
	                    y = this._pBottomRadius * Math.sin(revolutionAngle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._pSegmentsW) {
	                        positions[vidx] = positions[startIndex + stride];
	                        positions[vidx + 1] = positions[startIndex + stride + 1];
	                        positions[vidx + 2] = positions[startIndex + stride + 2];
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                    }
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = t1;
	                    normals[vidx + 2] = t2;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                    if (i > 0) {
	                        // add triangle
	                        indices[fidx++] = nextVertexIndex - 1;
	                        indices[fidx++] = nextVertexIndex;
	                        indices[fidx++] = centerVertexIndex;
	                    }
	                    nextVertexIndex++;
	                }
	            }
	            // The normals on the lateral surface all have the same incline, i.e.
	            // the "elevation" component (Y or Z depending on yUp) is constant.
	            // Same principle goes for the "base" of these vectors, which will be
	            // calculated such that a vector [base,elev] will be a unit vector.
	            dr = (this._pBottomRadius - this._topRadius);
	            latNormElev = dr / this._height;
	            latNormBase = (latNormElev == 0) ? 1 : this._height / dr;
	            // lateral surface
	            if (this._surfaceClosed) {
	                var a;
	                var b;
	                var c;
	                var d;
	                var na0, na1, naComp1, naComp2;
	                for (j = 0; j <= this._pSegmentsH; ++j) {
	                    radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
	                    z = -(this._height / 2) + (j / this._pSegmentsH * this._height);
	                    startIndex = nextVertexIndex * stride;
	                    for (i = 0; i <= this._pSegmentsW; ++i) {
	                        // revolution vertex
	                        revolutionAngle = i * revolutionAngleDelta;
	                        x = radius * Math.cos(revolutionAngle);
	                        y = radius * Math.sin(revolutionAngle);
	                        na0 = latNormBase * Math.cos(revolutionAngle);
	                        na1 = latNormBase * Math.sin(revolutionAngle);
	                        if (this._yUp) {
	                            t1 = 0;
	                            t2 = -na0;
	                            comp1 = -z;
	                            comp2 = y;
	                            naComp1 = latNormElev;
	                            naComp2 = na1;
	                        }
	                        else {
	                            t1 = -na0;
	                            t2 = 0;
	                            comp1 = y;
	                            comp2 = z;
	                            naComp1 = na1;
	                            naComp2 = latNormElev;
	                        }
	                        if (i == this._pSegmentsW) {
	                            positions[vidx] = positions[startIndex];
	                            positions[vidx + 1] = positions[startIndex + 1];
	                            positions[vidx + 2] = positions[startIndex + 2];
	                            normals[vidx] = na0;
	                            normals[vidx + 1] = latNormElev;
	                            normals[vidx + 2] = na1;
	                            tangents[vidx] = na1;
	                            tangents[vidx + 1] = t1;
	                            tangents[vidx + 2] = t2;
	                        }
	                        else {
	                            positions[vidx] = x;
	                            positions[vidx + 1] = comp1;
	                            positions[vidx + 2] = comp2;
	                            normals[vidx] = na0;
	                            normals[vidx + 1] = naComp1;
	                            normals[vidx + 2] = naComp2;
	                            tangents[vidx] = -na1;
	                            tangents[vidx + 1] = t1;
	                            tangents[vidx + 2] = t2;
	                        }
	                        vidx += stride;
	                        // close triangle
	                        if (i > 0 && j > 0) {
	                            a = nextVertexIndex; // current
	                            b = nextVertexIndex - 1; // previous
	                            c = b - this._pSegmentsW - 1; // previous of last level
	                            d = a - this._pSegmentsW - 1; // current of last level
	                            indices[fidx++] = a;
	                            indices[fidx++] = b;
	                            indices[fidx++] = c;
	                            indices[fidx++] = a;
	                            indices[fidx++] = c;
	                            indices[fidx++] = d;
	                        }
	                        nextVertexIndex++;
	                    }
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	            var lineGraphics = target;
	            var numSegments = this._pSegmentsH * this._pSegmentsW * 2 + this._pSegmentsW;
	            positions = new Float32Array(numSegments * 6);
	            var thickness = new Float32Array(numSegments);
	            vidx = 0;
	            fidx = 0;
	            var _radius = 50;
	            for (j = 0; j <= this._pSegmentsH; ++j) {
	                radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
	                z = -(this._height / 2) + (j / this._pSegmentsH * this._height);
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    // revolution vertex
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = radius * Math.cos(revolutionAngle);
	                    y = radius * Math.sin(revolutionAngle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i > 0) {
	                        //horizonal lines
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                        thickness[fidx++] = 1;
	                        //vertical lines
	                        if (j > 0) {
	                            var addx = (j == 1) ? 3 - (6 * (this._pSegmentsW - i) + 12 * i) : 3 - this._pSegmentsW * 12;
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx++] = x;
	                            positions[vidx++] = comp1;
	                            positions[vidx++] = comp2;
	                            thickness[fidx++] = 1;
	                        }
	                    }
	                    //horizonal lines
	                    if (i < this._pSegmentsW) {
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                    }
	                }
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCylinderPrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i;
	        var j;
	        var x;
	        var y;
	        var revolutionAngle;
	        var uvs;
	        var stride;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            // need to initialize raw array or can be reused?
	            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
	            }
	            else {
	                triangleGraphics.setUVs(new Float32Array(this._numVertices * 2));
	            }
	            uvs = triangleGraphics.uvs.get(this._numVertices);
	            stride = triangleGraphics.uvs.stride;
	            // evaluate revolution steps
	            var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;
	            // current uv component index
	            var index = 0;
	            // top
	            if (this._topClosed) {
	                uvs[index] = 0.5 * this._scaleU; // central vertex
	                uvs[index + 1] = 0.5 * this._scaleV;
	                index += stride;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = 0.5 + 0.5 * -Math.cos(revolutionAngle);
	                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
	                    uvs[index] = x * this._scaleU; // revolution vertex
	                    uvs[index + 1] = y * this._scaleV;
	                    index += stride;
	                }
	            }
	            // bottom
	            if (this._bottomClosed) {
	                uvs[index] = 0.5 * this._scaleU; // central vertex
	                uvs[index + 1] = 0.5 * this._scaleV;
	                index += stride;
	                for (i = 0; i <= this._pSegmentsW; ++i) {
	                    revolutionAngle = i * revolutionAngleDelta;
	                    x = 0.5 + 0.5 * Math.cos(revolutionAngle);
	                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
	                    uvs[index] = x * this._scaleU; // revolution vertex
	                    uvs[index + 1] = y * this._scaleV;
	                    index += stride;
	                }
	            }
	            // lateral surface
	            if (this._surfaceClosed) {
	                for (j = 0; j <= this._pSegmentsH; ++j) {
	                    for (i = 0; i <= this._pSegmentsW; ++i) {
	                        // revolution vertex
	                        uvs[index] = (i / this._pSegmentsW) * this._scaleU;
	                        uvs[index + 1] = (j / this._pSegmentsH) * this._scaleV;
	                        index += stride;
	                    }
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    return PrimitiveCylinderPrefab;
	}(PrimitivePrefabBase_1.PrimitivePrefabBase));
	exports.PrimitiveCylinderPrefab = PrimitiveCylinderPrefab;


/***/ },
/* 313 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(203);
	var PrimitivePrefabBase_1 = __webpack_require__(310);
	/**
	 * A Cube primitive prefab.
	 */
	var PrimitiveCubePrefab = (function (_super) {
	    __extends(PrimitiveCubePrefab, _super);
	    /**
	     * Creates a new Cube object.
	     * @param width The size of the cube along its X-axis.
	     * @param height The size of the cube along its Y-axis.
	     * @param depth The size of the cube along its Z-axis.
	     * @param segmentsW The number of segments that make up the cube along the X-axis.
	     * @param segmentsH The number of segments that make up the cube along the Y-axis.
	     * @param segmentsD The number of segments that make up the cube along the Z-axis.
	     * @param tile6 The type of uv mapping to use. When true, a texture will be subdivided in a 2x3 grid, each used for a single face. When false, the entire image is mapped on each face.
	     */
	    function PrimitiveCubePrefab(material, elementsType, width, height, depth, segmentsW, segmentsH, segmentsD, tile6) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (width === void 0) { width = 100; }
	        if (height === void 0) { height = 100; }
	        if (depth === void 0) { depth = 100; }
	        if (segmentsW === void 0) { segmentsW = 1; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (segmentsD === void 0) { segmentsD = 1; }
	        if (tile6 === void 0) { tile6 = true; }
	        _super.call(this, material, elementsType);
	        this._width = width;
	        this._height = height;
	        this._depth = depth;
	        this._segmentsW = segmentsW;
	        this._segmentsH = segmentsH;
	        this._segmentsD = segmentsD;
	        this._tile6 = tile6;
	    }
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "width", {
	        /**
	         * The size of the cube along its X-axis.
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            this._width = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "height", {
	        /**
	         * The size of the cube along its Y-axis.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "depth", {
	        /**
	         * The size of the cube along its Z-axis.
	         */
	        get: function () {
	            return this._depth;
	        },
	        set: function (value) {
	            this._depth = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "tile6", {
	        /**
	         * The type of uv mapping to use. When false, the entire image is mapped on each face.
	         * When true, a texture will be subdivided in a 3x2 grid, each used for a single face.
	         * Reading the tiles from left to right, top to bottom they represent the faces of the
	         * cube in the following order: bottom, top, back, left, front, right. This creates
	         * several shared edges (between the top, front, left and right faces) which simplifies
	         * texture painting.
	         */
	        get: function () {
	            return this._tile6;
	        },
	        set: function (value) {
	            this._tile6 = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsW", {
	        /**
	         * The number of segments that make up the cube along the X-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsH", {
	        /**
	         * The number of segments that make up the cube along the Y-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsD", {
	        /**
	         * The number of segments that make up the cube along the Z-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsD;
	        },
	        set: function (value) {
	            this._segmentsD = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCubePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var stride;
	        var tl, tr, bl, br;
	        var i, j, inc = 0;
	        var vidx, fidx; // indices
	        var hw, hh, hd; // halves
	        var dw, dh, dd; // deltas
	        var outer_pos;
	        // half cube dimensions
	        hw = this._width / 2;
	        hh = this._height / 2;
	        hd = this._depth / 2;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            var numVertices = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
	            var numIndices = ((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12);
	            if (numVertices == triangleGraphics.numVertices && triangleGraphics.indices != null) {
	                triangleGraphics.invalidateIndices();
	                triangleGraphics.invalidateVertices(triangleGraphics.positions);
	                triangleGraphics.invalidateVertices(triangleGraphics.normals);
	                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
	            }
	            else {
	                triangleGraphics.setIndices(new Uint16Array(numIndices));
	                triangleGraphics.setPositions(new Float32Array(numVertices * 3));
	                triangleGraphics.setNormals(new Float32Array(numVertices * 3));
	                triangleGraphics.setTangents(new Float32Array(numVertices * 3));
	                this._pInvalidateUVs();
	            }
	            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	            positions = triangleGraphics.positions.get(numVertices);
	            normals = triangleGraphics.normals.get(numVertices);
	            tangents = triangleGraphics.tangents.get(numVertices);
	            stride = triangleGraphics.concatenatedBuffer.stride / 4;
	            vidx = 0;
	            fidx = 0;
	            // Segment dimensions
	            dw = this._width / this._segmentsW;
	            dh = this._height / this._segmentsH;
	            dd = this._depth / this._segmentsD;
	            for (i = 0; i <= this._segmentsW; i++) {
	                outer_pos = -hw + i * dw;
	                for (j = 0; j <= this._segmentsH; j++) {
	                    // front
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = -hd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = -1;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                    // back
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = hd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = 1;
	                    tangents[vidx] = -1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                    if (i && j) {
	                        tl = 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
	                        tr = 2 * (i * (this._segmentsH + 1) + (j - 1));
	                        bl = tl + 2;
	                        br = tr + 2;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = bl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tr;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = br + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tl + 1;
	                    }
	                }
	            }
	            inc += 2 * (this._segmentsW + 1) * (this._segmentsH + 1);
	            for (i = 0; i <= this._segmentsW; i++) {
	                outer_pos = -hw + i * dw;
	                for (j = 0; j <= this._segmentsD; j++) {
	                    // top
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = hh;
	                    positions[vidx + 2] = -hd + j * dd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = 1;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                    // bottom
	                    positions[vidx] = outer_pos;
	                    positions[vidx + 1] = -hh;
	                    positions[vidx + 2] = -hd + j * dd;
	                    normals[vidx] = 0;
	                    normals[vidx + 1] = -1;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                    if (i && j) {
	                        tl = inc + 2 * ((i - 1) * (this._segmentsD + 1) + (j - 1));
	                        tr = inc + 2 * (i * (this._segmentsD + 1) + (j - 1));
	                        bl = tl + 2;
	                        br = tr + 2;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = bl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tr;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = br + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tl + 1;
	                    }
	                }
	            }
	            inc += 2 * (this._segmentsW + 1) * (this._segmentsD + 1);
	            for (i = 0; i <= this._segmentsD; i++) {
	                outer_pos = hd - i * dd;
	                for (j = 0; j <= this._segmentsH; j++) {
	                    // left
	                    positions[vidx] = -hw;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = outer_pos;
	                    normals[vidx] = -1;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 0;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = -1;
	                    vidx += stride;
	                    // right
	                    positions[vidx] = hw;
	                    positions[vidx + 1] = -hh + j * dh;
	                    positions[vidx + 2] = outer_pos;
	                    normals[vidx] = 1;
	                    normals[vidx + 1] = 0;
	                    normals[vidx + 2] = 0;
	                    tangents[vidx] = 0;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 1;
	                    vidx += stride;
	                    if (i && j) {
	                        tl = inc + 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
	                        tr = inc + 2 * (i * (this._segmentsH + 1) + (j - 1));
	                        bl = tl + 2;
	                        br = tr + 2;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = bl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tl;
	                        indices[fidx++] = br;
	                        indices[fidx++] = tr;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = br + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tr + 1;
	                        indices[fidx++] = bl + 1;
	                        indices[fidx++] = tl + 1;
	                    }
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	            var lineGraphics = target;
	            var numSegments = this._segmentsH * 4 + this._segmentsW * 4 + this._segmentsD * 4;
	            var thickness;
	            positions = new Float32Array(numSegments * 6);
	            thickness = new Float32Array(numSegments);
	            vidx = 0;
	            fidx = 0;
	            //front/back face
	            for (i = 0; i < this._segmentsH; ++i) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = -hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = -hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            for (i = 0; i < this._segmentsW; ++i) {
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = -hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd;
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            //left/right face
	            for (i = 0; i < this._segmentsH; ++i) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = -hw;
	                positions[vidx++] = i * this._height / this._segmentsH - hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = -hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh - i * this._height / this._segmentsH;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            for (i = 0; i < this._segmentsD; ++i) {
	                positions[vidx++] = hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = -hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                positions[vidx++] = -hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                thickness[fidx++] = 1;
	            }
	            //top/bottom face
	            for (i = 0; i < this._segmentsD; ++i) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                positions[vidx++] = hw;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd - i * this._depth / this._segmentsD;
	                thickness[fidx++] = 1;
	                positions[vidx++] = -hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                positions[vidx++] = hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = i * this._depth / this._segmentsD - hd;
	                thickness[fidx++] = 1;
	            }
	            for (i = 0; i < this._segmentsW; ++i) {
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = -hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = hw - i * this._width / this._segmentsW;
	                positions[vidx++] = -hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = -hd;
	                positions[vidx++] = i * this._width / this._segmentsW - hw;
	                positions[vidx++] = hh;
	                positions[vidx++] = hd;
	                thickness[fidx++] = 1;
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveCubePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j, index;
	        var uvs;
	        var stride;
	        var u_tile_dim, v_tile_dim;
	        var u_tile_step, v_tile_step;
	        var tl0u, tl0v;
	        var tl1u, tl1v;
	        var du, dv;
	        var numVertices;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            numVertices = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
	            var triangleGraphics = target;
	            if (triangleGraphics.uvs && numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
	            }
	            else {
	                triangleGraphics.setUVs(new Float32Array(numVertices * 2));
	            }
	            uvs = triangleGraphics.uvs.get(numVertices);
	            stride = triangleGraphics.uvs.stride;
	            if (this._tile6) {
	                u_tile_dim = u_tile_step = 1 / 3;
	                v_tile_dim = v_tile_step = 1 / 2;
	            }
	            else {
	                u_tile_dim = v_tile_dim = 1;
	                u_tile_step = v_tile_step = 0;
	            }
	            // Create planes two and two, the same way that they were
	            // constructed in the buildGraphics() function. First calculate
	            // the top-left UV coordinate for both planes, and then loop
	            // over the points, calculating the UVs from these numbers.
	            // When tile6 is true, the layout is as follows:
	            //       .-----.-----.-----. (1,1)
	            //       | Bot |  T  | Bak |
	            //       |-----+-----+-----|
	            //       |  L  |  F  |  R  |
	            // (0,0)'-----'-----'-----'
	            index = 0;
	            // FRONT / BACK
	            tl0u = 1 * u_tile_step;
	            tl0v = 1 * v_tile_step;
	            tl1u = 2 * u_tile_step;
	            tl1v = 0 * v_tile_step;
	            du = u_tile_dim / this._segmentsW;
	            dv = v_tile_dim / this._segmentsH;
	            for (i = 0; i <= this._segmentsW; i++) {
	                for (j = 0; j <= this._segmentsH; j++) {
	                    uvs[index] = (tl0u + i * du) * this._scaleU;
	                    uvs[index + 1] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
	                    index += stride;
	                    uvs[index] = (tl1u + (u_tile_dim - i * du)) * this._scaleU;
	                    uvs[index + 1] = (tl1v + (v_tile_dim - j * dv)) * this._scaleV;
	                    index += stride;
	                }
	            }
	            // TOP / BOTTOM
	            tl0u = 1 * u_tile_step;
	            tl0v = 0 * v_tile_step;
	            tl1u = 0 * u_tile_step;
	            tl1v = 0 * v_tile_step;
	            du = u_tile_dim / this._segmentsW;
	            dv = v_tile_dim / this._segmentsD;
	            for (i = 0; i <= this._segmentsW; i++) {
	                for (j = 0; j <= this._segmentsD; j++) {
	                    uvs[index] = (tl0u + i * du) * this._scaleU;
	                    uvs[index + 1] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
	                    index += stride;
	                    uvs[index] = (tl1u + i * du) * this._scaleU;
	                    uvs[index + 1] = (tl1v + j * dv) * this._scaleV;
	                    index += stride;
	                }
	            }
	            // LEFT / RIGHT
	            tl0u = 0 * u_tile_step;
	            tl0v = 1 * v_tile_step;
	            tl1u = 2 * u_tile_step;
	            tl1v = 1 * v_tile_step;
	            du = u_tile_dim / this._segmentsD;
	            dv = v_tile_dim / this._segmentsH;
	            for (i = 0; i <= this._segmentsD; i++) {
	                for (j = 0; j <= this._segmentsH; j++) {
	                    uvs[index] = (tl0u + i * du) * this._scaleU;
	                    uvs[index + 1] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
	                    index += stride;
	                    uvs[index] = (tl1u + (u_tile_dim - i * du)) * this._scaleU;
	                    uvs[index + 1] = (tl1v + (v_tile_dim - j * dv)) * this._scaleV;
	                    index += stride;
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    return PrimitiveCubePrefab;
	}(PrimitivePrefabBase_1.PrimitivePrefabBase));
	exports.PrimitiveCubePrefab = PrimitiveCubePrefab;


/***/ },
/* 314 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(203);
	var PrimitivePrefabBase_1 = __webpack_require__(310);
	/**
	 * A Plane primitive sprite.
	 */
	var PrimitivePlanePrefab = (function (_super) {
	    __extends(PrimitivePlanePrefab, _super);
	    /**
	     * Creates a new Plane object.
	     * @param width The width of the plane.
	     * @param height The height of the plane.
	     * @param segmentsW The number of segments that make up the plane along the X-axis.
	     * @param segmentsH The number of segments that make up the plane along the Y or Z-axis.
	     * @param yUp Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false).
	     * @param doubleSided Defines whether the plane will be visible from both sides, with correct vertex normals.
	     */
	    function PrimitivePlanePrefab(material, elementsType, width, height, segmentsW, segmentsH, yUp, doubleSided) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (width === void 0) { width = 100; }
	        if (height === void 0) { height = 100; }
	        if (segmentsW === void 0) { segmentsW = 1; }
	        if (segmentsH === void 0) { segmentsH = 1; }
	        if (yUp === void 0) { yUp = true; }
	        if (doubleSided === void 0) { doubleSided = false; }
	        _super.call(this, material, elementsType);
	        this._segmentsW = segmentsW;
	        this._segmentsH = segmentsH;
	        this._yUp = yUp;
	        this._width = width;
	        this._height = height;
	        this._doubleSided = doubleSided;
	    }
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "segmentsW", {
	        /**
	         * The number of segments that make up the plane along the X-axis. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "segmentsH", {
	        /**
	         * The number of segments that make up the plane along the Y or Z-axis, depending on whether yUp is true or
	         * false, respectively. Defaults to 1.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "yUp", {
	        /**
	         *  Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false). Defaults to true.
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "doubleSided", {
	        /**
	         * Defines whether the plane will be visible from both sides, with correct vertex normals (as opposed to bothSides on Material). Defaults to false.
	         */
	        get: function () {
	            return this._doubleSided;
	        },
	        set: function (value) {
	            this._doubleSided = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "width", {
	        /**
	         * The width of the plane.
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            this._width = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePlanePrefab.prototype, "height", {
	        /**
	         * The height of the plane.
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            this._height = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitivePlanePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var x, y;
	        var numIndices;
	        var stride;
	        var base;
	        var tw = this._segmentsW + 1;
	        var vidx, fidx; // indices
	        var xi;
	        var yi;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            var numVertices = (this._segmentsH + 1) * tw;
	            var positions;
	            var normals;
	            var tangents;
	            if (this._doubleSided)
	                numVertices *= 2;
	            numIndices = this._segmentsH * this._segmentsW * 6;
	            if (this._doubleSided)
	                numIndices *= 2;
	            if (triangleGraphics.indices != null && numIndices == triangleGraphics.indices.length) {
	                triangleGraphics.invalidateIndices();
	            }
	            else {
	                triangleGraphics.setIndices(new Uint16Array(numIndices));
	                this._pInvalidateUVs();
	            }
	            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	            if (numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateVertices(triangleGraphics.positions);
	                triangleGraphics.invalidateVertices(triangleGraphics.normals);
	                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
	            }
	            else {
	                triangleGraphics.setPositions(new Float32Array(numVertices * 3));
	                triangleGraphics.setNormals(new Float32Array(numVertices * 3));
	                triangleGraphics.setTangents(new Float32Array(numVertices * 3));
	                this._pInvalidateUVs();
	            }
	            positions = triangleGraphics.positions.get(numVertices);
	            normals = triangleGraphics.normals.get(numVertices);
	            tangents = triangleGraphics.tangents.get(numVertices);
	            stride = triangleGraphics.concatenatedBuffer.stride / 4;
	            fidx = 0;
	            vidx = 0;
	            for (yi = 0; yi <= this._segmentsH; ++yi) {
	                for (xi = 0; xi <= this._segmentsW; ++xi) {
	                    x = (xi / this._segmentsW - .5) * this._width;
	                    y = (yi / this._segmentsH - .5) * this._height;
	                    positions[vidx] = x;
	                    if (this._yUp) {
	                        positions[vidx + 1] = 0;
	                        positions[vidx + 2] = y;
	                    }
	                    else {
	                        positions[vidx + 1] = y;
	                        positions[vidx + 2] = 0;
	                    }
	                    normals[vidx] = 0;
	                    if (this._yUp) {
	                        normals[vidx + 1] = 1;
	                        normals[vidx + 2] = 0;
	                    }
	                    else {
	                        normals[vidx + 1] = 0;
	                        normals[vidx + 2] = -1;
	                    }
	                    tangents[vidx] = 1;
	                    tangents[vidx + 1] = 0;
	                    tangents[vidx + 2] = 0;
	                    vidx += stride;
	                    // add vertex with same position, but with inverted normal & tangent
	                    if (this._doubleSided) {
	                        for (var i = vidx; i < vidx + 3; ++i) {
	                            positions[i] = positions[i - 3];
	                            normals[i] = -normals[i - 3];
	                            tangents[i] = -tangents[i - 3];
	                        }
	                        vidx += stride;
	                    }
	                    if (xi != this._segmentsW && yi != this._segmentsH) {
	                        base = xi + yi * tw;
	                        var mult = this._doubleSided ? 2 : 1;
	                        indices[fidx++] = base * mult;
	                        indices[fidx++] = (base + tw) * mult;
	                        indices[fidx++] = (base + tw + 1) * mult;
	                        indices[fidx++] = base * mult;
	                        indices[fidx++] = (base + tw + 1) * mult;
	                        indices[fidx++] = (base + 1) * mult;
	                        if (this._doubleSided) {
	                            indices[fidx++] = (base + tw + 1) * mult + 1;
	                            indices[fidx++] = (base + tw) * mult + 1;
	                            indices[fidx++] = base * mult + 1;
	                            indices[fidx++] = (base + 1) * mult + 1;
	                            indices[fidx++] = (base + tw + 1) * mult + 1;
	                            indices[fidx++] = base * mult + 1;
	                        }
	                    }
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	            var lineGraphics = target;
	            var numSegments = (this._segmentsH + 1) + tw;
	            var positions;
	            var thickness;
	            var hw = this._width / 2;
	            var hh = this._height / 2;
	            positions = new Float32Array(numSegments * 6);
	            thickness = new Float32Array(numSegments);
	            fidx = 0;
	            vidx = 0;
	            for (yi = 0; yi <= this._segmentsH; ++yi) {
	                positions[vidx++] = -hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = yi * this._height - hh;
	                positions[vidx++] = hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = yi * this._height - hh;
	                thickness[fidx++] = 1;
	            }
	            for (xi = 0; xi <= this._segmentsW; ++xi) {
	                positions[vidx++] = xi * this._width - hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = -hh;
	                positions[vidx++] = xi * this._width - hw;
	                positions[vidx++] = 0;
	                positions[vidx++] = hh;
	                thickness[fidx++] = 1;
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitivePlanePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var uvs;
	        var stride;
	        var numVertices;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	            if (this._doubleSided)
	                numVertices *= 2;
	            var triangleGraphics = target;
	            if (triangleGraphics.uvs && numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
	            }
	            else {
	                triangleGraphics.setUVs(new Float32Array(numVertices * 2));
	            }
	            uvs = triangleGraphics.uvs.get(numVertices);
	            stride = triangleGraphics.uvs.stride;
	            var index = 0;
	            for (var yi = 0; yi <= this._segmentsH; ++yi) {
	                for (var xi = 0; xi <= this._segmentsW; ++xi) {
	                    uvs[index] = (xi / this._segmentsW) * this._scaleU;
	                    uvs[index + 1] = (1 - yi / this._segmentsH) * this._scaleV;
	                    index += stride;
	                    if (this._doubleSided) {
	                        uvs[index] = (xi / this._segmentsW) * this._scaleU;
	                        uvs[index + 1] = (1 - yi / this._segmentsH) * this._scaleV;
	                        index += stride;
	                    }
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    return PrimitivePlanePrefab;
	}(PrimitivePrefabBase_1.PrimitivePrefabBase));
	exports.PrimitivePlanePrefab = PrimitivePlanePrefab;


/***/ },
/* 315 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(203);
	var PrimitivePrefabBase_1 = __webpack_require__(310);
	/**
	 * A UV Sphere primitive sprite.
	 */
	var PrimitiveSpherePrefab = (function (_super) {
	    __extends(PrimitiveSpherePrefab, _super);
	    /**
	     * Creates a new Sphere object.
	     *
	     * @param radius The radius of the sphere.
	     * @param segmentsW Defines the number of horizontal segments that make up the sphere.
	     * @param segmentsH Defines the number of vertical segments that make up the sphere.
	     * @param yUp Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveSpherePrefab(material, elementsType, radius, segmentsW, segmentsH, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (segmentsW === void 0) { segmentsW = 16; }
	        if (segmentsH === void 0) { segmentsH = 12; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._radius = radius;
	        this._segmentsW = segmentsW;
	        this._segmentsH = segmentsH;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "radius", {
	        /**
	         * The radius of the sphere.
	         */
	        get: function () {
	            return this._radius;
	        },
	        set: function (value) {
	            this._radius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "segmentsW", {
	        /**
	         * Defines the number of horizontal segments that make up the sphere. Defaults to 16.
	         */
	        get: function () {
	            return this._segmentsW;
	        },
	        set: function (value) {
	            this._segmentsW = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "segmentsH", {
	        /**
	         * Defines the number of vertical segments that make up the sphere. Defaults to 12.
	         */
	        get: function () {
	            return this._segmentsH;
	        },
	        set: function (value) {
	            this._segmentsH = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveSpherePrefab.prototype, "yUp", {
	        /**
	         * Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveSpherePrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var stride;
	        var i;
	        var j;
	        var vidx, fidx; // indices
	        var comp1;
	        var comp2;
	        var numVertices;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	            if (numVertices == triangleGraphics.numVertices && triangleGraphics.indices != null) {
	                triangleGraphics.invalidateIndices();
	                triangleGraphics.invalidateVertices(triangleGraphics.positions);
	                triangleGraphics.invalidateVertices(triangleGraphics.normals);
	                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
	            }
	            else {
	                triangleGraphics.setIndices(new Uint16Array((this._segmentsH - 1) * this._segmentsW * 6));
	                triangleGraphics.setPositions(new Float32Array(numVertices * 3));
	                triangleGraphics.setNormals(new Float32Array(numVertices * 3));
	                triangleGraphics.setTangents(new Float32Array(numVertices * 3));
	                this._pInvalidateUVs();
	            }
	            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	            positions = triangleGraphics.positions.get(numVertices);
	            normals = triangleGraphics.normals.get(numVertices);
	            tangents = triangleGraphics.tangents.get(numVertices);
	            stride = triangleGraphics.concatenatedBuffer.stride / 4;
	            vidx = 0;
	            fidx = 0;
	            var startIndex;
	            var t1;
	            var t2;
	            for (j = 0; j <= this._segmentsH; ++j) {
	                startIndex = vidx;
	                var horangle = Math.PI * j / this._segmentsH;
	                var z = -this._radius * Math.cos(horangle);
	                var ringradius = this._radius * Math.sin(horangle);
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    var verangle = 2 * Math.PI * i / this._segmentsW;
	                    var x = ringradius * Math.cos(verangle);
	                    var y = ringradius * Math.sin(verangle);
	                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
	                    var tanLen = Math.sqrt(y * y + x * x);
	                    if (this._yUp) {
	                        t1 = 0;
	                        t2 = tanLen > .007 ? x / tanLen : 0;
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        t1 = tanLen > .007 ? x / tanLen : 0;
	                        t2 = 0;
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._segmentsW) {
	                        positions[vidx] = positions[startIndex];
	                        positions[vidx + 1] = positions[startIndex + 1];
	                        positions[vidx + 2] = positions[startIndex + 2];
	                        normals[vidx] = normals[startIndex] + (x * normLen) * .5;
	                        normals[vidx + 1] = normals[startIndex + 1] + (comp1 * normLen) * .5;
	                        normals[vidx + 2] = normals[startIndex + 2] + (comp2 * normLen) * .5;
	                        tangents[vidx] = tanLen > .007 ? -y / tanLen : 1;
	                        tangents[vidx + 1] = t1;
	                        tangents[vidx + 2] = t2;
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                        normals[vidx] = x * normLen;
	                        normals[vidx + 1] = comp1 * normLen;
	                        normals[vidx + 2] = comp2 * normLen;
	                        tangents[vidx] = tanLen > .007 ? -y / tanLen : 1;
	                        tangents[vidx + 1] = t1;
	                        tangents[vidx + 2] = t2;
	                    }
	                    if (i > 0 && j > 0) {
	                        var a = (this._segmentsW + 1) * j + i;
	                        var b = (this._segmentsW + 1) * j + i - 1;
	                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
	                        var d = (this._segmentsW + 1) * (j - 1) + i;
	                        if (j == this._segmentsH) {
	                            positions[vidx] = positions[startIndex];
	                            positions[vidx + 1] = positions[startIndex + 1];
	                            positions[vidx + 2] = positions[startIndex + 2];
	                            indices[fidx++] = a;
	                            indices[fidx++] = c;
	                            indices[fidx++] = d;
	                        }
	                        else if (j == 1) {
	                            indices[fidx++] = a;
	                            indices[fidx++] = b;
	                            indices[fidx++] = c;
	                        }
	                        else {
	                            indices[fidx++] = a;
	                            indices[fidx++] = b;
	                            indices[fidx++] = c;
	                            indices[fidx++] = a;
	                            indices[fidx++] = c;
	                            indices[fidx++] = d;
	                        }
	                    }
	                    vidx += stride;
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	            var lineGraphics = target;
	            var numSegments = this._segmentsH * this._segmentsW * 2 + this._segmentsW;
	            var positions = new Float32Array(numSegments * 6);
	            var thickness = new Float32Array(numSegments);
	            vidx = 0;
	            fidx = 0;
	            for (j = 0; j <= this._segmentsH; ++j) {
	                var horangle = Math.PI * j / this._segmentsH;
	                var z = -this._radius * Math.cos(horangle);
	                var ringradius = this._radius * Math.sin(horangle);
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    var verangle = 2 * Math.PI * i / this._segmentsW;
	                    var x = ringradius * Math.cos(verangle);
	                    var y = ringradius * Math.sin(verangle);
	                    if (this._yUp) {
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i > 0) {
	                        //horizonal lines
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                        thickness[fidx++] = 1;
	                        //vertical lines
	                        if (j > 0) {
	                            var addx = (j == 1) ? 3 - (6 * (this._segmentsW - i) + 12 * i) : 3 - this._segmentsW * 12;
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx] = positions[vidx++ + addx];
	                            positions[vidx++] = x;
	                            positions[vidx++] = comp1;
	                            positions[vidx++] = comp2;
	                            thickness[fidx++] = 1;
	                        }
	                    }
	                    //horizonal lines
	                    if (i < this._segmentsW) {
	                        positions[vidx++] = x;
	                        positions[vidx++] = comp1;
	                        positions[vidx++] = comp2;
	                    }
	                }
	            }
	            // build real data from raw data
	            lineGraphics.setPositions(positions);
	            lineGraphics.setThickness(thickness);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveSpherePrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j;
	        var numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	        var uvs;
	        var stride;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
	            var triangleGraphics = target;
	            if (triangleGraphics.uvs && numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
	            }
	            else {
	                triangleGraphics.setUVs(new Float32Array(numVertices * 2));
	            }
	            uvs = triangleGraphics.uvs.get(numVertices);
	            stride = triangleGraphics.uvs.stride;
	            var index = 0;
	            for (j = 0; j <= this._segmentsH; ++j) {
	                for (i = 0; i <= this._segmentsW; ++i) {
	                    uvs[index] = (i / this._segmentsW) * this._scaleU;
	                    uvs[index + 1] = (j / this._segmentsH) * this._scaleV;
	                    index += stride;
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    return PrimitiveSpherePrefab;
	}(PrimitivePrefabBase_1.PrimitivePrefabBase));
	exports.PrimitiveSpherePrefab = PrimitiveSpherePrefab;


/***/ },
/* 316 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsType_1 = __webpack_require__(203);
	var PrimitivePrefabBase_1 = __webpack_require__(310);
	/**
	 * A UV Cylinder primitive sprite.
	 */
	var PrimitiveTorusPrefab = (function (_super) {
	    __extends(PrimitiveTorusPrefab, _super);
	    /**
	     * Creates a new <code>Torus</code> object.
	     * @param radius The radius of the torus.
	     * @param tuebRadius The radius of the inner tube of the torus.
	     * @param segmentsR Defines the number of horizontal segments that make up the torus.
	     * @param segmentsT Defines the number of vertical segments that make up the torus.
	     * @param yUp Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitiveTorusPrefab(material, elementsType, radius, tubeRadius, segmentsR, segmentsT, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 50; }
	        if (tubeRadius === void 0) { tubeRadius = 50; }
	        if (segmentsR === void 0) { segmentsR = 16; }
	        if (segmentsT === void 0) { segmentsT = 8; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType);
	        this._numVertices = 0;
	        this._radius = radius;
	        this._tubeRadius = tubeRadius;
	        this._segmentsR = segmentsR;
	        this._segmentsT = segmentsT;
	        this._yUp = yUp;
	    }
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "radius", {
	        /**
	         * The radius of the torus.
	         */
	        get: function () {
	            return this._radius;
	        },
	        set: function (value) {
	            this._radius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "tubeRadius", {
	        /**
	         * The radius of the inner tube of the torus.
	         */
	        get: function () {
	            return this._tubeRadius;
	        },
	        set: function (value) {
	            this._tubeRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "segmentsR", {
	        /**
	         * Defines the number of horizontal segments that make up the torus. Defaults to 16.
	         */
	        get: function () {
	            return this._segmentsR;
	        },
	        set: function (value) {
	            this._segmentsR = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "segmentsT", {
	        /**
	         * Defines the number of vertical segments that make up the torus. Defaults to 8.
	         */
	        get: function () {
	            return this._segmentsT;
	        },
	        set: function (value) {
	            this._segmentsT = value;
	            this._pInvalidatePrimitive();
	            this._pInvalidateUVs();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitiveTorusPrefab.prototype, "yUp", {
	        /**
	         * Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
	         */
	        get: function () {
	            return this._yUp;
	        },
	        set: function (value) {
	            this._yUp = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    PrimitiveTorusPrefab.prototype._pBuildGraphics = function (target, elementsType) {
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var stride;
	        var i, j;
	        var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
	        var vidx;
	        var fidx;
	        var numIndices = 0;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            // evaluate target number of vertices, triangles and indices
	            this._numVertices = (this._segmentsT + 1) * (this._segmentsR + 1); // segmentsT + 1 because of closure, segmentsR + 1 because of closure
	            numIndices = this._segmentsT * this._segmentsR * 6; // each level has segmentR quads, each of 2 triangles
	            // need to initialize raw arrays or can be reused?
	            if (this._numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateIndices();
	                triangleGraphics.invalidateVertices(triangleGraphics.positions);
	                triangleGraphics.invalidateVertices(triangleGraphics.normals);
	                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
	            }
	            else {
	                triangleGraphics.setIndices(new Uint16Array(numIndices));
	                triangleGraphics.setPositions(new Float32Array(this._numVertices * 3));
	                triangleGraphics.setNormals(new Float32Array(this._numVertices * 3));
	                triangleGraphics.setTangents(new Float32Array(this._numVertices * 3));
	                this._pInvalidateUVs();
	            }
	            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
	            positions = triangleGraphics.positions.get(this._numVertices);
	            normals = triangleGraphics.normals.get(this._numVertices);
	            tangents = triangleGraphics.tangents.get(this._numVertices);
	            stride = triangleGraphics.concatenatedBuffer.stride / 4;
	            vidx = 0;
	            fidx = 0;
	            // evaluate revolution steps
	            var revolutionAngleDeltaR = 2 * Math.PI / this._segmentsR;
	            var revolutionAngleDeltaT = 2 * Math.PI / this._segmentsT;
	            var comp1, comp2;
	            var t1, t2, n1, n2;
	            var startIndex = 0;
	            var nextVertexIndex = 0;
	            // surface
	            var a, b, c, d, length;
	            for (j = 0; j <= this._segmentsT; ++j) {
	                startIndex = vidx;
	                for (i = 0; i <= this._segmentsR; ++i) {
	                    // revolution vertex
	                    revolutionAngleR = i * revolutionAngleDeltaR;
	                    revolutionAngleT = j * revolutionAngleDeltaT;
	                    length = Math.cos(revolutionAngleT);
	                    nx = length * Math.cos(revolutionAngleR);
	                    ny = length * Math.sin(revolutionAngleR);
	                    nz = Math.sin(revolutionAngleT);
	                    x = this._radius * Math.cos(revolutionAngleR) + this._tubeRadius * nx;
	                    y = this._radius * Math.sin(revolutionAngleR) + this._tubeRadius * ny;
	                    z = (j == this._segmentsT) ? 0 : this._tubeRadius * nz;
	                    if (this._yUp) {
	                        n1 = -nz;
	                        n2 = ny;
	                        t1 = 0;
	                        t2 = (length ? nx / length : x / this._radius);
	                        comp1 = -z;
	                        comp2 = y;
	                    }
	                    else {
	                        n1 = ny;
	                        n2 = nz;
	                        t1 = (length ? nx / length : x / this._radius);
	                        t2 = 0;
	                        comp1 = y;
	                        comp2 = z;
	                    }
	                    if (i == this._segmentsR) {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = positions[startIndex + 1];
	                        positions[vidx + 2] = positions[startIndex + 2];
	                    }
	                    else {
	                        positions[vidx] = x;
	                        positions[vidx + 1] = comp1;
	                        positions[vidx + 2] = comp2;
	                    }
	                    normals[vidx] = nx;
	                    normals[vidx + 1] = n1;
	                    normals[vidx + 2] = n2;
	                    tangents[vidx] = -(length ? ny / length : y / this._radius);
	                    tangents[vidx + 1] = t1;
	                    tangents[vidx + 2] = t2;
	                    vidx += stride;
	                    // close triangle
	                    if (i > 0 && j > 0) {
	                        a = nextVertexIndex; // current
	                        b = nextVertexIndex - 1; // previous
	                        c = b - this._segmentsR - 1; // previous of last level
	                        d = a - this._segmentsR - 1; // current of last level
	                        indices[fidx++] = a;
	                        indices[fidx++] = b;
	                        indices[fidx++] = c;
	                        indices[fidx++] = a;
	                        indices[fidx++] = c;
	                        indices[fidx++] = d;
	                    }
	                    nextVertexIndex++;
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    PrimitiveTorusPrefab.prototype._pBuildUVs = function (target, elementsType) {
	        var i, j;
	        var uvs;
	        var stride;
	        if (elementsType == ElementsType_1.ElementsType.TRIANGLE) {
	            var triangleGraphics = target;
	            // need to initialize raw array or can be reused?
	            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
	                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
	            }
	            else {
	                triangleGraphics.setUVs(new Float32Array(this._numVertices * 2));
	            }
	            uvs = triangleGraphics.uvs.get(this._numVertices);
	            stride = triangleGraphics.uvs.stride;
	            // current uv component index
	            var index = 0;
	            // surface
	            for (j = 0; j <= this._segmentsT; ++j) {
	                for (i = 0; i <= this._segmentsR; ++i) {
	                    // revolution vertex
	                    uvs[index] = (i / this._segmentsR) * this._scaleU;
	                    uvs[index + 1] = (j / this._segmentsT) * this._scaleV;
	                    index += stride;
	                }
	            }
	        }
	        else if (elementsType == ElementsType_1.ElementsType.LINE) {
	        }
	    };
	    return PrimitiveTorusPrefab;
	}(PrimitivePrefabBase_1.PrimitivePrefabBase));
	exports.PrimitiveTorusPrefab = PrimitiveTorusPrefab;


/***/ },
/* 317 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationSetBase_1 = __webpack_require__(318);
	var AnimationRegisterData_1 = __webpack_require__(320);
	var VertexAnimationMode_1 = __webpack_require__(321);
	/**
	 * The animation data set used by vertex-based animators, containing vertex animation state data.
	 *
	 * @see VertexAnimator
	 */
	var VertexAnimationSet = (function (_super) {
	    __extends(VertexAnimationSet, _super);
	    /**
	     * Returns whether or not normal data is used in last set GPU pass of the vertex shader.
	     */
	    //		public get useNormals():boolean
	    //		{
	    //			return this._uploadNormals;
	    //		}
	    /**
	     * Creates a new <code>VertexAnimationSet</code> object.
	     *
	     * @param numPoses The number of poses made available at once to the GPU animation code.
	     * @param blendMode Optional value for setting the animation mode of the vertex animator object.
	     *
	     * @see away3d.animators.data.VertexAnimationMode
	     */
	    function VertexAnimationSet(numPoses, blendMode) {
	        if (numPoses === void 0) { numPoses = 2; }
	        if (blendMode === void 0) { blendMode = "absolute"; }
	        _super.call(this);
	        this._numPoses = numPoses;
	        this._blendMode = blendMode;
	    }
	    Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
	        /**
	         * Returns the number of poses made available at once to the GPU animation code.
	         */
	        get: function () {
	            return this._numPoses;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexAnimationSet.prototype, "blendMode", {
	        /**
	         * Returns the active blend mode of the vertex animator object.
	         */
	        get: function () {
	            return this._blendMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
	        //grab animationRegisterData from the materialpassbase or create a new one if the first time
	        this._iAnimationRegisterData = shader.animationRegisterData;
	        if (this._iAnimationRegisterData == null)
	            this._iAnimationRegisterData = shader.animationRegisterData = new AnimationRegisterData_1.AnimationRegisterData();
	        if (this._blendMode == VertexAnimationMode_1.VertexAnimationMode.ABSOLUTE)
	            return this.getAbsoluteAGALCode(shader, registerCache, sharedRegisters);
	        else
	            return this.getAdditiveAGALCode(shader, registerCache, sharedRegisters);
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
	        return "";
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
	        return "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimationSet.prototype.doneAGALCode = function (shader) {
	    };
	    /**
	     * Generates the vertex AGAL code for absolute blending.
	     */
	    VertexAnimationSet.prototype.getAbsoluteAGALCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        var temp1 = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(temp1, 1);
	        var temp2 = registerCache.getFreeVertexVectorTemp();
	        var regs = new Array(".x", ".y", ".z", ".w");
	        var len = sharedRegisters.animatableAttributes.length;
	        var constantReg = registerCache.getFreeVertexConstant();
	        this._iAnimationRegisterData.weightsIndex = constantReg.index;
	        this._iAnimationRegisterData.poseIndices = new Array(this._numPoses);
	        var poseInput;
	        var k = 0;
	        if (len > 2)
	            len = 2;
	        for (var i = 0; i < len; ++i) {
	            code += "mul " + temp1 + ", " + sharedRegisters.animatableAttributes[i] + ", " + constantReg + regs[0] + "\n";
	            for (var j = 1; j < this._numPoses; ++j) {
	                poseInput = registerCache.getFreeVertexAttribute();
	                this._iAnimationRegisterData.poseIndices[k++] = poseInput.index;
	                code += "mul " + temp2 + ", " + poseInput + ", " + constantReg + regs[j] + "\n";
	                if (j < this._numPoses - 1)
	                    code += "add " + temp1 + ", " + temp1 + ", " + temp2 + "\n";
	            }
	            code += "add " + sharedRegisters.animationTargetRegisters[i] + ", " + temp1 + ", " + temp2 + "\n";
	        }
	        // add code for bitangents if tangents are used
	        if (shader.tangentDependencies > 0 || shader.outputsNormals) {
	            code += "dp3 " + temp1 + ".x, " + sharedRegisters.animatableAttributes[2] + ", " + sharedRegisters.animationTargetRegisters[1] + "\n" +
	                "mul " + temp1 + ", " + sharedRegisters.animationTargetRegisters[1] + ", " + temp1 + ".x\n" +
	                "sub " + sharedRegisters.animationTargetRegisters[2] + ", " + sharedRegisters.animationTargetRegisters[2] + ", " + temp1 + "\n";
	        }
	        //
	        // // simply write attributes to targets, do not animate them
	        // // projection will pick up on targets[0] to do the projection
	        // var len:number = sharedRegisters.animatableAttributes.length;
	        // for (var i:number = 0; i < len; ++i)
	        // 	code += "mov " + sharedRegisters.animationTargetRegisters[i] + ", " + sharedRegisters.animatableAttributes[i] + "\n";
	        return code;
	    };
	    /**
	     * Generates the vertex AGAL code for additive blending.
	     */
	    VertexAnimationSet.prototype.getAdditiveAGALCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        var len = sharedRegisters.animatableAttributes.length;
	        var regs = [".x", ".y", ".z", ".w"];
	        var temp1 = registerCache.getFreeVertexVectorTemp();
	        var constantReg = registerCache.getFreeVertexConstant();
	        this._iAnimationRegisterData.weightsIndex = constantReg.index;
	        this._iAnimationRegisterData.poseIndices = new Array(this._numPoses);
	        var poseInput;
	        var k = 0;
	        if (len > 2)
	            len = 2;
	        code += "mov  " + sharedRegisters.animationTargetRegisters[0] + ", " + sharedRegisters.animatableAttributes[0] + "\n";
	        if (shader.normalDependencies > 0)
	            code += "mov " + sharedRegisters.animationTargetRegisters[1] + ", " + sharedRegisters.animatableAttributes[1] + "\n";
	        for (var i = 0; i < len; ++i) {
	            for (var j = 0; j < this._numPoses; ++j) {
	                poseInput = registerCache.getFreeVertexAttribute();
	                this._iAnimationRegisterData.poseIndices[k++] = poseInput.index;
	                code += "mul " + temp1 + ", " + poseInput + ", " + constantReg + regs[j] + "\n" +
	                    "add " + sharedRegisters.animationTargetRegisters[i] + ", " + sharedRegisters.animationTargetRegisters[i] + ", " + temp1 + "\n";
	            }
	        }
	        if (shader.tangentDependencies > 0 || shader.outputsNormals) {
	            code += "dp3 " + temp1 + ".x, " + sharedRegisters.animatableAttributes[2] + ", " + sharedRegisters.animationTargetRegisters[1] + "\n" +
	                "mul " + temp1 + ", " + sharedRegisters.animationTargetRegisters[1] + ", " + temp1 + ".x\n" +
	                "sub " + sharedRegisters.animationTargetRegisters[2] + ", " + sharedRegisters.animatableAttributes[2] + ", " + temp1 + "\n";
	        }
	        return code;
	    };
	    return VertexAnimationSet;
	}(AnimationSetBase_1.AnimationSetBase));
	exports.VertexAnimationSet = VertexAnimationSet;


/***/ },
/* 318 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var AbstractMethodError_1 = __webpack_require__(7);
	var AnimationSetError_1 = __webpack_require__(319);
	/**
	 * Provides an abstract base class for data set classes that hold animation data for use in animator classes.
	 *
	 * @see away.animators.AnimatorBase
	 */
	var AnimationSetBase = (function (_super) {
	    __extends(AnimationSetBase, _super);
	    function AnimationSetBase() {
	        _super.call(this);
	        this._animations = new Array();
	        this._animationNames = new Array();
	        this._animationDictionary = new Object();
	    }
	    /**
	     * Retrieves a temporary GPU register that's still free.
	     *
	     * @param exclude An array of non-free temporary registers.
	     * @param excludeAnother An additional register that's not free.
	     * @return A temporary register that can be used.
	     */
	    AnimationSetBase.prototype._pFindTempReg = function (exclude, excludeAnother) {
	        if (excludeAnother === void 0) { excludeAnother = null; }
	        var i = 0;
	        var reg;
	        while (true) {
	            reg = "vt" + i;
	            if (exclude.indexOf(reg) == -1 && excludeAnother != reg)
	                return reg;
	            ++i;
	        }
	    };
	    Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
	        /**
	         * Indicates whether the properties of the animation data contained within the set combined with
	         * the vertex registers already in use on shading materials allows the animation data to utilise
	         * GPU calls.
	         */
	        get: function () {
	            return this._usesCPU;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Called by the material to reset the GPU indicator before testing whether register space in the shader
	     * is available for running GPU-based animation code.
	     *
	     * @private
	     */
	    AnimationSetBase.prototype.resetGPUCompatibility = function () {
	        this._usesCPU = false;
	    };
	    AnimationSetBase.prototype.cancelGPUCompatibility = function () {
	        this._usesCPU = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationSetBase.prototype.doneAGALCode = function (shader) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    Object.defineProperty(AnimationSetBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return AnimationSetBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationSetBase.prototype, "animations", {
	        /**
	         * Returns a vector of animation state objects that make up the contents of the animation data set.
	         */
	        get: function () {
	            return this._animations;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationSetBase.prototype, "animationNames", {
	        /**
	         * Returns a vector of animation state objects that make up the contents of the animation data set.
	         */
	        get: function () {
	            return this._animationNames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Check to determine whether a state is registered in the animation set under the given name.
	     *
	     * @param stateName The name of the animation state object to be checked.
	     */
	    AnimationSetBase.prototype.hasAnimation = function (name) {
	        return this._animationDictionary[name] != null;
	    };
	    /**
	     * Retrieves the animation state object registered in the animation data set under the given name.
	     *
	     * @param stateName The name of the animation state object to be retrieved.
	     */
	    AnimationSetBase.prototype.getAnimation = function (name) {
	        return this._animationDictionary[name];
	    };
	    /**
	     * Adds an animation state object to the aniamtion data set under the given name.
	     *
	     * @param stateName The name under which the animation state object will be stored.
	     * @param animationState The animation state object to be staored in the set.
	     */
	    AnimationSetBase.prototype.addAnimation = function (node) {
	        if (this._animationDictionary[node.name])
	            throw new AnimationSetError_1.AnimationSetError("root node name '" + node.name + "' already exists in the set");
	        this._animationDictionary[node.name] = node;
	        this._animations.push(node);
	        this._animationNames.push(node.name);
	    };
	    /**
	     * Cleans up any resources used by the current object.
	     */
	    AnimationSetBase.prototype.dispose = function () {
	    };
	    AnimationSetBase.assetType = "[asset AnimationSet]";
	    return AnimationSetBase;
	}(AssetBase_1.AssetBase));
	exports.AnimationSetBase = AnimationSetBase;


/***/ },
/* 319 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	var AnimationSetError = (function (_super) {
	    __extends(AnimationSetError, _super);
	    function AnimationSetError(message) {
	        _super.call(this, message);
	    }
	    return AnimationSetError;
	}(ErrorBase_1.ErrorBase));
	exports.AnimationSetError = AnimationSetError;


/***/ },
/* 320 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * ...
	 */
	var AnimationRegisterData = (function () {
	    function AnimationRegisterData() {
	        this.indexDictionary = new Object();
	    }
	    AnimationRegisterData.prototype.reset = function (registerCache, sharedRegisters, needVelocity) {
	        this.rotationRegisters = new Array();
	        this.positionAttribute = sharedRegisters.animatableAttributes[0];
	        this.scaleAndRotateTarget = sharedRegisters.animationTargetRegisters[0];
	        for (var i = 1; i < sharedRegisters.animationTargetRegisters.length; i++)
	            this.rotationRegisters.push(sharedRegisters.animationTargetRegisters[i]);
	        //allot const register
	        this.vertexZeroConst = registerCache.getFreeVertexConstant();
	        this.vertexZeroConst = new ShaderRegisterElement_1.ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 0);
	        this.vertexOneConst = new ShaderRegisterElement_1.ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 1);
	        this.vertexTwoConst = new ShaderRegisterElement_1.ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 2);
	        //allot temp register
	        this.positionTarget = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(this.positionTarget, 1);
	        this.positionTarget = new ShaderRegisterElement_1.ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);
	        if (needVelocity) {
	            this.velocityTarget = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(this.velocityTarget, 1);
	            this.velocityTarget = new ShaderRegisterElement_1.ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index);
	            this.vertexTime = new ShaderRegisterElement_1.ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index, 3);
	            this.vertexLife = new ShaderRegisterElement_1.ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index, 3);
	        }
	        else {
	            var tempTime = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(tempTime, 1);
	            this.vertexTime = new ShaderRegisterElement_1.ShaderRegisterElement(tempTime.regName, tempTime.index, 0);
	            this.vertexLife = new ShaderRegisterElement_1.ShaderRegisterElement(tempTime.regName, tempTime.index, 1);
	        }
	    };
	    AnimationRegisterData.prototype.setUVSourceAndTarget = function (sharedRegisters) {
	        this.uvVar = sharedRegisters.uvTarget;
	        this.uvAttribute = sharedRegisters.uvSource;
	        //uv action is processed after normal actions,so use offsetTarget as uvTarget
	        this.uvTarget = new ShaderRegisterElement_1.ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);
	    };
	    AnimationRegisterData.prototype.setRegisterIndex = function (node, parameterIndex, registerIndex) {
	        //8 should be enough for any node.
	        var t = this.indexDictionary[node.id];
	        if (t == null)
	            t = this.indexDictionary[node.id] = new Array(8);
	        t[parameterIndex] = registerIndex;
	    };
	    AnimationRegisterData.prototype.getRegisterIndex = function (node, parameterIndex) {
	        return this.indexDictionary[node.id][parameterIndex];
	    };
	    return AnimationRegisterData;
	}());
	exports.AnimationRegisterData = AnimationRegisterData;


/***/ },
/* 321 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Options for setting the animation mode of a vertex animator object.
	 *
	 * @see away.animators.VertexAnimator
	 */
	var VertexAnimationMode = (function () {
	    function VertexAnimationMode() {
	    }
	    /**
	     * Animation mode that adds all outputs from active vertex animation state to form the current vertex animation pose.
	     */
	    VertexAnimationMode.ADDITIVE = "additive";
	    /**
	     * Animation mode that picks the output from a single vertex animation state to form the current vertex animation pose.
	     */
	    VertexAnimationMode.ABSOLUTE = "absolute";
	    return VertexAnimationMode;
	}());
	exports.VertexAnimationMode = VertexAnimationMode;


/***/ },
/* 322 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var TriangleElements_1 = __webpack_require__(179);
	var AnimatorBase_1 = __webpack_require__(323);
	var VertexAnimationMode_1 = __webpack_require__(321);
	/**
	 * Provides an interface for assigning vertex-based animation data sets to sprite-based entity objects
	 * and controlling the various available states of animation through an interative playhead that can be
	 * automatically updated or manually triggered.
	 */
	var VertexAnimator = (function (_super) {
	    __extends(VertexAnimator, _super);
	    /**
	     * Creates a new <code>VertexAnimator</code> object.
	     *
	     * @param vertexAnimationSet The animation data set containing the vertex animations used by the animator.
	     */
	    function VertexAnimator(vertexAnimationSet) {
	        _super.call(this, vertexAnimationSet);
	        this._poses = new Array();
	        this._weights = new Float32Array([1, 0, 0, 0]);
	        this._vertexAnimationSet = vertexAnimationSet;
	    }
	    /**
	     * @inheritDoc
	     */
	    VertexAnimator.prototype.clone = function () {
	        return new VertexAnimator(this._vertexAnimationSet);
	    };
	    /**
	     * Plays a sequence with a given name. If the sequence is not found, it may not be loaded yet, and it will retry every frame.
	     * @param sequenceName The name of the clip to be played.
	     */
	    VertexAnimator.prototype.play = function (name, transition, offset) {
	        if (transition === void 0) { transition = null; }
	        if (offset === void 0) { offset = NaN; }
	        if (this._pActiveAnimationName == name)
	            return;
	        this._pActiveAnimationName = name;
	        //TODO: implement transitions in vertex animator
	        if (!this._pAnimationSet.hasAnimation(name))
	            throw new Error("Animation root node " + name + " not found!");
	        this._pActiveNode = this._pAnimationSet.getAnimation(name);
	        this._pActiveState = this.getAnimationState(this._pActiveNode);
	        if (this.updatePosition) {
	            //update straight away to reset position deltas
	            this._pActiveState.update(this._pAbsoluteTime);
	            this._pActiveState.positionDelta;
	        }
	        this._activeVertexState = this._pActiveState;
	        this.start();
	        //apply a time offset if specified
	        if (!isNaN(offset))
	            this.reset(name, offset);
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimator.prototype._pUpdateDeltaTime = function (dt) {
	        _super.prototype._pUpdateDeltaTime.call(this, dt);
	        var geometryFlag = false;
	        if (this._poses[0] != this._activeVertexState.currentGraphics) {
	            this._poses[0] = this._activeVertexState.currentGraphics;
	            geometryFlag = true;
	        }
	        if (this._poses[1] != this._activeVertexState.nextGraphics)
	            this._poses[1] = this._activeVertexState.nextGraphics;
	        this._weights[0] = 1 - (this._weights[1] = this._activeVertexState.blendWeight);
	        if (geometryFlag)
	            this.invalidateElements();
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexAnimator.prototype.setRenderState = function (shader, renderable, stage, camera) {
	        // todo: add code for when running on cpu
	        // this type of animation can only be SubSprite
	        var graphic = renderable.graphic;
	        var elements = graphic.elements;
	        // if no poses defined, set temp data
	        if (!this._poses.length) {
	            this.setNullPose(shader, elements, stage);
	            return;
	        }
	        var animationRegisterData = shader.animationRegisterData;
	        var i;
	        var len = this._vertexAnimationSet.numPoses;
	        shader.setVertexConstFromArray(animationRegisterData.weightsIndex, this._weights);
	        if (this._vertexAnimationSet.blendMode == VertexAnimationMode_1.VertexAnimationMode.ABSOLUTE)
	            i = 1;
	        else
	            i = 0;
	        var elementsGL;
	        var k = 0;
	        for (; i < len; ++i) {
	            elements = this._poses[i].getGraphicAt(graphic._iIndex).elements || graphic.elements;
	            elementsGL = stage.getAbstraction(elements);
	            elementsGL._indexMappings = stage.getAbstraction(graphic.elements).getIndexMappings();
	            if (elements.isAsset(TriangleElements_1.TriangleElements)) {
	                elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.positions);
	                if (shader.normalDependencies > 0)
	                    elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.normals);
	            }
	        }
	    };
	    VertexAnimator.prototype.setNullPose = function (shader, elements, stage) {
	        var animationRegisterData = shader.animationRegisterData;
	        shader.setVertexConstFromArray(animationRegisterData.weightsIndex, this._weights);
	        var elementsGL = stage.getAbstraction(elements);
	        var k = 0;
	        if (this._vertexAnimationSet.blendMode == VertexAnimationMode_1.VertexAnimationMode.ABSOLUTE) {
	            var len = this._vertexAnimationSet.numPoses;
	            for (var i = 1; i < len; ++i) {
	                if (elements.isAsset(TriangleElements_1.TriangleElements)) {
	                    elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.positions);
	                    if (shader.normalDependencies > 0)
	                        elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.normals);
	                }
	            }
	        }
	        // todo: set temp data for additive?
	    };
	    /**
	     * Verifies if the animation will be used on cpu. Needs to be true for all passes for a material to be able to use it on gpu.
	     * Needs to be called if gpu code is potentially required.
	     */
	    VertexAnimator.prototype.testGPUCompatibility = function (shader) {
	    };
	    VertexAnimator.prototype.getRenderableElements = function (renderable, sourceElements) {
	        if (this._vertexAnimationSet.blendMode == VertexAnimationMode_1.VertexAnimationMode.ABSOLUTE && this._poses.length)
	            return this._poses[0].getGraphicAt(renderable.graphic._iIndex).elements || sourceElements;
	        //nothing to do here
	        return sourceElements;
	    };
	    return VertexAnimator;
	}(AnimatorBase_1.AnimatorBase));
	exports.VertexAnimator = VertexAnimator;


/***/ },
/* 323 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var AbstractMethodError_1 = __webpack_require__(7);
	var RequestAnimationFrame_1 = __webpack_require__(324);
	var getTimer_1 = __webpack_require__(294);
	var AnimatorEvent_1 = __webpack_require__(325);
	/**
	 * Dispatched when playback of an animation inside the animator object starts.
	 *
	 * @eventType away3d.events.AnimatorEvent
	 */
	//[Event(name="start", type="away3d.events.AnimatorEvent")]
	/**
	 * Dispatched when playback of an animation inside the animator object stops.
	 *
	 * @eventType away3d.events.AnimatorEvent
	 */
	//[Event(name="stop", type="away3d.events.AnimatorEvent")]
	/**
	 * Dispatched when playback of an animation reaches the end of an animation.
	 *
	 * @eventType away3d.events.AnimatorEvent
	 */
	//[Event(name="cycle_complete", type="away3d.events.AnimatorEvent")]
	/**
	 * Provides an abstract base class for animator classes that control animation output from a data set subtype of <code>AnimationSetBase</code>.
	 *
	 * @see away.animators.AnimationSetBase
	 */
	var AnimatorBase = (function (_super) {
	    __extends(AnimatorBase, _super);
	    /**
	     * Creates a new <code>AnimatorBase</code> object.
	     *
	     * @param animationSet The animation data set to be used by the animator object.
	     */
	    function AnimatorBase(animationSet) {
	        _super.call(this);
	        this._autoUpdate = true;
	        this._time = 0;
	        this._playbackSpeed = 1;
	        this._pOwners = new Array();
	        this._pAbsoluteTime = 0;
	        this._animationStates = new Object();
	        /**
	         * Enables translation of the animated sprite from data returned per frame via the positionDelta property of the active animation node. Defaults to true.
	         *
	         * @see away.animators.IAnimationState#positionDelta
	         */
	        this.updatePosition = true;
	        this._pAnimationSet = animationSet;
	        this._broadcaster = new RequestAnimationFrame_1.RequestAnimationFrame(this.onEnterFrame, this);
	    }
	    AnimatorBase.prototype.getAnimationState = function (node) {
	        var className = node.stateClass;
	        var uID = node.id;
	        if (this._animationStates[uID] == null)
	            this._animationStates[uID] = new className(this, node);
	        return this._animationStates[uID];
	    };
	    AnimatorBase.prototype.getAnimationStateByName = function (name) {
	        return this.getAnimationState(this._pAnimationSet.getAnimation(name));
	    };
	    Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
	        /**
	         * Returns the internal absolute time of the animator, calculated by the current time and the playback speed.
	         *
	         * @see #time
	         * @see #playbackSpeed
	         */
	        get: function () {
	            return this._pAbsoluteTime;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "animationSet", {
	        /**
	         * Returns the animation data set in use by the animator.
	         */
	        get: function () {
	            return this._pAnimationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "activeState", {
	        /**
	         * Returns the current active animation state.
	         */
	        get: function () {
	            return this._pActiveState;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
	        /**
	         * Returns the current active animation node.
	         */
	        get: function () {
	            return this._pAnimationSet.getAnimation(this._pActiveAnimationName);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
	        /**
	         * Returns the current active animation node.
	         */
	        get: function () {
	            return this._pActiveAnimationName;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
	        /**
	         * Determines whether the animators internal update mechanisms are active. Used in cases
	         * where manual updates are required either via the <code>time</code> property or <code>update()</code> method.
	         * Defaults to true.
	         *
	         * @see #time
	         * @see #update()
	         */
	        get: function () {
	            return this._autoUpdate;
	        },
	        set: function (value) {
	            if (this._autoUpdate == value)
	                return;
	            this._autoUpdate = value;
	            if (this._autoUpdate)
	                this.start();
	            else
	                this.stop();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimatorBase.prototype, "time", {
	        /**
	         * Gets and sets the internal time clock of the animator.
	         */
	        get: function () {
	            return this._time;
	        },
	        set: function (value) {
	            if (this._time == value)
	                return;
	            this.update(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Sets the animation phase of the current active state's animation clip(s).
	     *
	     * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
	     */
	    AnimatorBase.prototype.phase = function (value) {
	        this._pActiveState.phase(value);
	    };
	    Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
	        /**
	         * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
	         */
	        get: function () {
	            return this._playbackSpeed;
	        },
	        set: function (value) {
	            this._playbackSpeed = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AnimatorBase.prototype.setRenderState = function (shader, renderable, stage, camera) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Resumes the automatic playback clock controling the active state of the animator.
	     */
	    AnimatorBase.prototype.start = function () {
	        if (this._isPlaying || !this._autoUpdate)
	            return;
	        this._time = this._pAbsoluteTime = getTimer_1.getTimer();
	        this._isPlaying = true;
	        this._broadcaster.start();
	        if (!this.hasEventListener(AnimatorEvent_1.AnimatorEvent.START))
	            return;
	        if (this._startEvent == null)
	            this._startEvent = new AnimatorEvent_1.AnimatorEvent(AnimatorEvent_1.AnimatorEvent.START, this);
	        this.dispatchEvent(this._startEvent);
	    };
	    /**
	     * Pauses the automatic playback clock of the animator, in case manual updates are required via the
	     * <code>time</code> property or <code>update()</code> method.
	     *
	     * @see #time
	     * @see #update()
	     */
	    AnimatorBase.prototype.stop = function () {
	        if (!this._isPlaying)
	            return;
	        this._isPlaying = false;
	        this._broadcaster.stop();
	        if (!this.hasEventListener(AnimatorEvent_1.AnimatorEvent.STOP))
	            return;
	        if (this._stopEvent == null)
	            this._stopEvent = new AnimatorEvent_1.AnimatorEvent(AnimatorEvent_1.AnimatorEvent.STOP, this);
	        this.dispatchEvent(this._stopEvent);
	    };
	    /**
	     * Provides a way to manually update the active state of the animator when automatic
	     * updates are disabled.
	     *
	     * @see #stop()
	     * @see #autoUpdate
	     */
	    AnimatorBase.prototype.update = function (time) {
	        var dt = (time - this._time) * this.playbackSpeed;
	        this._pUpdateDeltaTime(dt);
	        this._time = time;
	    };
	    AnimatorBase.prototype.reset = function (name, offset) {
	        if (offset === void 0) { offset = 0; }
	        this.getAnimationState(this._pAnimationSet.getAnimation(name)).offset(offset + this._pAbsoluteTime);
	    };
	    /**
	     * Used by the sprite object to which the animator is applied, registers the owner for internal use.
	     *
	     * @private
	     */
	    AnimatorBase.prototype.addOwner = function (sprite) {
	        this._pOwners.push(sprite);
	    };
	    /**
	     * Used by the sprite object from which the animator is removed, unregisters the owner for internal use.
	     *
	     * @private
	     */
	    AnimatorBase.prototype.removeOwner = function (sprite) {
	        this._pOwners.splice(this._pOwners.indexOf(sprite), 1);
	    };
	    /**
	     * Internal abstract method called when the time delta property of the animator's contents requires updating.
	     *
	     * @private
	     */
	    AnimatorBase.prototype._pUpdateDeltaTime = function (dt) {
	        this._pAbsoluteTime += dt;
	        this._pActiveState.update(this._pAbsoluteTime);
	        if (this.updatePosition)
	            this.applyPositionDelta();
	    };
	    /**
	     * Enter frame event handler for automatically updating the active state of the animator.
	     */
	    AnimatorBase.prototype.onEnterFrame = function (event) {
	        if (event === void 0) { event = null; }
	        this.update(getTimer_1.getTimer());
	    };
	    AnimatorBase.prototype.applyPositionDelta = function () {
	        var delta = this._pActiveState.positionDelta;
	        var dist = delta.length;
	        var len;
	        if (dist > 0) {
	            len = this._pOwners.length;
	            for (var i = 0; i < len; ++i)
	                this._pOwners[i].transform.translateLocal(delta, dist);
	        }
	    };
	    /**
	     *  for internal use.
	     *
	     * @private
	     */
	    AnimatorBase.prototype.dispatchCycleEvent = function () {
	        if (this.hasEventListener(AnimatorEvent_1.AnimatorEvent.CYCLE_COMPLETE)) {
	            if (this._cycleEvent == null)
	                this._cycleEvent = new AnimatorEvent_1.AnimatorEvent(AnimatorEvent_1.AnimatorEvent.CYCLE_COMPLETE, this);
	            this.dispatchEvent(this._cycleEvent);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimatorBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimatorBase.prototype.dispose = function () {
	    };
	    AnimatorBase.prototype.invalidateElements = function () {
	        var sprite;
	        var len = this._pOwners.length;
	        for (var i = 0; i < len; i++) {
	            sprite = this._pOwners[i];
	            sprite.graphics.invalidateElements();
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimatorBase.prototype.testGPUCompatibility = function (shader) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    Object.defineProperty(AnimatorBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return AnimatorBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AnimatorBase.prototype.getRenderableElements = function (renderable, sourceElements) {
	        //nothing to do here
	        return sourceElements;
	    };
	    AnimatorBase.assetType = "[asset Animator]";
	    return AnimatorBase;
	}(AssetBase_1.AssetBase));
	exports.AnimatorBase = AnimatorBase;


/***/ },
/* 324 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var getTimer_1 = __webpack_require__(294);
	var RequestAnimationFrame = (function () {
	    function RequestAnimationFrame(callback, callbackContext) {
	        var _this = this;
	        this._active = false;
	        this._argsArray = new Array();
	        this._getTimer = getTimer_1.getTimer;
	        this.setCallback(callback, callbackContext);
	        this._rafUpdateFunction = function () {
	            if (_this._active)
	                _this._tick();
	        };
	        this._argsArray.push(this._dt);
	    }
	    // Public
	    /**
	     *
	     * @param callback
	     * @param callbackContext
	     */
	    RequestAnimationFrame.prototype.setCallback = function (callback, callbackContext) {
	        this._callback = callback;
	        this._callbackContext = callbackContext;
	    };
	    /**
	     *
	     */
	    RequestAnimationFrame.prototype.start = function () {
	        this._prevTime = this._getTimer();
	        this._active = true;
	        if (window) {
	            if (window.requestAnimationFrame) {
	                window.requestAnimationFrame(this._rafUpdateFunction);
	            }
	            else {
	                if (window['mozRequestAnimationFrame'])
	                    window.requestAnimationFrame = window['mozRequestAnimationFrame'];
	                else if (window['webkitRequestAnimationFrame'])
	                    window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
	                else if (window['oRequestAnimationFrame'])
	                    window.requestAnimationFrame = window['oRequestAnimationFrame'];
	            }
	        }
	    };
	    /**
	     *
	     */
	    RequestAnimationFrame.prototype.stop = function () {
	        this._active = false;
	    };
	    Object.defineProperty(RequestAnimationFrame.prototype, "active", {
	        // Get / Set
	        /**
	         *
	         * @returns {boolean}
	         */
	        get: function () {
	            return this._active;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // Private
	    /**
	     *
	     * @private
	     */
	    RequestAnimationFrame.prototype._tick = function () {
	        this._currentTime = this._getTimer();
	        this._dt = this._currentTime - this._prevTime;
	        this._argsArray[0] = this._dt;
	        this._callback.apply(this._callbackContext, this._argsArray);
	        window.requestAnimationFrame(this._rafUpdateFunction);
	        this._prevTime = this._currentTime;
	    };
	    return RequestAnimationFrame;
	}());
	exports.RequestAnimationFrame = RequestAnimationFrame;


/***/ },
/* 325 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	/**
	 * Dispatched to notify changes in an animator's state.
	 */
	var AnimatorEvent = (function (_super) {
	    __extends(AnimatorEvent, _super);
	    /**
	     * Create a new <code>AnimatorEvent</code> object.
	     *
	     * @param type The event type.
	     * @param animator The animator object that is the subject of this event.
	     */
	    function AnimatorEvent(type, animator) {
	        _super.call(this, type);
	        this._animator = animator;
	    }
	    Object.defineProperty(AnimatorEvent.prototype, "animator", {
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current event object.
	     */
	    AnimatorEvent.prototype.clone = function () {
	        return new AnimatorEvent(this.type, this._animator);
	    };
	    /**
	     * Defines the value of the type property of a start event object.
	     */
	    AnimatorEvent.START = "animatorStart";
	    /**
	     * Defines the value of the type property of a stop event object.
	     */
	    AnimatorEvent.STOP = "animatorStop";
	    /**
	     * Defines the value of the type property of a cycle complete event object.
	     */
	    AnimatorEvent.CYCLE_COMPLETE = "animatorCycleComplete";
	    return AnimatorEvent;
	}(EventBase_1.EventBase));
	exports.AnimatorEvent = AnimatorEvent;


/***/ },
/* 326 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationSetBase_1 = __webpack_require__(318);
	/**
	 * The animation data set used by skeleton-based animators, containing skeleton animation data.
	 *
	 * @see away.animators.SkeletonAnimator
	 */
	var SkeletonAnimationSet = (function (_super) {
	    __extends(SkeletonAnimationSet, _super);
	    /**
	     * Creates a new <code>SkeletonAnimationSet</code> object.
	     *
	     * @param jointsPerVertex Sets the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the maximum allowed value is 4. Defaults to 4.
	     */
	    function SkeletonAnimationSet(jointsPerVertex) {
	        if (jointsPerVertex === void 0) { jointsPerVertex = 4; }
	        _super.call(this);
	        this._jointsPerVertex = jointsPerVertex;
	    }
	    Object.defineProperty(SkeletonAnimationSet.prototype, "jointsPerVertex", {
	        /**
	         * Returns the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the
	         * maximum allowed value is 4.
	         */
	        get: function () {
	            return this._jointsPerVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimationSet.prototype, "matricesIndex", {
	        get: function () {
	            return this._matricesIndex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
	        this._matricesIndex = registerCache.numUsedVertexConstants;
	        var indexOffset0 = this._matricesIndex;
	        var indexOffset1 = this._matricesIndex + 1;
	        var indexOffset2 = this._matricesIndex + 2;
	        var indexStream = registerCache.getFreeVertexAttribute();
	        shader.jointIndexIndex = indexStream.index;
	        var weightStream = registerCache.getFreeVertexAttribute();
	        shader.jointWeightIndex = weightStream.index;
	        var indices = [indexStream + ".x", indexStream + ".y", indexStream + ".z", indexStream + ".w"];
	        var weights = [weightStream + ".x", weightStream + ".y", weightStream + ".z", weightStream + ".w"];
	        var temp1 = registerCache.getFreeVertexVectorTemp();
	        var dot = "dp4";
	        var code = "";
	        var len = sharedRegisters.animatableAttributes.length;
	        for (var i = 0; i < len; ++i) {
	            var source = sharedRegisters.animatableAttributes[i];
	            var target = sharedRegisters.animationTargetRegisters[i];
	            for (var j = 0; j < this._jointsPerVertex; ++j) {
	                registerCache.getFreeVertexConstant();
	                registerCache.getFreeVertexConstant();
	                registerCache.getFreeVertexConstant();
	                code += dot + " " + temp1 + ".x, " + source + ", vc[" + indices[j] + "+" + indexOffset0 + "]\n" +
	                    dot + " " + temp1 + ".y, " + source + ", vc[" + indices[j] + "+" + indexOffset1 + "]\n" +
	                    dot + " " + temp1 + ".z, " + source + ", vc[" + indices[j] + "+" + indexOffset2 + "]\n" +
	                    "mov " + temp1 + ".w, " + source + ".w\n" +
	                    "mul " + temp1 + ", " + temp1 + ", " + weights[j] + "\n"; // apply weight
	                // add or mov to target. Need to write to a temp reg first, because an output can be a target
	                if (j == 0)
	                    code += "mov " + target + ", " + temp1 + "\n";
	                else
	                    code += "add " + target + ", " + target + ", " + temp1 + "\n";
	            }
	            // switch to dp3 once positions have been transformed, from now on, it should only be vectors instead of points
	            dot = "dp3";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
	        return "";
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
	        return "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimationSet.prototype.doneAGALCode = function (shader) {
	    };
	    return SkeletonAnimationSet;
	}(AnimationSetBase_1.AnimationSetBase));
	exports.SkeletonAnimationSet = SkeletonAnimationSet;


/***/ },
/* 327 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ElementsEvent_1 = __webpack_require__(127);
	var AnimatorBase_1 = __webpack_require__(323);
	var JointPose_1 = __webpack_require__(328);
	var SkeletonPose_1 = __webpack_require__(330);
	var AnimationStateEvent_1 = __webpack_require__(331);
	/**
	 * Provides an interface for assigning skeleton-based animation data sets to sprite-based entity objects
	 * and controlling the various available states of animation through an interative playhead that can be
	 * automatically updated or manually triggered.
	 */
	var SkeletonAnimator = (function (_super) {
	    __extends(SkeletonAnimator, _super);
	    /**
	     * Creates a new <code>SkeletonAnimator</code> object.
	     *
	     * @param skeletonAnimationSet The animation data set containing the skeleton animations used by the animator.
	     * @param skeleton The skeleton object used for calculating the resulting global matrices for transforming skinned sprite data.
	     * @param forceCPU Optional value that only allows the animator to perform calculation on the CPU. Defaults to false.
	     */
	    function SkeletonAnimator(animationSet, skeleton, forceCPU) {
	        var _this = this;
	        if (forceCPU === void 0) { forceCPU = false; }
	        _super.call(this, animationSet);
	        this._globalPose = new SkeletonPose_1.SkeletonPose();
	        this._morphedElements = new Object();
	        this._morphedElementsDirty = new Object();
	        this._skeletonAnimationSet = animationSet;
	        this._skeleton = skeleton;
	        this._forceCPU = forceCPU;
	        this._jointsPerVertex = animationSet.jointsPerVertex;
	        this._numJoints = this._skeleton.numJoints;
	        this._globalMatrices = new Float32Array(this._numJoints * 12);
	        var j = 0;
	        for (var i = 0; i < this._numJoints; ++i) {
	            this._globalMatrices[j++] = 1;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 1;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 0;
	            this._globalMatrices[j++] = 1;
	            this._globalMatrices[j++] = 0;
	        }
	        this._onTransitionCompleteDelegate = function (event) { return _this.onTransitionComplete(event); };
	        this._onIndicesUpdateDelegate = function (event) { return _this.onIndicesUpdate(event); };
	        this._onVerticesUpdateDelegate = function (event) { return _this.onVerticesUpdate(event); };
	    }
	    Object.defineProperty(SkeletonAnimator.prototype, "globalMatrices", {
	        /**
	         * returns the calculated global matrices of the current skeleton pose.
	         *
	         * @see #globalPose
	         */
	        get: function () {
	            if (this._globalPropertiesDirty)
	                this.updateGlobalProperties();
	            return this._globalMatrices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "globalPose", {
	        /**
	         * returns the current skeleton pose output from the animator.
	         *
	         * @see away.animators.data.SkeletonPose
	         */
	        get: function () {
	            if (this._globalPropertiesDirty)
	                this.updateGlobalProperties();
	            return this._globalPose;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "skeleton", {
	        /**
	         * Returns the skeleton object in use by the animator - this defines the number and heirarchy of joints used by the
	         * skinned geoemtry to which skeleon animator is applied.
	         */
	        get: function () {
	            return this._skeleton;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "forceCPU", {
	        /**
	         * Indicates whether the skeleton animator is disabled by default for GPU rendering, something that allows the animator to perform calculation on the GPU.
	         * Defaults to false.
	         */
	        get: function () {
	            return this._forceCPU;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonAnimator.prototype, "useCondensedIndices", {
	        /**
	         * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
	         * by condensing the number of joint index values required per sprite. Only applicable to
	         * skeleton animations that utilise more than one sprite object. Defaults to false.
	         */
	        get: function () {
	            return this._useCondensedIndices;
	        },
	        set: function (value) {
	            this._useCondensedIndices = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimator.prototype.clone = function () {
	        return new SkeletonAnimator(this._skeletonAnimationSet, this._skeleton, this._forceCPU);
	    };
	    /**
	     * Plays an animation state registered with the given name in the animation data set.
	     *
	     * @param name The data set name of the animation state to be played.
	     * @param transition An optional transition object that determines how the animator will transition from the currently active animation state.
	     * @param offset An option offset time (in milliseconds) that resets the state's internal clock to the absolute time of the animator plus the offset value. Required for non-looping animation states.
	     */
	    SkeletonAnimator.prototype.play = function (name, transition, offset) {
	        if (transition === void 0) { transition = null; }
	        if (offset === void 0) { offset = NaN; }
	        if (this._pActiveAnimationName == name)
	            return;
	        this._pActiveAnimationName = name;
	        if (!this._pAnimationSet.hasAnimation(name))
	            throw new Error("Animation root node " + name + " not found!");
	        if (transition && this._pActiveNode) {
	            //setup the transition
	            this._pActiveNode = transition.getAnimationNode(this, this._pActiveNode, this._pAnimationSet.getAnimation(name), this._pAbsoluteTime);
	            this._pActiveNode.addEventListener(AnimationStateEvent_1.AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
	        }
	        else
	            this._pActiveNode = this._pAnimationSet.getAnimation(name);
	        this._pActiveState = this.getAnimationState(this._pActiveNode);
	        if (this.updatePosition) {
	            //update straight away to reset position deltas
	            this._pActiveState.update(this._pAbsoluteTime);
	            this._pActiveState.positionDelta;
	        }
	        this._activeSkeletonState = this._pActiveState;
	        this.start();
	        //apply a time offset if specified
	        if (!isNaN(offset))
	            this.reset(name, offset);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimator.prototype.setRenderState = function (shader, renderable, stage, camera) {
	        // do on request of globalProperties
	        if (this._globalPropertiesDirty)
	            this.updateGlobalProperties();
	        var elements = renderable.graphic.elements;
	        elements.useCondensedIndices = this._useCondensedIndices;
	        if (this._useCondensedIndices) {
	            // using a condensed data set
	            this.updateCondensedMatrices(elements.condensedIndexLookUp);
	            shader.setVertexConstFromArray(this._skeletonAnimationSet.matricesIndex, this._condensedMatrices);
	        }
	        else {
	            if (this._pAnimationSet.usesCPU) {
	                if (this._morphedElementsDirty[elements.id])
	                    this.morphElements(renderable, elements);
	                return;
	            }
	            shader.setVertexConstFromArray(this._skeletonAnimationSet.matricesIndex, this._globalMatrices);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonAnimator.prototype.testGPUCompatibility = function (shader) {
	        if (!this._useCondensedIndices && (this._forceCPU || this._jointsPerVertex > 4 || shader.numUsedVertexConstants + this._numJoints * 3 > 128))
	            this._pAnimationSet.cancelGPUCompatibility();
	    };
	    /**
	     * Applies the calculated time delta to the active animation state node or state transition object.
	     */
	    SkeletonAnimator.prototype._pUpdateDeltaTime = function (dt) {
	        _super.prototype._pUpdateDeltaTime.call(this, dt);
	        //invalidate pose matrices
	        this._globalPropertiesDirty = true;
	        //trigger geometry invalidation if using CPU animation
	        if (this._pAnimationSet.usesCPU)
	            this.invalidateElements();
	    };
	    SkeletonAnimator.prototype.updateCondensedMatrices = function (condensedIndexLookUp) {
	        var j = 0, k = 0;
	        var len = condensedIndexLookUp.length;
	        var srcIndex;
	        this._condensedMatrices = new Float32Array(len * 12);
	        for (var i = 0; i < len; i++) {
	            srcIndex = condensedIndexLookUp[i] * 12; //12 required for the three 4-component vectors that store the matrix
	            k = 12;
	            // copy into condensed
	            while (k--)
	                this._condensedMatrices[j++] = this._globalMatrices[srcIndex++];
	        }
	    };
	    SkeletonAnimator.prototype.updateGlobalProperties = function () {
	        this._globalPropertiesDirty = false;
	        //get global pose
	        this.localToGlobalPose(this._activeSkeletonState.getSkeletonPose(this._skeleton), this._globalPose, this._skeleton);
	        // convert pose to matrix
	        var mtxOffset = 0;
	        var globalPoses = this._globalPose.jointPoses;
	        var raw;
	        var ox, oy, oz, ow;
	        var xy2, xz2, xw2;
	        var yz2, yw2, zw2;
	        var n11, n12, n13;
	        var n21, n22, n23;
	        var n31, n32, n33;
	        var m11, m12, m13, m14;
	        var m21, m22, m23, m24;
	        var m31, m32, m33, m34;
	        var joints = this._skeleton.joints;
	        var pose;
	        var quat;
	        var vec;
	        var t;
	        for (var i = 0; i < this._numJoints; ++i) {
	            pose = globalPoses[i];
	            quat = pose.orientation;
	            vec = pose.translation;
	            ox = quat.x;
	            oy = quat.y;
	            oz = quat.z;
	            ow = quat.w;
	            xy2 = (t = 2.0 * ox) * oy;
	            xz2 = t * oz;
	            xw2 = t * ow;
	            yz2 = (t = 2.0 * oy) * oz;
	            yw2 = t * ow;
	            zw2 = 2.0 * oz * ow;
	            yz2 = 2.0 * oy * oz;
	            yw2 = 2.0 * oy * ow;
	            zw2 = 2.0 * oz * ow;
	            ox *= ox;
	            oy *= oy;
	            oz *= oz;
	            ow *= ow;
	            n11 = (t = ox - oy) - oz + ow;
	            n12 = xy2 - zw2;
	            n13 = xz2 + yw2;
	            n21 = xy2 + zw2;
	            n22 = -t - oz + ow;
	            n23 = yz2 - xw2;
	            n31 = xz2 - yw2;
	            n32 = yz2 + xw2;
	            n33 = -ox - oy + oz + ow;
	            // prepend inverse bind pose
	            raw = joints[i].inverseBindPose;
	            m11 = raw[0];
	            m12 = raw[4];
	            m13 = raw[8];
	            m14 = raw[12];
	            m21 = raw[1];
	            m22 = raw[5];
	            m23 = raw[9];
	            m24 = raw[13];
	            m31 = raw[2];
	            m32 = raw[6];
	            m33 = raw[10];
	            m34 = raw[14];
	            this._globalMatrices[mtxOffset] = n11 * m11 + n12 * m21 + n13 * m31;
	            this._globalMatrices[mtxOffset + 1] = n11 * m12 + n12 * m22 + n13 * m32;
	            this._globalMatrices[mtxOffset + 2] = n11 * m13 + n12 * m23 + n13 * m33;
	            this._globalMatrices[mtxOffset + 3] = n11 * m14 + n12 * m24 + n13 * m34 + vec.x;
	            this._globalMatrices[mtxOffset + 4] = n21 * m11 + n22 * m21 + n23 * m31;
	            this._globalMatrices[mtxOffset + 5] = n21 * m12 + n22 * m22 + n23 * m32;
	            this._globalMatrices[mtxOffset + 6] = n21 * m13 + n22 * m23 + n23 * m33;
	            this._globalMatrices[mtxOffset + 7] = n21 * m14 + n22 * m24 + n23 * m34 + vec.y;
	            this._globalMatrices[mtxOffset + 8] = n31 * m11 + n32 * m21 + n33 * m31;
	            this._globalMatrices[mtxOffset + 9] = n31 * m12 + n32 * m22 + n33 * m32;
	            this._globalMatrices[mtxOffset + 10] = n31 * m13 + n32 * m23 + n33 * m33;
	            this._globalMatrices[mtxOffset + 11] = n31 * m14 + n32 * m24 + n33 * m34 + vec.z;
	            mtxOffset = mtxOffset + 12;
	        }
	    };
	    SkeletonAnimator.prototype.getRenderableElements = function (renderable, sourceElements) {
	        this._morphedElementsDirty[sourceElements.id] = true;
	        //early out for GPU animations
	        if (!this._pAnimationSet.usesCPU)
	            return sourceElements;
	        var targetElements;
	        if (!(targetElements = this._morphedElements[sourceElements.id])) {
	            //not yet stored
	            sourceElements.normals;
	            sourceElements.tangents;
	            targetElements = this._morphedElements[sourceElements.id] = sourceElements.clone();
	            //turn off auto calculations on the morphed geometry
	            targetElements.autoDeriveNormals = false;
	            targetElements.autoDeriveTangents = false;
	            //add event listeners for any changes in UV values on the source geometry
	            sourceElements.addEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_INDICES, this._onIndicesUpdateDelegate);
	            sourceElements.addEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_VERTICES, this._onVerticesUpdateDelegate);
	        }
	        return targetElements;
	    };
	    /**
	     * If the animation can't be performed on GPU, transform vertices manually
	     * @param subGeom The subgeometry containing the weights and joint index data per vertex.
	     * @param pass The material pass for which we need to transform the vertices
	     */
	    SkeletonAnimator.prototype.morphElements = function (renderable, sourceElements) {
	        this._morphedElementsDirty[sourceElements.id] = false;
	        var numVertices = sourceElements.numVertices;
	        var sourcePositions = sourceElements.positions.get(numVertices);
	        var sourceNormals = sourceElements.normals.get(numVertices);
	        var sourceTangents = sourceElements.tangents.get(numVertices);
	        var posDim = sourceElements.positions.dimensions;
	        var posStride = sourceElements.positions.stride;
	        var normalStride = sourceElements.normals.stride;
	        var tangentStride = sourceElements.tangents.stride;
	        var jointIndices = sourceElements.jointIndices.get(numVertices);
	        var jointWeights = sourceElements.jointWeights.get(numVertices);
	        var jointStride = sourceElements.jointIndices.stride;
	        var targetElements = this._morphedElements[sourceElements.id];
	        var targetPositions = targetElements.positions.get(numVertices);
	        var targetNormals = targetElements.normals.get(numVertices);
	        var targetTangents = targetElements.tangents.get(numVertices);
	        targetElements.positions.attributesBuffer.invalidate();
	        targetElements.normals.attributesBuffer.invalidate();
	        targetElements.tangents.attributesBuffer.invalidate();
	        var index = 0;
	        var i0 = 0;
	        var i1 = 0;
	        var i2 = 0;
	        var i3 = 0;
	        var k;
	        var vx, vy, vz;
	        var nx, ny, nz;
	        var tx, ty, tz;
	        var weight;
	        var vertX, vertY, vertZ;
	        var normX, normY, normZ;
	        var tangX, tangY, tangZ;
	        var m11, m12, m13, m14;
	        var m21, m22, m23, m24;
	        var m31, m32, m33, m34;
	        while (index < numVertices) {
	            i0 = index * posStride;
	            vertX = sourcePositions[i0];
	            vertY = sourcePositions[i0 + 1];
	            vertZ = (posDim == 3) ? sourcePositions[i0 + 2] : 0;
	            i1 = index * normalStride;
	            normX = sourceNormals[i1];
	            normY = sourceNormals[i1 + 1];
	            normZ = sourceNormals[i1 + 2];
	            i2 = index * tangentStride;
	            tangX = sourceTangents[i2];
	            tangY = sourceTangents[i2 + 1];
	            tangZ = sourceTangents[i2 + 2];
	            vx = 0;
	            vy = 0;
	            vz = 0;
	            nx = 0;
	            ny = 0;
	            nz = 0;
	            tx = 0;
	            ty = 0;
	            tz = 0;
	            k = 0;
	            i3 = index * jointStride;
	            while (k < this._jointsPerVertex) {
	                weight = jointWeights[i3 + k];
	                if (weight > 0) {
	                    // implicit /3*12 (/3 because indices are multiplied by 3 for gpu matrix access, *12 because it's the matrix size)
	                    var mtxOffset = jointIndices[i3 + k] << 2;
	                    m11 = this._globalMatrices[mtxOffset];
	                    m12 = this._globalMatrices[mtxOffset + 1];
	                    m13 = this._globalMatrices[mtxOffset + 2];
	                    m14 = this._globalMatrices[mtxOffset + 3];
	                    m21 = this._globalMatrices[mtxOffset + 4];
	                    m22 = this._globalMatrices[mtxOffset + 5];
	                    m23 = this._globalMatrices[mtxOffset + 6];
	                    m24 = this._globalMatrices[mtxOffset + 7];
	                    m31 = this._globalMatrices[mtxOffset + 8];
	                    m32 = this._globalMatrices[mtxOffset + 9];
	                    m33 = this._globalMatrices[mtxOffset + 10];
	                    m34 = this._globalMatrices[mtxOffset + 11];
	                    vx += weight * (m11 * vertX + m12 * vertY + m13 * vertZ + m14);
	                    vy += weight * (m21 * vertX + m22 * vertY + m23 * vertZ + m24);
	                    vz += weight * (m31 * vertX + m32 * vertY + m33 * vertZ + m34);
	                    nx += weight * (m11 * normX + m12 * normY + m13 * normZ);
	                    ny += weight * (m21 * normX + m22 * normY + m23 * normZ);
	                    nz += weight * (m31 * normX + m32 * normY + m33 * normZ);
	                    tx += weight * (m11 * tangX + m12 * tangY + m13 * tangZ);
	                    ty += weight * (m21 * tangX + m22 * tangY + m23 * tangZ);
	                    tz += weight * (m31 * tangX + m32 * tangY + m33 * tangZ);
	                    k++;
	                }
	                else {
	                    //if zero weight encountered, skip to the next vertex
	                    k = this._jointsPerVertex;
	                }
	            }
	            targetPositions[i0] = vx;
	            targetPositions[i0 + 1] = vy;
	            if (posDim == 3)
	                targetPositions[i0 + 2] = vz;
	            targetNormals[i1] = nx;
	            targetNormals[i1 + 1] = ny;
	            targetNormals[i1 + 2] = nz;
	            targetTangents[i2] = tx;
	            targetTangents[i2 + 1] = ty;
	            targetTangents[i2 + 2] = tz;
	            index++;
	        }
	    };
	    /**
	     * Converts a local hierarchical skeleton pose to a global pose
	     * @param targetPose The SkeletonPose object that will contain the global pose.
	     * @param skeleton The skeleton containing the joints, and as such, the hierarchical data to transform to global poses.
	     */
	    SkeletonAnimator.prototype.localToGlobalPose = function (sourcePose, targetPose, skeleton) {
	        var globalPoses = targetPose.jointPoses;
	        var globalJointPose;
	        var joints = skeleton.joints;
	        var len = sourcePose.numJointPoses;
	        var jointPoses = sourcePose.jointPoses;
	        var parentIndex;
	        var joint;
	        var parentPose;
	        var pose;
	        var or;
	        var tr;
	        var t;
	        var q;
	        var x1, y1, z1, w1;
	        var x2, y2, z2, w2;
	        var x3, y3, z3;
	        // :s
	        if (globalPoses.length != len)
	            globalPoses.length = len;
	        for (var i = 0; i < len; ++i) {
	            globalJointPose = globalPoses[i];
	            if (globalJointPose == null)
	                globalJointPose = globalPoses[i] = new JointPose_1.JointPose();
	            joint = joints[i];
	            parentIndex = joint.parentIndex;
	            pose = jointPoses[i];
	            q = globalJointPose.orientation;
	            t = globalJointPose.translation;
	            if (parentIndex < 0) {
	                tr = pose.translation;
	                or = pose.orientation;
	                q.x = or.x;
	                q.y = or.y;
	                q.z = or.z;
	                q.w = or.w;
	                t.x = tr.x;
	                t.y = tr.y;
	                t.z = tr.z;
	            }
	            else {
	                // append parent pose
	                parentPose = globalPoses[parentIndex];
	                // rotate point
	                or = parentPose.orientation;
	                tr = pose.translation;
	                x2 = or.x;
	                y2 = or.y;
	                z2 = or.z;
	                w2 = or.w;
	                x3 = tr.x;
	                y3 = tr.y;
	                z3 = tr.z;
	                w1 = -x2 * x3 - y2 * y3 - z2 * z3;
	                x1 = w2 * x3 + y2 * z3 - z2 * y3;
	                y1 = w2 * y3 - x2 * z3 + z2 * x3;
	                z1 = w2 * z3 + x2 * y3 - y2 * x3;
	                // append parent translation
	                tr = parentPose.translation;
	                t.x = -w1 * x2 + x1 * w2 - y1 * z2 + z1 * y2 + tr.x;
	                t.y = -w1 * y2 + x1 * z2 + y1 * w2 - z1 * x2 + tr.y;
	                t.z = -w1 * z2 - x1 * y2 + y1 * x2 + z1 * w2 + tr.z;
	                // append parent orientation
	                x1 = or.x;
	                y1 = or.y;
	                z1 = or.z;
	                w1 = or.w;
	                or = pose.orientation;
	                x2 = or.x;
	                y2 = or.y;
	                z2 = or.z;
	                w2 = or.w;
	                q.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
	                q.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
	                q.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
	                q.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
	            }
	        }
	    };
	    SkeletonAnimator.prototype.onTransitionComplete = function (event) {
	        if (event.type == AnimationStateEvent_1.AnimationStateEvent.TRANSITION_COMPLETE) {
	            event.animationNode.removeEventListener(AnimationStateEvent_1.AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
	            //if this is the current active state transition, revert control to the active node
	            if (this._pActiveState == event.animationState) {
	                this._pActiveNode = this._pAnimationSet.getAnimation(this._pActiveAnimationName);
	                this._pActiveState = this.getAnimationState(this._pActiveNode);
	                this._activeSkeletonState = this._pActiveState;
	            }
	        }
	    };
	    SkeletonAnimator.prototype.onIndicesUpdate = function (event) {
	        var elements = event.target;
	        this._morphedElements[elements.id].setIndices(elements.indices);
	    };
	    SkeletonAnimator.prototype.onVerticesUpdate = function (event) {
	        //only update uvs
	        if (event.attributesView != elements.uvs && event.attributesView != elements.getCustomAtributes("secondaryUVs"))
	            return;
	        var elements = event.target;
	        var morphGraphics = this._morphedElements[elements.id];
	        var morphUVs = morphGraphics.uvs.get(elements.numVertices);
	        morphGraphics.invalidateVertices(morphGraphics.uvs);
	        var uvStride = morphGraphics.uvs.stride;
	        var uvs = event.attributesView.get(elements.numVertices);
	        var len = elements.numVertices * uvStride;
	        for (var i = 0; i < len; i += uvStride) {
	            morphUVs[i] = uvs[i];
	            morphUVs[i + 1] = uvs[i + 1];
	        }
	    };
	    return SkeletonAnimator;
	}(AnimatorBase_1.AnimatorBase));
	exports.SkeletonAnimator = SkeletonAnimator;


/***/ },
/* 328 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Matrix3D_1 = __webpack_require__(32);
	var Quaternion_1 = __webpack_require__(329);
	var Vector3D_1 = __webpack_require__(34);
	/**
	 * Contains transformation data for a skeleton joint, used for skeleton animation.
	 *
	 * @see away.animation.Skeleton
	 * @see away.animation.SkeletonJoint
	 *
	 * todo: support (uniform) scale
	 */
	var JointPose = (function () {
	    function JointPose() {
	        /**
	         * The rotation of the pose stored as a quaternion
	         */
	        this.orientation = new Quaternion_1.Quaternion();
	        /**
	         * The translation of the pose
	         */
	        this.translation = new Vector3D_1.Vector3D();
	    }
	    /**
	     * Converts the transformation to a Matrix3D representation.
	     *
	     * @param target An optional target matrix to store the transformation. If not provided, it will create a new instance.
	     * @return The transformation matrix of the pose.
	     */
	    JointPose.prototype.toMatrix3D = function (target) {
	        if (target === void 0) { target = null; }
	        if (target == null)
	            target = new Matrix3D_1.Matrix3D();
	        this.orientation.toMatrix3D(target);
	        target.appendTranslation(this.translation.x, this.translation.y, this.translation.z);
	        return target;
	    };
	    /**
	     * Copies the transformation data from a source pose object into the existing pose object.
	     *
	     * @param pose The source pose to copy from.
	     */
	    JointPose.prototype.copyFrom = function (pose) {
	        var or = pose.orientation;
	        var tr = pose.translation;
	        this.orientation.x = or.x;
	        this.orientation.y = or.y;
	        this.orientation.z = or.z;
	        this.orientation.w = or.w;
	        this.translation.x = tr.x;
	        this.translation.y = tr.y;
	        this.translation.z = tr.z;
	    };
	    return JointPose;
	}());
	exports.JointPose = JointPose;


/***/ },
/* 329 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Orientation3D_1 = __webpack_require__(36);
	var Matrix3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(34);
	/**
	 * A Quaternion object which can be used to represent rotations.
	 */
	var Quaternion = (function () {
	    /**
	     * Creates a new Quaternion object.
	     * @param x The x value of the quaternion.
	     * @param y The y value of the quaternion.
	     * @param z The z value of the quaternion.
	     * @param w The w value of the quaternion.
	     */
	    function Quaternion(x, y, z, w) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (w === void 0) { w = 1; }
	        /**
	         * The x value of the quaternion.
	         */
	        this.x = 0;
	        /**
	         * The y value of the quaternion.
	         */
	        this.y = 0;
	        /**
	         * The z value of the quaternion.
	         */
	        this.z = 0;
	        /**
	         * The w value of the quaternion.
	         */
	        this.w = 1;
	        this.x = x;
	        this.y = y;
	        this.z = z;
	        this.w = w;
	    }
	    Object.defineProperty(Quaternion.prototype, "magnitude", {
	        /**
	         * Returns the magnitude of the quaternion object.
	         */
	        get: function () {
	            return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Fills the quaternion object with the result from a multiplication of two quaternion objects.
	     *
	     * @param    qa    The first quaternion in the multiplication.
	     * @param    qb    The second quaternion in the multiplication.
	     */
	    Quaternion.prototype.multiply = function (qa, qb) {
	        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
	        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
	        this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
	        this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
	        this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
	        this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
	    };
	    Quaternion.prototype.multiplyVector = function (vector, target) {
	        if (target === void 0) { target = null; }
	        //target ||= new Quaternion();
	        if (target === null) {
	            target = new Quaternion();
	        }
	        var x2 = vector.x;
	        var y2 = vector.y;
	        var z2 = vector.z;
	        target.w = -this.x * x2 - this.y * y2 - this.z * z2;
	        target.x = this.w * x2 + this.y * z2 - this.z * y2;
	        target.y = this.w * y2 - this.x * z2 + this.z * x2;
	        target.z = this.w * z2 + this.x * y2 - this.y * x2;
	        return target;
	    };
	    /**
	     * Fills the quaternion object with values representing the given rotation around a vector.
	     *
	     * @param    axis    The axis around which to rotate
	     * @param    angle    The angle in radians of the rotation.
	     */
	    Quaternion.prototype.fromAxisAngle = function (axis, angle) {
	        var sin_a = Math.sin(angle / 2);
	        var cos_a = Math.cos(angle / 2);
	        this.x = axis.x * sin_a;
	        this.y = axis.y * sin_a;
	        this.z = axis.z * sin_a;
	        this.w = cos_a;
	        this.normalize();
	    };
	    /**
	     * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
	     * @param qa The first quaternion to interpolate.
	     * @param qb The second quaternion to interpolate.
	     * @param t The interpolation weight, a value between 0 and 1.
	     */
	    Quaternion.prototype.slerp = function (qa, qb, t) {
	        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
	        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
	        var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
	        // shortest direction
	        if (dot < 0) {
	            dot = -dot;
	            w2 = -w2;
	            x2 = -x2;
	            y2 = -y2;
	            z2 = -z2;
	        }
	        if (dot < 0.95) {
	            // interpolate angle linearly
	            var angle = Math.acos(dot);
	            var s = 1 / Math.sin(angle);
	            var s1 = Math.sin(angle * (1 - t)) * s;
	            var s2 = Math.sin(angle * t) * s;
	            this.w = w1 * s1 + w2 * s2;
	            this.x = x1 * s1 + x2 * s2;
	            this.y = y1 * s1 + y2 * s2;
	            this.z = z1 * s1 + z2 * s2;
	        }
	        else {
	            // nearly identical angle, interpolate linearly
	            this.w = w1 + t * (w2 - w1);
	            this.x = x1 + t * (x2 - x1);
	            this.y = y1 + t * (y2 - y1);
	            this.z = z1 + t * (z2 - z1);
	            var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
	            this.w *= len;
	            this.x *= len;
	            this.y *= len;
	            this.z *= len;
	        }
	    };
	    /**
	     * Linearly interpolates between two quaternions.
	     * @param qa The first quaternion to interpolate.
	     * @param qb The second quaternion to interpolate.
	     * @param t The interpolation weight, a value between 0 and 1.
	     */
	    Quaternion.prototype.lerp = function (qa, qb, t) {
	        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
	        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
	        var len;
	        // shortest direction
	        if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
	            w2 = -w2;
	            x2 = -x2;
	            y2 = -y2;
	            z2 = -z2;
	        }
	        this.w = w1 + t * (w2 - w1);
	        this.x = x1 + t * (x2 - x1);
	        this.y = y1 + t * (y2 - y1);
	        this.z = z1 + t * (z2 - z1);
	        len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
	        this.w *= len;
	        this.x *= len;
	        this.y *= len;
	        this.z *= len;
	    };
	    /**
	     * Fills the quaternion object with values representing the given euler rotation.
	     *
	     * @param    ax        The angle in radians of the rotation around the ax axis.
	     * @param    ay        The angle in radians of the rotation around the ay axis.
	     * @param    az        The angle in radians of the rotation around the az axis.
	     */
	    Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
	        var halfX = ax * .5, halfY = ay * .5, halfZ = az * .5;
	        var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
	        var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
	        var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
	        this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
	        this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
	        this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
	        this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
	    };
	    /**
	     * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
	     * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
	     * @return The Vector3D containing the Euler angles.
	     */
	    Quaternion.prototype.toEulerAngles = function (target) {
	        if (target === void 0) { target = null; }
	        //target ||= new Vector3D();
	        if (target === null) {
	            target = new Vector3D_1.Vector3D();
	        }
	        target.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
	        target.y = Math.asin(2 * (this.w * this.y - this.z * this.x));
	        target.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
	        return target;
	    };
	    /**
	     * Normalises the quaternion object.
	     */
	    Quaternion.prototype.normalize = function (val) {
	        if (val === void 0) { val = 1; }
	        var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
	        this.x *= mag;
	        this.y *= mag;
	        this.z *= mag;
	        this.w *= mag;
	    };
	    /**
	     * Used to trace the values of a quaternion.
	     *
	     * @return A string representation of the quaternion object.
	     */
	    Quaternion.prototype.toString = function () {
	        return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
	    };
	    /**
	     * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
	     * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
	     * @return A Matrix3D object representing an equivalent rotation.
	     */
	    Quaternion.prototype.toMatrix3D = function (target) {
	        if (target === void 0) { target = null; }
	        var rawData = Matrix3DUtils_1.Matrix3DUtils.RAW_DATA_CONTAINER;
	        var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
	        var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
	        var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
	        rawData[0] = xx - yy - zz + ww;
	        rawData[4] = xy2 - zw2;
	        rawData[8] = xz2 + yw2;
	        rawData[12] = 0;
	        rawData[1] = xy2 + zw2;
	        rawData[5] = -xx + yy - zz + ww;
	        rawData[9] = yz2 - xw2;
	        rawData[13] = 0;
	        rawData[2] = xz2 - yw2;
	        rawData[6] = yz2 + xw2;
	        rawData[10] = -xx - yy + zz + ww;
	        rawData[14] = 0;
	        rawData[3] = 0.0;
	        rawData[7] = 0.0;
	        rawData[11] = 0;
	        rawData[15] = 1;
	        if (!target)
	            return new Matrix3D_1.Matrix3D(rawData);
	        else
	            target.copyRawDataFrom(rawData);
	        return target;
	    };
	    /**
	     * Extracts a quaternion rotation matrix out of a given Matrix3D object.
	     * @param matrix The Matrix3D out of which the rotation will be extracted.
	     */
	    Quaternion.prototype.fromMatrix = function (matrix) {
	        var v = matrix.decompose(Orientation3D_1.Orientation3D.QUATERNION)[1];
	        this.x = v.x;
	        this.y = v.y;
	        this.z = v.z;
	        this.w = v.w;
	    };
	    /**
	     * Converts the quaternion to a Vector.&lt;Number&gt; matrix representation of a rotation equivalent to this quaternion.
	     * @param target The Vector.&lt;Number&gt; to contain the raw matrix data.
	     * @param exclude4thRow If true, the last row will be omitted, and a 4x3 matrix will be generated instead of a 4x4.
	     */
	    Quaternion.prototype.toRawData = function (target, exclude4thRow) {
	        if (exclude4thRow === void 0) { exclude4thRow = false; }
	        var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
	        var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
	        var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
	        target[0] = xx - yy - zz + ww;
	        target[1] = xy2 - zw2;
	        target[2] = xz2 + yw2;
	        target[4] = xy2 + zw2;
	        target[5] = -xx + yy - zz + ww;
	        target[6] = yz2 - xw2;
	        target[8] = xz2 - yw2;
	        target[9] = yz2 + xw2;
	        target[10] = -xx - yy + zz + ww;
	        target[3] = target[7] = target[11] = 0;
	        if (!exclude4thRow) {
	            target[12] = target[13] = target[14] = 0;
	            target[15] = 1;
	        }
	    };
	    /**
	     * Clones the quaternion.
	     * @return An exact duplicate of the current Quaternion.
	     */
	    Quaternion.prototype.clone = function () {
	        return new Quaternion(this.x, this.y, this.z, this.w);
	    };
	    /**
	     * Rotates a point.
	     * @param vector The Vector3D object to be rotated.
	     * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
	     * @return A Vector3D object containing the rotated point.
	     */
	    Quaternion.prototype.rotatePoint = function (vector, target) {
	        if (target === void 0) { target = null; }
	        var x1, y1, z1, w1;
	        var x2 = vector.x, y2 = vector.y, z2 = vector.z;
	        //target ||= new Vector3D();
	        if (target === null) {
	            target = new Vector3D_1.Vector3D();
	        }
	        // p*q'
	        w1 = -this.x * x2 - this.y * y2 - this.z * z2;
	        x1 = this.w * x2 + this.y * z2 - this.z * y2;
	        y1 = this.w * y2 - this.x * z2 + this.z * x2;
	        z1 = this.w * z2 + this.x * y2 - this.y * x2;
	        target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
	        target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
	        target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
	        return target;
	    };
	    /**
	     * Copies the data from a quaternion into this instance.
	     * @param q The quaternion to copy from.
	     */
	    Quaternion.prototype.copyFrom = function (q) {
	        this.x = q.x;
	        this.y = q.y;
	        this.z = q.z;
	        this.w = q.w;
	    };
	    return Quaternion;
	}());
	exports.Quaternion = Quaternion;


/***/ },
/* 330 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var JointPose_1 = __webpack_require__(328);
	/**
	 * A collection of pose objects, determining the pose for an entire skeleton.
	 * The <code>jointPoses</code> vector object corresponds to a skeleton's <code>joints</code> vector object, however, there is no
	 * reference to a skeleton's instance, since several skeletons can be influenced by the same pose (eg: animation
	 * clips are added to any animator with a valid skeleton)
	 *
	 * @see away.animators.Skeleton
	 * @see away.animators.JointPose
	 */
	var SkeletonPose = (function (_super) {
	    __extends(SkeletonPose, _super);
	    /**
	     * Creates a new <code>SkeletonPose</code> object.
	     */
	    function SkeletonPose() {
	        _super.call(this);
	        this.jointPoses = new Array();
	    }
	    Object.defineProperty(SkeletonPose.prototype, "numJointPoses", {
	        /**
	         * The total number of joint poses in the skeleton pose.
	         */
	        get: function () {
	            return this.jointPoses.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonPose.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return SkeletonPose.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns the joint pose object with the given joint name, otherwise returns a null object.
	     *
	     * @param jointName The name of the joint object whose pose is to be found.
	     * @return The pose object with the given joint name.
	     */
	    SkeletonPose.prototype.jointPoseFromName = function (jointName) {
	        var jointPoseIndex = this.jointPoseIndexFromName(jointName);
	        if (jointPoseIndex != -1)
	            return this.jointPoses[jointPoseIndex];
	        else
	            return null;
	    };
	    /**
	     * Returns the pose index, given the joint name. -1 is returned if the joint name is not found in the pose.
	     *
	     * @param The name of the joint object whose pose is to be found.
	     * @return The index of the pose object in the jointPoses Array
	     *
	     * @see #jointPoses
	     */
	    SkeletonPose.prototype.jointPoseIndexFromName = function (jointName) {
	        // this is implemented as a linear search, rather than a possibly
	        // more optimal method (Dictionary lookup, for example) because:
	        // a) it is assumed that it will be called once for each joint
	        // b) it is assumed that it will be called only during load, and not during main loop
	        // c) maintaining a dictionary (for safety) would dictate an interface to access JointPoses,
	        //    rather than direct array access.  this would be sub-optimal.
	        var jointPoseIndex;
	        var jointPose;
	        for (var i; i < this.jointPoses.length; i++) {
	            jointPose = this.jointPoses[i];
	            if (jointPose.name == jointName)
	                return jointPoseIndex;
	            jointPoseIndex++;
	        }
	        return -1;
	    };
	    /**
	     * Creates a copy of the <code>SkeletonPose</code> object, with a dulpicate of its component joint poses.
	     *
	     * @return SkeletonPose
	     */
	    SkeletonPose.prototype.clone = function () {
	        var clone = new SkeletonPose();
	        var numJointPoses = this.jointPoses.length;
	        for (var i = 0; i < numJointPoses; i++) {
	            var cloneJointPose = new JointPose_1.JointPose();
	            var thisJointPose = this.jointPoses[i];
	            cloneJointPose.name = thisJointPose.name;
	            cloneJointPose.copyFrom(thisJointPose);
	            clone.jointPoses[i] = cloneJointPose;
	        }
	        return clone;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonPose.prototype.dispose = function () {
	        this.jointPoses.length = 0;
	    };
	    SkeletonPose.assetType = "[asset SkeletonPose]";
	    return SkeletonPose;
	}(AssetBase_1.AssetBase));
	exports.SkeletonPose = SkeletonPose;


/***/ },
/* 331 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	/**
	 * Dispatched to notify changes in an animation state's state.
	 */
	var AnimationStateEvent = (function (_super) {
	    __extends(AnimationStateEvent, _super);
	    /**
	     * Create a new <code>AnimatonStateEvent</code>
	     *
	     * @param type The event type.
	     * @param animator The animation state object that is the subject of this event.
	     * @param animationNode The animation node inside the animation state from which the event originated.
	     */
	    function AnimationStateEvent(type, animator, animationState, animationNode) {
	        _super.call(this, type);
	        this._animator = animator;
	        this._animationState = animationState;
	        this._animationNode = animationNode;
	    }
	    Object.defineProperty(AnimationStateEvent.prototype, "animator", {
	        /**
	         * The animator object that is the subject of this event.
	         */
	        get: function () {
	            return this._animator;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
	        /**
	         * The animation state object that is the subject of this event.
	         */
	        get: function () {
	            return this._animationState;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
	        /**
	         * The animation node inside the animation state from which the event originated.
	         */
	        get: function () {
	            return this._animationNode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    AnimationStateEvent.prototype.clone = function () {
	        return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
	    };
	    /**
	     * Dispatched when a non-looping clip node inside an animation state reaches the end of its timeline.
	     */
	    AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";
	    AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";
	    return AnimationStateEvent;
	}(EventBase_1.EventBase));
	exports.AnimationStateEvent = AnimationStateEvent;


/***/ },
/* 332 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	/**
	 * A Skeleton object is a hierarchical grouping of joint objects that can be used for skeletal animation.
	 *
	 * @see away.animators.SkeletonJoint
	 */
	var Skeleton = (function (_super) {
	    __extends(Skeleton, _super);
	    /**
	     * Creates a new <code>Skeleton</code> object
	     */
	    function Skeleton() {
	        _super.call(this);
	        // in the long run, it might be a better idea to not store Joint objects, but keep all data in Vectors, that we can upload easily?
	        this.joints = new Array();
	    }
	    Object.defineProperty(Skeleton.prototype, "numJoints", {
	        /**
	         * The total number of joints in the skeleton.
	         */
	        get: function () {
	            return this.joints.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns the joint object in the skeleton with the given name, otherwise returns a null object.
	     *
	     * @param jointName The name of the joint object to be found.
	     * @return The joint object with the given name.
	     *
	     * @see #joints
	     */
	    Skeleton.prototype.jointFromName = function (jointName) {
	        var jointIndex = this.jointIndexFromName(jointName);
	        if (jointIndex != -1)
	            return this.joints[jointIndex];
	        else
	            return null;
	    };
	    /**
	     * Returns the joint index, given the joint name. -1 is returned if the joint name is not found.
	     *
	     * @param jointName The name of the joint object to be found.
	     * @return The index of the joint object in the joints Array
	     *
	     * @see #joints
	     */
	    Skeleton.prototype.jointIndexFromName = function (jointName) {
	        // this is implemented as a linear search, rather than a possibly
	        // more optimal method (Dictionary lookup, for example) because:
	        // a) it is assumed that it will be called once for each joint
	        // b) it is assumed that it will be called only during load, and not during main loop
	        // c) maintaining a dictionary (for safety) would dictate an interface to access SkeletonJoints,
	        //    rather than direct array access.  this would be sub-optimal.
	        var jointIndex;
	        var joint;
	        for (var i; i < this.joints.length; i++) {
	            joint = this.joints[i];
	            if (joint.name == jointName)
	                return jointIndex;
	            jointIndex++;
	        }
	        return -1;
	    };
	    /**
	     * @inheritDoc
	     */
	    Skeleton.prototype.dispose = function () {
	        this.joints.length = 0;
	    };
	    Object.defineProperty(Skeleton.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return Skeleton.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Skeleton.assetType = "[asset Skeleton]";
	    return Skeleton;
	}(AssetBase_1.AssetBase));
	exports.Skeleton = Skeleton;


/***/ },
/* 333 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A value obect representing a single joint in a skeleton object.
	 *
	 * @see away.animators.Skeleton
	 */
	var SkeletonJoint = (function () {
	    /**
	     * Creates a new <code>SkeletonJoint</code> object
	     */
	    function SkeletonJoint() {
	        /**
	         * The index of the parent joint in the skeleton's joints vector.
	         *
	         * @see away.animators.Skeleton#joints
	         */
	        this.parentIndex = -1;
	    }
	    return SkeletonJoint;
	}());
	exports.SkeletonJoint = SkeletonJoint;


/***/ },
/* 334 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationClipNodeBase_1 = __webpack_require__(335);
	var SkeletonClipState_1 = __webpack_require__(337);
	/**
	 * A skeleton animation node containing time-based animation data as individual skeleton poses.
	 */
	var SkeletonClipNode = (function (_super) {
	    __extends(SkeletonClipNode, _super);
	    /**
	     * Creates a new <code>SkeletonClipNode</code> object.
	     */
	    function SkeletonClipNode() {
	        _super.call(this);
	        this._frames = new Array();
	        /**
	         * Determines whether to use SLERP equations (true) or LERP equations (false) in the calculation
	         * of the output skeleton pose. Defaults to false.
	         */
	        this.highQuality = false;
	        this._pStateClass = SkeletonClipState_1.SkeletonClipState;
	    }
	    Object.defineProperty(SkeletonClipNode.prototype, "frames", {
	        /**
	         * Returns a vector of skeleton poses representing the pose of each animation frame in the clip.
	         */
	        get: function () {
	            return this._frames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a skeleton pose frame to the internal timeline of the animation node.
	     *
	     * @param skeletonPose The skeleton pose object to add to the timeline of the node.
	     * @param duration The specified duration of the frame in milliseconds.
	     */
	    SkeletonClipNode.prototype.addFrame = function (skeletonPose, duration) {
	        this._frames.push(skeletonPose);
	        this._pDurations.push(duration);
	        this._pNumFrames = this._pDurations.length;
	        this._pStitchDirty = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipNode.prototype._pUpdateStitch = function () {
	        _super.prototype._pUpdateStitch.call(this);
	        var i = this._pNumFrames - 1;
	        var p1, p2, delta;
	        while (i--) {
	            this._pTotalDuration += this._pDurations[i];
	            p1 = this._frames[i].jointPoses[0].translation;
	            p2 = this._frames[i + 1].jointPoses[0].translation;
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	        if (this._pStitchFinalFrame || !this._pLooping) {
	            this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
	            p1 = this._frames[0].jointPoses[0].translation;
	            p2 = this._frames[1].jointPoses[0].translation;
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	    };
	    return SkeletonClipNode;
	}(AnimationClipNodeBase_1.AnimationClipNodeBase));
	exports.SkeletonClipNode = SkeletonClipNode;


/***/ },
/* 335 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var AnimationNodeBase_1 = __webpack_require__(336);
	/**
	 * Provides an abstract base class for nodes with time-based animation data in an animation blend tree.
	 */
	var AnimationClipNodeBase = (function (_super) {
	    __extends(AnimationClipNodeBase, _super);
	    /**
	     * Creates a new <code>AnimationClipNodeBase</code> object.
	     */
	    function AnimationClipNodeBase() {
	        _super.call(this);
	        this._pLooping = true;
	        this._pTotalDuration = 0;
	        this._pStitchDirty = true;
	        this._pStitchFinalFrame = false;
	        this._pNumFrames = 0;
	        this._pDurations = new Array();
	        /*uint*/
	        this._pTotalDelta = new Vector3D_1.Vector3D();
	        this.fixedFrameRate = true;
	    }
	    Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
	        /**
	         * Determines whether the contents of the animation node have looping characteristics enabled.
	         */
	        get: function () {
	            return this._pLooping;
	        },
	        set: function (value) {
	            if (this._pLooping == value)
	                return;
	            this._pLooping = value;
	            this._pStitchDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
	        /**
	         * Defines if looping content blends the final frame of animation data with the first (true) or works on the
	         * assumption that both first and last frames are identical (false). Defaults to false.
	         */
	        get: function () {
	            return this._pStitchFinalFrame;
	        },
	        set: function (value) {
	            if (this._pStitchFinalFrame == value)
	                return;
	            this._pStitchFinalFrame = value;
	            this._pStitchDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
	        get: function () {
	            if (this._pStitchDirty)
	                this._pUpdateStitch();
	            return this._pTotalDuration;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
	        get: function () {
	            if (this._pStitchDirty)
	                this._pUpdateStitch();
	            return this._pTotalDelta;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
	        get: function () {
	            if (this._pStitchDirty)
	                this._pUpdateStitch();
	            return this._pLastFrame;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
	        /**
	         * Returns a vector of time values representing the duration (in milliseconds) of each animation frame in the clip.
	         */
	        get: function () {
	            return this._pDurations;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Updates the node's final frame stitch state.
	     *
	     * @see #stitchFinalFrame
	     */
	    AnimationClipNodeBase.prototype._pUpdateStitch = function () {
	        this._pStitchDirty = false;
	        this._pLastFrame = (this._pStitchFinalFrame) ? this._pNumFrames : this._pNumFrames - 1;
	        this._pTotalDuration = 0;
	        this._pTotalDelta.x = 0;
	        this._pTotalDelta.y = 0;
	        this._pTotalDelta.z = 0;
	    };
	    return AnimationClipNodeBase;
	}(AnimationNodeBase_1.AnimationNodeBase));
	exports.AnimationClipNodeBase = AnimationClipNodeBase;


/***/ },
/* 336 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	/**
	 * Provides an abstract base class for nodes in an animation blend tree.
	 */
	var AnimationNodeBase = (function (_super) {
	    __extends(AnimationNodeBase, _super);
	    /**
	     * Creates a new <code>AnimationNodeBase</code> object.
	     */
	    function AnimationNodeBase() {
	        _super.call(this);
	    }
	    Object.defineProperty(AnimationNodeBase.prototype, "stateClass", {
	        get: function () {
	            return this._pStateClass;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    AnimationNodeBase.prototype.dispose = function () {
	    };
	    Object.defineProperty(AnimationNodeBase.prototype, "assetType", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return AnimationNodeBase.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AnimationNodeBase.assetType = "[asset AnimationNodeBase]";
	    return AnimationNodeBase;
	}(AssetBase_1.AssetBase));
	exports.AnimationNodeBase = AnimationNodeBase;


/***/ },
/* 337 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var JointPose_1 = __webpack_require__(328);
	var SkeletonPose_1 = __webpack_require__(330);
	var AnimationClipState_1 = __webpack_require__(338);
	/**
	 *
	 */
	var SkeletonClipState = (function (_super) {
	    __extends(SkeletonClipState, _super);
	    function SkeletonClipState(animator, skeletonClipNode) {
	        _super.call(this, animator, skeletonClipNode);
	        this._rootPos = new Vector3D_1.Vector3D();
	        this._skeletonPose = new SkeletonPose_1.SkeletonPose();
	        this._skeletonPoseDirty = true;
	        this._skeletonClipNode = skeletonClipNode;
	        this._frames = this._skeletonClipNode.frames;
	    }
	    Object.defineProperty(SkeletonClipState.prototype, "currentPose", {
	        /**
	         * Returns the current skeleton pose frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._currentPose;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(SkeletonClipState.prototype, "nextPose", {
	        /**
	         * Returns the next skeleton pose frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._nextPose;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
	     */
	    SkeletonClipState.prototype.getSkeletonPose = function (skeleton) {
	        if (this._skeletonPoseDirty)
	            this.updateSkeletonPose(skeleton);
	        return this._skeletonPose;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipState.prototype._pUpdateTime = function (time) {
	        this._skeletonPoseDirty = true;
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipState.prototype._pUpdateFrames = function () {
	        _super.prototype._pUpdateFrames.call(this);
	        this._currentPose = this._frames[this._pCurrentFrame];
	        if (this._skeletonClipNode.looping && this._pNextFrame >= this._skeletonClipNode.lastFrame) {
	            this._nextPose = this._frames[0];
	            this._pAnimator.dispatchCycleEvent();
	        }
	        else
	            this._nextPose = this._frames[this._pNextFrame];
	    };
	    /**
	     * Updates the output skeleton pose of the node based on the internal playhead position.
	     *
	     * @param skeleton The skeleton used by the animator requesting the ouput pose.
	     */
	    SkeletonClipState.prototype.updateSkeletonPose = function (skeleton) {
	        this._skeletonPoseDirty = false;
	        if (!this._skeletonClipNode.totalDuration)
	            return;
	        if (this._pFramesDirty)
	            this._pUpdateFrames();
	        var currentPose = this._currentPose.jointPoses;
	        var nextPose = this._nextPose.jointPoses;
	        var numJoints = skeleton.numJoints;
	        var p1, p2;
	        var pose1, pose2;
	        var endPoses = this._skeletonPose.jointPoses;
	        var endPose;
	        var tr;
	        // :s
	        if (endPoses.length != numJoints)
	            endPoses.length = numJoints;
	        if ((numJoints != currentPose.length) || (numJoints != nextPose.length))
	            throw new Error("joint counts don't match!");
	        for (var i = 0; i < numJoints; ++i) {
	            endPose = endPoses[i];
	            if (endPose == null)
	                endPose = endPoses[i] = new JointPose_1.JointPose();
	            pose1 = currentPose[i];
	            pose2 = nextPose[i];
	            p1 = pose1.translation;
	            p2 = pose2.translation;
	            if (this._skeletonClipNode.highQuality)
	                endPose.orientation.slerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
	            else
	                endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
	            if (i > 0) {
	                tr = endPose.translation;
	                tr.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
	                tr.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
	                tr.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
	            }
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonClipState.prototype._pUpdatePositionDelta = function () {
	        this._pPositionDeltaDirty = false;
	        if (this._pFramesDirty)
	            this._pUpdateFrames();
	        var p1, p2, p3;
	        var totalDelta = this._skeletonClipNode.totalDelta;
	        // jumping back, need to reset position
	        if ((this._pTimeDir > 0 && this._pNextFrame < this._pOldFrame) || (this._pTimeDir < 0 && this._pNextFrame > this._pOldFrame)) {
	            this._rootPos.x -= totalDelta.x * this._pTimeDir;
	            this._rootPos.y -= totalDelta.y * this._pTimeDir;
	            this._rootPos.z -= totalDelta.z * this._pTimeDir;
	        }
	        var dx = this._rootPos.x;
	        var dy = this._rootPos.y;
	        var dz = this._rootPos.z;
	        if (this._skeletonClipNode.stitchFinalFrame && this._pNextFrame == this._skeletonClipNode.lastFrame) {
	            p1 = this._frames[0].jointPoses[0].translation;
	            p2 = this._frames[1].jointPoses[0].translation;
	            p3 = this._currentPose.jointPoses[0].translation;
	            this._rootPos.x = p3.x + p1.x + this._pBlendWeight * (p2.x - p1.x);
	            this._rootPos.y = p3.y + p1.y + this._pBlendWeight * (p2.y - p1.y);
	            this._rootPos.z = p3.z + p1.z + this._pBlendWeight * (p2.z - p1.z);
	        }
	        else {
	            p1 = this._currentPose.jointPoses[0].translation;
	            p2 = this._frames[this._pNextFrame].jointPoses[0].translation; //cover the instances where we wrap the pose but still want the final frame translation values
	            this._rootPos.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
	            this._rootPos.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
	            this._rootPos.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
	        }
	        this._pRootDelta.x = this._rootPos.x - dx;
	        this._pRootDelta.y = this._rootPos.y - dy;
	        this._pRootDelta.z = this._rootPos.z - dz;
	        this._pOldFrame = this._pNextFrame;
	    };
	    return SkeletonClipState;
	}(AnimationClipState_1.AnimationClipState));
	exports.SkeletonClipState = SkeletonClipState;


/***/ },
/* 338 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationStateBase_1 = __webpack_require__(339);
	var AnimationStateEvent_1 = __webpack_require__(331);
	/**
	 *
	 */
	var AnimationClipState = (function (_super) {
	    __extends(AnimationClipState, _super);
	    function AnimationClipState(animator, animationClipNode) {
	        _super.call(this, animator, animationClipNode);
	        this._pFramesDirty = true;
	        this._animationClipNode = animationClipNode;
	    }
	    Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
	        /**
	         * Returns a fractional value between 0 and 1 representing the blending ratio of the current playhead position
	         * between the current frame (0) and next frame (1) of the animation.
	         *
	         * @see #currentFrame
	         * @see #nextFrame
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._pBlendWeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
	        /**
	         * Returns the current frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._pCurrentFrame;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
	        /**
	         * Returns the next frame of animation in the clip based on the internal playhead position.
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._pNextFrame;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    AnimationClipState.prototype.update = function (time) {
	        if (!this._animationClipNode.looping) {
	            if (time > this._pStartTime + this._animationClipNode.totalDuration)
	                time = this._pStartTime + this._animationClipNode.totalDuration;
	            else if (time < this._pStartTime)
	                time = this._pStartTime;
	        }
	        if (this._pTime == time - this._pStartTime)
	            return;
	        this._pUpdateTime(time);
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationClipState.prototype.phase = function (value) {
	        var time = value * this._animationClipNode.totalDuration + this._pStartTime;
	        if (this._pTime == time - this._pStartTime)
	            return;
	        this._pUpdateTime(time);
	    };
	    /**
	     * @inheritDoc
	     */
	    AnimationClipState.prototype._pUpdateTime = function (time) {
	        this._pFramesDirty = true;
	        this._pTimeDir = (time - this._pStartTime > this._pTime) ? 1 : -1;
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * Updates the nodes internal playhead to determine the current and next animation frame, and the blendWeight between the two.
	     *
	     * @see #currentFrame
	     * @see #nextFrame
	     * @see #blendWeight
	     */
	    AnimationClipState.prototype._pUpdateFrames = function () {
	        this._pFramesDirty = false;
	        var looping = this._animationClipNode.looping;
	        var totalDuration = this._animationClipNode.totalDuration;
	        var lastFrame = this._animationClipNode.lastFrame;
	        var time = this._pTime;
	        //trace("time", time, totalDuration)
	        if (looping && (time >= totalDuration || time < 0)) {
	            time %= totalDuration;
	            if (time < 0)
	                time += totalDuration;
	        }
	        if (!looping && time >= totalDuration) {
	            this.notifyPlaybackComplete();
	            this._pCurrentFrame = lastFrame;
	            this._pNextFrame = lastFrame;
	            this._pBlendWeight = 0;
	        }
	        else if (!looping && time <= 0) {
	            this._pCurrentFrame = 0;
	            this._pNextFrame = 0;
	            this._pBlendWeight = 0;
	        }
	        else if (this._animationClipNode.fixedFrameRate) {
	            var t = time / totalDuration * lastFrame;
	            this._pCurrentFrame = Math.floor(t);
	            this._pBlendWeight = t - this._pCurrentFrame;
	            this._pNextFrame = this._pCurrentFrame + 1;
	        }
	        else {
	            this._pCurrentFrame = 0;
	            this._pNextFrame = 0;
	            var dur = 0, frameTime;
	            var durations = this._animationClipNode.durations;
	            do {
	                frameTime = dur;
	                dur += durations[this._pNextFrame];
	                this._pCurrentFrame = this._pNextFrame++;
	            } while (time > dur);
	            if (this._pCurrentFrame == lastFrame) {
	                this._pCurrentFrame = 0;
	                this._pNextFrame = 1;
	            }
	            this._pBlendWeight = (time - frameTime) / durations[this._pCurrentFrame];
	        }
	    };
	    AnimationClipState.prototype.notifyPlaybackComplete = function () {
	        if (this._animationStatePlaybackComplete == null)
	            this._animationStatePlaybackComplete = new AnimationStateEvent_1.AnimationStateEvent(AnimationStateEvent_1.AnimationStateEvent.PLAYBACK_COMPLETE, this._pAnimator, this, this._animationClipNode);
	        this._animationClipNode.dispatchEvent(this._animationStatePlaybackComplete);
	    };
	    return AnimationClipState;
	}(AnimationStateBase_1.AnimationStateBase));
	exports.AnimationClipState = AnimationClipState;


/***/ },
/* 339 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(34);
	/**
	 *
	 */
	var AnimationStateBase = (function () {
	    function AnimationStateBase(animator, animationNode) {
	        this._pRootDelta = new Vector3D_1.Vector3D();
	        this._pPositionDeltaDirty = true;
	        this._pStartTime = 0;
	        this._pAnimator = animator;
	        this._pAnimationNode = animationNode;
	    }
	    Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
	        /**
	         * Returns a 3d vector representing the translation delta of the animating entity for the current timestep of animation
	         */
	        get: function () {
	            if (this._pPositionDeltaDirty) {
	                this._pUpdatePositionDelta();
	            }
	            return this._pRootDelta;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Resets the start time of the node to a  new value.
	     *
	     * @param startTime The absolute start time (in milliseconds) of the node's starting time.
	     */
	    AnimationStateBase.prototype.offset = function (startTime) {
	        this._pStartTime = startTime;
	        this._pPositionDeltaDirty = true;
	    };
	    /**
	     * Updates the configuration of the node to its current state.
	     *
	     * @param time The absolute time (in milliseconds) of the animator's play head position.
	     *
	     * @see AnimatorBase#update()
	     */
	    AnimationStateBase.prototype.update = function (time) {
	        if (this._pTime == time - this._pStartTime) {
	            return;
	        }
	        this._pUpdateTime(time);
	    };
	    /**
	     * Sets the animation phase of the node.
	     *
	     * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
	     */
	    AnimationStateBase.prototype.phase = function (value) {
	    };
	    /**
	     * Updates the node's internal playhead position.
	     *
	     * @param time The local time (in milliseconds) of the node's playhead position.
	     */
	    AnimationStateBase.prototype._pUpdateTime = function (time) {
	        this._pTime = time - this._pStartTime;
	        this._pPositionDeltaDirty = true;
	    };
	    /**
	     * Updates the node's root delta position
	     */
	    AnimationStateBase.prototype._pUpdatePositionDelta = function () {
	    };
	    return AnimationStateBase;
	}());
	exports.AnimationStateBase = AnimationStateBase;


/***/ },
/* 340 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var AnimationClipNodeBase_1 = __webpack_require__(335);
	var VertexClipState_1 = __webpack_require__(341);
	/**
	 * A vertex animation node containing time-based animation data as individual geometry obejcts.
	 */
	var VertexClipNode = (function (_super) {
	    __extends(VertexClipNode, _super);
	    /**
	     * Creates a new <code>VertexClipNode</code> object.
	     */
	    function VertexClipNode() {
	        _super.call(this);
	        this._frames = new Array();
	        this._translations = new Array();
	        this._pStateClass = VertexClipState_1.VertexClipState;
	    }
	    Object.defineProperty(VertexClipNode.prototype, "frames", {
	        /**
	         * Returns a vector of geometry frames representing the vertex values of each animation frame in the clip.
	         */
	        get: function () {
	            return this._frames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Adds a geometry object to the internal timeline of the animation node.
	     *
	     * @param geometry The geometry object to add to the timeline of the node.
	     * @param duration The specified duration of the frame in milliseconds.
	     * @param translation The absolute translation of the frame, used in root delta calculations for sprite movement.
	     */
	    VertexClipNode.prototype.addFrame = function (geometry, duration, translation) {
	        if (translation === void 0) { translation = null; }
	        this._frames.push(geometry);
	        this._pDurations.push(duration);
	        this._translations.push(translation || new Vector3D_1.Vector3D());
	        this._pNumFrames = this._pDurations.length;
	        this._pStitchDirty = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexClipNode.prototype._pUpdateStitch = function () {
	        _super.prototype._pUpdateStitch.call(this);
	        var i = this._pNumFrames - 1;
	        var p1, p2, delta;
	        while (i--) {
	            this._pTotalDuration += this._pDurations[i];
	            p1 = this._translations[i];
	            p2 = this._translations[i + 1];
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	        if (this._pNumFrames > 1 && (this._pStitchFinalFrame || !this._pLooping)) {
	            this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
	            p1 = this._translations[0];
	            p2 = this._translations[1];
	            delta = p2.subtract(p1);
	            this._pTotalDelta.x += delta.x;
	            this._pTotalDelta.y += delta.y;
	            this._pTotalDelta.z += delta.z;
	        }
	    };
	    return VertexClipNode;
	}(AnimationClipNodeBase_1.AnimationClipNodeBase));
	exports.VertexClipNode = VertexClipNode;


/***/ },
/* 341 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationClipState_1 = __webpack_require__(338);
	/**
	 *
	 */
	var VertexClipState = (function (_super) {
	    __extends(VertexClipState, _super);
	    function VertexClipState(animator, vertexClipNode) {
	        _super.call(this, animator, vertexClipNode);
	        this._vertexClipNode = vertexClipNode;
	        this._frames = this._vertexClipNode.frames;
	    }
	    Object.defineProperty(VertexClipState.prototype, "currentGraphics", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._currentGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(VertexClipState.prototype, "nextGraphics", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            if (this._pFramesDirty)
	                this._pUpdateFrames();
	            return this._nextGraphics;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    VertexClipState.prototype._pUpdateFrames = function () {
	        _super.prototype._pUpdateFrames.call(this);
	        this._currentGraphics = this._frames[this._pCurrentFrame];
	        if (this._vertexClipNode.looping && this._pNextFrame >= this._vertexClipNode.lastFrame) {
	            this._nextGraphics = this._frames[0];
	            this._pAnimator.dispatchCycleEvent();
	        }
	        else
	            this._nextGraphics = this._frames[this._pNextFrame];
	    };
	    /**
	     * @inheritDoc
	     */
	    VertexClipState.prototype._pUpdatePositionDelta = function () {
	        //TODO:implement positiondelta functionality for vertex animations
	    };
	    return VertexClipState;
	}(AnimationClipState_1.AnimationClipState));
	exports.VertexClipState = VertexClipState;


/***/ },
/* 342 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AS2MovieClipAdapter_1 = __webpack_require__(343);
	var AS2TextFieldAdapter_1 = __webpack_require__(353);
	var TextField_1 = __webpack_require__(191);
	var MovieClip_1 = __webpack_require__(176);
	var AS2SceneGraphFactory = (function () {
	    function AS2SceneGraphFactory(view) {
	        this._view = view;
	    }
	    AS2SceneGraphFactory.prototype.createMovieClip = function (timeline) {
	        var mc = new MovieClip_1.MovieClip(timeline);
	        mc.adapter = new AS2MovieClipAdapter_1.AS2MovieClipAdapter(mc, this._view);
	        return mc;
	    };
	    AS2SceneGraphFactory.prototype.createTextField = function () {
	        var tf = new TextField_1.TextField();
	        tf.adapter = new AS2TextFieldAdapter_1.AS2TextFieldAdapter(tf, this._view);
	        return tf;
	    };
	    return AS2SceneGraphFactory;
	}());
	exports.AS2SceneGraphFactory = AS2SceneGraphFactory;


/***/ },
/* 343 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var Point_1 = __webpack_require__(58);
	var AssetLibrary_1 = __webpack_require__(211);
	var MovieClip_1 = __webpack_require__(176);
	var MouseEvent_1 = __webpack_require__(195);
	var AS2SymbolAdapter_1 = __webpack_require__(344);
	var AS2MCSoundProps_1 = __webpack_require__(345);
	var AS2ColorAdapter_1 = __webpack_require__(346);
	var AS2SystemAdapter_1 = __webpack_require__(347);
	var AS2SoundAdapter_1 = __webpack_require__(348);
	var AS2KeyAdapter_1 = __webpack_require__(349);
	var AS2MouseAdapter_1 = __webpack_require__(350);
	var AS2StageAdapter_1 = __webpack_require__(351);
	var AS2SharedObjectAdapter_1 = __webpack_require__(352);
	var includeString = 'var Color			= this._includes.Color;\n' +
	    'var System				= this._includes.System;\n' +
	    'var Sound				= this._includes.Sound;\n' +
	    'var Key				= this._includes.Key;\n' +
	    'var Mouse				= this._includes.Mouse;\n' +
	    'var Stage				= this._includes.Stage;\n' +
	    'var SharedObject		= this._includes.SharedObject;\n' +
	    'var int = function(value) {return Math.floor(value) | 0;}\n' +
	    'var string = function(value) {return value.toString();}\n' +
	    'var getURL = function(value) {return value;}\n\n';
	var AS2MovieClipAdapter = (function (_super) {
	    __extends(AS2MovieClipAdapter, _super);
	    function AS2MovieClipAdapter(adaptee, view) {
	        // create an empty MovieClip if none is passed
	        _super.call(this, adaptee || new MovieClip_1.MovieClip(), view);
	        this._includes = {
	            Color: AS2ColorAdapter_1.AS2ColorAdapter,
	            System: AS2SystemAdapter_1.AS2SystemAdapter,
	            Sound: AS2SoundAdapter_1.AS2SoundAdapter,
	            Key: AS2KeyAdapter_1.AS2KeyAdapter,
	            Mouse: AS2MouseAdapter_1.AS2MouseAdapter,
	            Stage: AS2StageAdapter_1.AS2StageAdapter,
	            SharedObject: AS2SharedObjectAdapter_1.AS2SharedObjectAdapter
	        };
	        this.__pSoundProps = new AS2MCSoundProps_1.AS2MCSoundProps();
	    }
	    AS2MovieClipAdapter.prototype.dispose = function () {
	        _super.prototype.dispose.call(this);
	        this.__pSoundProps.dispose();
	        this.__pSoundProps = null;
	    };
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "_framesloaded", {
	        get: function () {
	            // not loading frame by frame?
	            return this.adaptee.numFrames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "_currentframe", {
	        get: function () {
	            return this.adaptee.currentFrameIndex + 1;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "_totalframes", {
	        get: function () {
	            return this.adaptee.numFrames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "enabled", {
	        get: function () {
	            return this.adaptee.mouseEnabled;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2MovieClipAdapter.prototype.evalScript = function (str) {
	        var tag = document.createElement('script');
	        tag.text = 'var __framescript__ = function() {\n' + includeString + str + '\n}';
	        //add and remove script tag to dom to trigger compilation
	        var sibling = document.scripts[0];
	        sibling.parentNode.insertBefore(tag, sibling).parentNode.removeChild(tag);
	        var script = __framescript__;
	        window['__framescript__'] = null;
	        return script;
	    };
	    //attachAudio(id: AS2SoundAdapter):void {	}
	    //attachBitmap(bmp: BitmapImage2D, depth: Number, pixelSnapping: String = null, smoothing: boolean = false):void { }
	    AS2MovieClipAdapter.prototype.attachMovie = function (id, name, depth, initObject) {
	        if (initObject === void 0) { initObject = null; }
	        var attached_mc = AssetLibrary_1.AssetLibrary.getAsset(id);
	        var cloned_mc = attached_mc.clone();
	        var adapter = new AS2MovieClipAdapter(cloned_mc, this._view);
	        this.adaptee.addChildAtDepth(adapter.adaptee, depth);
	        adapter.adaptee.name = name;
	        this.registerScriptObject(adapter.adaptee);
	        return attached_mc;
	        // todo: apply object from initObject to attached_mc
	    };
	    //beginBitmapFill(bmp: BitmapImage2D, matrix: Matrix = null, repeat: boolean = false, smoothing: boolean = false):void {}
	    //beginFill(rgb: Number, alpha: number = 1.0):void {}
	    //beginGradientFill(fillType: string, colors: Array, alphas: Array, ratios: Array, matrix: Object, spreadMethod: string = null, interpolationMethod: string  = null, focalPointRatio: number  = null):void {}
	    //clear():void {}
	    AS2MovieClipAdapter.prototype.createEmptyMovieClip = function (name, depth) {
	        var mc = new MovieClip_1.MovieClip();
	        mc.adapter = new AS2MovieClipAdapter(mc, this._view);
	        mc.name = name;
	        this.adaptee.addChildAtDepth(mc, depth);
	        this.registerScriptObject(mc);
	        return mc.adapter;
	    };
	    //createTextField(instanceName: String, depth: Number, x: Number, y: Number, width: Number, height: Number):TextField {}
	    //curveTo(controlX: number, controlY: number, anchorX: number, anchorY: number):void {}
	    AS2MovieClipAdapter.prototype.duplicateMovieClip = function (name, depth, initObject) {
	        var duplicate = this.adaptee.clone().adapter;
	        duplicate.adaptee.name = name;
	        if (initObject)
	            for (var key in initObject)
	                if (duplicate.hasOwnProperty(key))
	                    duplicate[key] = initObject[key];
	        this.adaptee.parent.addChildAtDepth(duplicate.adaptee, depth);
	        return duplicate;
	    };
	    //endFill():void {}
	    //getBounds(bounds: Object):Object { return null; }
	    // not applicable?
	    AS2MovieClipAdapter.prototype.getBytesLoaded = function () { return 1; };
	    // not applicable?
	    AS2MovieClipAdapter.prototype.getBytesTotal = function () { return 1; };
	    AS2MovieClipAdapter.prototype.getInstanceAtDepth = function (depth) {
	        return this.adaptee.getChildAtDepth(depth);
	    };
	    AS2MovieClipAdapter.prototype.getNextHighestDepth = function () {
	        return this.adaptee.getNextHighestDepth();
	    };
	    //getRect(bounds: Object):Object { return null; }
	    //getSWFVersion():number { return 0; }
	    //getTextSnapshot():TextSnapshot {}
	    //getURL(url: string, window: string, method: string):void {}
	    AS2MovieClipAdapter.prototype.globalToLocal = function (pt) {
	        var newPoint = this.adaptee.globalToLocal(new Point_1.Point(pt.x, pt.y));
	        pt.x = newPoint.x;
	        pt.y = newPoint.y;
	    };
	    AS2MovieClipAdapter.prototype.gotoAndPlay = function (frame) {
	        if (frame == null)
	            return;
	        this.play();
	        this._gotoFrame(frame);
	    };
	    AS2MovieClipAdapter.prototype.gotoAndStop = function (frame) {
	        if (frame == null)
	            return;
	        this.stop();
	        this._gotoFrame(frame);
	    };
	    AS2MovieClipAdapter.prototype.play = function () {
	        this.adaptee.play();
	    };
	    AS2MovieClipAdapter.prototype.stop = function () {
	        this.adaptee.stop();
	    };
	    AS2MovieClipAdapter.prototype.hitTest = function (x, y, shapeFlag) {
	        if (shapeFlag === void 0) { shapeFlag = false; }
	        return this.adaptee.hitTestPoint(x, y, shapeFlag);
	    };
	    //lineGradientStyle(fillType: string, colors: array, alphas: array, ratios: array, matrix: Object, spreadMethod: string = null, interpolationMethod: string, focalPointRatio: number):void {}
	    //lineStyle(thickness: number, rgb: number, alpha: number, pixelHinting: boolean, noScale: string, capsStyle: string, jointStyle: string, miterLimit: number):void {}
	    //lineTo(x: number, y: number):void {}
	    //loadMovie(url: string, method: string = null):void {}
	    //loadVariables(url: string, method: string = null):void {}
	    AS2MovieClipAdapter.prototype.localToGlobal = function (pt) {
	        var newPoint = this.adaptee.localToGlobal(new Point_1.Point(pt.x, pt.y));
	        pt.x = newPoint.x;
	        pt.y = newPoint.y;
	    };
	    //moveTo(x: number, y: number):void {}
	    AS2MovieClipAdapter.prototype.nextFrame = function () {
	        ++this.adaptee.currentFrameIndex;
	    };
	    AS2MovieClipAdapter.prototype.prevFrame = function () {
	        --this.adaptee.currentFrameIndex;
	    };
	    //removeMovieClip():void {}
	    AS2MovieClipAdapter.prototype.setMask = function (mc) {
	        this.adaptee.masks = [mc];
	    };
	    //startDrag(lockCenter: boolean = false, left: number = 0, top: number = 0, right: number = 0, bottom: number = 0):void {}
	    //stopDrag():void {}
	    AS2MovieClipAdapter.prototype.swapDepths = function (target) {
	        var parent = this.adaptee.parent;
	        if (parent != null && target.parent == parent)
	            parent.swapChildren(this.adaptee, target);
	    };
	    //unloadMovie():void {}
	    AS2MovieClipAdapter.prototype.clone = function (newAdaptee) {
	        return new AS2MovieClipAdapter(newAdaptee, this._view);
	    };
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onEnterFrame", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onEnterFrame;
	        },
	        set: function (value) {
	            this._onEnterFrame = this._replaceEventListener(AssetEvent_1.AssetEvent.ENTER_FRAME, this._onEnterFrame, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRollOut", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onRollOut;
	        },
	        set: function (value) {
	            this._onRollOut = this._replaceEventListener(MouseEvent_1.MouseEvent.MOUSE_OUT, this._onRollOut, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRollOver", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onRollOver;
	        },
	        set: function (value) {
	            this._onRollOver = this._replaceEventListener(MouseEvent_1.MouseEvent.MOUSE_OVER, this._onRollOver, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRelease", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onRelease;
	        },
	        set: function (value) {
	            this._onRelease = this._replaceEventListener(MouseEvent_1.MouseEvent.MOUSE_UP, this._onRelease, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onPress", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onPress;
	        },
	        set: function (value) {
	            this._onPress = this._replaceEventListener(MouseEvent_1.MouseEvent.MOUSE_DOWN, this._onPress, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onMouseDown", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onMouseDown;
	        },
	        set: function (value) {
	            this._onMouseDown = this._replaceEventListener(MouseEvent_1.MouseEvent.MOUSE_DOWN, this._onMouseDown, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MovieClipAdapter.prototype, "onMouseUp", {
	        /**
	         *
	         */
	        get: function () {
	            return this._onMouseUp;
	        },
	        set: function (value) {
	            this._onMouseUp = this._replaceEventListener(MouseEvent_1.MouseEvent.MOUSE_UP, this._onMouseUp, value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2MovieClipAdapter.prototype.registerScriptObject = function (child) {
	        if (child.name)
	            this[child.name] = child.adapter ? child.adapter : child;
	    };
	    AS2MovieClipAdapter.prototype.unregisterScriptObject = function (child) {
	        delete this[child.name];
	        if (child.isAsset(MovieClip_1.MovieClip))
	            child.removeButtonListeners();
	    };
	    AS2MovieClipAdapter.prototype._gotoFrame = function (frame) {
	        var mc = this.adaptee;
	        if (typeof frame === "string")
	            mc.jumpToLabel(frame);
	        else
	            mc.currentFrameIndex = frame - 1;
	    };
	    AS2MovieClipAdapter.prototype._replaceEventListener = function (eventType, currentListener, newListener) {
	        var mc = this.adaptee;
	        if (currentListener)
	            mc.removeEventListener(eventType, currentListener);
	        if (newListener) {
	            var self = this;
	            var delegate = function () { return newListener.call(self); };
	            mc.addEventListener(eventType, delegate);
	        }
	        return delegate;
	    };
	    return AS2MovieClipAdapter;
	}(AS2SymbolAdapter_1.AS2SymbolAdapter));
	exports.AS2MovieClipAdapter = AS2MovieClipAdapter;


/***/ },
/* 344 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ColorTransform_1 = __webpack_require__(27);
	var HierarchicalProperties_1 = __webpack_require__(22);
	var FrameScriptManager_1 = __webpack_require__(29);
	// also contains global AS2 gunctions
	var AS2SymbolAdapter = (function () {
	    function AS2SymbolAdapter(adaptee, view) {
	        this.__quality = "high";
	        this._adaptee = adaptee;
	        this._view = view;
	        this._blockedByScript = false;
	        if (AS2SymbolAdapter.REFERENCE_TIME === -1)
	            AS2SymbolAdapter.REFERENCE_TIME = new Date().getTime();
	    }
	    AS2SymbolAdapter.prototype.isBlockedByScript = function () { return this._blockedByScript; };
	    AS2SymbolAdapter.prototype.isVisibilityByScript = function () { return this._visibilityByScript; };
	    AS2SymbolAdapter.prototype.freeFromScript = function () { this._blockedByScript = false; this._visibilityByScript = false; };
	    AS2SymbolAdapter.prototype.dispose = function () {
	        this._adaptee = null;
	        this._view = null;
	    };
	    AS2SymbolAdapter.prototype.getVersion = function () {
	        return 0;
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "adaptee", {
	        get: function () {
	            return this._adaptee;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_height", {
	        get: function () {
	            return this._adaptee.height;
	        },
	        set: function (value) {
	            this._adaptee.height = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_name", {
	        get: function () {
	            return this._adaptee.name;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_rotation", {
	        get: function () {
	            return this._adaptee.rotationZ;
	        },
	        set: function (value) {
	            this._adaptee.rotationZ = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_x", {
	        get: function () {
	            return this._adaptee.x;
	        },
	        set: function (value) {
	            this._adaptee.x = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_xmouse", {
	        get: function () {
	            return this._view.getLocalMouseX(this._adaptee);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_y", {
	        get: function () {
	            return this._adaptee.y;
	        },
	        set: function (value) {
	            this._adaptee.y = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_ymouse", {
	        get: function () {
	            return this._view.getLocalMouseY(this._adaptee);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_xscale", {
	        get: function () {
	            return this._adaptee.scaleX * 100;
	        },
	        set: function (value) {
	            this._adaptee.scaleX = value / 100;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_yscale", {
	        get: function () {
	            return this._adaptee.scaleY * 100;
	        },
	        set: function (value) {
	            this._adaptee.scaleY = value / 100;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_visible", {
	        get: function () {
	            return this._adaptee.visible;
	        },
	        set: function (value) {
	            this._adaptee.visible = value;
	            this._visibilityByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_width", {
	        get: function () {
	            return this._adaptee.width;
	        },
	        set: function (value) {
	            this._adaptee.width = value;
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_touchpoints", {
	        get: function () {
	            return this._view.getLocalTouchPoints(this._adaptee);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.getDepth = function () {
	        return this._adaptee.z;
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_quality", {
	        // just assure consistency for scripts, doesn't actually effect rendering.
	        get: function () {
	            return this.__quality;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "quality", {
	        set: function (value) {
	            this.__quality = value;
	            // this._blockedByScript=true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.trace = function (message) {
	        console.log(message);
	    };
	    // may need proper high-def timer mechanism
	    AS2SymbolAdapter.prototype.getTimer = function () {
	        return new Date().getTime() - AS2SymbolAdapter.REFERENCE_TIME;
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_alpha", {
	        get: function () {
	            return this.adaptee.transform.colorTransform ? (this.adaptee.transform.colorTransform.alphaMultiplier * 100) : 100;
	        },
	        set: function (value) {
	            if (!this.adaptee.transform.colorTransform)
	                this.adaptee.transform.colorTransform = new ColorTransform_1.ColorTransform();
	            this.adaptee.transform.colorTransform.alphaMultiplier = value / 100;
	            this.adaptee.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM);
	            this._blockedByScript = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_url", {
	        get: function () {
	            return document.URL;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_global", {
	        get: function () {
	            return null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_level0", {
	        get: function () {
	            return this._root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.clearInterval = function (handle) {
	        FrameScriptManager_1.FrameScriptManager.clearInterval(handle); //window.clearInterval(handle);
	        return;
	    };
	    AS2SymbolAdapter.prototype.setInterval = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        var scope;
	        var func;
	        if (typeof (args[0]) == "function") {
	            scope = this;
	            func = args[0];
	        }
	        else {
	            //remove scope variable from args
	            scope = args.shift();
	            //reformat function string to actual function variable in the scope
	            func = scope[args[0]];
	        }
	        //wrap function to maintain scope
	        args[0] = function () { func.apply(scope, arguments); };
	        return FrameScriptManager_1.FrameScriptManager.setInterval(args[0]); // window.setInterval.apply(window, args);
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_level10301", {
	        // temporary:
	        get: function () {
	            return this._root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_root", {
	        get: function () {
	            if (!this.__root) {
	                var p = this._parent;
	                // parents are always MovieClips
	                this.__root = p ? p._root : this;
	            }
	            return this.__root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.prototype.random = function (range) {
	        return Math.floor(Math.random() * range);
	    };
	    Object.defineProperty(AS2SymbolAdapter.prototype, "_parent", {
	        get: function () {
	            var parent = this.adaptee.parent;
	            return parent ? parent.adapter : null;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SymbolAdapter.REFERENCE_TIME = -1;
	    return AS2SymbolAdapter;
	}());
	exports.AS2SymbolAdapter = AS2SymbolAdapter;


/***/ },
/* 345 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var AssetBase_1 = __webpack_require__(6);
	var AS2MCSoundProps = (function (_super) {
	    __extends(AS2MCSoundProps, _super);
	    function AS2MCSoundProps() {
	        _super.call(this);
	        this._volume = 1;
	        this._pan = 1;
	        this._changeEvent = new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.INVALIDATE, this);
	    }
	    AS2MCSoundProps.prototype.dispose = function () {
	        this._audio = null;
	        this._changeEvent = null;
	    };
	    Object.defineProperty(AS2MCSoundProps.prototype, "volume", {
	        get: function () {
	            return this._volume;
	        },
	        set: function (value) {
	            if (this._volume != value) {
	                this._volume = value;
	                this.dispatchEvent(this._changeEvent);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MCSoundProps.prototype, "pan", {
	        get: function () {
	            return this._pan;
	        },
	        set: function (value) {
	            if (this._pan != value) {
	                this._pan = value;
	                this.dispatchEvent(this._changeEvent);
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2MCSoundProps.prototype, "audio", {
	        get: function () {
	            return this._audio;
	        },
	        set: function (value) {
	            if (this._audio)
	                this._audio.stop();
	            this._audio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return AS2MCSoundProps;
	}(AssetBase_1.AssetBase));
	exports.AS2MCSoundProps = AS2MCSoundProps;


/***/ },
/* 346 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var HierarchicalProperties_1 = __webpack_require__(22);
	var ColorTransform_1 = __webpack_require__(27);
	// also contains global AS2 functions
	var AS2ColorAdapter = (function () {
	    function AS2ColorAdapter(symbol) {
	        this._rgb = 0xffffff;
	        this._symbol = symbol;
	        this._symbol._blockedByScript = true;
	        this._target = symbol.adaptee.transform.colorTransform || (symbol.adaptee.transform.colorTransform = new ColorTransform_1.ColorTransform());
	        this._transform = { ra: 100, rb: 0, ga: 100, gb: 0, ba: 100, bb: 0, aa: 100, ab: 0 };
	    }
	    AS2ColorAdapter.prototype.getRGB = function () {
	        return this._rgb;
	    };
	    AS2ColorAdapter.prototype.setRGB = function (value) {
	        this._rgb = value;
	        var r = (value >> 16) & 0xff;
	        var g = (value >> 8) & 0xff;
	        var b = value & 0xff;
	        this.setTransform({ ra: r / 0xff * 100, ga: g / 0xff * 100, ba: b / 0xff * 100, aa: 100, rb: 0, gb: 0, bb: 0, ab: 0 });
	    };
	    AS2ColorAdapter.prototype.getTransform = function () {
	        return this._transform;
	    };
	    AS2ColorAdapter.prototype.setTransform = function (value) {
	        this._transform = value;
	        var ct = this._target;
	        ct.redMultiplier = value.ra === undefined ? 1 : value.ra / 100;
	        ct.greenMultiplier = value.ga === undefined ? 1 : value.ga / 100;
	        ct.blueMultiplier = value.ba === undefined ? 1 : value.ba / 100;
	        ct.alphaMultiplier = value.aa === undefined ? 1 : value.aa / 100;
	        ct.redOffset = value.rb || 0;
	        ct.greenOffset = value.gb || 0;
	        ct.blueOffset = value.bb || 0;
	        ct.alphaOffset = value.ab || 0;
	        this._symbol.adaptee.pInvalidateHierarchicalProperties(HierarchicalProperties_1.HierarchicalProperties.COLOR_TRANSFORM);
	    };
	    return AS2ColorAdapter;
	}());
	exports.AS2ColorAdapter = AS2ColorAdapter;


/***/ },
/* 347 */
/***/ function(module, exports) {

	"use strict";
	// also contains global AS2 functions
	var AS2SystemAdapter = (function () {
	    function AS2SystemAdapter() {
	    }
	    AS2SystemAdapter.security = null;
	    AS2SystemAdapter.capabilities = { version: 6 };
	    return AS2SystemAdapter;
	}());
	exports.AS2SystemAdapter = AS2SystemAdapter;


/***/ },
/* 348 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AssetEvent_1 = __webpack_require__(9);
	var AS2MCSoundProps_1 = __webpack_require__(345);
	var AssetLibrary_1 = __webpack_require__(211);
	var AudioManager_1 = __webpack_require__(302);
	// also contains global AS2 functions
	var AS2SoundAdapter = (function () {
	    // TODO: Any real Sound stuff should be externalized for AwayJS use. For now use internally since it's only 2D.
	    function AS2SoundAdapter(target) {
	        var _this = this;
	        this._loop = false;
	        this._name = "";
	        this._id = -1;
	        this._playing = false;
	        this._volume = 0; // uses this vol property on sound.
	        // not sure how to handle target yet
	        this._id = AS2SoundAdapter._soundIDCnt++;
	        this._target = target;
	        this._soundProps = (target != null && target.__pSoundProps) ? this._target.__pSoundProps : AS2SoundAdapter._globalSoundProps;
	        this._onGlobalChangeDelegate = function (event) { return _this.onGlobalChange(event); };
	        AS2SoundAdapter._globalSoundProps.addEventListener(AssetEvent_1.AssetEvent.INVALIDATE, this._onGlobalChangeDelegate);
	    }
	    AS2SoundAdapter.prototype.attachSound = function (id) {
	        this._name = id;
	        // TODO: This will be AudioAsset or something
	        var asset = AssetLibrary_1.AssetLibrary.getAsset(id);
	        if (asset)
	            this._soundProps.audio = asset.clone();
	        this.updateVolume();
	    };
	    /*getBytesLoaded():number
	    {
	        return 1;
	    }
	
	    getBytesTotal():number
	    {
	        return 1;
	    }*/
	    AS2SoundAdapter.prototype.getPan = function () {
	        return this._soundProps.pan;
	    };
	    AS2SoundAdapter.prototype.setPan = function (value) {
	        this._soundProps.pan = value;
	        // panning not supported at this point
	    };
	    /*getTransform():Object
	    {
	        return this._transform;
	    }
	
	    setTransform(value:Object):void
	    {
	        this._transform = value;
	    }*/
	    AS2SoundAdapter.prototype.getVolume = function () {
	        return this._soundProps.volume * 100;
	    };
	    AS2SoundAdapter.prototype.setVolume = function (value) {
	        this._soundProps.volume = value / 100;
	        this.updateVolume();
	    };
	    /*loadSound(url:string, isStreaming:boolean):void
	    {
	        this.disposeAudio();
	        // how to handle isStreaming == false? Manually?
	        this._soundProps.audio = new Audio();
	        this._soundProps.audio.src = url;
	        this.initAudio();
	    }*/
	    AS2SoundAdapter.prototype.start = function (offsetInSeconds, loops) {
	        if (offsetInSeconds === void 0) { offsetInSeconds = 0; }
	        if (loops === void 0) { loops = 0; }
	        this._playing = true;
	        this._loop = Boolean(loops > 0);
	        if (AudioManager_1.AudioManager.getExternalSoundInterface()) {
	            AudioManager_1.AudioManager.getExternalSoundInterface().startSound(this._name, this._id, this._volume, this._loop);
	            return;
	        }
	        if (this._soundProps.audio) {
	            this._soundProps.audio.play(offsetInSeconds, this._loop);
	            return;
	        }
	        console.log("Calling AS2SoundAdapter.start() was not successfull. Audio not set for this sound.");
	    };
	    AS2SoundAdapter.prototype.stop = function (linkageID) {
	        if (linkageID === void 0) { linkageID = null; }
	        if (!this._playing)
	            return;
	        this._playing = false;
	        if (AudioManager_1.AudioManager.getExternalSoundInterface()) {
	            AudioManager_1.AudioManager.getExternalSoundInterface().stopSound(this._id);
	            return;
	        }
	        else if (this._soundProps.audio) {
	            this._soundProps.audio.stop();
	            return;
	        }
	        console.log("Calling AS2SoundAdapter.stop() was not successfull. Audio not set for this sound.");
	    };
	    Object.defineProperty(AS2SoundAdapter.prototype, "position", {
	        get: function () {
	            if (this._soundProps.audio)
	                return this._soundProps.audio.currentTime;
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SoundAdapter.prototype, "duration", {
	        get: function () {
	            if (this._soundProps.audio)
	                return this._soundProps.audio.duration;
	            return 0;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2SoundAdapter.prototype, "id3", {
	        get: function () {
	            return {};
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AS2SoundAdapter.prototype.onGlobalChange = function (event) {
	        this.updateVolume();
	    };
	    AS2SoundAdapter.prototype.updateVolume = function () {
	        var vol = this._soundProps.volume * AS2SoundAdapter._globalSoundProps.volume;
	        if (vol > 1)
	            vol = 1;
	        if (vol < 0)
	            vol = 0;
	        vol = Math.round(vol * 100) / 100;
	        if (this._volume == vol)
	            return;
	        this._volume = vol;
	        if (AudioManager_1.AudioManager.getExternalSoundInterface()) {
	            if (this._playing)
	                AudioManager_1.AudioManager.getExternalSoundInterface().updateSound(this._id, this._volume, this._loop);
	        }
	        else if (this._soundProps.audio)
	            this._soundProps.audio.volume = this._volume;
	    };
	    AS2SoundAdapter._globalSoundProps = new AS2MCSoundProps_1.AS2MCSoundProps();
	    AS2SoundAdapter._soundIDCnt = 0;
	    return AS2SoundAdapter;
	}());
	exports.AS2SoundAdapter = AS2SoundAdapter;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AS2SoundAdapter;


/***/ },
/* 349 */
/***/ function(module, exports) {

	"use strict";
	var AS2KeyAdapter = (function () {
	    function AS2KeyAdapter() {
	    }
	    AS2KeyAdapter.addListener = function (listener) {
	        AS2KeyAdapter._listeners.push(listener);
	    };
	    AS2KeyAdapter.removeListener = function (listener) {
	        var listeners = AS2KeyAdapter._listeners;
	        var index = listeners.indexOf(listener);
	        if (index != -1)
	            listeners.splice(index, 1);
	    };
	    AS2KeyAdapter.isDown = function (code) {
	        return AS2KeyAdapter._keys[code];
	    };
	    AS2KeyAdapter.getCode = function () {
	        return AS2KeyAdapter._key;
	    };
	    AS2KeyAdapter.getAscii = function () {
	        return AS2KeyAdapter._char;
	    };
	    AS2KeyAdapter._onKeyDown = function (event) {
	        AS2KeyAdapter._key = event.keyCode;
	        AS2KeyAdapter._char = event.charCode;
	        AS2KeyAdapter._keys[event.keyCode] = true;
	        var len = AS2KeyAdapter._listeners.length;
	        for (var i = 0; i < len; i++)
	            if (AS2KeyAdapter._listeners[i].onKeyDown)
	                AS2KeyAdapter._listeners[i].onKeyDown();
	    };
	    AS2KeyAdapter._onKeyUp = function (event) {
	        AS2KeyAdapter._keys[event.keyCode] = false;
	        var len = AS2KeyAdapter._listeners.length;
	        for (var i = 0; i < len; i++)
	            if (AS2KeyAdapter._listeners[i].onKeyUp)
	                AS2KeyAdapter._listeners[i].onKeyUp();
	    };
	    AS2KeyAdapter._keys = new Array();
	    AS2KeyAdapter._listeners = new Array();
	    AS2KeyAdapter._addListeners = (function () {
	        if (typeof document !== "undefined") {
	            document.onkeydown = function (event) { return AS2KeyAdapter._onKeyDown(event); };
	            document.onkeyup = function (event) { return AS2KeyAdapter._onKeyUp(event); };
	        }
	    })();
	    /**
	     * Constant associated with the key code value for the Backspace key (8).
	     */
	    AS2KeyAdapter.BACKSPACE = 8;
	    /**
	     * Constant associated with the key code value for the Caps Lock key (20).
	     */
	    AS2KeyAdapter.CAPSLOCK = 20;
	    /**
	     * Constant associated with the key code value for the Control key (17).
	     */
	    AS2KeyAdapter.CONTROL = 17;
	    /**
	     * Constant associated with the key code value for the Delete key (46).
	     */
	    AS2KeyAdapter.DELETEKEY = 46;
	    /**
	     * Constant associated with the key code value for the Down Arrow key (40).
	     */
	    AS2KeyAdapter.DOWN = 40;
	    /**
	     * Constant associated with the key code value for the End key (35).
	     */
	    AS2KeyAdapter.END = 35;
	    /**
	     * Constant associated with the key code value for the Enter key (13).
	     */
	    AS2KeyAdapter.ENTER = 13;
	    /**
	     * Constant associated with the key code value for the Escape key (27).
	     */
	    AS2KeyAdapter.ESCAPE = 27;
	    /**
	     * Constant associated with the key code value for the Home key (36).
	     */
	    AS2KeyAdapter.HOME = 36;
	    /**
	     * Constant associated with the key code value for the Insert key (45).
	     */
	    AS2KeyAdapter.INSERT = 45;
	    /**
	     * Constant associated with the key code value for the Left Arrow key (37).
	     */
	    AS2KeyAdapter.LEFT = 37;
	    /**
	     * Constant associated with the key code value for the Page Down key (34).
	     */
	    AS2KeyAdapter.PGDN = 34;
	    /**
	     * Constant associated with the key code value for the Page Up key (33).
	     */
	    AS2KeyAdapter.PGUP = 33;
	    /**
	     * Constant associated with the key code value for the Right Arrow key (39).
	     */
	    AS2KeyAdapter.RIGHT = 39;
	    /**
	     * Constant associated with the key code value for the Shift key (16).
	     */
	    AS2KeyAdapter.SHIFT = 16;
	    /**
	     * Constant associated with the key code value for the Spacebar (32).
	     */
	    AS2KeyAdapter.SPACE = 32;
	    /**
	     * Constant associated with the key code value for the Tab key (9).
	     */
	    AS2KeyAdapter.TAB = 9;
	    /**
	     * Constant associated with the key code value for the Up Arrow key (38).
	     */
	    AS2KeyAdapter.UP = 38;
	    return AS2KeyAdapter;
	}());
	exports.AS2KeyAdapter = AS2KeyAdapter;


/***/ },
/* 350 */
/***/ function(module, exports) {

	"use strict";
	var AS2MouseAdapter = (function () {
	    function AS2MouseAdapter() {
	    }
	    // this does nothing really, just to catch usage in scripts
	    AS2MouseAdapter.addListener = function (listener) {
	        AS2MouseAdapter._globalListeners.push(listener);
	        // TODO: Init actual mouse events here, relative to root MovieClip (I suppose?)
	    };
	    AS2MouseAdapter._globalListeners = [];
	    return AS2MouseAdapter;
	}());
	exports.AS2MouseAdapter = AS2MouseAdapter;


/***/ },
/* 351 */
/***/ function(module, exports) {

	"use strict";
	var AS2StageAdapter = (function () {
	    function AS2StageAdapter() {
	    }
	    // this does nothing really, just to catch usage in scripts
	    AS2StageAdapter.showMenu = true;
	    return AS2StageAdapter;
	}());
	exports.AS2StageAdapter = AS2StageAdapter;


/***/ },
/* 352 */
/***/ function(module, exports) {

	"use strict";
	var AS2SharedObjectAdapter = (function () {
	    function AS2SharedObjectAdapter(name) {
	        this._object_name = name;
	        if (typeof (Storage) !== "undefined") {
	            this.data = JSON.parse(localStorage.getItem(name));
	        }
	        if (this.data == null) {
	            console.log("no shared object found");
	            this.data = {};
	        }
	    }
	    // should become a static
	    AS2SharedObjectAdapter.getLocal = function (name, localPath, secure) {
	        return new AS2SharedObjectAdapter(name);
	    };
	    // needs to stay as it is
	    AS2SharedObjectAdapter.prototype.flush = function () {
	        if (typeof (Storage) !== "undefined") {
	            localStorage.setItem(this._object_name, JSON.stringify(this.data));
	        }
	        else {
	            console.log("no local storage available");
	        }
	        // save all local data to wherever it needs to go
	    };
	    return AS2SharedObjectAdapter;
	}());
	exports.AS2SharedObjectAdapter = AS2SharedObjectAdapter;


/***/ },
/* 353 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AS2SymbolAdapter_1 = __webpack_require__(344);
	var TextField_1 = __webpack_require__(191);
	var AS2TextFieldAdapter = (function (_super) {
	    __extends(AS2TextFieldAdapter, _super);
	    function AS2TextFieldAdapter(adaptee, view) {
	        // create an empty text field if none is passed
	        _super.call(this, adaptee || new TextField_1.TextField(), view);
	    }
	    AS2TextFieldAdapter.prototype.clone = function (newAdaptee) {
	        return new AS2TextFieldAdapter(newAdaptee, this._view);
	    };
	    Object.defineProperty(AS2TextFieldAdapter.prototype, "textColor", {
	        get: function () {
	            return this.adaptee.textColor;
	        },
	        set: function (value) {
	            this.adaptee.textColor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2TextFieldAdapter.prototype, "embedFonts", {
	        get: function () {
	            return this._embedFonts;
	        },
	        set: function (value) {
	            this._embedFonts = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AS2TextFieldAdapter.prototype, "text", {
	        get: function () {
	            return this.adaptee.text;
	        },
	        set: function (value) {
	            this.adaptee.text = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return AS2TextFieldAdapter;
	}(AS2SymbolAdapter_1.AS2SymbolAdapter));
	exports.AS2TextFieldAdapter = AS2TextFieldAdapter;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = AS2TextFieldAdapter;


/***/ },
/* 354 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var TesselatedFontTable_1 = __webpack_require__(355);
	var BitmapFontTable_1 = __webpack_require__(193);
	/**
	 * Font is a container for FontTables.
	 *
	 *
	 *
	 */
	var Font = (function (_super) {
	    __extends(Font, _super);
	    //TODO test shader picking
	    //		public get shaderPickingDetails():boolean
	    //		{
	    //
	    //			return this.sourceEntity.shaderPickingDetails;
	    //		}
	    /**
	     * Creates a new TesselatedFont object
	     */
	    function Font() {
	        _super.call(this);
	        this._font_styles = [];
	    }
	    Object.defineProperty(Font.prototype, "font_styles", {
	        get: function () {
	            return this._font_styles;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Font.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return Font.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    Font.prototype.dispose = function () {
	    };
	    /**
	     *Get a font-table for a specific name, or create one if it does not exists.
	     */
	    Font.prototype.get_font_table = function (style_name, assetType, openTypeFont) {
	        if (assetType === void 0) { assetType = TesselatedFontTable_1.TesselatedFontTable.assetType; }
	        if (openTypeFont === void 0) { openTypeFont = null; }
	        var len = this._font_styles.length;
	        for (var i = 0; i < len; ++i) {
	            if ((this._font_styles[i].assetType == assetType) && (this._font_styles[i].name == style_name)) {
	                // mak
	                return this._font_styles[i];
	            }
	        }
	        var font_style = null;
	        if (assetType == TesselatedFontTable_1.TesselatedFontTable.assetType) {
	            font_style = new TesselatedFontTable_1.TesselatedFontTable(openTypeFont);
	        }
	        else if (assetType == BitmapFontTable_1.BitmapFontTable.assetType) {
	            font_style = new BitmapFontTable_1.BitmapFontTable();
	        }
	        font_style.name = style_name;
	        this._font_styles.push(font_style);
	        return font_style;
	    };
	    Font.assetType = "[asset Font]";
	    return Font;
	}(AssetBase_1.AssetBase));
	exports.Font = Font;


/***/ },
/* 355 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	var TesselatedFontChar_1 = __webpack_require__(356);
	var GraphicsPath_1 = __webpack_require__(180);
	var GraphicsFactoryStrokes_1 = __webpack_require__(189);
	var JointStyle_1 = __webpack_require__(185);
	var CapsStyle_1 = __webpack_require__(186);
	var DrawMode_1 = __webpack_require__(357);
	var GraphicsStrokeStyle_1 = __webpack_require__(184);
	var AttributesView_1 = __webpack_require__(4);
	/**
	 * GraphicBase wraps a TriangleElements as a scene graph instantiation. A GraphicBase is owned by a Sprite object.
	 *
	 *
	 * @see away.base.TriangleElements
	 * @see away.entities.Sprite
	 *
	 * @class away.base.GraphicBase
	 */
	var TesselatedFontTable = (function (_super) {
	    __extends(TesselatedFontTable, _super);
	    //TODO test shader picking
	    //		public get shaderPickingDetails():boolean
	    //		{
	    //
	    //			return this.sourceEntity.shaderPickingDetails;
	    //		}
	    /**
	     * Creates a new TesselatedFont object
	     * If a opentype_font object is passed, the chars will get tessellated whenever requested.
	     * If no opentype font object is passed, it is expected that tesselated chars
	     */
	    function TesselatedFontTable(opentype_font) {
	        if (opentype_font === void 0) { opentype_font = null; }
	        _super.call(this);
	        this._font_chars = [];
	        this._font_chars_dic = new Object();
	        this._current_size = 0;
	        this._size_multiply = 0;
	        this._ascent = 0;
	        this._descent = 0;
	        if (opentype_font) {
	            this._opentype_font = opentype_font;
	            /*
	             console.log("head.yMax "+head.yMax);
	             console.log("head.yMin "+head.yMin);
	             console.log("font.numGlyphs "+font.numGlyphs);
	             console.log('Ascender', font.tables.hhea.ascender);
	             console.log('Descender', font.tables.hhea.descender);
	             console.log('Typo Ascender', font.tables.os2.sTypoAscender);
	             console.log('Typo Descender', font.tables.os2.sTypoDescender);
	             */
	            //this._ascent=this._opentype_font.tables.hhea.ascender;
	            //this._descent=this._opentype_font.tables.hhea.descender;
	            this._font_em_size = 72;
	            this._current_size = 0;
	            this._size_multiply = 0;
	            return;
	        }
	    }
	    TesselatedFontTable.prototype.hasChar = function (char_code) {
	        return this._font_chars_dic[char_code] != null;
	    };
	    TesselatedFontTable.prototype.changeOpenTypeFont = function (newOpenTypeFont, tesselateAllOld) {
	        if (tesselateAllOld === void 0) { tesselateAllOld = true; }
	        if ((tesselateAllOld) && (this._opentype_font)) {
	        }
	        // todo: when updating a font we must take care that they are compatible in terms of em_size
	        this._opentype_font = newOpenTypeFont;
	    };
	    TesselatedFontTable.prototype.initFontSize = function (font_size) {
	        if (this._current_size == font_size)
	            return;
	        this._current_size = font_size;
	        this._size_multiply = font_size / this._font_em_size;
	    };
	    TesselatedFontTable.prototype.getCharVertCnt = function (char_code) {
	        var tesselated_font_char = this._font_chars_dic[char_code];
	        if (tesselated_font_char) {
	            return tesselated_font_char.fill_data.length;
	        }
	        return 0;
	    };
	    TesselatedFontTable.prototype.getCharWidth = function (char_code) {
	        var tesselated_font_char = this._font_chars_dic[char_code];
	        if (tesselated_font_char) {
	            return tesselated_font_char.char_width * this._size_multiply;
	        }
	        return 0;
	    };
	    TesselatedFontTable.prototype.getLineHeight = function () {
	        return 0;
	    };
	    Object.defineProperty(TesselatedFontTable.prototype, "assetType", {
	        get: function () {
	            return TesselatedFontTable.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    TesselatedFontTable.prototype.dispose = function () {
	    };
	    Object.defineProperty(TesselatedFontTable.prototype, "ascent", {
	        get: function () {
	            return this._ascent;
	        },
	        set: function (value) {
	            this._ascent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TesselatedFontTable.prototype, "descent", {
	        get: function () {
	            return this._descent;
	        },
	        set: function (value) {
	            this._descent = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TesselatedFontTable.prototype, "offset_x", {
	        get: function () {
	            return this._offset_x;
	        },
	        set: function (value) {
	            this._offset_x = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TesselatedFontTable.prototype, "offset_y", {
	        get: function () {
	            return this._offset_y;
	        },
	        set: function (value) {
	            this._offset_y = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TesselatedFontTable.prototype.get_font_chars = function () {
	        return this._font_chars;
	    };
	    TesselatedFontTable.prototype.get_font_em_size = function () {
	        return this._font_em_size;
	    };
	    TesselatedFontTable.prototype.set_whitespace_width = function (value) {
	        this._whitespace_width = value;
	    };
	    TesselatedFontTable.prototype.get_whitespace_width = function () {
	        return this._whitespace_width;
	    };
	    TesselatedFontTable.prototype.set_font_em_size = function (font_em_size) {
	        this._font_em_size = font_em_size;
	    };
	    /**
	     *
	     */
	    TesselatedFontTable.prototype.getChar = function (name) {
	        if (this._font_chars_dic[name] == null) {
	            if (this._opentype_font) {
	                //console.log("get char for '"+String.fromCharCode(parseInt(name))+"'. char does not exists yet. try creating it from opentype.");
	                var thisGlyph = this._opentype_font.charToGlyph(String.fromCharCode(parseInt(name)));
	                if (thisGlyph) {
	                    //console.log("got the glyph from opentype");
	                    if (true) {
	                        var thisPath = thisGlyph.getPath();
	                        var awayPath = new GraphicsPath_1.GraphicsPath();
	                        var i = 0;
	                        var len = thisPath.commands.length;
	                        //awayPath.lineTo(0, 0);
	                        //awayPath.moveTo(0,0);//-100);
	                        //awayPath.curveTo(100, 250, 200,0);
	                        //awayPath.lineTo(150, 100);
	                        //awayPath.moveTo(0,20);
	                        //awayPath.curveTo(100, 270, 200,20);
	                        //awayPath.moveTo(0,-20);
	                        //awayPath.moveTo(0,-10);
	                        //awayPath.curveTo(100, -110, 200,-10);
	                        var startx = 0;
	                        var starty = 0;
	                        for (i = 0; i < len; i++) {
	                            var cmd = thisPath.commands[i];
	                            if (cmd.type === 'M') {
	                                awayPath.moveTo(cmd.x, cmd.y);
	                                startx = cmd.x;
	                                starty = cmd.y;
	                            }
	                            else if (cmd.type === 'L') {
	                                awayPath.lineTo(cmd.x, cmd.y);
	                            }
	                            else if (cmd.type === 'Q') {
	                                awayPath.curveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
	                            }
	                            else if (cmd.type === 'C') {
	                                awayPath.cubicCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
	                            }
	                            else if (cmd.type === 'Z') {
	                                awayPath.lineTo(startx, starty);
	                            }
	                        }
	                        awayPath.style = new GraphicsStrokeStyle_1.GraphicsStrokeStyle(0xff0000, 1, 1, JointStyle_1.JointStyle.MITER, CapsStyle_1.CapsStyle.NONE, 100);
	                        var final_vert_list = [];
	                        GraphicsFactoryStrokes_1.GraphicsFactoryStrokes.draw_pathes([awayPath], final_vert_list);
	                        var attributesView = new AttributesView_1.AttributesView(Float32Array, 3);
	                        attributesView.set(final_vert_list);
	                        var attributesBuffer = attributesView.attributesBuffer;
	                        attributesView.dispose();
	                        var tesselated_font_char = new TesselatedFontChar_1.TesselatedFontChar(attributesBuffer, null);
	                        tesselated_font_char.char_width = (thisGlyph.advanceWidth * (1 / thisGlyph.path.unitsPerEm * 72));
	                        //console.log("tesselated_font_char.char_width "+tesselated_font_char.char_width);
	                        this._font_chars.push(tesselated_font_char);
	                        this._font_chars_dic[name] = tesselated_font_char;
	                    }
	                }
	            }
	        }
	        return this._font_chars_dic[name];
	    };
	    /**
	     *
	     */
	    TesselatedFontTable.prototype.setChar = function (name, char_width, fills_data, stroke_data) {
	        if (fills_data === void 0) { fills_data = null; }
	        if (stroke_data === void 0) { stroke_data = null; }
	        if ((fills_data == null) && (stroke_data == null))
	            throw ("TesselatedFontTable: trying to create a TesselatedFontChar with no data (fills_data and stroke_data is null)");
	        var tesselated_font_char = new TesselatedFontChar_1.TesselatedFontChar(fills_data, stroke_data);
	        tesselated_font_char.char_width = char_width;
	        this._font_chars.push(tesselated_font_char);
	        this._font_chars_dic[name] = tesselated_font_char;
	    };
	    TesselatedFontTable.prototype.buildTextRuns = function (textRuns, output_verts) {
	        if ((textRuns.length * 2) != (output_verts.length))
	            throw ("Invalid data passed to TesselatedFontTable.buildTextRuns(). output_verts.length is not double textRuns.length.");
	        var i = 0;
	        var font_size = 0;
	        var drawMode = 0;
	        var charCode = 0;
	        var xpos = 0;
	        var ypos = 0;
	        var runCnt = 0;
	        var runLen = 0;
	        var vertCnt = 0;
	        var len = textRuns.length;
	        var textrun;
	        var thisChar;
	        for (i = 0; i < len; i++) {
	            textrun = textRuns[i];
	            font_size = textrun[0];
	            drawMode = textrun[1];
	            ypos = textrun[2];
	            runLen = textrun.length;
	            for (runCnt = 3; runCnt < runLen; runCnt += 2) {
	                charCode = textrun[runCnt];
	                xpos = textrun[runCnt + 1];
	                thisChar = this.getChar(charCode.toString());
	                if ((drawMode == DrawMode_1.DrawMode.BOTH) || (drawMode == DrawMode_1.DrawMode.STROKE)) {
	                    if (output_verts[i * 2] == null) {
	                        throw ("Trying to render strokes for a textrun, but no output_vert list was set for this textrun strokes");
	                    }
	                }
	                if ((drawMode == DrawMode_1.DrawMode.BOTH) || (drawMode == DrawMode_1.DrawMode.FILL)) {
	                    if (output_verts[i * 2 + 1] == null) {
	                        throw ("Trying to render fills for a textrun, but no output_vert list was set for this textrun fills");
	                    }
	                }
	            }
	        }
	    };
	    TesselatedFontTable.assetType = "[asset TesselatedFontTable]";
	    return TesselatedFontTable;
	}(AssetBase_1.AssetBase));
	exports.TesselatedFontTable = TesselatedFontTable;


/***/ },
/* 356 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextFormat class represents character formatting information. Use the
	 * TextFormat class to create specific text formatting for text fields. You
	 * can apply text formatting to both static and dynamic text fields. The
	 * properties of the TextFormat class apply to device and embedded fonts.
	 * However, for embedded fonts, bold and italic text actually require specific
	 * fonts. If you want to display bold or italic text with an embedded font,
	 * you need to embed the bold and italic variations of that font.
	 *
	 * <p> You must use the constructor <code>new TextFormat()</code> to create a
	 * TextFormat object before setting its properties. When you apply a
	 * TextFormat object to a text field using the
	 * <code>TextField.defaultTextFormat</code> property or the
	 * <code>TextField.setTextFormat()</code> method, only its defined properties
	 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
	 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
	 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
	 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
	 * by default because if you don't provide values for the properties, Flash
	 * Player uses its own default formatting. The default formatting that Flash
	 * Player uses for each property(if property's value is <code>null</code>) is
	 * as follows:</p>
	 *
	 * <p>The default formatting for each property is also described in each
	 * property description.</p>
	 */
	var TesselatedFontChar = (function () {
	    function TesselatedFontChar(fill_data, stroke_data) {
	        if (fill_data === void 0) { fill_data = null; }
	        if (stroke_data === void 0) { stroke_data = null; }
	        /**
	         * the char_codes that this geom has kerning set for
	         */
	        this.kerningCharCodes = [];
	        /**
	         * the kerning values per char_code
	         */
	        this.kerningValues = [];
	        this.fill_data = fill_data;
	        this.stroke_data = stroke_data;
	    }
	    return TesselatedFontChar;
	}());
	exports.TesselatedFontChar = TesselatedFontChar;


/***/ },
/* 357 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * DrawMode is an enumeration of constant values that specify the
	 * DrawMode to use when drawing.
	 */
	var DrawMode = (function () {
	    function DrawMode() {
	    }
	    /**
	     * Used to specify to draw both strokes and fills
	     */
	    DrawMode.BOTH = 1;
	    /**
	     * Used to specify to draw strokes only
	     */
	    DrawMode.STROKE = 0;
	    /**
	     * Used to specify to draw fills only
	     */
	    DrawMode.FILL = 2;
	    return DrawMode;
	}());
	exports.DrawMode = DrawMode;


/***/ },
/* 358 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetBase_1 = __webpack_require__(6);
	/**
	 * The TextFormat class represents character formatting information. Use the
	 * TextFormat class to create specific text formatting for text fields. You
	 * can apply text formatting to both static and dynamic text fields. The
	 * properties of the TextFormat class apply to device and embedded fonts.
	 * However, for embedded fonts, bold and italic text actually require specific
	 * fonts. If you want to display bold or italic text with an embedded font,
	 * you need to embed the bold and italic variations of that font.
	 *
	 * <p> You must use the constructor <code>new TextFormat()</code> to create a
	 * TextFormat object before setting its properties. When you apply a
	 * TextFormat object to a text field using the
	 * <code>TextField.defaultTextFormat</code> property or the
	 * <code>TextField.setTextFormat()</code> method, only its defined properties
	 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
	 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
	 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
	 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
	 * by default because if you don't provide values for the properties, Flash
	 * Player uses its own default formatting. The default formatting that Flash
	 * Player uses for each property(if property's value is <code>null</code>) is
	 * as follows:</p>
	 *
	 * <p>The default formatting for each property is also described in each
	 * property description.</p>
	 */
	var TextFormat = (function (_super) {
	    __extends(TextFormat, _super);
	    /**
	     * Creates a TextFormat object with the specified properties. You can then
	     * change the properties of the TextFormat object to change the formatting of
	     * text fields.
	     *
	     * <p>Any parameter may be set to <code>null</code> to indicate that it is
	     * not defined. All of the parameters are optional; any omitted parameters
	     * are treated as <code>null</code>.</p>
	     *
	     * @param font        The name of a font for text as a string.
	     * @param size        An integer that indicates the size in pixels.
	     * @param color       The color of text using this text format. A number
	     *                    containing three 8-bit RGB components; for example,
	     *                    0xFF0000 is red, and 0x00FF00 is green.
	     * @param bold        A Boolean value that indicates whether the text is
	     *                    boldface.
	     * @param italic      A Boolean value that indicates whether the text is
	     *                    italicized.
	     * @param underline   A Boolean value that indicates whether the text is
	     *                    underlined.
	     * @param url         The URL to which the text in this text format
	     *                    hyperlinks. If <code>url</code> is an empty string, the
	     *                    text does not have a hyperlink.
	     * @param target      The target window where the hyperlink is displayed. If
	     *                    the target window is an empty string, the text is
	     *                    displayed in the default target window
	     *                    <code>_self</code>. If the <code>url</code> parameter
	     *                    is set to an empty string or to the value
	     *                    <code>null</code>, you can get or set this property,
	     *                    but the property will have no effect.
	     * @param align       The alignment of the paragraph, as a TextFormatAlign
	     *                    value.
	     * @param leftMargin  Indicates the left margin of the paragraph, in pixels.
	     * @param rightMargin Indicates the right margin of the paragraph, in pixels.
	     * @param indent      An integer that indicates the indentation from the left
	     *                    margin to the first character in the paragraph.
	     * @param leading     A number that indicates the amount of leading vertical
	     *                    space between lines.
	     */
	    function TextFormat(font, size, color, bold, italic, underline, url, link_target, align, leftMargin, rightMargin, indent, leading) {
	        if (font === void 0) { font = "Times New Roman"; }
	        if (size === void 0) { size = 12; }
	        if (color === void 0) { color = 0x000000; }
	        if (bold === void 0) { bold = false; }
	        if (italic === void 0) { italic = false; }
	        if (underline === void 0) { underline = false; }
	        if (url === void 0) { url = ""; }
	        if (link_target === void 0) { link_target = ""; }
	        if (align === void 0) { align = "left"; }
	        if (leftMargin === void 0) { leftMargin = 0; }
	        if (rightMargin === void 0) { rightMargin = 0; }
	        if (indent === void 0) { indent = 0; }
	        if (leading === void 0) { leading = 0; }
	        _super.call(this);
	        /**
	         * Specifies custom tab stops as an array of non-negative integers. Each tab
	         * stop is specified in pixels. If custom tab stops are not specified
	         * (<code>null</code>), the default tab stop is 4(average character width).
	         */
	        //todo: not used with in tesselated-font-table yet
	        this.tabStops = [];
	        this.font_name = font;
	        this.size = size;
	        this.bold = bold;
	        this.italic = italic;
	        this.underline = underline;
	        this.url = url;
	        this.link_target = link_target;
	        this.align = align;
	        this.leftMargin = leftMargin;
	        this.rightMargin = rightMargin;
	        this.indent = indent;
	        this.leading = leading;
	    }
	    Object.defineProperty(TextFormat.prototype, "assetType", {
	        /**
	         *
	         */
	        get: function () {
	            return TextFormat.assetType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    TextFormat.assetType = "[asset TextFormat]";
	    return TextFormat;
	}(AssetBase_1.AssetBase));
	exports.TextFormat = TextFormat;


/***/ },
/* 359 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AWD3Utils_1 = __webpack_require__(360);
	var AWDBlock = (function () {
	    function AWDBlock(this_id, this_type) {
	        this.type = this_type;
	        this.id = this_id;
	        this.state = AWD3Utils_1.AWD3Utils.BLOCKSTATE_FINALIZE;
	        this.dependencies_data = Array();
	        this.dependencies_urls = Array();
	        if (this_type == 83) {
	            this.loaded_dependencies = Array(6);
	        }
	        this.loaded_dependencies_cnt = 0;
	    }
	    AWDBlock.prototype.dispose = function () {
	        this.id = null;
	        this.bytes = null;
	        this.errorMessages = null;
	        this.uvsForVertexAnimation = null;
	    };
	    AWDBlock.prototype.addError = function (errorMsg) {
	        if (!this.errorMessages)
	            this.errorMessages = new Array();
	        this.errorMessages.push(errorMsg);
	    };
	    return AWDBlock;
	}());
	exports.AWDBlock = AWDBlock;


/***/ },
/* 360 */
/***/ function(module, exports) {

	"use strict";
	var AWD3Utils = (function () {
	    function AWD3Utils() {
	    }
	    AWD3Utils.BLOCKSTATE_FINALIZE = 0;
	    AWD3Utils.BLOCKSTATE_INVALID = 1;
	    AWD3Utils.BLOCKSTATE_LOAD_DEPENDENICES = 2;
	    AWD3Utils.BLOCKSTATE_NO_ASSET = 3;
	    AWD3Utils.COMPRESSIONMODE_LZMA = "lzma";
	    AWD3Utils.UNCOMPRESSED = 0;
	    AWD3Utils.DEFLATE = 1;
	    AWD3Utils.LZMA = 2;
	    AWD3Utils.INT8 = 1;
	    AWD3Utils.INT16 = 2;
	    AWD3Utils.INT32 = 3;
	    AWD3Utils.UINT8 = 4;
	    AWD3Utils.UINT16 = 5;
	    AWD3Utils.UINT32 = 6;
	    AWD3Utils.FLOAT32 = 7;
	    AWD3Utils.FLOAT64 = 8;
	    AWD3Utils.BOOL = 21;
	    AWD3Utils.COLOR = 22;
	    AWD3Utils.BADDR = 23;
	    AWD3Utils.AWDSTRING = 31;
	    AWD3Utils.AWDBYTEARRAY = 32;
	    AWD3Utils.VECTOR2x1 = 41;
	    AWD3Utils.VECTOR3x1 = 42;
	    AWD3Utils.VECTOR4x1 = 43;
	    AWD3Utils.MTX3x2 = 44;
	    AWD3Utils.MTX3x3 = 45;
	    AWD3Utils.MTX4x3 = 46;
	    AWD3Utils.MTX4x4 = 47;
	    return AWD3Utils;
	}());
	exports.AWD3Utils = AWD3Utils;


/***/ },
/* 361 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequest_1 = __webpack_require__(296);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var XmlUtils_1 = __webpack_require__(299);
	var BitmapFontTable_1 = __webpack_require__(193);
	var Font_1 = __webpack_require__(354);
	var MethodMaterial_1 = __webpack_require__(285);
	var Sampler2D_1 = __webpack_require__(121);
	/**
	 * TextureAtlasParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
	 * a loader object, it wraps it in a BitmapImage2DResource so resource management can happen consistently without
	 * exception cases.
	 */
	var FNTParser = (function (_super) {
	    __extends(FNTParser, _super);
	    /**
	     * Creates a new TextureAtlasParser object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function FNTParser() {
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT);
	        this._parseState = 0;
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    FNTParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "fnt";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    FNTParser.supportsData = function (data) {
	        try {
	            var content = ParserUtils_1.ParserUtils.toString(data);
	            if (content.indexOf("font") != -1 || content.indexOf("Font") != -1) {
	                //console.log("supportsData fnt");
	                return true;
	            }
	            return false;
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    FNTParser.prototype._iResolveDependency = function (resourceDependency) {
	        if (resourceDependency.assets.length) {
	            var mat = new MethodMaterial_1.MethodMaterial(resourceDependency.assets[0]);
	            mat.bothSides = true;
	            mat.alphaBlending = true;
	            mat.useColorTransform = true;
	            mat.style.sampler = new Sampler2D_1.Sampler2D(false, true, true);
	            this._bitmapFontTable.addMaterial(mat);
	            this._pFinalizeAsset(resourceDependency.assets[0]);
	            this._pFinalizeAsset(mat);
	            this._parseState = FNTParserState.PARSE_CHARS;
	        }
	        else {
	            this._parseState = FNTParserState.PARSE_COMPLETE;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    FNTParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        this._parseState = FNTParserState.PARSE_COMPLETE;
	    };
	    /**
	     * @inheritDoc
	     */
	    FNTParser.prototype._pProceedParsing = function () {
	        var nodes;
	        switch (this._parseState) {
	            case FNTParserState.PARSE_XML:
	                try {
	                    this._doc = XmlUtils_1.XmlUtils.getChildrenWithTag(XmlUtils_1.XmlUtils.strToXml(this._pGetTextData()), "font")[0];
	                    var page_node = XmlUtils_1.XmlUtils.getChildrenWithTag(this._doc, "pages")[0];
	                    var all_pages = XmlUtils_1.XmlUtils.getChildrenWithTag(page_node, "page");
	                    var len = all_pages.length;
	                    // todo: correctly support multiple pages
	                    for (var i = 0; i < len; i++) {
	                        this._imagePath = XmlUtils_1.XmlUtils.readAttributeValue(all_pages[i], "file");
	                    }
	                    var char_node = XmlUtils_1.XmlUtils.getChildrenWithTag(this._doc, "chars")[0];
	                    this._chars = XmlUtils_1.XmlUtils.getChildrenWithTag(char_node, "char");
	                    this._parseState = FNTParserState.PARSE_IMAGE;
	                    var info_node = XmlUtils_1.XmlUtils.getChildrenWithTag(this._doc, "info")[0];
	                    var common_node = XmlUtils_1.XmlUtils.getChildrenWithTag(this._doc, "common")[0];
	                    var font_name = XmlUtils_1.XmlUtils.readAttributeValue(info_node, "face");
	                    //this._font = <Font>AssetLibrary.getAsset(font_name);
	                    //if(this._font==undefined){
	                    this._font = new Font_1.Font();
	                    this._font.name = font_name;
	                    //}
	                    var bold = XmlUtils_1.XmlUtils.readAttributeValue(info_node, "bold");
	                    if (bold != "0")
	                        font_name += "_bold";
	                    var italic = XmlUtils_1.XmlUtils.readAttributeValue(info_node, "italic");
	                    if (italic != "0")
	                        font_name += "_italic";
	                    this._bitmapFontTable = this._font.get_font_table(font_name, BitmapFontTable_1.BitmapFontTable.assetType);
	                    var size = XmlUtils_1.XmlUtils.readAttributeValue(info_node, "size");
	                    this._bitmapFontTable._init_size = parseInt(size);
	                    var scaleH = XmlUtils_1.XmlUtils.readAttributeValue(common_node, "scaleH");
	                    this._bitmapFontTable.texture_height = parseInt(scaleH);
	                    var scaleW = XmlUtils_1.XmlUtils.readAttributeValue(common_node, "scaleW");
	                    this._bitmapFontTable.texture_width = parseInt(scaleW);
	                    var adjustSize = XmlUtils_1.XmlUtils.readAttributeValue(common_node, "adjustSize");
	                    if (adjustSize != "")
	                        this._bitmapFontTable._adjust_size = parseFloat(adjustSize);
	                }
	                catch (Error) {
	                    return ParserBase_1.ParserBase.PARSING_DONE;
	                }
	                break;
	            case FNTParserState.PARSE_IMAGE:
	                if (this._imagePath) {
	                    this._pAddDependency(this._imagePath, new URLRequest_1.URLRequest(this._imagePath));
	                    this._pPauseAndRetrieveDependencies();
	                }
	                else {
	                    return ParserBase_1.ParserBase.PARSING_DONE;
	                }
	                break;
	            case FNTParserState.PARSE_CHARS:
	                var element;
	                var x, y, width, height, xoff, yoff, xadv, page, chnl;
	                var id;
	                var len = this._chars.length;
	                for (var i = 0; i < len; i++) {
	                    element = this._chars[i];
	                    x = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "x"));
	                    y = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "y"));
	                    width = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "width"));
	                    height = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "height"));
	                    xoff = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "xoffset"));
	                    yoff = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "yoffset"));
	                    xadv = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "xadvance"));
	                    page = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "page"));
	                    chnl = parseInt(XmlUtils_1.XmlUtils.readAttributeValue(element, "chnl"));
	                    id = XmlUtils_1.XmlUtils.readAttributeValue(element, "id");
	                    this._bitmapFontTable.setChar(id, x, y, width, height, xoff, yoff, xadv, page, chnl);
	                }
	                this._pFinalizeAsset(this._font, this._font.name);
	                this._parseState = FNTParserState.PARSE_COMPLETE;
	                break;
	            case FNTParserState.PARSE_COMPLETE:
	                return ParserBase_1.ParserBase.PARSING_DONE;
	        }
	        return ParserBase_1.ParserBase.MORE_TO_PARSE;
	    };
	    return FNTParser;
	}(ParserBase_1.ParserBase));
	exports.FNTParser = FNTParser;
	var FNTParserState = (function () {
	    function FNTParserState() {
	    }
	    FNTParserState.PARSE_XML = 0;
	    FNTParserState.PARSE_IMAGE = 1;
	    FNTParserState.PARSE_CHARS = 2;
	    FNTParserState.PARSE_COMPLETE = 3;
	    return FNTParserState;
	}());


/***/ },
/* 362 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var BitmapImage2D_1 = __webpack_require__(95);
	var Matrix3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(34);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequest_1 = __webpack_require__(296);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var TriangleElements_1 = __webpack_require__(179);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var Sprite_1 = __webpack_require__(177);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var Single2DTexture_1 = __webpack_require__(136);
	var MethodMaterial_1 = __webpack_require__(285);
	var MethodMaterialMode_1 = __webpack_require__(284);
	/**
	 * Max3DSParser provides a parser for the 3ds data type.
	 */
	var Max3DSParser = (function (_super) {
	    __extends(Max3DSParser, _super);
	    /**
	     * Creates a new <code>Max3DSParser</code> object.
	     *
	     * @param useSmoothingGroups Determines whether the parser looks for smoothing groups in the 3ds file or assumes uniform smoothing. Defaults to true.
	     */
	    function Max3DSParser(useSmoothingGroups) {
	        if (useSmoothingGroups === void 0) { useSmoothingGroups = true; }
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.ARRAY_BUFFER);
	        this._useSmoothingGroups = useSmoothingGroups;
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    Max3DSParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "3ds";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    Max3DSParser.supportsData = function (data) {
	        var ba;
	        try {
	            //TODO!!!: crashes when trying to check against AudioData
	            ba = ParserUtils_1.ParserUtils.toByteArray(data);
	            if (ba) {
	                ba.position = 0;
	                if (ba.readShort() == 0x4d4d)
	                    return true;
	            }
	        }
	        catch (err) {
	            return false;
	        }
	        return false;
	    };
	    /**
	     * @inheritDoc
	     */
	    Max3DSParser.prototype._iResolveDependency = function (resourceDependency) {
	        if (resourceDependency.assets.length == 1) {
	            var asset;
	            asset = resourceDependency.assets[0];
	            if (asset.isAsset(BitmapImage2D_1.BitmapImage2D)) {
	                var tex;
	                tex = this._textures[resourceDependency.id];
	                tex.texture = new Single2DTexture_1.Single2DTexture(asset);
	            }
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    Max3DSParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        // TODO: Implement
	    };
	    /**
	     * @inheritDoc
	     */
	    Max3DSParser.prototype._pProceedParsing = function () {
	        if (!this._byteData) {
	            this._byteData = this._pGetByteData();
	            this._byteData.position = 0;
	            //----------------------------------------------------------------------------
	            // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
	            //----------------------------------------------------------------------------
	            //this._byteData.endian = Endian.LITTLE_ENDIAN;// Should be default
	            //----------------------------------------------------------------------------
	            this._textures = {};
	            this._materials = {};
	            this._unfinalized_objects = {};
	        }
	        // TODO: With this construct, the loop will run no-op for as long
	        // as there is time once file has finished reading. Consider a nice
	        // way to stop loop when byte array is empty, without putting it in
	        // the while-conditional, which will prevent finalizations from
	        // happening after the last chunk.
	        while (this._pHasTime()) {
	            // If we are currently working on an object, and the most recent chunk was
	            // the last one in that object, finalize the current object.
	            if (this._cur_mat && this._byteData.position >= this._cur_mat_end)
	                this.finalizeCurrentMaterial();
	            else if (this._cur_obj && this._byteData.position >= this._cur_obj_end) {
	                // Can't finalize at this point, because we have to wait until the full
	                // animation section has been parsed for any potential pivot definitions
	                this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
	                this._cur_obj_end = Number.MAX_VALUE /*uint*/;
	                this._cur_obj = null;
	            }
	            if (this._byteData.getBytesAvailable() > 0) {
	                var cid;
	                var len;
	                var end;
	                cid = this._byteData.readUnsignedShort();
	                len = this._byteData.readUnsignedInt();
	                end = this._byteData.position + (len - 6);
	                switch (cid) {
	                    case 0x4D4D: // MAIN3DS
	                    case 0x3D3D: // EDIT3DS
	                    case 0xB000:
	                        // This types are "container chunks" and contain only
	                        // sub-chunks (no data on their own.) This means that
	                        // there is nothing more to parse at this point, and
	                        // instead we should progress to the next chunk, which
	                        // will be the first sub-chunk of this one.
	                        continue;
	                    case 0xAFFF:
	                        this._cur_mat_end = end;
	                        this._cur_mat = this.parseMaterial();
	                        break;
	                    case 0x4000:
	                        this._cur_obj_end = end;
	                        this._cur_obj = new ObjectVO();
	                        this._cur_obj.name = this.readNulTermstring();
	                        this._cur_obj.materials = new Array();
	                        this._cur_obj.materialFaces = {};
	                        break;
	                    case 0x4100:
	                        this._cur_obj.type = Sprite_1.Sprite.assetType;
	                        break;
	                    case 0x4110:
	                        this.parseVertexList();
	                        break;
	                    case 0x4120:
	                        this.parseFaceList();
	                        break;
	                    case 0x4140:
	                        this.parseUVList();
	                        break;
	                    case 0x4130:
	                        this.parseFaceMaterialList();
	                        break;
	                    case 0x4160:
	                        this._cur_obj.transform = this.readTransform();
	                        break;
	                    case 0xB002:
	                        this.parseObjectAnimation(end);
	                        break;
	                    case 0x4150:
	                        this.parseSmoothingGroups();
	                        break;
	                    default:
	                        // Skip this (unknown) chunk
	                        this._byteData.position += (len - 6);
	                        break;
	                }
	                // Pause parsing if there were any dependencies found during this
	                // iteration (i.e. if there are any dependencies that need to be
	                // retrieved at this time.)
	                if (this.dependencies.length) {
	                    this._pPauseAndRetrieveDependencies();
	                    break;
	                }
	            }
	        }
	        // More parsing is required if the entire byte array has not yet
	        // been read, or if there is a currently non-finalized object in
	        // the pipeline.
	        if (this._byteData.getBytesAvailable() || this._cur_obj || this._cur_mat) {
	            return ParserBase_1.ParserBase.MORE_TO_PARSE;
	        }
	        else {
	            var name;
	            // Finalize any remaining objects before ending.
	            for (name in this._unfinalized_objects) {
	                var obj;
	                obj = this.constructObject(this._unfinalized_objects[name]);
	                if (obj) {
	                    //add to the content property
	                    this._pContent.addChild(obj);
	                    this._pFinalizeAsset(obj, name);
	                }
	            }
	            return ParserBase_1.ParserBase.PARSING_DONE;
	        }
	    };
	    Max3DSParser.prototype._pStartParsing = function (frameLimit) {
	        //create a content object for Loaders
	        this._pContent = new DisplayObjectContainer_1.DisplayObjectContainer();
	        _super.prototype._pStartParsing.call(this, frameLimit);
	    };
	    Max3DSParser.prototype.parseMaterial = function () {
	        var mat;
	        mat = new MaterialVO();
	        while (this._byteData.position < this._cur_mat_end) {
	            var cid;
	            var len;
	            var end;
	            cid = this._byteData.readUnsignedShort();
	            len = this._byteData.readUnsignedInt();
	            end = this._byteData.position + (len - 6);
	            switch (cid) {
	                case 0xA000:
	                    mat.name = this.readNulTermstring();
	                    break;
	                case 0xA010:
	                    mat.ambientColor = this.readColor();
	                    break;
	                case 0xA020:
	                    mat.diffuseColor = this.readColor();
	                    break;
	                case 0xA030:
	                    mat.specularColor = this.readColor();
	                    break;
	                case 0xA081:
	                    mat.twoSided = true;
	                    break;
	                case 0xA200:
	                    mat.colorMap = this.parseTexture(end);
	                    break;
	                case 0xA204:
	                    mat.specularMap = this.parseTexture(end);
	                    break;
	                default:
	                    this._byteData.position = end;
	                    break;
	            }
	        }
	        return mat;
	    };
	    Max3DSParser.prototype.parseTexture = function (end /*uint*/) {
	        var tex;
	        tex = new TextureVO();
	        while (this._byteData.position < end) {
	            var cid;
	            var len;
	            cid = this._byteData.readUnsignedShort();
	            len = this._byteData.readUnsignedInt();
	            switch (cid) {
	                case 0xA300:
	                    tex.url = this.readNulTermstring();
	                    break;
	                default:
	                    // Skip this unknown texture sub-chunk
	                    this._byteData.position += (len - 6);
	                    break;
	            }
	        }
	        this._textures[tex.url] = tex;
	        this._pAddDependency(tex.url, new URLRequest_1.URLRequest(tex.url));
	        return tex;
	    };
	    Max3DSParser.prototype.parseVertexList = function () {
	        var i;
	        var len;
	        var count;
	        count = this._byteData.readUnsignedShort();
	        this._cur_obj.verts = new Array(count * 3);
	        i = 0;
	        len = this._cur_obj.verts.length;
	        while (i < len) {
	            var x, y, z;
	            x = this._byteData.readFloat();
	            y = this._byteData.readFloat();
	            z = this._byteData.readFloat();
	            this._cur_obj.verts[i++] = x;
	            this._cur_obj.verts[i++] = z;
	            this._cur_obj.verts[i++] = y;
	        }
	    };
	    Max3DSParser.prototype.parseFaceList = function () {
	        var i;
	        var len;
	        var count;
	        count = this._byteData.readUnsignedShort();
	        this._cur_obj.indices = new Array(count * 3) /*uint*/;
	        i = 0;
	        len = this._cur_obj.indices.length;
	        while (i < len) {
	            var i0 /*uint*/, i1 /*uint*/, i2;
	            i0 = this._byteData.readUnsignedShort();
	            i1 = this._byteData.readUnsignedShort();
	            i2 = this._byteData.readUnsignedShort();
	            this._cur_obj.indices[i++] = i0;
	            this._cur_obj.indices[i++] = i2;
	            this._cur_obj.indices[i++] = i1;
	            // Skip "face info", irrelevant in Away3D
	            this._byteData.position += 2;
	        }
	        this._cur_obj.smoothingGroups = new Array(count) /*uint*/;
	    };
	    Max3DSParser.prototype.parseSmoothingGroups = function () {
	        var len = this._cur_obj.indices.length / 3;
	        var i = 0;
	        while (i < len) {
	            this._cur_obj.smoothingGroups[i] = this._byteData.readUnsignedInt();
	            i++;
	        }
	    };
	    Max3DSParser.prototype.parseUVList = function () {
	        var i;
	        var len;
	        var count;
	        count = this._byteData.readUnsignedShort();
	        this._cur_obj.uvs = new Array(count * 2);
	        i = 0;
	        len = this._cur_obj.uvs.length;
	        while (i < len) {
	            this._cur_obj.uvs[i++] = this._byteData.readFloat();
	            this._cur_obj.uvs[i++] = 1.0 - this._byteData.readFloat();
	        }
	    };
	    Max3DSParser.prototype.parseFaceMaterialList = function () {
	        var mat;
	        var count;
	        var i;
	        var faces;
	        mat = this.readNulTermstring();
	        count = this._byteData.readUnsignedShort();
	        faces = new Array(count) /*uint*/;
	        i = 0;
	        while (i < faces.length)
	            faces[i++] = this._byteData.readUnsignedShort();
	        this._cur_obj.materials.push(mat);
	        this._cur_obj.materialFaces[mat] = faces;
	    };
	    Max3DSParser.prototype.parseObjectAnimation = function (end) {
	        var vo;
	        var obj;
	        var pivot;
	        var name;
	        var hier;
	        // Pivot defaults to origin
	        pivot = new Vector3D_1.Vector3D;
	        while (this._byteData.position < end) {
	            var cid;
	            var len;
	            cid = this._byteData.readUnsignedShort();
	            len = this._byteData.readUnsignedInt();
	            switch (cid) {
	                case 0xb010:
	                    name = this.readNulTermstring();
	                    this._byteData.position += 4;
	                    hier = this._byteData.readShort();
	                    break;
	                case 0xb013:
	                    pivot.x = this._byteData.readFloat();
	                    pivot.z = this._byteData.readFloat();
	                    pivot.y = this._byteData.readFloat();
	                    break;
	                default:
	                    this._byteData.position += (len - 6);
	                    break;
	            }
	        }
	        // If name is "$$$DUMMY" this is an empty object (e.g. a container)
	        // and will be ignored in this version of the parser
	        // TODO: Implement containers in 3DS parser.
	        if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
	            vo = this._unfinalized_objects[name];
	            obj = this.constructObject(vo, pivot);
	            if (obj) {
	                //add to the content property
	                this._pContent.addChild(obj);
	                this._pFinalizeAsset(obj, vo.name);
	            }
	            delete this._unfinalized_objects[name];
	        }
	    };
	    Max3DSParser.prototype.constructObject = function (obj, pivot) {
	        if (pivot === void 0) { pivot = null; }
	        if (obj.type == Sprite_1.Sprite.assetType) {
	            var i;
	            var sub;
	            var graphics;
	            var mat;
	            var sprite;
	            var mtx;
	            var vertices;
	            var faces;
	            if (obj.materials.length > 1)
	                console.log("The Away3D 3DS parser does not support multiple materials per sprite at this point.");
	            // Ignore empty objects
	            if (!obj.indices || obj.indices.length == 0)
	                return null;
	            vertices = new Array(obj.verts.length / 3);
	            faces = new Array(obj.indices.length / 3);
	            this.prepareData(vertices, faces, obj);
	            if (this._useSmoothingGroups)
	                this.applySmoothGroups(vertices, faces);
	            obj.verts = new Array(vertices.length * 3);
	            for (i = 0; i < vertices.length; i++) {
	                obj.verts[i * 3] = vertices[i].x;
	                obj.verts[i * 3 + 1] = vertices[i].y;
	                obj.verts[i * 3 + 2] = vertices[i].z;
	            }
	            obj.indices = new Array(faces.length * 3) /*uint*/;
	            for (i = 0; i < faces.length; i++) {
	                obj.indices[i * 3] = faces[i].a;
	                obj.indices[i * 3 + 1] = faces[i].b;
	                obj.indices[i * 3 + 2] = faces[i].c;
	            }
	            if (obj.uvs) {
	                // If the object had UVs to start with, use UVs generated by
	                // smoothing group splitting algorithm. Otherwise those UVs
	                // will be nonsense and should be skipped.
	                obj.uvs = new Array(vertices.length * 2);
	                for (i = 0; i < vertices.length; i++) {
	                    obj.uvs[i * 2] = vertices[i].u;
	                    obj.uvs[i * 2 + 1] = vertices[i].v;
	                }
	            }
	            if (obj.materials.length > 0) {
	                var mname;
	                mname = obj.materials[0];
	                mat = this._materials[mname].material;
	            }
	            // Build sprite and return it
	            sprite = new Sprite_1.Sprite(mat);
	            sprite.transform.matrix3D = new Matrix3D_1.Matrix3D(obj.transform);
	            graphics = sprite.graphics;
	            // Construct elements (potentially splitting buffers)
	            // and add them to graphics.
	            sub = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	            sub.setIndices(obj.indices);
	            sub.setPositions(obj.verts);
	            sub.setUVs(obj.uvs);
	            graphics.addGraphic(sub);
	            // Apply pivot translation to graphics if a pivot was
	            // found while parsing the keyframe chunk earlier.
	            if (pivot) {
	                if (obj.transform) {
	                    // If a transform was found while parsing the
	                    // object chunk, use it to find the local pivot vector
	                    mtx = new Matrix3D_1.Matrix3D(obj.transform);
	                    mtx.rawData[12] = 0;
	                    mtx.rawData[13] = 0;
	                    mtx.rawData[14] = 0;
	                    pivot = mtx.transformVector(pivot);
	                }
	                pivot.scaleBy(-1);
	                mtx = new Matrix3D_1.Matrix3D();
	                mtx.appendTranslation(pivot.x, pivot.y, pivot.z);
	                graphics.applyTransformation(mtx);
	            }
	            // Apply transformation to graphics if a transformation
	            // was found while parsing the object chunk earlier.
	            if (obj.transform) {
	                mtx = new Matrix3D_1.Matrix3D(obj.transform);
	                mtx.invert();
	                graphics.applyTransformation(mtx);
	            }
	            // Final transform applied to graphics. Finalize the graphics,
	            // which will no longer be modified after this point.
	            this._pFinalizeAsset(graphics, obj.name.concat('_graphics'));
	            return sprite;
	        }
	        // If reached, unknown
	        return null;
	    };
	    Max3DSParser.prototype.prepareData = function (vertices, faces, obj) {
	        // convert raw ObjectVO's data to structured VertexVO and FaceVO
	        var i;
	        var j;
	        var k;
	        var len = obj.verts.length;
	        for (i = 0, j = 0, k = 0; i < len;) {
	            var v = new VertexVO;
	            v.x = obj.verts[i++];
	            v.y = obj.verts[i++];
	            v.z = obj.verts[i++];
	            if (obj.uvs) {
	                v.u = obj.uvs[j++];
	                v.v = obj.uvs[j++];
	            }
	            vertices[k++] = v;
	        }
	        len = obj.indices.length;
	        for (i = 0, k = 0; i < len;) {
	            var f = new FaceVO();
	            f.a = obj.indices[i++];
	            f.b = obj.indices[i++];
	            f.c = obj.indices[i++];
	            f.smoothGroup = obj.smoothingGroups[k] || 0;
	            faces[k++] = f;
	        }
	    };
	    Max3DSParser.prototype.applySmoothGroups = function (vertices, faces) {
	        // clone vertices according to following rule:
	        // clone if vertex's in faces from groups 1+2 and 3
	        // don't clone if vertex's in faces from groups 1+2, 3 and 1+3
	        var i;
	        var j;
	        var k;
	        var l;
	        var len;
	        var numVerts = vertices.length;
	        var numFaces = faces.length;
	        // extract groups data for vertices
	        var vGroups = new Array(numVerts);
	        for (i = 0; i < numVerts; i++)
	            vGroups[i] = new Array() /*uint*/;
	        for (i = 0; i < numFaces; i++) {
	            var face = faces[i];
	            for (j = 0; j < 3; j++) {
	                var groups = vGroups[(j == 0) ? face.a : ((j == 1) ? face.b : face.c)];
	                var group = face.smoothGroup;
	                for (k = groups.length - 1; k >= 0; k--) {
	                    if ((group & groups[k]) > 0) {
	                        group |= groups[k];
	                        groups.splice(k, 1);
	                        k = groups.length - 1;
	                    }
	                }
	                groups.push(group);
	            }
	        }
	        // clone vertices
	        var vClones = new Array(numVerts);
	        for (i = 0; i < numVerts; i++) {
	            if ((len = vGroups[i].length) < 1)
	                continue;
	            var clones = new Array(len);
	            vClones[i] = clones;
	            clones[0] = i;
	            var v0 = vertices[i];
	            for (j = 1; j < len; j++) {
	                var v1 = new VertexVO;
	                v1.x = v0.x;
	                v1.y = v0.y;
	                v1.z = v0.z;
	                v1.u = v0.u;
	                v1.v = v0.v;
	                clones[j] = vertices.length;
	                vertices.push(v1);
	            }
	        }
	        numVerts = vertices.length;
	        for (i = 0; i < numFaces; i++) {
	            face = faces[i];
	            group = face.smoothGroup;
	            for (j = 0; j < 3; j++) {
	                k = (j == 0) ? face.a : ((j == 1) ? face.b : face.c);
	                groups = vGroups[k];
	                len = groups.length;
	                clones = vClones[k];
	                for (l = 0; l < len; l++) {
	                    if (((group == 0) && (groups[l] == 0)) || ((group & groups[l]) > 0)) {
	                        var index = clones[l];
	                        if (group == 0) {
	                            // vertex is unique if no smoothGroup found
	                            groups.splice(l, 1);
	                            clones.splice(l, 1);
	                        }
	                        if (j == 0)
	                            face.a = index;
	                        else if (j == 1)
	                            face.b = index;
	                        else
	                            face.c = index;
	                        l = len;
	                    }
	                }
	            }
	        }
	    };
	    Max3DSParser.prototype.finalizeCurrentMaterial = function () {
	        var mat;
	        mat = new MethodMaterial_1.MethodMaterial(this._cur_mat.ambientColor);
	        if (this._cur_mat.colorMap)
	            mat.ambientMethod.texture = this._cur_mat.colorMap.texture || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultTexture();
	        mat.diffuseMethod.color = this._cur_mat.diffuseColor;
	        mat.specularMethod.color = this._cur_mat.specularColor;
	        if (this.materialMode >= 2)
	            mat.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	        mat.bothSides = this._cur_mat.twoSided;
	        this._pFinalizeAsset(mat, this._cur_mat.name);
	        this._materials[this._cur_mat.name] = this._cur_mat;
	        this._cur_mat.material = mat;
	        this._cur_mat = null;
	    };
	    Max3DSParser.prototype.readNulTermstring = function () {
	        var chr;
	        var str = "";
	        while ((chr = this._byteData.readUnsignedByte()) > 0)
	            str += String.fromCharCode(chr);
	        return str;
	    };
	    Max3DSParser.prototype.readTransform = function () {
	        var data = new Float32Array(16);
	        // X axis
	        data[0] = this._byteData.readFloat(); // X
	        data[2] = this._byteData.readFloat(); // Z
	        data[1] = this._byteData.readFloat(); // Y
	        data[3] = 0;
	        // Z axis
	        data[8] = this._byteData.readFloat(); // X
	        data[10] = this._byteData.readFloat(); // Z
	        data[9] = this._byteData.readFloat(); // Y
	        data[11] = 0;
	        // Y Axis
	        data[4] = this._byteData.readFloat(); // X
	        data[6] = this._byteData.readFloat(); // Z
	        data[5] = this._byteData.readFloat(); // Y
	        data[7] = 0;
	        // Translation
	        data[12] = this._byteData.readFloat(); // X
	        data[14] = this._byteData.readFloat(); // Z
	        data[13] = this._byteData.readFloat(); // Y
	        data[15] = 1;
	        return data;
	    };
	    Max3DSParser.prototype.readColor = function () {
	        var cid;
	        var len;
	        var r /*int*/, g /*int*/, b;
	        cid = this._byteData.readUnsignedShort();
	        len = this._byteData.readUnsignedInt();
	        switch (cid) {
	            case 0x0010:
	                r = this._byteData.readFloat() * 255;
	                g = this._byteData.readFloat() * 255;
	                b = this._byteData.readFloat() * 255;
	                break;
	            case 0x0011:
	                r = this._byteData.readUnsignedByte();
	                g = this._byteData.readUnsignedByte();
	                b = this._byteData.readUnsignedByte();
	                break;
	            default:
	                this._byteData.position += (len - 6);
	                break;
	        }
	        return (r << 16) | (g << 8) | b;
	    };
	    return Max3DSParser;
	}(ParserBase_1.ParserBase));
	exports.Max3DSParser = Max3DSParser;
	/**
	 *
	 */
	var FaceVO = (function () {
	    function FaceVO() {
	    }
	    return FaceVO;
	}());
	exports.FaceVO = FaceVO;
	/**
	 *
	 */
	var MaterialVO = (function () {
	    function MaterialVO() {
	    }
	    return MaterialVO;
	}());
	exports.MaterialVO = MaterialVO;
	/**
	 *
	 */
	var ObjectVO = (function () {
	    function ObjectVO() {
	    }
	    return ObjectVO;
	}());
	exports.ObjectVO = ObjectVO;
	/**
	 *
	 */
	var TextureVO = (function () {
	    function TextureVO() {
	    }
	    return TextureVO;
	}());
	exports.TextureVO = TextureVO;
	/**
	 *
	 */
	var VertexVO = (function () {
	    function VertexVO() {
	    }
	    return VertexVO;
	}());
	exports.VertexVO = VertexVO;


/***/ },
/* 363 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetLibrary_1 = __webpack_require__(211);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var Font_1 = __webpack_require__(354);
	var TesselatedFontTable_1 = __webpack_require__(355);
	var opentype;
	/**
	 * FontParser should parse Fonts into TesselatedFontTable for usage with webGL, or just load the Font as css class for usage with canvas and no webGL
	 */
	var FontParser = (function (_super) {
	    __extends(FontParser, _super);
	    /**
	     * Creates a new TextureAtlasParser object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function FontParser(useWebGL) {
	        if (useWebGL === void 0) { useWebGL = true; }
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.ARRAY_BUFFER);
	        this._useWebGL = false;
	        this._useWebGL = useWebGL;
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    FontParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        var supports = ((extension == "ttf") || (extension == "otf"));
	        if (supports) {
	            console.log("FontParse encountered file with supported extension: = " + extension);
	        }
	        return ((extension == "ttf") || (extension == "otf"));
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    FontParser.supportsData = function (data) {
	        console.log("ParserFont = " + ParserUtils_1.ParserUtils.toString(data, 20));
	        try {
	            /*
	            var content:string = ParserUtils.toString(data);
	            if(content.indexOf("font") != -1 || content.indexOf("Font") != -1){
	                console.log("supportsData fnt");
	                return true;
	
	            }
	            */
	            return true;
	        }
	        catch (e) {
	            return false;
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    FontParser.prototype._iResolveDependency = function (resourceDependency) {
	    };
	    /**
	     * @inheritDoc
	     */
	    FontParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	    };
	    FontParser.prototype.sortKeys = function (dict) {
	        var keys = [];
	        for (var key in dict) {
	            keys.push(key);
	        }
	        keys.sort();
	        return keys;
	    };
	    /**
	     * @inheritDoc
	     */
	    FontParser.prototype._pProceedParsing = function () {
	        //console.log("proceed parsing = "+this._iFileName);
	        opentype = window["opentype"];
	        if (opentype) {
	            //console.log("parsing font = "+this._iFileName+" / bytelength = "+this._pGetByteData().getBytesAvailable());
	            var font_name = "";
	            var font_style_name = "";
	            var font = opentype.parse(this.data);
	            var tablename, table, property, value, fontname;
	            var head = font.tables.head;
	            /*
	            */
	            for (tablename in font.tables) {
	                table = font.tables[tablename];
	                if (tablename == 'name') {
	                    var properties = this.sortKeys(table);
	                    for (var i = 0; i < properties.length; i++) {
	                        var property = properties[i];
	                        var translations = table[property];
	                        var langs = this.sortKeys(translations);
	                        for (var j = 0; j < langs.length; j++) {
	                            var lang = langs[j];
	                            if (property == "fontFamily") {
	                                font_name = translations[lang];
	                            }
	                            else if (property == "fontSubfamily") {
	                                font_style_name = translations[lang];
	                            }
	                            console.log("    " + property + ": " + lang + " : " + translations[lang]);
	                        }
	                    }
	                }
	            }
	            if (font_name == "") {
	                console.log("FontParser.ts '" + this._iFileName + "': Could not read fontname !!!");
	            }
	            if (font_style_name == "") {
	                console.log("FontParser.ts '" + this._iFileName + "': Could not read font_style_name !!!");
	            }
	            var new_font = AssetLibrary_1.AssetLibrary.getAsset(font_name);
	            var newfont = false;
	            if (new_font == undefined) {
	                new_font = new Font_1.Font();
	                newfont = true;
	            }
	            new_font.name = font_name;
	            var new_font_style = new_font.get_font_table(font_style_name, TesselatedFontTable_1.TesselatedFontTable.assetType, font);
	        }
	        if (document) {
	            var s = document.createElement('style');
	            s.type = "text/css";
	            document.getElementsByTagName('head')[0].appendChild(s);
	            s.style.cssText = "@font-face {\
						font-family: ''" + this._iFileName + "';\
						src: url('" + this._iFileName + "');\
						};";
	        }
	        this._pFinalizeAsset(new_font, new_font.name);
	        return ParserBase_1.ParserBase.PARSING_DONE;
	    };
	    return FontParser;
	}(ParserBase_1.ParserBase));
	exports.FontParser = FontParser;


/***/ },
/* 364 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequest_1 = __webpack_require__(296);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var Graphics_1 = __webpack_require__(178);
	var TriangleElements_1 = __webpack_require__(179);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var Sprite_1 = __webpack_require__(177);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var VertexClipNode_1 = __webpack_require__(340);
	var VertexAnimationSet_1 = __webpack_require__(317);
	var MethodMaterial_1 = __webpack_require__(285);
	var MethodMaterialMode_1 = __webpack_require__(284);
	/**
	 * MD2Parser provides a parser for the MD2 data type.
	 */
	var MD2Parser = (function (_super) {
	    __extends(MD2Parser, _super);
	    /**
	     * Creates a new MD2Parser object.
	     * @param textureType The extension of the texture (e.g. jpg/png/...)
	     * @param ignoreTexturePath If true, the path of the texture is ignored
	     */
	    function MD2Parser(textureType, ignoreTexturePath) {
	        if (textureType === void 0) { textureType = "jpg"; }
	        if (ignoreTexturePath === void 0) { ignoreTexturePath = true; }
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.ARRAY_BUFFER);
	        this._clipNodes = new Object();
	        // the current elements being built
	        this._animationSet = new VertexAnimationSet_1.VertexAnimationSet();
	        this.materialFinal = false;
	        this.graphicsCreated = false;
	        this._textureType = textureType;
	        this._ignoreTexturePath = ignoreTexturePath;
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    MD2Parser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "md2";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    MD2Parser.supportsData = function (data) {
	        return (ParserUtils_1.ParserUtils.toString(data, 4) == 'IDP2');
	    };
	    /**
	     * @inheritDoc
	     */
	    MD2Parser.prototype._iResolveDependency = function (resourceDependency) {
	        if (resourceDependency.assets.length != 1)
	            return;
	        var material = new MethodMaterial_1.MethodMaterial(resourceDependency.assets[0]);
	        if (this.materialMode >= 2)
	            material.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	        //add to the content property
	        this._pContent.addChild(this._sprite);
	        material.name = this._sprite.material.name;
	        this._sprite.material = material;
	        this._pFinalizeAsset(material);
	        this._pFinalizeAsset(this._sprite.graphics);
	        this._pFinalizeAsset(this._sprite);
	        this.materialFinal = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    MD2Parser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        // apply system default
	        if (this.materialMode < 2) {
	            this._sprite.material = DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial();
	        }
	        else {
	            this._sprite.material = new MethodMaterial_1.MethodMaterial(DefaultMaterialManager_1.DefaultMaterialManager.getDefaultImage2D());
	            this._sprite.material.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	        }
	        //add to the content property
	        this._pContent.addChild(this._sprite);
	        this._pFinalizeAsset(this._sprite.graphics);
	        this._pFinalizeAsset(this._sprite);
	        this.materialFinal = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    MD2Parser.prototype._pProceedParsing = function () {
	        if (!this._startedParsing) {
	            this._byteData = this._pGetByteData();
	            this._startedParsing = true;
	            // Reset bytearray read position (which may have been
	            // moved forward by the supportsData() function.)
	            this._byteData.position = 0;
	        }
	        while (this._pHasTime()) {
	            if (!this._parsedHeader) {
	                //----------------------------------------------------------------------------
	                // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
	                //----------------------------------------------------------------------------
	                //this._byteData.endian = Endian.LITTLE_ENDIAN;
	                // TODO: Create a sprite only when encountered (if it makes sense
	                // for this file format) and return it using this._pFinalizeAsset()
	                this._sprite = new Sprite_1.Sprite();
	                this._graphics = this._sprite.graphics;
	                if (this.materialMode < 2) {
	                    this._sprite.material = DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial();
	                }
	                else {
	                    this._sprite.material = new MethodMaterial_1.MethodMaterial(DefaultMaterialManager_1.DefaultMaterialManager.getDefaultImage2D());
	                    this._sprite.material.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	                }
	                //_graphics.animation = new VertexAnimation(2, VertexAnimationMode.ABSOLUTE);
	                //_animator = new VertexAnimator(VertexAnimationState(_sprite.animationState));
	                // Parse header and decompress body
	                this.parseHeader();
	                this.parseMaterialNames();
	            }
	            else if (!this._parsedUV) {
	                this.parseUV();
	            }
	            else if (!this._parsedFaces) {
	                this.parseFaces();
	            }
	            else if (!this._parsedFrames) {
	                this.parseFrames();
	            }
	            else if ((this.graphicsCreated) && (this.materialFinal)) {
	                return ParserBase_1.ParserBase.PARSING_DONE;
	            }
	            else if (!this.graphicsCreated) {
	                this.graphicsCreated = true;
	                //create default subgraphics
	                this._graphics.addGraphic(this._firstElements.clone());
	                // Force name to be chosen by this._pFinalizeAsset()
	                this._sprite.name = "";
	                if (this.materialFinal) {
	                    //add to the content property
	                    this._pContent.addChild(this._sprite);
	                    this._pFinalizeAsset(this._sprite.graphics);
	                    this._pFinalizeAsset(this._sprite);
	                }
	                this._pPauseAndRetrieveDependencies();
	            }
	        }
	        return ParserBase_1.ParserBase.MORE_TO_PARSE;
	    };
	    MD2Parser.prototype._pStartParsing = function (frameLimit) {
	        //create a content object for Loaders
	        this._pContent = new DisplayObjectContainer_1.DisplayObjectContainer();
	        _super.prototype._pStartParsing.call(this, frameLimit);
	    };
	    /**
	     * Reads in all that MD2 Header data that is declared as private variables.
	     * I know its a lot, and it looks ugly, but only way to do it in Flash
	     */
	    MD2Parser.prototype.parseHeader = function () {
	        this._ident = this._byteData.readInt();
	        this._version = this._byteData.readInt();
	        this._skinWidth = this._byteData.readInt();
	        this._skinHeight = this._byteData.readInt();
	        //skip this._frameSize
	        this._byteData.readInt();
	        this._numSkins = this._byteData.readInt();
	        this._numVertices = this._byteData.readInt();
	        this._numST = this._byteData.readInt();
	        this._numTris = this._byteData.readInt();
	        //skip this._numGlCmds
	        this._byteData.readInt();
	        this._numFrames = this._byteData.readInt();
	        this._offsetSkins = this._byteData.readInt();
	        this._offsetST = this._byteData.readInt();
	        this._offsetTris = this._byteData.readInt();
	        this._offsetFrames = this._byteData.readInt();
	        //skip this._offsetGlCmds
	        this._byteData.readInt();
	        this._offsetEnd = this._byteData.readInt();
	        this._parsedHeader = true;
	    };
	    /**
	     * Parses the file names for the materials.
	     */
	    MD2Parser.prototype.parseMaterialNames = function () {
	        var url;
	        var name;
	        var extIndex;
	        var slashIndex;
	        this._materialNames = new Array();
	        this._byteData.position = this._offsetSkins;
	        var regExp = new RegExp("[^a-zA-Z0-9\\_\/.]", "g");
	        for (var i = 0; i < this._numSkins; ++i) {
	            name = this._byteData.readUTFBytes(64);
	            name = name.replace(regExp, "");
	            extIndex = name.lastIndexOf(".");
	            if (this._ignoreTexturePath)
	                slashIndex = name.lastIndexOf("/");
	            if (name.toLowerCase().indexOf(".jpg") == -1 && name.toLowerCase().indexOf(".png") == -1) {
	                name = name.substring(slashIndex + 1, extIndex);
	                url = name + "." + this._textureType;
	            }
	            else {
	                url = name;
	            }
	            this._materialNames[i] = name;
	            // only support 1 skin TODO: really?
	            if (this.dependencies.length == 0)
	                this._pAddDependency(name, new URLRequest_1.URLRequest(url));
	        }
	        if (this._materialNames.length > 0)
	            this._sprite.material.name = this._materialNames[0];
	        else
	            this.materialFinal = true;
	    };
	    /**
	     * Parses the uv data for the sprite.
	     */
	    MD2Parser.prototype.parseUV = function () {
	        var j = 0;
	        this._uvs = new Array(this._numST * 2);
	        this._byteData.position = this._offsetST;
	        for (var i = 0; i < this._numST; i++) {
	            this._uvs[j++] = this._byteData.readShort() / this._skinWidth;
	            this._uvs[j++] = this._byteData.readShort() / this._skinHeight;
	        }
	        this._parsedUV = true;
	    };
	    /**
	     * Parses unique indices for the faces.
	     */
	    MD2Parser.prototype.parseFaces = function () {
	        var a /*uint*/, b /*uint*/, c /*uint*/, ta /*uint*/, tb /*uint*/, tc;
	        var i;
	        this._vertIndices = new Array();
	        this._uvIndices = new Array();
	        this._indices = new Array() /*uint*/;
	        this._byteData.position = this._offsetTris;
	        for (i = 0; i < this._numTris; i++) {
	            //collect vertex indices
	            a = this._byteData.readUnsignedShort();
	            b = this._byteData.readUnsignedShort();
	            c = this._byteData.readUnsignedShort();
	            //collect uv indices
	            ta = this._byteData.readUnsignedShort();
	            tb = this._byteData.readUnsignedShort();
	            tc = this._byteData.readUnsignedShort();
	            this.addIndex(a, ta);
	            this.addIndex(b, tb);
	            this.addIndex(c, tc);
	        }
	        var len = this._uvIndices.length;
	        this._finalUV = new Array(len * 2);
	        for (i = 0; i < len; ++i) {
	            this._finalUV[i << 1] = this._uvs[this._uvIndices[i] << 1];
	            this._finalUV[(i << 1) + 1] = this._uvs[(this._uvIndices[i] << 1) + 1];
	        }
	        this._parsedFaces = true;
	    };
	    /**
	     * Adds a face index to the list if it doesn't exist yet, based on vertexIndex and uvIndex, and adds the
	     * corresponding vertex and uv data in the correct location.
	     * @param vertexIndex The original index in the vertex list.
	     * @param uvIndex The original index in the uv list.
	     */
	    MD2Parser.prototype.addIndex = function (vertexIndex /*uint*/, uvIndex /*uint*/) {
	        var index = this.findIndex(vertexIndex, uvIndex);
	        if (index == -1) {
	            this._indices.push(this._vertIndices.length);
	            this._vertIndices.push(vertexIndex);
	            this._uvIndices.push(uvIndex);
	        }
	        else
	            this._indices.push(index);
	    };
	    /**
	     * Finds the final index corresponding to the original MD2's vertex and uv indices. Returns -1 if it wasn't added yet.
	     * @param vertexIndex The original index in the vertex list.
	     * @param uvIndex The original index in the uv list.
	     * @return The index of the final sprite corresponding to the original vertex and uv index. -1 if it doesn't exist yet.
	     */
	    MD2Parser.prototype.findIndex = function (vertexIndex /*uint*/, uvIndex /*uint*/) {
	        var len = this._vertIndices.length;
	        for (var i = 0; i < len; ++i) {
	            if (this._vertIndices[i] == vertexIndex && this._uvIndices[i] == uvIndex)
	                return i;
	        }
	        return -1;
	    };
	    /**
	     * Parses all the frame elements.
	     */
	    MD2Parser.prototype.parseFrames = function () {
	        var sx, sy, sz;
	        var tx, ty, tz;
	        var graphics;
	        var elements;
	        var vertLen = this._vertIndices.length;
	        var fvertices;
	        var tvertices;
	        var i /*uint*/, j /*int*/, k;
	        //var ch : number /*uint*/;
	        var name = "";
	        var prevClip = null;
	        this._byteData.position = this._offsetFrames;
	        for (i = 0; i < this._numFrames; i++) {
	            tvertices = new Array();
	            fvertices = new Array(vertLen * 3);
	            sx = this._byteData.readFloat();
	            sy = this._byteData.readFloat();
	            sz = this._byteData.readFloat();
	            tx = this._byteData.readFloat();
	            ty = this._byteData.readFloat();
	            tz = this._byteData.readFloat();
	            name = this.readFrameName();
	            // Note, the extra data.position++ in the for loop is there
	            // to skip over a byte that holds the "vertex normal index"
	            for (j = 0; j < this._numVertices; j++, this._byteData.position++)
	                tvertices.push(sx * this._byteData.readUnsignedByte() + tx, sy * this._byteData.readUnsignedByte() + ty, sz * this._byteData.readUnsignedByte() + tz);
	            k = 0;
	            for (j = 0; j < vertLen; j++) {
	                fvertices[k++] = tvertices[this._vertIndices[j] * 3];
	                fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 2];
	                fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 1];
	            }
	            elements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	            if (this._firstElements == null)
	                this._firstElements = elements;
	            graphics = new Graphics_1.Graphics();
	            graphics.addGraphic(elements);
	            elements.setIndices(this._indices);
	            elements.setPositions(fvertices);
	            elements.setUVs(this._finalUV);
	            // cause explicit updates
	            elements.setNormals(null);
	            elements.setTangents(null);
	            // turn auto updates off because they may be animated and set explicitly
	            elements.autoDeriveNormals = false;
	            elements.autoDeriveTangents = false;
	            var clip = this._clipNodes[name];
	            if (!clip) {
	                // If another sequence was parsed before this one, starting
	                // a new state means the previous one is complete and can
	                // hence be finalized.
	                if (prevClip) {
	                    this._pFinalizeAsset(prevClip);
	                    this._animationSet.addAnimation(prevClip);
	                }
	                clip = new VertexClipNode_1.VertexClipNode();
	                clip.name = name;
	                clip.stitchFinalFrame = true;
	                this._clipNodes[name] = clip;
	                prevClip = clip;
	            }
	            clip.addFrame(graphics, 1000 / MD2Parser.FPS);
	        }
	        // Finalize the last state
	        if (prevClip) {
	            this._pFinalizeAsset(prevClip);
	            this._animationSet.addAnimation(prevClip);
	        }
	        // Force this._pFinalizeAsset() to decide name
	        this._pFinalizeAsset(this._animationSet);
	        this._parsedFrames = true;
	    };
	    MD2Parser.prototype.readFrameName = function () {
	        var name = "";
	        var k = 0;
	        for (var j = 0; j < 16; j++) {
	            var ch = this._byteData.readUnsignedByte();
	            if (Math.floor(ch) > 0x39 && Math.floor(ch) <= 0x7A && k == 0)
	                name += String.fromCharCode(ch);
	            if (Math.floor(ch) >= 0x30 && Math.floor(ch) <= 0x39)
	                k++;
	        }
	        return name;
	    };
	    MD2Parser.FPS = 6;
	    return MD2Parser;
	}(ParserBase_1.ParserBase));
	exports.MD2Parser = MD2Parser;


/***/ },
/* 365 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Quaternion_1 = __webpack_require__(329);
	var Vector3D_1 = __webpack_require__(34);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var ParserBase_1 = __webpack_require__(289);
	var JointPose_1 = __webpack_require__(328);
	var SkeletonPose_1 = __webpack_require__(330);
	var SkeletonClipNode_1 = __webpack_require__(334);
	/**
	 * MD5AnimParser provides a parser for the md5anim data type, providing an animation sequence for the md5 format.
	 *
	 * todo: optimize
	 */
	var MD5AnimParser = (function (_super) {
	    __extends(MD5AnimParser, _super);
	    /**
	     * Creates a new MD5AnimParser object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function MD5AnimParser(additionalRotationAxis, additionalRotationRadians) {
	        if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
	        if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT);
	        this._parseIndex = 0;
	        this._line = 0;
	        this._charLineIndex = 0;
	        this._rotationQuat = new Quaternion_1.Quaternion();
	        var t1 = new Quaternion_1.Quaternion();
	        var t2 = new Quaternion_1.Quaternion();
	        t1.fromAxisAngle(Vector3D_1.Vector3D.X_AXIS, -Math.PI * .5);
	        t2.fromAxisAngle(Vector3D_1.Vector3D.Y_AXIS, -Math.PI * .5);
	        this._rotationQuat.multiply(t2, t1);
	        if (additionalRotationAxis) {
	            this._rotationQuat.multiply(t2, t1);
	            t1.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
	            this._rotationQuat.multiply(t1, this._rotationQuat);
	        }
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    MD5AnimParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "md5anim";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    MD5AnimParser.supportsData = function (data) {
	        return false;
	    };
	    /**
	     * @inheritDoc
	     */
	    MD5AnimParser.prototype._pProceedParsing = function () {
	        var token;
	        if (!this._startedParsing) {
	            this._textData = this._pGetTextData();
	            this._startedParsing = true;
	        }
	        while (this._pHasTime()) {
	            token = this.getNextToken();
	            switch (token) {
	                case MD5AnimParser.COMMENT_TOKEN:
	                    this.ignoreLine();
	                    break;
	                case "":
	                    // can occur at the end of a file
	                    break;
	                case MD5AnimParser.VERSION_TOKEN:
	                    this._version = this.getNextInt();
	                    if (this._version != 10)
	                        throw new Error("Unknown version number encountered!");
	                    break;
	                case MD5AnimParser.COMMAND_LINE_TOKEN:
	                    this.parseCMD();
	                    break;
	                case MD5AnimParser.NUM_FRAMES_TOKEN:
	                    this._numFrames = this.getNextInt();
	                    this._bounds = new Array();
	                    this._frameData = new Array();
	                    break;
	                case MD5AnimParser.NUM_JOINTS_TOKEN:
	                    this._numJoints = this.getNextInt();
	                    this._hierarchy = new Array(this._numJoints);
	                    this._baseFrameData = new Array(this._numJoints);
	                    break;
	                case MD5AnimParser.FRAME_RATE_TOKEN:
	                    this._frameRate = this.getNextInt();
	                    break;
	                case MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN:
	                    this._numAnimatedComponents = this.getNextInt();
	                    break;
	                case MD5AnimParser.HIERARCHY_TOKEN:
	                    this.parseHierarchy();
	                    break;
	                case MD5AnimParser.BOUNDS_TOKEN:
	                    this.parseBounds();
	                    break;
	                case MD5AnimParser.BASE_FRAME_TOKEN:
	                    this.parseBaseFrame();
	                    break;
	                case MD5AnimParser.FRAME_TOKEN:
	                    this.parseFrame();
	                    break;
	                default:
	                    if (!this._reachedEOF)
	                        this.sendUnknownKeywordError();
	            }
	            if (this._reachedEOF) {
	                this._clip = new SkeletonClipNode_1.SkeletonClipNode();
	                this.translateClip();
	                this._pFinalizeAsset(this._clip);
	                return ParserBase_1.ParserBase.PARSING_DONE;
	            }
	        }
	        return ParserBase_1.ParserBase.MORE_TO_PARSE;
	    };
	    /**
	     * Converts all key frame data to an SkinnedAnimationSequence.
	     */
	    MD5AnimParser.prototype.translateClip = function () {
	        for (var i = 0; i < this._numFrames; ++i)
	            this._clip.addFrame(this.translatePose(this._frameData[i]), 1000 / this._frameRate);
	    };
	    /**
	     * Converts a single key frame data to a SkeletonPose.
	     * @param frameData The actual frame data.
	     * @return A SkeletonPose containing the frame data's pose.
	     */
	    MD5AnimParser.prototype.translatePose = function (frameData) {
	        var hierarchy;
	        var pose;
	        var base;
	        var flags;
	        var j;
	        var translate = new Vector3D_1.Vector3D();
	        var orientation = new Quaternion_1.Quaternion();
	        var components = frameData.components;
	        var skelPose = new SkeletonPose_1.SkeletonPose();
	        var jointPoses = skelPose.jointPoses;
	        for (var i = 0; i < this._numJoints; ++i) {
	            j = 0;
	            pose = new JointPose_1.JointPose();
	            hierarchy = this._hierarchy[i];
	            base = this._baseFrameData[i];
	            flags = hierarchy.flags;
	            translate.x = base.position.x;
	            translate.y = base.position.y;
	            translate.z = base.position.z;
	            orientation.x = base.orientation.x;
	            orientation.y = base.orientation.y;
	            orientation.z = base.orientation.z;
	            if (flags & 1)
	                translate.x = components[hierarchy.startIndex + (j++)];
	            if (flags & 2)
	                translate.y = components[hierarchy.startIndex + (j++)];
	            if (flags & 4)
	                translate.z = components[hierarchy.startIndex + (j++)];
	            if (flags & 8)
	                orientation.x = components[hierarchy.startIndex + (j++)];
	            if (flags & 16)
	                orientation.y = components[hierarchy.startIndex + (j++)];
	            if (flags & 32)
	                orientation.z = components[hierarchy.startIndex + (j++)];
	            var w = 1 - orientation.x * orientation.x - orientation.y * orientation.y - orientation.z * orientation.z;
	            orientation.w = w < 0 ? 0 : -Math.sqrt(w);
	            if (hierarchy.parentIndex < 0) {
	                pose.orientation.multiply(this._rotationQuat, orientation);
	                pose.translation = this._rotationQuat.rotatePoint(translate);
	            }
	            else {
	                pose.orientation.copyFrom(orientation);
	                pose.translation.x = translate.x;
	                pose.translation.y = translate.y;
	                pose.translation.z = translate.z;
	            }
	            pose.orientation.y = -pose.orientation.y;
	            pose.orientation.z = -pose.orientation.z;
	            pose.translation.x = -pose.translation.x;
	            jointPoses[i] = pose;
	        }
	        return skelPose;
	    };
	    /**
	     * Parses the skeleton's hierarchy data.
	     */
	    MD5AnimParser.prototype.parseHierarchy = function () {
	        var ch;
	        var data;
	        var token = this.getNextToken();
	        var i = 0;
	        if (token != "{")
	            this.sendUnknownKeywordError();
	        do {
	            if (this._reachedEOF)
	                this.sendEOFError();
	            data = new HierarchyData();
	            data.name = this.parseLiteralstring();
	            data.parentIndex = this.getNextInt();
	            data.flags = this.getNextInt();
	            data.startIndex = this.getNextInt();
	            this._hierarchy[i++] = data;
	            ch = this.getNextChar();
	            if (ch == "/") {
	                this.putBack();
	                ch = this.getNextToken();
	                if (ch == MD5AnimParser.COMMENT_TOKEN)
	                    this.ignoreLine();
	                ch = this.getNextChar();
	            }
	            if (ch != "}")
	                this.putBack();
	        } while (ch != "}");
	    };
	    /**
	     * Parses frame bounds.
	     */
	    MD5AnimParser.prototype.parseBounds = function () {
	        var ch;
	        var data;
	        var token = this.getNextToken();
	        var i = 0;
	        if (token != "{")
	            this.sendUnknownKeywordError();
	        do {
	            if (this._reachedEOF)
	                this.sendEOFError();
	            data = new BoundsData();
	            data.min = this.parseVector3D();
	            data.max = this.parseVector3D();
	            this._bounds[i++] = data;
	            ch = this.getNextChar();
	            if (ch == "/") {
	                this.putBack();
	                ch = this.getNextToken();
	                if (ch == MD5AnimParser.COMMENT_TOKEN)
	                    this.ignoreLine();
	                ch = this.getNextChar();
	            }
	            if (ch != "}")
	                this.putBack();
	        } while (ch != "}");
	    };
	    /**
	     * Parses the base frame.
	     */
	    MD5AnimParser.prototype.parseBaseFrame = function () {
	        var ch;
	        var data;
	        var token = this.getNextToken();
	        var i = 0;
	        if (token != "{")
	            this.sendUnknownKeywordError();
	        do {
	            if (this._reachedEOF)
	                this.sendEOFError();
	            data = new BaseFrameData();
	            data.position = this.parseVector3D();
	            data.orientation = this.parseQuaternion();
	            this._baseFrameData[i++] = data;
	            ch = this.getNextChar();
	            if (ch == "/") {
	                this.putBack();
	                ch = this.getNextToken();
	                if (ch == MD5AnimParser.COMMENT_TOKEN)
	                    this.ignoreLine();
	                ch = this.getNextChar();
	            }
	            if (ch != "}")
	                this.putBack();
	        } while (ch != "}");
	    };
	    /**
	     * Parses a single frame.
	     */
	    MD5AnimParser.prototype.parseFrame = function () {
	        var ch;
	        var data;
	        var token;
	        var frameIndex;
	        frameIndex = this.getNextInt();
	        token = this.getNextToken();
	        if (token != "{")
	            this.sendUnknownKeywordError();
	        do {
	            if (this._reachedEOF)
	                this.sendEOFError();
	            data = new FrameData();
	            data.components = new Array(this._numAnimatedComponents);
	            for (var i = 0; i < this._numAnimatedComponents; ++i)
	                data.components[i] = this.getNextNumber();
	            this._frameData[frameIndex] = data;
	            ch = this.getNextChar();
	            if (ch == "/") {
	                this.putBack();
	                ch = this.getNextToken();
	                if (ch == MD5AnimParser.COMMENT_TOKEN)
	                    this.ignoreLine();
	                ch = this.getNextChar();
	            }
	            if (ch != "}")
	                this.putBack();
	        } while (ch != "}");
	    };
	    /**
	     * Puts back the last read character into the data stream.
	     */
	    MD5AnimParser.prototype.putBack = function () {
	        this._parseIndex--;
	        this._charLineIndex--;
	        this._reachedEOF = this._parseIndex >= this._textData.length;
	    };
	    /**
	     * Gets the next token in the data stream.
	     */
	    MD5AnimParser.prototype.getNextToken = function () {
	        var ch;
	        var token = "";
	        while (!this._reachedEOF) {
	            ch = this.getNextChar();
	            if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
	                if (token != MD5AnimParser.COMMENT_TOKEN)
	                    this.skipWhiteSpace();
	                if (token != "")
	                    return token;
	            }
	            else
	                token += ch;
	            if (token == MD5AnimParser.COMMENT_TOKEN)
	                return token;
	        }
	        return token;
	    };
	    /**
	     * Skips all whitespace in the data stream.
	     */
	    MD5AnimParser.prototype.skipWhiteSpace = function () {
	        var ch;
	        do
	            ch = this.getNextChar();
	        while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
	        this.putBack();
	    };
	    /**
	     * Skips to the next line.
	     */
	    MD5AnimParser.prototype.ignoreLine = function () {
	        var ch;
	        while (!this._reachedEOF && ch != "\n")
	            ch = this.getNextChar();
	    };
	    /**
	     * Retrieves the next single character in the data stream.
	     */
	    MD5AnimParser.prototype.getNextChar = function () {
	        var ch = this._textData.charAt(this._parseIndex++);
	        if (ch == "\n") {
	            ++this._line;
	            this._charLineIndex = 0;
	        }
	        else if (ch != "\r")
	            ++this._charLineIndex;
	        if (this._parseIndex == this._textData.length)
	            this._reachedEOF = true;
	        return ch;
	    };
	    /**
	     * Retrieves the next integer in the data stream.
	     */
	    MD5AnimParser.prototype.getNextInt = function () {
	        var i = parseInt(this.getNextToken());
	        if (isNaN(i))
	            this.sendParseError("int type");
	        return i;
	    };
	    /**
	     * Retrieves the next floating point number in the data stream.
	     */
	    MD5AnimParser.prototype.getNextNumber = function () {
	        var f = parseFloat(this.getNextToken());
	        if (isNaN(f))
	            this.sendParseError("float type");
	        return f;
	    };
	    /**
	     * Retrieves the next 3d vector in the data stream.
	     */
	    MD5AnimParser.prototype.parseVector3D = function () {
	        var vec = new Vector3D_1.Vector3D();
	        var ch = this.getNextToken();
	        if (ch != "(")
	            this.sendParseError("(");
	        vec.x = this.getNextNumber();
	        vec.y = this.getNextNumber();
	        vec.z = this.getNextNumber();
	        if (this.getNextToken() != ")")
	            this.sendParseError(")");
	        return vec;
	    };
	    /**
	     * Retrieves the next quaternion in the data stream.
	     */
	    MD5AnimParser.prototype.parseQuaternion = function () {
	        var quat = new Quaternion_1.Quaternion();
	        var ch = this.getNextToken();
	        if (ch != "(")
	            this.sendParseError("(");
	        quat.x = this.getNextNumber();
	        quat.y = this.getNextNumber();
	        quat.z = this.getNextNumber();
	        // quat supposed to be unit length
	        var t = 1 - (quat.x * quat.x) - (quat.y * quat.y) - (quat.z * quat.z);
	        quat.w = t < 0 ? 0 : -Math.sqrt(t);
	        if (this.getNextToken() != ")")
	            this.sendParseError(")");
	        return quat;
	    };
	    /**
	     * Parses the command line data.
	     */
	    MD5AnimParser.prototype.parseCMD = function () {
	        // just ignore the command line property
	        this.parseLiteralstring();
	    };
	    /**
	     * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
	     * by double quotes.
	     */
	    MD5AnimParser.prototype.parseLiteralstring = function () {
	        this.skipWhiteSpace();
	        var ch = this.getNextChar();
	        var str = "";
	        if (ch != "\"")
	            this.sendParseError("\"");
	        do {
	            if (this._reachedEOF)
	                this.sendEOFError();
	            ch = this.getNextChar();
	            if (ch != "\"")
	                str += ch;
	        } while (ch != "\"");
	        return str;
	    };
	    /**
	     * Throws an end-of-file error when a premature end of file was encountered.
	     */
	    MD5AnimParser.prototype.sendEOFError = function () {
	        throw new Error("Unexpected end of file");
	    };
	    /**
	     * Throws an error when an unexpected token was encountered.
	     * @param expected The token type that was actually expected.
	     */
	    MD5AnimParser.prototype.sendParseError = function (expected) {
	        throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
	    };
	    /**
	     * Throws an error when an unknown keyword was encountered.
	     */
	    MD5AnimParser.prototype.sendUnknownKeywordError = function () {
	        throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
	    };
	    MD5AnimParser.VERSION_TOKEN = "MD5Version";
	    MD5AnimParser.COMMAND_LINE_TOKEN = "commandline";
	    MD5AnimParser.NUM_FRAMES_TOKEN = "numFrames";
	    MD5AnimParser.NUM_JOINTS_TOKEN = "numJoints";
	    MD5AnimParser.FRAME_RATE_TOKEN = "frameRate";
	    MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN = "numAnimatedComponents";
	    MD5AnimParser.HIERARCHY_TOKEN = "hierarchy";
	    MD5AnimParser.BOUNDS_TOKEN = "bounds";
	    MD5AnimParser.BASE_FRAME_TOKEN = "baseframe";
	    MD5AnimParser.FRAME_TOKEN = "frame";
	    MD5AnimParser.COMMENT_TOKEN = "//";
	    return MD5AnimParser;
	}(ParserBase_1.ParserBase));
	exports.MD5AnimParser = MD5AnimParser;
	/**
	 *
	 */
	var BaseFrameData = (function () {
	    function BaseFrameData() {
	    }
	    return BaseFrameData;
	}());
	exports.BaseFrameData = BaseFrameData;
	/**
	 *
	 */
	var BoundsData = (function () {
	    function BoundsData() {
	    }
	    return BoundsData;
	}());
	exports.BoundsData = BoundsData;
	/**
	 *
	 */
	var FrameData = (function () {
	    function FrameData() {
	    }
	    return FrameData;
	}());
	exports.FrameData = FrameData;
	/**
	 *
	 */
	var HierarchyData = (function () {
	    function HierarchyData() {
	    }
	    return HierarchyData;
	}());
	exports.HierarchyData = HierarchyData;


/***/ },
/* 366 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var Quaternion_1 = __webpack_require__(329);
	var Vector3D_1 = __webpack_require__(34);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var ParserBase_1 = __webpack_require__(289);
	var TriangleElements_1 = __webpack_require__(179);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var Sprite_1 = __webpack_require__(177);
	var SkeletonAnimationSet_1 = __webpack_require__(326);
	var Skeleton_1 = __webpack_require__(332);
	var SkeletonJoint_1 = __webpack_require__(333);
	// todo: create animation system, parse skeleton
	/**
	 * MD5MeshParser provides a parser for the md5mesh data type, providing the graphics of the md5 format.
	 *
	 * todo: optimize
	 */
	var MD5MeshParser = (function (_super) {
	    __extends(MD5MeshParser, _super);
	    /**
	     * Creates a new MD5MeshParser object.
	     */
	    function MD5MeshParser(additionalRotationAxis, additionalRotationRadians) {
	        if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
	        if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT);
	        this._parseIndex = 0;
	        this._line = 0;
	        this._charLineIndex = 0;
	        this._rotationQuat = new Quaternion_1.Quaternion();
	        this._rotationQuat.fromAxisAngle(Vector3D_1.Vector3D.X_AXIS, -Math.PI * .5);
	        if (additionalRotationAxis) {
	            var quat = new Quaternion_1.Quaternion();
	            quat.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
	            this._rotationQuat.multiply(this._rotationQuat, quat);
	        }
	    }
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    MD5MeshParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "md5sprite";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    MD5MeshParser.supportsData = function (data) {
	        return false;
	    };
	    /**
	     * @inheritDoc
	     */
	    MD5MeshParser.prototype._pProceedParsing = function () {
	        var token;
	        if (!this._startedParsing) {
	            this._textData = this._pGetTextData();
	            this._startedParsing = true;
	        }
	        while (this._pHasTime()) {
	            token = this.getNextToken();
	            switch (token) {
	                case MD5MeshParser.COMMENT_TOKEN:
	                    this.ignoreLine();
	                    break;
	                case MD5MeshParser.VERSION_TOKEN:
	                    this._version = this.getNextInt();
	                    if (this._version != 10)
	                        throw new Error("Unknown version number encountered!");
	                    break;
	                case MD5MeshParser.COMMAND_LINE_TOKEN:
	                    this.parseCMD();
	                    break;
	                case MD5MeshParser.NUM_JOINTS_TOKEN:
	                    this._numJoints = this.getNextInt();
	                    this._bindPoses = new Array(this._numJoints);
	                    break;
	                case MD5MeshParser.NUM_MESHES_TOKEN:
	                    this._numMeshes = this.getNextInt();
	                    break;
	                case MD5MeshParser.JOINTS_TOKEN:
	                    this.parseJoints();
	                    break;
	                case MD5MeshParser.MESH_TOKEN:
	                    this.parseMesh();
	                    break;
	                default:
	                    if (!this._reachedEOF)
	                        this.sendUnknownKeywordError();
	            }
	            if (this._reachedEOF) {
	                this.calculateMaxJointCount();
	                this._animationSet = new SkeletonAnimationSet_1.SkeletonAnimationSet(this._maxJointCount);
	                this._sprite = new Sprite_1.Sprite();
	                this._graphics = this._sprite.graphics;
	                for (var i = 0; i < this._elementsData.length; ++i)
	                    this._graphics.addGraphic(this.translateElements(this._elementsData[i].positionData, this._elementsData[i].weightData, this._elementsData[i].indices));
	                //_graphics.animation = _animation;
	                //					_sprite.animationController = _animationController;
	                //add to the content property
	                this._pContent.addChild(this._sprite);
	                this._pFinalizeAsset(this._graphics);
	                this._pFinalizeAsset(this._sprite);
	                this._pFinalizeAsset(this._skeleton);
	                this._pFinalizeAsset(this._animationSet);
	                return ParserBase_1.ParserBase.PARSING_DONE;
	            }
	        }
	        return ParserBase_1.ParserBase.MORE_TO_PARSE;
	    };
	    MD5MeshParser.prototype._pStartParsing = function (frameLimit) {
	        //create a content object for Loaders
	        this._pContent = new DisplayObjectContainer_1.DisplayObjectContainer();
	        _super.prototype._pStartParsing.call(this, frameLimit);
	    };
	    MD5MeshParser.prototype.calculateMaxJointCount = function () {
	        this._maxJointCount = 0;
	        var numElementsData = this._elementsData.length;
	        for (var i = 0; i < numElementsData; ++i) {
	            var elementsData = this._elementsData[i];
	            var positionData = elementsData.positionData;
	            var numVerts = positionData.length;
	            for (var j = 0; j < numVerts; ++j) {
	                var zeroWeights = this.countZeroWeightJoints(positionData[j], elementsData.weightData);
	                var totalJoints = positionData[j].countWeight - zeroWeights;
	                if (totalJoints > this._maxJointCount)
	                    this._maxJointCount = totalJoints;
	            }
	        }
	    };
	    MD5MeshParser.prototype.countZeroWeightJoints = function (position, weights) {
	        var start = position.startWeight;
	        var end = position.startWeight + position.countWeight;
	        var count = 0;
	        var weight;
	        for (var i = start; i < end; ++i) {
	            weight = weights[i].bias;
	            if (weight == 0)
	                ++count;
	        }
	        return count;
	    };
	    /**
	     * Parses the skeleton's joints.
	     */
	    MD5MeshParser.prototype.parseJoints = function () {
	        var ch;
	        var joint;
	        var pos;
	        var quat;
	        var i = 0;
	        var token = this.getNextToken();
	        if (token != "{")
	            this.sendUnknownKeywordError();
	        this._skeleton = new Skeleton_1.Skeleton();
	        do {
	            if (this._reachedEOF)
	                this.sendEOFError();
	            joint = new SkeletonJoint_1.SkeletonJoint();
	            joint.name = this.parseLiteralstring();
	            joint.parentIndex = this.getNextInt();
	            pos = this.parseVector3D();
	            pos = this._rotationQuat.rotatePoint(pos);
	            quat = this.parseQuaternion();
	            // todo: check if this is correct, or maybe we want to actually store it as quats?
	            this._bindPoses[i] = quat.toMatrix3D();
	            this._bindPoses[i].appendTranslation(pos.x, pos.y, pos.z);
	            var inv = this._bindPoses[i].clone();
	            inv.invert();
	            joint.inverseBindPose = inv.rawData;
	            this._skeleton.joints[i++] = joint;
	            ch = this.getNextChar();
	            if (ch == "/") {
	                this.putBack();
	                ch = this.getNextToken();
	                if (ch == MD5MeshParser.COMMENT_TOKEN)
	                    this.ignoreLine();
	                ch = this.getNextChar();
	            }
	            if (ch != "}")
	                this.putBack();
	        } while (ch != "}");
	    };
	    /**
	     * Puts back the last read character into the data stream.
	     */
	    MD5MeshParser.prototype.putBack = function () {
	        this._parseIndex--;
	        this._charLineIndex--;
	        this._reachedEOF = this._parseIndex >= this._textData.length;
	    };
	    /**
	     * Parses the mesh graphics.
	     */
	    MD5MeshParser.prototype.parseMesh = function () {
	        var token = this.getNextToken();
	        var ch;
	        var positionData;
	        var weights;
	        var indices;
	        if (token != "{")
	            this.sendUnknownKeywordError();
	        if (this._shaders == null)
	            this._shaders = new Array();
	        while (ch != "}") {
	            ch = this.getNextToken();
	            switch (ch) {
	                case MD5MeshParser.COMMENT_TOKEN:
	                    this.ignoreLine();
	                    break;
	                case MD5MeshParser.MESH_SHADER_TOKEN:
	                    this._shaders.push(this.parseLiteralstring());
	                    break;
	                case MD5MeshParser.MESH_NUM_VERTS_TOKEN:
	                    positionData = new Array(this.getNextInt());
	                    break;
	                case MD5MeshParser.MESH_NUM_TRIS_TOKEN:
	                    indices = new Array(this.getNextInt() * 3) /*uint*/;
	                    break;
	                case MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN:
	                    weights = new Array(this.getNextInt());
	                    break;
	                case MD5MeshParser.MESH_VERT_TOKEN:
	                    this.parseVertex(positionData);
	                    break;
	                case MD5MeshParser.MESH_TRI_TOKEN:
	                    this.parseTri(indices);
	                    break;
	                case MD5MeshParser.MESH_WEIGHT_TOKEN:
	                    this.parseJoint(weights);
	                    break;
	            }
	        }
	        if (this._elementsData == null)
	            this._elementsData = new Array();
	        var i = this._elementsData.length;
	        this._elementsData[i] = new ElementsData();
	        this._elementsData[i].positionData = positionData;
	        this._elementsData[i].weightData = weights;
	        this._elementsData[i].indices = indices;
	    };
	    /**
	     * Converts the sprite data to a SkinnedSub instance.
	     * @param positionData The sprite's positions.
	     * @param weights The joint weights per position.
	     * @param indices The indices for the faces.
	     * @return A TriangleElements instance containing all elements data for the current sprite.
	     */
	    MD5MeshParser.prototype.translateElements = function (positionData, weights, indices /*uint*/) {
	        var len = positionData.length;
	        var v1 /*int*/, v2 /*int*/, v3;
	        var position;
	        var weight;
	        var bindPose;
	        var pos;
	        var elements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	        var uvs = new Array(len * 2);
	        var positions = new Array(len * 3);
	        var jointIndices = new Array(len * this._maxJointCount);
	        var jointWeights = new Array(len * this._maxJointCount);
	        var l = 0;
	        var nonZeroWeights;
	        for (var i = 0; i < len; ++i) {
	            position = positionData[i];
	            v1 = position.index * 3;
	            v2 = v1 + 1;
	            v3 = v1 + 2;
	            positions[v1] = positions[v2] = positions[v3] = 0;
	            nonZeroWeights = 0;
	            for (var j = 0; j < position.countWeight; ++j) {
	                weight = weights[position.startWeight + j];
	                if (weight.bias > 0) {
	                    bindPose = this._bindPoses[weight.joint];
	                    pos = bindPose.transformVector(weight.pos);
	                    positions[v1] += pos.x * weight.bias;
	                    positions[v2] += pos.y * weight.bias;
	                    positions[v3] += pos.z * weight.bias;
	                    // indices need to be multiplied by 3 (amount of matrix registers)
	                    jointIndices[l] = weight.joint * 3;
	                    jointWeights[l++] = weight.bias;
	                    ++nonZeroWeights;
	                }
	            }
	            for (j = nonZeroWeights; j < this._maxJointCount; ++j) {
	                jointIndices[l] = 0;
	                jointWeights[l++] = 0;
	            }
	            v1 = position.index << 1;
	            uvs[v1++] = position.s;
	            uvs[v1] = position.t;
	        }
	        elements.jointsPerVertex = this._maxJointCount;
	        elements.setIndices(indices);
	        elements.setPositions(positions);
	        elements.setUVs(uvs);
	        elements.setJointIndices(jointIndices);
	        elements.setJointWeights(jointWeights);
	        // cause explicit updates
	        elements.setNormals(null);
	        elements.setTangents(null);
	        // turn auto updates off because they may be animated and set explicitly
	        elements.autoDeriveTangents = false;
	        elements.autoDeriveNormals = false;
	        return elements;
	    };
	    /**
	     * Retrieve the next triplet of position indices that form a face.
	     * @param indices The index list in which to store the read data.
	     */
	    MD5MeshParser.prototype.parseTri = function (indices /*uint*/) {
	        var index = this.getNextInt() * 3;
	        indices[index] = this.getNextInt();
	        indices[index + 1] = this.getNextInt();
	        indices[index + 2] = this.getNextInt();
	    };
	    /**
	     * Reads a new joint data set for a single joint.
	     * @param weights the target list to contain the weight data.
	     */
	    MD5MeshParser.prototype.parseJoint = function (weights) {
	        var weight = new JointData();
	        weight.index = this.getNextInt();
	        weight.joint = this.getNextInt();
	        weight.bias = this.getNextNumber();
	        weight.pos = this.parseVector3D();
	        weights[weight.index] = weight;
	    };
	    /**
	     * Reads the data for a single position.
	     * @param positionData The list to contain the position data.
	     */
	    MD5MeshParser.prototype.parseVertex = function (positionData) {
	        var position = new PositionData();
	        position.index = this.getNextInt();
	        this.parseUV(position);
	        position.startWeight = this.getNextInt();
	        position.countWeight = this.getNextInt();
	        //			if (position.countWeight > _maxJointCount) _maxJointCount = position.countWeight;
	        positionData[position.index] = position;
	    };
	    /**
	     * Reads the next uv coordinate.
	     * @param positionData The positionData to contain the UV coordinates.
	     */
	    MD5MeshParser.prototype.parseUV = function (positionData) {
	        var ch = this.getNextToken();
	        if (ch != "(")
	            this.sendParseError("(");
	        positionData.s = this.getNextNumber();
	        positionData.t = this.getNextNumber();
	        if (this.getNextToken() != ")")
	            this.sendParseError(")");
	    };
	    /**
	     * Gets the next token in the data stream.
	     */
	    MD5MeshParser.prototype.getNextToken = function () {
	        var ch;
	        var token = "";
	        while (!this._reachedEOF) {
	            ch = this.getNextChar();
	            if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
	                if (token != MD5MeshParser.COMMENT_TOKEN)
	                    this.skipWhiteSpace();
	                if (token != "")
	                    return token;
	            }
	            else
	                token += ch;
	            if (token == MD5MeshParser.COMMENT_TOKEN)
	                return token;
	        }
	        return token;
	    };
	    /**
	     * Skips all whitespace in the data stream.
	     */
	    MD5MeshParser.prototype.skipWhiteSpace = function () {
	        var ch;
	        do
	            ch = this.getNextChar();
	        while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
	        this.putBack();
	    };
	    /**
	     * Skips to the next line.
	     */
	    MD5MeshParser.prototype.ignoreLine = function () {
	        var ch;
	        while (!this._reachedEOF && ch != "\n")
	            ch = this.getNextChar();
	    };
	    /**
	     * Retrieves the next single character in the data stream.
	     */
	    MD5MeshParser.prototype.getNextChar = function () {
	        var ch = this._textData.charAt(this._parseIndex++);
	        if (ch == "\n") {
	            ++this._line;
	            this._charLineIndex = 0;
	        }
	        else if (ch != "\r")
	            ++this._charLineIndex;
	        if (this._parseIndex >= this._textData.length)
	            this._reachedEOF = true;
	        return ch;
	    };
	    /**
	     * Retrieves the next integer in the data stream.
	     */
	    MD5MeshParser.prototype.getNextInt = function () {
	        var i = parseInt(this.getNextToken());
	        if (isNaN(i))
	            this.sendParseError("int type");
	        return i;
	    };
	    /**
	     * Retrieves the next floating point number in the data stream.
	     */
	    MD5MeshParser.prototype.getNextNumber = function () {
	        var f = parseFloat(this.getNextToken());
	        if (isNaN(f))
	            this.sendParseError("float type");
	        return f;
	    };
	    /**
	     * Retrieves the next 3d vector in the data stream.
	     */
	    MD5MeshParser.prototype.parseVector3D = function () {
	        var vec = new Vector3D_1.Vector3D();
	        var ch = this.getNextToken();
	        if (ch != "(")
	            this.sendParseError("(");
	        vec.x = -this.getNextNumber();
	        vec.y = this.getNextNumber();
	        vec.z = this.getNextNumber();
	        if (this.getNextToken() != ")")
	            this.sendParseError(")");
	        return vec;
	    };
	    /**
	     * Retrieves the next quaternion in the data stream.
	     */
	    MD5MeshParser.prototype.parseQuaternion = function () {
	        var quat = new Quaternion_1.Quaternion();
	        var ch = this.getNextToken();
	        if (ch != "(")
	            this.sendParseError("(");
	        quat.x = this.getNextNumber();
	        quat.y = -this.getNextNumber();
	        quat.z = -this.getNextNumber();
	        // quat supposed to be unit length
	        var t = 1 - quat.x * quat.x - quat.y * quat.y - quat.z * quat.z;
	        quat.w = t < 0 ? 0 : -Math.sqrt(t);
	        if (this.getNextToken() != ")")
	            this.sendParseError(")");
	        var rotQuat = new Quaternion_1.Quaternion();
	        rotQuat.multiply(this._rotationQuat, quat);
	        return rotQuat;
	    };
	    /**
	     * Parses the command line data.
	     */
	    MD5MeshParser.prototype.parseCMD = function () {
	        // just ignore the command line property
	        this.parseLiteralstring();
	    };
	    /**
	     * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
	     * by double quotes.
	     */
	    MD5MeshParser.prototype.parseLiteralstring = function () {
	        this.skipWhiteSpace();
	        var ch = this.getNextChar();
	        var str = "";
	        if (ch != "\"")
	            this.sendParseError("\"");
	        do {
	            if (this._reachedEOF)
	                this.sendEOFError();
	            ch = this.getNextChar();
	            if (ch != "\"")
	                str += ch;
	        } while (ch != "\"");
	        return str;
	    };
	    /**
	     * Throws an end-of-file error when a premature end of file was encountered.
	     */
	    MD5MeshParser.prototype.sendEOFError = function () {
	        throw new Error("Unexpected end of file");
	    };
	    /**
	     * Throws an error when an unexpected token was encountered.
	     * @param expected The token type that was actually expected.
	     */
	    MD5MeshParser.prototype.sendParseError = function (expected) {
	        throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
	    };
	    /**
	     * Throws an error when an unknown keyword was encountered.
	     */
	    MD5MeshParser.prototype.sendUnknownKeywordError = function () {
	        throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
	    };
	    MD5MeshParser.VERSION_TOKEN = "MD5Version";
	    MD5MeshParser.COMMAND_LINE_TOKEN = "commandline";
	    MD5MeshParser.NUM_JOINTS_TOKEN = "numJoints";
	    MD5MeshParser.NUM_MESHES_TOKEN = "numMeshes";
	    MD5MeshParser.COMMENT_TOKEN = "//";
	    MD5MeshParser.JOINTS_TOKEN = "joints";
	    MD5MeshParser.MESH_TOKEN = "mesh";
	    MD5MeshParser.MESH_SHADER_TOKEN = "shader";
	    MD5MeshParser.MESH_NUM_VERTS_TOKEN = "numverts";
	    MD5MeshParser.MESH_VERT_TOKEN = "vert";
	    MD5MeshParser.MESH_NUM_TRIS_TOKEN = "numtris";
	    MD5MeshParser.MESH_TRI_TOKEN = "tri";
	    MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN = "numweights";
	    MD5MeshParser.MESH_WEIGHT_TOKEN = "weight";
	    return MD5MeshParser;
	}(ParserBase_1.ParserBase));
	exports.MD5MeshParser = MD5MeshParser;
	var PositionData = (function () {
	    function PositionData() {
	    }
	    return PositionData;
	}());
	exports.PositionData = PositionData;
	var JointData = (function () {
	    function JointData() {
	    }
	    return JointData;
	}());
	exports.JointData = JointData;
	var ElementsData = (function () {
	    function ElementsData() {
	    }
	    return ElementsData;
	}());
	exports.ElementsData = ElementsData;


/***/ },
/* 367 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Sampler2D_1 = __webpack_require__(121);
	var AttributesBuffer_1 = __webpack_require__(5);
	var BitmapImage2D_1 = __webpack_require__(95);
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	var URLRequest_1 = __webpack_require__(296);
	var ParserBase_1 = __webpack_require__(289);
	var ParserUtils_1 = __webpack_require__(291);
	var TriangleElements_1 = __webpack_require__(179);
	var DisplayObjectContainer_1 = __webpack_require__(146);
	var Sprite_1 = __webpack_require__(177);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var Single2DTexture_1 = __webpack_require__(136);
	var MethodMaterial_1 = __webpack_require__(285);
	var MethodMaterialMode_1 = __webpack_require__(284);
	var SpecularBasicMethod_1 = __webpack_require__(263);
	/**
	 * OBJParser provides a parser for the OBJ data type.
	 */
	var OBJParser = (function (_super) {
	    __extends(OBJParser, _super);
	    /**
	     * Creates a new OBJParser object.
	     * @param uri The url or id of the data or file to be parsed.
	     * @param extra The holder for extra contextual data that the parser might need.
	     */
	    function OBJParser(scale) {
	        if (scale === void 0) { scale = 1; }
	        _super.call(this, URLLoaderDataFormat_1.URLLoaderDataFormat.TEXT);
	        this._mtlLibLoaded = true;
	        this._activeMaterialID = "";
	        this._scale = scale;
	    }
	    Object.defineProperty(OBJParser.prototype, "scale", {
	        /**
	         * Scaling factor applied directly to vertices data
	         * @param value The scaling factor.
	         */
	        set: function (value) {
	            this._scale = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Indicates whether or not a given file extension is supported by the parser.
	     * @param extension The file extension of a potential file to be parsed.
	     * @return Whether or not the given file type is supported.
	     */
	    OBJParser.supportsType = function (extension) {
	        extension = extension.toLowerCase();
	        return extension == "obj";
	    };
	    /**
	     * Tests whether a data block can be parsed by the parser.
	     * @param data The data block to potentially be parsed.
	     * @return Whether or not the given data is supported.
	     */
	    OBJParser.supportsData = function (data) {
	        var content = ParserUtils_1.ParserUtils.toString(data);
	        var hasV = false;
	        var hasF = false;
	        if (content) {
	            hasV = content.indexOf("\nv ") != -1;
	            hasF = content.indexOf("\nf ") != -1;
	        }
	        return hasV && hasF;
	    };
	    /**
	     * @inheritDoc
	     */
	    OBJParser.prototype._iResolveDependency = function (resourceDependency) {
	        if (resourceDependency.id == 'mtl') {
	            var str = ParserUtils_1.ParserUtils.toString(resourceDependency.data);
	            this.parseMtl(str);
	        }
	        else {
	            var asset;
	            if (resourceDependency.assets.length != 1) {
	                return;
	            }
	            asset = resourceDependency.assets[0];
	            if (asset.isAsset(BitmapImage2D_1.BitmapImage2D)) {
	                var lm = new LoadedMaterial();
	                lm.materialID = resourceDependency.id;
	                lm.texture = new Single2DTexture_1.Single2DTexture(asset);
	                this._materialLoaded.push(lm);
	                if (this._sprites.length > 0) {
	                    this.applyMaterial(lm);
	                }
	            }
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    OBJParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
	        if (resourceDependency.id == "mtl") {
	            this._mtlLib = false;
	            this._mtlLibLoaded = false;
	        }
	        else {
	            var lm = new LoadedMaterial();
	            lm.materialID = resourceDependency.id;
	            this._materialLoaded.push(lm);
	        }
	        if (this._sprites.length > 0)
	            this.applyMaterial(lm);
	    };
	    /**
	     * @inheritDoc
	     */
	    OBJParser.prototype._pProceedParsing = function () {
	        var line;
	        var creturn = String.fromCharCode(10);
	        var trunk;
	        if (!this._startedParsing) {
	            this._textData = this._pGetTextData();
	            // Merge linebreaks that are immediately preceeded by
	            // the "escape" backward slash into single lines.
	            this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
	        }
	        if (this._textData.indexOf(creturn) == -1)
	            creturn = String.fromCharCode(13);
	        if (!this._startedParsing) {
	            this._startedParsing = true;
	            this._vertices = new Array();
	            this._vertexNormals = new Array();
	            this._materialIDs = new Array();
	            this._materialLoaded = new Array();
	            this._sprites = new Array();
	            this._uvs = new Array();
	            this._stringLength = this._textData.length;
	            this._charIndex = this._textData.indexOf(creturn, 0);
	            this._oldIndex = 0;
	            this._objects = new Array();
	            this._objectIndex = 0;
	        }
	        while (this._charIndex < this._stringLength && this._pHasTime()) {
	            this._charIndex = this._textData.indexOf(creturn, this._oldIndex);
	            if (this._charIndex == -1)
	                this._charIndex = this._stringLength;
	            line = this._textData.substring(this._oldIndex, this._charIndex);
	            line = line.split('\r').join("");
	            line = line.replace("  ", " ");
	            trunk = line.split(" ");
	            this._oldIndex = this._charIndex + 1;
	            this.parseLine(trunk);
	            // If whatever was parsed on this line resulted in the
	            // parsing being paused to retrieve dependencies, break
	            // here and do not continue parsing until un-paused.
	            if (this.parsingPaused) {
	                return ParserBase_1.ParserBase.MORE_TO_PARSE;
	            }
	        }
	        if (this._charIndex >= this._stringLength) {
	            if (this._mtlLib && !this._mtlLibLoaded) {
	                return ParserBase_1.ParserBase.MORE_TO_PARSE;
	            }
	            this.translate();
	            this.applyMaterials();
	            return ParserBase_1.ParserBase.PARSING_DONE;
	        }
	        return ParserBase_1.ParserBase.MORE_TO_PARSE;
	    };
	    OBJParser.prototype._pStartParsing = function (frameLimit) {
	        //create a content object for Loaders
	        this._pContent = new DisplayObjectContainer_1.DisplayObjectContainer();
	        _super.prototype._pStartParsing.call(this, frameLimit);
	    };
	    /**
	     * Parses a single line in the OBJ file.
	     */
	    OBJParser.prototype.parseLine = function (trunk) {
	        switch (trunk[0]) {
	            case "mtllib":
	                this._mtlLib = true;
	                this._mtlLibLoaded = false;
	                this.loadMtl(trunk[1]);
	                break;
	            case "g":
	                this.createGroup(trunk);
	                break;
	            case "o":
	                this.createObject(trunk);
	                break;
	            case "usemtl":
	                if (this._mtlLib) {
	                    if (!trunk[1])
	                        trunk[1] = "def000";
	                    this._materialIDs.push(trunk[1]);
	                    this._activeMaterialID = trunk[1];
	                    if (this._currentGroup)
	                        this._currentGroup.materialID = this._activeMaterialID;
	                }
	                break;
	            case "v":
	                this.parseVertex(trunk);
	                break;
	            case "vt":
	                this.parseUV(trunk);
	                break;
	            case "vn":
	                this.parseVertexNormal(trunk);
	                break;
	            case "f":
	                this.parseFace(trunk);
	        }
	    };
	    /**
	     * Converts the parsed data into an Away3D scenegraph structure
	     */
	    OBJParser.prototype.translate = function () {
	        for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
	            var groups = this._objects[objIndex].groups;
	            var numGroups = groups.length;
	            var materialGroups;
	            var numMaterialGroups;
	            var graphics;
	            var sprite;
	            var m;
	            var sm;
	            var bmMaterial;
	            for (var g = 0; g < numGroups; ++g) {
	                bmMaterial = new MethodMaterial_1.MethodMaterial(DefaultMaterialManager_1.DefaultMaterialManager.getDefaultImage2D());
	                //check for multipass
	                if (this.materialMode >= 2)
	                    bmMaterial.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	                sprite = new Sprite_1.Sprite(bmMaterial);
	                graphics = sprite.graphics;
	                materialGroups = groups[g].materialGroups;
	                numMaterialGroups = materialGroups.length;
	                for (m = 0; m < numMaterialGroups; ++m)
	                    this.translateMaterialGroup(materialGroups[m], graphics);
	                if (graphics.count == 0)
	                    continue;
	                // Finalize and force type-based name
	                this._pFinalizeAsset(graphics); //, "");
	                if (this._objects[objIndex].name) {
	                    // this is a full independent object ('o' tag in OBJ file)
	                    sprite.name = this._objects[objIndex].name;
	                }
	                else if (groups[g].name) {
	                    // this is a group so the sub groups contain the actual sprite object names ('g' tag in OBJ file)
	                    sprite.name = groups[g].name;
	                }
	                else {
	                    // No name stored. Use empty string which will force it
	                    // to be overridden by finalizeAsset() to type default.
	                    sprite.name = "";
	                }
	                this._sprites.push(sprite);
	                if (groups[g].materialID != "")
	                    bmMaterial.name = groups[g].materialID + "~" + sprite.name;
	                else
	                    bmMaterial.name = this._lastMtlID + "~" + sprite.name;
	                if (sprite.graphics.count > 1) {
	                    for (sm = 1; sm < sprite.graphics.count; ++sm)
	                        sprite.graphics.getGraphicAt(sm).material = bmMaterial;
	                }
	                //add to the content property
	                this._pContent.addChild(sprite);
	                this._pFinalizeAsset(sprite);
	            }
	        }
	    };
	    /**
	     * Translates an obj's material group to a subgraphics.
	     * @param materialGroup The material group data to convert.
	     * @param graphics The Graphics to contain the converted Elements.
	     */
	    OBJParser.prototype.translateMaterialGroup = function (materialGroup, graphics) {
	        var faces = materialGroup.faces;
	        var face;
	        var numFaces = faces.length;
	        var numVerts;
	        var elements;
	        var vertices = new Array();
	        var uvs = new Array();
	        var normals = new Array();
	        var indices = new Array();
	        this._realIndices = [];
	        this._vertexIndex = 0;
	        var j;
	        for (var i = 0; i < numFaces; ++i) {
	            face = faces[i];
	            numVerts = face.indexIds.length - 1;
	            for (j = 1; j < numVerts; ++j) {
	                this.translateVertexData(face, j, vertices, uvs, indices, normals);
	                this.translateVertexData(face, 0, vertices, uvs, indices, normals);
	                this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
	            }
	        }
	        if (vertices.length > 0) {
	            elements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	            elements.autoDeriveNormals = normals.length ? false : true;
	            elements.setIndices(indices);
	            elements.setPositions(vertices);
	            elements.setNormals(normals);
	            elements.setUVs(uvs);
	            graphics.addGraphic(elements);
	        }
	    };
	    OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices /*uint*/, normals) {
	        var index;
	        var vertex;
	        var vertexNormal;
	        var uv;
	        if (!this._realIndices[face.indexIds[vertexIndex]]) {
	            index = this._vertexIndex;
	            this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
	            vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
	            vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);
	            if (face.normalIndices.length > 0) {
	                vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
	                normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
	            }
	            if (face.uvIndices.length > 0) {
	                try {
	                    uv = this._uvs[face.uvIndices[vertexIndex] - 1];
	                    uvs.push(uv.u, uv.v);
	                }
	                catch (e) {
	                    switch (vertexIndex) {
	                        case 0:
	                            uvs.push(0, 1);
	                            break;
	                        case 1:
	                            uvs.push(.5, 0);
	                            break;
	                        case 2:
	                            uvs.push(1, 1);
	                    }
	                }
	            }
	        }
	        else {
	            index = this._realIndices[face.indexIds[vertexIndex]] - 1;
	        }
	        indices.push(index);
	    };
	    /**
	     * Creates a new object group.
	     * @param trunk The data block containing the object tag and its parameters
	     */
	    OBJParser.prototype.createObject = function (trunk) {
	        this._currentGroup = null;
	        this._currentMaterialGroup = null;
	        this._objects.push(this._currentObject = new ObjectGroup());
	        if (trunk)
	            this._currentObject.name = trunk[1];
	    };
	    /**
	     * Creates a new group.
	     * @param trunk The data block containing the group tag and its parameters
	     */
	    OBJParser.prototype.createGroup = function (trunk) {
	        if (!this._currentObject)
	            this.createObject(null);
	        this._currentGroup = new Group();
	        this._currentGroup.materialID = this._activeMaterialID;
	        if (trunk)
	            this._currentGroup.name = trunk[1];
	        this._currentObject.groups.push(this._currentGroup);
	        this.createMaterialGroup(null);
	    };
	    /**
	     * Creates a new material group.
	     * @param trunk The data block containing the material tag and its parameters
	     */
	    OBJParser.prototype.createMaterialGroup = function (trunk) {
	        this._currentMaterialGroup = new MaterialGroup();
	        if (trunk)
	            this._currentMaterialGroup.url = trunk[1];
	        this._currentGroup.materialGroups.push(this._currentMaterialGroup);
	    };
	    /**
	     * Reads the next vertex coordinates.
	     * @param trunk The data block containing the vertex tag and its parameters
	     */
	    OBJParser.prototype.parseVertex = function (trunk) {
	        //for the very rare cases of other delimiters/charcodes seen in some obj files
	        var v1, v2, v3;
	        if (trunk.length > 4) {
	            var nTrunk = [];
	            var val;
	            for (var i = 1; i < trunk.length; ++i) {
	                val = parseFloat(trunk[i]);
	                if (!isNaN(val))
	                    nTrunk.push(val);
	            }
	            v1 = nTrunk[0];
	            v2 = nTrunk[1];
	            v3 = -nTrunk[2];
	            this._vertices.push(new Vertex(v1, v2, v3));
	        }
	        else {
	            v1 = parseFloat(trunk[1]);
	            v2 = parseFloat(trunk[2]);
	            v3 = -parseFloat(trunk[3]);
	            this._vertices.push(new Vertex(v1, v2, v3));
	        }
	    };
	    /**
	     * Reads the next uv coordinates.
	     * @param trunk The data block containing the uv tag and its parameters
	     */
	    OBJParser.prototype.parseUV = function (trunk) {
	        if (trunk.length > 3) {
	            var nTrunk = [];
	            var val;
	            for (var i = 1; i < trunk.length; ++i) {
	                val = parseFloat(trunk[i]);
	                if (!isNaN(val))
	                    nTrunk.push(val);
	            }
	            this._uvs.push(new UV(nTrunk[0], 1 - nTrunk[1]));
	        }
	        else {
	            this._uvs.push(new UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
	        }
	    };
	    /**
	     * Reads the next vertex normal coordinates.
	     * @param trunk The data block containing the vertex normal tag and its parameters
	     */
	    OBJParser.prototype.parseVertexNormal = function (trunk) {
	        if (trunk.length > 4) {
	            var nTrunk = [];
	            var val;
	            for (var i = 1; i < trunk.length; ++i) {
	                val = parseFloat(trunk[i]);
	                if (!isNaN(val))
	                    nTrunk.push(val);
	            }
	            this._vertexNormals.push(new Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
	        }
	        else {
	            this._vertexNormals.push(new Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
	        }
	    };
	    /**
	     * Reads the next face's indices.
	     * @param trunk The data block containing the face tag and its parameters
	     */
	    OBJParser.prototype.parseFace = function (trunk) {
	        var len = trunk.length;
	        var face = new FaceData();
	        if (!this._currentGroup) {
	            this.createGroup(null);
	        }
	        var indices;
	        for (var i = 1; i < len; ++i) {
	            if (trunk[i] == "") {
	                continue;
	            }
	            indices = trunk[i].split("/");
	            face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));
	            if (indices[1] && String(indices[1]).length > 0)
	                face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));
	            if (indices[2] && String(indices[2]).length > 0)
	                face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));
	            face.indexIds.push(trunk[i]);
	        }
	        this._currentMaterialGroup.faces.push(face);
	    };
	    /**
	     * This is a hack around negative face coords
	     */
	    OBJParser.prototype.parseIndex = function (index, length) {
	        if (index < 0)
	            return index + length + 1;
	        else
	            return index;
	    };
	    OBJParser.prototype.parseMtl = function (data) {
	        var materialDefinitions = data.split('newmtl');
	        var lines;
	        var trunk;
	        var j;
	        var basicSpecularMethod;
	        var useSpecular;
	        var useColor;
	        var diffuseColor;
	        var color;
	        var specularColor;
	        var specular;
	        var alpha;
	        var mapkd;
	        for (var i = 0; i < materialDefinitions.length; ++i) {
	            lines = (materialDefinitions[i].split('\r')).join("").split('\n');
	            //lines = (materialDefinitions[i].split('\r') as Array).join("").split('\n');
	            if (lines.length == 1)
	                lines = materialDefinitions[i].split(String.fromCharCode(13));
	            diffuseColor = color = specularColor = 0xFFFFFF;
	            specular = 0;
	            useSpecular = false;
	            useColor = false;
	            alpha = 1;
	            mapkd = "";
	            for (j = 0; j < lines.length; ++j) {
	                lines[j] = lines[j].replace(/\s+$/, "");
	                if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
	                    trunk = lines[j].split(" ");
	                    if (String(trunk[0]).charCodeAt(0) == 9 || String(trunk[0]).charCodeAt(0) == 32)
	                        trunk[0] = trunk[0].substring(1, trunk[0].length);
	                    if (j == 0) {
	                        this._lastMtlID = trunk.join("");
	                        this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
	                    }
	                    else {
	                        switch (trunk[0]) {
	                            case "Ka":
	                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3])))
	                                    color = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
	                                break;
	                            case "Ks":
	                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
	                                    specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
	                                    useSpecular = true;
	                                }
	                                break;
	                            case "Ns":
	                                if (trunk[1] && !isNaN(Number(trunk[1])))
	                                    specular = Number(trunk[1]) * 0.001;
	                                if (specular == 0)
	                                    useSpecular = false;
	                                break;
	                            case "Kd":
	                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
	                                    diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
	                                    useColor = true;
	                                }
	                                break;
	                            case "tr":
	                            case "d":
	                                if (trunk[1] && !isNaN(Number(trunk[1])))
	                                    alpha = Number(trunk[1]);
	                                break;
	                            case "map_Kd":
	                                mapkd = this.parseMapKdString(trunk);
	                                mapkd = mapkd.replace(/\\/g, "/");
	                        }
	                    }
	                }
	            }
	            if (mapkd != "") {
	                if (useSpecular) {
	                    basicSpecularMethod = new SpecularBasicMethod_1.SpecularBasicMethod();
	                    basicSpecularMethod.color = specularColor;
	                    basicSpecularMethod.strength = specular;
	                    var specularData = new SpecularData();
	                    specularData.alpha = alpha;
	                    specularData.basicSpecularMethod = basicSpecularMethod;
	                    specularData.materialID = this._lastMtlID;
	                    if (!this._materialSpecularData)
	                        this._materialSpecularData = new Array();
	                    this._materialSpecularData.push(specularData);
	                }
	                this._pAddDependency(this._lastMtlID, new URLRequest_1.URLRequest(mapkd));
	            }
	            else if (useColor && !isNaN(color)) {
	                var lm = new LoadedMaterial();
	                lm.materialID = this._lastMtlID;
	                if (alpha == 0)
	                    console.log("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", sprite(es) using it will be invisible!");
	                var cm = new MethodMaterial_1.MethodMaterial(color);
	                if (this.materialMode < 2) {
	                    cm.alpha = alpha;
	                }
	                else {
	                    cm.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	                }
	                cm.diffuseMethod.color = diffuseColor;
	                if (useSpecular) {
	                    cm.specularMethod.color = specularColor;
	                    cm.specularMethod.strength = specular;
	                }
	                lm.cm = cm;
	                this._materialLoaded.push(lm);
	                if (this._sprites.length > 0)
	                    this.applyMaterial(lm);
	            }
	        }
	        this._mtlLibLoaded = true;
	    };
	    OBJParser.prototype.parseMapKdString = function (trunk) {
	        var url = "";
	        var i;
	        var breakflag;
	        for (i = 1; i < trunk.length;) {
	            switch (trunk[i]) {
	                case "-blendu":
	                case "-blendv":
	                case "-cc":
	                case "-clamp":
	                case "-texres":
	                    i += 2; //Skip ahead 1 attribute
	                    break;
	                case "-mm":
	                    i += 3; //Skip ahead 2 attributes
	                    break;
	                case "-o":
	                case "-s":
	                case "-t":
	                    i += 4; //Skip ahead 3 attributes
	                    continue;
	                default:
	                    breakflag = true;
	                    break;
	            }
	            if (breakflag)
	                break;
	        }
	        //Reconstruct URL/filename
	        for (i; i < trunk.length; i++) {
	            url += trunk[i];
	            url += " ";
	        }
	        //Remove the extraneous space and/or newline from the right side
	        url = url.replace(/\s+$/, "");
	        return url;
	    };
	    OBJParser.prototype.loadMtl = function (mtlurl) {
	        // Add raw-data dependency to queue and load dependencies now,
	        // which will pause the parsing in the meantime.
	        this._pAddDependency('mtl', new URLRequest_1.URLRequest(mtlurl), true);
	        this._pPauseAndRetrieveDependencies(); //
	    };
	    OBJParser.prototype.applyMaterial = function (lm) {
	        var decomposeID;
	        var sprite;
	        var tm;
	        var j;
	        var specularData;
	        for (var i = 0; i < this._sprites.length; ++i) {
	            sprite = this._sprites[i];
	            decomposeID = sprite.material.name.split("~");
	            if (decomposeID[0] == lm.materialID) {
	                if (lm.cm) {
	                    if (sprite.material)
	                        sprite.material = null;
	                    sprite.material = lm.cm;
	                }
	                else if (lm.texture) {
	                    tm = sprite.material;
	                    tm.ambientMethod.texture = lm.texture;
	                    tm.style.color = lm.color;
	                    tm.alpha = lm.alpha;
	                    tm.style.sampler = new Sampler2D_1.Sampler2D(true);
	                    if (this.materialMode < 2)
	                        tm.alpha = lm.alpha;
	                    else
	                        tm.mode = MethodMaterialMode_1.MethodMaterialMode.MULTI_PASS;
	                    if (lm.specularMethod) {
	                        // By setting the specularMethod property to null before assigning
	                        // the actual method instance, we avoid having the properties of
	                        // the new method being overridden with the settings from the old
	                        // one, which is default behavior of the setter.
	                        tm.specularMethod = null;
	                        tm.specularMethod = lm.specularMethod;
	                    }
	                    else if (this._materialSpecularData) {
	                        for (j = 0; j < this._materialSpecularData.length; ++j) {
	                            specularData = this._materialSpecularData[j];
	                            if (specularData.materialID == lm.materialID) {
	                                tm.specularMethod = null; // Prevent property overwrite (see above)
	                                tm.specularMethod = specularData.basicSpecularMethod;
	                                tm.specularMethod.color = specularData.color;
	                                tm.specularMethod.strength = specularData.alpha;
	                                break;
	                            }
	                        }
	                    }
	                }
	                sprite.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
	                this._sprites.splice(i, 1);
	                --i;
	            }
	        }
	        if (lm.cm || tm)
	            this._pFinalizeAsset(lm.cm || tm);
	    };
	    OBJParser.prototype.applyMaterials = function () {
	        if (this._materialLoaded.length == 0)
	            return;
	        for (var i = 0; i < this._materialLoaded.length; ++i)
	            this.applyMaterial(this._materialLoaded[i]);
	    };
	    return OBJParser;
	}(ParserBase_1.ParserBase));
	exports.OBJParser = OBJParser;
	var ObjectGroup = (function () {
	    function ObjectGroup() {
	        this.groups = new Array();
	    }
	    return ObjectGroup;
	}());
	exports.ObjectGroup = ObjectGroup;
	var Group = (function () {
	    function Group() {
	        this.materialGroups = new Array();
	    }
	    return Group;
	}());
	exports.Group = Group;
	var MaterialGroup = (function () {
	    function MaterialGroup() {
	        this.faces = new Array();
	    }
	    return MaterialGroup;
	}());
	exports.MaterialGroup = MaterialGroup;
	var SpecularData = (function () {
	    function SpecularData() {
	        this.color = 0xFFFFFF;
	        this.alpha = 1;
	    }
	    return SpecularData;
	}());
	exports.SpecularData = SpecularData;
	var LoadedMaterial = (function () {
	    function LoadedMaterial() {
	        this.color = 0xFFFFFF;
	        this.alpha = 1;
	    }
	    return LoadedMaterial;
	}());
	exports.LoadedMaterial = LoadedMaterial;
	var FaceData = (function () {
	    function FaceData() {
	        this.vertexIndices = new Array();
	        this.uvIndices = new Array();
	        this.normalIndices = new Array();
	        this.indexIds = new Array(); // used for real index lookups
	    }
	    return FaceData;
	}());
	exports.FaceData = FaceData;
	/**
	* Texture coordinates value object.
	*/
	var UV = (function () {
	    /**
	     * Creates a new <code>UV</code> object.
	     *
	     * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
	     * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
	     */
	    function UV(u, v) {
	        if (u === void 0) { u = 0; }
	        if (v === void 0) { v = 0; }
	        this._u = u;
	        this._v = v;
	    }
	    Object.defineProperty(UV.prototype, "v", {
	        /**
	         * Defines the vertical coordinate of the texture value.
	         */
	        get: function () {
	            return this._v;
	        },
	        set: function (value) {
	            this._v = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(UV.prototype, "u", {
	        /**
	         * Defines the horizontal coordinate of the texture value.
	         */
	        get: function () {
	            return this._u;
	        },
	        set: function (value) {
	            this._u = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * returns a new UV value Object
	     */
	    UV.prototype.clone = function () {
	        return new UV(this._u, this._v);
	    };
	    /**
	     * returns the value object as a string for trace/debug purpose
	     */
	    UV.prototype.toString = function () {
	        return this._u + "," + this._v;
	    };
	    return UV;
	}());
	exports.UV = UV;
	var Vertex = (function () {
	    /**
	     * Creates a new <code>Vertex</code> value object.
	     *
	     * @param    x            [optional]    The x value. Defaults to 0.
	     * @param    y            [optional]    The y value. Defaults to 0.
	     * @param    z            [optional]    The z value. Defaults to 0.
	     * @param    index        [optional]    The index value. Defaults is NaN.
	     */
	    function Vertex(x, y, z, index) {
	        if (x === void 0) { x = 0; }
	        if (y === void 0) { y = 0; }
	        if (z === void 0) { z = 0; }
	        if (index === void 0) { index = 0; }
	        this._x = x;
	        this._y = y;
	        this._z = z;
	        this._index = index;
	    }
	    Object.defineProperty(Vertex.prototype, "index", {
	        get: function () {
	            return this._index;
	        },
	        /**
	         * To define/store the index of value object
	         * @param    ind        The index
	         */
	        set: function (ind) {
	            this._index = ind;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vertex.prototype, "x", {
	        /**
	         * To define/store the x value of the value object
	         * @param    value        The x value
	         */
	        get: function () {
	            return this._x;
	        },
	        set: function (value) {
	            this._x = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vertex.prototype, "y", {
	        /**
	         * To define/store the y value of the value object
	         * @param    value        The y value
	         */
	        get: function () {
	            return this._y;
	        },
	        set: function (value) {
	            this._y = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Vertex.prototype, "z", {
	        /**
	         * To define/store the z value of the value object
	         * @param    value        The z value
	         */
	        get: function () {
	            return this._z;
	        },
	        set: function (value) {
	            this._z = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * returns a new Vertex value Object
	     */
	    Vertex.prototype.clone = function () {
	        return new Vertex(this._x, this._y, this._z);
	    };
	    return Vertex;
	}());
	exports.Vertex = Vertex;


/***/ },
/* 368 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Loader_1 = __webpack_require__(161);
	var AWDParser_1 = __webpack_require__(305);
	var Max3DSParser_1 = __webpack_require__(362);
	var MD2Parser_1 = __webpack_require__(364);
	var OBJParser_1 = __webpack_require__(367);
	var FNTParser_1 = __webpack_require__(361);
	/**
	 *
	 */
	var Parsers = (function () {
	    function Parsers() {
	    }
	    /**
	     * Short-hand function to enable all bundled parsers for auto-detection. In practice,
	     * this is the same as invoking enableParsers(Parsers.ALL_BUNDLED) on any of the
	     * loader classes SingleFileLoader, LoaderSession, AssetLibrary or Loader3D.
	     *
	     * See notes about file size in the documentation for the ALL_BUNDLED constant.
	     *
	     * @see away.parsers.Parsers.ALL_BUNDLED
	     */
	    Parsers.enableAllBundled = function () {
	        Loader_1.Loader.enableParsers(Parsers.ALL_BUNDLED);
	    };
	    /**
	     * A list of all parsers that come bundled with Away3D. Use this to quickly
	     * enable support for all bundled parsers to the file format auto-detection
	     * feature, using any of the enableParsers() methods on loaders, e.g.:
	     *
	     * <code>AssetLibrary.enableParsers(Parsers.ALL_BUNDLED);</code>
	     *
	     * Beware however that this requires all parser classes to be included in the
	     * SWF file, which will add 50-100 kb to the file. When only a limited set of
	     * file formats are used, SWF file size can be saved by adding the parsers
	     * individually using AssetLibrary.enableParser()
	     *
	     * A third way is to specify a parser for each loaded file, thereby bypassing
	     * the auto-detection mechanisms altogether, while at the same time allowing
	     * any properties that are unique to that parser to be set for that load.
	     *
	     * The bundled parsers are:
	     *
	     * <ul>
	     * <li>AC3D (.ac)</li>
	     * <li>Away Data version 1 ASCII and version 2 binary (.awd). AWD1 BSP unsupported</li>
	     * <li>3DMax (.3ds)</li>
	     * <li>DXF (.dxf)</li>
	     * <li>Quake 2 MD2 models (.md2)</li>
	     * <li>Doom 3 MD5 animation clips (.md5anim)</li>
	     * <li>Doom 3 MD5 sprites (.md5sprite)</li>
	     * <li>Wavefront OBJ (.obj)</li>
	     * <li>Collada (.dae)</li>
	     * <li>Images (.jpg, .png)</li>
	     * </ul>
	     *
	     * @see away.library.AssetLibrary.enableParser
	     */
	    Parsers.ALL_BUNDLED = Array(AWDParser_1.AWDParser, Max3DSParser_1.Max3DSParser, MD2Parser_1.MD2Parser, OBJParser_1.OBJParser, FNTParser_1.FNTParser);
	    return Parsers;
	}());
	exports.Parsers = Parsers;


/***/ },
/* 369 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(370));


/***/ },
/* 370 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BasicPartition_1 = __webpack_require__(371);
	exports.BasicPartition = BasicPartition_1.BasicPartition;
	var CameraNode_1 = __webpack_require__(376);
	exports.CameraNode = CameraNode_1.CameraNode;
	var DirectionalLightNode_1 = __webpack_require__(381);
	exports.DirectionalLightNode = DirectionalLightNode_1.DirectionalLightNode;
	var DisplayObjectNode_1 = __webpack_require__(378);
	exports.DisplayObjectNode = DisplayObjectNode_1.DisplayObjectNode;
	var EntityNode_1 = __webpack_require__(377);
	exports.EntityNode = EntityNode_1.EntityNode;
	var LightProbeNode_1 = __webpack_require__(382);
	exports.LightProbeNode = LightProbeNode_1.LightProbeNode;
	var NodeBase_1 = __webpack_require__(372);
	exports.NodeBase = NodeBase_1.NodeBase;
	var PartitionBase_1 = __webpack_require__(375);
	exports.PartitionBase = PartitionBase_1.PartitionBase;
	var PointLightNode_1 = __webpack_require__(383);
	exports.PointLightNode = PointLightNode_1.PointLightNode;
	var SceneGraphNode_1 = __webpack_require__(384);
	exports.SceneGraphNode = SceneGraphNode_1.SceneGraphNode;
	var SceneGraphPartition_1 = __webpack_require__(385);
	exports.SceneGraphPartition = SceneGraphPartition_1.SceneGraphPartition;
	var SkyboxNode_1 = __webpack_require__(386);
	exports.SkyboxNode = SkyboxNode_1.SkyboxNode;


/***/ },
/* 371 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var NodeBase_1 = __webpack_require__(372);
	var PartitionBase_1 = __webpack_require__(375);
	/**
	 * @class away.partition.Partition
	 */
	var BasicPartition = (function (_super) {
	    __extends(BasicPartition, _super);
	    function BasicPartition(root) {
	        _super.call(this, root);
	        this._rootNode = new NodeBase_1.NodeBase();
	    }
	    return BasicPartition;
	}(PartitionBase_1.PartitionBase));
	exports.BasicPartition = BasicPartition;


/***/ },
/* 372 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var NullBounds_1 = __webpack_require__(373);
	/**
	 * @class away.partition.NodeBase
	 */
	var NodeBase = (function () {
	    /**
	     *
	     */
	    function NodeBase() {
	        this._bounds = new NullBounds_1.NullBounds();
	        this._pChildNodes = new Array();
	        this._pNumChildNodes = 0;
	        this.numEntities = 0;
	    }
	    Object.defineProperty(NodeBase.prototype, "debugVisible", {
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(NodeBase.prototype, "bounds", {
	        /**
	         * @internal
	         */
	        get: function () {
	            return this._bounds; //TODO
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     * @param planes
	     * @param numPlanes
	     * @returns {boolean}
	     * @internal
	     */
	    NodeBase.prototype.isInFrustum = function (planes, numPlanes) {
	        return true;
	    };
	    /**
	     *
	     * @param rayPosition
	     * @param rayDirection
	     * @returns {boolean}
	     */
	    NodeBase.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
	        return true;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    NodeBase.prototype.isRenderable = function () {
	        return true;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    NodeBase.prototype.isCastingShadow = function () {
	        return true;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    NodeBase.prototype.isMask = function () {
	        return false;
	    };
	    NodeBase.prototype.dispose = function () {
	        this.parent = null;
	        this._pChildNodes = null;
	    };
	    /**
	     *
	     * @param traverser
	     */
	    NodeBase.prototype.acceptTraverser = function (traverser) {
	        if (this.numEntities == 0)
	            return;
	        if (traverser.enterNode(this)) {
	            for (var i = 0; i < this._pNumChildNodes; i++)
	                this._pChildNodes[i].acceptTraverser(traverser);
	        }
	    };
	    /**
	     *
	     * @param node
	     * @internal
	     */
	    NodeBase.prototype.iAddNode = function (node) {
	        node.parent = this;
	        this.numEntities += node.numEntities;
	        this._pChildNodes[this._pNumChildNodes++] = node;
	        var numEntities = node.numEntities;
	        node = this;
	        do {
	            node.numEntities += numEntities;
	        } while ((node = node.parent) != null);
	    };
	    /**
	     *
	     * @param node
	     * @internal
	     */
	    NodeBase.prototype.iRemoveNode = function (node) {
	        var index = this._pChildNodes.indexOf(node);
	        this._pChildNodes[index] = this._pChildNodes[--this._pNumChildNodes];
	        this._pChildNodes.pop();
	        var numEntities = node.numEntities;
	        node = this;
	        do {
	            node.numEntities -= numEntities;
	        } while ((node = node.parent) != null);
	    };
	    return NodeBase;
	}());
	exports.NodeBase = NodeBase;


/***/ },
/* 373 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PlaneClassification_1 = __webpack_require__(141);
	var BoundingVolumeBase_1 = __webpack_require__(374);
	var NullBounds = (function (_super) {
	    __extends(NullBounds, _super);
	    function NullBounds(alwaysIn) {
	        if (alwaysIn === void 0) { alwaysIn = true; }
	        _super.call(this, null);
	        this._alwaysIn = alwaysIn;
	    }
	    //@override
	    NullBounds.prototype.clone = function () {
	        return new NullBounds(this._alwaysIn);
	    };
	    //@override
	    NullBounds.prototype.isInFrustum = function (planes, numPlanes) {
	        return this._alwaysIn;
	    };
	    NullBounds.prototype.classifyToPlane = function (plane) {
	        return PlaneClassification_1.PlaneClassification.INTERSECT;
	    };
	    return NullBounds;
	}(BoundingVolumeBase_1.BoundingVolumeBase));
	exports.NullBounds = NullBounds;


/***/ },
/* 374 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(7);
	var BoundingVolumeBase = (function () {
	    function BoundingVolumeBase(entity) {
	        this._pInvalidated = true;
	        this._pEntity = entity;
	    }
	    BoundingVolumeBase.prototype.dispose = function () {
	        this._pEntity = null;
	        this._pBoundsPrimitive = null;
	    };
	    Object.defineProperty(BoundingVolumeBase.prototype, "boundsPrimitive", {
	        get: function () {
	            if (this._pBoundsPrimitive == null) {
	                this._pBoundsPrimitive = this._pCreateBoundsPrimitive();
	                this._pInvalidated = true;
	            }
	            if (this._pInvalidated)
	                this._pUpdate();
	            return this._pBoundsPrimitive;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BoundingVolumeBase.prototype.nullify = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    BoundingVolumeBase.prototype.isInFrustum = function (planes, numPlanes) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    BoundingVolumeBase.prototype.clone = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    BoundingVolumeBase.prototype.rayIntersection = function (position, direction, targetNormal) {
	        return -1;
	    };
	    BoundingVolumeBase.prototype.classifyToPlane = function (plane) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    BoundingVolumeBase.prototype._pUpdate = function () {
	        this._pInvalidated = false;
	    };
	    BoundingVolumeBase.prototype.invalidate = function () {
	        this._pInvalidated = true;
	    };
	    BoundingVolumeBase.prototype._pCreateBoundsPrimitive = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    return BoundingVolumeBase;
	}());
	exports.BoundingVolumeBase = BoundingVolumeBase;


/***/ },
/* 375 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.partition.Partition
	 */
	var PartitionBase = (function () {
	    function PartitionBase(root) {
	        this._abstractionPool = new Object();
	        this._updatesMade = false;
	        this._root = root;
	    }
	    Object.defineProperty(PartitionBase.prototype, "root", {
	        get: function () {
	            return this._root;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    PartitionBase.prototype.getAbstraction = function (displayObject) {
	        return (this._abstractionPool[displayObject.id] || (this._abstractionPool[displayObject.id] = new PartitionBase._abstractionClassPool[displayObject.assetType](displayObject, this)));
	    };
	    /**
	     *
	     * @param image
	     */
	    PartitionBase.prototype.clearAbstraction = function (displayObject) {
	        this._abstractionPool[displayObject.id] = null;
	    };
	    PartitionBase.prototype.traverse = function (traverser) {
	        if (this._updatesMade)
	            this.updateEntities();
	        if (this._rootNode) {
	            this._rootNode.acceptTraverser(traverser);
	        }
	    };
	    PartitionBase.prototype.iMarkForUpdate = function (node) {
	        var t = this._updateQueue;
	        while (t) {
	            if (node == t)
	                return;
	            t = t._iUpdateQueueNext;
	        }
	        node._iUpdateQueueNext = this._updateQueue;
	        this._updateQueue = node;
	        this._updatesMade = true;
	    };
	    PartitionBase.prototype.iRemoveEntity = function (node) {
	        var t;
	        if (node.parent) {
	            node.parent.iRemoveNode(node);
	            node.parent = null;
	        }
	        if (node == this._updateQueue) {
	            this._updateQueue = node._iUpdateQueueNext;
	        }
	        else {
	            t = this._updateQueue;
	            while (t && t._iUpdateQueueNext != node)
	                t = t._iUpdateQueueNext;
	            if (t)
	                t._iUpdateQueueNext = node._iUpdateQueueNext;
	        }
	        node._iUpdateQueueNext = null;
	        if (!this._updateQueue)
	            this._updatesMade = false;
	    };
	    /**
	     *
	     * @param entity
	     * @returns {away.partition.NodeBase}
	     */
	    PartitionBase.prototype.findParentForNode = function (node) {
	        return this._rootNode;
	    };
	    PartitionBase.prototype.updateEntities = function () {
	        var node = this._updateQueue;
	        while (node) {
	            //required for controllers with autoUpdate set to true and queued events
	            node._displayObject._iInternalUpdate();
	            node = node._iUpdateQueueNext;
	        }
	        //reset head
	        node = this._updateQueue;
	        var targetNode;
	        var t;
	        this._updateQueue = null;
	        this._updatesMade = false;
	        do {
	            targetNode = this.findParentForNode(node);
	            if (node.parent != targetNode) {
	                if (node.parent)
	                    node.parent.iRemoveNode(node);
	                targetNode.iAddNode(node);
	            }
	            t = node._iUpdateQueueNext;
	            node._iUpdateQueueNext = null;
	        } while ((node = t) != null);
	    };
	    /**
	     * @internal
	     */
	    PartitionBase.prototype._iRegisterEntity = function (displayObject) {
	        if (displayObject.isEntity)
	            this.iMarkForUpdate(this.getAbstraction(displayObject));
	    };
	    /**
	     * @internal
	     */
	    PartitionBase.prototype._iUnregisterEntity = function (displayObject) {
	        if (displayObject.isEntity)
	            this.iRemoveEntity(this.getAbstraction(displayObject));
	    };
	    PartitionBase.prototype.dispose = function () {
	        //TODO
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    PartitionBase.registerAbstraction = function (entityNodeClass, assetClass) {
	        PartitionBase._abstractionClassPool[assetClass.assetType] = entityNodeClass;
	    };
	    PartitionBase._abstractionClassPool = new Object();
	    return PartitionBase;
	}());
	exports.PartitionBase = PartitionBase;


/***/ },
/* 376 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EntityNode_1 = __webpack_require__(377);
	/**
	 * @class away.partition.CameraNode
	 */
	var CameraNode = (function (_super) {
	    __extends(CameraNode, _super);
	    function CameraNode() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @inheritDoc
	     */
	    CameraNode.prototype.acceptTraverser = function (traverser) {
	        // todo: dead end for now, if it has a debug sprite, then sure accept that
	    };
	    return CameraNode;
	}(EntityNode_1.EntityNode));
	exports.CameraNode = CameraNode;


/***/ },
/* 377 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var DisplayObjectNode_1 = __webpack_require__(378);
	/**
	 * @class away.partition.EntityNode
	 */
	var EntityNode = (function (_super) {
	    __extends(EntityNode, _super);
	    function EntityNode(displayObject, partition) {
	        _super.call(this, displayObject, partition);
	        this.numEntities = 1;
	        this._maskPosition = new Vector3D_1.Vector3D();
	        this._partition = partition;
	    }
	    EntityNode.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._partition = null;
	    };
	    /**
	     *
	     * @param planes
	     * @param numPlanes
	     * @returns {boolean}
	     */
	    EntityNode.prototype.isInFrustum = function (planes, numPlanes) {
	        if (!this._displayObject._iIsVisible())
	            return false;
	        return true; // todo: hack for 2d. attention. might break stuff in 3d.
	        //return this._bounds.isInFrustum(planes, numPlanes);
	    };
	    /**
	     * @inheritDoc
	     */
	    EntityNode.prototype.isIntersectingRay = function (globalRayPosition, globalRayDirection) {
	        if (!this._displayObject._iIsVisible() || !this.isIntersectingMasks(globalRayPosition, globalRayDirection, this._displayObject._iAssignedMasks()))
	            return false;
	        var pickingCollision = this._displayObject._iPickingCollision;
	        pickingCollision.rayPosition = this._displayObject.inverseSceneTransform.transformVector(globalRayPosition);
	        pickingCollision.rayDirection = this._displayObject.inverseSceneTransform.deltaTransformVector(globalRayDirection);
	        if (!pickingCollision.normal)
	            pickingCollision.normal = new Vector3D_1.Vector3D();
	        var rayEntryDistance = this.bounds.rayIntersection(pickingCollision.rayPosition, pickingCollision.rayDirection, pickingCollision.normal);
	        if (rayEntryDistance < 0)
	            return false;
	        pickingCollision.rayEntryDistance = rayEntryDistance;
	        pickingCollision.globalRayPosition = globalRayPosition;
	        pickingCollision.globalRayDirection = globalRayDirection;
	        pickingCollision.rayOriginIsInsideBounds = rayEntryDistance == 0;
	        return true;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    EntityNode.prototype.isRenderable = function () {
	        return this._displayObject._iAssignedColorTransform()._isRenderable();
	    };
	    /**
	     * @inheritDoc
	     */
	    EntityNode.prototype.acceptTraverser = function (traverser) {
	        if (traverser.enterNode(this))
	            traverser.applyEntity(this._displayObject);
	    };
	    EntityNode.prototype._onInvalidatePartitionBounds = function (event) {
	        this.bounds.invalidate();
	        this._partition.iMarkForUpdate(this);
	    };
	    EntityNode.prototype.isIntersectingMasks = function (globalRayPosition, globalRayDirection, masks) {
	        //horrible hack for 2d masks
	        if (masks != null) {
	            this._maskPosition.x = globalRayPosition.x + globalRayDirection.x * 1000;
	            this._maskPosition.y = globalRayPosition.y + globalRayDirection.y * 1000;
	            var numLayers = masks.length;
	            var children;
	            var numChildren;
	            var layerHit;
	            for (var i = 0; i < numLayers; i++) {
	                children = masks[i];
	                numChildren = children.length;
	                layerHit = false;
	                for (var j = 0; j < numChildren; j++) {
	                    if (children[j].hitTestPoint(this._maskPosition.x, this._maskPosition.y, true, true)) {
	                        layerHit = true;
	                        break;
	                    }
	                }
	                if (!layerHit)
	                    return false;
	            }
	        }
	        return true;
	    };
	    return EntityNode;
	}(DisplayObjectNode_1.DisplayObjectNode));
	exports.EntityNode = EntityNode;


/***/ },
/* 378 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractionBase_1 = __webpack_require__(210);
	var DisplayObjectEvent_1 = __webpack_require__(117);
	var AxisAlignedBoundingBox_1 = __webpack_require__(379);
	var BoundingSphere_1 = __webpack_require__(380);
	var BoundsType_1 = __webpack_require__(115);
	var NullBounds_1 = __webpack_require__(373);
	/**
	 * @class away.partition.EntityNode
	 */
	var DisplayObjectNode = (function (_super) {
	    __extends(DisplayObjectNode, _super);
	    function DisplayObjectNode(displayObject, pool) {
	        var _this = this;
	        _super.call(this, displayObject, pool);
	        this.numEntities = 0;
	        this.isSceneGraphNode = false;
	        this._boundsDirty = true;
	        this._onInvalidatePartitionBoundsDelegate = function (event) { return _this._onInvalidatePartitionBounds(event); };
	        this._displayObject = displayObject;
	        this._displayObject.addEventListener(DisplayObjectEvent_1.DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS, this._onInvalidatePartitionBoundsDelegate);
	        this._boundsType = this._displayObject.boundsType;
	    }
	    Object.defineProperty(DisplayObjectNode.prototype, "debugVisible", {
	        get: function () {
	            return this._displayObject.debugVisible;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DisplayObjectNode.prototype, "bounds", {
	        /**
	         * @internal
	         */
	        get: function () {
	            if (this._boundsDirty)
	                this._updateBounds();
	            return this._bounds;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     * @returns {boolean}
	     */
	    DisplayObjectNode.prototype.isCastingShadow = function () {
	        return this._displayObject.castsShadows;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    DisplayObjectNode.prototype.isMask = function () {
	        return this._displayObject.maskMode;
	    };
	    DisplayObjectNode.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._displayObject.removeEventListener(DisplayObjectEvent_1.DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS, this._onInvalidatePartitionBoundsDelegate);
	        this._displayObject = null;
	        if (this._bounds)
	            this._bounds.dispose();
	        this._bounds = null;
	    };
	    DisplayObjectNode.prototype.onInvalidate = function (event) {
	        _super.prototype.onInvalidate.call(this, event);
	        if (this._boundsType != this._displayObject.boundsType) {
	            this._boundsType = this._displayObject.boundsType;
	            this._boundsDirty = true;
	        }
	    };
	    /**
	     *
	     * @param planes
	     * @param numPlanes
	     * @returns {boolean}
	     */
	    DisplayObjectNode.prototype.isInFrustum = function (planes, numPlanes) {
	        return true;
	    };
	    /**
	     * @inheritDoc
	     */
	    DisplayObjectNode.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
	        return true;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    DisplayObjectNode.prototype.isRenderable = function () {
	        return true;
	    };
	    /**
	     * @inheritDoc
	     */
	    DisplayObjectNode.prototype.acceptTraverser = function (traverser) {
	        // do nothing here
	    };
	    DisplayObjectNode.prototype._onInvalidatePartitionBounds = function (event) {
	        // do nothing here
	    };
	    DisplayObjectNode.prototype._updateBounds = function () {
	        if (this._bounds)
	            this._bounds.dispose();
	        if (this._boundsType == BoundsType_1.BoundsType.AXIS_ALIGNED_BOX)
	            this._bounds = new AxisAlignedBoundingBox_1.AxisAlignedBoundingBox(this._displayObject);
	        else if (this._boundsType == BoundsType_1.BoundsType.SPHERE)
	            this._bounds = new BoundingSphere_1.BoundingSphere(this._displayObject);
	        else if (this._boundsType == BoundsType_1.BoundsType.NULL)
	            this._bounds = new NullBounds_1.NullBounds();
	        this._boundsDirty = false;
	    };
	    return DisplayObjectNode;
	}(AbstractionBase_1.AbstractionBase));
	exports.DisplayObjectNode = DisplayObjectNode;


/***/ },
/* 379 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PlaneClassification_1 = __webpack_require__(141);
	var ElementsType_1 = __webpack_require__(203);
	var BoundingVolumeBase_1 = __webpack_require__(374);
	var PrimitiveCubePrefab_1 = __webpack_require__(313);
	/**
	 * AxisAlignedBoundingBox represents a bounding box volume that has its planes aligned to the local coordinate axes of the bounded object.
	 * This is useful for most sprites.
	 */
	var AxisAlignedBoundingBox = (function (_super) {
	    __extends(AxisAlignedBoundingBox, _super);
	    /**
	     * Creates a new <code>AxisAlignedBoundingBox</code> object.
	     */
	    function AxisAlignedBoundingBox(entity) {
	        _super.call(this, entity);
	        this._x = 0;
	        this._y = 0;
	        this._z = 0;
	        this._width = 0;
	        this._height = 0;
	        this._depth = 0;
	        this._centerX = 0;
	        this._centerY = 0;
	        this._centerZ = 0;
	        this._halfExtentsX = 0;
	        this._halfExtentsY = 0;
	        this._halfExtentsZ = 0;
	    }
	    /**
	     * @inheritDoc
	     */
	    AxisAlignedBoundingBox.prototype.nullify = function () {
	        this._x = this._y = this._z = 0;
	        this._width = this._height = this._depth = 0;
	        this._centerX = this._centerY = this._centerZ = 0;
	        this._halfExtentsX = this._halfExtentsY = this._halfExtentsZ = 0;
	    };
	    /**
	     * @inheritDoc
	     */
	    AxisAlignedBoundingBox.prototype.isInFrustum = function (planes, numPlanes) {
	        if (this._pInvalidated)
	            this._pUpdate();
	        for (var i = 0; i < numPlanes; ++i) {
	            var plane = planes[i];
	            var a = plane.a;
	            var b = plane.b;
	            var c = plane.c;
	            var flippedExtentX = a < 0 ? -this._halfExtentsX : this._halfExtentsX;
	            var flippedExtentY = b < 0 ? -this._halfExtentsY : this._halfExtentsY;
	            var flippedExtentZ = c < 0 ? -this._halfExtentsZ : this._halfExtentsZ;
	            var projDist = a * (this._centerX + flippedExtentX) + b * (this._centerY + flippedExtentY) + c * (this._centerZ + flippedExtentZ) - plane.d;
	            if (projDist < 0)
	                return false;
	        }
	        return true;
	    };
	    AxisAlignedBoundingBox.prototype.rayIntersection = function (position, direction, targetNormal) {
	        if (this._pInvalidated)
	            this._pUpdate();
	        return this._box.rayIntersection(position, direction, targetNormal);
	    };
	    AxisAlignedBoundingBox.prototype.classifyToPlane = function (plane) {
	        var a = plane.a;
	        var b = plane.b;
	        var c = plane.c;
	        var centerDistance = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;
	        if (a < 0)
	            a = -a;
	        if (b < 0)
	            b = -b;
	        if (c < 0)
	            c = -c;
	        var boundOffset = a * this._halfExtentsX + b * this._halfExtentsY + c * this._halfExtentsZ;
	        return centerDistance > boundOffset ? PlaneClassification_1.PlaneClassification.FRONT : centerDistance < -boundOffset ? PlaneClassification_1.PlaneClassification.BACK : PlaneClassification_1.PlaneClassification.INTERSECT;
	    };
	    AxisAlignedBoundingBox.prototype._pUpdate = function () {
	        _super.prototype._pUpdate.call(this);
	        this._box = this._pEntity.getBox();
	        var matrix = this._pEntity.sceneTransform;
	        var hx = this._box.width / 2;
	        var hy = this._box.height / 2;
	        var hz = this._box.depth / 2;
	        var cx = this._box.x + hx;
	        var cy = this._box.y + hy;
	        var cz = this._box.z + hz;
	        var raw = matrix.rawData;
	        var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
	        var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
	        var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
	        this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
	        this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
	        this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
	        this._halfExtentsX = Math.abs(hx * m11 + hy * m12 + hz * m13);
	        this._halfExtentsY = Math.abs(hx * m21 + hy * m22 + hz * m23);
	        this._halfExtentsZ = Math.abs(hx * m31 + hy * m32 + hz * m33);
	        if (this._prefab) {
	            this._prefab.width = this._box.width;
	            this._prefab.height = this._box.height;
	            this._prefab.depth = this._box.depth;
	            this._pBoundsPrimitive.transform.matrix3D = matrix;
	        }
	        this._width = this._halfExtentsX * 2;
	        this._height = this._halfExtentsY * 2;
	        this._depth = this._halfExtentsZ * 2;
	        this._x = this._centerX - this._halfExtentsX;
	        this._y = this._centerY - this._halfExtentsY;
	        this._z = this._centerZ - this._halfExtentsZ;
	    };
	    AxisAlignedBoundingBox.prototype._pCreateBoundsPrimitive = function () {
	        this._prefab = new PrimitiveCubePrefab_1.PrimitiveCubePrefab(null, ElementsType_1.ElementsType.LINE);
	        return this._prefab.getNewObject();
	    };
	    return AxisAlignedBoundingBox;
	}(BoundingVolumeBase_1.BoundingVolumeBase));
	exports.AxisAlignedBoundingBox = AxisAlignedBoundingBox;


/***/ },
/* 380 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PlaneClassification_1 = __webpack_require__(141);
	var ElementsType_1 = __webpack_require__(203);
	var BoundingVolumeBase_1 = __webpack_require__(374);
	var PrimitiveSpherePrefab_1 = __webpack_require__(315);
	var BoundingSphere = (function (_super) {
	    __extends(BoundingSphere, _super);
	    function BoundingSphere(entity) {
	        _super.call(this, entity);
	        this._radius = 0;
	        this._centerX = 0;
	        this._centerY = 0;
	        this._centerZ = 0;
	    }
	    BoundingSphere.prototype.nullify = function () {
	        this._centerX = this._centerY = this._centerZ = 0;
	        this._radius = 0;
	    };
	    BoundingSphere.prototype.isInFrustum = function (planes, numPlanes) {
	        if (this._pInvalidated)
	            this._pUpdate();
	        for (var i = 0; i < numPlanes; ++i) {
	            var plane = planes[i];
	            var flippedExtentX = plane.a < 0 ? -this._radius : this._radius;
	            var flippedExtentY = plane.b < 0 ? -this._radius : this._radius;
	            var flippedExtentZ = plane.c < 0 ? -this._radius : this._radius;
	            var projDist = plane.a * (this._centerX + flippedExtentX) + plane.b * (this._centerY + flippedExtentY) + plane.c * (this._centerZ + flippedExtentZ) - plane.d;
	            if (projDist < 0) {
	                return false;
	            }
	        }
	        return true;
	    };
	    BoundingSphere.prototype.rayIntersection = function (position, direction, targetNormal) {
	        if (this._pInvalidated)
	            this._pUpdate();
	        return this._sphere.rayIntersection(position, direction, targetNormal);
	    };
	    //@override
	    BoundingSphere.prototype.classifyToPlane = function (plane) {
	        var a = plane.a;
	        var b = plane.b;
	        var c = plane.c;
	        var dd = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;
	        if (a < 0)
	            a = -a;
	        if (b < 0)
	            b = -b;
	        if (c < 0)
	            c = -c;
	        var rr = (a + b + c) * this._radius;
	        return dd > rr ? PlaneClassification_1.PlaneClassification.FRONT : dd < -rr ? PlaneClassification_1.PlaneClassification.BACK : PlaneClassification_1.PlaneClassification.INTERSECT;
	    };
	    BoundingSphere.prototype._pUpdate = function () {
	        _super.prototype._pUpdate.call(this);
	        this._sphere = this._pEntity.getSphere();
	        var matrix = this._pEntity.sceneTransform;
	        var cx = this._sphere.x;
	        var cy = this._sphere.y;
	        var cz = this._sphere.z;
	        var r = this._sphere.radius;
	        var raw = matrix.rawData;
	        var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
	        var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
	        var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
	        this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
	        this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
	        this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
	        var rx = m11 + m12 + m13;
	        var ry = m21 + m22 + m23;
	        var rz = m31 + m32 + m33;
	        this._radius = r * Math.sqrt((rx * rx + ry * ry + rz * rz) / 3);
	        if (this._prefab) {
	            this._prefab.radius = r;
	            this._pBoundsPrimitive.x = cx;
	            this._pBoundsPrimitive.y = cy;
	            this._pBoundsPrimitive.z = cz;
	            this._pBoundsPrimitive.transform.matrix3D = matrix;
	        }
	    };
	    BoundingSphere.prototype._pCreateBoundsPrimitive = function () {
	        this._prefab = new PrimitiveSpherePrefab_1.PrimitiveSpherePrefab(null, ElementsType_1.ElementsType.LINE);
	        return this._prefab.getNewObject();
	    };
	    return BoundingSphere;
	}(BoundingVolumeBase_1.BoundingVolumeBase));
	exports.BoundingSphere = BoundingSphere;


/***/ },
/* 381 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EntityNode_1 = __webpack_require__(377);
	/**
	 * @class away.partition.DirectionalLightNode
	 */
	var DirectionalLightNode = (function (_super) {
	    __extends(DirectionalLightNode, _super);
	    function DirectionalLightNode() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @inheritDoc
	     */
	    DirectionalLightNode.prototype.acceptTraverser = function (traverser) {
	        if (traverser.enterNode(this))
	            traverser.applyDirectionalLight(this._displayObject);
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    DirectionalLightNode.prototype.isCastingShadow = function () {
	        return false;
	    };
	    return DirectionalLightNode;
	}(EntityNode_1.EntityNode));
	exports.DirectionalLightNode = DirectionalLightNode;


/***/ },
/* 382 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EntityNode_1 = __webpack_require__(377);
	/**
	 * @class away.partition.LightProbeNode
	 */
	var LightProbeNode = (function (_super) {
	    __extends(LightProbeNode, _super);
	    function LightProbeNode() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @inheritDoc
	     */
	    LightProbeNode.prototype.acceptTraverser = function (traverser) {
	        if (traverser.enterNode(this))
	            traverser.applyLightProbe(this._displayObject);
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    LightProbeNode.prototype.isCastingShadow = function () {
	        return false;
	    };
	    return LightProbeNode;
	}(EntityNode_1.EntityNode));
	exports.LightProbeNode = LightProbeNode;


/***/ },
/* 383 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EntityNode_1 = __webpack_require__(377);
	/**
	 * @class away.partition.PointLightNode
	 */
	var PointLightNode = (function (_super) {
	    __extends(PointLightNode, _super);
	    function PointLightNode() {
	        _super.apply(this, arguments);
	    }
	    /**
	     * @inheritDoc
	     */
	    PointLightNode.prototype.acceptTraverser = function (traverser) {
	        if (traverser.enterNode(this))
	            traverser.applyPointLight(this._displayObject);
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    PointLightNode.prototype.isCastingShadow = function () {
	        return false;
	    };
	    return PointLightNode;
	}(EntityNode_1.EntityNode));
	exports.PointLightNode = PointLightNode;


/***/ },
/* 384 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DisplayObjectNode_1 = __webpack_require__(378);
	/**
	 * Maintains scenegraph heirarchy when collecting nodes
	 */
	var SceneGraphNode = (function (_super) {
	    __extends(SceneGraphNode, _super);
	    function SceneGraphNode() {
	        _super.apply(this, arguments);
	        this.isSceneGraphNode = true;
	        this._numNodes = 0;
	        this._pChildNodes = new Array();
	        this._childDepths = new Array();
	        this._numMasks = 0;
	        this._childMasks = new Array();
	    }
	    /**
	     *
	     * @param traverser
	     */
	    SceneGraphNode.prototype.acceptTraverser = function (traverser) {
	        //containers nodes are for ordering only, no need to check enterNode or debugVisible
	        if (this.numEntities == 0)
	            return;
	        var i;
	        for (i = this._numNodes - 1; i >= 0; i--)
	            this._pChildNodes[i].acceptTraverser(traverser);
	        for (i = this._numMasks - 1; i >= 0; i--)
	            this._childMasks[i].acceptTraverser(traverser);
	    };
	    /**
	     *
	     * @param node
	     * @internal
	     */
	    SceneGraphNode.prototype.iAddNode = function (node) {
	        node.parent = this;
	        if (node._displayObject.maskMode) {
	            this._childMasks.push(node);
	            this._numMasks++;
	        }
	        else {
	            var depth = node._displayObject._depthID;
	            var len = this._childDepths.length;
	            var index = len;
	            while (index--)
	                if (this._childDepths[index] < depth)
	                    break;
	            index++;
	            if (index < len) {
	                this._pChildNodes.splice(index, 0, node);
	                this._childDepths.splice(index, 0, depth);
	            }
	            else {
	                this._pChildNodes.push(node);
	                this._childDepths.push(depth);
	            }
	            this._numNodes++;
	        }
	        var numEntities = node.isSceneGraphNode ? node.numEntities : 1;
	        node = this;
	        do {
	            node.numEntities += numEntities;
	        } while ((node = node.parent) != null);
	    };
	    /**
	     *
	     * @param node
	     * @internal
	     */
	    SceneGraphNode.prototype.iRemoveNode = function (node) {
	        if (node._displayObject.maskMode) {
	            this._childMasks.splice(this._childMasks.indexOf(node), 1);
	            this._numMasks--;
	        }
	        else {
	            var index = this._pChildNodes.indexOf(node);
	            this._pChildNodes.splice(index, 1);
	            this._childDepths.splice(index, 1);
	            this._numNodes--;
	        }
	        var numEntities = node.numEntities;
	        node = this;
	        do {
	            node.numEntities -= numEntities;
	        } while ((node = node.parent) != null);
	    };
	    return SceneGraphNode;
	}(DisplayObjectNode_1.DisplayObjectNode));
	exports.SceneGraphNode = SceneGraphNode;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SceneGraphNode;


/***/ },
/* 385 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SceneGraphNode_1 = __webpack_require__(384);
	var PartitionBase_1 = __webpack_require__(375);
	/**
	 * @class away.partition.Partition
	 */
	var SceneGraphPartition = (function (_super) {
	    __extends(SceneGraphPartition, _super);
	    function SceneGraphPartition(root) {
	        _super.call(this, root);
	        this._sceneGraphNodePool = new SceneGraphNodePool();
	    }
	    SceneGraphPartition.prototype.traverse = function (traverser) {
	        _super.prototype.traverse.call(this, traverser);
	    };
	    /**
	     *
	     * @param entity
	     * @returns {away.partition.NodeBase}
	     */
	    SceneGraphPartition.prototype.findParentForNode = function (node) {
	        if (this._root == node._displayObject) {
	            this._rootNode = node;
	            return null;
	        }
	        if (!node.isSceneGraphNode && node._displayObject.isContainer)
	            return this._sceneGraphNodePool.getAbstraction(node._displayObject);
	        return this._sceneGraphNodePool.getAbstraction(node._displayObject.parent);
	    };
	    /**
	     * @internal
	     */
	    SceneGraphPartition.prototype._iRegisterEntity = function (displayObject) {
	        _super.prototype._iRegisterEntity.call(this, displayObject);
	        if (displayObject.isContainer)
	            this.iMarkForUpdate(this._sceneGraphNodePool.getAbstraction(displayObject));
	    };
	    /**
	     * @internal
	     */
	    SceneGraphPartition.prototype._iUnregisterEntity = function (displayObject) {
	        _super.prototype._iUnregisterEntity.call(this, displayObject);
	        if (displayObject.isContainer)
	            this.iRemoveEntity(this._sceneGraphNodePool.getAbstraction(displayObject));
	    };
	    return SceneGraphPartition;
	}(PartitionBase_1.PartitionBase));
	exports.SceneGraphPartition = SceneGraphPartition;
	/**
	 * @class away.pool.SceneGraphNodePool
	 */
	var SceneGraphNodePool = (function () {
	    function SceneGraphNodePool() {
	        this._abstractionPool = new Object();
	    }
	    /**
	     * //TODO
	     *
	     * @param entity
	     * @returns EntityNode
	     */
	    SceneGraphNodePool.prototype.getAbstraction = function (displayObjectContainer) {
	        return (this._abstractionPool[displayObjectContainer.id] || (this._abstractionPool[displayObjectContainer.id] = new SceneGraphNode_1.SceneGraphNode(displayObjectContainer, this)));
	    };
	    /**
	     * //TODO
	     *
	     * @param entity
	     */
	    SceneGraphNodePool.prototype.clearAbstraction = function (displayObjectContainer) {
	        delete this._abstractionPool[displayObjectContainer.id];
	    };
	    return SceneGraphNodePool;
	}());
	exports.SceneGraphNodePool = SceneGraphNodePool;


/***/ },
/* 386 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EntityNode_1 = __webpack_require__(377);
	/**
	 * SkyboxNode is a space partitioning leaf node that contains a Skybox object.
	 *
	 * @class away.partition.SkyboxNode
	 */
	var SkyboxNode = (function (_super) {
	    __extends(SkyboxNode, _super);
	    function SkyboxNode() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     * @param planes
	     * @param numPlanes
	     * @returns {boolean}
	     */
	    SkyboxNode.prototype.isInFrustum = function (planes, numPlanes) {
	        if (!this._displayObject._iIsVisible)
	            return false;
	        //a skybox is always in view unless its visibility is set to false
	        return true;
	    };
	    /**
	     *
	     * @returns {boolean}
	     */
	    SkyboxNode.prototype.isCastingShadow = function () {
	        return false; //skybox never casts shadows
	    };
	    return SkyboxNode;
	}(EntityNode_1.EntityNode));
	exports.SkyboxNode = SkyboxNode;


/***/ },
/* 387 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(388));


/***/ },
/* 388 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var MappingMode_1 = __webpack_require__(137);
	exports.MappingMode = MappingMode_1.MappingMode;
	var Single2DTexture_1 = __webpack_require__(136);
	exports.Single2DTexture = Single2DTexture_1.Single2DTexture;
	var SingleCubeTexture_1 = __webpack_require__(132);
	exports.SingleCubeTexture = SingleCubeTexture_1.SingleCubeTexture;
	var TextureBase_1 = __webpack_require__(133);
	exports.TextureBase = TextureBase_1.TextureBase;


/***/ },
/* 389 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractionBase_1 = __webpack_require__(210);
	/**
	 *
	 * @class away.pool.GL_AttributesBuffer
	 */
	var GL_AttributesBuffer = (function (_super) {
	    __extends(GL_AttributesBuffer, _super);
	    function GL_AttributesBuffer(attributesBuffer, stage) {
	        _super.call(this, attributesBuffer, stage);
	        this._stage = stage;
	        this._attributesBuffer = attributesBuffer;
	    }
	    /**
	     *
	     */
	    GL_AttributesBuffer.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._attributesBuffer = null;
	        if (this._indexBuffer) {
	            this._indexBuffer.dispose();
	            this._indexBuffer = null;
	        }
	        if (this._vertexBuffer) {
	            this._vertexBuffer.dispose();
	            this._vertexBuffer = null;
	        }
	    };
	    GL_AttributesBuffer.prototype.activate = function (index, size, dimensions, offset, unsigned) {
	        if (unsigned === void 0) { unsigned = false; }
	        this._stage.setVertexBuffer(index, this._getVertexBuffer(), size, dimensions, offset, unsigned);
	    };
	    GL_AttributesBuffer.prototype.draw = function (mode, firstIndex, numIndices) {
	        this._stage.context.drawIndices(mode, this._getIndexBuffer(), firstIndex, numIndices);
	    };
	    GL_AttributesBuffer.prototype._getIndexBuffer = function () {
	        if (!this._indexBuffer) {
	            this._invalid = true;
	            this._indexBuffer = this._stage.context.createIndexBuffer(this._attributesBuffer.count * this._attributesBuffer.stride / 2); //hardcoded assuming UintArray
	        }
	        if (this._invalid) {
	            this._invalid = false;
	            this._indexBuffer.uploadFromByteArray(this._attributesBuffer.buffer, 0, this._attributesBuffer.length);
	        }
	        return this._indexBuffer;
	    };
	    GL_AttributesBuffer.prototype._getVertexBuffer = function () {
	        if (!this._vertexBuffer) {
	            this._invalid = true;
	            this._vertexBuffer = this._stage.context.createVertexBuffer(this._attributesBuffer.count, this._attributesBuffer.stride);
	        }
	        if (this._invalid) {
	            this._invalid = false;
	            this._vertexBuffer.uploadFromByteArray(this._attributesBuffer.buffer, 0, this._attributesBuffer.count);
	        }
	        return this._vertexBuffer;
	    };
	    return GL_AttributesBuffer;
	}(AbstractionBase_1.AbstractionBase));
	exports.GL_AttributesBuffer = GL_AttributesBuffer;


/***/ },
/* 390 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MipmapGenerator_1 = __webpack_require__(391);
	var GL_Image2D_1 = __webpack_require__(392);
	/**
	 *
	 * @class away.pool.ImageObjectBase
	 */
	var GL_BitmapImage2D = (function (_super) {
	    __extends(GL_BitmapImage2D, _super);
	    function GL_BitmapImage2D() {
	        _super.apply(this, arguments);
	    }
	    GL_BitmapImage2D.prototype.activate = function (index, mipmap) {
	        if (mipmap && this._stage.globalDisableMipmap)
	            mipmap = false;
	        if (!this._texture) {
	            this._createTexture();
	            this._invalid = true;
	        }
	        if (!this._mipmap && mipmap) {
	            this._mipmap = true;
	            this._invalid = true;
	        }
	        if (this._invalid) {
	            this._invalid = false;
	            this._texture.uploadFromData(this._asset.getImageData(), 0);
	            if (mipmap)
	                this._texture.generateMipmaps();
	        }
	        // if (this._invalid) {
	        // 	this._invalid = false;
	        // 	if (mipmap) {
	        // 		var mipmapData:Array<BitmapImage2D> = this._mipmapData || (this._mipmapData = new Array<BitmapImage2D>());
	        //
	        // 		MipmapGenerator._generateMipMaps((<BitmapImage2D> this._asset).getCanvas(), mipmapData, true);
	        // 		var len:number = mipmapData.length;
	        // 		for (var i:number = 0; i < len; i++)
	        // 			(<ITexture> this._texture).uploadFromData(mipmapData[i].getImageData(), i);
	        // 	} else {
	        // 		(<ITexture> this._texture).uploadFromData((<BitmapImage2D> this._asset).getImageData(), 0);
	        // 	}
	        // }
	        _super.prototype.activate.call(this, index, mipmap);
	    };
	    /**
	     *
	     */
	    GL_BitmapImage2D.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        if (this._mipmapData) {
	            var len = this._mipmapData.length;
	            for (var i = 0; i < len; i++)
	                MipmapGenerator_1.MipmapGenerator._freeMipMapHolder(this._mipmapData[i]);
	        }
	    };
	    return GL_BitmapImage2D;
	}(GL_Image2D_1.GL_Image2D));
	exports.GL_BitmapImage2D = GL_BitmapImage2D;


/***/ },
/* 391 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImage2D_1 = __webpack_require__(95);
	var Matrix_1 = __webpack_require__(102);
	var Rectangle_1 = __webpack_require__(57);
	var MipmapGenerator = (function () {
	    function MipmapGenerator() {
	    }
	    MipmapGenerator._generateMipMaps = function (source, output, alpha) {
	        if (alpha === void 0) { alpha = false; }
	        var w = source.width;
	        var h = source.height;
	        var i = 0;
	        var mipmap;
	        MipmapGenerator._rect.width = w;
	        MipmapGenerator._rect.height = h;
	        //use (OR) to create non-square texture mipmaps
	        while (w >= 1 || h >= 1) {
	            mipmap = output[i] = MipmapGenerator._getMipmapHolder(output[i], MipmapGenerator._rect.width, MipmapGenerator._rect.height);
	            if (alpha)
	                mipmap.fillRect(MipmapGenerator._rect, 0);
	            MipmapGenerator._matrix.a = MipmapGenerator._rect.width / source.width;
	            MipmapGenerator._matrix.d = MipmapGenerator._rect.height / source.height;
	            //todo: add support for NPOT textures
	            if (typeof document !== "undefined") {
	                mipmap.draw(source, MipmapGenerator._matrix); //TODO: smoothing?
	            }
	            else {
	                if (source.constructor.toString().indexOf("BitmapImage2D") > -1) {
	                    //for BitmapImage2D
	                    var bitmapImage = source;
	                    bitmapImage.lock();
	                    mipmap.lock();
	                    this.downsampleImage(bitmapImage.getImageData(), mipmap.getImageData());
	                    mipmap.unlock();
	                    bitmapImage.unlock();
	                }
	                else if (source.constructor.toString().indexOf("CPUCanvas") > -1) {
	                    this.downsampleImage(source.getImageData(), mipmap.getImageData());
	                }
	                else {
	                    //for imageData
	                    this.downsampleImage(source, mipmap.getImageData());
	                }
	            }
	            w >>= 1;
	            h >>= 1;
	            MipmapGenerator._rect.width = w > 1 ? w : 1;
	            MipmapGenerator._rect.height = h > 1 ? h : 1;
	            i++;
	        }
	    };
	    MipmapGenerator._getMipmapHolder = function (mipMapHolder, newW, newH) {
	        if (mipMapHolder) {
	            if (mipMapHolder.width == newW && mipMapHolder.height == newH)
	                return mipMapHolder;
	            MipmapGenerator._freeMipMapHolder(mipMapHolder);
	        }
	        if (!MipmapGenerator._mipMaps[newW]) {
	            MipmapGenerator._mipMaps[newW] = [];
	            MipmapGenerator._mipMapUses[newW] = [];
	        }
	        if (!MipmapGenerator._mipMaps[newW][newH]) {
	            mipMapHolder = MipmapGenerator._mipMaps[newW][newH] = new BitmapImage2D_1.BitmapImage2D(newW, newH, true);
	            MipmapGenerator._mipMapUses[newW][newH] = 1;
	        }
	        else {
	            MipmapGenerator._mipMapUses[newW][newH] = MipmapGenerator._mipMapUses[newW][newH] + 1;
	            mipMapHolder = MipmapGenerator._mipMaps[newW][newH];
	        }
	        return mipMapHolder;
	    };
	    MipmapGenerator._freeMipMapHolder = function (mipMapHolder) {
	        var holderWidth = mipMapHolder.width;
	        var holderHeight = mipMapHolder.height;
	        if (--MipmapGenerator._mipMapUses[holderWidth][holderHeight] == 0) {
	            MipmapGenerator._mipMaps[holderWidth][holderHeight].dispose();
	            MipmapGenerator._mipMaps[holderWidth][holderHeight] = null;
	        }
	    };
	    MipmapGenerator.downsampleImage = function (bitmap, destBitmap) {
	        var box = new BoxFilter();
	        var xkernel = new PolyphaseKernel(box, bitmap.width, destBitmap.width, 4);
	        var ykernel = new PolyphaseKernel(box, bitmap.height, destBitmap.height, 4);
	        var tempBitmap = []; //destBitmap.width, bitmap.height
	        var scale = 0;
	        var iscale = 0;
	        var kernelLength = 0;
	        var kernelWidth = 0;
	        var kernelWindowSize = 0;
	        var sumR = 0;
	        var sumG = 0;
	        var sumB = 0;
	        var sumA = 0;
	        var center;
	        var left;
	        var i = 0;
	        var j = 0;
	        var index = 0;
	        for (var y = 0; y < bitmap.height; y++) {
	            kernelLength = xkernel.len;
	            scale = kernelLength / bitmap.width;
	            iscale = 1.0 / scale;
	            kernelWidth = xkernel.width;
	            kernelWindowSize = xkernel.windowSize;
	            for (i = 0; i < kernelLength; i++) {
	                center = (0.5 + i) * iscale;
	                left = Math.floor(center - kernelWidth);
	                sumR = 0;
	                sumG = 0;
	                sumB = 0;
	                sumA = 0;
	                for (var j = 0; j < kernelWindowSize; ++j) {
	                    index = (y * bitmap.width + (left + j)) * 4;
	                    var colorR = bitmap.data[index];
	                    var colorG = bitmap.data[index + 1];
	                    var colorB = bitmap.data[index + 2];
	                    var colorA = bitmap.data[index + 3];
	                    var value = xkernel.valueAt(i, j);
	                    sumR += value * colorR;
	                    sumG += value * colorG;
	                    sumB += value * colorB;
	                    sumA += value * colorA;
	                }
	                index = (y * destBitmap.width + i) * 4;
	                tempBitmap[index] = sumR;
	                tempBitmap[index + 1] = sumG;
	                tempBitmap[index + 2] = sumB;
	                tempBitmap[index + 3] = sumA;
	            }
	        }
	        for (var x = 0; x < destBitmap.width; x++) {
	            kernelLength = ykernel.len;
	            scale = kernelLength / bitmap.height;
	            iscale = 1.0 / scale;
	            kernelWidth = ykernel.width;
	            kernelWindowSize = ykernel.windowSize;
	            for (i = 0; i < kernelLength; i++) {
	                center = (0.5 + i) * iscale;
	                left = Math.floor(center - kernelWidth);
	                sumR = 0;
	                sumG = 0;
	                sumB = 0;
	                sumA = 0;
	                for (j = 0; j < kernelWindowSize; ++j) {
	                    index = ((j + left) * destBitmap.width + x) * 4;
	                    var colorR = tempBitmap[index];
	                    var colorG = tempBitmap[index + 1];
	                    var colorB = tempBitmap[index + 2];
	                    var colorA = tempBitmap[index + 3];
	                    var value = ykernel.valueAt(i, j);
	                    sumR += value * colorR;
	                    sumG += value * colorG;
	                    sumB += value * colorB;
	                    sumA += value * colorA;
	                }
	                index = (i * destBitmap.width + x) * 4;
	                destBitmap.data[index] = sumR;
	                destBitmap.data[index + 1] = sumG;
	                destBitmap.data[index + 2] = sumB;
	                destBitmap.data[index + 3] = sumA;
	            }
	        }
	        return destBitmap;
	    };
	    MipmapGenerator._mipMaps = [];
	    MipmapGenerator._mipMapUses = [];
	    MipmapGenerator._matrix = new Matrix_1.Matrix();
	    MipmapGenerator._rect = new Rectangle_1.Rectangle();
	    return MipmapGenerator;
	}());
	exports.MipmapGenerator = MipmapGenerator;
	var PolyphaseKernel = (function () {
	    function PolyphaseKernel(f, srcLength, dstLength, samples) {
	        var scale = dstLength / srcLength;
	        var iscale = 1.0 / scale;
	        if (scale > 1) {
	            // Upsampling.
	            samples = 1;
	            scale = 1;
	        }
	        this.len = dstLength;
	        this.width = f.width * iscale;
	        this.windowSize = Math.ceil(this.width * 2);
	        this.data = [];
	        for (var i = 0; i < this.len; i++) {
	            var center = (0.5 + i) * iscale;
	            var left = Math.floor(center - this.width);
	            var total = 0.0;
	            for (var j = 0; j < this.windowSize; j++) {
	                var sample = f.sampleBox(left + j - center, scale, samples);
	                //printf("%f %X\n", sample, *(uint32 *)&sample);
	                this.data[i * this.windowSize + j] = sample;
	                total += sample;
	            }
	            // normalize weights.
	            for (var j = 0; j < this.windowSize; j++) {
	                this.data[i * this.windowSize + j] /= total;
	            }
	        }
	    }
	    PolyphaseKernel.prototype.valueAt = function (column, x) {
	        return this.data[column * this.windowSize + x];
	    };
	    return PolyphaseKernel;
	}());
	exports.PolyphaseKernel = PolyphaseKernel;
	var BoxFilter = (function () {
	    function BoxFilter() {
	    }
	    Object.defineProperty(BoxFilter.prototype, "width", {
	        get: function () {
	            return 0.5;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BoxFilter.prototype.sampleBox = function (x, scale, samples) {
	        var sum = 0;
	        var isamples = 1.0 / samples;
	        for (var s = 0; s < samples; s++) {
	            var p = (x + (s + 0.5) * isamples) * scale;
	            var value = this.evaluate(p);
	            sum += value;
	        }
	        return sum * isamples;
	    };
	    BoxFilter.prototype.evaluate = function (x) {
	        if (Math.abs(x) <= this.width)
	            return 1.0;
	        else
	            return 0.0;
	    };
	    return BoxFilter;
	}());
	exports.BoxFilter = BoxFilter;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = MipmapGenerator;


/***/ },
/* 392 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLTextureFormat_1 = __webpack_require__(50);
	var GL_ImageBase_1 = __webpack_require__(393);
	/**
	 *
	 * @class away.pool.GL_ImageBase
	 */
	var GL_Image2D = (function (_super) {
	    __extends(GL_Image2D, _super);
	    function GL_Image2D() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     * @param context
	     * @returns {ITexture}
	     */
	    GL_Image2D.prototype._createTexture = function () {
	        this._texture = this._stage.context.createTexture(this._asset.width, this._asset.height, ContextGLTextureFormat_1.ContextGLTextureFormat.BGRA, true);
	    };
	    return GL_Image2D;
	}(GL_ImageBase_1.GL_ImageBase));
	exports.GL_Image2D = GL_Image2D;


/***/ },
/* 393 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var AbstractionBase_1 = __webpack_require__(210);
	/**
	 *
	 * @class away.pool.GL_ImageBase
	 */
	var GL_ImageBase = (function (_super) {
	    __extends(GL_ImageBase, _super);
	    function GL_ImageBase(asset, stage) {
	        _super.call(this, asset, stage);
	        this.usages = 0;
	        this._stage = stage;
	    }
	    Object.defineProperty(GL_ImageBase.prototype, "texture", {
	        get: function () {
	            if (!this._texture) {
	                this._createTexture();
	                this._invalid = true;
	            }
	            return this._texture;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    GL_ImageBase.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        if (this._texture) {
	            this._texture.dispose();
	            this._texture = null;
	        }
	    };
	    GL_ImageBase.prototype.activate = function (index, mipmap) {
	        this._stage.context.setTextureAt(index, this._texture);
	    };
	    GL_ImageBase.prototype._createTexture = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    return GL_ImageBase;
	}(AbstractionBase_1.AbstractionBase));
	exports.GL_ImageBase = GL_ImageBase;


/***/ },
/* 394 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MipmapGenerator_1 = __webpack_require__(391);
	var GL_ImageCube_1 = __webpack_require__(395);
	/**
	 *
	 * @class away.pool.ImageObjectBase
	 */
	var GL_BitmapImageCube = (function (_super) {
	    __extends(GL_BitmapImageCube, _super);
	    function GL_BitmapImageCube() {
	        _super.apply(this, arguments);
	        this._mipmapDataArray = new Array(6);
	    }
	    GL_BitmapImageCube.prototype.activate = function (index, mipmap) {
	        if (mipmap && this._stage.globalDisableMipmap)
	            mipmap = false;
	        if (!this._texture) {
	            this._createTexture();
	            this._invalid = true;
	        }
	        if (!this._mipmap && mipmap) {
	            this._mipmap = true;
	            this._invalid = true;
	        }
	        if (this._invalid) {
	            this._invalid = false;
	            for (var i = 0; i < 6; ++i) {
	                if (mipmap) {
	                    var mipmapData = this._mipmapDataArray[i] || (this._mipmapDataArray[i] = new Array());
	                    MipmapGenerator_1.MipmapGenerator._generateMipMaps(this._asset.getCanvas(i), mipmapData, true);
	                    var len = mipmapData.length;
	                    for (var j = 0; j < len; j++)
	                        this._texture.uploadFromData(mipmapData[j].getImageData(), i, j);
	                }
	                else {
	                    this._texture.uploadFromData(this._asset.getImageData(i), i, 0);
	                }
	            }
	        }
	        _super.prototype.activate.call(this, index, mipmap);
	    };
	    /**
	     *
	     */
	    GL_BitmapImageCube.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        for (var i = 0; i < 6; i++) {
	            var mipmapData = this._mipmapDataArray[i];
	            if (mipmapData) {
	                var len = mipmapData.length;
	                for (var j = 0; j < len; i++)
	                    MipmapGenerator_1.MipmapGenerator._freeMipMapHolder(mipmapData[j]);
	            }
	        }
	    };
	    return GL_BitmapImageCube;
	}(GL_ImageCube_1.GL_ImageCube));
	exports.GL_BitmapImageCube = GL_BitmapImageCube;


/***/ },
/* 395 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLTextureFormat_1 = __webpack_require__(50);
	var GL_ImageBase_1 = __webpack_require__(393);
	/**
	 *
	 * @class away.pool.GL_ImageCubeBase
	 */
	var GL_ImageCube = (function (_super) {
	    __extends(GL_ImageCube, _super);
	    function GL_ImageCube() {
	        _super.apply(this, arguments);
	    }
	    /**
	     *
	     * @param context
	     * @returns {ITexture}
	     */
	    GL_ImageCube.prototype._createTexture = function () {
	        this._texture = this._stage.context.createCubeTexture(this._asset.size, ContextGLTextureFormat_1.ContextGLTextureFormat.BGRA, false);
	    };
	    return GL_ImageCube;
	}(GL_ImageBase_1.GL_ImageBase));
	exports.GL_ImageCube = GL_ImageCube;


/***/ },
/* 396 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_Image2D_1 = __webpack_require__(392);
	/**
	 *
	 * @class away.pool.ImageObjectBase
	 */
	var GL_RenderImage2D = (function (_super) {
	    __extends(GL_RenderImage2D, _super);
	    function GL_RenderImage2D() {
	        _super.apply(this, arguments);
	    }
	    GL_RenderImage2D.prototype.activate = function (index, mipmap) {
	        _super.prototype.activate.call(this, index, false);
	        if (!this._mipmap && mipmap) {
	            this._mipmap = true;
	            this._invalid = true;
	        }
	        if (this._invalid) {
	            this._invalid = false;
	            if (mipmap)
	                this._texture.generateMipmaps();
	        }
	    };
	    return GL_RenderImage2D;
	}(GL_Image2D_1.GL_Image2D));
	exports.GL_RenderImage2D = GL_RenderImage2D;


/***/ },
/* 397 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_ImageCube_1 = __webpack_require__(395);
	/**
	 *
	 * @class away.pool.ImageObjectBase
	 */
	var GL_RenderImageCube = (function (_super) {
	    __extends(GL_RenderImageCube, _super);
	    function GL_RenderImageCube() {
	        _super.apply(this, arguments);
	    }
	    GL_RenderImageCube.prototype.activate = function (index, mipmap) {
	        _super.prototype.activate.call(this, index, false);
	        //TODO: allow automatic mipmap generation
	    };
	    return GL_RenderImageCube;
	}(GL_ImageCube_1.GL_ImageCube));
	exports.GL_RenderImageCube = GL_RenderImageCube;


/***/ },
/* 398 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_SamplerBase_1 = __webpack_require__(399);
	/**
	 *
	 * @class away.pool.GL_SamplerBase
	 */
	var GL_Sampler2D = (function (_super) {
	    __extends(GL_Sampler2D, _super);
	    function GL_Sampler2D(sampler, stage) {
	        _super.call(this, sampler, stage);
	        this._sampler = sampler;
	    }
	    GL_Sampler2D.prototype.activate = function (index) {
	        this._stage.setSamplerState(index, this._sampler.repeat, this._sampler.smooth, this._sampler.mipmap);
	    };
	    return GL_Sampler2D;
	}(GL_SamplerBase_1.GL_SamplerBase));
	exports.GL_Sampler2D = GL_Sampler2D;


/***/ },
/* 399 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var AbstractionBase_1 = __webpack_require__(210);
	/**
	 *
	 * @class away.pool.GL_SamplerBase
	 */
	var GL_SamplerBase = (function (_super) {
	    __extends(GL_SamplerBase, _super);
	    function GL_SamplerBase(asset, stage) {
	        _super.call(this, asset, stage);
	        this._stage = stage;
	    }
	    GL_SamplerBase.prototype.activate = function (index) {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    return GL_SamplerBase;
	}(AbstractionBase_1.AbstractionBase));
	exports.GL_SamplerBase = GL_SamplerBase;


/***/ },
/* 400 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_SamplerBase_1 = __webpack_require__(399);
	/**
	 *
	 * @class away.pool.GL_SamplerBase
	 */
	var GL_SamplerCube = (function (_super) {
	    __extends(GL_SamplerCube, _super);
	    function GL_SamplerCube(sampler, stage) {
	        _super.call(this, sampler, stage);
	        this._sampler = sampler;
	    }
	    GL_SamplerCube.prototype.activate = function (index) {
	        this._stage.setSamplerState(index, false, this._sampler.smooth, this._sampler.mipmap);
	    };
	    return GL_SamplerCube;
	}(GL_SamplerBase_1.GL_SamplerBase));
	exports.GL_SamplerCube = GL_SamplerCube;


/***/ },
/* 401 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var ContextGLDrawMode_1 = __webpack_require__(44);
	var ContextGLProgramType_1 = __webpack_require__(47);
	var GL_ElementsBase_1 = __webpack_require__(402);
	/**
	 *
	 * @class away.pool.GL_LineElements
	 */
	var GL_LineElements = (function (_super) {
	    __extends(GL_LineElements, _super);
	    function GL_LineElements(lineElements, stage) {
	        _super.call(this, lineElements, stage);
	        this._calcMatrix = new Matrix3D_1.Matrix3D();
	        this._thickness = 1.25;
	        this._lineElements = lineElements;
	    }
	    Object.defineProperty(GL_LineElements.prototype, "elementsType", {
	        get: function () {
	            return GL_LineElements.elementsType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_LineElements.prototype, "elementsClass", {
	        get: function () {
	            return GL_LineElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GL_LineElements._iIncludeDependencies = function (shader) {
	        shader.colorDependencies++;
	    };
	    GL_LineElements._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        //get the projection coordinates
	        var position0 = (shader.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.animatedPosition;
	        var position1 = registerCache.getFreeVertexAttribute();
	        var thickness = registerCache.getFreeVertexAttribute();
	        //reserving vertex constants for projection matrix
	        var viewMatrixReg = registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        shader.viewMatrixIndex = viewMatrixReg.index * 4;
	        registerCache.getFreeVertexConstant(); // not used
	        var constOne = registerCache.getFreeVertexConstant();
	        var constNegOne = registerCache.getFreeVertexConstant();
	        var misc = registerCache.getFreeVertexConstant();
	        var sceneMatrixReg = registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        shader.sceneMatrixIndex = sceneMatrixReg.index * 4;
	        var q0 = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(q0, 1);
	        var q1 = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(q1, 1);
	        var l = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(l, 1);
	        var behind = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(behind, 1);
	        var qclipped = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(qclipped, 1);
	        var offset = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(offset, 1);
	        return "m44 " + q0 + ", " + position0 + ", " + sceneMatrixReg + "			\n" +
	            "m44 " + q1 + ", " + position1 + ", " + sceneMatrixReg + "			\n" +
	            "sub " + l + ", " + q1 + ", " + q0 + " 			\n" +
	            // test if behind camera near plane
	            // if 0 - Q0.z < Camera.near then the point needs to be clipped
	            "slt " + behind + ".x, " + q0 + ".z, " + misc + ".z			\n" +
	            "sub " + behind + ".y, " + constOne + ".x, " + behind + ".x			\n" +
	            // p = point on the plane (0,0,-near)
	            // n = plane normal (0,0,-1)
	            // D = Q1 - Q0
	            // t = ( dot( n, ( p - Q0 ) ) / ( dot( n, d )
	            // solve for t where line crosses Camera.near
	            "add " + offset + ".x, " + q0 + ".z, " + misc + ".z			\n" +
	            "sub " + offset + ".y, " + q0 + ".z, " + q1 + ".z			\n" +
	            // fix divide by zero for horizontal lines
	            "seq " + offset + ".z, " + offset + ".y " + constNegOne + ".x			\n" +
	            "add " + offset + ".y, " + offset + ".y, " + offset + ".z			\n" +
	            "div " + offset + ".z, " + offset + ".x, " + offset + ".y			\n" +
	            "mul " + offset + ".xyz, " + offset + ".zzz, " + l + ".xyz	\n" +
	            "add " + qclipped + ".xyz, " + q0 + ".xyz, " + offset + ".xyz	\n" +
	            "mov " + qclipped + ".w, " + constOne + ".x			\n" +
	            // If necessary, replace Q0 with new Qclipped
	            "mul " + q0 + ", " + q0 + ", " + behind + ".yyyy			\n" +
	            "mul " + qclipped + ", " + qclipped + ", " + behind + ".xxxx			\n" +
	            "add " + q0 + ", " + q0 + ", " + qclipped + "				\n" +
	            // calculate side vector for line
	            "nrm " + l + ".xyz, " + l + ".xyz			\n" +
	            "nrm " + behind + ".xyz, " + q0 + ".xyz			\n" +
	            "mov " + behind + ".w, " + constOne + ".x				\n" +
	            "crs " + qclipped + ".xyz, " + l + ", " + behind + "			\n" +
	            "nrm " + qclipped + ".xyz, " + qclipped + ".xyz			\n" +
	            // face the side vector properly for the given point
	            "mul " + qclipped + ".xyz, " + qclipped + ".xyz, " + thickness + ".xxx	\n" +
	            "mov " + qclipped + ".w, " + constOne + ".x			\n" +
	            // calculate the amount required to move at the point's distance to correspond to the line's pixel width
	            // scale the side vector by that amount
	            "dp3 " + offset + ".x, " + q0 + ", " + constNegOne + "			\n" +
	            "mul " + offset + ".x, " + offset + ".x, " + misc + ".x			\n" +
	            "mul " + qclipped + ".xyz, " + qclipped + ".xyz, " + offset + ".xxx	\n" +
	            // add scaled side vector to Q0 and transform to clip space
	            "add " + q0 + ".xyz, " + q0 + ".xyz, " + qclipped + ".xyz	\n" +
	            "m44 op, " + q0 + ", " + viewMatrixReg + "			\n"; // transform Q0 to clip space
	    };
	    GL_LineElements._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_LineElements.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._lineElements = null;
	    };
	    GL_LineElements.prototype._setRenderState = function (renderable, shader, camera, viewProjection) {
	        _super.prototype._setRenderState.call(this, renderable, shader, camera, viewProjection);
	        if (shader.colorBufferIndex >= 0)
	            this.activateVertexBufferVO(shader.colorBufferIndex, this._lineElements.colors);
	        this.activateVertexBufferVO(0, this._lineElements.positions, 3);
	        this.activateVertexBufferVO(2, this._lineElements.positions, 3, 12);
	        this.activateVertexBufferVO(3, this._lineElements.thickness);
	        shader.vertexConstantData[4 + 16] = 1;
	        shader.vertexConstantData[5 + 16] = 1;
	        shader.vertexConstantData[6 + 16] = 1;
	        shader.vertexConstantData[7 + 16] = 1;
	        shader.vertexConstantData[10 + 16] = -1;
	        shader.vertexConstantData[12 + 16] = this._thickness / ((this._stage.scissorRect) ? Math.min(this._stage.scissorRect.width, this._stage.scissorRect.height) : Math.min(this._stage.width, this._stage.height));
	        shader.vertexConstantData[13 + 16] = 1 / 255;
	        shader.vertexConstantData[14 + 16] = camera.projection.near;
	        var context = this._stage.context;
	    };
	    GL_LineElements.prototype.draw = function (renderable, shader, camera, viewProjection, count, offset) {
	        var context = this._stage.context;
	        // projection matrix
	        camera.projection.matrix.copyRawDataTo(shader.vertexConstantData, shader.viewMatrixIndex, true);
	        this._calcMatrix.copyFrom(renderable.sourceEntity.sceneTransform);
	        this._calcMatrix.append(camera.inverseSceneTransform);
	        this._calcMatrix.copyRawDataTo(shader.vertexConstantData, shader.sceneMatrixIndex, true);
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.VERTEX, shader.vertexConstantData);
	        if (this._indices)
	            this.getIndexBufferGL().draw(ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES, 0, this.numIndices);
	        else
	            this._stage.context.drawVertices(ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES, offset, count || this.numVertices);
	    };
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param renderable
	     * @param level
	     * @param indexOffset
	     * @returns {away.pool.LineSubSpriteRenderable}
	     * @protected
	     */
	    GL_LineElements.prototype._pGetOverflowElements = function () {
	        return new GL_LineElements(this._lineElements, this._stage);
	    };
	    GL_LineElements.elementsType = "[elements Line]";
	    return GL_LineElements;
	}(GL_ElementsBase_1.GL_ElementsBase));
	exports.GL_LineElements = GL_LineElements;


/***/ },
/* 402 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractionBase_1 = __webpack_require__(210);
	var AbstractMethodError_1 = __webpack_require__(7);
	var AssetEvent_1 = __webpack_require__(9);
	var ElementsEvent_1 = __webpack_require__(127);
	var ElementsUtils_1 = __webpack_require__(128);
	/**
	 *
	 * @class away.pool.GL_ElementsBaseBase
	 */
	var GL_ElementsBase = (function (_super) {
	    __extends(GL_ElementsBase, _super);
	    function GL_ElementsBase(elements, stage) {
	        var _this = this;
	        _super.call(this, elements, stage);
	        this.usages = 0;
	        this._vertices = new Object();
	        this._verticesUpdated = new Object();
	        this._indexMappings = Array();
	        this._numIndices = 0;
	        this._elements = elements;
	        this._stage = stage;
	        this._onInvalidateIndicesDelegate = function (event) { return _this._onInvalidateIndices(event); };
	        this._onClearIndicesDelegate = function (event) { return _this._onClearIndices(event); };
	        this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
	        this._onClearVerticesDelegate = function (event) { return _this._onClearVertices(event); };
	        this._elements.addEventListener(ElementsEvent_1.ElementsEvent.CLEAR_INDICES, this._onClearIndicesDelegate);
	        this._elements.addEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_INDICES, this._onInvalidateIndicesDelegate);
	        this._elements.addEventListener(ElementsEvent_1.ElementsEvent.CLEAR_VERTICES, this._onClearVerticesDelegate);
	        this._elements.addEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	    }
	    Object.defineProperty(GL_ElementsBase.prototype, "elementsType", {
	        get: function () {
	            throw new AbstractMethodError_1.AbstractMethodError();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_ElementsBase.prototype, "elementsClass", {
	        get: function () {
	            throw new AbstractMethodError_1.AbstractMethodError();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_ElementsBase.prototype, "elements", {
	        get: function () {
	            return this._elements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_ElementsBase.prototype, "numIndices", {
	        /**
	         *
	         */
	        get: function () {
	            return this._numIndices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_ElementsBase.prototype, "numVertices", {
	        /**
	         *
	         */
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.getIndexMappings = function () {
	        if (!this._indicesUpdated)
	            this._updateIndices();
	        return this._indexMappings;
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.getIndexBufferGL = function () {
	        if (!this._indicesUpdated)
	            this._updateIndices();
	        return this._indices;
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.getVertexBufferGL = function (attributesView) {
	        //first check if indices need updating which may affect vertices
	        if (!this._indicesUpdated)
	            this._updateIndices();
	        var bufferId = attributesView.attributesBuffer.id;
	        if (!this._verticesUpdated[bufferId])
	            this._updateVertices(attributesView);
	        return this._vertices[bufferId];
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.activateVertexBufferVO = function (index, attributesView, dimensions, offset) {
	        if (dimensions === void 0) { dimensions = 0; }
	        if (offset === void 0) { offset = 0; }
	        this.getVertexBufferGL(attributesView).activate(index, attributesView.size, dimensions || attributesView.dimensions, attributesView.offset + offset, attributesView.unsigned);
	    };
	    /**
	     *
	     */
	    GL_ElementsBase.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._elements.removeEventListener(ElementsEvent_1.ElementsEvent.CLEAR_INDICES, this._onClearIndicesDelegate);
	        this._elements.removeEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_INDICES, this._onInvalidateIndicesDelegate);
	        this._elements.removeEventListener(ElementsEvent_1.ElementsEvent.CLEAR_VERTICES, this._onClearVerticesDelegate);
	        this._elements.removeEventListener(ElementsEvent_1.ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
	        this._elements = null;
	        if (this._overflow) {
	            this._overflow.onClear(event);
	            this._overflow = null;
	        }
	    };
	    GL_ElementsBase.prototype._setRenderState = function (renderable, shader, camera, viewProjection) {
	        if (!this._verticesUpdated)
	            this._updateIndices();
	        //TODO replace overflow system with something sensible
	        //this._render(renderable, camera, viewProjection);
	        //
	        // if (this._overflow)
	        // 	this._overflow._iRender(renderable, camera, viewProjection);
	    };
	    GL_ElementsBase.prototype.draw = function (renderable, shader, camera, viewProjection, count, offset, idx_count, idx_offset) {
	        if (idx_count === void 0) { idx_count = 0; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * //TODO
	     *
	     * @private
	     */
	    GL_ElementsBase.prototype._updateIndices = function (indexOffset) {
	        if (indexOffset === void 0) { indexOffset = 0; }
	        var indices = this._elements.indices;
	        if (indices) {
	            this._indices = this._stage.getAbstraction(ElementsUtils_1.ElementsUtils.getSubIndices(indices, this._elements.numVertices, this._indexMappings, indexOffset));
	            this._numIndices = this._indices._attributesBuffer.count * indices.dimensions;
	        }
	        else {
	            this._indices = null;
	            this._numIndices = 0;
	            this._indexMappings = Array();
	        }
	        indexOffset += this._numIndices;
	        //check if there is more to split
	        if (indices && indexOffset < indices.count * this._elements.indices.dimensions) {
	            if (!this._overflow)
	                this._overflow = this._pGetOverflowElements();
	            this._overflow._updateIndices(indexOffset);
	        }
	        else if (this._overflow) {
	            this._overflow.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._elements));
	            this._overflow = null;
	        }
	        this._indicesUpdated = true;
	        //invalidate vertices if index mappings exist
	        if (this._indexMappings.length)
	            for (var key in this._verticesUpdated)
	                this._verticesUpdated[key] = false;
	    };
	    /**
	     * //TODO
	     *
	     * @param attributesView
	     * @private
	     */
	    GL_ElementsBase.prototype._updateVertices = function (attributesView) {
	        this._numVertices = this._elements.numVertices;
	        var bufferId = attributesView.attributesBuffer.id;
	        this._vertices[bufferId] = this._stage.getAbstraction(ElementsUtils_1.ElementsUtils.getSubVertices(attributesView.attributesBuffer, this._indexMappings));
	        this._verticesUpdated[bufferId] = true;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onInvalidateIndices = function (event) {
	        if (!event.attributesView)
	            return;
	        this._indicesUpdated = false;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onClearIndices = function (event) {
	        if (!event.attributesView)
	            return;
	        this._indices.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, event.attributesView));
	        this._indices = null;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onInvalidateVertices = function (event) {
	        if (!event.attributesView)
	            return;
	        var bufferId = event.attributesView.attributesBuffer.id;
	        this._verticesUpdated[bufferId] = false;
	    };
	    /**
	     * //TODO
	     *
	     * @param event
	     * @private
	     */
	    GL_ElementsBase.prototype._onClearVertices = function (event) {
	        if (!event.attributesView)
	            return;
	        var bufferId = event.attributesView.attributesBuffer.id;
	        if (this._vertices[bufferId]) {
	            this._vertices[bufferId].onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, event.attributesView));
	            delete this._vertices[bufferId];
	            delete this._verticesUpdated[bufferId];
	        }
	    };
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param renderable
	     * @param level
	     * @param indexOffset
	     * @returns {away.pool.GL_GraphicRenderable}
	     * @protected
	     */
	    GL_ElementsBase.prototype._pGetOverflowElements = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    return GL_ElementsBase;
	}(AbstractionBase_1.AbstractionBase));
	exports.GL_ElementsBase = GL_ElementsBase;


/***/ },
/* 403 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3DUtils_1 = __webpack_require__(38);
	var ContextGLDrawMode_1 = __webpack_require__(44);
	var ContextGLProgramType_1 = __webpack_require__(47);
	var GL_ElementsBase_1 = __webpack_require__(402);
	/**
	 *
	 * @class away.pool.GL_TriangleElements
	 */
	var GL_TriangleElements = (function (_super) {
	    __extends(GL_TriangleElements, _super);
	    function GL_TriangleElements(triangleElements, stage) {
	        _super.call(this, triangleElements, stage);
	        this._triangleElements = triangleElements;
	    }
	    Object.defineProperty(GL_TriangleElements.prototype, "elementsType", {
	        get: function () {
	            return GL_TriangleElements.elementsType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_TriangleElements.prototype, "elementsClass", {
	        get: function () {
	            return GL_TriangleElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GL_TriangleElements._iIncludeDependencies = function (shader) {
	    };
	    GL_TriangleElements._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        //get the projection coordinates
	        var position = (shader.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.animatedPosition;
	        //reserving vertex constants for projection matrix
	        var viewMatrixReg = registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        shader.viewMatrixIndex = viewMatrixReg.index * 4;
	        if (shader.projectionDependencies > 0) {
	            sharedRegisters.projectionFragment = registerCache.getFreeVarying();
	            var temp = registerCache.getFreeVertexVectorTemp();
	            code += "m44 " + temp + ", " + position + ", " + viewMatrixReg + "\n" +
	                "mov " + sharedRegisters.projectionFragment + ", " + temp + "\n" +
	                "mov op, " + temp + "\n";
	        }
	        else {
	            code += "m44 op, " + position + ", " + viewMatrixReg + "\n";
	        }
	        return code;
	    };
	    GL_TriangleElements._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_TriangleElements.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._triangleElements = null;
	    };
	    GL_TriangleElements.prototype._setRenderState = function (renderable, shader, camera, viewProjection) {
	        _super.prototype._setRenderState.call(this, renderable, shader, camera, viewProjection);
	        //set buffers
	        //TODO: find a better way to update a concatenated buffer when autoderiving
	        if (shader.normalIndex >= 0 && this._triangleElements.autoDeriveNormals)
	            this._triangleElements.normals;
	        if (shader.tangentIndex >= 0 && this._triangleElements.autoDeriveTangents)
	            this._triangleElements.tangents;
	        if (shader.curvesIndex >= 0)
	            this.activateVertexBufferVO(shader.curvesIndex, this._triangleElements.getCustomAtributes("curves"));
	        if (shader.uvIndex >= 0)
	            this.activateVertexBufferVO(shader.uvIndex, this._triangleElements.uvs || this._triangleElements.positions);
	        if (shader.secondaryUVIndex >= 0)
	            this.activateVertexBufferVO(shader.secondaryUVIndex, this._triangleElements.getCustomAtributes("secondaryUVs") || this._triangleElements.uvs || this._triangleElements.positions);
	        if (shader.normalIndex >= 0)
	            this.activateVertexBufferVO(shader.normalIndex, this._triangleElements.normals);
	        if (shader.tangentIndex >= 0)
	            this.activateVertexBufferVO(shader.tangentIndex, this._triangleElements.tangents);
	        if (shader.jointIndexIndex >= 0)
	            this.activateVertexBufferVO(shader.jointIndexIndex, this._triangleElements.jointIndices);
	        if (shader.jointWeightIndex >= 0)
	            this.activateVertexBufferVO(shader.jointIndexIndex, this._triangleElements.jointWeights);
	        this.activateVertexBufferVO(0, this._triangleElements.positions);
	    };
	    GL_TriangleElements.prototype.draw = function (renderable, shader, camera, viewProjection, count, offset, idx_count, idx_offset) {
	        if (idx_count === void 0) { idx_count = this.numIndices; }
	        if (idx_offset === void 0) { idx_offset = 0; }
	        //set constants
	        if (shader.sceneMatrixIndex >= 0) {
	            renderable.renderSceneTransform.copyRawDataTo(shader.vertexConstantData, shader.sceneMatrixIndex, true);
	            viewProjection.copyRawDataTo(shader.vertexConstantData, shader.viewMatrixIndex, true);
	        }
	        else {
	            var matrix3D = Matrix3DUtils_1.Matrix3DUtils.CALCULATION_MATRIX;
	            matrix3D.copyFrom(renderable.renderSceneTransform);
	            matrix3D.append(viewProjection);
	            matrix3D.copyRawDataTo(shader.vertexConstantData, shader.viewMatrixIndex, true);
	        }
	        var context = this._stage.context;
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.VERTEX, shader.vertexConstantData);
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.FRAGMENT, shader.fragmentConstantData);
	        if (this._indices)
	            this.getIndexBufferGL().draw(ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES, idx_offset, idx_count || this.numIndices);
	        else
	            this._stage.context.drawVertices(ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES, offset, count || this.numVertices);
	    };
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param renderable
	     * @param level
	     * @param indexOffset
	     * @returns {away.pool.GL_GraphicRenderable}
	     * @protected
	     */
	    GL_TriangleElements.prototype._pGetOverflowElements = function () {
	        return new GL_TriangleElements(this._triangleElements, this._stage);
	    };
	    GL_TriangleElements.elementsType = "[elements Triangle]";
	    return GL_TriangleElements;
	}(GL_ElementsBase_1.GL_ElementsBase));
	exports.GL_TriangleElements = GL_TriangleElements;


/***/ },
/* 404 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var TriangleElements_1 = __webpack_require__(179);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var GL_RenderableBase_1 = __webpack_require__(405);
	/**
	 * @class away.pool.RenderableListItem
	 */
	var GL_BillboardRenderable = (function (_super) {
	    __extends(GL_BillboardRenderable, _super);
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param billboard
	     */
	    function GL_BillboardRenderable(billboard, renderer) {
	        _super.call(this, billboard, renderer);
	        this._billboard = billboard;
	    }
	    GL_BillboardRenderable.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._billboard = null;
	    };
	    /**
	     * //TODO
	     *
	     * @returns {away.base.TriangleElements}
	     */
	    GL_BillboardRenderable.prototype._pGetElements = function () {
	        var texture = this._billboard.material.getTextureAt(0);
	        var id = -1;
	        if (texture)
	            id = ((this.renderable.style ? this.renderable.style.getSamplerAt(texture) || texture.getSamplerAt(0) : texture.getSamplerAt(0)) || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultSampler()).id;
	        this._id = id;
	        var elements = GL_BillboardRenderable._samplerElements[id];
	        var width = this._billboard.billboardWidth;
	        var height = this._billboard.billboardHeight;
	        var billboardRect = this._billboard.billboardRect;
	        if (!elements) {
	            elements = GL_BillboardRenderable._samplerElements[id] = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer(11, 4));
	            elements.autoDeriveNormals = false;
	            elements.autoDeriveTangents = false;
	            elements.setIndices(Array(0, 1, 2, 0, 2, 3));
	            elements.setPositions(Array(-billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, -billboardRect.y, 0, -billboardRect.x, -billboardRect.y, 0));
	            elements.setNormals(Array(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0));
	            elements.setTangents(Array(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1));
	            elements.setUVs(Array(0, 0, 1, 0, 1, 1, 0, 1));
	        }
	        else {
	            elements.setPositions(Array(-billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, -billboardRect.y, 0, -billboardRect.x, -billboardRect.y, 0));
	        }
	        return this._stage.getAbstraction(elements);
	    };
	    GL_BillboardRenderable.prototype._pGetSurface = function () {
	        return this._renderer.getSurfacePool(this.elementsGL).getAbstraction(this._billboard.material || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial(this.renderable));
	    };
	    GL_BillboardRenderable._samplerElements = new Object();
	    return GL_BillboardRenderable;
	}(GL_RenderableBase_1.GL_RenderableBase));
	exports.GL_BillboardRenderable = GL_BillboardRenderable;


/***/ },
/* 405 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var AssetEvent_1 = __webpack_require__(9);
	var AbstractionBase_1 = __webpack_require__(210);
	var RenderableEvent_1 = __webpack_require__(118);
	/**
	 * @class RenderableListItem
	 */
	var GL_RenderableBase = (function (_super) {
	    __extends(GL_RenderableBase, _super);
	    /**
	     *
	     * @param renderable
	     * @param sourceEntity
	     * @param surface
	     * @param renderer
	     */
	    function GL_RenderableBase(renderable, renderer) {
	        var _this = this;
	        _super.call(this, renderable, renderer);
	        this._count = 0;
	        this._offset = 0;
	        this._idx_count = 0;
	        this._idx_offset = 0;
	        this._elementsDirty = true;
	        this._surfaceDirty = true;
	        this.images = new Array();
	        this.samplers = new Array();
	        this._onInvalidateSurfaceDelegate = function (event) { return _this._onInvalidateSurface(event); };
	        this._onInvalidateElementsDelegate = function (event) { return _this.onInvalidateElements(event); };
	        //store a reference to the pool for later disposal
	        this._renderer = renderer;
	        this._stage = renderer.stage;
	        this.renderable = renderable;
	        this.renderable.addEventListener(RenderableEvent_1.RenderableEvent.INVALIDATE_SURFACE, this._onInvalidateSurfaceDelegate);
	        this.renderable.addEventListener(RenderableEvent_1.RenderableEvent.INVALIDATE_ELEMENTS, this._onInvalidateElementsDelegate);
	    }
	    Object.defineProperty(GL_RenderableBase.prototype, "elementsGL", {
	        get: function () {
	            if (this._elementsDirty)
	                this._updateElements();
	            return this._elementsGL;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_RenderableBase.prototype, "surfaceGL", {
	        get: function () {
	            if (this._surfaceDirty)
	                this._updateSurface();
	            return this._surfaceGL;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GL_RenderableBase.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this.next = null;
	        this.masksConfig = null;
	        this.renderSceneTransform = null;
	        this._renderer = null;
	        this._stage = null;
	        this.sourceEntity = null;
	        this.renderable.removeEventListener(RenderableEvent_1.RenderableEvent.INVALIDATE_SURFACE, this._onInvalidateSurfaceDelegate);
	        this.renderable.removeEventListener(RenderableEvent_1.RenderableEvent.INVALIDATE_ELEMENTS, this._onInvalidateElementsDelegate);
	        this.renderable = null;
	        this._surfaceGL.usages--;
	        if (!this._surfaceGL.usages)
	            this._surfaceGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._surfaceGL.surface));
	        this._surfaceGL = null;
	        this._elementsGL = null;
	    };
	    GL_RenderableBase.prototype.onInvalidateElements = function (event) {
	        this._elementsDirty = true;
	    };
	    GL_RenderableBase.prototype._onInvalidateSurface = function (event) {
	        this._surfaceDirty = true;
	    };
	    GL_RenderableBase.prototype._pGetElements = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    GL_RenderableBase.prototype._pGetSurface = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    /**
	     * Renders an object to the current render target.
	     *
	     * @private
	     */
	    GL_RenderableBase.prototype._iRender = function (pass, camera, viewProjection) {
	        this._setRenderState(pass, camera, viewProjection);
	        this._elementsGL.draw(this, pass.shader, camera, viewProjection, this._count, this._offset, this._idx_count, this._idx_offset);
	    };
	    GL_RenderableBase.prototype._setRenderState = function (pass, camera, viewProjection) {
	        if (this._elementsDirty)
	            this._updateElements();
	        pass._setRenderState(this, camera, viewProjection);
	        if (pass.shader.activeElements != this._elementsGL) {
	            pass.shader.activeElements = this._elementsGL;
	            this._elementsGL._setRenderState(this, pass.shader, camera, viewProjection);
	        }
	    };
	    /**
	     * //TODO
	     *
	     * @private
	     */
	    GL_RenderableBase.prototype._updateElements = function () {
	        this._elementsGL = this._pGetElements();
	        this._elementsDirty = false;
	    };
	    GL_RenderableBase.prototype._updateSurface = function () {
	        var surfaceGL = this._pGetSurface();
	        if (this._surfaceGL != surfaceGL) {
	            if (this._surfaceGL) {
	                this._surfaceGL.usages--;
	                //dispose current surfaceGL object
	                if (!this._surfaceGL.usages)
	                    this._surfaceGL.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._surfaceGL.surface));
	            }
	            this._surfaceGL = surfaceGL;
	            this._surfaceGL.usages++;
	        }
	        //create a cache of image & sampler objects for the renderable
	        var numImages = surfaceGL.numImages;
	        this.images.length = numImages;
	        this.samplers.length = numImages;
	        this.uvMatrix = this.renderable.style ? this.renderable.style.uvMatrix : this._surfaceGL.surface.style ? this._surfaceGL.surface.style.uvMatrix : null;
	        var numTextures = this._surfaceGL.surface.getNumTextures();
	        var texture;
	        var numImages;
	        var image;
	        var sampler;
	        var index;
	        for (var i = 0; i < numTextures; i++) {
	            texture = this._surfaceGL.surface.getTextureAt(i);
	            numImages = texture.getNumImages();
	            for (var j = 0; j < numImages; j++) {
	                index = surfaceGL.getImageIndex(texture, j);
	                image = this.renderable.style ? this.renderable.style.getImageAt(texture, j) : null;
	                this.images[index] = image ? this._stage.getAbstraction(image) : null;
	                sampler = this.renderable.style ? this.renderable.style.getSamplerAt(texture, j) : null;
	                this.samplers[index] = sampler ? this._stage.getAbstraction(sampler) : null;
	            }
	        }
	        this._surfaceDirty = false;
	    };
	    return GL_RenderableBase;
	}(AbstractionBase_1.AbstractionBase));
	exports.GL_RenderableBase = GL_RenderableBase;


/***/ },
/* 406 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var GL_RenderableBase_1 = __webpack_require__(405);
	/**
	 * @class away.pool.GL_GraphicRenderable
	 */
	var GL_GraphicRenderable = (function (_super) {
	    __extends(GL_GraphicRenderable, _super);
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param graphic
	     * @param level
	     * @param indexOffset
	     */
	    function GL_GraphicRenderable(graphic, renderer) {
	        _super.call(this, graphic, renderer);
	        this.graphic = graphic;
	    }
	    GL_GraphicRenderable.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this.graphic = null;
	    };
	    /**
	     *
	     * @returns {ElementsBase}
	     * @protected
	     */
	    GL_GraphicRenderable.prototype._pGetElements = function () {
	        this._offset = this.graphic.offset;
	        this._count = this.graphic.count;
	        this._idx_offset = this.graphic.idx_offset;
	        this._idx_count = this.graphic.idx_count;
	        return this._stage.getAbstraction((this.renderable.animator) ? this.renderable.animator.getRenderableElements(this, this.graphic.elements) : this.graphic.elements);
	    };
	    GL_GraphicRenderable.prototype._pGetSurface = function () {
	        return this._renderer.getSurfacePool(this.elementsGL).getAbstraction(this.graphic.material || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial(this.renderable));
	    };
	    return GL_GraphicRenderable;
	}(GL_RenderableBase_1.GL_RenderableBase));
	exports.GL_GraphicRenderable = GL_GraphicRenderable;


/***/ },
/* 407 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var LineElements_1 = __webpack_require__(125);
	var DefaultMaterialManager_1 = __webpack_require__(120);
	var GL_RenderableBase_1 = __webpack_require__(405);
	/**
	 * @class away.pool.GL_LineSegmentRenderable
	 */
	var GL_LineSegmentRenderable = (function (_super) {
	    __extends(GL_LineSegmentRenderable, _super);
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param graphic
	     * @param level
	     * @param dataOffset
	     */
	    function GL_LineSegmentRenderable(lineSegment, renderer) {
	        _super.call(this, lineSegment, renderer);
	        this._lineSegment = lineSegment;
	    }
	    GL_LineSegmentRenderable.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._lineSegment = null;
	    };
	    /**
	     * //TODO
	     *
	     * @returns {base.LineElements}
	     * @protected
	     */
	    GL_LineSegmentRenderable.prototype._pGetElements = function () {
	        var elements = GL_LineSegmentRenderable._lineGraphics[this._lineSegment.id] || (GL_LineSegmentRenderable._lineGraphics[this._lineSegment.id] = new LineElements_1.LineElements());
	        var start = this._lineSegment.startPostion;
	        var end = this._lineSegment.endPosition;
	        var positions = new Float32Array(6);
	        var thickness = new Float32Array(1);
	        positions[0] = start.x;
	        positions[1] = start.y;
	        positions[2] = start.z;
	        positions[3] = end.x;
	        positions[4] = end.y;
	        positions[5] = end.z;
	        thickness[0] = this._lineSegment.thickness;
	        elements.setPositions(positions);
	        elements.setThickness(thickness);
	        return this._stage.getAbstraction(elements);
	    };
	    GL_LineSegmentRenderable.prototype._pGetSurface = function () {
	        return this._renderer.getSurfacePool(this.elementsGL).getAbstraction(this._lineSegment.material || DefaultMaterialManager_1.DefaultMaterialManager.getDefaultMaterial(this.renderable));
	    };
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param renderable
	     * @param level
	     * @param indexOffset
	     * @returns {away.pool.LineSubSpriteRenderable}
	     * @private
	     */
	    GL_LineSegmentRenderable.prototype._pGetOverflowRenderable = function (indexOffset) {
	        return new GL_LineSegmentRenderable(this.renderable, this._renderer);
	    };
	    GL_LineSegmentRenderable._lineGraphics = new Object();
	    return GL_LineSegmentRenderable;
	}(GL_RenderableBase_1.GL_RenderableBase));
	exports.GL_LineSegmentRenderable = GL_LineSegmentRenderable;


/***/ },
/* 408 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AttributesBuffer_1 = __webpack_require__(5);
	var TriangleElements_1 = __webpack_require__(179);
	var GL_RenderableBase_1 = __webpack_require__(405);
	var GL_SkyboxElements_1 = __webpack_require__(409);
	/**
	 * @class away.pool.GL_SkyboxRenderable
	 */
	var GL_SkyboxRenderable = (function (_super) {
	    __extends(GL_SkyboxRenderable, _super);
	    /**
	     * //TODO
	     *
	     * @param pool
	     * @param skybox
	     */
	    function GL_SkyboxRenderable(skybox, renderer) {
	        _super.call(this, skybox, renderer);
	        this._skybox = skybox;
	    }
	    /**
	     * //TODO
	     *
	     * @returns {away.base.TriangleElements}
	     * @private
	     */
	    GL_SkyboxRenderable.prototype._pGetElements = function () {
	        var elementsGL = GL_SkyboxRenderable._elementsGL;
	        if (!elementsGL) {
	            var elements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer(11, 4));
	            elements.autoDeriveNormals = false;
	            elements.autoDeriveTangents = false;
	            elements.setIndices(Array(0, 1, 2, 2, 3, 0, 6, 5, 4, 4, 7, 6, 2, 6, 7, 7, 3, 2, 4, 5, 1, 1, 0, 4, 4, 0, 3, 3, 7, 4, 2, 1, 5, 5, 6, 2));
	            elements.setPositions(Array(-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1));
	            elementsGL = GL_SkyboxRenderable._elementsGL = new GL_SkyboxElements_1.GL_SkyboxElements(elements, this._stage);
	        }
	        return elementsGL;
	    };
	    GL_SkyboxRenderable.prototype._pGetSurface = function () {
	        return this._renderer.getSurfacePool(this.elementsGL).getAbstraction(this._skybox);
	    };
	    GL_SkyboxRenderable._iIncludeDependencies = function (shader) {
	    };
	    return GL_SkyboxRenderable;
	}(GL_RenderableBase_1.GL_RenderableBase));
	exports.GL_SkyboxRenderable = GL_SkyboxRenderable;


/***/ },
/* 409 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLDrawMode_1 = __webpack_require__(44);
	var ContextGLProgramType_1 = __webpack_require__(47);
	var GL_TriangleElements_1 = __webpack_require__(403);
	/**
	 *
	 * @class away.pool.GL_SkyboxElements
	 */
	var GL_SkyboxElements = (function (_super) {
	    __extends(GL_SkyboxElements, _super);
	    function GL_SkyboxElements() {
	        _super.apply(this, arguments);
	        this._skyboxProjection = new Matrix3D_1.Matrix3D();
	    }
	    Object.defineProperty(GL_SkyboxElements.prototype, "elementsType", {
	        get: function () {
	            return GL_SkyboxElements.elementsType;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SkyboxElements.prototype, "elementsClass", {
	        get: function () {
	            return GL_SkyboxElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    GL_SkyboxElements._iIncludeDependencies = function (shader) {
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_SkyboxElements._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        //get the projection coordinates
	        var position = (shader.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.animatedPosition;
	        //reserving vertex constants for projection matrix
	        var viewMatrixReg = registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        shader.viewMatrixIndex = viewMatrixReg.index * 4;
	        var scenePosition = registerCache.getFreeVertexConstant();
	        shader.scenePositionIndex = scenePosition.index * 4;
	        var skyboxScale = registerCache.getFreeVertexConstant();
	        var temp = registerCache.getFreeVertexVectorTemp();
	        code += "mul " + temp + ", " + position + ", " + skyboxScale + "\n" +
	            "add " + temp + ", " + temp + ", " + scenePosition + "\n";
	        if (shader.projectionDependencies > 0) {
	            sharedRegisters.projectionFragment = registerCache.getFreeVarying();
	            code += "m44 " + temp + ", " + temp + ", " + viewMatrixReg + "\n" +
	                "mov " + sharedRegisters.projectionFragment + ", " + temp + "\n" +
	                "mov op, " + temp + "\n";
	        }
	        else {
	            code += "m44 op, " + temp + ", " + viewMatrixReg + "\n";
	        }
	        return code;
	    };
	    GL_SkyboxElements._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SkyboxElements.prototype.draw = function (renderable, shader, camera, viewProjection, count, offset) {
	        var index = shader.scenePositionIndex;
	        var pos = camera.scenePosition;
	        shader.vertexConstantData[index++] = 2 * pos.x;
	        shader.vertexConstantData[index++] = 2 * pos.y;
	        shader.vertexConstantData[index++] = 2 * pos.z;
	        shader.vertexConstantData[index++] = 1;
	        shader.vertexConstantData[index++] = shader.vertexConstantData[index++] = shader.vertexConstantData[index++] = camera.projection.far / Math.sqrt(3);
	        shader.vertexConstantData[index] = 1;
	        var near = new Vector3D_1.Vector3D();
	        this._skyboxProjection.copyFrom(viewProjection);
	        this._skyboxProjection.copyRowTo(2, near);
	        var camPos = camera.scenePosition;
	        var cx = near.x;
	        var cy = near.y;
	        var cz = near.z;
	        var cw = -(near.x * camPos.x + near.y * camPos.y + near.z * camPos.z + Math.sqrt(cx * cx + cy * cy + cz * cz));
	        var signX = cx >= 0 ? 1 : -1;
	        var signY = cy >= 0 ? 1 : -1;
	        var p = new Vector3D_1.Vector3D(signX, signY, 1, 1);
	        var inverse = this._skyboxProjection.clone();
	        inverse.invert();
	        var q = inverse.transformVector(p);
	        this._skyboxProjection.copyRowTo(3, p);
	        var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);
	        this._skyboxProjection.copyRowFrom(2, new Vector3D_1.Vector3D(cx * a, cy * a, cz * a, cw * a));
	        //set constants
	        if (shader.sceneMatrixIndex >= 0) {
	            renderable.renderSceneTransform.copyRawDataTo(shader.vertexConstantData, shader.sceneMatrixIndex, true);
	            this._skyboxProjection.copyRawDataTo(shader.vertexConstantData, shader.viewMatrixIndex, true);
	        }
	        else {
	            this._skyboxProjection.copyRawDataTo(shader.vertexConstantData, shader.viewMatrixIndex, true);
	        }
	        var context = this._stage.context;
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.VERTEX, shader.vertexConstantData);
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.FRAGMENT, shader.fragmentConstantData);
	        if (this._indices)
	            this.getIndexBufferGL().draw(ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES, 0, this.numIndices);
	        else
	            this._stage.context.drawVertices(ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES, offset, count || this.numVertices);
	    };
	    GL_SkyboxElements.elementsType = "[elements Skybox]";
	    return GL_SkyboxElements;
	}(GL_TriangleElements_1.GL_TriangleElements));
	exports.GL_SkyboxElements = GL_SkyboxElements;


/***/ },
/* 410 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BlendMode_1 = __webpack_require__(131);
	var BasicMaterialPass_1 = __webpack_require__(411);
	var GL_SurfaceBase_1 = __webpack_require__(283);
	/**
	 * RenderMaterialObject forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var GL_BasicMaterialSurface = (function (_super) {
	    __extends(GL_BasicMaterialSurface, _super);
	    function GL_BasicMaterialSurface(material, elementsClass, renderPool) {
	        _super.call(this, material, elementsClass, renderPool);
	        this._material = material;
	        this._pAddPass(this._pass = new BasicMaterialPass_1.BasicMaterialPass(this, material, elementsClass, this._stage));
	    }
	    GL_BasicMaterialSurface.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._material = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_BasicMaterialSurface.prototype._pUpdateRender = function () {
	        _super.prototype._pUpdateRender.call(this);
	        this._pRequiresBlending = (this._material.blendMode != BlendMode_1.BlendMode.NORMAL || this._material.alphaBlending || (this._material.colorTransform && this._material.colorTransform.alphaMultiplier < 1));
	        this._pass.preserveAlpha = this._material.preserveAlpha; //this._pRequiresBlending;
	        this._pass.shader.setBlendMode((this._surface.blendMode == BlendMode_1.BlendMode.NORMAL && this._pRequiresBlending) ? BlendMode_1.BlendMode.LAYER : this._material.blendMode);
	        //this._pass.forceSeparateMVP = false;
	    };
	    return GL_BasicMaterialSurface;
	}(GL_SurfaceBase_1.GL_SurfaceBase));
	exports.GL_BasicMaterialSurface = GL_BasicMaterialSurface;


/***/ },
/* 411 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var ShaderBase_1 = __webpack_require__(271);
	var PassBase_1 = __webpack_require__(278);
	/**
	 * BasicMaterialPass forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var BasicMaterialPass = (function (_super) {
	    __extends(BasicMaterialPass, _super);
	    function BasicMaterialPass(render, surface, elementsClass, stage) {
	        _super.call(this, render, surface, elementsClass, stage);
	        this._diffuseR = 1;
	        this._diffuseG = 1;
	        this._diffuseB = 1;
	        this._diffuseA = 1;
	        this._shader = new ShaderBase_1.ShaderBase(elementsClass, this, this._stage);
	        this.invalidate();
	    }
	    BasicMaterialPass.prototype._iIncludeDependencies = function (shader) {
	        _super.prototype._iIncludeDependencies.call(this, shader);
	        if (this._textureVO != null)
	            shader.uvDependencies++;
	    };
	    BasicMaterialPass.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._textureVO = this._surface.getTextureAt(0) ? this._shader.getAbstraction(this._surface.getTextureAt(0)) : null;
	    };
	    BasicMaterialPass.prototype.dispose = function () {
	        if (this._textureVO) {
	            this._textureVO.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._surface.getTextureAt(0)));
	            this._textureVO = null;
	        }
	        _super.prototype.dispose.call(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    BasicMaterialPass.prototype._iGetFragmentCode = function (shader, regCache, sharedReg) {
	        var code = "";
	        var alphaReg;
	        if (this.preserveAlpha) {
	            alphaReg = regCache.getFreeFragmentSingleTemp();
	            regCache.addFragmentTempUsages(alphaReg, 1);
	            code += "mov " + alphaReg + ", " + sharedReg.shadedTarget + ".w\n";
	        }
	        var targetReg = sharedReg.shadedTarget;
	        if (this._textureVO != null) {
	            code += this._textureVO._iGetFragmentCode(targetReg, regCache, sharedReg, sharedReg.uvVarying);
	            if (shader.alphaThreshold > 0) {
	                var cutOffReg = regCache.getFreeFragmentConstant();
	                this._fragmentConstantsIndex = cutOffReg.index * 4;
	                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" + "kil " + targetReg + ".w\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
	            }
	        }
	        else if (shader.colorBufferIndex != -1) {
	            code += "mov " + targetReg + ", " + sharedReg.colorVarying + "\n";
	        }
	        else {
	            var diffuseInputReg = regCache.getFreeFragmentConstant();
	            this._fragmentConstantsIndex = diffuseInputReg.index * 4;
	            code += "mov " + targetReg + ", " + diffuseInputReg + "\n";
	        }
	        if (this.preserveAlpha) {
	            code += "mul " + sharedReg.shadedTarget + ".w, " + sharedReg.shadedTarget + ".w, " + alphaReg + "\n";
	            regCache.removeFragmentTempUsage(alphaReg);
	        }
	        return code;
	    };
	    BasicMaterialPass.prototype._setRenderState = function (renderable, camera, viewProjection) {
	        _super.prototype._setRenderState.call(this, renderable, camera, viewProjection);
	        if (this._textureVO != null)
	            this._textureVO._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    BasicMaterialPass.prototype._iActivate = function (camera) {
	        _super.prototype._iActivate.call(this, camera);
	        if (this._textureVO != null) {
	            this._textureVO.activate(this._render);
	            if (this._shader.alphaThreshold > 0)
	                this._shader.fragmentConstantData[this._fragmentConstantsIndex] = this._shader.alphaThreshold;
	        }
	        else if (this._shader.colorBufferIndex == -1) {
	            var index = this._fragmentConstantsIndex;
	            var data = this._shader.fragmentConstantData;
	            data[index] = this._diffuseR;
	            data[index + 1] = this._diffuseG;
	            data[index + 2] = this._diffuseB;
	            data[index + 3] = this._diffuseA;
	        }
	    };
	    return BasicMaterialPass;
	}(PassBase_1.PassBase));
	exports.BasicMaterialPass = BasicMaterialPass;


/***/ },
/* 412 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AssetEvent_1 = __webpack_require__(9);
	var BlendMode_1 = __webpack_require__(131);
	var ContextGLCompareMode_1 = __webpack_require__(43);
	var GL_SurfacePassBase_1 = __webpack_require__(413);
	var ShaderBase_1 = __webpack_require__(271);
	/**
	 * GL_SkyboxSurface forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var GL_SkyboxSurface = (function (_super) {
	    __extends(GL_SkyboxSurface, _super);
	    function GL_SkyboxSurface(skybox, elementsClass, renderPool) {
	        _super.call(this, skybox, elementsClass, renderPool);
	        this._skybox = skybox;
	        this._shader = new ShaderBase_1.ShaderBase(elementsClass, this, this._stage);
	        this._texture = this._shader.getAbstraction(this._skybox.texture);
	        this._pAddPass(this);
	    }
	    GL_SkyboxSurface.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._texture.onClear(new AssetEvent_1.AssetEvent(AssetEvent_1.AssetEvent.CLEAR, this._skybox.texture));
	        this._texture = null;
	        this._skybox = null;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_SkyboxSurface.prototype._pUpdateRender = function () {
	        _super.prototype._pUpdateRender.call(this);
	        this._pRequiresBlending = (this._surface.blendMode != BlendMode_1.BlendMode.NORMAL);
	        this.shader.setBlendMode((this._surface.blendMode == BlendMode_1.BlendMode.NORMAL && this._pRequiresBlending) ? BlendMode_1.BlendMode.LAYER : this._surface.blendMode);
	    };
	    GL_SkyboxSurface.prototype._iIncludeDependencies = function (shader) {
	        _super.prototype._iIncludeDependencies.call(this, shader);
	        shader.usesPositionFragment = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_SkyboxSurface.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return this._texture._iGetFragmentCode(sharedRegisters.shadedTarget, registerCache, sharedRegisters, sharedRegisters.positionVarying);
	    };
	    GL_SkyboxSurface.prototype._setRenderState = function (renderable, camera, viewProjection) {
	        _super.prototype._setRenderState.call(this, renderable, camera, viewProjection);
	        this._texture._setRenderState(renderable);
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_SkyboxSurface.prototype._iActivate = function (camera) {
	        _super.prototype._iActivate.call(this, camera);
	        this._stage.context.setDepthTest(false, ContextGLCompareMode_1.ContextGLCompareMode.LESS);
	        this._texture.activate(this);
	    };
	    return GL_SkyboxSurface;
	}(GL_SurfacePassBase_1.GL_SurfacePassBase));
	exports.GL_SkyboxSurface = GL_SkyboxSurface;


/***/ },
/* 413 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PassEvent_1 = __webpack_require__(279);
	var GL_SurfaceBase_1 = __webpack_require__(283);
	/**
	 * GL_SurfacePassBase provides an abstract base class for material shader passes. A material pass constitutes at least
	 * a render call per required renderable.
	 */
	var GL_SurfacePassBase = (function (_super) {
	    __extends(GL_SurfacePassBase, _super);
	    function GL_SurfacePassBase() {
	        _super.apply(this, arguments);
	    }
	    Object.defineProperty(GL_SurfacePassBase.prototype, "shader", {
	        get: function () {
	            return this._shader;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(GL_SurfacePassBase.prototype, "animationSet", {
	        get: function () {
	            return this._surface.animationSet;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Marks the shader program as invalid, so it will be recompiled before the next render.
	     */
	    GL_SurfacePassBase.prototype.invalidate = function () {
	        this._shader.invalidateProgram();
	        this.dispatchEvent(new PassEvent_1.PassEvent(PassEvent_1.PassEvent.INVALIDATE, this));
	    };
	    GL_SurfacePassBase.prototype.dispose = function () {
	        if (this._shader) {
	            this._shader.dispose();
	            this._shader = null;
	        }
	    };
	    /**
	     * Renders the current pass. Before calling pass, activatePass needs to be called with the same index.
	     * @param pass The pass used to render the renderable.
	     * @param renderable The IRenderable object to draw.
	     * @param stage The Stage object used for rendering.
	     * @param entityCollector The EntityCollector object that contains the visible scene data.
	     * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
	     * camera.viewProjection as it includes the scaling factors when rendering to textures.
	     *
	     * @internal
	     */
	    GL_SurfacePassBase.prototype._setRenderState = function (renderable, camera, viewProjection) {
	        this._shader._setRenderState(renderable, camera, viewProjection);
	    };
	    /**
	     * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
	     * calling pass. Before activating a pass, the previously used pass needs to be deactivated.
	     * @param stage The Stage object which is currently used for rendering.
	     * @param camera The camera from which the scene is viewed.
	     * @private
	     */
	    GL_SurfacePassBase.prototype._iActivate = function (camera) {
	        this._shader._iActivate(camera);
	    };
	    /**
	     * Clears the render state for the pass. This needs to be called before activating another pass.
	     * @param stage The Stage used for rendering
	     *
	     * @private
	     */
	    GL_SurfacePassBase.prototype._iDeactivate = function () {
	        this._shader._iDeactivate();
	    };
	    GL_SurfacePassBase.prototype._iInitConstantData = function (shader) {
	    };
	    GL_SurfacePassBase.prototype._iGetPreLightingVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetPreLightingFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetNormalVertexCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    GL_SurfacePassBase.prototype._iGetNormalFragmentCode = function (shader, registerCache, sharedRegisters) {
	        return "";
	    };
	    return GL_SurfacePassBase;
	}(GL_SurfaceBase_1.GL_SurfaceBase));
	exports.GL_SurfacePassBase = GL_SurfacePassBase;


/***/ },
/* 414 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.pool.SurfacePool
	 */
	var SurfacePool = (function () {
	    /**
	     * //TODO
	     *
	     * @param surfaceClassGL
	     */
	    function SurfacePool(elementsClass, stage, surfaceClassGL) {
	        if (surfaceClassGL === void 0) { surfaceClassGL = null; }
	        this._abstractionPool = new Object();
	        this._elementsClass = elementsClass;
	        this._stage = stage;
	        this._surfaceClassGL = surfaceClassGL;
	    }
	    Object.defineProperty(SurfacePool.prototype, "stage", {
	        get: function () {
	            return this._stage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * //TODO
	     *
	     * @param elementsOwner
	     * @returns IElements
	     */
	    SurfacePool.prototype.getAbstraction = function (surface) {
	        return (this._abstractionPool[surface.id] || (this._abstractionPool[surface.id] = new (this._surfaceClassGL || SurfacePool._abstractionClassPool[surface.assetType])(surface, this._elementsClass, this)));
	    };
	    /**
	     * //TODO
	     *
	     * @param elementsOwner
	     */
	    SurfacePool.prototype.clearAbstraction = function (surface) {
	        delete this._abstractionPool[surface.id];
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    SurfacePool.registerAbstraction = function (surfaceClassGL, assetClass) {
	        SurfacePool._abstractionClassPool[assetClass.assetType] = surfaceClassGL;
	    };
	    SurfacePool._abstractionClassPool = new Object();
	    return SurfacePool;
	}());
	exports.SurfacePool = SurfacePool;


/***/ },
/* 415 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MappingMode_1 = __webpack_require__(137);
	var GL_TextureBase_1 = __webpack_require__(416);
	/**
	 *
	 * @class away.pool.GL_Single2DTexture
	 */
	var GL_Single2DTexture = (function (_super) {
	    __extends(GL_Single2DTexture, _super);
	    function GL_Single2DTexture(single2DTexture, shader) {
	        _super.call(this, single2DTexture, shader);
	        this._single2DTexture = single2DTexture;
	    }
	    GL_Single2DTexture.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._single2DTexture = null;
	    };
	    /**
	     *
	     * @param shader
	     * @param regCache
	     * @param targetReg The register in which to store the sampled colour.
	     * @param uvReg The uv coordinate vector with which to sample the texture map.
	     * @returns {string}
	     * @private
	     */
	    GL_Single2DTexture.prototype._iGetFragmentCode = function (targetReg, regCache, sharedReg, inputReg) {
	        var code = "";
	        var wrap = "wrap";
	        var format = ""; //this.getFormatString(this._single2DTexture.image2D);
	        var filter = "linear,miplinear";
	        var temp;
	        //modify depending on mapping mode
	        if (this._single2DTexture.mappingMode == MappingMode_1.MappingMode.RADIAL_GRADIENT) {
	            temp = regCache.getFreeFragmentVectorTemp();
	            code += "mul " + temp + ".xy, " + inputReg + ", " + inputReg + "\n";
	            code += "mul " + temp + ".xy, " + inputReg + ", " + inputReg + "\n";
	            code += "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n";
	            code += "sub " + temp + ".y, " + temp + ".y, " + temp + ".y\n";
	            code += "sqt " + temp + ".x, " + temp + ".x, " + temp + ".x\n";
	            inputReg = temp;
	        }
	        //handles texture atlasing
	        if (this._shader.useImageRect) {
	            var samplerReg = regCache.getFreeFragmentConstant();
	            this._samplerIndex = samplerReg.index * 4;
	            temp = regCache.getFreeFragmentVectorTemp();
	            code += "mul " + temp + ", " + inputReg + ", " + samplerReg + ".xy\n";
	            code += "add " + temp + ", " + temp + ", " + samplerReg + ".zw\n";
	            inputReg = temp;
	        }
	        this._imageIndex = this._shader.getImageIndex(this._single2DTexture, 0);
	        var textureReg = this.getTextureReg(this._imageIndex, regCache, sharedReg);
	        this._textureIndex = textureReg.index;
	        code += "tex " + targetReg + ", " + inputReg + ", " + textureReg + " <2d," + filter + "," + format + wrap + ">\n";
	        return code;
	    };
	    GL_Single2DTexture.prototype.activate = function (render) {
	        var sampler = render.samplers[this._imageIndex];
	        sampler.activate(this._textureIndex);
	        var image = render.images[this._imageIndex];
	        image.activate(this._textureIndex, sampler._sampler.mipmap);
	        if (this._shader.useImageRect) {
	            var index = this._samplerIndex;
	            var data = this._shader.fragmentConstantData;
	            if (!sampler._sampler.imageRect) {
	                data[index] = 1;
	                data[index + 1] = 1;
	                data[index + 2] = 0;
	                data[index + 3] = 0;
	            }
	            else {
	                data[index] = sampler._sampler.imageRect.width;
	                data[index + 1] = sampler._sampler.imageRect.height;
	                data[index + 2] = sampler._sampler.imageRect.x;
	                data[index + 3] = sampler._sampler.imageRect.y;
	            }
	        }
	    };
	    GL_Single2DTexture.prototype._setRenderState = function (renderable) {
	        var sampler = renderable.samplers[this._imageIndex];
	        if (sampler)
	            sampler.activate(this._textureIndex);
	        var image = renderable.images[this._imageIndex];
	        if (image)
	            image.activate(this._textureIndex, sampler._sampler.mipmap);
	        if (this._shader.useImageRect && sampler) {
	            var index = this._samplerIndex;
	            var data = this._shader.fragmentConstantData;
	            if (!sampler._sampler.imageRect) {
	                data[index] = 1;
	                data[index + 1] = 1;
	                data[index + 2] = 0;
	                data[index + 3] = 0;
	            }
	            else {
	                data[index] = sampler._sampler.imageRect.width;
	                data[index + 1] = sampler._sampler.imageRect.height;
	                data[index + 2] = sampler._sampler.imageRect.x;
	                data[index + 3] = sampler._sampler.imageRect.y;
	            }
	        }
	    };
	    return GL_Single2DTexture;
	}(GL_TextureBase_1.GL_TextureBase));
	exports.GL_Single2DTexture = GL_Single2DTexture;


/***/ },
/* 416 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AbstractMethodError_1 = __webpack_require__(7);
	var AbstractionBase_1 = __webpack_require__(210);
	var ContextGLTextureFormat_1 = __webpack_require__(50);
	/**
	 *
	 * @class away.pool.GL_TextureBaseBase
	 */
	var GL_TextureBase = (function (_super) {
	    __extends(GL_TextureBase, _super);
	    function GL_TextureBase(texture, shader) {
	        _super.call(this, texture, shader);
	        this._texture = texture;
	        this._shader = shader;
	        this._stage = shader._stage;
	    }
	    /**
	     *
	     */
	    GL_TextureBase.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._texture = null;
	        this._shader = null;
	        this._stage = null;
	    };
	    GL_TextureBase.prototype._iGetFragmentCode = function (targetReg, regCache, sharedReg, inputReg) {
	        if (inputReg === void 0) { inputReg = null; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    GL_TextureBase.prototype._setRenderState = function (renderable) {
	        //overidden for state logic
	    };
	    GL_TextureBase.prototype.activate = function (render) {
	        //overridden for activation logic
	    };
	    GL_TextureBase.prototype.getTextureReg = function (imageIndex, regCache, sharedReg) {
	        var index = this._shader.imageIndices.indexOf(imageIndex); //todo: collapse the index based on duplicate image objects to save registrations
	        if (index == -1) {
	            var textureReg = regCache.getFreeTextureReg();
	            sharedReg.textures.push(textureReg);
	            this._shader.imageIndices.push(imageIndex);
	            return textureReg;
	        }
	        return sharedReg.textures[index];
	    };
	    GL_TextureBase.prototype.getFormatString = function (image) {
	        switch (image.format) {
	            case ContextGLTextureFormat_1.ContextGLTextureFormat.COMPRESSED:
	                return "dxt1,";
	            case ContextGLTextureFormat_1.ContextGLTextureFormat.COMPRESSED_ALPHA:
	                return "dxt5,";
	            default:
	                return "";
	        }
	    };
	    return GL_TextureBase;
	}(AbstractionBase_1.AbstractionBase));
	exports.GL_TextureBase = GL_TextureBase;


/***/ },
/* 417 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_TextureBase_1 = __webpack_require__(416);
	/**
	 *
	 * @class away.pool.TextureDataBase
	 */
	var GL_SingleCubeTexture = (function (_super) {
	    __extends(GL_SingleCubeTexture, _super);
	    function GL_SingleCubeTexture(singleCubeTexture, shader) {
	        _super.call(this, singleCubeTexture, shader);
	        this._singleCubeTexture = singleCubeTexture;
	    }
	    GL_SingleCubeTexture.prototype.onClear = function (event) {
	        _super.prototype.onClear.call(this, event);
	        this._singleCubeTexture = null;
	    };
	    GL_SingleCubeTexture.prototype._iIncludeDependencies = function (includeInput) {
	        if (includeInput === void 0) { includeInput = true; }
	        if (includeInput)
	            this._shader.usesPositionFragment = true;
	    };
	    /**
	     *
	     * @param shader
	     * @param regCache
	     * @param targetReg The register in which to store the sampled colour.
	     * @param uvReg The direction vector with which to sample the cube map.
	     * @returns {string}
	     * @private
	     */
	    GL_SingleCubeTexture.prototype._iGetFragmentCode = function (targetReg, regCache, sharedReg, inputReg) {
	        var format = ""; //this.getFormatString(this._singleCubeTexture.imageCube);
	        var filter = "linear,miplinear";
	        this._imageIndex = this._shader.getImageIndex(this._singleCubeTexture, 0);
	        var textureReg = this.getTextureReg(this._imageIndex, regCache, sharedReg);
	        this._textureIndex = textureReg.index;
	        return "tex " + targetReg + ", " + inputReg + ", " + textureReg + " <cube," + format + filter + ">\n";
	    };
	    GL_SingleCubeTexture.prototype.activate = function (render) {
	        var sampler = render.samplers[this._imageIndex];
	        if (sampler)
	            sampler.activate(this._textureIndex);
	        if (render.images[this._imageIndex])
	            render.images[this._imageIndex].activate(this._textureIndex, sampler._sampler.mipmap);
	    };
	    GL_SingleCubeTexture.prototype._setRenderState = function (renderable) {
	        var sampler = renderable.samplers[this._imageIndex];
	        if (sampler)
	            sampler.activate(this._textureIndex);
	        if (renderable.images[this._imageIndex] && sampler)
	            renderable.images[this._imageIndex].activate(this._textureIndex, sampler._sampler.mipmap);
	    };
	    return GL_SingleCubeTexture;
	}(GL_TextureBase_1.GL_TextureBase));
	exports.GL_SingleCubeTexture = GL_SingleCubeTexture;


/***/ },
/* 418 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var Matrix3DUtils_1 = __webpack_require__(38);
	var Point_1 = __webpack_require__(58);
	var Rectangle_1 = __webpack_require__(57);
	var Vector3D_1 = __webpack_require__(34);
	var EventDispatcher_1 = __webpack_require__(11);
	var AGALMiniAssembler_1 = __webpack_require__(419);
	var ContextGLBlendFactor_1 = __webpack_require__(41);
	var ContextGLCompareMode_1 = __webpack_require__(43);
	var StageEvent_1 = __webpack_require__(60);
	var StageManager_1 = __webpack_require__(428);
	var RendererEvent_1 = __webpack_require__(429);
	var SurfacePool_1 = __webpack_require__(414);
	var RenderableMergeSort_1 = __webpack_require__(430);
	/**
	 * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render the
	 * contents of a partition
	 *
	 * @class away.render.RendererBase
	 */
	var RendererBase = (function (_super) {
	    __extends(RendererBase, _super);
	    /**
	     * Creates a new RendererBase object.
	     */
	    function RendererBase(stage, surfaceClassGL, forceSoftware, profile, mode) {
	        var _this = this;
	        if (stage === void 0) { stage = null; }
	        if (surfaceClassGL === void 0) { surfaceClassGL = null; }
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        _super.call(this);
	        this._objectPools = new Object();
	        this._abstractionPool = new Object();
	        this._activeMasksConfig = new Array();
	        this._registeredMasks = new Array();
	        this._numUsedStreams = 0;
	        this._numUsedTextures = 0;
	        this._cameraForward = new Vector3D_1.Vector3D();
	        this._viewPort = new Rectangle_1.Rectangle();
	        this._pBackBufferInvalid = true;
	        this._pDepthTextureInvalid = true;
	        this._depthPrepass = false;
	        this._backgroundR = 0;
	        this._backgroundG = 0;
	        this._backgroundB = 0;
	        this._backgroundAlpha = 1;
	        this.textureRatioX = 1;
	        this.textureRatioY = 1;
	        this._pRttViewProjectionMatrix = new Matrix3D_1.Matrix3D();
	        this._localPos = new Point_1.Point();
	        this._globalPos = new Point_1.Point();
	        this._pScissorRect = new Rectangle_1.Rectangle();
	        this._pNumElements = 0;
	        this._disableColor = false;
	        this._renderBlended = true;
	        this._numCullPlanes = 0;
	        this._onViewportUpdatedDelegate = function (event) { return _this.onViewportUpdated(event); };
	        this._onContextUpdateDelegate = function (event) { return _this.onContextUpdate(event); };
	        //default sorting algorithm
	        this.renderableSorter = new RenderableMergeSort_1.RenderableMergeSort();
	        //set stage
	        this._pStage = stage || StageManager_1.StageManager.getInstance().getFreeStage(forceSoftware, profile, mode);
	        this._pStage.addEventListener(StageEvent_1.StageEvent.CONTEXT_CREATED, this._onContextUpdateDelegate);
	        this._pStage.addEventListener(StageEvent_1.StageEvent.CONTEXT_RECREATED, this._onContextUpdateDelegate);
	        this._pStage.addEventListener(StageEvent_1.StageEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	        this._surfaceClassGL = surfaceClassGL;
	        /*
	         if (_backgroundImageRenderer)
	         _backgroundImageRenderer.stage = value;
	         */
	        if (this._pStage.context)
	            this._pContext = this._pStage.context;
	    }
	    Object.defineProperty(RendererBase.prototype, "cullPlanes", {
	        /**
	         *
	         */
	        get: function () {
	            return this._customCullPlanes;
	        },
	        set: function (value) {
	            this._customCullPlanes = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "renderBlended", {
	        get: function () {
	            return this._renderBlended;
	        },
	        set: function (value) {
	            this._renderBlended = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "disableColor", {
	        get: function () {
	            return this._disableColor;
	        },
	        set: function (value) {
	            this._disableColor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "numElements", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pNumElements;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "viewPort", {
	        /**
	         * A viewPort rectangle equivalent of the Stage size and position.
	         */
	        get: function () {
	            return this._viewPort;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "scissorRect", {
	        /**
	         * A scissor rectangle equivalent of the view size and position.
	         */
	        get: function () {
	            return this._pScissorRect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "x", {
	        /**
	         *
	         */
	        get: function () {
	            return this._localPos.x;
	        },
	        set: function (value) {
	            if (this.x == value)
	                return;
	            this._pStage.x = value;
	            this._globalPos.x = this._localPos.x = value;
	            this.updateGlobalPos();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "y", {
	        /**
	         *
	         */
	        get: function () {
	            return this._localPos.y;
	        },
	        set: function (value) {
	            if (this.y == value)
	                return;
	            this._pStage.y = value;
	            this._globalPos.y = this._localPos.y = value;
	            this.updateGlobalPos();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "width", {
	        /**
	         *
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            if (this._width == value)
	                return;
	            this._width = value;
	            this._pScissorRect.width = value;
	            if (this._pRttBufferManager)
	                this._pRttBufferManager.viewWidth = value;
	            this._pBackBufferInvalid = true;
	            this._pDepthTextureInvalid = true;
	            this.notifyScissorUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "height", {
	        /**
	         *
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            if (this._height == value)
	                return;
	            this._height = value;
	            this._pScissorRect.height = value;
	            if (this._pRttBufferManager)
	                this._pRttBufferManager.viewHeight = value;
	            this._pBackBufferInvalid = true;
	            this._pDepthTextureInvalid = true;
	            this.notifyScissorUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RendererBase.prototype.getAbstraction = function (renderable) {
	        return this._abstractionPool[renderable.id] || (this._abstractionPool[renderable.id] = new RendererBase._abstractionClassPool[renderable.assetType](renderable, this));
	    };
	    /**
	     *
	     * @param image
	     */
	    RendererBase.prototype.clearAbstraction = function (renderable) {
	        this._abstractionPool[renderable.id] = null;
	    };
	    /**
	     * //TODO
	     *
	     * @param elementsClass
	     * @returns SurfacePool
	     */
	    RendererBase.prototype.getSurfacePool = function (elements) {
	        return this._objectPools[elements.elementsType] || (this._objectPools[elements.elementsType] = new SurfacePool_1.SurfacePool(elements.elementsClass, this._pStage, this._surfaceClassGL));
	    };
	    /**
	     *
	     * @param imageObjectClass
	     */
	    RendererBase.registerAbstraction = function (renderableClass, assetClass) {
	        RendererBase._abstractionClassPool[assetClass.assetType] = renderableClass;
	    };
	    RendererBase.prototype.activatePass = function (pass, camera) {
	        //clear unused vertex streams
	        var i;
	        for (i = pass.shader.numUsedStreams; i < this._numUsedStreams; i++)
	            this._pContext.setVertexBufferAt(i, null);
	        //clear unused texture streams
	        for (i = pass.shader.numUsedTextures; i < this._numUsedTextures; i++)
	            this._pContext.setTextureAt(i, null);
	        //check program data is uploaded
	        var programData = pass.shader.programData;
	        if (!programData.program) {
	            programData.program = this._pContext.createProgram();
	            var vertexByteCode = (new AGALMiniAssembler_1.AGALMiniAssembler().assemble("part vertex 1\n" + programData.vertexString + "endpart"))['vertex'].data;
	            var fragmentByteCode = (new AGALMiniAssembler_1.AGALMiniAssembler().assemble("part fragment 1\n" + programData.fragmentString + "endpart"))['fragment'].data;
	            programData.program.upload(vertexByteCode, fragmentByteCode);
	        }
	        //set program data
	        this._pContext.setProgram(programData.program);
	        //activate shader object through pass
	        pass._iActivate(camera);
	    };
	    RendererBase.prototype.deactivatePass = function (pass) {
	        //deactivate shader object through pass
	        pass._iDeactivate();
	        this._numUsedStreams = pass.shader.numUsedStreams;
	        this._numUsedTextures = pass.shader.numUsedTextures;
	    };
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundR", {
	        /**
	         * The background color's red component, used when clearing.
	         *
	         * @private
	         */
	        get: function () {
	            return this._backgroundR;
	        },
	        set: function (value) {
	            if (this._backgroundR == value)
	                return;
	            this._backgroundR = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundG", {
	        /**
	         * The background color's green component, used when clearing.
	         *
	         * @private
	         */
	        get: function () {
	            return this._backgroundG;
	        },
	        set: function (value) {
	            if (this._backgroundG == value)
	                return;
	            this._backgroundG = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundB", {
	        /**
	         * The background color's blue component, used when clearing.
	         *
	         * @private
	         */
	        get: function () {
	            return this._backgroundB;
	        },
	        set: function (value) {
	            if (this._backgroundB == value)
	                return;
	            this._backgroundB = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "context", {
	        get: function () {
	            return this._pContext;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RendererBase.prototype, "stage", {
	        /**
	         * The Stage that will provide the ContextGL used for rendering.
	         */
	        get: function () {
	            return this._pStage;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Disposes the resources used by the RendererBase.
	     */
	    RendererBase.prototype.dispose = function () {
	        for (var id in this._abstractionPool)
	            this._abstractionPool[id].clear();
	        this._abstractionPool = null;
	        this._pStage.removeEventListener(StageEvent_1.StageEvent.CONTEXT_CREATED, this._onContextUpdateDelegate);
	        this._pStage.removeEventListener(StageEvent_1.StageEvent.CONTEXT_RECREATED, this._onContextUpdateDelegate);
	        this._pStage.removeEventListener(StageEvent_1.StageEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	        this._pStage = null;
	        this._pContext = null;
	        /*
	         if (_backgroundImageRenderer) {
	         _backgroundImageRenderer.dispose();
	         _backgroundImageRenderer = null;
	         }
	         */
	    };
	    RendererBase.prototype.render = function (view) {
	        this._viewportDirty = false;
	        this._scissorDirty = false;
	    };
	    /**
	     * Renders the potentially visible geometry to the back buffer or texture.
	     * @param target An option target texture to render to.
	     * @param surfaceSelector The index of a CubeTexture's face to render to.
	     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
	     */
	    RendererBase.prototype._iRender = function (camera, view, target, scissorRect, surfaceSelector) {
	        if (target === void 0) { target = null; }
	        if (scissorRect === void 0) { scissorRect = null; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        //TODO refactor setTarget so that rendertextures are created before this check
	        if (!this._pStage || !this._pContext)
	            return;
	        //reset head values
	        this._pBlendedRenderableHead = null;
	        this._pOpaqueRenderableHead = null;
	        this._pNumElements = 0;
	        this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : camera.frustumPlanes;
	        this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
	        this._cameraPosition = camera.scenePosition;
	        this._cameraTransform = camera.sceneTransform;
	        this._cameraForward = Matrix3DUtils_1.Matrix3DUtils.getForward(camera.sceneTransform, this._cameraForward);
	        RendererBase._iCollectionMark++;
	        view.traversePartitions(this);
	        //sort the resulting renderables
	        if (this.renderableSorter) {
	            this._pOpaqueRenderableHead = this.renderableSorter.sortOpaqueRenderables(this._pOpaqueRenderableHead);
	            this._pBlendedRenderableHead = this.renderableSorter.sortBlendedRenderables(this._pBlendedRenderableHead);
	        }
	        this._pRttViewProjectionMatrix.copyFrom(camera.viewProjection);
	        this._pRttViewProjectionMatrix.appendScale(this.textureRatioX, this.textureRatioY, 1);
	        this.pExecuteRender(camera, view, target, scissorRect, surfaceSelector);
	        // invalidate target (if target exists) to regenerate mipmaps (if required)
	        if (target)
	            target.invalidate();
	        // clear buffers
	        for (var i = 0; i < 8; ++i) {
	            this._pContext.setVertexBufferAt(i, null);
	            this._pContext.setTextureAt(i, null);
	        }
	    };
	    RendererBase.prototype._iRenderCascades = function (camera, view, target, numCascades, scissorRects, cameras) {
	        this._pStage.setRenderTarget(target, true, 0);
	        this._pContext.clear(1, 1, 1, 1, 1, 0);
	        this._pContext.setBlendFactors(ContextGLBlendFactor_1.ContextGLBlendFactor.ONE, ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO);
	        this._pContext.setDepthTest(true, ContextGLCompareMode_1.ContextGLCompareMode.LESS);
	        var head = this._pOpaqueRenderableHead;
	        var first = true;
	        //TODO cascades must have separate collectors, rather than separate draw commands
	        for (var i = numCascades - 1; i >= 0; --i) {
	            this._pStage.scissorRect = scissorRects[i];
	            //this.drawCascadeRenderables(head, cameras[i], first? null : cameras[i].frustumPlanes);
	            first = false;
	        }
	        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
	        this._pContext.setDepthTest(false, ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL);
	        this._pStage.scissorRect = null;
	    };
	    /**
	     * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
	     *
	     * @param target An option target texture to render to.
	     * @param surfaceSelector The index of a CubeTexture's face to render to.
	     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
	     */
	    RendererBase.prototype.pExecuteRender = function (camera, view, target, scissorRect, surfaceSelector) {
	        if (target === void 0) { target = null; }
	        if (scissorRect === void 0) { scissorRect = null; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        this._pStage.setRenderTarget(target, true, surfaceSelector);
	        if ((target || !this.shareContext) && !this._depthPrepass)
	            this._pContext.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);
	        this._pStage.scissorRect = scissorRect;
	        /*
	         if (_backgroundImageRenderer)
	         _backgroundImageRenderer.render();
	         */
	        this._pContext.setBlendFactors(ContextGLBlendFactor_1.ContextGLBlendFactor.ONE, ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO);
	        this.pDraw(camera);
	        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
	        //this._pContext.setDepthTest(false, ContextGLCompareMode.LESS_EQUAL); //oopsie
	        if (!this.shareContext) {
	            if (this._snapshotRequired && this._snapshotBitmapImage2D) {
	                this._pContext.drawToBitmapImage2D(this._snapshotBitmapImage2D);
	                this._snapshotRequired = false;
	            }
	        }
	        this._pStage.scissorRect = null;
	    };
	    /*
	     * Will draw the renderer's output on next render to the provided bitmap data.
	     * */
	    RendererBase.prototype.queueSnapshot = function (bmd) {
	        this._snapshotRequired = true;
	        this._snapshotBitmapImage2D = bmd;
	    };
	    /**
	     * Performs the actual drawing of geometry to the target.
	     */
	    RendererBase.prototype.pDraw = function (camera) {
	        this._pContext.setDepthTest(true, ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL);
	        if (this._disableColor)
	            this._pContext.setColorMask(false, false, false, false);
	        this.drawRenderables(camera, this._pOpaqueRenderableHead);
	        if (this._renderBlended)
	            this.drawRenderables(camera, this._pBlendedRenderableHead);
	        if (this._disableColor)
	            this._pContext.setColorMask(true, true, true, true);
	    };
	    //private drawCascadeRenderables(renderableGL:GL_RenderableBase, camera:Camera, cullPlanes:Array<Plane3D>)
	    //{
	    //	var renderableGL2:GL_RenderableBase;
	    //	var render:GL_SurfaceBase;
	    //	var pass:IPass;
	    //
	    //	while (renderableGL) {
	    //		renderableGL2 = renderableGL;
	    //		render = renderableGL.render;
	    //		pass = render.passes[0] //assuming only one pass per material
	    //
	    //		this.activatePass(renderableGL, pass, camera);
	    //
	    //		do {
	    //			// if completely in front, it will fall in a different cascade
	    //			// do not use near and far planes
	    //			if (!cullPlanes || renderableGL2.sourceEntity.worldBounds.isInFrustum(cullPlanes, 4)) {
	    //				renderableGL2._iRender(pass, camera, this._pRttViewProjectionMatrix);
	    //			} else {
	    //				renderableGL2.cascaded = true;
	    //			}
	    //
	    //			renderableGL2 = renderableGL2.next;
	    //
	    //		} while (renderableGL2 && renderableGL2.render == render && !renderableGL2.cascaded);
	    //
	    //		this.deactivatePass(renderableGL, pass);
	    //
	    //		renderableGL = renderableGL2;
	    //	}
	    //}
	    /**
	     * Draw a list of renderables.
	     *
	     * @param renderables The renderables to draw.
	     */
	    RendererBase.prototype.drawRenderables = function (camera, renderableGL) {
	        var i;
	        var len;
	        var renderableGL2;
	        var surfaceGL;
	        var passes;
	        var pass;
	        this._pContext.setStencilActions("frontAndBack", "always", "keep", "keep", "keep");
	        this._registeredMasks.length = 0;
	        var gl = this._pContext["_gl"];
	        if (gl) {
	            gl.disable(gl.STENCIL_TEST);
	        }
	        this._maskConfig = 0;
	        while (renderableGL) {
	            surfaceGL = renderableGL.surfaceGL;
	            passes = surfaceGL.passes;
	            // otherwise this would result in depth rendered anyway because fragment shader kil is ignored
	            if (this._disableColor && surfaceGL._surface.alphaThreshold != 0) {
	                renderableGL2 = renderableGL;
	                // fast forward
	                do {
	                    renderableGL2 = renderableGL2.next;
	                } while (renderableGL2 && renderableGL2.surfaceGL == surfaceGL);
	            }
	            else {
	                if (this._activeMasksDirty || this._checkMasksConfig(renderableGL.masksConfig)) {
	                    this._activeMasksConfig = renderableGL.masksConfig;
	                    if (!this._activeMasksConfig.length) {
	                        // disable stencil
	                        if (gl) {
	                            gl.disable(gl.STENCIL_TEST);
	                            gl.stencilFunc(gl.ALWAYS, 0, 0xff);
	                            gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	                        }
	                    }
	                    else {
	                        this._renderMasks(camera, renderableGL.sourceEntity._iAssignedMasks());
	                    }
	                    this._activeMasksDirty = false;
	                }
	                //iterate through each shader object
	                len = passes.length;
	                for (i = 0; i < len; i++) {
	                    renderableGL2 = renderableGL;
	                    pass = passes[i];
	                    this.activatePass(pass, camera);
	                    do {
	                        if (renderableGL2.maskId !== -1) {
	                            if (i == 0)
	                                this._registerMask(renderableGL2);
	                        }
	                        else {
	                            renderableGL2._iRender(pass, camera, this._pRttViewProjectionMatrix);
	                        }
	                        renderableGL2 = renderableGL2.next;
	                    } while (renderableGL2 && renderableGL2.surfaceGL == surfaceGL && !(this._activeMasksDirty = this._checkMasksConfig(renderableGL2.masksConfig)));
	                    this.deactivatePass(pass);
	                }
	            }
	            renderableGL = renderableGL2;
	        }
	    };
	    /**
	     * Assign the context once retrieved
	     */
	    RendererBase.prototype.onContextUpdate = function (event) {
	        this._pContext = this._pStage.context;
	    };
	    Object.defineProperty(RendererBase.prototype, "_iBackgroundAlpha", {
	        get: function () {
	            return this._backgroundAlpha;
	        },
	        set: function (value) {
	            if (this._backgroundAlpha == value)
	                return;
	            this._backgroundAlpha = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /*
	     public get iBackground():Texture2DBase
	     {
	     return this._background;
	     }
	     */
	    /*
	     public set iBackground(value:Texture2DBase)
	     {
	     if (this._backgroundImageRenderer && !value) {
	     this._backgroundImageRenderer.dispose();
	     this._backgroundImageRenderer = null;
	     }
	
	     if (!this._backgroundImageRenderer && value)
	     {
	
	     this._backgroundImageRenderer = new BackgroundImageRenderer(this._pStage);
	
	     }
	
	
	     this._background = value;
	
	     if (this._backgroundImageRenderer)
	     this._backgroundImageRenderer.texture = value;
	     }
	     */
	    /*
	     public get backgroundImageRenderer():BackgroundImageRenderer
	     {
	     return _backgroundImageRenderer;
	     }
	     */
	    /**
	     * @private
	     */
	    RendererBase.prototype.notifyScissorUpdate = function () {
	        if (this._scissorDirty)
	            return;
	        this._scissorDirty = true;
	        if (!this._scissorUpdated)
	            this._scissorUpdated = new RendererEvent_1.RendererEvent(RendererEvent_1.RendererEvent.SCISSOR_UPDATED);
	        this.dispatchEvent(this._scissorUpdated);
	    };
	    /**
	     * @private
	     */
	    RendererBase.prototype.notifyViewportUpdate = function () {
	        if (this._viewportDirty)
	            return;
	        this._viewportDirty = true;
	        if (!this._viewPortUpdated)
	            this._viewPortUpdated = new RendererEvent_1.RendererEvent(RendererEvent_1.RendererEvent.VIEWPORT_UPDATED);
	        this.dispatchEvent(this._viewPortUpdated);
	    };
	    /**
	     *
	     */
	    RendererBase.prototype.onViewportUpdated = function (event) {
	        this._viewPort = this._pStage.viewPort;
	        //TODO stop firing viewport updated for every stagegl viewport change
	        if (this.shareContext) {
	            this._pScissorRect.x = this._globalPos.x - this._pStage.x;
	            this._pScissorRect.y = this._globalPos.y - this._pStage.y;
	            this.notifyScissorUpdate();
	        }
	        this.notifyViewportUpdate();
	    };
	    /**
	     *
	     */
	    RendererBase.prototype.updateGlobalPos = function () {
	        if (this.shareContext) {
	            this._pScissorRect.x = this._globalPos.x - this._viewPort.x;
	            this._pScissorRect.y = this._globalPos.y - this._viewPort.y;
	        }
	        else {
	            this._pScissorRect.x = 0;
	            this._pScissorRect.y = 0;
	            this._viewPort.x = this._globalPos.x;
	            this._viewPort.y = this._globalPos.y;
	        }
	        this.notifyScissorUpdate();
	    };
	    /**
	     *
	     * @param node
	     * @returns {boolean}
	     */
	    RendererBase.prototype.enterNode = function (node) {
	        var enter = node._iCollectionMark != RendererBase._iCollectionMark && node.isRenderable() && node.isInFrustum(this._cullPlanes, this._numCullPlanes);
	        node._iCollectionMark = RendererBase._iCollectionMark;
	        return enter;
	    };
	    RendererBase.prototype.applyEntity = function (entity) {
	        this._sourceEntity = entity;
	        // project onto camera's z-axis
	        this._zIndex = entity.zOffset + this._cameraPosition.subtract(entity.scenePosition).dotProduct(this._cameraForward);
	        //save sceneTransform
	        this._renderSceneTransform = entity.getRenderSceneTransform(this._cameraTransform);
	        //collect renderables
	        entity._acceptTraverser(this);
	    };
	    RendererBase.prototype.applyRenderable = function (renderable) {
	        var renderableGL = this.getAbstraction(renderable);
	        var surfaceGL = renderableGL.surfaceGL;
	        //set local vars for faster referencing
	        renderableGL.surfaceID = surfaceGL.surfaceID;
	        renderableGL.renderOrderId = surfaceGL.renderOrderId;
	        renderableGL.cascaded = false;
	        renderableGL.sourceEntity = this._sourceEntity;
	        renderableGL.zIndex = this._zIndex;
	        renderableGL.maskId = this._sourceEntity._iAssignedMaskId();
	        renderableGL.masksConfig = this._sourceEntity._iMasksConfig();
	        //store reference to scene transform
	        renderableGL.renderSceneTransform = this._renderSceneTransform;
	        if (surfaceGL.requiresBlending) {
	            renderableGL.next = this._pBlendedRenderableHead;
	            this._pBlendedRenderableHead = renderableGL;
	        }
	        else {
	            renderableGL.next = this._pOpaqueRenderableHead;
	            this._pOpaqueRenderableHead = renderableGL;
	        }
	        this._pNumElements += renderableGL.elementsGL.elements.numElements;
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applyDirectionalLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applyLightProbe = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applyPointLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RendererBase.prototype.applySkybox = function (entity) {
	        //don't do anything here
	    };
	    RendererBase.prototype._registerMask = function (obj) {
	        //console.log("registerMask");
	        this._registeredMasks.push(obj);
	    };
	    RendererBase.prototype._renderMasks = function (camera, masks) {
	        var gl = this._pContext["_gl"];
	        if (!gl)
	            return;
	        //var oldRenderTarget = this._stage.renderTarget;
	        //this._stage.setRenderTarget(this._image);
	        //this._stage.clear();
	        this._pContext.setColorMask(false, false, false, false);
	        // TODO: Could we create masks within masks by providing a previous configID, and supply "clear/keep" on stencil fail
	        //context.setStencilActions("frontAndBack", "always", "set", "set", "set");
	        gl.enable(gl.STENCIL_TEST);
	        this._maskConfig++;
	        gl.stencilFunc(gl.ALWAYS, this._maskConfig, 0xff);
	        gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
	        var numLayers = masks.length;
	        var numRenderables = this._registeredMasks.length;
	        var renderableGL;
	        var children;
	        var numChildren;
	        var mask;
	        for (var i = 0; i < numLayers; ++i) {
	            if (i != 0) {
	                gl.stencilFunc(gl.EQUAL, this._maskConfig, 0xff);
	                gl.stencilOp(gl.KEEP, gl.INCR, gl.INCR);
	                this._maskConfig++;
	            }
	            children = masks[i];
	            numChildren = children.length;
	            for (var j = 0; j < numChildren; ++j) {
	                mask = children[j];
	                for (var k = 0; k < numRenderables; ++k) {
	                    renderableGL = this._registeredMasks[k];
	                    //console.log("testing for " + mask["hierarchicalMaskID"] + ", " + mask.name);
	                    if (renderableGL.maskId == mask.id) {
	                        //console.log("Rendering hierarchicalMaskID " + mask["hierarchicalMaskID"]);
	                        this._drawMask(camera, renderableGL);
	                    }
	                }
	            }
	        }
	        gl.stencilFunc(gl.EQUAL, this._maskConfig, 0xff);
	        gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
	        this._pContext.setColorMask(true, true, true, true);
	        this._pContext.setDepthTest(true, ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL);
	        //this._stage.setRenderTarget(oldRenderTarget);
	    };
	    RendererBase.prototype._drawMask = function (camera, renderableGL) {
	        var surfaceGL = renderableGL.surfaceGL;
	        var passes = surfaceGL.passes;
	        var len = passes.length;
	        var pass = passes[len - 1];
	        this.activatePass(pass, camera);
	        this._pContext.setDepthTest(false, ContextGLCompareMode_1.ContextGLCompareMode.LESS_EQUAL); //TODO: setup so as not to override activate
	        // only render last pass for now
	        renderableGL._iRender(pass, camera, this._pRttViewProjectionMatrix);
	        this.deactivatePass(pass);
	    };
	    RendererBase.prototype._checkMasksConfig = function (masksConfig) {
	        if (this._activeMasksConfig.length != masksConfig.length)
	            return true;
	        var numLayers = masksConfig.length;
	        var numChildren;
	        var childConfig;
	        var activeNumChildren;
	        var activeChildConfig;
	        for (var i = 0; i < numLayers; i++) {
	            childConfig = masksConfig[i];
	            numChildren = childConfig.length;
	            activeChildConfig = this._activeMasksConfig[i];
	            activeNumChildren = activeChildConfig.length;
	            if (activeNumChildren != numChildren)
	                return true;
	            for (var j = 0; j < numChildren; j++) {
	                if (activeChildConfig[j] != childConfig[j])
	                    return true;
	            }
	        }
	        return false;
	    };
	    RendererBase._iCollectionMark = 0;
	    RendererBase._abstractionClassPool = new Object();
	    return RendererBase;
	}(EventDispatcher_1.EventDispatcher));
	exports.RendererBase = RendererBase;


/***/ },
/* 419 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var OpcodeMap_1 = __webpack_require__(420);
	var Part_1 = __webpack_require__(424);
	var RegMap_1 = __webpack_require__(425);
	var SamplerMap_1 = __webpack_require__(426);
	var AGALMiniAssembler = (function () {
	    function AGALMiniAssembler() {
	        this.r = {};
	        this.cur = new Part_1.Part();
	    }
	    AGALMiniAssembler.prototype.assemble = function (source, ext_part, ext_version) {
	        if (ext_part === void 0) { ext_part = null; }
	        if (ext_version === void 0) { ext_version = null; }
	        if (!ext_version) {
	            ext_version = 1;
	        }
	        if (ext_part) {
	            this.addHeader(ext_part, ext_version);
	        }
	        var lines = source.replace(/[\f\n\r\v]+/g, "\n").split("\n"); // handle breaks, then split into lines
	        for (var i in lines) {
	            this.processLine(lines[i], i);
	        }
	        return this.r;
	    };
	    AGALMiniAssembler.prototype.processLine = function (line, linenr) {
	        var startcomment = line.search("//"); // remove comments
	        if (startcomment != -1) {
	            line = line.slice(0, startcomment);
	        }
	        line = line.replace(/^\s+|\s+$/g, ""); // remove outer space
	        if (!(line.length > 0)) {
	            return;
	        }
	        var optsi = line.search(/<.*>/g); // split of options part <*> if there
	        var opts = null;
	        if (optsi != -1) {
	            opts = line.slice(optsi).match(/([\w\.\-\+]+)/gi);
	            line = line.slice(0, optsi);
	        }
	        // get opcode/command				            
	        var tokens = line.match(/([\w\.\+\[\]]+)/gi); // get tokens in line
	        if (!tokens || tokens.length < 1) {
	            if (line.length >= 3) {
	                console.log("Warning: bad line " + linenr + ": " + line);
	            }
	            return;
	        }
	        //console.log ( linenr, line, cur, tokens ); 
	        switch (tokens[0]) {
	            case "part":
	                this.addHeader(tokens[1], Number(tokens[2]));
	                break;
	            case "endpart":
	                if (!this.cur) {
	                    throw "Unexpected endpart";
	                }
	                this.cur.data.position = 0;
	                this.cur = null;
	                return;
	            default:
	                if (!this.cur) {
	                    console.log("Warning: bad line " + linenr + ": " + line + " (Outside of any part definition)");
	                    return;
	                }
	                if (this.cur.name == "comment") {
	                    return;
	                }
	                var op = OpcodeMap_1.OpcodeMap.map[tokens[0]];
	                if (!op) {
	                    throw "Bad opcode " + tokens[0] + " " + linenr + ": " + line;
	                }
	                // console.log( 'AGALMiniAssembler' , 'op' , op );
	                this.emitOpcode(this.cur, op.opcode);
	                var ti = 1;
	                if (op.dest && op.dest != "none") {
	                    if (!this.emitDest(this.cur, tokens[ti++], op.dest)) {
	                        throw "Bad destination register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                    }
	                }
	                else {
	                    this.emitZeroDword(this.cur);
	                }
	                if (op.a && op.a.format != "none") {
	                    if (!this.emitSource(this.cur, tokens[ti++], op.a))
	                        throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                }
	                else {
	                    this.emitZeroQword(this.cur);
	                }
	                if (op.b && op.b.format != "none") {
	                    if (op.b.format == "sampler") {
	                        if (!this.emitSampler(this.cur, tokens[ti++], op.b, opts)) {
	                            throw "Bad sampler register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                        }
	                    }
	                    else {
	                        if (!this.emitSource(this.cur, tokens[ti++], op.b)) {
	                            throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
	                        }
	                    }
	                }
	                else {
	                    this.emitZeroQword(this.cur);
	                }
	                break;
	        }
	    };
	    AGALMiniAssembler.prototype.emitHeader = function (pr) {
	        pr.data.writeUnsignedByte(0xa0); // tag version
	        pr.data.writeUnsignedInt(pr.version);
	        if (pr.version >= 0x10) {
	            pr.data.writeUnsignedByte(0); // align, for higher versions
	        }
	        pr.data.writeUnsignedByte(0xa1); // tag program id
	        switch (pr.name) {
	            case "fragment":
	                pr.data.writeUnsignedByte(1);
	                break;
	            case "vertex":
	                pr.data.writeUnsignedByte(0);
	                break;
	            case "cpu":
	                pr.data.writeUnsignedByte(2);
	                break;
	            default:
	                pr.data.writeUnsignedByte(0xff);
	                break; // unknown/comment
	        }
	    };
	    AGALMiniAssembler.prototype.emitOpcode = function (pr, opcode) {
	        pr.data.writeUnsignedInt(opcode);
	        //console.log ( "Emit opcode: ", opcode ); 
	    };
	    AGALMiniAssembler.prototype.emitZeroDword = function (pr) {
	        pr.data.writeUnsignedInt(0);
	    };
	    AGALMiniAssembler.prototype.emitZeroQword = function (pr) {
	        pr.data.writeUnsignedInt(0);
	        pr.data.writeUnsignedInt(0);
	    };
	    AGALMiniAssembler.prototype.emitDest = function (pr, token, opdest) {
	        //console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map' , RegMap.map);
	        var reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:mask
	        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'reg' , reg , reg[1] , RegMap.map[reg[1]] );
	        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map[reg[1]]' , RegMap.map[reg[1]] , 'bool' , !RegMap.map[reg[1]] ) ;
	        if (!RegMap_1.RegMap.map[reg[1]])
	            return false;
	        var em = { num: reg[2] ? reg[2] : 0, code: RegMap_1.RegMap.map[reg[1]].code, mask: this.stringToMask(reg[3]) };
	        pr.data.writeUnsignedShort(em.num);
	        pr.data.writeUnsignedByte(em.mask);
	        pr.data.writeUnsignedByte(em.code);
	        //console.log ( "  Emit dest: ", em );
	        return true;
	    };
	    AGALMiniAssembler.prototype.stringToMask = function (s) {
	        if (!s)
	            return 0xf;
	        var r = 0;
	        if (s.indexOf("x") != -1)
	            r |= 1;
	        if (s.indexOf("y") != -1)
	            r |= 2;
	        if (s.indexOf("z") != -1)
	            r |= 4;
	        if (s.indexOf("w") != -1)
	            r |= 8;
	        return r;
	    };
	    AGALMiniAssembler.prototype.stringToSwizzle = function (s) {
	        if (!s) {
	            return 0xe4;
	        }
	        var chartoindex = { x: 0, y: 1, z: 2, w: 3 };
	        var sw = 0;
	        if (s.charAt(0) != ".") {
	            throw "Missing . for swizzle";
	        }
	        if (s.length > 1) {
	            sw |= chartoindex[s.charAt(1)];
	        }
	        if (s.length > 2) {
	            sw |= chartoindex[s.charAt(2)] << 2;
	        }
	        else {
	            sw |= (sw & 3) << 2;
	        }
	        if (s.length > 3) {
	            sw |= chartoindex[s.charAt(3)] << 4;
	        }
	        else {
	            sw |= (sw & (3 << 2)) << 2;
	        }
	        if (s.length > 4) {
	            sw |= chartoindex[s.charAt(4)] << 6;
	        }
	        else {
	            sw |= (sw & (3 << 4)) << 2;
	        }
	        return sw;
	    };
	    AGALMiniAssembler.prototype.emitSampler = function (pr, token, opsrc, opts) {
	        var reg = token.match(/fs(\d*)/i); // g1:regnum
	        if (!reg || !reg[1]) {
	            return false;
	        }
	        pr.data.writeUnsignedShort(parseInt(reg[1]));
	        pr.data.writeUnsignedByte(0); // bias
	        pr.data.writeUnsignedByte(0);
	        /*
	         pr.data.writeUnsignedByte ( 0x5 );
	         pr.data.writeUnsignedByte ( 0 );   // readmode, dim
	         pr.data.writeUnsignedByte ( 0 );   // special, wrap
	         pr.data.writeUnsignedByte ( 0 );   // mip, filter
	         */
	        var samplerbits = 0x5;
	        var sampleroptset = 0;
	        for (var i = 0; i < opts.length; i++) {
	            var o = SamplerMap_1.SamplerMap.map[opts[i].toLowerCase()];
	            //console.log( 'AGALMiniAssembler' , 'emitSampler' , 'SampleMap opt:' , o , '<-------- WATCH FOR THIS');
	            if (o) {
	                if (((sampleroptset >> o.shift) & o.mask) != 0) {
	                    console.log("Warning, duplicate sampler option");
	                }
	                sampleroptset |= o.mask << o.shift;
	                samplerbits &= ~(o.mask << o.shift);
	                samplerbits |= o.value << o.shift;
	            }
	            else {
	                console.log("Warning, unknown sampler option: ", opts[i]);
	            }
	        }
	        pr.data.writeUnsignedInt(samplerbits);
	        return true;
	    };
	    AGALMiniAssembler.prototype.emitSource = function (pr, token, opsrc) {
	        var indexed = token.match(/vc\[(v[tcai])(\d+)\.([xyzw])([\+\-]\d+)?\](\.[xyzw]{1,4})?/i); // g1: indexregname, g2:indexregnum, g3:select, [g4:offset], [g5:swizzle]
	        var reg;
	        if (indexed) {
	            if (!RegMap_1.RegMap.map[indexed[1]]) {
	                return false;
	            }
	            var selindex = { x: 0, y: 1, z: 2, w: 3 };
	            var em = { num: indexed[2] | 0, code: RegMap_1.RegMap.map[indexed[1]].code, swizzle: this.stringToSwizzle(indexed[5]), select: selindex[indexed[3]], offset: indexed[4] | 0 };
	            pr.data.writeUnsignedShort(em.num);
	            pr.data.writeByte(em.offset);
	            pr.data.writeUnsignedByte(em.swizzle);
	            pr.data.writeUnsignedByte(0x1); // constant reg
	            pr.data.writeUnsignedByte(em.code);
	            pr.data.writeUnsignedByte(em.select);
	            pr.data.writeUnsignedByte(1 << 7);
	        }
	        else {
	            reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:swizzle
	            if (!RegMap_1.RegMap.map[reg[1]]) {
	                return false;
	            }
	            var em = { num: reg[2] | 0, code: RegMap_1.RegMap.map[reg[1]].code, swizzle: this.stringToSwizzle(reg[3]) };
	            pr.data.writeUnsignedShort(em.num);
	            pr.data.writeUnsignedByte(0);
	            pr.data.writeUnsignedByte(em.swizzle);
	            pr.data.writeUnsignedByte(em.code);
	            pr.data.writeUnsignedByte(0);
	            pr.data.writeUnsignedByte(0);
	            pr.data.writeUnsignedByte(0);
	        }
	        return true;
	    };
	    AGALMiniAssembler.prototype.addHeader = function (partname, version) {
	        if (!version) {
	            version = 1;
	        }
	        if (this.r[partname] == undefined) {
	            this.r[partname] = new Part_1.Part(partname, version);
	            this.emitHeader(this.r[partname]);
	        }
	        else if (this.r[partname].version != version) {
	            throw "Multiple versions for part " + partname;
	        }
	        this.cur = this.r[partname];
	    };
	    return AGALMiniAssembler;
	}());
	exports.AGALMiniAssembler = AGALMiniAssembler;


/***/ },
/* 420 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Opcode_1 = __webpack_require__(421);
	var OpcodeMap = (function () {
	    function OpcodeMap() {
	    }
	    Object.defineProperty(OpcodeMap, "map", {
	        get: function () {
	            if (!OpcodeMap._map) {
	                OpcodeMap._map = new Array();
	                OpcodeMap._map['mov'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x00, true, null, null, null); //0
	                OpcodeMap._map['add'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x01, true, null, null, null); //1
	                OpcodeMap._map['sub'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x02, true, null, null, null); //2
	                OpcodeMap._map['mul'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x03, true, null, null, null); //3
	                OpcodeMap._map['div'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x04, true, null, null, null); //4
	                OpcodeMap._map['rcp'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x05, true, null, null, null); //5
	                OpcodeMap._map['min'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x06, true, null, null, null); //6
	                OpcodeMap._map['max'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x07, true, null, null, null); //7
	                OpcodeMap._map['frc'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x08, true, null, null, null); //8
	                OpcodeMap._map['sqt'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x09, true, null, null, null); //9
	                OpcodeMap._map['rsq'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x0a, true, null, null, null); //10
	                OpcodeMap._map['pow'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x0b, true, null, null, null); //11
	                OpcodeMap._map['log'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x0c, true, null, null, null); //12
	                OpcodeMap._map['exp'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x0d, true, null, null, null); //13
	                OpcodeMap._map['nrm'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x0e, true, null, null, null); //14
	                OpcodeMap._map['sin'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x0f, true, null, null, null); //15
	                OpcodeMap._map['cos'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x10, true, null, null, null); //16
	                OpcodeMap._map['crs'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x11, true, true, null, null); //17
	                OpcodeMap._map['dp3'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x12, true, true, null, null); //18
	                OpcodeMap._map['dp4'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x13, true, true, null, null); //19
	                OpcodeMap._map['abs'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x14, true, null, null, null); //20
	                OpcodeMap._map['neg'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x15, true, null, null, null); //21
	                OpcodeMap._map['sat'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x16, true, null, null, null); //22
	                OpcodeMap._map['ted'] = new Opcode_1.Opcode("vector", "vector", 4, "sampler", 1, 0x26, true, null, true, null); //38
	                OpcodeMap._map['kil'] = new Opcode_1.Opcode("none", "scalar", 1, "none", 0, 0x27, true, null, true, null); //39
	                OpcodeMap._map['tex'] = new Opcode_1.Opcode("vector", "vector", 4, "sampler", 1, 0x28, true, null, true, null); //40
	                OpcodeMap._map['m33'] = new Opcode_1.Opcode("vector", "matrix", 3, "vector", 3, 0x17, true, null, null, true); //23
	                OpcodeMap._map['m44'] = new Opcode_1.Opcode("vector", "matrix", 4, "vector", 4, 0x18, true, null, null, true); //24
	                OpcodeMap._map['m43'] = new Opcode_1.Opcode("vector", "matrix", 3, "vector", 4, 0x19, true, null, null, true); //25
	                OpcodeMap._map['ddx'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x1a, true, null, true, null); //26
	                OpcodeMap._map['ddy'] = new Opcode_1.Opcode("vector", "vector", 4, "none", 0, 0x1b, true, null, true, null); //27
	                OpcodeMap._map['sge'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x29, true, null, null, null); //41
	                OpcodeMap._map['slt'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x2a, true, null, null, null); //42
	                OpcodeMap._map['sgn'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x2b, true, null, null, null); //43
	                OpcodeMap._map['seq'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x2c, true, null, null, null); //44
	                OpcodeMap._map['sne'] = new Opcode_1.Opcode("vector", "vector", 4, "vector", 4, 0x2d, true, null, null, null); //45
	            }
	            return OpcodeMap._map;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return OpcodeMap;
	}());
	exports.OpcodeMap = OpcodeMap;


/***/ },
/* 421 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Flags_1 = __webpack_require__(422);
	var FS_1 = __webpack_require__(423);
	/**
	 *
	 */
	var Opcode = (function () {
	    function Opcode(dest, aformat, asize, bformat, bsize, opcode, simple, horizontal, fragonly, matrix) {
	        this.a = new FS_1.FS();
	        this.b = new FS_1.FS();
	        this.flags = new Flags_1.Flags();
	        this.dest = dest;
	        this.a.format = aformat;
	        this.a.size = asize;
	        this.b.format = bformat;
	        this.b.size = bsize;
	        this.opcode = opcode;
	        this.flags.simple = simple;
	        this.flags.horizontal = horizontal;
	        this.flags.fragonly = fragonly;
	        this.flags.matrix = matrix;
	    }
	    return Opcode;
	}());
	exports.Opcode = Opcode;


/***/ },
/* 422 */
/***/ function(module, exports) {

	"use strict";
	var Flags = (function () {
	    function Flags() {
	    }
	    return Flags;
	}());
	exports.Flags = Flags;


/***/ },
/* 423 */
/***/ function(module, exports) {

	"use strict";
	var FS = (function () {
	    function FS() {
	    }
	    return FS;
	}());
	exports.FS = FS;


/***/ },
/* 424 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ByteArray_1 = __webpack_require__(292);
	var Part = (function () {
	    function Part(name, version) {
	        if (name === void 0) { name = null; }
	        if (version === void 0) { version = null; }
	        this.name = "";
	        this.version = 0;
	        this.name = name;
	        this.version = version;
	        this.data = new ByteArray_1.ByteArray();
	    }
	    return Part;
	}());
	exports.Part = Part;


/***/ },
/* 425 */
/***/ function(module, exports) {

	"use strict";
	var Reg = (function () {
	    function Reg(code, desc) {
	        this.code = code;
	        this.desc = desc;
	    }
	    return Reg;
	}());
	var RegMap = (function () {
	    /*
	     public static va:Reg = new Reg( 0x00, "vertex attribute" );
	     public static fc:Reg = new Reg( 0x01, "fragment constant" );
	     public static vc:Reg = new Reg( 0x01, "vertex constant" );
	     public static ft:Reg = new Reg( 0x02, "fragment temporary" );
	     public static vt:Reg = new Reg( 0x02, "vertex temporary" );
	     public static vo:Reg = new Reg( 0x03, "vertex output" );
	     public static op:Reg = new Reg( 0x03, "vertex output" );
	     public static fd:Reg = new Reg( 0x03, "fragment depth output" );
	     public static fo:Reg = new Reg( 0x03, "fragment output" );
	     public static oc:Reg = new Reg( 0x03, "fragment output" );
	     public static v: Reg = new Reg( 0x04, "varying" );
	     public static vi:Reg = new Reg( 0x04, "varying output" );
	     public static fi:Reg = new Reg( 0x04, "varying input" );
	     public static fs:Reg = new Reg( 0x05, "sampler" );
	     */
	    function RegMap() {
	    }
	    Object.defineProperty(RegMap, "map", {
	        get: function () {
	            if (!RegMap._map) {
	                RegMap._map = new Array();
	                RegMap._map['va'] = new Reg(0x00, "vertex attribute");
	                RegMap._map['fc'] = new Reg(0x01, "fragment constant");
	                RegMap._map['vc'] = new Reg(0x01, "vertex constant");
	                RegMap._map['ft'] = new Reg(0x02, "fragment temporary");
	                RegMap._map['vt'] = new Reg(0x02, "vertex temporary");
	                RegMap._map['vo'] = new Reg(0x03, "vertex output");
	                RegMap._map['op'] = new Reg(0x03, "vertex output");
	                RegMap._map['fd'] = new Reg(0x03, "fragment depth output");
	                RegMap._map['fo'] = new Reg(0x03, "fragment output");
	                RegMap._map['oc'] = new Reg(0x03, "fragment output");
	                RegMap._map['v'] = new Reg(0x04, "varying");
	                RegMap._map['vi'] = new Reg(0x04, "varying output");
	                RegMap._map['fi'] = new Reg(0x04, "varying input");
	                RegMap._map['fs'] = new Reg(0x05, "sampler");
	            }
	            return RegMap._map;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return RegMap;
	}());
	exports.RegMap = RegMap;


/***/ },
/* 426 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Sampler_1 = __webpack_require__(427);
	var SamplerMap = (function () {
	    /*
	     public static map =     [ new Sampler( 8, 0xf, 0 ),
	     new Sampler( 8, 0xf, 5 ),
	     new Sampler( 8, 0xf, 4 ),
	     new Sampler( 8, 0xf, 1 ),
	     new Sampler( 8, 0xf, 2 ),
	     new Sampler( 8, 0xf, 1 ),
	     new Sampler( 8, 0xf, 2 ),
	
	     // dimension
	     new Sampler( 12, 0xf, 0 ),
	     new Sampler( 12, 0xf, 1 ),
	     new Sampler( 12, 0xf, 2 ),
	
	     // special
	     new Sampler( 16, 1, 1 ),
	     new Sampler( 16, 4, 4 ),
	
	     // repeat
	     new Sampler( 20, 0xf, 0 ),
	     new Sampler( 20, 0xf, 1 ),
	     new Sampler( 20, 0xf, 1 ),
	
	     // mip
	     new Sampler( 24, 0xf, 0 ),
	     new Sampler( 24, 0xf, 0 ),
	     new Sampler( 24, 0xf, 1 ),
	     new Sampler( 24, 0xf, 2 ),
	
	     // filter
	     new Sampler( 28, 0xf, 0 ),
	     new Sampler( 28, 0xf, 1 ) ]
	     */
	    /*
	     public static rgba: Sampler = new Sampler( 8, 0xf, 0 );
	     public static rg: Sampler = new Sampler( 8, 0xf, 5 );
	     public static r: Sampler = new Sampler( 8, 0xf, 4 );
	     public static compressed: Sampler = new Sampler( 8, 0xf, 1 );
	     public static compressed_alpha: Sampler = new Sampler( 8, 0xf, 2 );
	     public static dxt1: Sampler = new Sampler( 8, 0xf, 1 );
	     public static dxt5: Sampler = new Sampler( 8, 0xf, 2 );
	
	     // dimension
	     public static sampler2d: Sampler = new Sampler( 12, 0xf, 0 );
	     public static cube: Sampler = new Sampler( 12, 0xf, 1 );
	     public static sampler3d: Sampler = new Sampler( 12, 0xf, 2 );
	
	     // special
	     public static centroid: Sampler = new Sampler( 16, 1, 1 );
	     public static ignoresampler: Sampler = new Sampler( 16, 4, 4 );
	
	     // repeat
	     public static clamp: Sampler = new Sampler( 20, 0xf, 0 );
	     public static repeat: Sampler = new Sampler( 20, 0xf, 1 );
	     public static wrap: Sampler = new Sampler( 20, 0xf, 1 );
	
	     // mip
	     public static nomip: Sampler = new Sampler( 24, 0xf, 0 );
	     public static mipnone: Sampler = new Sampler( 24, 0xf, 0 );
	     public static mipnearest: Sampler = new Sampler( 24, 0xf, 1 );
	     public static miplinear: Sampler = new Sampler( 24, 0xf, 2 );
	
	     // filter
	     public static nearest: Sampler = new Sampler( 28, 0xf, 0 );
	     public static linear: Sampler = new Sampler( 28, 0xf, 1 );
	     */
	    function SamplerMap() {
	    }
	    Object.defineProperty(SamplerMap, "map", {
	        get: function () {
	            if (!SamplerMap._map) {
	                SamplerMap._map = new Array();
	                SamplerMap._map['rgba'] = new Sampler_1.Sampler(8, 0xf, 0);
	                SamplerMap._map['rg'] = new Sampler_1.Sampler(8, 0xf, 5);
	                SamplerMap._map['r'] = new Sampler_1.Sampler(8, 0xf, 4);
	                SamplerMap._map['compressed'] = new Sampler_1.Sampler(8, 0xf, 1);
	                SamplerMap._map['compressed_alpha'] = new Sampler_1.Sampler(8, 0xf, 2);
	                SamplerMap._map['dxt1'] = new Sampler_1.Sampler(8, 0xf, 1);
	                SamplerMap._map['dxt5'] = new Sampler_1.Sampler(8, 0xf, 2);
	                // dimension
	                SamplerMap._map['2d'] = new Sampler_1.Sampler(12, 0xf, 0);
	                SamplerMap._map['cube'] = new Sampler_1.Sampler(12, 0xf, 1);
	                SamplerMap._map['3d'] = new Sampler_1.Sampler(12, 0xf, 2);
	                // special
	                SamplerMap._map['centroid'] = new Sampler_1.Sampler(16, 1, 1);
	                SamplerMap._map['ignoresampler'] = new Sampler_1.Sampler(16, 4, 4);
	                // repeat
	                SamplerMap._map['clamp'] = new Sampler_1.Sampler(20, 0xf, 0);
	                SamplerMap._map['repeat'] = new Sampler_1.Sampler(20, 0xf, 1);
	                SamplerMap._map['wrap'] = new Sampler_1.Sampler(20, 0xf, 1);
	                // mip
	                SamplerMap._map['nomip'] = new Sampler_1.Sampler(24, 0xf, 0);
	                SamplerMap._map['mipnone'] = new Sampler_1.Sampler(24, 0xf, 0);
	                SamplerMap._map['mipnearest'] = new Sampler_1.Sampler(24, 0xf, 1);
	                SamplerMap._map['miplinear'] = new Sampler_1.Sampler(24, 0xf, 2);
	                // filter
	                SamplerMap._map['nearest'] = new Sampler_1.Sampler(28, 0xf, 0);
	                SamplerMap._map['linear'] = new Sampler_1.Sampler(28, 0xf, 1);
	            }
	            return SamplerMap._map;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return SamplerMap;
	}());
	exports.SamplerMap = SamplerMap;


/***/ },
/* 427 */
/***/ function(module, exports) {

	"use strict";
	var Sampler = (function () {
	    function Sampler(shift, mask, value) {
	        this.shift = shift;
	        this.mask = mask;
	        this.value = value;
	    }
	    return Sampler;
	}());
	exports.Sampler = Sampler;


/***/ },
/* 428 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventDispatcher_1 = __webpack_require__(11);
	var ArgumentError_1 = __webpack_require__(37);
	var Stage_1 = __webpack_require__(56);
	var StageEvent_1 = __webpack_require__(60);
	/**
	 * The StageManager class provides a multiton object that handles management for Stage objects.
	 *
	 * @see away.base.Stage
	 */
	var StageManager = (function (_super) {
	    __extends(StageManager, _super);
	    /**
	     * Creates a new StageManager class.
	     * @param stage The Stage object that contains the Stage objects to be managed.
	     * @private
	     */
	    function StageManager() {
	        var _this = this;
	        _super.call(this);
	        this._stages = new Array(StageManager.STAGE_MAX_QUANTITY);
	        this._onContextCreatedDelegate = function (event) { return _this.onContextCreated(event); };
	    }
	    /**
	     * Gets a StageManager instance for the given Stage object.
	     * @param stage The Stage object that contains the Stage objects to be managed.
	     * @return The StageManager instance for the given Stage object.
	     */
	    StageManager.getInstance = function () {
	        if (this._instance == null)
	            this._instance = new StageManager();
	        return this._instance;
	    };
	    /**
	     * Requests the Stage for the given index.
	     *
	     * @param index The index of the requested Stage.
	     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
	     * @param profile The compatibility profile, an enumeration of ContextProfile
	     * @return The Stage for the given index.
	     */
	    StageManager.prototype.getStageAt = function (index, forceSoftware, profile, mode) {
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        if (index < 0 || index >= StageManager.STAGE_MAX_QUANTITY)
	            throw new ArgumentError_1.ArgumentError("Index is out of bounds [0.." + StageManager.STAGE_MAX_QUANTITY + "]");
	        if (!this._stages[index]) {
	            StageManager._numStages++;
	            if (document) {
	                var canvas = document.createElement("canvas");
	                canvas.id = "stage" + index;
	                document.body.appendChild(canvas);
	            }
	            var stage = this._stages[index] = new Stage_1.Stage(canvas, index, this, forceSoftware, profile);
	            stage.addEventListener(StageEvent_1.StageEvent.CONTEXT_CREATED, this._onContextCreatedDelegate);
	            stage.requestContext(forceSoftware, profile, mode);
	        }
	        return stage;
	    };
	    /**
	     * Removes a Stage from the manager.
	     * @param stage
	     * @private
	     */
	    StageManager.prototype.iRemoveStage = function (stage) {
	        StageManager._numStages--;
	        stage.removeEventListener(StageEvent_1.StageEvent.CONTEXT_CREATED, this._onContextCreatedDelegate);
	        this._stages[stage.stageIndex] = null;
	    };
	    /**
	     * Get the next available stage. An error is thrown if there are no StageProxies available
	     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
	     * @param profile The compatibility profile, an enumeration of ContextProfile
	     * @return The allocated stage
	     */
	    StageManager.prototype.getFreeStage = function (forceSoftware, profile, mode) {
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        var i = 0;
	        var len = this._stages.length;
	        while (i < len) {
	            if (!this._stages[i])
	                return this.getStageAt(i, forceSoftware, profile, mode);
	            ++i;
	        }
	        return null;
	    };
	    Object.defineProperty(StageManager.prototype, "hasFreeStage", {
	        /**
	         * Checks if a new stage can be created and managed by the class.
	         * @return true if there is one slot free for a new stage
	         */
	        get: function () {
	            return StageManager._numStages < StageManager.STAGE_MAX_QUANTITY ? true : false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StageManager.prototype, "numSlotsFree", {
	        /**
	         * Returns the amount of stage objects that can be created and managed by the class
	         * @return the amount of free slots
	         */
	        get: function () {
	            return StageManager.STAGE_MAX_QUANTITY - StageManager._numStages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StageManager.prototype, "numSlotsUsed", {
	        /**
	         * Returns the amount of Stage objects currently managed by the class.
	         * @return the amount of slots used
	         */
	        get: function () {
	            return StageManager._numStages;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(StageManager.prototype, "numSlotsTotal", {
	        /**
	         * The maximum amount of Stage objects that can be managed by the class
	         */
	        get: function () {
	            return this._stages.length;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    StageManager.prototype.onContextCreated = function (event) {
	        //var stage:Stage = <Stage> e.target;
	        //document.body.appendChild(stage.canvas)
	    };
	    StageManager.STAGE_MAX_QUANTITY = 8;
	    StageManager._numStages = 0;
	    return StageManager;
	}(EventDispatcher_1.EventDispatcher));
	exports.StageManager = StageManager;


/***/ },
/* 429 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var RendererEvent = (function (_super) {
	    __extends(RendererEvent, _super);
	    function RendererEvent(type) {
	        _super.call(this, type);
	    }
	    RendererEvent.VIEWPORT_UPDATED = "viewportUpdated";
	    RendererEvent.SCISSOR_UPDATED = "scissorUpdated";
	    return RendererEvent;
	}(EventBase_1.EventBase));
	exports.RendererEvent = RendererEvent;


/***/ },
/* 430 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * @class away.sort.RenderableMergeSort
	 */
	var RenderableMergeSort = (function () {
	    function RenderableMergeSort() {
	    }
	    RenderableMergeSort.prototype.sortBlendedRenderables = function (head) {
	        var headB;
	        var fast;
	        var slow;
	        if (!head || !head.next) {
	            return head;
	        }
	        // split in two sublists
	        slow = head;
	        fast = head.next;
	        while (fast) {
	            fast = fast.next;
	            if (fast) {
	                slow = slow.next;
	                fast = fast.next;
	            }
	        }
	        headB = slow.next;
	        slow.next = null;
	        // recurse
	        head = this.sortBlendedRenderables(head);
	        headB = this.sortBlendedRenderables(headB);
	        // merge sublists while respecting order
	        var result;
	        var curr;
	        var l;
	        if (!head)
	            return headB;
	        if (!headB)
	            return head;
	        while (head && headB) {
	            if (head.zIndex < headB.zIndex) {
	                l = head;
	                head = head.next;
	            }
	            else {
	                l = headB;
	                headB = headB.next;
	            }
	            if (!result)
	                result = l;
	            else
	                curr.next = l;
	            curr = l;
	        }
	        if (head)
	            curr.next = head;
	        else if (headB)
	            curr.next = headB;
	        return result;
	    };
	    RenderableMergeSort.prototype.sortOpaqueRenderables = function (head) {
	        var headB;
	        var fast, slow;
	        if (!head || !head.next) {
	            return head;
	        }
	        // split in two sublists
	        slow = head;
	        fast = head.next;
	        while (fast) {
	            fast = fast.next;
	            if (fast) {
	                slow = slow.next;
	                fast = fast.next;
	            }
	        }
	        headB = slow.next;
	        slow.next = null;
	        // recurse
	        head = this.sortOpaqueRenderables(head);
	        headB = this.sortOpaqueRenderables(headB);
	        // merge sublists while respecting order
	        var result;
	        var curr;
	        var l;
	        var cmp = 0;
	        if (!head)
	            return headB;
	        if (!headB)
	            return head;
	        while (head && headB && head != null && headB != null) {
	            // first sort per render order id (reduces program3D switches),
	            // then on render object id (reduces setting props),
	            // then on zIndex (reduces overdraw)
	            var aid = head.renderOrderId;
	            var bid = headB.renderOrderId;
	            if (aid == bid) {
	                var ma = head.surfaceID;
	                var mb = headB.surfaceID;
	                if (ma == mb) {
	                    if (head.zIndex < headB.zIndex)
	                        cmp = 1;
	                    else
	                        cmp = -1;
	                }
	                else if (ma > mb) {
	                    cmp = 1;
	                }
	                else {
	                    cmp = -1;
	                }
	            }
	            else if (aid > bid) {
	                cmp = 1;
	            }
	            else {
	                cmp = -1;
	            }
	            if (cmp < 0) {
	                l = head;
	                head = head.next;
	            }
	            else {
	                l = headB;
	                headB = headB.next;
	            }
	            if (!result) {
	                result = l;
	                curr = l;
	            }
	            else {
	                curr.next = l;
	                curr = l;
	            }
	        }
	        if (head)
	            curr.next = head;
	        else if (headB)
	            curr.next = headB;
	        return result;
	    };
	    return RenderableMergeSort;
	}());
	exports.RenderableMergeSort = RenderableMergeSort;


/***/ },
/* 431 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(432));


/***/ },
/* 432 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AS2ColorAdapter_1 = __webpack_require__(346);
	exports.AS2ColorAdapter = AS2ColorAdapter_1.AS2ColorAdapter;
	var AS2KeyAdapter_1 = __webpack_require__(349);
	exports.AS2KeyAdapter = AS2KeyAdapter_1.AS2KeyAdapter;
	var AS2MCSoundProps_1 = __webpack_require__(345);
	exports.AS2MCSoundProps = AS2MCSoundProps_1.AS2MCSoundProps;
	var AS2MouseAdapter_1 = __webpack_require__(350);
	exports.AS2MouseAdapter = AS2MouseAdapter_1.AS2MouseAdapter;
	var AS2MovieClipAdapter_1 = __webpack_require__(343);
	exports.AS2MovieClipAdapter = AS2MovieClipAdapter_1.AS2MovieClipAdapter;
	var AS2SharedObjectAdapter_1 = __webpack_require__(352);
	exports.AS2SharedObjectAdapter = AS2SharedObjectAdapter_1.AS2SharedObjectAdapter;
	var AS2SoundAdapter_1 = __webpack_require__(348);
	exports.AS2SoundAdapter = AS2SoundAdapter_1.AS2SoundAdapter;
	var AS2StageAdapter_1 = __webpack_require__(351);
	exports.AS2StageAdapter = AS2StageAdapter_1.AS2StageAdapter;
	var AS2SymbolAdapter_1 = __webpack_require__(344);
	exports.AS2SymbolAdapter = AS2SymbolAdapter_1.AS2SymbolAdapter;
	var AS2SystemAdapter_1 = __webpack_require__(347);
	exports.AS2SystemAdapter = AS2SystemAdapter_1.AS2SystemAdapter;
	var AS2TextFieldAdapter_1 = __webpack_require__(353);
	exports.AS2TextFieldAdapter = AS2TextFieldAdapter_1.AS2TextFieldAdapter;


/***/ },
/* 433 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(434));
	__export(__webpack_require__(436));


/***/ },
/* 434 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ParticleData_1 = __webpack_require__(435);
	exports.ParticleData = ParticleData_1.ParticleData;
	var AnimationNodeBase_1 = __webpack_require__(336);
	exports.AnimationNodeBase = AnimationNodeBase_1.AnimationNodeBase;


/***/ },
/* 435 */
/***/ function(module, exports) {

	"use strict";
	var ParticleData = (function () {
	    function ParticleData() {
	    }
	    return ParticleData;
	}());
	exports.ParticleData = ParticleData;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = ParticleData;


/***/ },
/* 436 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AnimationElements_1 = __webpack_require__(437);
	exports.AnimationElements = AnimationElements_1.AnimationElements;
	var AnimationRegisterData_1 = __webpack_require__(320);
	exports.AnimationRegisterData = AnimationRegisterData_1.AnimationRegisterData;
	var ColorSegmentPoint_1 = __webpack_require__(438);
	exports.ColorSegmentPoint = ColorSegmentPoint_1.ColorSegmentPoint;
	var JointPose_1 = __webpack_require__(328);
	exports.JointPose = JointPose_1.JointPose;
	var ParticleAnimationData_1 = __webpack_require__(439);
	exports.ParticleAnimationData = ParticleAnimationData_1.ParticleAnimationData;
	var ParticleProperties_1 = __webpack_require__(440);
	exports.ParticleProperties = ParticleProperties_1.ParticleProperties;
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	exports.ParticlePropertiesMode = ParticlePropertiesMode_1.ParticlePropertiesMode;
	var Skeleton_1 = __webpack_require__(332);
	exports.Skeleton = Skeleton_1.Skeleton;
	var SkeletonJoint_1 = __webpack_require__(333);
	exports.SkeletonJoint = SkeletonJoint_1.SkeletonJoint;
	var SkeletonPose_1 = __webpack_require__(330);
	exports.SkeletonPose = SkeletonPose_1.SkeletonPose;
	var VertexAnimationMode_1 = __webpack_require__(321);
	exports.VertexAnimationMode = VertexAnimationMode_1.VertexAnimationMode;
	var AnimationClipNodeBase_1 = __webpack_require__(335);
	exports.AnimationClipNodeBase = AnimationClipNodeBase_1.AnimationClipNodeBase;
	var ParticleAccelerationNode_1 = __webpack_require__(442);
	exports.ParticleAccelerationNode = ParticleAccelerationNode_1.ParticleAccelerationNode;
	var ParticleBezierCurveNode_1 = __webpack_require__(446);
	exports.ParticleBezierCurveNode = ParticleBezierCurveNode_1.ParticleBezierCurveNode;
	var ParticleBillboardNode_1 = __webpack_require__(448);
	exports.ParticleBillboardNode = ParticleBillboardNode_1.ParticleBillboardNode;
	var ParticleColorNode_1 = __webpack_require__(450);
	exports.ParticleColorNode = ParticleColorNode_1.ParticleColorNode;
	var ParticleFollowNode_1 = __webpack_require__(455);
	exports.ParticleFollowNode = ParticleFollowNode_1.ParticleFollowNode;
	var ParticleInitialColorNode_1 = __webpack_require__(457);
	exports.ParticleInitialColorNode = ParticleInitialColorNode_1.ParticleInitialColorNode;
	var ParticleNodeBase_1 = __webpack_require__(443);
	exports.ParticleNodeBase = ParticleNodeBase_1.ParticleNodeBase;
	var ParticleOrbitNode_1 = __webpack_require__(459);
	exports.ParticleOrbitNode = ParticleOrbitNode_1.ParticleOrbitNode;
	var ParticleOscillatorNode_1 = __webpack_require__(461);
	exports.ParticleOscillatorNode = ParticleOscillatorNode_1.ParticleOscillatorNode;
	var ParticlePositionNode_1 = __webpack_require__(463);
	exports.ParticlePositionNode = ParticlePositionNode_1.ParticlePositionNode;
	var ParticleRotateToHeadingNode_1 = __webpack_require__(465);
	exports.ParticleRotateToHeadingNode = ParticleRotateToHeadingNode_1.ParticleRotateToHeadingNode;
	var ParticleRotateToPositionNode_1 = __webpack_require__(467);
	exports.ParticleRotateToPositionNode = ParticleRotateToPositionNode_1.ParticleRotateToPositionNode;
	var ParticleRotationalVelocityNode_1 = __webpack_require__(469);
	exports.ParticleRotationalVelocityNode = ParticleRotationalVelocityNode_1.ParticleRotationalVelocityNode;
	var ParticleScaleNode_1 = __webpack_require__(471);
	exports.ParticleScaleNode = ParticleScaleNode_1.ParticleScaleNode;
	var ParticleSegmentedColorNode_1 = __webpack_require__(473);
	exports.ParticleSegmentedColorNode = ParticleSegmentedColorNode_1.ParticleSegmentedColorNode;
	var ParticleSpriteSheetNode_1 = __webpack_require__(475);
	exports.ParticleSpriteSheetNode = ParticleSpriteSheetNode_1.ParticleSpriteSheetNode;
	var ParticleTimeNode_1 = __webpack_require__(452);
	exports.ParticleTimeNode = ParticleTimeNode_1.ParticleTimeNode;
	var ParticleUVNode_1 = __webpack_require__(477);
	exports.ParticleUVNode = ParticleUVNode_1.ParticleUVNode;
	var ParticleVelocityNode_1 = __webpack_require__(479);
	exports.ParticleVelocityNode = ParticleVelocityNode_1.ParticleVelocityNode;
	var SkeletonBinaryLERPNode_1 = __webpack_require__(481);
	exports.SkeletonBinaryLERPNode = SkeletonBinaryLERPNode_1.SkeletonBinaryLERPNode;
	var SkeletonClipNode_1 = __webpack_require__(334);
	exports.SkeletonClipNode = SkeletonClipNode_1.SkeletonClipNode;
	var SkeletonDifferenceNode_1 = __webpack_require__(483);
	exports.SkeletonDifferenceNode = SkeletonDifferenceNode_1.SkeletonDifferenceNode;
	var SkeletonDirectionalNode_1 = __webpack_require__(485);
	exports.SkeletonDirectionalNode = SkeletonDirectionalNode_1.SkeletonDirectionalNode;
	var SkeletonNaryLERPNode_1 = __webpack_require__(487);
	exports.SkeletonNaryLERPNode = SkeletonNaryLERPNode_1.SkeletonNaryLERPNode;
	var VertexClipNode_1 = __webpack_require__(340);
	exports.VertexClipNode = VertexClipNode_1.VertexClipNode;
	var AnimationClipState_1 = __webpack_require__(338);
	exports.AnimationClipState = AnimationClipState_1.AnimationClipState;
	var AnimationStateBase_1 = __webpack_require__(339);
	exports.AnimationStateBase = AnimationStateBase_1.AnimationStateBase;
	var ParticleAccelerationState_1 = __webpack_require__(444);
	exports.ParticleAccelerationState = ParticleAccelerationState_1.ParticleAccelerationState;
	var ParticleBezierCurveState_1 = __webpack_require__(447);
	exports.ParticleBezierCurveState = ParticleBezierCurveState_1.ParticleBezierCurveState;
	var ParticleBillboardState_1 = __webpack_require__(449);
	exports.ParticleBillboardState = ParticleBillboardState_1.ParticleBillboardState;
	var ParticleColorState_1 = __webpack_require__(454);
	exports.ParticleColorState = ParticleColorState_1.ParticleColorState;
	var ParticleFollowState_1 = __webpack_require__(456);
	exports.ParticleFollowState = ParticleFollowState_1.ParticleFollowState;
	var ParticleInitialColorState_1 = __webpack_require__(458);
	exports.ParticleInitialColorState = ParticleInitialColorState_1.ParticleInitialColorState;
	var ParticleStateBase_1 = __webpack_require__(445);
	exports.ParticleStateBase = ParticleStateBase_1.ParticleStateBase;
	var ParticleOrbitState_1 = __webpack_require__(460);
	exports.ParticleOrbitState = ParticleOrbitState_1.ParticleOrbitState;
	var ParticleOscillatorState_1 = __webpack_require__(462);
	exports.ParticleOscillatorState = ParticleOscillatorState_1.ParticleOscillatorState;
	var ParticlePositionState_1 = __webpack_require__(464);
	exports.ParticlePositionState = ParticlePositionState_1.ParticlePositionState;
	var ParticleRotateToHeadingState_1 = __webpack_require__(466);
	exports.ParticleRotateToHeadingState = ParticleRotateToHeadingState_1.ParticleRotateToHeadingState;
	var ParticleRotateToPositionState_1 = __webpack_require__(468);
	exports.ParticleRotateToPositionState = ParticleRotateToPositionState_1.ParticleRotateToPositionState;
	var ParticleRotationalVelocityState_1 = __webpack_require__(470);
	exports.ParticleRotationalVelocityState = ParticleRotationalVelocityState_1.ParticleRotationalVelocityState;
	var ParticleScaleState_1 = __webpack_require__(472);
	exports.ParticleScaleState = ParticleScaleState_1.ParticleScaleState;
	var ParticleSegmentedColorState_1 = __webpack_require__(474);
	exports.ParticleSegmentedColorState = ParticleSegmentedColorState_1.ParticleSegmentedColorState;
	var ParticleSpriteSheetState_1 = __webpack_require__(476);
	exports.ParticleSpriteSheetState = ParticleSpriteSheetState_1.ParticleSpriteSheetState;
	var ParticleTimeState_1 = __webpack_require__(453);
	exports.ParticleTimeState = ParticleTimeState_1.ParticleTimeState;
	var ParticleUVState_1 = __webpack_require__(478);
	exports.ParticleUVState = ParticleUVState_1.ParticleUVState;
	var ParticleVelocityState_1 = __webpack_require__(480);
	exports.ParticleVelocityState = ParticleVelocityState_1.ParticleVelocityState;
	var SkeletonBinaryLERPState_1 = __webpack_require__(482);
	exports.SkeletonBinaryLERPState = SkeletonBinaryLERPState_1.SkeletonBinaryLERPState;
	var SkeletonClipState_1 = __webpack_require__(337);
	exports.SkeletonClipState = SkeletonClipState_1.SkeletonClipState;
	var SkeletonDifferenceState_1 = __webpack_require__(484);
	exports.SkeletonDifferenceState = SkeletonDifferenceState_1.SkeletonDifferenceState;
	var SkeletonDirectionalState_1 = __webpack_require__(486);
	exports.SkeletonDirectionalState = SkeletonDirectionalState_1.SkeletonDirectionalState;
	var SkeletonNaryLERPState_1 = __webpack_require__(488);
	exports.SkeletonNaryLERPState = SkeletonNaryLERPState_1.SkeletonNaryLERPState;
	var VertexClipState_1 = __webpack_require__(341);
	exports.VertexClipState = VertexClipState_1.VertexClipState;
	var CrossfadeTransition_1 = __webpack_require__(489);
	exports.CrossfadeTransition = CrossfadeTransition_1.CrossfadeTransition;
	var CrossfadeTransitionNode_1 = __webpack_require__(490);
	exports.CrossfadeTransitionNode = CrossfadeTransitionNode_1.CrossfadeTransitionNode;
	var CrossfadeTransitionState_1 = __webpack_require__(491);
	exports.CrossfadeTransitionState = CrossfadeTransitionState_1.CrossfadeTransitionState;
	var AnimationSetBase_1 = __webpack_require__(318);
	exports.AnimationSetBase = AnimationSetBase_1.AnimationSetBase;
	var AnimatorBase_1 = __webpack_require__(323);
	exports.AnimatorBase = AnimatorBase_1.AnimatorBase;
	var ParticleAnimationSet_1 = __webpack_require__(451);
	exports.ParticleAnimationSet = ParticleAnimationSet_1.ParticleAnimationSet;
	var ParticleAnimator_1 = __webpack_require__(492);
	exports.ParticleAnimator = ParticleAnimator_1.ParticleAnimator;
	var SkeletonAnimationSet_1 = __webpack_require__(326);
	exports.SkeletonAnimationSet = SkeletonAnimationSet_1.SkeletonAnimationSet;
	var SkeletonAnimator_1 = __webpack_require__(327);
	exports.SkeletonAnimator = SkeletonAnimator_1.SkeletonAnimator;
	var VertexAnimationSet_1 = __webpack_require__(317);
	exports.VertexAnimationSet = VertexAnimationSet_1.VertexAnimationSet;
	var VertexAnimator_1 = __webpack_require__(322);
	exports.VertexAnimator = VertexAnimator_1.VertexAnimator;


/***/ },
/* 437 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * ...
	 */
	var AnimationElements = (function () {
	    function AnimationElements() {
	        this._pVertexBuffer = new Array(8);
	        this._pBufferContext = new Array(8);
	        this._pBufferDirty = new Array(8);
	        this.numProcessedVertices = 0;
	        this.previousTime = Number.NEGATIVE_INFINITY;
	        this.animationParticles = new Array();
	        for (var i = 0; i < 8; i++)
	            this._pBufferDirty[i] = true;
	        this._iUniqueId = AnimationElements.SUBGEOM_ID_COUNT++;
	    }
	    AnimationElements.prototype.createVertexData = function (numVertices, totalLenOfOneVertex) {
	        this._numVertices = numVertices;
	        this._totalLenOfOneVertex = totalLenOfOneVertex;
	        this._pVertexData = new Array(numVertices * totalLenOfOneVertex);
	    };
	    AnimationElements.prototype.activateVertexBuffer = function (index, bufferOffset, stage, format) {
	        var contextIndex = stage.stageIndex;
	        var context = stage.context;
	        var buffer = this._pVertexBuffer[contextIndex];
	        if (!buffer || this._pBufferContext[contextIndex] != context) {
	            buffer = this._pVertexBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, this._totalLenOfOneVertex * 4);
	            this._pBufferContext[contextIndex] = context;
	            this._pBufferDirty[contextIndex] = true;
	        }
	        if (this._pBufferDirty[contextIndex]) {
	            buffer.uploadFromArray(this._pVertexData, 0, this._numVertices);
	            this._pBufferDirty[contextIndex] = false;
	        }
	        context.setVertexBufferAt(index, buffer, bufferOffset * 4, format);
	    };
	    AnimationElements.prototype.dispose = function () {
	        while (this._pVertexBuffer.length) {
	            var vertexBuffer = this._pVertexBuffer.pop();
	            if (vertexBuffer)
	                vertexBuffer.dispose();
	        }
	    };
	    AnimationElements.prototype.invalidateBuffer = function () {
	        for (var i = 0; i < 8; i++)
	            this._pBufferDirty[i] = true;
	    };
	    Object.defineProperty(AnimationElements.prototype, "vertexData", {
	        get: function () {
	            return this._pVertexData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationElements.prototype, "numVertices", {
	        get: function () {
	            return this._numVertices;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(AnimationElements.prototype, "totalLenOfOneVertex", {
	        get: function () {
	            return this._totalLenOfOneVertex;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    AnimationElements.SUBGEOM_ID_COUNT = 0;
	    return AnimationElements;
	}());
	exports.AnimationElements = AnimationElements;


/***/ },
/* 438 */
/***/ function(module, exports) {

	"use strict";
	var ColorSegmentPoint = (function () {
	    function ColorSegmentPoint(life, color) {
	        //0<life<1
	        if (life <= 0 || life >= 1)
	            throw (new Error("life exceeds range (0,1)"));
	        this._life = life;
	        this._color = color;
	    }
	    Object.defineProperty(ColorSegmentPoint.prototype, "color", {
	        get: function () {
	            return this._color;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ColorSegmentPoint.prototype, "life", {
	        get: function () {
	            return this._life;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ColorSegmentPoint;
	}());
	exports.ColorSegmentPoint = ColorSegmentPoint;


/***/ },
/* 439 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * ...
	 */
	var ParticleAnimationData = (function () {
	    function ParticleAnimationData(index, startTime, duration, delay, particle) {
	        this.index = index;
	        this.startTime = startTime;
	        this.totalTime = duration + delay;
	        this.duration = duration;
	        this.delay = delay;
	        this.startVertexIndex = particle.startVertexIndex;
	        this.numVertices = particle.numVertices;
	    }
	    return ParticleAnimationData;
	}());
	exports.ParticleAnimationData = ParticleAnimationData;


/***/ },
/* 440 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Dynamic class for holding the local properties of a particle, used for processing the static properties
	 * of particles in the particle animation set before beginning upload to the GPU.
	 */
	var ParticleProperties = (function () {
	    function ParticleProperties() {
	    }
	    return ParticleProperties;
	}());
	exports.ParticleProperties = ParticleProperties;


/***/ },
/* 441 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Options for setting the properties mode of a particle animation node.
	 */
	var ParticlePropertiesMode = (function () {
	    function ParticlePropertiesMode() {
	    }
	    /**
	     * Mode that defines the particle node as acting on global properties (ie. the properties set in the node constructor or the corresponding animation state).
	     */
	    ParticlePropertiesMode.GLOBAL = 0;
	    /**
	     * Mode that defines the particle node as acting on local static properties (ie. the properties of particles set in the initialising on the animation set).
	     */
	    ParticlePropertiesMode.LOCAL_STATIC = 1;
	    /**
	     * Mode that defines the particle node as acting on local dynamic properties (ie. the properties of the particles set in the corresponding animation state).
	     */
	    ParticlePropertiesMode.LOCAL_DYNAMIC = 2;
	    return ParticlePropertiesMode;
	}());
	exports.ParticlePropertiesMode = ParticlePropertiesMode;


/***/ },
/* 442 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleAccelerationState_1 = __webpack_require__(444);
	/**
	 * A particle animation node used to apply a constant acceleration vector to the motion of a particle.
	 */
	var ParticleAccelerationNode = (function (_super) {
	    __extends(ParticleAccelerationNode, _super);
	    /**
	     * Creates a new <code>ParticleAccelerationNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] acceleration    Defines the default acceleration vector of the node, used when in global mode.
	     */
	    function ParticleAccelerationNode(mode, acceleration) {
	        if (acceleration === void 0) { acceleration = null; }
	        _super.call(this, "ParticleAcceleration", mode, 3);
	        this._pStateClass = ParticleAccelerationState_1.ParticleAccelerationState;
	        this._acceleration = acceleration || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleAccelerationNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var accelerationValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleAccelerationState_1.ParticleAccelerationState.ACCELERATION_INDEX, accelerationValue.index);
	        var temp = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(temp, 1);
	        var code = "mul " + temp + "," + animationRegisterData.vertexTime + "," + accelerationValue + "\n";
	        if (animationSet.needVelocity) {
	            var temp2 = registerCache.getFreeVertexVectorTemp();
	            code += "mul " + temp2 + "," + temp + "," + animationRegisterData.vertexTwoConst + "\n";
	            code += "add " + animationRegisterData.velocityTarget + ".xyz," + temp2 + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
	        }
	        registerCache.removeVertexTempUsage(temp);
	        code += "mul " + temp + "," + temp + "," + animationRegisterData.vertexTime + "\n";
	        code += "add " + animationRegisterData.positionTarget + ".xyz," + temp + "," + animationRegisterData.positionTarget + ".xyz\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAccelerationNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAccelerationNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var tempAcceleration = param[ParticleAccelerationNode.ACCELERATION_VECTOR3D];
	        if (!tempAcceleration)
	            throw new Error("there is no " + ParticleAccelerationNode.ACCELERATION_VECTOR3D + " in param!");
	        this._pOneData[0] = tempAcceleration.x / 2;
	        this._pOneData[1] = tempAcceleration.y / 2;
	        this._pOneData[2] = tempAcceleration.z / 2;
	    };
	    /**
	     * Reference for acceleration node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the direction of acceleration on the particle.
	     */
	    ParticleAccelerationNode.ACCELERATION_VECTOR3D = "AccelerationVector3D";
	    return ParticleAccelerationNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleAccelerationNode = ParticleAccelerationNode;


/***/ },
/* 443 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationNodeBase_1 = __webpack_require__(336);
	/**
	 * Provides an abstract base class for particle animation nodes.
	 */
	var ParticleNodeBase = (function (_super) {
	    __extends(ParticleNodeBase, _super);
	    /**
	     * Creates a new <code>ParticleNodeBase</code> object.
	     *
	     * @param               name            Defines the generic name of the particle animation node.
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param               dataLength      Defines the length of the data used by the node when in <code>LOCAL_STATIC</code> mode.
	     * @param    [optional] priority        the priority of the particle animation node, used to order the agal generated in a particle animation set. Defaults to 1.
	     */
	    function ParticleNodeBase(name, mode, dataLength, priority) {
	        if (priority === void 0) { priority = 1; }
	        _super.call(this);
	        this._pDataLength = 3;
	        name = name + ParticleNodeBase.MODES[mode];
	        this.name = name;
	        this._pMode = mode;
	        this._priority = priority;
	        this._pDataLength = dataLength;
	        this._pOneData = new Array(this._pDataLength);
	    }
	    Object.defineProperty(ParticleNodeBase.prototype, "mode", {
	        /**
	         * Returns the property mode of the particle animation node. Typically set in the node constructor
	         *
	         * @see away.animators.ParticlePropertiesMode
	         */
	        get: function () {
	            return this._pMode;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleNodeBase.prototype, "priority", {
	        /**
	         * Returns the priority of the particle animation node, used to order the agal generated in a particle animation set. Set automatically on instantiation.
	         *
	         * @see away.animators.ParticleAnimationSet
	         * @see #getAGALVertexCode
	         */
	        get: function () {
	            return this._priority;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleNodeBase.prototype, "dataLength", {
	        /**
	         * Returns the length of the data used by the node when in <code>LOCAL_STATIC</code> mode. Used to generate the local static data of the particle animation set.
	         *
	         * @see away.animators.ParticleAnimationSet
	         * @see #getAGALVertexCode
	         */
	        get: function () {
	            return this._pDataLength;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleNodeBase.prototype, "oneData", {
	        /**
	         * Returns the generated data vector of the node after one particle pass during the generation of all local static data of the particle animation set.
	         *
	         * @see away.animators.ParticleAnimationSet
	         * @see #generatePropertyOfOneParticle
	         */
	        get: function () {
	            return this._pOneData;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns the AGAL code of the particle animation node for use in the vertex shader.
	     */
	    ParticleNodeBase.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        return "";
	    };
	    /**
	     * Returns the AGAL code of the particle animation node for use in the fragment shader.
	     */
	    ParticleNodeBase.prototype.getAGALFragmentCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        return "";
	    };
	    /**
	     * Returns the AGAL code of the particle animation node for use in the fragment shader when UV coordinates are required.
	     */
	    ParticleNodeBase.prototype.getAGALUVCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        return "";
	    };
	    /**
	     * Called internally by the particle animation set when assigning the set of static properties originally defined by the initParticleFunc of the set.
	     *
	     * @see away.animators.ParticleAnimationSet#initParticleFunc
	     */
	    ParticleNodeBase.prototype._iGeneratePropertyOfOneParticle = function (param) {
	    };
	    /**
	     * Called internally by the particle animation set when determining the requirements of the particle animation node AGAL.
	     */
	    ParticleNodeBase.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	    };
	    //modes alias
	    ParticleNodeBase.GLOBAL = 'Global';
	    ParticleNodeBase.LOCAL_STATIC = 'LocalStatic';
	    ParticleNodeBase.LOCAL_DYNAMIC = 'LocalDynamic';
	    //modes list
	    ParticleNodeBase.MODES = {
	        0: ParticleNodeBase.GLOBAL,
	        1: ParticleNodeBase.LOCAL_STATIC,
	        2: ParticleNodeBase.LOCAL_DYNAMIC
	    };
	    return ParticleNodeBase;
	}(AnimationNodeBase_1.AnimationNodeBase));
	exports.ParticleNodeBase = ParticleNodeBase;


/***/ },
/* 444 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleAccelerationState = (function (_super) {
	    __extends(ParticleAccelerationState, _super);
	    function ParticleAccelerationState(animator, particleAccelerationNode) {
	        _super.call(this, animator, particleAccelerationNode);
	        this._particleAccelerationNode = particleAccelerationNode;
	        this._acceleration = this._particleAccelerationNode._acceleration;
	        this.updateAccelerationData();
	    }
	    Object.defineProperty(ParticleAccelerationState.prototype, "acceleration", {
	        /**
	         * Defines the acceleration vector of the state, used when in global mode.
	         */
	        get: function () {
	            return this._acceleration;
	        },
	        set: function (value) {
	            this._acceleration.x = value.x;
	            this._acceleration.y = value.y;
	            this._acceleration.z = value.z;
	            this.updateAccelerationData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleAccelerationState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleAccelerationState.ACCELERATION_INDEX);
	        if (this._particleAccelerationNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC)
	            animationElements.activateVertexBuffer(index, this._particleAccelerationNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	        else
	            shader.setVertexConst(index, this._halfAcceleration.x, this._halfAcceleration.y, this._halfAcceleration.z);
	    };
	    ParticleAccelerationState.prototype.updateAccelerationData = function () {
	        if (this._particleAccelerationNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL)
	            this._halfAcceleration = new Vector3D_1.Vector3D(this._acceleration.x / 2, this._acceleration.y / 2, this._acceleration.z / 2);
	    };
	    /** @private */
	    ParticleAccelerationState.ACCELERATION_INDEX = 0;
	    return ParticleAccelerationState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleAccelerationState = ParticleAccelerationState;


/***/ },
/* 445 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationStateBase_1 = __webpack_require__(339);
	/**
	 * ...
	 */
	var ParticleStateBase = (function (_super) {
	    __extends(ParticleStateBase, _super);
	    function ParticleStateBase(animator, particleNode, needUpdateTime) {
	        if (needUpdateTime === void 0) { needUpdateTime = false; }
	        _super.call(this, animator, particleNode);
	        this._pDynamicProperties = new Array();
	        this._pDynamicPropertiesDirty = new Object();
	        this._pParticleAnimator = animator;
	        this._particleNode = particleNode;
	        this._pNeedUpdateTime = needUpdateTime;
	    }
	    Object.defineProperty(ParticleStateBase.prototype, "needUpdateTime", {
	        get: function () {
	            return this._pNeedUpdateTime;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleStateBase.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	    };
	    ParticleStateBase.prototype._pUpdateDynamicProperties = function (animationElements) {
	        this._pDynamicPropertiesDirty[animationElements._iUniqueId] = true;
	        var animationParticles = animationElements.animationParticles;
	        var vertexData = animationElements.vertexData;
	        var totalLenOfOneVertex = animationElements.totalLenOfOneVertex;
	        var dataLength = this._particleNode.dataLength;
	        var dataOffset = this._particleNode._iDataOffset;
	        var vertexLength;
	        //			var particleOffset:number;
	        var startingOffset;
	        var vertexOffset;
	        var data;
	        var animationParticle;
	        //			var numParticles:number = _positions.length/dataLength;
	        var numParticles = this._pDynamicProperties.length;
	        var i = 0;
	        var j = 0;
	        var k = 0;
	        //loop through all particles
	        while (i < numParticles) {
	            //loop through each particle data for the current particle
	            while (j < numParticles && (animationParticle = animationParticles[j]).index == i) {
	                data = this._pDynamicProperties[i];
	                vertexLength = animationParticle.numVertices * totalLenOfOneVertex;
	                startingOffset = animationParticle.startVertexIndex * totalLenOfOneVertex + dataOffset;
	                //loop through each vertex in the particle data
	                for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
	                    vertexOffset = startingOffset + k;
	                    //						particleOffset = i * dataLength;
	                    //loop through all vertex data for the current particle data
	                    for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
	                        vertexOffset = startingOffset + k;
	                        vertexData[vertexOffset++] = data.x;
	                        vertexData[vertexOffset++] = data.y;
	                        vertexData[vertexOffset++] = data.z;
	                        if (dataLength == 4)
	                            vertexData[vertexOffset++] = data.w;
	                    }
	                }
	                j++;
	            }
	            i++;
	        }
	        animationElements.invalidateBuffer();
	    };
	    return ParticleStateBase;
	}(AnimationStateBase_1.AnimationStateBase));
	exports.ParticleStateBase = ParticleStateBase;


/***/ },
/* 446 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleBezierCurveState_1 = __webpack_require__(447);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used to control the position of a particle over time along a bezier curve.
	 */
	var ParticleBezierCurveNode = (function (_super) {
	    __extends(ParticleBezierCurveNode, _super);
	    /**
	     * Creates a new <code>ParticleBezierCurveNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] controlPoint    Defines the default control point of the node, used when in global mode.
	     * @param    [optional] endPoint        Defines the default end point of the node, used when in global mode.
	     */
	    function ParticleBezierCurveNode(mode, controlPoint, endPoint) {
	        if (controlPoint === void 0) { controlPoint = null; }
	        if (endPoint === void 0) { endPoint = null; }
	        _super.call(this, "ParticleBezierCurve", mode, 6);
	        this._pStateClass = ParticleBezierCurveState_1.ParticleBezierCurveState;
	        this._iControlPoint = controlPoint || new Vector3D_1.Vector3D();
	        this._iEndPoint = endPoint || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleBezierCurveNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var controlValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleBezierCurveState_1.ParticleBezierCurveState.BEZIER_CONTROL_INDEX, controlValue.index);
	        var endValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleBezierCurveState_1.ParticleBezierCurveState.BEZIER_END_INDEX, endValue.index);
	        var temp = registerCache.getFreeVertexVectorTemp();
	        var rev_time = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 0);
	        var time_2 = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 1);
	        var time_temp = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 2);
	        registerCache.addVertexTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeVertexVectorTemp();
	        var distance = new ShaderRegisterElement_1.ShaderRegisterElement(temp2.regName, temp2.index);
	        registerCache.removeVertexTempUsage(temp);
	        var code = "";
	        code += "sub " + rev_time + "," + animationRegisterData.vertexOneConst + "," + animationRegisterData.vertexLife + "\n";
	        code += "mul " + time_2 + "," + animationRegisterData.vertexLife + "," + animationRegisterData.vertexLife + "\n";
	        code += "mul " + time_temp + "," + animationRegisterData.vertexLife + "," + rev_time + "\n";
	        code += "mul " + time_temp + "," + time_temp + "," + animationRegisterData.vertexTwoConst + "\n";
	        code += "mul " + distance + ".xyz," + time_temp + "," + controlValue + "\n";
	        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	        code += "mul " + distance + ".xyz," + time_2 + "," + endValue + "\n";
	        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	        if (animationSet.needVelocity) {
	            code += "mul " + time_2 + "," + animationRegisterData.vertexLife + "," + animationRegisterData.vertexTwoConst + "\n";
	            code += "sub " + time_temp + "," + animationRegisterData.vertexOneConst + "," + time_2 + "\n";
	            code += "mul " + time_temp + "," + animationRegisterData.vertexTwoConst + "," + time_temp + "\n";
	            code += "mul " + distance + ".xyz," + controlValue + "," + time_temp + "\n";
	            code += "add " + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
	            code += "mul " + distance + ".xyz," + endValue + "," + time_2 + "\n";
	            code += "add " + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleBezierCurveNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleBezierCurveNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var bezierControl = param[ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D];
	        if (!bezierControl)
	            throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D + " in param!");
	        var bezierEnd = param[ParticleBezierCurveNode.BEZIER_END_VECTOR3D];
	        if (!bezierEnd)
	            throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_END_VECTOR3D + " in param!");
	        this._pOneData[0] = bezierControl.x;
	        this._pOneData[1] = bezierControl.y;
	        this._pOneData[2] = bezierControl.z;
	        this._pOneData[3] = bezierEnd.x;
	        this._pOneData[4] = bezierEnd.y;
	        this._pOneData[5] = bezierEnd.z;
	    };
	    /**
	     * Reference for bezier curve node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the control point position (0, 1, 2) of the curve.
	     */
	    ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D = "BezierControlVector3D";
	    /**
	     * Reference for bezier curve node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the end point position (0, 1, 2) of the curve.
	     */
	    ParticleBezierCurveNode.BEZIER_END_VECTOR3D = "BezierEndVector3D";
	    return ParticleBezierCurveNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleBezierCurveNode = ParticleBezierCurveNode;


/***/ },
/* 447 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleBezierCurveState = (function (_super) {
	    __extends(ParticleBezierCurveState, _super);
	    function ParticleBezierCurveState(animator, particleBezierCurveNode) {
	        _super.call(this, animator, particleBezierCurveNode);
	        this._particleBezierCurveNode = particleBezierCurveNode;
	        this._controlPoint = this._particleBezierCurveNode._iControlPoint;
	        this._endPoint = this._particleBezierCurveNode._iEndPoint;
	    }
	    Object.defineProperty(ParticleBezierCurveState.prototype, "controlPoint", {
	        /**
	         * Defines the default control point of the node, used when in global mode.
	         */
	        get: function () {
	            return this._controlPoint;
	        },
	        set: function (value) {
	            this._controlPoint = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleBezierCurveState.prototype, "endPoint", {
	        /**
	         * Defines the default end point of the node, used when in global mode.
	         */
	        get: function () {
	            return this._endPoint;
	        },
	        set: function (value) {
	            this._endPoint = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleBezierCurveState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        var controlIndex = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleBezierCurveState.BEZIER_CONTROL_INDEX);
	        var endIndex = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleBezierCurveState.BEZIER_END_INDEX);
	        if (this._particleBezierCurveNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	            animationElements.activateVertexBuffer(controlIndex, this._particleBezierCurveNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	            animationElements.activateVertexBuffer(endIndex, this._particleBezierCurveNode._iDataOffset + 3, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	        }
	        else {
	            shader.setVertexConst(controlIndex, this._controlPoint.x, this._controlPoint.y, this._controlPoint.z);
	            shader.setVertexConst(endIndex, this._endPoint.x, this._endPoint.y, this._endPoint.z);
	        }
	    };
	    /** @private */
	    ParticleBezierCurveState.BEZIER_CONTROL_INDEX = 0;
	    /** @private */
	    ParticleBezierCurveState.BEZIER_END_INDEX = 1;
	    return ParticleBezierCurveState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleBezierCurveState = ParticleBezierCurveState;


/***/ },
/* 448 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleBillboardState_1 = __webpack_require__(449);
	/**
	 * A particle animation node that controls the rotation of a particle to always face the camera.
	 */
	var ParticleBillboardNode = (function (_super) {
	    __extends(ParticleBillboardNode, _super);
	    /**
	     * Creates a new <code>ParticleBillboardNode</code>
	     */
	    function ParticleBillboardNode(billboardAxis) {
	        if (billboardAxis === void 0) { billboardAxis = null; }
	        _super.call(this, "ParticleBillboard", ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL, 0, 4);
	        this._pStateClass = ParticleBillboardState_1.ParticleBillboardState;
	        this._iBillboardAxis = billboardAxis;
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleBillboardNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var rotationMatrixRegister = registerCache.getFreeVertexConstant();
	        animationRegisterData.setRegisterIndex(this, ParticleBillboardState_1.ParticleBillboardState.MATRIX_INDEX, rotationMatrixRegister.index);
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        var temp = registerCache.getFreeVertexVectorTemp();
	        var code = "m33 " + temp + ".xyz," + animationRegisterData.scaleAndRotateTarget + "," + rotationMatrixRegister + "\n" +
	            "mov " + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp + "\n";
	        var shaderRegisterElement;
	        for (var i = 0; i < animationRegisterData.rotationRegisters.length; i++) {
	            shaderRegisterElement = animationRegisterData.rotationRegisters[i];
	            code += "m33 " + temp + ".xyz," + shaderRegisterElement + "," + rotationMatrixRegister + "\n" +
	                "mov " + shaderRegisterElement + ".xyz," + shaderRegisterElement + "\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleBillboardNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleBillboardNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	        particleAnimationSet.hasBillboard = true;
	    };
	    return ParticleBillboardNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleBillboardNode = ParticleBillboardNode;


/***/ },
/* 449 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MathConsts_1 = __webpack_require__(35);
	var Matrix3D_1 = __webpack_require__(32);
	var Orientation3D_1 = __webpack_require__(36);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleBillboardState = (function (_super) {
	    __extends(ParticleBillboardState, _super);
	    /**
	     *
	     */
	    function ParticleBillboardState(animator, particleNode) {
	        _super.call(this, animator, particleNode);
	        this._matrix = new Matrix3D_1.Matrix3D;
	        this._billboardAxis = particleNode._iBillboardAxis;
	    }
	    ParticleBillboardState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        var comps;
	        if (this._billboardAxis) {
	            var pos = renderable.sourceEntity.sceneTransform.position;
	            var look = camera.sceneTransform.position.subtract(pos);
	            var right = look.crossProduct(this._billboardAxis);
	            right.normalize();
	            look = this.billboardAxis.crossProduct(right);
	            look.normalize();
	            //create a quick inverse projection matrix
	            this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
	            comps = this._matrix.decompose(Orientation3D_1.Orientation3D.AXIS_ANGLE);
	            this._matrix.copyColumnFrom(0, right);
	            this._matrix.copyColumnFrom(1, this.billboardAxis);
	            this._matrix.copyColumnFrom(2, look);
	            this._matrix.copyColumnFrom(3, pos);
	            this._matrix.appendRotation(-comps[1].w * MathConsts_1.MathConsts.RADIANS_TO_DEGREES, comps[1]);
	        }
	        else {
	            //create a quick inverse projection matrix
	            this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
	            this._matrix.append(camera.inverseSceneTransform);
	            //decompose using axis angle rotations
	            comps = this._matrix.decompose(Orientation3D_1.Orientation3D.AXIS_ANGLE);
	            //recreate the matrix with just the rotation data
	            this._matrix.identity();
	            this._matrix.appendRotation(-comps[1].w * MathConsts_1.MathConsts.RADIANS_TO_DEGREES, comps[1]);
	        }
	        //set a new matrix transform constant
	        shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleBillboardState.MATRIX_INDEX), this._matrix);
	    };
	    Object.defineProperty(ParticleBillboardState.prototype, "billboardAxis", {
	        /**
	         * Defines the billboard axis.
	         */
	        get: function () {
	            return this.billboardAxis;
	        },
	        set: function (value) {
	            this.billboardAxis = value ? value.clone() : null;
	            if (this.billboardAxis)
	                this.billboardAxis.normalize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /** @private */
	    ParticleBillboardState.MATRIX_INDEX = 0;
	    return ParticleBillboardState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleBillboardState = ParticleBillboardState;


/***/ },
/* 450 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ColorTransform_1 = __webpack_require__(27);
	var ParticleAnimationSet_1 = __webpack_require__(451);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleColorState_1 = __webpack_require__(454);
	/**
	 * A particle animation node used to control the color variation of a particle over time.
	 */
	var ParticleColorNode = (function (_super) {
	    __extends(ParticleColorNode, _super);
	    /**
	     * Creates a new <code>ParticleColorNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] usesMultiplier  Defines whether the node uses multiplier data in the shader for its color transformations. Defaults to true.
	     * @param    [optional] usesOffset      Defines whether the node uses offset data in the shader for its color transformations. Defaults to true.
	     * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the animation independent of particle duration. Defaults to false.
	     * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
	     * @param    [optional] startColor      Defines the default start color transform of the node, when in global mode.
	     * @param    [optional] endColor        Defines the default end color transform of the node, when in global mode.
	     * @param    [optional] cycleDuration   Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
	     * @param    [optional] cyclePhase      Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
	     */
	    function ParticleColorNode(mode, usesMultiplier, usesOffset, usesCycle, usesPhase, startColor, endColor, cycleDuration, cyclePhase) {
	        if (usesMultiplier === void 0) { usesMultiplier = true; }
	        if (usesOffset === void 0) { usesOffset = true; }
	        if (usesCycle === void 0) { usesCycle = false; }
	        if (usesPhase === void 0) { usesPhase = false; }
	        if (startColor === void 0) { startColor = null; }
	        if (endColor === void 0) { endColor = null; }
	        if (cycleDuration === void 0) { cycleDuration = 1; }
	        if (cyclePhase === void 0) { cyclePhase = 0; }
	        _super.call(this, "ParticleColor", mode, (usesMultiplier && usesOffset) ? 16 : 8, ParticleAnimationSet_1.ParticleAnimationSet.COLOR_PRIORITY);
	        this._pStateClass = ParticleColorState_1.ParticleColorState;
	        this._iUsesMultiplier = usesMultiplier;
	        this._iUsesOffset = usesOffset;
	        this._iUsesCycle = usesCycle;
	        this._iUsesPhase = usesPhase;
	        this._iStartColor = startColor || new ColorTransform_1.ColorTransform();
	        this._iEndColor = endColor || new ColorTransform_1.ColorTransform();
	        this._iCycleDuration = cycleDuration;
	        this._iCyclePhase = cyclePhase;
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleColorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var code = "";
	        if (shader.usesFragmentAnimation) {
	            var temp = registerCache.getFreeVertexVectorTemp();
	            if (this._iUsesCycle) {
	                var cycleConst = registerCache.getFreeVertexConstant();
	                animationRegisterData.setRegisterIndex(this, ParticleColorState_1.ParticleColorState.CYCLE_INDEX, cycleConst.index);
	                registerCache.addVertexTempUsages(temp, 1);
	                var sin = registerCache.getFreeVertexSingleTemp();
	                registerCache.removeVertexTempUsage(temp);
	                code += "mul " + sin + "," + animationRegisterData.vertexTime + "," + cycleConst + ".x\n";
	                if (this._iUsesPhase)
	                    code += "add " + sin + "," + sin + "," + cycleConst + ".y\n";
	                code += "sin " + sin + "," + sin + "\n";
	            }
	            if (this._iUsesMultiplier) {
	                var startMultiplierValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	                var deltaMultiplierValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	                animationRegisterData.setRegisterIndex(this, ParticleColorState_1.ParticleColorState.START_MULTIPLIER_INDEX, startMultiplierValue.index);
	                animationRegisterData.setRegisterIndex(this, ParticleColorState_1.ParticleColorState.DELTA_MULTIPLIER_INDEX, deltaMultiplierValue.index);
	                code += "mul " + temp + "," + deltaMultiplierValue + "," + (this._iUsesCycle ? sin : animationRegisterData.vertexLife) + "\n";
	                code += "add " + temp + "," + temp + "," + startMultiplierValue + "\n";
	                code += "mul " + animationRegisterData.colorMulTarget + "," + temp + "," + animationRegisterData.colorMulTarget + "\n";
	            }
	            if (this._iUsesOffset) {
	                var startOffsetValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) ? registerCache.getFreeVertexAttribute() : registerCache.getFreeVertexConstant();
	                var deltaOffsetValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) ? registerCache.getFreeVertexAttribute() : registerCache.getFreeVertexConstant();
	                animationRegisterData.setRegisterIndex(this, ParticleColorState_1.ParticleColorState.START_OFFSET_INDEX, startOffsetValue.index);
	                animationRegisterData.setRegisterIndex(this, ParticleColorState_1.ParticleColorState.DELTA_OFFSET_INDEX, deltaOffsetValue.index);
	                code += "mul " + temp + "," + deltaOffsetValue + "," + (this._iUsesCycle ? sin : animationRegisterData.vertexLife) + "\n";
	                code += "add " + temp + "," + temp + "," + startOffsetValue + "\n";
	                code += "add " + animationRegisterData.colorAddTarget + "," + temp + "," + animationRegisterData.colorAddTarget + "\n";
	            }
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleColorNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	        if (this._iUsesMultiplier)
	            particleAnimationSet.hasColorMulNode = true;
	        if (this._iUsesOffset)
	            particleAnimationSet.hasColorAddNode = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var startColor = param[ParticleColorNode.COLOR_START_COLORTRANSFORM];
	        if (!startColor)
	            throw (new Error("there is no " + ParticleColorNode.COLOR_START_COLORTRANSFORM + " in param!"));
	        var endColor = param[ParticleColorNode.COLOR_END_COLORTRANSFORM];
	        if (!endColor)
	            throw (new Error("there is no " + ParticleColorNode.COLOR_END_COLORTRANSFORM + " in param!"));
	        var i = 0;
	        if (!this._iUsesCycle) {
	            //multiplier
	            if (this._iUsesMultiplier) {
	                this._pOneData[i++] = startColor.redMultiplier;
	                this._pOneData[i++] = startColor.greenMultiplier;
	                this._pOneData[i++] = startColor.blueMultiplier;
	                this._pOneData[i++] = startColor.alphaMultiplier;
	                this._pOneData[i++] = endColor.redMultiplier - startColor.redMultiplier;
	                this._pOneData[i++] = endColor.greenMultiplier - startColor.greenMultiplier;
	                this._pOneData[i++] = endColor.blueMultiplier - startColor.blueMultiplier;
	                this._pOneData[i++] = endColor.alphaMultiplier - startColor.alphaMultiplier;
	            }
	            //offset
	            if (this._iUsesOffset) {
	                this._pOneData[i++] = startColor.redOffset / 255;
	                this._pOneData[i++] = startColor.greenOffset / 255;
	                this._pOneData[i++] = startColor.blueOffset / 255;
	                this._pOneData[i++] = startColor.alphaOffset / 255;
	                this._pOneData[i++] = (endColor.redOffset - startColor.redOffset) / 255;
	                this._pOneData[i++] = (endColor.greenOffset - startColor.greenOffset) / 255;
	                this._pOneData[i++] = (endColor.blueOffset - startColor.blueOffset) / 255;
	                this._pOneData[i++] = (endColor.alphaOffset - startColor.alphaOffset) / 255;
	            }
	        }
	        else {
	            //multiplier
	            if (this._iUsesMultiplier) {
	                this._pOneData[i++] = (startColor.redMultiplier + endColor.redMultiplier) / 2;
	                this._pOneData[i++] = (startColor.greenMultiplier + endColor.greenMultiplier) / 2;
	                this._pOneData[i++] = (startColor.blueMultiplier + endColor.blueMultiplier) / 2;
	                this._pOneData[i++] = (startColor.alphaMultiplier + endColor.alphaMultiplier) / 2;
	                this._pOneData[i++] = (startColor.redMultiplier - endColor.redMultiplier) / 2;
	                this._pOneData[i++] = (startColor.greenMultiplier - endColor.greenMultiplier) / 2;
	                this._pOneData[i++] = (startColor.blueMultiplier - endColor.blueMultiplier) / 2;
	                this._pOneData[i++] = (startColor.alphaMultiplier - endColor.alphaMultiplier) / 2;
	            }
	            //offset
	            if (this._iUsesOffset) {
	                this._pOneData[i++] = (startColor.redOffset + endColor.redOffset) / (255 * 2);
	                this._pOneData[i++] = (startColor.greenOffset + endColor.greenOffset) / (255 * 2);
	                this._pOneData[i++] = (startColor.blueOffset + endColor.blueOffset) / (255 * 2);
	                this._pOneData[i++] = (startColor.alphaOffset + endColor.alphaOffset) / (255 * 2);
	                this._pOneData[i++] = (startColor.redOffset - endColor.redOffset) / (255 * 2);
	                this._pOneData[i++] = (startColor.greenOffset - endColor.greenOffset) / (255 * 2);
	                this._pOneData[i++] = (startColor.blueOffset - endColor.blueOffset) / (255 * 2);
	                this._pOneData[i++] = (startColor.alphaOffset - endColor.alphaOffset) / (255 * 2);
	            }
	        }
	    };
	    /**
	     * Reference for color node properties on a single particle (when in local property mode).
	     * Expects a <code>ColorTransform</code> object representing the start color transform applied to the particle.
	     */
	    ParticleColorNode.COLOR_START_COLORTRANSFORM = "ColorStartColorTransform";
	    /**
	     * Reference for color node properties on a single particle (when in local property mode).
	     * Expects a <code>ColorTransform</code> object representing the end color transform applied to the particle.
	     */
	    ParticleColorNode.COLOR_END_COLORTRANSFORM = "ColorEndColorTransform";
	    return ParticleColorNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleColorNode = ParticleColorNode;


/***/ },
/* 451 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationSetBase_1 = __webpack_require__(318);
	var AnimationRegisterData_1 = __webpack_require__(320);
	var AnimationElements_1 = __webpack_require__(437);
	var ParticleAnimationData_1 = __webpack_require__(439);
	var ParticleProperties_1 = __webpack_require__(440);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleTimeNode_1 = __webpack_require__(452);
	/**
	 * The animation data set used by particle-based animators, containing particle animation data.
	 *
	 * @see away.animators.ParticleAnimator
	 */
	var ParticleAnimationSet = (function (_super) {
	    __extends(ParticleAnimationSet, _super);
	    /**
	     * Creates a new <code>ParticleAnimationSet</code>
	     *
	     * @param    [optional] usesDuration    Defines whether the animation set uses the <code>duration</code> data in its static properties to determine how long a particle is visible for. Defaults to false.
	     * @param    [optional] usesLooping     Defines whether the animation set uses a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in its static properties function. Defaults to false. Requires <code>usesDuration</code> to be true.
	     * @param    [optional] usesDelay       Defines whether the animation set uses the <code>delay</code> data in its static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesLooping</code> to be true.
	     */
	    function ParticleAnimationSet(usesDuration, usesLooping, usesDelay) {
	        if (usesDuration === void 0) { usesDuration = false; }
	        if (usesLooping === void 0) { usesLooping = false; }
	        if (usesDelay === void 0) { usesDelay = false; }
	        _super.call(this);
	        this._animationElements = new Object();
	        this._particleNodes = new Array();
	        this._localDynamicNodes = new Array();
	        this._localStaticNodes = new Array();
	        this._totalLenOfOneVertex = 0;
	        /**
	         *
	         */
	        this.shareAnimationGraphics = true;
	        //automatically add a particle time node to the set
	        this.addAnimation(this._timeNode = new ParticleTimeNode_1.ParticleTimeNode(usesDuration, usesLooping, usesDelay));
	    }
	    Object.defineProperty(ParticleAnimationSet.prototype, "particleNodes", {
	        /**
	         * Returns a vector of the particle animation nodes contained within the set.
	         */
	        get: function () {
	            return this._particleNodes;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimationSet.prototype.addAnimation = function (node) {
	        var i;
	        var n = node;
	        n._iProcessAnimationSetting(this);
	        if (n.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	            n._iDataOffset = this._totalLenOfOneVertex;
	            this._totalLenOfOneVertex += n.dataLength;
	            this._localStaticNodes.push(n);
	        }
	        else if (n.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_DYNAMIC)
	            this._localDynamicNodes.push(n);
	        for (i = this._particleNodes.length - 1; i >= 0; i--) {
	            if (this._particleNodes[i].priority <= n.priority)
	                break;
	        }
	        this._particleNodes.splice(i + 1, 0, n);
	        _super.prototype.addAnimation.call(this, node);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimationSet.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
	        //grab animationRegisterData from the materialpassbase or create a new one if the first time
	        this._iAnimationRegisterData = shader.animationRegisterData;
	        if (this._iAnimationRegisterData == null)
	            this._iAnimationRegisterData = shader.animationRegisterData = new AnimationRegisterData_1.AnimationRegisterData();
	        //reset animationRegisterData
	        this._iAnimationRegisterData.reset(registerCache, sharedRegisters, this.needVelocity);
	        var code = "";
	        var len = sharedRegisters.animatableAttributes.length;
	        for (var i = 0; i < len; i++)
	            code += "mov " + sharedRegisters.animationTargetRegisters[i] + "," + sharedRegisters.animatableAttributes[i] + "\n";
	        code += "mov " + this._iAnimationRegisterData.positionTarget + ".xyz," + this._iAnimationRegisterData.vertexZeroConst + "\n";
	        if (this.needVelocity)
	            code += "mov " + this._iAnimationRegisterData.velocityTarget + ".xyz," + this._iAnimationRegisterData.vertexZeroConst + "\n";
	        var node;
	        var i;
	        for (i = 0; i < this._particleNodes.length; i++) {
	            node = this._particleNodes[i];
	            if (node.priority < ParticleAnimationSet.POST_PRIORITY)
	                code += node.getAGALVertexCode(shader, this, registerCache, this._iAnimationRegisterData);
	        }
	        code += "add " + this._iAnimationRegisterData.scaleAndRotateTarget + ".xyz," + this._iAnimationRegisterData.scaleAndRotateTarget + ".xyz," + this._iAnimationRegisterData.positionTarget + ".xyz\n";
	        for (i = 0; i < this._particleNodes.length; i++) {
	            node = this._particleNodes[i];
	            if (node.priority >= ParticleAnimationSet.POST_PRIORITY && node.priority < ParticleAnimationSet.COLOR_PRIORITY)
	                code += node.getAGALVertexCode(shader, this, registerCache, this._iAnimationRegisterData);
	        }
	        if (this.hasColorMulNode) {
	            this._iAnimationRegisterData.colorMulTarget = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(this._iAnimationRegisterData.colorMulTarget, 1);
	            this._iAnimationRegisterData.colorMulVary = registerCache.getFreeVarying();
	            code += "mov " + this._iAnimationRegisterData.colorMulTarget + "," + this._iAnimationRegisterData.vertexOneConst + "\n";
	        }
	        if (this.hasColorAddNode) {
	            this._iAnimationRegisterData.colorAddTarget = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(this._iAnimationRegisterData.colorAddTarget, 1);
	            this._iAnimationRegisterData.colorAddVary = registerCache.getFreeVarying();
	            code += "mov " + this._iAnimationRegisterData.colorAddTarget + "," + this._iAnimationRegisterData.vertexZeroConst + "\n";
	        }
	        for (i = 0; i < this._particleNodes.length; i++) {
	            node = this._particleNodes[i];
	            if (node.priority >= ParticleAnimationSet.COLOR_PRIORITY)
	                code += node.getAGALVertexCode(shader, this, registerCache, this._iAnimationRegisterData);
	        }
	        if (shader.usesFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
	            if (this.hasColorMulNode)
	                code += "mov " + this._iAnimationRegisterData.colorMulVary + "," + this._iAnimationRegisterData.colorMulTarget + "\n";
	            if (this.hasColorAddNode)
	                code += "mov " + this._iAnimationRegisterData.colorAddVary + "," + this._iAnimationRegisterData.colorAddTarget + "\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimationSet.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        if (this.hasUVNode) {
	            this._iAnimationRegisterData.setUVSourceAndTarget(sharedRegisters);
	            code += "mov " + this._iAnimationRegisterData.uvTarget + ".xy," + this._iAnimationRegisterData.uvAttribute.toString() + "\n";
	            var node;
	            for (var i = 0; i < this._particleNodes.length; i++)
	                node = this._particleNodes[i];
	            code += node.getAGALUVCode(shader, this, registerCache, this._iAnimationRegisterData);
	            code += "mov " + this._iAnimationRegisterData.uvVar + "," + this._iAnimationRegisterData.uvTarget + ".xy\n";
	        }
	        else
	            code += "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimationSet.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
	        var code = "";
	        if (shader.usesFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
	            if (this.hasColorMulNode)
	                code += "mul " + shadedTarget + "," + shadedTarget + "," + this._iAnimationRegisterData.colorMulVary + "\n";
	            if (this.hasColorAddNode)
	                code += "add " + shadedTarget + "," + shadedTarget + "," + this._iAnimationRegisterData.colorAddVary + "\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimationSet.prototype.doneAGALCode = function (shader) {
	        //set vertexZeroConst,vertexOneConst,vertexTwoConst
	        shader.setVertexConst(this._iAnimationRegisterData.vertexZeroConst.index, 0, 1, 2, 0);
	    };
	    Object.defineProperty(ParticleAnimationSet.prototype, "usesCPU", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            return false;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimationSet.prototype.cancelGPUCompatibility = function () {
	    };
	    ParticleAnimationSet.prototype.dispose = function () {
	        for (var key in this._animationElements)
	            this._animationElements[key].dispose();
	        _super.prototype.dispose.call(this);
	    };
	    ParticleAnimationSet.prototype.getAnimationElements = function (graphic) {
	        var animationElements = (this.shareAnimationGraphics) ? this._animationElements[graphic.elements.id] : this._animationElements[graphic.id];
	        if (animationElements)
	            return animationElements;
	        this._iGenerateAnimationElements(graphic.parent);
	        return (this.shareAnimationGraphics) ? this._animationElements[graphic.elements.id] : this._animationElements[graphic.id];
	    };
	    /** @private */
	    ParticleAnimationSet.prototype._iGenerateAnimationElements = function (graphics) {
	        if (this.initParticleFunc == null)
	            throw (new Error("no initParticleFunc set"));
	        var i, j, k;
	        var animationElements;
	        var newAnimationElements = false;
	        var elements;
	        var graphic;
	        var localNode;
	        for (i = 0; i < graphics.count; i++) {
	            graphic = graphics.getGraphicAt(i);
	            elements = graphic.elements;
	            if (this.shareAnimationGraphics) {
	                animationElements = this._animationElements[elements.id];
	                if (animationElements)
	                    continue;
	            }
	            animationElements = new AnimationElements_1.AnimationElements();
	            if (this.shareAnimationGraphics)
	                this._animationElements[elements.id] = animationElements;
	            else
	                this._animationElements[graphic.id] = animationElements;
	            newAnimationElements = true;
	            //create the vertexData vector that will be used for local node data
	            animationElements.createVertexData(elements.numVertices, this._totalLenOfOneVertex);
	        }
	        if (!newAnimationElements)
	            return;
	        var particles = graphics.particles;
	        var particlesLength = particles.length;
	        var numParticles = graphics.numParticles;
	        var particleProperties = new ParticleProperties_1.ParticleProperties();
	        var particle;
	        var oneDataLen;
	        var oneDataOffset;
	        var counterForVertex;
	        var counterForOneData;
	        var oneData;
	        var numVertices;
	        var vertexData;
	        var vertexLength;
	        var startingOffset;
	        var vertexOffset;
	        //default values for particle param
	        particleProperties.total = numParticles;
	        particleProperties.startTime = 0;
	        particleProperties.duration = 1000;
	        particleProperties.delay = 0.1;
	        i = 0;
	        j = 0;
	        while (i < numParticles) {
	            particleProperties.index = i;
	            //call the init on the particle parameters
	            this.initParticleFunc.call(this.initParticleScope, particleProperties);
	            //create the next set of node properties for the particle
	            for (k = 0; k < this._localStaticNodes.length; k++)
	                this._localStaticNodes[k]._iGeneratePropertyOfOneParticle(particleProperties);
	            //loop through all particle data for the curent particle
	            while (j < particlesLength && (particle = particles[j]).particleIndex == i) {
	                //find the target animationElements
	                for (k = 0; k < graphics.count; k++) {
	                    graphic = graphics.getGraphicAt(k);
	                    if (graphic.elements == particle.elements) {
	                        animationElements = (this.shareAnimationGraphics) ? this._animationElements[graphic.elements.id] : this._animationElements[graphic.id];
	                        break;
	                    }
	                }
	                numVertices = particle.numVertices;
	                vertexData = animationElements.vertexData;
	                vertexLength = numVertices * this._totalLenOfOneVertex;
	                startingOffset = animationElements.numProcessedVertices * this._totalLenOfOneVertex;
	                //loop through each static local node in the animation set
	                for (k = 0; k < this._localStaticNodes.length; k++) {
	                    localNode = this._localStaticNodes[k];
	                    oneData = localNode.oneData;
	                    oneDataLen = localNode.dataLength;
	                    oneDataOffset = startingOffset + localNode._iDataOffset;
	                    //loop through each vertex set in the vertex data
	                    for (counterForVertex = 0; counterForVertex < vertexLength; counterForVertex += this._totalLenOfOneVertex) {
	                        vertexOffset = oneDataOffset + counterForVertex;
	                        //add the data for the local node to the vertex data
	                        for (counterForOneData = 0; counterForOneData < oneDataLen; counterForOneData++)
	                            vertexData[vertexOffset + counterForOneData] = oneData[counterForOneData];
	                    }
	                }
	                //store particle properties if they need to be retreived for dynamic local nodes
	                if (this._localDynamicNodes.length)
	                    animationElements.animationParticles.push(new ParticleAnimationData_1.ParticleAnimationData(i, particleProperties.startTime, particleProperties.duration, particleProperties.delay, particle));
	                animationElements.numProcessedVertices += numVertices;
	                //next index
	                j++;
	            }
	            //next particle
	            i++;
	        }
	    };
	    /**
	     * Property used by particle nodes that require compilers at the end of the shader
	     */
	    ParticleAnimationSet.POST_PRIORITY = 9;
	    /**
	     * Property used by particle nodes that require color compilers
	     */
	    ParticleAnimationSet.COLOR_PRIORITY = 18;
	    return ParticleAnimationSet;
	}(AnimationSetBase_1.AnimationSetBase));
	exports.ParticleAnimationSet = ParticleAnimationSet;


/***/ },
/* 452 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleTimeState_1 = __webpack_require__(453);
	/**
	 * A particle animation node used as the base node for timekeeping inside a particle. Automatically added to a particle animation set on instatiation.
	 */
	var ParticleTimeNode = (function (_super) {
	    __extends(ParticleTimeNode, _super);
	    /**
	     * Creates a new <code>ParticleTimeNode</code>
	     *
	     * @param    [optional] usesDuration    Defines whether the node uses the <code>duration</code> data in the static properties to determine how long a particle is visible for. Defaults to false.
	     * @param    [optional] usesDelay       Defines whether the node uses the <code>delay</code> data in the static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesDuration</code> to be true.
	     * @param    [optional] usesLooping     Defines whether the node creates a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in the static properties function. Defaults to false. Requires <code>usesLooping</code> to be true.
	     */
	    function ParticleTimeNode(usesDuration, usesLooping, usesDelay) {
	        if (usesDuration === void 0) { usesDuration = false; }
	        if (usesLooping === void 0) { usesLooping = false; }
	        if (usesDelay === void 0) { usesDelay = false; }
	        _super.call(this, "ParticleTime", ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC, 4, 0);
	        this._pStateClass = ParticleTimeState_1.ParticleTimeState;
	        this._iUsesDuration = usesDuration;
	        this._iUsesLooping = usesLooping;
	        this._iUsesDelay = usesDelay;
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleTimeNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var timeStreamRegister = registerCache.getFreeVertexAttribute(); //timeStreamRegister.x is start，timeStreamRegister.y is during time
	        animationRegisterData.setRegisterIndex(this, ParticleTimeState_1.ParticleTimeState.TIME_STREAM_INDEX, timeStreamRegister.index);
	        var timeConst = registerCache.getFreeVertexConstant();
	        animationRegisterData.setRegisterIndex(this, ParticleTimeState_1.ParticleTimeState.TIME_CONSTANT_INDEX, timeConst.index);
	        var code = "";
	        code += "sub " + animationRegisterData.vertexTime + "," + timeConst + "," + timeStreamRegister + ".x\n";
	        //if time=0,set the position to zero.
	        var temp = registerCache.getFreeVertexSingleTemp();
	        code += "sge " + temp + "," + animationRegisterData.vertexTime + "," + animationRegisterData.vertexZeroConst + "\n";
	        code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp + "\n";
	        if (this._iUsesDuration) {
	            if (this._iUsesLooping) {
	                var div = registerCache.getFreeVertexSingleTemp();
	                if (this._iUsesDelay) {
	                    code += "div " + div + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".z\n";
	                    code += "frc " + div + "," + div + "\n";
	                    code += "mul " + animationRegisterData.vertexTime + "," + div + "," + timeStreamRegister + ".z\n";
	                    code += "slt " + div + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".y\n";
	                    code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + div + "\n";
	                }
	                else {
	                    code += "mul " + div + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".w\n";
	                    code += "frc " + div + "," + div + "\n";
	                    code += "mul " + animationRegisterData.vertexTime + "," + div + "," + timeStreamRegister + ".y\n";
	                }
	            }
	            else {
	                var sge = registerCache.getFreeVertexSingleTemp();
	                code += "sge " + sge + "," + timeStreamRegister + ".y," + animationRegisterData.vertexTime + "\n";
	                code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + sge + "\n";
	            }
	        }
	        code += "mul " + animationRegisterData.vertexLife + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".w\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleTimeNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleTimeNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        this._pOneData[0] = param.startTime;
	        this._pOneData[1] = param.duration;
	        this._pOneData[2] = param.delay + param.duration;
	        this._pOneData[3] = 1 / param.duration;
	    };
	    return ParticleTimeNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleTimeNode = ParticleTimeNode;


/***/ },
/* 453 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleTimeState = (function (_super) {
	    __extends(ParticleTimeState, _super);
	    function ParticleTimeState(animator, particleTimeNode) {
	        _super.call(this, animator, particleTimeNode, true);
	        this._particleTimeNode = particleTimeNode;
	    }
	    ParticleTimeState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleTimeState.TIME_STREAM_INDEX), this._particleTimeNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	        var particleTime = this._pTime / 1000;
	        shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleTimeState.TIME_CONSTANT_INDEX), particleTime, particleTime, particleTime, particleTime);
	    };
	    /** @private */
	    ParticleTimeState.TIME_STREAM_INDEX = 0;
	    /** @private */
	    ParticleTimeState.TIME_CONSTANT_INDEX = 1;
	    return ParticleTimeState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleTimeState = ParticleTimeState;


/***/ },
/* 454 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 * @author ...
	 */
	var ParticleColorState = (function (_super) {
	    __extends(ParticleColorState, _super);
	    function ParticleColorState(animator, particleColorNode) {
	        _super.call(this, animator, particleColorNode);
	        this._particleColorNode = particleColorNode;
	        this._usesMultiplier = this._particleColorNode._iUsesMultiplier;
	        this._usesOffset = this._particleColorNode._iUsesOffset;
	        this._usesCycle = this._particleColorNode._iUsesCycle;
	        this._usesPhase = this._particleColorNode._iUsesPhase;
	        this._startColor = this._particleColorNode._iStartColor;
	        this._endColor = this._particleColorNode._iEndColor;
	        this._cycleDuration = this._particleColorNode._iCycleDuration;
	        this._cyclePhase = this._particleColorNode._iCyclePhase;
	        this.updateColorData();
	    }
	    Object.defineProperty(ParticleColorState.prototype, "startColor", {
	        /**
	         * Defines the start color transform of the state, when in global mode.
	         */
	        get: function () {
	            return this._startColor;
	        },
	        set: function (value) {
	            this._startColor = value;
	            this.updateColorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleColorState.prototype, "endColor", {
	        /**
	         * Defines the end color transform of the state, when in global mode.
	         */
	        get: function () {
	            return this._endColor;
	        },
	        set: function (value) {
	            this._endColor = value;
	            this.updateColorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleColorState.prototype, "cycleDuration", {
	        /**
	         * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
	         */
	        get: function () {
	            return this._cycleDuration;
	        },
	        set: function (value) {
	            this._cycleDuration = value;
	            this.updateColorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleColorState.prototype, "cyclePhase", {
	        /**
	         * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
	         */
	        get: function () {
	            return this._cyclePhase;
	        },
	        set: function (value) {
	            this._cyclePhase = value;
	            this.updateColorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleColorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (shader.usesFragmentAnimation) {
	            var dataOffset = this._particleColorNode._iDataOffset;
	            var index;
	            if (this._usesCycle)
	                shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.CYCLE_INDEX), this._cycleData.x, this._cycleData.y, this._cycleData.z, this._cycleData.w);
	            if (this._usesMultiplier) {
	                if (this._particleColorNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_MULTIPLIER_INDEX), dataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	                    dataOffset += 4;
	                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_MULTIPLIER_INDEX), dataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	                    dataOffset += 4;
	                }
	                else {
	                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_MULTIPLIER_INDEX), this._startMultiplierData.x, this._startMultiplierData.y, this._startMultiplierData.z, this._startMultiplierData.w);
	                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_MULTIPLIER_INDEX), this._deltaMultiplierData.x, this._deltaMultiplierData.y, this._deltaMultiplierData.z, this._deltaMultiplierData.w);
	                }
	            }
	            if (this._usesOffset) {
	                if (this._particleColorNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_OFFSET_INDEX), dataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	                    dataOffset += 4;
	                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_OFFSET_INDEX), dataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	                }
	                else {
	                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_OFFSET_INDEX), this._startOffsetData.x, this._startOffsetData.y, this._startOffsetData.z, this._startOffsetData.w);
	                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_OFFSET_INDEX), this._deltaOffsetData.x, this._deltaOffsetData.y, this._deltaOffsetData.z, this._deltaOffsetData.w);
	                }
	            }
	        }
	    };
	    ParticleColorState.prototype.updateColorData = function () {
	        if (this._usesCycle) {
	            if (this._cycleDuration <= 0)
	                throw (new Error("the cycle duration must be greater than zero"));
	            this._cycleData = new Vector3D_1.Vector3D(Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180, 0, 0);
	        }
	        if (this._particleColorNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) {
	            if (this._usesCycle) {
	                if (this._usesMultiplier) {
	                    this._startMultiplierData = new Vector3D_1.Vector3D((this._startColor.redMultiplier + this._endColor.redMultiplier) / 2, (this._startColor.greenMultiplier + this._endColor.greenMultiplier) / 2, (this._startColor.blueMultiplier + this._endColor.blueMultiplier) / 2, (this._startColor.alphaMultiplier + this._endColor.alphaMultiplier) / 2);
	                    this._deltaMultiplierData = new Vector3D_1.Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier) / 2, (this._endColor.greenMultiplier - this._startColor.greenMultiplier) / 2, (this._endColor.blueMultiplier - this._startColor.blueMultiplier) / 2, (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier) / 2);
	                }
	                if (this._usesOffset) {
	                    this._startOffsetData = new Vector3D_1.Vector3D((this._startColor.redOffset + this._endColor.redOffset) / (255 * 2), (this._startColor.greenOffset + this._endColor.greenOffset) / (255 * 2), (this._startColor.blueOffset + this._endColor.blueOffset) / (255 * 2), (this._startColor.alphaOffset + this._endColor.alphaOffset) / (255 * 2));
	                    this._deltaOffsetData = new Vector3D_1.Vector3D((this._endColor.redOffset - this._startColor.redOffset) / (255 * 2), (this._endColor.greenOffset - this._startColor.greenOffset) / (255 * 2), (this._endColor.blueOffset - this._startColor.blueOffset) / (255 * 2), (this._endColor.alphaOffset - this._startColor.alphaOffset) / (255 * 2));
	                }
	            }
	            else {
	                if (this._usesMultiplier) {
	                    this._startMultiplierData = new Vector3D_1.Vector3D(this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier);
	                    this._deltaMultiplierData = new Vector3D_1.Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier), (this._endColor.greenMultiplier - this._startColor.greenMultiplier), (this._endColor.blueMultiplier - this._startColor.blueMultiplier), (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier));
	                }
	                if (this._usesOffset) {
	                    this._startOffsetData = new Vector3D_1.Vector3D(this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255);
	                    this._deltaOffsetData = new Vector3D_1.Vector3D((this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255);
	                }
	            }
	        }
	    };
	    /** @private */
	    ParticleColorState.START_MULTIPLIER_INDEX = 0;
	    /** @private */
	    ParticleColorState.DELTA_MULTIPLIER_INDEX = 1;
	    /** @private */
	    ParticleColorState.START_OFFSET_INDEX = 2;
	    /** @private */
	    ParticleColorState.DELTA_OFFSET_INDEX = 3;
	    /** @private */
	    ParticleColorState.CYCLE_INDEX = 4;
	    return ParticleColorState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleColorState = ParticleColorState;


/***/ },
/* 455 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticleAnimationSet_1 = __webpack_require__(451);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleFollowState_1 = __webpack_require__(456);
	/**
	 * A particle animation node used to create a follow behaviour on a particle system.
	 */
	var ParticleFollowNode = (function (_super) {
	    __extends(ParticleFollowNode, _super);
	    /**
	     * Creates a new <code>ParticleFollowNode</code>
	     *
	     * @param    [optional] usesPosition     Defines wehether the individual particle reacts to the position of the target.
	     * @param    [optional] usesRotation     Defines wehether the individual particle reacts to the rotation of the target.
	     * @param    [optional] smooth     Defines wehether the state calculate the interpolated value.
	     */
	    function ParticleFollowNode(usesPosition, usesRotation, smooth) {
	        if (usesPosition === void 0) { usesPosition = true; }
	        if (usesRotation === void 0) { usesRotation = true; }
	        if (smooth === void 0) { smooth = false; }
	        _super.call(this, "ParticleFollow", ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_DYNAMIC, (usesPosition && usesRotation) ? 6 : 3, ParticleAnimationSet_1.ParticleAnimationSet.POST_PRIORITY);
	        this._pStateClass = ParticleFollowState_1.ParticleFollowState;
	        this._iUsesPosition = usesPosition;
	        this._iUsesRotation = usesRotation;
	        this._iSmooth = smooth;
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleFollowNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        //TODO: use Quaternion to implement this function
	        var code = "";
	        if (this._iUsesRotation) {
	            var rotationAttribute = registerCache.getFreeVertexAttribute();
	            animationRegisterData.setRegisterIndex(this, ParticleFollowState_1.ParticleFollowState.FOLLOW_ROTATION_INDEX, rotationAttribute.index);
	            var temp1 = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(temp1, 1);
	            var temp2 = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(temp2, 1);
	            var temp3 = registerCache.getFreeVertexVectorTemp();
	            var temp4;
	            if (animationSet.hasBillboard) {
	                registerCache.addVertexTempUsages(temp3, 1);
	                temp4 = registerCache.getFreeVertexVectorTemp();
	            }
	            registerCache.removeVertexTempUsage(temp1);
	            registerCache.removeVertexTempUsage(temp2);
	            if (animationSet.hasBillboard)
	                registerCache.removeVertexTempUsage(temp3);
	            var len = animationRegisterData.rotationRegisters.length;
	            var i;
	            //x axis
	            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp1 + ".x," + animationRegisterData.vertexOneConst + "\n";
	            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "sin " + temp3 + ".y," + rotationAttribute + ".x\n";
	            code += "cos " + temp3 + ".z," + rotationAttribute + ".x\n";
	            code += "mov " + temp2 + ".x," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp2 + ".y," + temp3 + ".z\n";
	            code += "neg " + temp2 + ".z," + temp3 + ".y\n";
	            if (animationSet.hasBillboard)
	                code += "m33 " + temp4 + ".xyz," + animationRegisterData.positionTarget + ".xyz," + temp1 + "\n";
	            else {
	                code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
	                for (i = 0; i < len; i++)
	                    code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
	            }
	            //y axis
	            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "cos " + temp1 + ".x," + rotationAttribute + ".y\n";
	            code += "sin " + temp1 + ".z," + rotationAttribute + ".y\n";
	            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp2 + ".y," + animationRegisterData.vertexOneConst + "\n";
	            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "neg " + temp3 + ".x," + temp1 + ".z\n";
	            code += "mov " + temp3 + ".z," + temp1 + ".x\n";
	            if (animationSet.hasBillboard)
	                code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
	            else {
	                code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
	                for (i = 0; i < len; i++)
	                    code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
	            }
	            //z axis
	            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "sin " + temp2 + ".x," + rotationAttribute + ".z\n";
	            code += "cos " + temp2 + ".y," + rotationAttribute + ".z\n";
	            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp1 + ".x," + temp2 + ".y\n";
	            code += "neg " + temp1 + ".y," + temp2 + ".x\n";
	            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp3 + ".z," + animationRegisterData.vertexOneConst + "\n";
	            if (animationSet.hasBillboard) {
	                code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
	                code += "sub " + temp4 + ".xyz," + temp4 + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	                code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp4 + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	            }
	            else {
	                code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
	                for (i = 0; i < len; i++)
	                    code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
	            }
	        }
	        if (this._iUsesPosition) {
	            var positionAttribute = registerCache.getFreeVertexAttribute();
	            animationRegisterData.setRegisterIndex(this, ParticleFollowState_1.ParticleFollowState.FOLLOW_POSITION_INDEX, positionAttribute.index);
	            code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + positionAttribute + "," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleFollowNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    return ParticleFollowNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleFollowNode = ParticleFollowNode;


/***/ },
/* 456 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MathConsts_1 = __webpack_require__(35);
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleFollowState = (function (_super) {
	    __extends(ParticleFollowState, _super);
	    function ParticleFollowState(animator, particleFollowNode) {
	        _super.call(this, animator, particleFollowNode, true);
	        this._targetPos = new Vector3D_1.Vector3D();
	        this._targetEuler = new Vector3D_1.Vector3D();
	        //temporary vector3D for calculation
	        this._temp = new Vector3D_1.Vector3D();
	        this._particleFollowNode = particleFollowNode;
	        this._smooth = particleFollowNode._iSmooth;
	    }
	    Object.defineProperty(ParticleFollowState.prototype, "followTarget", {
	        get: function () {
	            return this._followTarget;
	        },
	        set: function (value) {
	            this._followTarget = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleFollowState.prototype, "smooth", {
	        get: function () {
	            return this._smooth;
	        },
	        set: function (value) {
	            this._smooth = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleFollowState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (this._followTarget) {
	            if (this._particleFollowNode._iUsesPosition) {
	                this._targetPos.x = this._followTarget.transform.position.x / renderable.sourceEntity.scaleX;
	                this._targetPos.y = this._followTarget.transform.position.y / renderable.sourceEntity.scaleY;
	                this._targetPos.z = this._followTarget.transform.position.z / renderable.sourceEntity.scaleZ;
	            }
	            if (this._particleFollowNode._iUsesRotation) {
	                this._targetEuler.x = this._followTarget.rotationX;
	                this._targetEuler.y = this._followTarget.rotationY;
	                this._targetEuler.z = this._followTarget.rotationZ;
	                this._targetEuler.scaleBy(MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	            }
	        }
	        //initialization
	        if (!this._prePos)
	            this._prePos = this._targetPos.clone();
	        if (!this._preEuler)
	            this._preEuler = this._targetEuler.clone();
	        var currentTime = this._pTime / 1000;
	        var previousTime = animationElements.previousTime;
	        var deltaTime = currentTime - previousTime;
	        var needProcess = previousTime != currentTime;
	        if (this._particleFollowNode._iUsesPosition && this._particleFollowNode._iUsesRotation) {
	            if (needProcess)
	                this.processPositionAndRotation(currentTime, deltaTime, animationElements);
	            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset + 3, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	        }
	        else if (this._particleFollowNode._iUsesPosition) {
	            if (needProcess)
	                this.processPosition(currentTime, deltaTime, animationElements);
	            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	        }
	        else if (this._particleFollowNode._iUsesRotation) {
	            if (needProcess)
	                this.precessRotation(currentTime, deltaTime, animationElements);
	            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	        }
	        this._prePos.copyFrom(this._targetPos);
	        this._targetEuler.copyFrom(this._targetEuler);
	        animationElements.previousTime = currentTime;
	    };
	    ParticleFollowState.prototype.processPosition = function (currentTime, deltaTime, animationElements) {
	        var data = animationElements.animationParticles;
	        var vertexData = animationElements.vertexData;
	        var changed = false;
	        var len = data.length;
	        var interpolatedPos;
	        var posVelocity;
	        if (this._smooth) {
	            posVelocity = this._prePos.subtract(this._targetPos);
	            posVelocity.scaleBy(1 / deltaTime);
	        }
	        else
	            interpolatedPos = this._targetPos;
	        for (var i = 0; i < len; i++) {
	            var k = (currentTime - data[i].startTime) / data[i].totalTime;
	            var t = (k - Math.floor(k)) * data[i].totalTime;
	            if (t - deltaTime <= 0) {
	                var inc = data[i].startVertexIndex * animationElements.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
	                if (this._smooth) {
	                    this._temp.copyFrom(posVelocity);
	                    this._temp.scaleBy(t);
	                    interpolatedPos = this._targetPos.add(this._temp);
	                }
	                if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z) {
	                    changed = true;
	                    for (var j = 0; j < data[i].numVertices; j++) {
	                        vertexData[inc++] = interpolatedPos.x;
	                        vertexData[inc++] = interpolatedPos.y;
	                        vertexData[inc++] = interpolatedPos.z;
	                    }
	                }
	            }
	        }
	        if (changed)
	            animationElements.invalidateBuffer();
	    };
	    ParticleFollowState.prototype.precessRotation = function (currentTime, deltaTime, animationElements) {
	        var data = animationElements.animationParticles;
	        var vertexData = animationElements.vertexData;
	        var changed = false;
	        var len = data.length;
	        var interpolatedRotation;
	        var rotationVelocity;
	        if (this._smooth) {
	            rotationVelocity = this._preEuler.subtract(this._targetEuler);
	            rotationVelocity.scaleBy(1 / deltaTime);
	        }
	        else
	            interpolatedRotation = this._targetEuler;
	        for (var i = 0; i < len; i++) {
	            var k = (currentTime - data[i].startTime) / data[i].totalTime;
	            var t = (k - Math.floor(k)) * data[i].totalTime;
	            if (t - deltaTime <= 0) {
	                var inc = data[i].startVertexIndex * animationElements.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
	                if (this._smooth) {
	                    this._temp.copyFrom(rotationVelocity);
	                    this._temp.scaleBy(t);
	                    interpolatedRotation = this._targetEuler.add(this._temp);
	                }
	                if (vertexData[inc] != interpolatedRotation.x || vertexData[inc + 1] != interpolatedRotation.y || vertexData[inc + 2] != interpolatedRotation.z) {
	                    changed = true;
	                    for (var j = 0; j < data[i].numVertices; j++) {
	                        vertexData[inc++] = interpolatedRotation.x;
	                        vertexData[inc++] = interpolatedRotation.y;
	                        vertexData[inc++] = interpolatedRotation.z;
	                    }
	                }
	            }
	        }
	        if (changed)
	            animationElements.invalidateBuffer();
	    };
	    ParticleFollowState.prototype.processPositionAndRotation = function (currentTime, deltaTime, animationElements) {
	        var data = animationElements.animationParticles;
	        var vertexData = animationElements.vertexData;
	        var changed = false;
	        var len = data.length;
	        var interpolatedPos;
	        var interpolatedRotation;
	        var posVelocity;
	        var rotationVelocity;
	        if (this._smooth) {
	            posVelocity = this._prePos.subtract(this._targetPos);
	            posVelocity.scaleBy(1 / deltaTime);
	            rotationVelocity = this._preEuler.subtract(this._targetEuler);
	            rotationVelocity.scaleBy(1 / deltaTime);
	        }
	        else {
	            interpolatedPos = this._targetPos;
	            interpolatedRotation = this._targetEuler;
	        }
	        for (var i = 0; i < len; i++) {
	            var k = (currentTime - data[i].startTime) / data[i].totalTime;
	            var t = (k - Math.floor(k)) * data[i].totalTime;
	            if (t - deltaTime <= 0) {
	                var inc = data[i].startVertexIndex * animationElements.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
	                if (this._smooth) {
	                    this._temp.copyFrom(posVelocity);
	                    this._temp.scaleBy(t);
	                    interpolatedPos = this._targetPos.add(this._temp);
	                    this._temp.copyFrom(rotationVelocity);
	                    this._temp.scaleBy(t);
	                    interpolatedRotation = this._targetEuler.add(this._temp);
	                }
	                if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z || vertexData[inc + 3] != interpolatedRotation.x || vertexData[inc + 4] != interpolatedRotation.y || vertexData[inc + 5] != interpolatedRotation.z) {
	                    changed = true;
	                    for (var j = 0; j < data[i].numVertices; j++) {
	                        vertexData[inc++] = interpolatedPos.x;
	                        vertexData[inc++] = interpolatedPos.y;
	                        vertexData[inc++] = interpolatedPos.z;
	                        vertexData[inc++] = interpolatedRotation.x;
	                        vertexData[inc++] = interpolatedRotation.y;
	                        vertexData[inc++] = interpolatedRotation.z;
	                    }
	                }
	            }
	        }
	        if (changed)
	            animationElements.invalidateBuffer();
	    };
	    /** @private */
	    ParticleFollowState.FOLLOW_POSITION_INDEX = 0;
	    /** @private */
	    ParticleFollowState.FOLLOW_ROTATION_INDEX = 1;
	    return ParticleFollowState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleFollowState = ParticleFollowState;


/***/ },
/* 457 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ColorTransform_1 = __webpack_require__(27);
	var ParticleAnimationSet_1 = __webpack_require__(451);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleInitialColorState_1 = __webpack_require__(458);
	/**
	 *
	 */
	var ParticleInitialColorNode = (function (_super) {
	    __extends(ParticleInitialColorNode, _super);
	    function ParticleInitialColorNode(mode, usesMultiplier, usesOffset, initialColor) {
	        if (usesMultiplier === void 0) { usesMultiplier = true; }
	        if (usesOffset === void 0) { usesOffset = false; }
	        if (initialColor === void 0) { initialColor = null; }
	        _super.call(this, "ParticleInitialColor", mode, (usesMultiplier && usesOffset) ? 8 : 4, ParticleAnimationSet_1.ParticleAnimationSet.COLOR_PRIORITY);
	        this._pStateClass = ParticleInitialColorState_1.ParticleInitialColorState;
	        this._iUsesMultiplier = usesMultiplier;
	        this._iUsesOffset = usesOffset;
	        this._iInitialColor = initialColor || new ColorTransform_1.ColorTransform();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleInitialColorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var code = "";
	        if (shader.usesFragmentAnimation) {
	            if (this._iUsesMultiplier) {
	                var multiplierValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	                animationRegisterData.setRegisterIndex(this, ParticleInitialColorState_1.ParticleInitialColorState.MULTIPLIER_INDEX, multiplierValue.index);
	                code += "mul " + animationRegisterData.colorMulTarget + "," + multiplierValue + "," + animationRegisterData.colorMulTarget + "\n";
	            }
	            if (this._iUsesOffset) {
	                var offsetValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) ? registerCache.getFreeVertexAttribute() : registerCache.getFreeVertexConstant();
	                animationRegisterData.setRegisterIndex(this, ParticleInitialColorState_1.ParticleInitialColorState.OFFSET_INDEX, offsetValue.index);
	                code += "add " + animationRegisterData.colorAddTarget + "," + offsetValue + "," + animationRegisterData.colorAddTarget + "\n";
	            }
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleInitialColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	        if (this._iUsesMultiplier)
	            particleAnimationSet.hasColorMulNode = true;
	        if (this._iUsesOffset)
	            particleAnimationSet.hasColorAddNode = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleInitialColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var initialColor = param[ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM];
	        if (!initialColor)
	            throw (new Error("there is no " + ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM + " in param!"));
	        var i = 0;
	        //multiplier
	        if (this._iUsesMultiplier) {
	            this._pOneData[i++] = initialColor.redMultiplier;
	            this._pOneData[i++] = initialColor.greenMultiplier;
	            this._pOneData[i++] = initialColor.blueMultiplier;
	            this._pOneData[i++] = initialColor.alphaMultiplier;
	        }
	        //offset
	        if (this._iUsesOffset) {
	            this._pOneData[i++] = initialColor.redOffset / 255;
	            this._pOneData[i++] = initialColor.greenOffset / 255;
	            this._pOneData[i++] = initialColor.blueOffset / 255;
	            this._pOneData[i++] = initialColor.alphaOffset / 255;
	        }
	    };
	    /**
	     * Reference for color node properties on a single particle (when in local property mode).
	     * Expects a <code>ColorTransform</code> object representing the color transform applied to the particle.
	     */
	    ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM = "ColorInitialColorTransform";
	    return ParticleInitialColorNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleInitialColorNode = ParticleInitialColorNode;


/***/ },
/* 458 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	*
	*/
	var ParticleInitialColorState = (function (_super) {
	    __extends(ParticleInitialColorState, _super);
	    function ParticleInitialColorState(animator, particleInitialColorNode) {
	        _super.call(this, animator, particleInitialColorNode);
	        this._particleInitialColorNode = particleInitialColorNode;
	        this._usesMultiplier = particleInitialColorNode._iUsesMultiplier;
	        this._usesOffset = particleInitialColorNode._iUsesOffset;
	        this._initialColor = particleInitialColorNode._iInitialColor;
	        this.updateColorData();
	    }
	    Object.defineProperty(ParticleInitialColorState.prototype, "initialColor", {
	        /**
	         * Defines the initial color transform of the state, when in global mode.
	         */
	        get: function () {
	            return this._initialColor;
	        },
	        set: function (value) {
	            this._initialColor = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleInitialColorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (shader.usesFragmentAnimation) {
	            var index;
	            if (this._particleInitialColorNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	                var dataOffset = this._particleInitialColorNode._iDataOffset;
	                if (this._usesMultiplier) {
	                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.MULTIPLIER_INDEX), dataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	                    dataOffset += 4;
	                }
	                if (this._usesOffset)
	                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.OFFSET_INDEX), dataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	            }
	            else {
	                if (this._usesMultiplier)
	                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.MULTIPLIER_INDEX), this._multiplierData.x, this._multiplierData.y, this._multiplierData.z, this._multiplierData.w);
	                if (this._usesOffset)
	                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.OFFSET_INDEX), this._offsetData.x, this._offsetData.y, this._offsetData.z, this._offsetData.w);
	            }
	        }
	    };
	    ParticleInitialColorState.prototype.updateColorData = function () {
	        if (this._particleInitialColorNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) {
	            if (this._usesMultiplier)
	                this._multiplierData = new Vector3D_1.Vector3D(this._initialColor.redMultiplier, this._initialColor.greenMultiplier, this._initialColor.blueMultiplier, this._initialColor.alphaMultiplier);
	            if (this._usesOffset)
	                this._offsetData = new Vector3D_1.Vector3D(this._initialColor.redOffset / 255, this._initialColor.greenOffset / 255, this._initialColor.blueOffset / 255, this._initialColor.alphaOffset / 255);
	        }
	    };
	    /** @private */
	    ParticleInitialColorState.MULTIPLIER_INDEX = 0;
	    /** @private */
	    ParticleInitialColorState.OFFSET_INDEX = 1;
	    return ParticleInitialColorState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleInitialColorState = ParticleInitialColorState;


/***/ },
/* 459 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleOrbitState_1 = __webpack_require__(460);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used to control the position of a particle over time around a circular orbit.
	 */
	var ParticleOrbitNode = (function (_super) {
	    __extends(ParticleOrbitNode, _super);
	    /**
	     * Creates a new <code>ParticleOrbitNode</code> object.
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] usesEulers      Defines whether the node uses the <code>eulers</code> property in the shader to calculate a rotation on the orbit. Defaults to true.
	     * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the orbit independent of particle duration. Defaults to false.
	     * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
	     * @param    [optional] radius          Defines the radius of the orbit when in global mode. Defaults to 100.
	     * @param    [optional] cycleDuration   Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
	     * @param    [optional] cyclePhase      Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
	     * @param    [optional] eulers          Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
	     */
	    function ParticleOrbitNode(mode, usesEulers, usesCycle, usesPhase, radius, cycleDuration, cyclePhase, eulers) {
	        if (usesEulers === void 0) { usesEulers = true; }
	        if (usesCycle === void 0) { usesCycle = false; }
	        if (usesPhase === void 0) { usesPhase = false; }
	        if (radius === void 0) { radius = 100; }
	        if (cycleDuration === void 0) { cycleDuration = 1; }
	        if (cyclePhase === void 0) { cyclePhase = 0; }
	        if (eulers === void 0) { eulers = null; }
	        var len = 3;
	        if (usesPhase)
	            len++;
	        _super.call(this, "ParticleOrbit", mode, len);
	        this._pStateClass = ParticleOrbitState_1.ParticleOrbitState;
	        this._iUsesEulers = usesEulers;
	        this._iUsesCycle = usesCycle;
	        this._iUsesPhase = usesPhase;
	        this._iRadius = radius;
	        this._iCycleDuration = cycleDuration;
	        this._iCyclePhase = cyclePhase;
	        this._iEulers = eulers || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleOrbitNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var orbitRegister = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleOrbitState_1.ParticleOrbitState.ORBIT_INDEX, orbitRegister.index);
	        var eulersMatrixRegister = registerCache.getFreeVertexConstant();
	        animationRegisterData.setRegisterIndex(this, ParticleOrbitState_1.ParticleOrbitState.EULERS_INDEX, eulersMatrixRegister.index);
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        registerCache.getFreeVertexConstant();
	        var temp1 = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(temp1, 1);
	        var distance = new ShaderRegisterElement_1.ShaderRegisterElement(temp1.regName, temp1.index);
	        var temp2 = registerCache.getFreeVertexVectorTemp();
	        var cos = new ShaderRegisterElement_1.ShaderRegisterElement(temp2.regName, temp2.index, 0);
	        var sin = new ShaderRegisterElement_1.ShaderRegisterElement(temp2.regName, temp2.index, 1);
	        var degree = new ShaderRegisterElement_1.ShaderRegisterElement(temp2.regName, temp2.index, 2);
	        registerCache.removeVertexTempUsage(temp1);
	        var code = "";
	        if (this._iUsesCycle) {
	            code += "mul " + degree + "," + animationRegisterData.vertexTime + "," + orbitRegister + ".y\n";
	            if (this._iUsesPhase)
	                code += "add " + degree + "," + degree + "," + orbitRegister + ".w\n";
	        }
	        else
	            code += "mul " + degree + "," + animationRegisterData.vertexLife + "," + orbitRegister + ".y\n";
	        code += "cos " + cos + "," + degree + "\n";
	        code += "sin " + sin + "," + degree + "\n";
	        code += "mul " + distance + ".x," + cos + "," + orbitRegister + ".x\n";
	        code += "mul " + distance + ".y," + sin + "," + orbitRegister + ".x\n";
	        code += "mov " + distance + ".wz" + animationRegisterData.vertexZeroConst + "\n";
	        if (this._iUsesEulers)
	            code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
	        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	        if (animationSet.needVelocity) {
	            code += "neg " + distance + ".x," + sin + "\n";
	            code += "mov " + distance + ".y," + cos + "\n";
	            code += "mov " + distance + ".zw," + animationRegisterData.vertexZeroConst + "\n";
	            if (this._iUsesEulers)
	                code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
	            code += "mul " + distance + "," + distance + "," + orbitRegister + ".z\n";
	            code += "div " + distance + "," + distance + "," + orbitRegister + ".y\n";
	            if (!this._iUsesCycle)
	                code += "div " + distance + "," + distance + "," + animationRegisterData.vertexLife + "\n";
	            code += "add " + animationRegisterData.velocityTarget + ".xyz," + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleOrbitNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleOrbitNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        //Vector3D.x is radius, Vector3D.y is cycle duration, Vector3D.z is phase
	        var orbit = param[ParticleOrbitNode.ORBIT_VECTOR3D];
	        if (!orbit)
	            throw new Error("there is no " + ParticleOrbitNode.ORBIT_VECTOR3D + " in param!");
	        this._pOneData[0] = orbit.x;
	        if (this._iUsesCycle && orbit.y <= 0)
	            throw (new Error("the cycle duration must be greater than zero"));
	        this._pOneData[1] = Math.PI * 2 / (!this._iUsesCycle ? 1 : orbit.y);
	        this._pOneData[2] = orbit.x * Math.PI * 2;
	        if (this._iUsesPhase)
	            this._pOneData[3] = orbit.z * Math.PI / 180;
	    };
	    /**
	     * Reference for orbit node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the radius (x), cycle speed (y) and cycle phase (z) of the motion on the particle.
	     */
	    ParticleOrbitNode.ORBIT_VECTOR3D = "OrbitVector3D";
	    return ParticleOrbitNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleOrbitNode = ParticleOrbitNode;


/***/ },
/* 460 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleOrbitState = (function (_super) {
	    __extends(ParticleOrbitState, _super);
	    function ParticleOrbitState(animator, particleOrbitNode) {
	        _super.call(this, animator, particleOrbitNode);
	        this._particleOrbitNode = particleOrbitNode;
	        this._usesEulers = this._particleOrbitNode._iUsesEulers;
	        this._usesCycle = this._particleOrbitNode._iUsesCycle;
	        this._usesPhase = this._particleOrbitNode._iUsesPhase;
	        this._eulers = this._particleOrbitNode._iEulers;
	        this._radius = this._particleOrbitNode._iRadius;
	        this._cycleDuration = this._particleOrbitNode._iCycleDuration;
	        this._cyclePhase = this._particleOrbitNode._iCyclePhase;
	        this.updateOrbitData();
	    }
	    Object.defineProperty(ParticleOrbitState.prototype, "radius", {
	        /**
	         * Defines the radius of the orbit when in global mode. Defaults to 100.
	         */
	        get: function () {
	            return this._radius;
	        },
	        set: function (value) {
	            this._radius = value;
	            this.updateOrbitData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleOrbitState.prototype, "cycleDuration", {
	        /**
	         * Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
	         */
	        get: function () {
	            return this._cycleDuration;
	        },
	        set: function (value) {
	            this._cycleDuration = value;
	            this.updateOrbitData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleOrbitState.prototype, "cyclePhase", {
	        /**
	         * Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
	         */
	        get: function () {
	            return this._cyclePhase;
	        },
	        set: function (value) {
	            this._cyclePhase = value;
	            this.updateOrbitData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleOrbitState.prototype, "eulers", {
	        /**
	         * Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
	         */
	        get: function () {
	            return this._eulers;
	        },
	        set: function (value) {
	            this._eulers = value;
	            this.updateOrbitData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleOrbitState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleOrbitState.ORBIT_INDEX);
	        if (this._particleOrbitNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	            if (this._usesPhase)
	                animationElements.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	            else
	                animationElements.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	        }
	        else
	            shader.setVertexConst(index, this._orbitData.x, this._orbitData.y, this._orbitData.z, this._orbitData.w);
	        if (this._usesEulers)
	            shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleOrbitState.EULERS_INDEX), this._eulersMatrix);
	    };
	    ParticleOrbitState.prototype.updateOrbitData = function () {
	        if (this._usesEulers) {
	            this._eulersMatrix = new Matrix3D_1.Matrix3D();
	            this._eulersMatrix.appendRotation(this._eulers.x, Vector3D_1.Vector3D.X_AXIS);
	            this._eulersMatrix.appendRotation(this._eulers.y, Vector3D_1.Vector3D.Y_AXIS);
	            this._eulersMatrix.appendRotation(this._eulers.z, Vector3D_1.Vector3D.Z_AXIS);
	        }
	        if (this._particleOrbitNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) {
	            this._orbitData = new Vector3D_1.Vector3D(this._radius, 0, this._radius * Math.PI * 2, this._cyclePhase * Math.PI / 180);
	            if (this._usesCycle) {
	                if (this._cycleDuration <= 0)
	                    throw (new Error("the cycle duration must be greater than zero"));
	                this._orbitData.y = Math.PI * 2 / this._cycleDuration;
	            }
	            else
	                this._orbitData.y = Math.PI * 2;
	        }
	    };
	    /** @private */
	    ParticleOrbitState.ORBIT_INDEX = 0;
	    /** @private */
	    ParticleOrbitState.EULERS_INDEX = 1;
	    return ParticleOrbitState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleOrbitState = ParticleOrbitState;


/***/ },
/* 461 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleOscillatorState_1 = __webpack_require__(462);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used to control the position of a particle over time using simple harmonic motion.
	 */
	var ParticleOscillatorNode = (function (_super) {
	    __extends(ParticleOscillatorNode, _super);
	    /**
	     * Creates a new <code>ParticleOscillatorNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] oscillator      Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the node, used when in global mode.
	     */
	    function ParticleOscillatorNode(mode, oscillator) {
	        if (oscillator === void 0) { oscillator = null; }
	        _super.call(this, "ParticleOscillator", mode, 4);
	        this._pStateClass = ParticleOscillatorState_1.ParticleOscillatorState;
	        this._iOscillator = oscillator || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleOscillatorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var oscillatorRegister = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleOscillatorState_1.ParticleOscillatorState.OSCILLATOR_INDEX, oscillatorRegister.index);
	        var temp = registerCache.getFreeVertexVectorTemp();
	        var dgree = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 0);
	        var sin = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 1);
	        var cos = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 2);
	        registerCache.addVertexTempUsages(temp, 1);
	        var temp2 = registerCache.getFreeVertexVectorTemp();
	        var distance = new ShaderRegisterElement_1.ShaderRegisterElement(temp2.regName, temp2.index);
	        registerCache.removeVertexTempUsage(temp);
	        var code = "";
	        code += "mul " + dgree + "," + animationRegisterData.vertexTime + "," + oscillatorRegister + ".w\n";
	        code += "sin " + sin + "," + dgree + "\n";
	        code += "mul " + distance + ".xyz," + sin + "," + oscillatorRegister + ".xyz\n";
	        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	        if (animationSet.needVelocity) {
	            code += "cos " + cos + "," + dgree + "\n";
	            code += "mul " + distance + ".xyz," + cos + "," + oscillatorRegister + ".xyz\n";
	            code += "add " + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleOscillatorNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleOscillatorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        //(Vector3D.x,Vector3D.y,Vector3D.z) is oscillator axis, Vector3D.w is oscillator cycle duration
	        var drift = param[ParticleOscillatorNode.OSCILLATOR_VECTOR3D];
	        if (!drift)
	            throw (new Error("there is no " + ParticleOscillatorNode.OSCILLATOR_VECTOR3D + " in param!"));
	        this._pOneData[0] = drift.x;
	        this._pOneData[1] = drift.y;
	        this._pOneData[2] = drift.z;
	        if (drift.w <= 0)
	            throw (new Error("the cycle duration must greater than zero"));
	        this._pOneData[3] = Math.PI * 2 / drift.w;
	    };
	    /**
	     * Reference for ocsillator node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the axis (x,y,z) and cycle speed (w) of the motion on the particle.
	     */
	    ParticleOscillatorNode.OSCILLATOR_VECTOR3D = "OscillatorVector3D";
	    return ParticleOscillatorNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleOscillatorNode = ParticleOscillatorNode;


/***/ },
/* 462 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleOscillatorState = (function (_super) {
	    __extends(ParticleOscillatorState, _super);
	    function ParticleOscillatorState(animator, particleOscillatorNode) {
	        _super.call(this, animator, particleOscillatorNode);
	        this._particleOscillatorNode = particleOscillatorNode;
	        this._oscillator = this._particleOscillatorNode._iOscillator;
	        this.updateOscillatorData();
	    }
	    Object.defineProperty(ParticleOscillatorState.prototype, "oscillator", {
	        /**
	         * Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the state, used when in global mode.
	         */
	        get: function () {
	            return this._oscillator;
	        },
	        set: function (value) {
	            this._oscillator = value;
	            this.updateOscillatorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleOscillatorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleOscillatorState.OSCILLATOR_INDEX);
	        if (this._particleOscillatorNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC)
	            animationElements.activateVertexBuffer(index, this._particleOscillatorNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	        else
	            shader.setVertexConst(index, this._oscillatorData.x, this._oscillatorData.y, this._oscillatorData.z, this._oscillatorData.w);
	    };
	    ParticleOscillatorState.prototype.updateOscillatorData = function () {
	        if (this._particleOscillatorNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) {
	            if (this._oscillator.w <= 0)
	                throw (new Error("the cycle duration must greater than zero"));
	            if (this._oscillatorData == null)
	                this._oscillatorData = new Vector3D_1.Vector3D();
	            this._oscillatorData.x = this._oscillator.x;
	            this._oscillatorData.y = this._oscillator.y;
	            this._oscillatorData.z = this._oscillator.z;
	            this._oscillatorData.w = Math.PI * 2 / this._oscillator.w;
	        }
	    };
	    /** @private */
	    ParticleOscillatorState.OSCILLATOR_INDEX = 0;
	    return ParticleOscillatorState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleOscillatorState = ParticleOscillatorState;


/***/ },
/* 463 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticlePositionState_1 = __webpack_require__(464);
	/**
	 * A particle animation node used to set the starting position of a particle.
	 */
	var ParticlePositionNode = (function (_super) {
	    __extends(ParticlePositionNode, _super);
	    /**
	     * Creates a new <code>ParticlePositionNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] position        Defines the default position of the particle when in global mode. Defaults to 0,0,0.
	     */
	    function ParticlePositionNode(mode, position) {
	        if (position === void 0) { position = null; }
	        _super.call(this, "ParticlePosition", mode, 3);
	        this._pStateClass = ParticlePositionState_1.ParticlePositionState;
	        this._iPosition = position || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticlePositionNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var positionAttribute = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticlePositionState_1.ParticlePositionState.POSITION_INDEX, positionAttribute.index);
	        return "add " + animationRegisterData.positionTarget + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticlePositionNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticlePositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var offset = param[ParticlePositionNode.POSITION_VECTOR3D];
	        if (!offset)
	            throw (new Error("there is no " + ParticlePositionNode.POSITION_VECTOR3D + " in param!"));
	        this._pOneData[0] = offset.x;
	        this._pOneData[1] = offset.y;
	        this._pOneData[2] = offset.z;
	    };
	    /**
	     * Reference for position node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing position of the particle.
	     */
	    ParticlePositionNode.POSITION_VECTOR3D = "PositionVector3D";
	    return ParticlePositionNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticlePositionNode = ParticlePositionNode;


/***/ },
/* 464 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 * @author ...
	 */
	var ParticlePositionState = (function (_super) {
	    __extends(ParticlePositionState, _super);
	    function ParticlePositionState(animator, particlePositionNode) {
	        _super.call(this, animator, particlePositionNode);
	        this._particlePositionNode = particlePositionNode;
	        this._position = this._particlePositionNode._iPosition;
	    }
	    Object.defineProperty(ParticlePositionState.prototype, "position", {
	        /**
	         * Defines the position of the particle when in global mode. Defaults to 0,0,0.
	         */
	        get: function () {
	            return this._position;
	        },
	        set: function (value) {
	            this._position = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    ParticlePositionState.prototype.getPositions = function () {
	        return this._pDynamicProperties;
	    };
	    ParticlePositionState.prototype.setPositions = function (value) {
	        this._pDynamicProperties = value;
	        this._pDynamicPropertiesDirty = new Object();
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticlePositionState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (this._particlePositionNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationElements._iUniqueId])
	            this._pUpdateDynamicProperties(animationElements);
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticlePositionState.POSITION_INDEX);
	        if (this._particlePositionNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL)
	            shader.setVertexConst(index, this._position.x, this._position.y, this._position.z);
	        else
	            animationElements.activateVertexBuffer(index, this._particlePositionNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	    };
	    /** @private */
	    ParticlePositionState.POSITION_INDEX = 0;
	    return ParticlePositionState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticlePositionState = ParticlePositionState;


/***/ },
/* 465 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleRotateToHeadingState_1 = __webpack_require__(466);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used to control the rotation of a particle to match its heading vector.
	 */
	var ParticleRotateToHeadingNode = (function (_super) {
	    __extends(ParticleRotateToHeadingNode, _super);
	    /**
	     * Creates a new <code>ParticleBillboardNode</code>
	     */
	    function ParticleRotateToHeadingNode() {
	        _super.call(this, "ParticleRotateToHeading", ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL, 0, 3);
	        this._pStateClass = ParticleRotateToHeadingState_1.ParticleRotateToHeadingState;
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleRotateToHeadingNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var code = "";
	        var len = animationRegisterData.rotationRegisters.length;
	        var i;
	        if (animationSet.hasBillboard) {
	            var temp1 = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(temp1, 1);
	            var temp2 = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(temp2, 1);
	            var temp3 = registerCache.getFreeVertexVectorTemp();
	            var rotationMatrixRegister = registerCache.getFreeVertexConstant();
	            animationRegisterData.setRegisterIndex(this, ParticleRotateToHeadingState_1.ParticleRotateToHeadingState.MATRIX_INDEX, rotationMatrixRegister.index);
	            registerCache.getFreeVertexConstant();
	            registerCache.getFreeVertexConstant();
	            registerCache.getFreeVertexConstant();
	            registerCache.removeVertexTempUsage(temp1);
	            registerCache.removeVertexTempUsage(temp2);
	            //process the velocity
	            code += "m33 " + temp1 + ".xyz," + animationRegisterData.velocityTarget + ".xyz," + rotationMatrixRegister + "\n";
	            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
	            code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";
	            //temp3.x=cos,temp3.y=sin
	            //only process z axis
	            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp2 + ".x," + temp3 + ".y\n";
	            code += "mov " + temp2 + ".y," + temp3 + ".x\n";
	            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp1 + ".x," + temp3 + ".x\n";
	            code += "neg " + temp1 + ".y," + temp3 + ".y\n";
	            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp3 + ".z," + animationRegisterData.vertexOneConst + "\n";
	            code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
	            for (i = 0; i < len; i++)
	                code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
	        }
	        else {
	            var nrmVel = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(nrmVel, 1);
	            var xAxis = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(xAxis, 1);
	            var R = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(R, 1);
	            var R_rev = registerCache.getFreeVertexVectorTemp();
	            var cos = new ShaderRegisterElement_1.ShaderRegisterElement(R.regName, R.index, 3);
	            var sin = new ShaderRegisterElement_1.ShaderRegisterElement(R_rev.regName, R_rev.index, 3);
	            var cos2 = new ShaderRegisterElement_1.ShaderRegisterElement(nrmVel.regName, nrmVel.index, 3);
	            var tempSingle = sin;
	            registerCache.removeVertexTempUsage(nrmVel);
	            registerCache.removeVertexTempUsage(xAxis);
	            registerCache.removeVertexTempUsage(R);
	            code += "mov " + xAxis + ".x," + animationRegisterData.vertexOneConst + "\n";
	            code += "mov " + xAxis + ".yz," + animationRegisterData.vertexZeroConst + "\n";
	            code += "nrm " + nrmVel + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
	            code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
	            code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
	            code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";
	            //use R as temp to judge if nrm is (0,0,0).
	            //if nrm is (0,0,0) ,change it to (0,0,1).
	            code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
	            code += "sge " + R + ".x," + animationRegisterData.vertexZeroConst + "," + R + ".x\n";
	            code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";
	            code += "add " + tempSingle + "," + cos2 + "," + animationRegisterData.vertexOneConst + "\n";
	            code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
	            code += "sqt " + cos + "," + tempSingle + "\n";
	            code += "sub " + tempSingle + "," + animationRegisterData.vertexOneConst + "," + cos2 + "\n";
	            code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
	            code += "sqt " + sin + "," + tempSingle + "\n";
	            code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	            //use cos as R.w
	            code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	            code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
	            //use cos as R_rev.w
	            //nrmVel and xAxis are used as temp register
	            code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	            //use cos as R.w
	            code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	            code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
	            code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	            code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
	            code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
	            //code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," +R_rev + ".w\n";
	            code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
	            code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
	            code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
	            code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
	            for (i = 0; i < len; i++) {
	                //just repeat the calculate above
	                //because of the limited registers, no need to optimise
	                code += "mov " + xAxis + ".x," + animationRegisterData.vertexOneConst + "\n";
	                code += "mov " + xAxis + ".yz," + animationRegisterData.vertexZeroConst + "\n";
	                code += "nrm " + nrmVel + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
	                code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
	                code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
	                code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";
	                code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
	                code += "sge " + R + ".x," + animationRegisterData.vertexZeroConst + "," + R + ".x\n";
	                code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";
	                code += "add " + tempSingle + "," + cos2 + "," + animationRegisterData.vertexOneConst + "\n";
	                code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
	                code += "sqt " + cos + "," + tempSingle + "\n";
	                code += "sub " + tempSingle + "," + animationRegisterData.vertexOneConst + "," + cos2 + "\n";
	                code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
	                code += "sqt " + sin + "," + tempSingle + "\n";
	                code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	                code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	                code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
	                code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
	                code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
	                code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
	                code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
	                code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
	                code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
	                code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
	                code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
	                code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
	                code += "add " + animationRegisterData.rotationRegisters[i] + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
	            }
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleRotateToHeadingNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleRotateToHeadingNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	        particleAnimationSet.needVelocity = true;
	    };
	    return ParticleRotateToHeadingNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleRotateToHeadingNode = ParticleRotateToHeadingNode;


/***/ },
/* 466 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleRotateToHeadingState = (function (_super) {
	    __extends(ParticleRotateToHeadingState, _super);
	    function ParticleRotateToHeadingState(animator, particleNode) {
	        _super.call(this, animator, particleNode);
	        this._matrix = new Matrix3D_1.Matrix3D();
	    }
	    ParticleRotateToHeadingState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (this._pParticleAnimator.animationSet.hasBillboard) {
	            this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
	            this._matrix.append(camera.inverseSceneTransform);
	            shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotateToHeadingState.MATRIX_INDEX), this._matrix);
	        }
	    };
	    /** @private */
	    ParticleRotateToHeadingState.MATRIX_INDEX = 0;
	    return ParticleRotateToHeadingState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleRotateToHeadingState = ParticleRotateToHeadingState;


/***/ },
/* 467 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleRotateToPositionState_1 = __webpack_require__(468);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used to control the rotation of a particle to face to a position
	 */
	var ParticleRotateToPositionNode = (function (_super) {
	    __extends(ParticleRotateToPositionNode, _super);
	    /**
	     * Creates a new <code>ParticleRotateToPositionNode</code>
	     */
	    function ParticleRotateToPositionNode(mode, position) {
	        if (position === void 0) { position = null; }
	        _super.call(this, "ParticleRotateToPosition", mode, 3, 3);
	        this._pStateClass = ParticleRotateToPositionState_1.ParticleRotateToPositionState;
	        this._iPosition = position || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleRotateToPositionNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var positionAttribute = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleRotateToPositionState_1.ParticleRotateToPositionState.POSITION_INDEX, positionAttribute.index);
	        var code = "";
	        var len = animationRegisterData.rotationRegisters.length;
	        var i;
	        if (animationSet.hasBillboard) {
	            var temp1 = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(temp1, 1);
	            var temp2 = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(temp2, 1);
	            var temp3 = registerCache.getFreeVertexVectorTemp();
	            var rotationMatrixRegister = registerCache.getFreeVertexConstant();
	            animationRegisterData.setRegisterIndex(this, ParticleRotateToPositionState_1.ParticleRotateToPositionState.MATRIX_INDEX, rotationMatrixRegister.index);
	            registerCache.getFreeVertexConstant();
	            registerCache.getFreeVertexConstant();
	            registerCache.getFreeVertexConstant();
	            registerCache.removeVertexTempUsage(temp1);
	            registerCache.removeVertexTempUsage(temp2);
	            //process the position
	            code += "sub " + temp1 + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	            code += "m33 " + temp1 + ".xyz," + temp1 + ".xyz," + rotationMatrixRegister + "\n";
	            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
	            code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";
	            //temp3.x=cos,temp3.y=sin
	            //only process z axis
	            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp2 + ".x," + temp3 + ".y\n";
	            code += "mov " + temp2 + ".y," + temp3 + ".x\n";
	            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp1 + ".x," + temp3 + ".x\n";
	            code += "neg " + temp1 + ".y," + temp3 + ".y\n";
	            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mov " + temp3 + ".z," + animationRegisterData.vertexOneConst + "\n";
	            code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
	            for (i = 0; i < len; i++)
	                code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
	        }
	        else {
	            var nrmDirection = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(nrmDirection, 1);
	            var temp = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(temp, 1);
	            var cos = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 0);
	            var sin = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 1);
	            var o_temp = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 2);
	            var tempSingle = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 3);
	            var R = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(R, 1);
	            registerCache.removeVertexTempUsage(nrmDirection);
	            registerCache.removeVertexTempUsage(temp);
	            registerCache.removeVertexTempUsage(R);
	            code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	            code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
	            code += "mov " + sin + "," + nrmDirection + ".y\n";
	            code += "mul " + cos + "," + sin + "," + sin + "\n";
	            code += "sub " + cos + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
	            code += "sqt " + cos + "," + cos + "\n";
	            code += "mul " + R + ".x," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".y\n";
	            code += "mul " + R + ".y," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
	            code += "mul " + R + ".z," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".y\n";
	            code += "mul " + R + ".w," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
	            code += "sub " + animationRegisterData.scaleAndRotateTarget + ".y," + R + ".x," + R + ".y\n";
	            code += "add " + animationRegisterData.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";
	            code += "abs " + R + ".y," + nrmDirection + ".y\n";
	            code += "sge " + R + ".z," + R + ".y," + animationRegisterData.vertexOneConst + "\n";
	            code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";
	            //judgu if nrmDirection=(0,1,0);
	            code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
	            code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
	            code += "sge " + tempSingle + "," + animationRegisterData.vertexZeroConst + "," + sin + "\n";
	            code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
	            code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
	            code += "sub " + sin + "," + animationRegisterData.vertexOneConst + "," + tempSingle + "\n";
	            code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";
	            code += "mov " + cos + "," + nrmDirection + ".z\n";
	            code += "neg " + cos + "," + cos + "\n";
	            code += "sub " + o_temp + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
	            code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
	            code += "add " + cos + "," + cos + "," + o_temp + "\n";
	            code += "mul " + R + ".x," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".x\n";
	            code += "mul " + R + ".y," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
	            code += "mul " + R + ".z," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".x\n";
	            code += "mul " + R + ".w," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
	            code += "sub " + animationRegisterData.scaleAndRotateTarget + ".x," + R + ".x," + R + ".y\n";
	            code += "add " + animationRegisterData.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";
	            for (i = 0; i < len; i++) {
	                //just repeat the calculate above
	                //because of the limited registers, no need to optimise
	                code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
	                code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
	                code += "mov " + sin + "," + nrmDirection + ".y\n";
	                code += "mul " + cos + "," + sin + "," + sin + "\n";
	                code += "sub " + cos + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
	                code += "sqt " + cos + "," + cos + "\n";
	                code += "mul " + R + ".x," + cos + "," + animationRegisterData.rotationRegisters[i] + ".y\n";
	                code += "mul " + R + ".y," + sin + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
	                code += "mul " + R + ".z," + sin + "," + animationRegisterData.rotationRegisters[i] + ".y\n";
	                code += "mul " + R + ".w," + cos + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
	                code += "sub " + animationRegisterData.rotationRegisters[i] + ".y," + R + ".x," + R + ".y\n";
	                code += "add " + animationRegisterData.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
	                code += "abs " + R + ".y," + nrmDirection + ".y\n";
	                code += "sge " + R + ".z," + R + ".y," + animationRegisterData.vertexOneConst + "\n";
	                code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";
	                code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
	                code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
	                code += "sge " + tempSingle + "," + animationRegisterData.vertexZeroConst + "," + sin + "\n";
	                code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
	                code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
	                code += "sub " + sin + "," + animationRegisterData.vertexOneConst + "," + tempSingle + "\n";
	                code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";
	                code += "mov " + cos + "," + nrmDirection + ".z\n";
	                code += "neg " + cos + "," + cos + "\n";
	                code += "sub " + o_temp + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
	                code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
	                code += "add " + cos + "," + cos + "," + o_temp + "\n";
	                code += "mul " + R + ".x," + cos + "," + animationRegisterData.rotationRegisters[i] + ".x\n";
	                code += "mul " + R + ".y," + sin + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
	                code += "mul " + R + ".z," + sin + "," + animationRegisterData.rotationRegisters[i] + ".x\n";
	                code += "mul " + R + ".w," + cos + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
	                code += "sub " + animationRegisterData.rotationRegisters[i] + ".x," + R + ".x," + R + ".y\n";
	                code += "add " + animationRegisterData.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
	            }
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleRotateToPositionNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleRotateToPositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var offset = param[ParticleRotateToPositionNode.POSITION_VECTOR3D];
	        if (!offset)
	            throw (new Error("there is no " + ParticleRotateToPositionNode.POSITION_VECTOR3D + " in param!"));
	        this._pOneData[0] = offset.x;
	        this._pOneData[1] = offset.y;
	        this._pOneData[2] = offset.z;
	    };
	    /**
	     * Reference for the position the particle will rotate to face for a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the position that the particle must face.
	     */
	    ParticleRotateToPositionNode.POSITION_VECTOR3D = "RotateToPositionVector3D";
	    return ParticleRotateToPositionNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleRotateToPositionNode = ParticleRotateToPositionNode;


/***/ },
/* 468 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleRotateToPositionState = (function (_super) {
	    __extends(ParticleRotateToPositionState, _super);
	    function ParticleRotateToPositionState(animator, particleRotateToPositionNode) {
	        _super.call(this, animator, particleRotateToPositionNode);
	        this._matrix = new Matrix3D_1.Matrix3D();
	        this._particleRotateToPositionNode = particleRotateToPositionNode;
	        this._position = this._particleRotateToPositionNode._iPosition;
	    }
	    Object.defineProperty(ParticleRotateToPositionState.prototype, "position", {
	        /**
	         * Defines the position of the point the particle will rotate to face when in global mode. Defaults to 0,0,0.
	         */
	        get: function () {
	            return this._position;
	        },
	        set: function (value) {
	            this._position = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleRotateToPositionState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotateToPositionState.POSITION_INDEX);
	        if (this._pParticleAnimator.animationSet.hasBillboard) {
	            this._matrix.copyFrom(renderable.sourceEntity.sceneTransform);
	            this._matrix.append(camera.inverseSceneTransform);
	            shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotateToPositionState.MATRIX_INDEX), this._matrix);
	        }
	        if (this._particleRotateToPositionNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) {
	            this._offset = renderable.sourceEntity.inverseSceneTransform.transformVector(this._position);
	            shader.setVertexConst(index, this._offset.x, this._offset.y, this._offset.z);
	        }
	        else
	            animationElements.activateVertexBuffer(index, this._particleRotateToPositionNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	    };
	    /** @private */
	    ParticleRotateToPositionState.MATRIX_INDEX = 0;
	    /** @private */
	    ParticleRotateToPositionState.POSITION_INDEX = 1;
	    return ParticleRotateToPositionState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleRotateToPositionState = ParticleRotateToPositionState;


/***/ },
/* 469 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleRotationalVelocityState_1 = __webpack_require__(470);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used to set the starting rotational velocity of a particle.
	 */
	var ParticleRotationalVelocityNode = (function (_super) {
	    __extends(ParticleRotationalVelocityNode, _super);
	    /**
	     * Creates a new <code>ParticleRotationalVelocityNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     */
	    function ParticleRotationalVelocityNode(mode, rotationalVelocity) {
	        if (rotationalVelocity === void 0) { rotationalVelocity = null; }
	        _super.call(this, "ParticleRotationalVelocity", mode, 4);
	        this._pStateClass = ParticleRotationalVelocityState_1.ParticleRotationalVelocityState;
	        this._iRotationalVelocity = rotationalVelocity || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleRotationalVelocityNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var rotationRegister = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleRotationalVelocityState_1.ParticleRotationalVelocityState.ROTATIONALVELOCITY_INDEX, rotationRegister.index);
	        var nrmVel = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(nrmVel, 1);
	        var xAxis = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(xAxis, 1);
	        var temp = registerCache.getFreeVertexVectorTemp();
	        registerCache.addVertexTempUsages(temp, 1);
	        var Rtemp = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index);
	        var R_rev = registerCache.getFreeVertexVectorTemp();
	        R_rev = new ShaderRegisterElement_1.ShaderRegisterElement(R_rev.regName, R_rev.index);
	        var cos = new ShaderRegisterElement_1.ShaderRegisterElement(Rtemp.regName, Rtemp.index, 3);
	        var sin = new ShaderRegisterElement_1.ShaderRegisterElement(R_rev.regName, R_rev.index, 3);
	        registerCache.removeVertexTempUsage(nrmVel);
	        registerCache.removeVertexTempUsage(xAxis);
	        registerCache.removeVertexTempUsage(temp);
	        var code = "";
	        code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
	        code += "mov " + nrmVel + ".w," + animationRegisterData.vertexZeroConst + "\n";
	        code += "mul " + cos + "," + animationRegisterData.vertexTime + "," + rotationRegister + ".w\n";
	        code += "sin " + sin + "," + cos + "\n";
	        code += "cos " + cos + "," + cos + "\n";
	        code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	        code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	        code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
	        //nrmVel and xAxis are used as temp register
	        code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	        code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	        code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
	        code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
	        code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
	        code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
	        //use cos as R_rev.w
	        code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
	        code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
	        code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
	        code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
	        var len = animationRegisterData.rotationRegisters.length;
	        for (var i = 0; i < len; i++) {
	            code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
	            code += "mov " + nrmVel + ".w," + animationRegisterData.vertexZeroConst + "\n";
	            code += "mul " + cos + "," + animationRegisterData.vertexTime + "," + rotationRegister + ".w\n";
	            code += "sin " + sin + "," + cos + "\n";
	            code += "cos " + cos + "," + cos + "\n";
	            code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	            code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
	            code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
	            code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
	            code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.rotationRegisters[i] + "\n";
	            code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
	            code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterData.rotationRegisters[i] + "\n";
	            code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
	            code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
	            code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
	            code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
	            code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
	            code += "add " + animationRegisterData.rotationRegisters[i] + "," + Rtemp + ".xyz," + xAxis + ".xyz\n";
	        }
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleRotationalVelocityNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleRotationalVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        //(Vector3d.x,Vector3d.y,Vector3d.z) is rotation axis,Vector3d.w is cycle duration
	        var rotate = param[ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D];
	        if (!rotate)
	            throw (new Error("there is no " + ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D + " in param!"));
	        if (rotate.length <= 0)
	            rotate.z = 1; //set the default direction
	        else
	            rotate.normalize();
	        this._pOneData[0] = rotate.x;
	        this._pOneData[1] = rotate.y;
	        this._pOneData[2] = rotate.z;
	        if (rotate.w <= 0)
	            throw (new Error("the cycle duration must greater than zero"));
	        // it's used as angle/2 in agal
	        this._pOneData[3] = Math.PI / rotate.w;
	    };
	    /**
	     * Reference for rotational velocity node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the rotational velocity around an axis of the particle.
	     */
	    ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D = "RotationalVelocityVector3D";
	    return ParticleRotationalVelocityNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleRotationalVelocityNode = ParticleRotationalVelocityNode;


/***/ },
/* 470 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleRotationalVelocityState = (function (_super) {
	    __extends(ParticleRotationalVelocityState, _super);
	    function ParticleRotationalVelocityState(animator, particleRotationNode) {
	        _super.call(this, animator, particleRotationNode);
	        this._particleRotationalVelocityNode = particleRotationNode;
	        this._rotationalVelocity = this._particleRotationalVelocityNode._iRotationalVelocity;
	        this.updateRotationalVelocityData();
	    }
	    Object.defineProperty(ParticleRotationalVelocityState.prototype, "rotationalVelocity", {
	        /**
	         * Defines the default rotationalVelocity of the state, used when in global mode.
	         */
	        get: function () {
	            return this._rotationalVelocity;
	        },
	        set: function (value) {
	            this._rotationalVelocity = value;
	            this.updateRotationalVelocityData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    ParticleRotationalVelocityState.prototype.getRotationalVelocities = function () {
	        return this._pDynamicProperties;
	    };
	    ParticleRotationalVelocityState.prototype.setRotationalVelocities = function (value) {
	        this._pDynamicProperties = value;
	        this._pDynamicPropertiesDirty = new Object();
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleRotationalVelocityState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (this._particleRotationalVelocityNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationElements._iUniqueId])
	            this._pUpdateDynamicProperties(animationElements);
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotationalVelocityState.ROTATIONALVELOCITY_INDEX);
	        if (this._particleRotationalVelocityNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL)
	            shader.setVertexConst(index, this._rotationalVelocityData.x, this._rotationalVelocityData.y, this._rotationalVelocityData.z, this._rotationalVelocityData.w);
	        else
	            animationElements.activateVertexBuffer(index, this._particleRotationalVelocityNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	    };
	    ParticleRotationalVelocityState.prototype.updateRotationalVelocityData = function () {
	        if (this._particleRotationalVelocityNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) {
	            if (this._rotationalVelocity.w <= 0)
	                throw (new Error("the cycle duration must greater than zero"));
	            var rotation = this._rotationalVelocity.clone();
	            if (rotation.length <= 0)
	                rotation.z = 1; //set the default direction
	            else
	                rotation.normalize();
	            // w is used as angle/2 in agal
	            this._rotationalVelocityData = new Vector3D_1.Vector3D(rotation.x, rotation.y, rotation.z, Math.PI / rotation.w);
	        }
	    };
	    /** @private */
	    ParticleRotationalVelocityState.ROTATIONALVELOCITY_INDEX = 0;
	    return ParticleRotationalVelocityState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleRotationalVelocityState = ParticleRotationalVelocityState;


/***/ },
/* 471 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleScaleState_1 = __webpack_require__(472);
	/**
	 * A particle animation node used to control the scale variation of a particle over time.
	 */
	var ParticleScaleNode = (function (_super) {
	    __extends(ParticleScaleNode, _super);
	    /**
	     * Creates a new <code>ParticleScaleNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of animation independent of particle duration. Defaults to false.
	     * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the animation cycle. Defaults to false.
	     * @param    [optional] minScale        Defines the default min scale transform of the node, when in global mode. Defaults to 1.
	     * @param    [optional] maxScale        Defines the default max color transform of the node, when in global mode. Defaults to 1.
	     * @param    [optional] cycleDuration   Defines the default duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
	     * @param    [optional] cyclePhase      Defines the default phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
	     */
	    function ParticleScaleNode(mode, usesCycle, usesPhase, minScale, maxScale, cycleDuration, cyclePhase) {
	        if (minScale === void 0) { minScale = 1; }
	        if (maxScale === void 0) { maxScale = 1; }
	        if (cycleDuration === void 0) { cycleDuration = 1; }
	        if (cyclePhase === void 0) { cyclePhase = 0; }
	        _super.call(this, "ParticleScale", mode, (usesCycle && usesPhase) ? 4 : ((usesCycle || usesPhase) ? 3 : 2), 3);
	        this._pStateClass = ParticleScaleState_1.ParticleScaleState;
	        this._iUsesCycle = usesCycle;
	        this._iUsesPhase = usesPhase;
	        this._iMinScale = minScale;
	        this._iMaxScale = maxScale;
	        this._iCycleDuration = cycleDuration;
	        this._iCyclePhase = cyclePhase;
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleScaleNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var code = "";
	        var temp = registerCache.getFreeVertexSingleTemp();
	        var scaleRegister = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleScaleState_1.ParticleScaleState.SCALE_INDEX, scaleRegister.index);
	        if (this._iUsesCycle) {
	            code += "mul " + temp + "," + animationRegisterData.vertexTime + "," + scaleRegister + ".z\n";
	            if (this._iUsesPhase)
	                code += "add " + temp + "," + temp + "," + scaleRegister + ".w\n";
	            code += "sin " + temp + "," + temp + "\n";
	        }
	        code += "mul " + temp + "," + scaleRegister + ".y," + ((this._iUsesCycle) ? temp : animationRegisterData.vertexLife) + "\n";
	        code += "add " + temp + "," + scaleRegister + ".x," + temp + "\n";
	        code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleScaleNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleScaleNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var scale = param[ParticleScaleNode.SCALE_VECTOR3D];
	        if (!scale)
	            throw (new Error("there is no " + ParticleScaleNode.SCALE_VECTOR3D + " in param!"));
	        if (this._iUsesCycle) {
	            this._pOneData[0] = (scale.x + scale.y) / 2;
	            this._pOneData[1] = Math.abs(scale.x - scale.y) / 2;
	            if (scale.z <= 0)
	                throw (new Error("the cycle duration must be greater than zero"));
	            this._pOneData[2] = Math.PI * 2 / scale.z;
	            if (this._iUsesPhase)
	                this._pOneData[3] = scale.w * Math.PI / 180;
	        }
	        else {
	            this._pOneData[0] = scale.x;
	            this._pOneData[1] = scale.y - scale.x;
	        }
	    };
	    /**
	     * Reference for scale node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> representing the min scale (x), max scale(y), optional cycle speed (z) and phase offset (w) applied to the particle.
	     */
	    ParticleScaleNode.SCALE_VECTOR3D = "ScaleVector3D";
	    return ParticleScaleNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleScaleNode = ParticleScaleNode;


/***/ },
/* 472 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleScaleState = (function (_super) {
	    __extends(ParticleScaleState, _super);
	    function ParticleScaleState(animator, particleScaleNode) {
	        _super.call(this, animator, particleScaleNode);
	        this._particleScaleNode = particleScaleNode;
	        this._usesCycle = this._particleScaleNode._iUsesCycle;
	        this._usesPhase = this._particleScaleNode._iUsesPhase;
	        this._minScale = this._particleScaleNode._iMinScale;
	        this._maxScale = this._particleScaleNode._iMaxScale;
	        this._cycleDuration = this._particleScaleNode._iCycleDuration;
	        this._cyclePhase = this._particleScaleNode._iCyclePhase;
	        this.updateScaleData();
	    }
	    Object.defineProperty(ParticleScaleState.prototype, "minScale", {
	        /**
	         * Defines the end scale of the state, when in global mode. Defaults to 1.
	         */
	        get: function () {
	            return this._minScale;
	        },
	        set: function (value) {
	            this._minScale = value;
	            this.updateScaleData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleScaleState.prototype, "maxScale", {
	        /**
	         * Defines the end scale of the state, when in global mode. Defaults to 1.
	         */
	        get: function () {
	            return this._maxScale;
	        },
	        set: function (value) {
	            this._maxScale = value;
	            this.updateScaleData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleScaleState.prototype, "cycleDuration", {
	        /**
	         * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
	         */
	        get: function () {
	            return this._cycleDuration;
	        },
	        set: function (value) {
	            this._cycleDuration = value;
	            this.updateScaleData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleScaleState.prototype, "cyclePhase", {
	        /**
	         * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
	         */
	        get: function () {
	            return this._cyclePhase;
	        },
	        set: function (value) {
	            this._cyclePhase = value;
	            this.updateScaleData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleScaleState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleScaleState.SCALE_INDEX);
	        if (this._particleScaleNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	            if (this._usesCycle) {
	                if (this._usesPhase)
	                    animationElements.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_4);
	                else
	                    animationElements.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	            }
	            else
	                animationElements.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2);
	        }
	        else
	            shader.setVertexConst(index, this._scaleData.x, this._scaleData.y, this._scaleData.z, this._scaleData.w);
	    };
	    ParticleScaleState.prototype.updateScaleData = function () {
	        if (this._particleScaleNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) {
	            if (this._usesCycle) {
	                if (this._cycleDuration <= 0)
	                    throw (new Error("the cycle duration must be greater than zero"));
	                this._scaleData = new Vector3D_1.Vector3D((this._minScale + this._maxScale) / 2, Math.abs(this._minScale - this._maxScale) / 2, Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180);
	            }
	            else
	                this._scaleData = new Vector3D_1.Vector3D(this._minScale, this._maxScale - this._minScale, 0, 0);
	        }
	    };
	    /** @private */
	    ParticleScaleState.SCALE_INDEX = 0;
	    return ParticleScaleState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleScaleState = ParticleScaleState;


/***/ },
/* 473 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticleAnimationSet_1 = __webpack_require__(451);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleSegmentedColorState_1 = __webpack_require__(474);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 *
	 */
	var ParticleSegmentedColorNode = (function (_super) {
	    __extends(ParticleSegmentedColorNode, _super);
	    function ParticleSegmentedColorNode(usesMultiplier, usesOffset, numSegmentPoint, startColor, endColor, segmentPoints) {
	        //because of the stage3d register limitation, it only support the global mode
	        _super.call(this, "ParticleSegmentedColor", ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL, 0, ParticleAnimationSet_1.ParticleAnimationSet.COLOR_PRIORITY);
	        this._pStateClass = ParticleSegmentedColorState_1.ParticleSegmentedColorState;
	        if (numSegmentPoint > 4)
	            throw (new Error("the numSegmentPoint must be less or equal 4"));
	        this._iUsesMultiplier = usesMultiplier;
	        this._iUsesOffset = usesOffset;
	        this._iNumSegmentPoint = numSegmentPoint;
	        this._iStartColor = startColor;
	        this._iEndColor = endColor;
	        this._iSegmentPoints = segmentPoints;
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleSegmentedColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	        if (this._iUsesMultiplier)
	            particleAnimationSet.hasColorMulNode = true;
	        if (this._iUsesOffset)
	            particleAnimationSet.hasColorAddNode = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleSegmentedColorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var code = "";
	        if (shader.usesFragmentAnimation) {
	            var accMultiplierColor;
	            //var accOffsetColor:ShaderRegisterElement;
	            if (this._iUsesMultiplier) {
	                accMultiplierColor = registerCache.getFreeVertexVectorTemp();
	                registerCache.addVertexTempUsages(accMultiplierColor, 1);
	            }
	            var tempColor = registerCache.getFreeVertexVectorTemp();
	            registerCache.addVertexTempUsages(tempColor, 1);
	            var temp = registerCache.getFreeVertexVectorTemp();
	            var accTime = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 0);
	            var tempTime = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 1);
	            if (this._iUsesMultiplier)
	                registerCache.removeVertexTempUsage(accMultiplierColor);
	            registerCache.removeVertexTempUsage(tempColor);
	            //for saving all the life values (at most 4)
	            var lifeTimeRegister = registerCache.getFreeVertexConstant();
	            animationRegisterData.setRegisterIndex(this, ParticleSegmentedColorState_1.ParticleSegmentedColorState.TIME_DATA_INDEX, lifeTimeRegister.index);
	            var i;
	            var startMulValue;
	            var deltaMulValues;
	            if (this._iUsesMultiplier) {
	                startMulValue = registerCache.getFreeVertexConstant();
	                animationRegisterData.setRegisterIndex(this, ParticleSegmentedColorState_1.ParticleSegmentedColorState.START_MULTIPLIER_INDEX, startMulValue.index);
	                deltaMulValues = new Array();
	                for (i = 0; i < this._iNumSegmentPoint + 1; i++)
	                    deltaMulValues.push(registerCache.getFreeVertexConstant());
	            }
	            var startOffsetValue;
	            var deltaOffsetValues;
	            if (this._iUsesOffset) {
	                startOffsetValue = registerCache.getFreeVertexConstant();
	                animationRegisterData.setRegisterIndex(this, ParticleSegmentedColorState_1.ParticleSegmentedColorState.START_OFFSET_INDEX, startOffsetValue.index);
	                deltaOffsetValues = new Array();
	                for (i = 0; i < this._iNumSegmentPoint + 1; i++)
	                    deltaOffsetValues.push(registerCache.getFreeVertexConstant());
	            }
	            if (this._iUsesMultiplier)
	                code += "mov " + accMultiplierColor + "," + startMulValue + "\n";
	            if (this._iUsesOffset)
	                code += "add " + animationRegisterData.colorAddTarget + "," + animationRegisterData.colorAddTarget + "," + startOffsetValue + "\n";
	            for (i = 0; i < this._iNumSegmentPoint; i++) {
	                switch (i) {
	                    case 0:
	                        code += "min " + tempTime + "," + animationRegisterData.vertexLife + "," + lifeTimeRegister + ".x\n";
	                        break;
	                    case 1:
	                        code += "sub " + accTime + "," + animationRegisterData.vertexLife + "," + lifeTimeRegister + ".x\n";
	                        code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
	                        code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".y\n";
	                        break;
	                    case 2:
	                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
	                        code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
	                        code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".z\n";
	                        break;
	                    case 3:
	                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
	                        code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
	                        code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".w\n";
	                        break;
	                }
	                if (this._iUsesMultiplier) {
	                    code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[i] + "\n";
	                    code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
	                }
	                if (this._iUsesOffset) {
	                    code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[i] + "\n";
	                    code += "add " + animationRegisterData.colorAddTarget + "," + animationRegisterData.colorAddTarget + "," + tempColor + "\n";
	                }
	            }
	            //for the last segment:
	            if (this._iNumSegmentPoint == 0)
	                tempTime = animationRegisterData.vertexLife;
	            else {
	                switch (this._iNumSegmentPoint) {
	                    case 1:
	                        code += "sub " + accTime + "," + animationRegisterData.vertexLife + "," + lifeTimeRegister + ".x\n";
	                        break;
	                    case 2:
	                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
	                        break;
	                    case 3:
	                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
	                        break;
	                    case 4:
	                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".w\n";
	                        break;
	                }
	                code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
	            }
	            if (this._iUsesMultiplier) {
	                code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[this._iNumSegmentPoint] + "\n";
	                code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
	                code += "mul " + animationRegisterData.colorMulTarget + "," + animationRegisterData.colorMulTarget + "," + accMultiplierColor + "\n";
	            }
	            if (this._iUsesOffset) {
	                code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[this._iNumSegmentPoint] + "\n";
	                code += "add " + animationRegisterData.colorAddTarget + "," + animationRegisterData.colorAddTarget + "," + tempColor + "\n";
	            }
	        }
	        return code;
	    };
	    return ParticleSegmentedColorNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleSegmentedColorNode = ParticleSegmentedColorNode;


/***/ },
/* 474 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 *
	 */
	var ParticleSegmentedColorState = (function (_super) {
	    __extends(ParticleSegmentedColorState, _super);
	    function ParticleSegmentedColorState(animator, particleSegmentedColorNode) {
	        _super.call(this, animator, particleSegmentedColorNode);
	        this._usesMultiplier = particleSegmentedColorNode._iUsesMultiplier;
	        this._usesOffset = particleSegmentedColorNode._iUsesOffset;
	        this._startColor = particleSegmentedColorNode._iStartColor;
	        this._endColor = particleSegmentedColorNode._iEndColor;
	        this._segmentPoints = particleSegmentedColorNode._iSegmentPoints;
	        this._numSegmentPoint = particleSegmentedColorNode._iNumSegmentPoint;
	        this.updateColorData();
	    }
	    Object.defineProperty(ParticleSegmentedColorState.prototype, "startColor", {
	        /**
	         * Defines the start color transform of the state, when in global mode.
	         */
	        get: function () {
	            return this._startColor;
	        },
	        set: function (value) {
	            this._startColor = value;
	            this.updateColorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSegmentedColorState.prototype, "endColor", {
	        /**
	         * Defines the end color transform of the state, when in global mode.
	         */
	        get: function () {
	            return this._endColor;
	        },
	        set: function (value) {
	            this._endColor = value;
	            this.updateColorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSegmentedColorState.prototype, "numSegmentPoint", {
	        /**
	         * Defines the number of segments.
	         */
	        get: function () {
	            return this._numSegmentPoint;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSegmentedColorState.prototype, "segmentPoints", {
	        /**
	         * Defines the key points of color
	         */
	        get: function () {
	            return this._segmentPoints;
	        },
	        set: function (value) {
	            this._segmentPoints = value;
	            this.updateColorData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSegmentedColorState.prototype, "usesMultiplier", {
	        get: function () {
	            return this._usesMultiplier;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSegmentedColorState.prototype, "usesOffset", {
	        get: function () {
	            return this._usesOffset;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleSegmentedColorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (shader.usesFragmentAnimation) {
	            if (this._numSegmentPoint > 0)
	                shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSegmentedColorState.TIME_DATA_INDEX), this._timeLifeData[0], this._timeLifeData[1], this._timeLifeData[2], this._timeLifeData[3]);
	            if (this._usesMultiplier)
	                shader.setVertexConstFromArray(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSegmentedColorState.START_MULTIPLIER_INDEX), this._multiplierData);
	            if (this._usesOffset)
	                shader.setVertexConstFromArray(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSegmentedColorState.START_OFFSET_INDEX), this._offsetData);
	        }
	    };
	    ParticleSegmentedColorState.prototype.updateColorData = function () {
	        this._timeLifeData = new Float32Array(4);
	        this._multiplierData = new Float32Array(4 * (this._numSegmentPoint + 1));
	        this._offsetData = new Float32Array(4 * (this._numSegmentPoint + 1));
	        //cut off the time data
	        var i;
	        var j = 0;
	        var count = this._numSegmentPoint > 3 ? 3 : this._numSegmentPoint;
	        for (i = 0; i < count; i++) {
	            if (i == 0)
	                this._timeLifeData[j++] = this._segmentPoints[i].life;
	            else
	                this._timeLifeData[j++] = this._segmentPoints[i].life - this._segmentPoints[i - 1].life;
	        }
	        i = count;
	        if (this._numSegmentPoint == 0)
	            this._timeLifeData[j++] = 1;
	        else
	            this._timeLifeData[j++] = 1 - this._segmentPoints[i - 1].life;
	        if (this._usesMultiplier) {
	            j = 0;
	            this._multiplierData[j++] = this._startColor.redMultiplier;
	            this._multiplierData[j++] = this._startColor.greenMultiplier;
	            this._multiplierData[j++] = this._startColor.blueMultiplier;
	            this._multiplierData[j++] = this._startColor.alphaMultiplier;
	            for (i = 0; i < this._numSegmentPoint; i++) {
	                if (i == 0) {
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.redMultiplier - this._startColor.redMultiplier) / this._timeLifeData[i];
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.greenMultiplier - this._startColor.greenMultiplier) / this._timeLifeData[i];
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.blueMultiplier - this._startColor.blueMultiplier) / this._timeLifeData[i];
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.alphaMultiplier - this._startColor.alphaMultiplier) / this._timeLifeData[i];
	                }
	                else {
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i];
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i];
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i];
	                    this._multiplierData[j++] = (this._segmentPoints[i].color.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i];
	                }
	            }
	            i = this._numSegmentPoint;
	            if (this._numSegmentPoint == 0) {
	                this._multiplierData[j++] = this._endColor.redMultiplier - this._startColor.redMultiplier;
	                this._multiplierData[j++] = this._endColor.greenMultiplier - this._startColor.greenMultiplier;
	                this._multiplierData[j++] = this._endColor.blueMultiplier - this._startColor.blueMultiplier;
	                this._multiplierData[j++] = this._endColor.alphaMultiplier - this._startColor.alphaMultiplier;
	            }
	            else {
	                this._multiplierData[j++] = (this._endColor.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i];
	                this._multiplierData[j++] = (this._endColor.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i];
	                this._multiplierData[j++] = (this._endColor.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i];
	                this._multiplierData[j++] = (this._endColor.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i];
	            }
	        }
	        if (this._usesOffset) {
	            j = 0;
	            this._offsetData[j++] = this._startColor.redOffset / 255;
	            this._offsetData[j++] = this._startColor.greenOffset / 255;
	            this._offsetData[j++] = this._startColor.blueOffset / 255;
	            this._offsetData[j++] = this._startColor.alphaOffset / 255;
	            for (i = 0; i < this._numSegmentPoint; i++) {
	                if (i == 0) {
	                    this._offsetData[j++] = (this._segmentPoints[i].color.redOffset - this._startColor.redOffset) / this._timeLifeData[i] / 255;
	                    this._offsetData[j++] = (this._segmentPoints[i].color.greenOffset - this._startColor.greenOffset) / this._timeLifeData[i] / 255;
	                    this._offsetData[j++] = (this._segmentPoints[i].color.blueOffset - this._startColor.blueOffset) / this._timeLifeData[i] / 255;
	                    this._offsetData[j++] = (this._segmentPoints[i].color.alphaOffset - this._startColor.alphaOffset) / this._timeLifeData[i] / 255;
	                }
	                else {
	                    this._offsetData[j++] = (this._segmentPoints[i].color.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255;
	                    this._offsetData[j++] = (this._segmentPoints[i].color.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255;
	                    this._offsetData[j++] = (this._segmentPoints[i].color.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255;
	                    this._offsetData[j++] = (this._segmentPoints[i].color.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255;
	                }
	            }
	            i = this._numSegmentPoint;
	            if (this._numSegmentPoint == 0) {
	                this._offsetData[j++] = (this._endColor.redOffset - this._startColor.redOffset) / 255;
	                this._offsetData[j++] = (this._endColor.greenOffset - this._startColor.greenOffset) / 255;
	                this._offsetData[j++] = (this._endColor.blueOffset - this._startColor.blueOffset) / 255;
	                this._offsetData[j++] = (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255;
	            }
	            else {
	                this._offsetData[i] = (this._endColor.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255;
	                this._offsetData[j++] = (this._endColor.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255;
	                this._offsetData[j++] = (this._endColor.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255;
	                this._offsetData[j++] = (this._endColor.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255;
	            }
	        }
	    };
	    /** @private */
	    ParticleSegmentedColorState.START_MULTIPLIER_INDEX = 0;
	    /** @private */
	    ParticleSegmentedColorState.START_OFFSET_INDEX = 1;
	    /** @private */
	    ParticleSegmentedColorState.TIME_DATA_INDEX = 2;
	    return ParticleSegmentedColorState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleSegmentedColorState = ParticleSegmentedColorState;


/***/ },
/* 475 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticleAnimationSet_1 = __webpack_require__(451);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleSpriteSheetState_1 = __webpack_require__(476);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used when a spritesheet texture is required to animate the particle.
	 * NB: to enable use of this node, the <code>repeat</code> property on the material has to be set to true.
	 */
	var ParticleSpriteSheetNode = (function (_super) {
	    __extends(ParticleSpriteSheetNode, _super);
	    /**
	     * Creates a new <code>ParticleSpriteSheetNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] numColumns      Defines the number of columns in the spritesheet, when in global mode. Defaults to 1.
	     * @param    [optional] numRows         Defines the number of rows in the spritesheet, when in global mode. Defaults to 1.
	     * @param    [optional] cycleDuration   Defines the default cycle duration in seconds, when in global mode. Defaults to 1.
	     * @param    [optional] cyclePhase      Defines the default cycle phase, when in global mode. Defaults to 0.
	     * @param    [optional] totalFrames     Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows.
	     * @param    [optional] looping         Defines whether the spritesheet animation is set to loop indefinitely. Defaults to true.
	     */
	    function ParticleSpriteSheetNode(mode, usesCycle, usesPhase, numColumns, numRows, cycleDuration, cyclePhase, totalFrames) {
	        if (numColumns === void 0) { numColumns = 1; }
	        if (numRows === void 0) { numRows = 1; }
	        if (cycleDuration === void 0) { cycleDuration = 1; }
	        if (cyclePhase === void 0) { cyclePhase = 0; }
	        if (totalFrames === void 0) { totalFrames = Number.MAX_VALUE; }
	        _super.call(this, "ParticleSpriteSheet", mode, usesCycle ? (usesPhase ? 3 : 2) : 1, ParticleAnimationSet_1.ParticleAnimationSet.POST_PRIORITY + 1);
	        this._pStateClass = ParticleSpriteSheetState_1.ParticleSpriteSheetState;
	        this._iUsesCycle = usesCycle;
	        this._iUsesPhase = usesPhase;
	        this._iNumColumns = numColumns;
	        this._iNumRows = numRows;
	        this._iCyclePhase = cyclePhase;
	        this._iCycleDuration = cycleDuration;
	        this._iTotalFrames = Math.min(totalFrames, numColumns * numRows);
	    }
	    Object.defineProperty(ParticleSpriteSheetNode.prototype, "numColumns", {
	        /**
	         * Defines the number of columns in the spritesheet, when in global mode. Defaults to 1. Read only.
	         */
	        get: function () {
	            return this._iNumColumns;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSpriteSheetNode.prototype, "numRows", {
	        /**
	         * Defines the number of rows in the spritesheet, when in global mode. Defaults to 1. Read only.
	         */
	        get: function () {
	            return this._iNumRows;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSpriteSheetNode.prototype, "totalFrames", {
	        /**
	         * Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows. Read only.
	         */
	        get: function () {
	            return this._iTotalFrames;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleSpriteSheetNode.prototype.getAGALUVCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        //get 2 vc
	        var uvParamConst1 = registerCache.getFreeVertexConstant();
	        var uvParamConst2 = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleSpriteSheetState_1.ParticleSpriteSheetState.UV_INDEX_0, uvParamConst1.index);
	        animationRegisterData.setRegisterIndex(this, ParticleSpriteSheetState_1.ParticleSpriteSheetState.UV_INDEX_1, uvParamConst2.index);
	        var uTotal = new ShaderRegisterElement_1.ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 0);
	        var uStep = new ShaderRegisterElement_1.ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 1);
	        var vStep = new ShaderRegisterElement_1.ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 2);
	        var uSpeed = new ShaderRegisterElement_1.ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 0);
	        var cycle = new ShaderRegisterElement_1.ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 1);
	        var phaseTime = new ShaderRegisterElement_1.ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 2);
	        var temp = registerCache.getFreeVertexVectorTemp();
	        var time = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 0);
	        var vOffset = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 1);
	        temp = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 2);
	        var temp2 = new ShaderRegisterElement_1.ShaderRegisterElement(temp.regName, temp.index, 3);
	        var u = new ShaderRegisterElement_1.ShaderRegisterElement(animationRegisterData.uvTarget.regName, animationRegisterData.uvTarget.index, 0);
	        var v = new ShaderRegisterElement_1.ShaderRegisterElement(animationRegisterData.uvTarget.regName, animationRegisterData.uvTarget.index, 1);
	        var code = "";
	        //scale uv
	        code += "mul " + u + "," + u + "," + uStep + "\n";
	        if (this._iNumRows > 1)
	            code += "mul " + v + "," + v + "," + vStep + "\n";
	        if (this._iUsesCycle) {
	            if (this._iUsesPhase)
	                code += "add " + time + "," + animationRegisterData.vertexTime + "," + phaseTime + "\n";
	            else
	                code += "mov " + time + "," + animationRegisterData.vertexTime + "\n";
	            code += "div " + time + "," + time + "," + cycle + "\n";
	            code += "frc " + time + "," + time + "\n";
	            code += "mul " + time + "," + time + "," + cycle + "\n";
	            code += "mul " + temp + "," + time + "," + uSpeed + "\n";
	        }
	        else
	            code += "mul " + temp.toString() + "," + animationRegisterData.vertexLife + "," + uTotal + "\n";
	        if (this._iNumRows > 1) {
	            code += "frc " + temp2 + "," + temp + "\n";
	            code += "sub " + vOffset + "," + temp + "," + temp2 + "\n";
	            code += "mul " + vOffset + "," + vOffset + "," + vStep + "\n";
	            code += "add " + v + "," + v + "," + vOffset + "\n";
	        }
	        code += "div " + temp2 + "," + temp + "," + uStep + "\n";
	        code += "frc " + temp + "," + temp2 + "\n";
	        code += "sub " + temp2 + "," + temp2 + "," + temp + "\n";
	        code += "mul " + temp + "," + temp2 + "," + uStep + "\n";
	        if (this._iNumRows > 1)
	            code += "frc " + temp + "," + temp + "\n";
	        code += "add " + u + "," + u + "," + temp + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleSpriteSheetNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleSpriteSheetNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	        particleAnimationSet.hasUVNode = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleSpriteSheetNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        if (this._iUsesCycle) {
	            var uvCycle = param[ParticleSpriteSheetNode.UV_VECTOR3D];
	            if (!uvCycle)
	                throw (new Error("there is no " + ParticleSpriteSheetNode.UV_VECTOR3D + " in param!"));
	            if (uvCycle.x <= 0)
	                throw (new Error("the cycle duration must be greater than zero"));
	            var uTotal = this._iTotalFrames / this._iNumColumns;
	            this._pOneData[0] = uTotal / uvCycle.x;
	            this._pOneData[1] = uvCycle.x;
	            if (this._iUsesPhase)
	                this._pOneData[2] = uvCycle.y;
	        }
	    };
	    /**
	     * Reference for spritesheet node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> representing the cycleDuration (x), optional phaseTime (y).
	     */
	    ParticleSpriteSheetNode.UV_VECTOR3D = "UVVector3D";
	    return ParticleSpriteSheetNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleSpriteSheetNode = ParticleSpriteSheetNode;


/***/ },
/* 476 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleSpriteSheetState = (function (_super) {
	    __extends(ParticleSpriteSheetState, _super);
	    function ParticleSpriteSheetState(animator, particleSpriteSheetNode) {
	        _super.call(this, animator, particleSpriteSheetNode);
	        this._particleSpriteSheetNode = particleSpriteSheetNode;
	        this._usesCycle = this._particleSpriteSheetNode._iUsesCycle;
	        this._usesPhase = this._particleSpriteSheetNode._iUsesCycle;
	        this._totalFrames = this._particleSpriteSheetNode._iTotalFrames;
	        this._numColumns = this._particleSpriteSheetNode._iNumColumns;
	        this._numRows = this._particleSpriteSheetNode._iNumRows;
	        this._cycleDuration = this._particleSpriteSheetNode._iCycleDuration;
	        this._cyclePhase = this._particleSpriteSheetNode._iCyclePhase;
	        this.updateSpriteSheetData();
	    }
	    Object.defineProperty(ParticleSpriteSheetState.prototype, "cyclePhase", {
	        /**
	         * Defines the cycle phase, when in global mode. Defaults to zero.
	         */
	        get: function () {
	            return this._cyclePhase;
	        },
	        set: function (value) {
	            this._cyclePhase = value;
	            this.updateSpriteSheetData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleSpriteSheetState.prototype, "cycleDuration", {
	        /**
	         * Defines the cycle duration in seconds, when in global mode. Defaults to 1.
	         */
	        get: function () {
	            return this._cycleDuration;
	        },
	        set: function (value) {
	            this._cycleDuration = value;
	            this.updateSpriteSheetData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ParticleSpriteSheetState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (!shader.usesUVTransform) {
	            shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSpriteSheetState.UV_INDEX_0), this._spriteSheetData[0], this._spriteSheetData[1], this._spriteSheetData[2], this._spriteSheetData[3]);
	            if (this._usesCycle) {
	                var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSpriteSheetState.UV_INDEX_1);
	                if (this._particleSpriteSheetNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_STATIC) {
	                    if (this._usesPhase)
	                        animationElements.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	                    else
	                        animationElements.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2);
	                }
	                else
	                    shader.setVertexConst(index, this._spriteSheetData[4], this._spriteSheetData[5]);
	            }
	        }
	    };
	    ParticleSpriteSheetState.prototype.updateSpriteSheetData = function () {
	        this._spriteSheetData = new Array(8);
	        var uTotal = this._totalFrames / this._numColumns;
	        this._spriteSheetData[0] = uTotal;
	        this._spriteSheetData[1] = 1 / this._numColumns;
	        this._spriteSheetData[2] = 1 / this._numRows;
	        if (this._usesCycle) {
	            if (this._cycleDuration <= 0)
	                throw (new Error("the cycle duration must be greater than zero"));
	            this._spriteSheetData[4] = uTotal / this._cycleDuration;
	            this._spriteSheetData[5] = this._cycleDuration;
	            if (this._usesPhase)
	                this._spriteSheetData[6] = this._cyclePhase;
	        }
	    };
	    /** @private */
	    ParticleSpriteSheetState.UV_INDEX_0 = 0;
	    /** @private */
	    ParticleSpriteSheetState.UV_INDEX_1 = 1;
	    return ParticleSpriteSheetState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleSpriteSheetState = ParticleSpriteSheetState;


/***/ },
/* 477 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticleAnimationSet_1 = __webpack_require__(451);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleUVState_1 = __webpack_require__(478);
	var ShaderRegisterElement_1 = __webpack_require__(275);
	/**
	 * A particle animation node used to control the UV offset and scale of a particle over time.
	 */
	var ParticleUVNode = (function (_super) {
	    __extends(ParticleUVNode, _super);
	    /**
	     * Creates a new <code>ParticleTimeNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] cycle           Defines whether the time track is in loop mode. Defaults to false.
	     * @param    [optional] scale           Defines whether the time track is in loop mode. Defaults to false.
	     * @param    [optional] axis            Defines whether the time track is in loop mode. Defaults to false.
	     */
	    function ParticleUVNode(mode, cycle, scale, axis) {
	        if (cycle === void 0) { cycle = 1; }
	        if (scale === void 0) { scale = 1; }
	        if (axis === void 0) { axis = "x"; }
	        //because of the stage3d register limitation, it only support the global mode
	        _super.call(this, "ParticleUV", ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL, 4, ParticleAnimationSet_1.ParticleAnimationSet.POST_PRIORITY + 1);
	        this._pStateClass = ParticleUVState_1.ParticleUVState;
	        this._cycle = cycle;
	        this._scale = scale;
	        this._axis = axis;
	        this.updateUVData();
	    }
	    Object.defineProperty(ParticleUVNode.prototype, "cycle", {
	        /**
	         *
	         */
	        get: function () {
	            return this._cycle;
	        },
	        set: function (value) {
	            this._cycle = value;
	            this.updateUVData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleUVNode.prototype, "scale", {
	        /**
	         *
	         */
	        get: function () {
	            return this._scale;
	        },
	        set: function (value) {
	            this._scale = value;
	            this.updateUVData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleUVNode.prototype, "axis", {
	        /**
	         *
	         */
	        get: function () {
	            return this._axis;
	        },
	        set: function (value) {
	            this._axis = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    ParticleUVNode.prototype.getAGALUVCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var code = "";
	        var uvConst = registerCache.getFreeVertexConstant();
	        animationRegisterData.setRegisterIndex(this, ParticleUVState_1.ParticleUVState.UV_INDEX, uvConst.index);
	        var axisIndex = this._axis == "x" ? 0 : (this._axis == "y" ? 1 : 2);
	        var target = new ShaderRegisterElement_1.ShaderRegisterElement(animationRegisterData.uvTarget.regName, animationRegisterData.uvTarget.index, axisIndex);
	        var sin = registerCache.getFreeVertexSingleTemp();
	        if (this._scale != 1)
	            code += "mul " + target + "," + target + "," + uvConst + ".y\n";
	        code += "mul " + sin + "," + animationRegisterData.vertexTime + "," + uvConst + ".x\n";
	        code += "sin " + sin + "," + sin + "\n";
	        code += "add " + target + "," + target + "," + sin + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleUVNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    ParticleUVNode.prototype.updateUVData = function () {
	        this._iUvData = new Vector3D_1.Vector3D(Math.PI * 2 / this._cycle, this._scale, 0, 0);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleUVNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
	        particleAnimationSet.hasUVNode = true;
	    };
	    /**
	     *
	     */
	    ParticleUVNode.U_AXIS = "x";
	    /**
	     *
	     */
	    ParticleUVNode.V_AXIS = "y";
	    return ParticleUVNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleUVNode = ParticleUVNode;


/***/ },
/* 478 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleUVState = (function (_super) {
	    __extends(ParticleUVState, _super);
	    function ParticleUVState(animator, particleUVNode) {
	        _super.call(this, animator, particleUVNode);
	        this._particleUVNode = particleUVNode;
	    }
	    ParticleUVState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (!shader.usesUVTransform) {
	            var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleUVState.UV_INDEX);
	            var data = this._particleUVNode._iUvData;
	            shader.setVertexConst(index, data.x, data.y);
	        }
	    };
	    /** @private */
	    ParticleUVState.UV_INDEX = 0;
	    return ParticleUVState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleUVState = ParticleUVState;


/***/ },
/* 479 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleNodeBase_1 = __webpack_require__(443);
	var ParticleVelocityState_1 = __webpack_require__(480);
	/**
	 * A particle animation node used to set the starting velocity of a particle.
	 */
	var ParticleVelocityNode = (function (_super) {
	    __extends(ParticleVelocityNode, _super);
	    /**
	     * Creates a new <code>ParticleVelocityNode</code>
	     *
	     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
	     * @param    [optional] velocity        Defines the default velocity vector of the node, used when in global mode.
	     */
	    function ParticleVelocityNode(mode, velocity) {
	        if (velocity === void 0) { velocity = null; }
	        _super.call(this, "ParticleVelocity", mode, 3);
	        this._pStateClass = ParticleVelocityState_1.ParticleVelocityState;
	        this._iVelocity = velocity || new Vector3D_1.Vector3D();
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleVelocityNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
	        var velocityValue = (this._pMode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
	        animationRegisterData.setRegisterIndex(this, ParticleVelocityState_1.ParticleVelocityState.VELOCITY_INDEX, velocityValue.index);
	        var distance = registerCache.getFreeVertexVectorTemp();
	        var code = "";
	        code += "mul " + distance + "," + animationRegisterData.vertexTime + "," + velocityValue + "\n";
	        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + "," + animationRegisterData.positionTarget + ".xyz\n";
	        if (animationSet.needVelocity)
	            code += "add " + animationRegisterData.velocityTarget + ".xyz," + velocityValue + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleVelocityNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
	        var _tempVelocity = param[ParticleVelocityNode.VELOCITY_VECTOR3D];
	        if (!_tempVelocity)
	            throw new Error("there is no " + ParticleVelocityNode.VELOCITY_VECTOR3D + " in param!");
	        this._pOneData[0] = _tempVelocity.x;
	        this._pOneData[1] = _tempVelocity.y;
	        this._pOneData[2] = _tempVelocity.z;
	    };
	    /**
	     * Reference for velocity node properties on a single particle (when in local property mode).
	     * Expects a <code>Vector3D</code> object representing the direction of movement on the particle.
	     */
	    ParticleVelocityNode.VELOCITY_VECTOR3D = "VelocityVector3D";
	    return ParticleVelocityNode;
	}(ParticleNodeBase_1.ParticleNodeBase));
	exports.ParticleVelocityNode = ParticleVelocityNode;


/***/ },
/* 480 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	var ParticleStateBase_1 = __webpack_require__(445);
	/**
	 * ...
	 */
	var ParticleVelocityState = (function (_super) {
	    __extends(ParticleVelocityState, _super);
	    function ParticleVelocityState(animator, particleVelocityNode) {
	        _super.call(this, animator, particleVelocityNode);
	        this._particleVelocityNode = particleVelocityNode;
	        this._velocity = this._particleVelocityNode._iVelocity;
	    }
	    Object.defineProperty(ParticleVelocityState.prototype, "velocity", {
	        /**
	         * Defines the default velocity vector of the state, used when in global mode.
	         */
	        get: function () {
	            return this._velocity;
	        },
	        set: function (value) {
	            this._velocity = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    ParticleVelocityState.prototype.getVelocities = function () {
	        return this._pDynamicProperties;
	    };
	    ParticleVelocityState.prototype.setVelocities = function (value) {
	        this._pDynamicProperties = value;
	        this._pDynamicPropertiesDirty = new Object();
	    };
	    ParticleVelocityState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, camera, stage) {
	        if (this._particleVelocityNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationElements._iUniqueId])
	            this._pUpdateDynamicProperties(animationElements);
	        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleVelocityState.VELOCITY_INDEX);
	        if (this._particleVelocityNode.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.GLOBAL)
	            shader.setVertexConst(index, this._velocity.x, this._velocity.y, this._velocity.z);
	        else
	            animationElements.activateVertexBuffer(index, this._particleVelocityNode._iDataOffset, stage, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_3);
	    };
	    /** @private */
	    ParticleVelocityState.VELOCITY_INDEX = 0;
	    return ParticleVelocityState;
	}(ParticleStateBase_1.ParticleStateBase));
	exports.ParticleVelocityState = ParticleVelocityState;


/***/ },
/* 481 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationNodeBase_1 = __webpack_require__(336);
	var SkeletonBinaryLERPState_1 = __webpack_require__(482);
	/**
	 * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
	 */
	var SkeletonBinaryLERPNode = (function (_super) {
	    __extends(SkeletonBinaryLERPNode, _super);
	    /**
	     * Creates a new <code>SkeletonBinaryLERPNode</code> object.
	     */
	    function SkeletonBinaryLERPNode() {
	        _super.call(this);
	        this._pStateClass = SkeletonBinaryLERPState_1.SkeletonBinaryLERPState;
	    }
	    /**
	     * @inheritDoc
	     */
	    SkeletonBinaryLERPNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    return SkeletonBinaryLERPNode;
	}(AnimationNodeBase_1.AnimationNodeBase));
	exports.SkeletonBinaryLERPNode = SkeletonBinaryLERPNode;


/***/ },
/* 482 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var JointPose_1 = __webpack_require__(328);
	var SkeletonPose_1 = __webpack_require__(330);
	var AnimationStateBase_1 = __webpack_require__(339);
	/**
	 *
	 */
	var SkeletonBinaryLERPState = (function (_super) {
	    __extends(SkeletonBinaryLERPState, _super);
	    function SkeletonBinaryLERPState(animator, skeletonAnimationNode) {
	        _super.call(this, animator, skeletonAnimationNode);
	        this._blendWeight = 0;
	        this._skeletonPose = new SkeletonPose_1.SkeletonPose();
	        this._skeletonPoseDirty = true;
	        this._skeletonAnimationNode = skeletonAnimationNode;
	        this._inputA = animator.getAnimationState(this._skeletonAnimationNode.inputA);
	        this._inputB = animator.getAnimationState(this._skeletonAnimationNode.inputB);
	    }
	    Object.defineProperty(SkeletonBinaryLERPState.prototype, "blendWeight", {
	        /**
	         * Defines a fractional value between 0 and 1 representing the blending ratio between inputA (0) and inputB (1),
	         * used to produce the skeleton pose output.
	         *
	         * @see inputA
	         * @see inputB
	         */
	        get: function () {
	            return this._blendWeight;
	        },
	        set: function (value) {
	            this._blendWeight = value;
	            this._pPositionDeltaDirty = true;
	            this._skeletonPoseDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SkeletonBinaryLERPState.prototype.phase = function (value) {
	        this._skeletonPoseDirty = true;
	        this._pPositionDeltaDirty = true;
	        this._inputA.phase(value);
	        this._inputB.phase(value);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonBinaryLERPState.prototype._pUpdateTime = function (time) {
	        this._skeletonPoseDirty = true;
	        this._inputA.update(time);
	        this._inputB.update(time);
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
	     */
	    SkeletonBinaryLERPState.prototype.getSkeletonPose = function (skeleton) {
	        if (this._skeletonPoseDirty)
	            this.updateSkeletonPose(skeleton);
	        return this._skeletonPose;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonBinaryLERPState.prototype._pUpdatePositionDelta = function () {
	        this._pPositionDeltaDirty = false;
	        var deltA = this._inputA.positionDelta;
	        var deltB = this._inputB.positionDelta;
	        this._pRootDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
	        this._pRootDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
	        this._pRootDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
	    };
	    /**
	     * Updates the output skeleton pose of the node based on the blendWeight value between input nodes.
	     *
	     * @param skeleton The skeleton used by the animator requesting the ouput pose.
	     */
	    SkeletonBinaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
	        this._skeletonPoseDirty = false;
	        var endPose;
	        var endPoses = this._skeletonPose.jointPoses;
	        var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
	        var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
	        var pose1, pose2;
	        var p1, p2;
	        var tr;
	        var numJoints = skeleton.numJoints;
	        // :s
	        if (endPoses.length != numJoints)
	            endPoses.length = numJoints;
	        for (var i = 0; i < numJoints; ++i) {
	            endPose = endPoses[i];
	            if (endPose == null)
	                endPose = endPoses[i] = new JointPose_1.JointPose();
	            pose1 = poses1[i];
	            pose2 = poses2[i];
	            p1 = pose1.translation;
	            p2 = pose2.translation;
	            endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);
	            tr = endPose.translation;
	            tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
	            tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
	            tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
	        }
	    };
	    return SkeletonBinaryLERPState;
	}(AnimationStateBase_1.AnimationStateBase));
	exports.SkeletonBinaryLERPState = SkeletonBinaryLERPState;


/***/ },
/* 483 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationNodeBase_1 = __webpack_require__(336);
	var SkeletonDifferenceState_1 = __webpack_require__(484);
	/**
	 * A skeleton animation node that uses a difference input pose with a base input pose to blend a linearly interpolated output of a skeleton pose.
	 */
	var SkeletonDifferenceNode = (function (_super) {
	    __extends(SkeletonDifferenceNode, _super);
	    /**
	     * Creates a new <code>SkeletonAdditiveNode</code> object.
	     */
	    function SkeletonDifferenceNode() {
	        _super.call(this);
	        this._pStateClass = SkeletonDifferenceState_1.SkeletonDifferenceState;
	    }
	    /**
	     * @inheritDoc
	     */
	    SkeletonDifferenceNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    return SkeletonDifferenceNode;
	}(AnimationNodeBase_1.AnimationNodeBase));
	exports.SkeletonDifferenceNode = SkeletonDifferenceNode;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonDifferenceNode;


/***/ },
/* 484 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Quaternion_1 = __webpack_require__(329);
	var JointPose_1 = __webpack_require__(328);
	var SkeletonPose_1 = __webpack_require__(330);
	var AnimationStateBase_1 = __webpack_require__(339);
	/**
	 *
	 */
	var SkeletonDifferenceState = (function (_super) {
	    __extends(SkeletonDifferenceState, _super);
	    function SkeletonDifferenceState(animator, skeletonAnimationNode) {
	        _super.call(this, animator, skeletonAnimationNode);
	        this._blendWeight = 0;
	        this._skeletonPose = new SkeletonPose_1.SkeletonPose();
	        this._skeletonPoseDirty = true;
	        this._skeletonAnimationNode = skeletonAnimationNode;
	        this._baseInput = animator.getAnimationState(this._skeletonAnimationNode.baseInput);
	        this._differenceInput = animator.getAnimationState(this._skeletonAnimationNode.differenceInput);
	    }
	    Object.defineProperty(SkeletonDifferenceState.prototype, "blendWeight", {
	        /**
	         * Defines a fractional value between 0 and 1 representing the blending ratio between the base input (0) and difference input (1),
	         * used to produce the skeleton pose output.
	         *
	         * @see #baseInput
	         * @see #differenceInput
	         */
	        get: function () {
	            return this._blendWeight;
	        },
	        set: function (value) {
	            this._blendWeight = value;
	            this._pPositionDeltaDirty = true;
	            this._skeletonPoseDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SkeletonDifferenceState.prototype.phase = function (value) {
	        this._skeletonPoseDirty = true;
	        this._pPositionDeltaDirty = true;
	        this._baseInput.phase(value);
	        this._baseInput.phase(value);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonDifferenceState.prototype._pUpdateTime = function (time) {
	        this._skeletonPoseDirty = true;
	        this._baseInput.update(time);
	        this._differenceInput.update(time);
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
	     */
	    SkeletonDifferenceState.prototype.getSkeletonPose = function (skeleton) {
	        if (this._skeletonPoseDirty)
	            this.updateSkeletonPose(skeleton);
	        return this._skeletonPose;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonDifferenceState.prototype._pUpdatePositionDelta = function () {
	        this._pPositionDeltaDirty = false;
	        var deltA = this._baseInput.positionDelta;
	        var deltB = this._differenceInput.positionDelta;
	        this.positionDelta.x = deltA.x + this._blendWeight * deltB.x;
	        this.positionDelta.y = deltA.y + this._blendWeight * deltB.y;
	        this.positionDelta.z = deltA.z + this._blendWeight * deltB.z;
	    };
	    /**
	     * Updates the output skeleton pose of the node based on the blendWeight value between base input and difference input nodes.
	     *
	     * @param skeleton The skeleton used by the animator requesting the ouput pose.
	     */
	    SkeletonDifferenceState.prototype.updateSkeletonPose = function (skeleton) {
	        this._skeletonPoseDirty = false;
	        var endPose;
	        var endPoses = this._skeletonPose.jointPoses;
	        var basePoses = this._baseInput.getSkeletonPose(skeleton).jointPoses;
	        var diffPoses = this._differenceInput.getSkeletonPose(skeleton).jointPoses;
	        var base, diff;
	        var basePos, diffPos;
	        var tr;
	        var numJoints = skeleton.numJoints;
	        // :s
	        if (endPoses.length != numJoints)
	            endPoses.length = numJoints;
	        for (var i = 0; i < numJoints; ++i) {
	            endPose = endPoses[i];
	            if (endPose == null)
	                endPose = endPoses[i] = new JointPose_1.JointPose();
	            base = basePoses[i];
	            diff = diffPoses[i];
	            basePos = base.translation;
	            diffPos = diff.translation;
	            SkeletonDifferenceState._tempQuat.multiply(diff.orientation, base.orientation);
	            endPose.orientation.lerp(base.orientation, SkeletonDifferenceState._tempQuat, this._blendWeight);
	            tr = endPose.translation;
	            tr.x = basePos.x + this._blendWeight * diffPos.x;
	            tr.y = basePos.y + this._blendWeight * diffPos.y;
	            tr.z = basePos.z + this._blendWeight * diffPos.z;
	        }
	    };
	    SkeletonDifferenceState._tempQuat = new Quaternion_1.Quaternion();
	    return SkeletonDifferenceState;
	}(AnimationStateBase_1.AnimationStateBase));
	exports.SkeletonDifferenceState = SkeletonDifferenceState;


/***/ },
/* 485 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationNodeBase_1 = __webpack_require__(336);
	var SkeletonDirectionalState_1 = __webpack_require__(486);
	/**
	 * A skeleton animation node that uses four directional input poses with an input direction to blend a linearly interpolated output of a skeleton pose.
	 */
	var SkeletonDirectionalNode = (function (_super) {
	    __extends(SkeletonDirectionalNode, _super);
	    function SkeletonDirectionalNode() {
	        _super.call(this);
	        this._pStateClass = SkeletonDirectionalState_1.SkeletonDirectionalState;
	    }
	    /**
	     * @inheritDoc
	     */
	    SkeletonDirectionalNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    return SkeletonDirectionalNode;
	}(AnimationNodeBase_1.AnimationNodeBase));
	exports.SkeletonDirectionalNode = SkeletonDirectionalNode;


/***/ },
/* 486 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var JointPose_1 = __webpack_require__(328);
	var SkeletonPose_1 = __webpack_require__(330);
	var AnimationStateBase_1 = __webpack_require__(339);
	/**
	 *
	 */
	var SkeletonDirectionalState = (function (_super) {
	    __extends(SkeletonDirectionalState, _super);
	    function SkeletonDirectionalState(animator, skeletonAnimationNode) {
	        _super.call(this, animator, skeletonAnimationNode);
	        this._skeletonPose = new SkeletonPose_1.SkeletonPose();
	        this._skeletonPoseDirty = true;
	        this._blendWeight = 0;
	        this._direction = 0;
	        this._blendDirty = true;
	        this._skeletonAnimationNode = skeletonAnimationNode;
	        this._forward = animator.getAnimationState(this._skeletonAnimationNode.forward);
	        this._backward = animator.getAnimationState(this._skeletonAnimationNode.backward);
	        this._left = animator.getAnimationState(this._skeletonAnimationNode.left);
	        this._right = animator.getAnimationState(this._skeletonAnimationNode.right);
	    }
	    Object.defineProperty(SkeletonDirectionalState.prototype, "direction", {
	        get: function () {
	            return this._direction;
	        },
	        /**
	         * Defines the direction in degrees of the aniamtion between the forwards (0), right(90) backwards (180) and left(270) input nodes,
	         * used to produce the skeleton pose output.
	         */
	        set: function (value) {
	            if (this._direction == value)
	                return;
	            this._direction = value;
	            this._blendDirty = true;
	            this._skeletonPoseDirty = true;
	            this._pPositionDeltaDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    SkeletonDirectionalState.prototype.phase = function (value) {
	        if (this._blendDirty)
	            this.updateBlend();
	        this._skeletonPoseDirty = true;
	        this._pPositionDeltaDirty = true;
	        this._inputA.phase(value);
	        this._inputB.phase(value);
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonDirectionalState.prototype._pUdateTime = function (time) {
	        if (this._blendDirty)
	            this.updateBlend();
	        this._skeletonPoseDirty = true;
	        this._inputA.update(time);
	        this._inputB.update(time);
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
	     */
	    SkeletonDirectionalState.prototype.getSkeletonPose = function (skeleton) {
	        if (this._skeletonPoseDirty)
	            this.updateSkeletonPose(skeleton);
	        return this._skeletonPose;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonDirectionalState.prototype._pUpdatePositionDelta = function () {
	        this._pPositionDeltaDirty = false;
	        if (this._blendDirty)
	            this.updateBlend();
	        var deltA = this._inputA.positionDelta;
	        var deltB = this._inputB.positionDelta;
	        this.positionDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
	        this.positionDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
	        this.positionDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
	    };
	    /**
	     * Updates the output skeleton pose of the node based on the direction value between forward, backwards, left and right input nodes.
	     *
	     * @param skeleton The skeleton used by the animator requesting the ouput pose.
	     */
	    SkeletonDirectionalState.prototype.updateSkeletonPose = function (skeleton) {
	        this._skeletonPoseDirty = false;
	        if (this._blendDirty)
	            this.updateBlend();
	        var endPose;
	        var endPoses = this._skeletonPose.jointPoses;
	        var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
	        var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
	        var pose1, pose2;
	        var p1, p2;
	        var tr;
	        var numJoints = skeleton.numJoints;
	        // :s
	        if (endPoses.length != numJoints)
	            endPoses.length = numJoints;
	        for (var i = 0; i < numJoints; ++i) {
	            endPose = endPoses[i];
	            if (endPose == null)
	                endPose = endPoses[i] = new JointPose_1.JointPose();
	            pose1 = poses1[i];
	            pose2 = poses2[i];
	            p1 = pose1.translation;
	            p2 = pose2.translation;
	            endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);
	            tr = endPose.translation;
	            tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
	            tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
	            tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
	        }
	    };
	    /**
	     * Updates the blend value for the animation output based on the direction value between forward, backwards, left and right input nodes.
	     *
	     * @private
	     */
	    SkeletonDirectionalState.prototype.updateBlend = function () {
	        this._blendDirty = false;
	        if (this._direction < 0 || this._direction > 360) {
	            this._direction %= 360;
	            if (this._direction < 0)
	                this._direction += 360;
	        }
	        if (this._direction < 90) {
	            this._inputA = this._forward;
	            this._inputB = this._right;
	            this._blendWeight = this._direction / 90;
	        }
	        else if (this._direction < 180) {
	            this._inputA = this._right;
	            this._inputB = this._backward;
	            this._blendWeight = (this._direction - 90) / 90;
	        }
	        else if (this._direction < 270) {
	            this._inputA = this._backward;
	            this._inputB = this._left;
	            this._blendWeight = (this._direction - 180) / 90;
	        }
	        else {
	            this._inputA = this._left;
	            this._inputB = this._forward;
	            this._blendWeight = (this._direction - 270) / 90;
	        }
	    };
	    return SkeletonDirectionalState;
	}(AnimationStateBase_1.AnimationStateBase));
	exports.SkeletonDirectionalState = SkeletonDirectionalState;


/***/ },
/* 487 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimationNodeBase_1 = __webpack_require__(336);
	var SkeletonNaryLERPState_1 = __webpack_require__(488);
	/**
	 * A skeleton animation node that uses an n-dimensional array of animation node inputs to blend a lineraly interpolated output of a skeleton pose.
	 */
	var SkeletonNaryLERPNode = (function (_super) {
	    __extends(SkeletonNaryLERPNode, _super);
	    /**
	     * Creates a new <code>SkeletonNaryLERPNode</code> object.
	     */
	    function SkeletonNaryLERPNode() {
	        _super.call(this);
	        this._iInputs = new Array();
	        this._pStateClass = SkeletonNaryLERPState_1.SkeletonNaryLERPState;
	    }
	    Object.defineProperty(SkeletonNaryLERPNode.prototype, "numInputs", {
	        get: function () {
	            return this._numInputs;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Returns an integer representing the input index of the given skeleton animation node.
	     *
	     * @param input The skeleton animation node for with the input index is requested.
	     */
	    SkeletonNaryLERPNode.prototype.getInputIndex = function (input) {
	        return this._iInputs.indexOf(input);
	    };
	    /**
	     * Returns the skeleton animation node object that resides at the given input index.
	     *
	     * @param index The input index for which the skeleton animation node is requested.
	     */
	    SkeletonNaryLERPNode.prototype.getInputAt = function (index) {
	        return this._iInputs[index];
	    };
	    /**
	     * Adds a new skeleton animation node input to the animation node.
	     */
	    SkeletonNaryLERPNode.prototype.addInput = function (input) {
	        this._iInputs[this._numInputs++] = input;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonNaryLERPNode.prototype.getAnimationState = function (animator) {
	        return animator.getAnimationState(this);
	    };
	    return SkeletonNaryLERPNode;
	}(AnimationNodeBase_1.AnimationNodeBase));
	exports.SkeletonNaryLERPNode = SkeletonNaryLERPNode;
	Object.defineProperty(exports, "__esModule", { value: true });
	exports.default = SkeletonNaryLERPNode;


/***/ },
/* 488 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var JointPose_1 = __webpack_require__(328);
	var SkeletonPose_1 = __webpack_require__(330);
	var AnimationStateBase_1 = __webpack_require__(339);
	/**
	 *
	 */
	var SkeletonNaryLERPState = (function (_super) {
	    __extends(SkeletonNaryLERPState, _super);
	    function SkeletonNaryLERPState(animator, skeletonAnimationNode) {
	        _super.call(this, animator, skeletonAnimationNode);
	        this._skeletonPose = new SkeletonPose_1.SkeletonPose();
	        this._skeletonPoseDirty = true;
	        this._blendWeights = new Array();
	        this._inputs = new Array();
	        this._skeletonAnimationNode = skeletonAnimationNode;
	        var i = this._skeletonAnimationNode.numInputs;
	        while (i--)
	            this._inputs[i] = animator.getAnimationState(this._skeletonAnimationNode._iInputs[i]);
	    }
	    /**
	     * @inheritDoc
	     */
	    SkeletonNaryLERPState.prototype.phase = function (value) {
	        this._skeletonPoseDirty = true;
	        this._pPositionDeltaDirty = true;
	        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
	            if (this._blendWeights[j])
	                this._inputs[j].update(value);
	        }
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonNaryLERPState.prototype._pUdateTime = function (time) {
	        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
	            if (this._blendWeights[j])
	                this._inputs[j].update(time);
	        }
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    /**
	     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
	     */
	    SkeletonNaryLERPState.prototype.getSkeletonPose = function (skeleton) {
	        if (this._skeletonPoseDirty)
	            this.updateSkeletonPose(skeleton);
	        return this._skeletonPose;
	    };
	    /**
	     * Returns the blend weight of the skeleton aniamtion node that resides at the given input index.
	     *
	     * @param index The input index for which the skeleton animation node blend weight is requested.
	     */
	    SkeletonNaryLERPState.prototype.getBlendWeightAt = function (index) {
	        return this._blendWeights[index];
	    };
	    /**
	     * Sets the blend weight of the skeleton aniamtion node that resides at the given input index.
	     *
	     * @param index The input index on which the skeleton animation node blend weight is to be set.
	     * @param blendWeight The blend weight value to use for the given skeleton animation node index.
	     */
	    SkeletonNaryLERPState.prototype.setBlendWeightAt = function (index, blendWeight) {
	        this._blendWeights[index] = blendWeight;
	        this._pPositionDeltaDirty = true;
	        this._skeletonPoseDirty = true;
	    };
	    /**
	     * @inheritDoc
	     */
	    SkeletonNaryLERPState.prototype._pUpdatePositionDelta = function () {
	        this._pPositionDeltaDirty = false;
	        var delta;
	        var weight;
	        this.positionDelta.x = 0;
	        this.positionDelta.y = 0;
	        this.positionDelta.z = 0;
	        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
	            weight = this._blendWeights[j];
	            if (weight) {
	                delta = this._inputs[j].positionDelta;
	                this.positionDelta.x += weight * delta.x;
	                this.positionDelta.y += weight * delta.y;
	                this.positionDelta.z += weight * delta.z;
	            }
	        }
	    };
	    /**
	     * Updates the output skeleton pose of the node based on the blend weight values given to the input nodes.
	     *
	     * @param skeleton The skeleton used by the animator requesting the ouput pose.
	     */
	    SkeletonNaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
	        this._skeletonPoseDirty = false;
	        var weight;
	        var endPoses = this._skeletonPose.jointPoses;
	        var poses;
	        var endPose, pose;
	        var endTr, tr;
	        var endQuat, q;
	        var firstPose;
	        var i;
	        var w0, x0, y0, z0;
	        var w1, x1, y1, z1;
	        var numJoints = skeleton.numJoints;
	        // :s
	        if (endPoses.length != numJoints)
	            endPoses.length = numJoints;
	        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
	            weight = this._blendWeights[j];
	            if (!weight)
	                continue;
	            poses = this._inputs[j].getSkeletonPose(skeleton).jointPoses;
	            if (!firstPose) {
	                firstPose = poses;
	                for (i = 0; i < numJoints; ++i) {
	                    endPose = endPoses[i];
	                    if (endPose == null)
	                        endPose = endPoses[i] = new JointPose_1.JointPose();
	                    pose = poses[i];
	                    q = pose.orientation;
	                    tr = pose.translation;
	                    endQuat = endPose.orientation;
	                    endQuat.x = weight * q.x;
	                    endQuat.y = weight * q.y;
	                    endQuat.z = weight * q.z;
	                    endQuat.w = weight * q.w;
	                    endTr = endPose.translation;
	                    endTr.x = weight * tr.x;
	                    endTr.y = weight * tr.y;
	                    endTr.z = weight * tr.z;
	                }
	            }
	            else {
	                for (i = 0; i < skeleton.numJoints; ++i) {
	                    endPose = endPoses[i];
	                    pose = poses[i];
	                    q = firstPose[i].orientation;
	                    x0 = q.x;
	                    y0 = q.y;
	                    z0 = q.z;
	                    w0 = q.w;
	                    q = pose.orientation;
	                    tr = pose.translation;
	                    x1 = q.x;
	                    y1 = q.y;
	                    z1 = q.z;
	                    w1 = q.w;
	                    // find shortest direction
	                    if (x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1 < 0) {
	                        x1 = -x1;
	                        y1 = -y1;
	                        z1 = -z1;
	                        w1 = -w1;
	                    }
	                    endQuat = endPose.orientation;
	                    endQuat.x += weight * x1;
	                    endQuat.y += weight * y1;
	                    endQuat.z += weight * z1;
	                    endQuat.w += weight * w1;
	                    endTr = endPose.translation;
	                    endTr.x += weight * tr.x;
	                    endTr.y += weight * tr.y;
	                    endTr.z += weight * tr.z;
	                }
	            }
	        }
	        for (i = 0; i < skeleton.numJoints; ++i)
	            endPoses[i].orientation.normalize();
	    };
	    return SkeletonNaryLERPState;
	}(AnimationStateBase_1.AnimationStateBase));
	exports.SkeletonNaryLERPState = SkeletonNaryLERPState;


/***/ },
/* 489 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CrossfadeTransitionNode_1 = __webpack_require__(490);
	/**
	 *
	 */
	var CrossfadeTransition = (function () {
	    function CrossfadeTransition(blendSpeed) {
	        this.blendSpeed = 0.5;
	        this.blendSpeed = blendSpeed;
	    }
	    CrossfadeTransition.prototype.getAnimationNode = function (animator, startNode, endNode, startBlend) {
	        var crossFadeTransitionNode = new CrossfadeTransitionNode_1.CrossfadeTransitionNode();
	        crossFadeTransitionNode.inputA = startNode;
	        crossFadeTransitionNode.inputB = endNode;
	        crossFadeTransitionNode.blendSpeed = this.blendSpeed;
	        crossFadeTransitionNode.startBlend = startBlend;
	        return crossFadeTransitionNode;
	    };
	    return CrossfadeTransition;
	}());
	exports.CrossfadeTransition = CrossfadeTransition;


/***/ },
/* 490 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SkeletonBinaryLERPNode_1 = __webpack_require__(481);
	var CrossfadeTransitionState_1 = __webpack_require__(491);
	/**
	 * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
	 */
	var CrossfadeTransitionNode = (function (_super) {
	    __extends(CrossfadeTransitionNode, _super);
	    /**
	     * Creates a new <code>CrossfadeTransitionNode</code> object.
	     */
	    function CrossfadeTransitionNode() {
	        _super.call(this);
	        this._pStateClass = CrossfadeTransitionState_1.CrossfadeTransitionState;
	    }
	    return CrossfadeTransitionNode;
	}(SkeletonBinaryLERPNode_1.SkeletonBinaryLERPNode));
	exports.CrossfadeTransitionNode = CrossfadeTransitionNode;


/***/ },
/* 491 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var SkeletonBinaryLERPState_1 = __webpack_require__(482);
	var AnimationStateEvent_1 = __webpack_require__(331);
	/**
	 *
	 */
	var CrossfadeTransitionState = (function (_super) {
	    __extends(CrossfadeTransitionState, _super);
	    function CrossfadeTransitionState(animator, skeletonAnimationNode) {
	        _super.call(this, animator, skeletonAnimationNode);
	        this._crossfadeTransitionNode = skeletonAnimationNode;
	    }
	    /**
	     * @inheritDoc
	     */
	    CrossfadeTransitionState.prototype._pUpdateTime = function (time) {
	        this.blendWeight = Math.abs(time - this._crossfadeTransitionNode.startBlend) / (1000 * this._crossfadeTransitionNode.blendSpeed);
	        if (this.blendWeight >= 1) {
	            this.blendWeight = 1;
	            if (this._animationStateTransitionComplete == null)
	                this._animationStateTransitionComplete = new AnimationStateEvent_1.AnimationStateEvent(AnimationStateEvent_1.AnimationStateEvent.TRANSITION_COMPLETE, this._pAnimator, this, this._crossfadeTransitionNode);
	            this._crossfadeTransitionNode.dispatchEvent(this._animationStateTransitionComplete);
	        }
	        _super.prototype._pUpdateTime.call(this, time);
	    };
	    return CrossfadeTransitionState;
	}(SkeletonBinaryLERPState_1.SkeletonBinaryLERPState));
	exports.CrossfadeTransitionState = CrossfadeTransitionState;


/***/ },
/* 492 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var AnimatorBase_1 = __webpack_require__(323);
	var AnimationElements_1 = __webpack_require__(437);
	var ParticlePropertiesMode_1 = __webpack_require__(441);
	/**
	 * Provides an interface for assigning paricle-based animation data sets to sprite-based entity objects
	 * and controlling the various available states of animation through an interative playhead that can be
	 * automatically updated or manually triggered.
	 *
	 * Requires that the containing geometry of the parent sprite is particle geometry
	 *
	 * @see away.base.ParticleGraphics
	 */
	var ParticleAnimator = (function (_super) {
	    __extends(ParticleAnimator, _super);
	    /**
	     * Creates a new <code>ParticleAnimator</code> object.
	     *
	     * @param particleAnimationSet The animation data set containing the particle animations used by the animator.
	     */
	    function ParticleAnimator(particleAnimationSet) {
	        _super.call(this, particleAnimationSet);
	        this._animationParticleStates = new Array();
	        this._animatorParticleStates = new Array();
	        this._timeParticleStates = new Array();
	        this._totalLenOfOneVertex = 0;
	        this._animatorSubGeometries = new Object();
	        this._particleAnimationSet = particleAnimationSet;
	        var state;
	        var node;
	        for (var i = 0; i < this._particleAnimationSet.particleNodes.length; i++) {
	            node = this._particleAnimationSet.particleNodes[i];
	            state = this.getAnimationState(node);
	            if (node.mode == ParticlePropertiesMode_1.ParticlePropertiesMode.LOCAL_DYNAMIC) {
	                this._animatorParticleStates.push(state);
	                node._iDataOffset = this._totalLenOfOneVertex;
	                this._totalLenOfOneVertex += node.dataLength;
	            }
	            else {
	                this._animationParticleStates.push(state);
	            }
	            if (state.needUpdateTime)
	                this._timeParticleStates.push(state);
	        }
	    }
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimator.prototype.clone = function () {
	        return new ParticleAnimator(this._particleAnimationSet);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimator.prototype.setRenderState = function (shader, renderable, stage, camera) {
	        var animationRegisterData = this._particleAnimationSet._iAnimationRegisterData;
	        var graphic = renderable.graphic;
	        if (!graphic)
	            throw (new Error("Must be graphic"));
	        //process animation sub geometries
	        var animationElements = this._particleAnimationSet.getAnimationElements(graphic);
	        var i;
	        for (i = 0; i < this._animationParticleStates.length; i++)
	            this._animationParticleStates[i].setRenderState(shader, renderable, animationElements, animationRegisterData, camera, stage);
	        //process animator subgeometries
	        var animatorElements = this.getAnimatorElements(graphic);
	        for (i = 0; i < this._animatorParticleStates.length; i++)
	            this._animatorParticleStates[i].setRenderState(shader, renderable, animatorElements, animationRegisterData, camera, stage);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimator.prototype.testGPUCompatibility = function (shader) {
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimator.prototype.start = function () {
	        _super.prototype.start.call(this);
	        for (var i = 0; i < this._timeParticleStates.length; i++)
	            this._timeParticleStates[i].offset(this._pAbsoluteTime);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimator.prototype._pUpdateDeltaTime = function (dt) {
	        this._pAbsoluteTime += dt;
	        for (var i = 0; i < this._timeParticleStates.length; i++)
	            this._timeParticleStates[i].update(this._pAbsoluteTime);
	    };
	    /**
	     * @inheritDoc
	     */
	    ParticleAnimator.prototype.resetTime = function (offset) {
	        if (offset === void 0) { offset = 0; }
	        for (var i = 0; i < this._timeParticleStates.length; i++)
	            this._timeParticleStates[i].offset(this._pAbsoluteTime + offset);
	        this.update(this.time);
	    };
	    ParticleAnimator.prototype.dispose = function () {
	        for (var key in this._animatorSubGeometries)
	            this._animatorSubGeometries[key].dispose();
	    };
	    ParticleAnimator.prototype.getAnimatorElements = function (graphic) {
	        if (!this._animatorParticleStates.length)
	            return;
	        var elements = graphic.elements;
	        var animatorElements = this._animatorSubGeometries[elements.id] = new AnimationElements_1.AnimationElements();
	        //create the vertexData vector that will be used for local state data
	        animatorElements.createVertexData(elements.numVertices, this._totalLenOfOneVertex);
	        //pass the particles data to the animator elements
	        animatorElements.animationParticles = this._particleAnimationSet.getAnimationElements(graphic).animationParticles;
	    };
	    return ParticleAnimator;
	}(AnimatorBase_1.AnimatorBase));
	exports.ParticleAnimator = ParticleAnimator;


/***/ },
/* 493 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(494));


/***/ },
/* 494 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AxisAlignedBoundingBox_1 = __webpack_require__(379);
	exports.AxisAlignedBoundingBox = AxisAlignedBoundingBox_1.AxisAlignedBoundingBox;
	var BoundingSphere_1 = __webpack_require__(380);
	exports.BoundingSphere = BoundingSphere_1.BoundingSphere;
	var BoundingVolumeBase_1 = __webpack_require__(374);
	exports.BoundingVolumeBase = BoundingVolumeBase_1.BoundingVolumeBase;
	var BoundsType_1 = __webpack_require__(115);
	exports.BoundsType = BoundsType_1.BoundsType;
	var NullBounds_1 = __webpack_require__(373);
	exports.NullBounds = NullBounds_1.NullBounds;


/***/ },
/* 495 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(496));


/***/ },
/* 496 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ControllerBase_1 = __webpack_require__(497);
	exports.ControllerBase = ControllerBase_1.ControllerBase;
	var FirstPersonController_1 = __webpack_require__(498);
	exports.FirstPersonController = FirstPersonController_1.FirstPersonController;
	var FollowController_1 = __webpack_require__(499);
	exports.FollowController = FollowController_1.FollowController;
	var HoverController_1 = __webpack_require__(500);
	exports.HoverController = HoverController_1.HoverController;
	var LookAtController_1 = __webpack_require__(501);
	exports.LookAtController = LookAtController_1.LookAtController;
	var SpringController_1 = __webpack_require__(502);
	exports.SpringController = SpringController_1.SpringController;


/***/ },
/* 497 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(7);
	var ControllerBase = (function () {
	    function ControllerBase(targetObject) {
	        if (targetObject === void 0) { targetObject = null; }
	        this._pAutoUpdate = true;
	        this.targetObject = targetObject;
	    }
	    ControllerBase.prototype.pNotifyUpdate = function () {
	        if (this._pTargetObject)
	            this._pTargetObject.invalidatePartitionBounds();
	    };
	    Object.defineProperty(ControllerBase.prototype, "targetObject", {
	        get: function () {
	            return this._pTargetObject;
	        },
	        set: function (val) {
	            if (this._pTargetObject == val)
	                return;
	            if (this._pTargetObject && this._pAutoUpdate)
	                this._pTargetObject._iController = null;
	            this._pTargetObject = val;
	            if (this._pTargetObject && this._pAutoUpdate)
	                this._pTargetObject._iController = this;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ControllerBase.prototype, "autoUpdate", {
	        get: function () {
	            return this._pAutoUpdate;
	        },
	        set: function (val) {
	            if (this._pAutoUpdate == val)
	                return;
	            this._pAutoUpdate = val;
	            if (this._pTargetObject) {
	                if (this._pAutoUpdate)
	                    this._pTargetObject._iController = this;
	                else
	                    this._pTargetObject._iController = null;
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ControllerBase.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    ControllerBase.prototype.updateController = function () {
	        if (this._pControllerDirty && this._pAutoUpdate) {
	            this._pControllerDirty = false;
	            this.pNotifyUpdate();
	        }
	    };
	    return ControllerBase;
	}());
	exports.ControllerBase = ControllerBase;


/***/ },
/* 498 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MathConsts_1 = __webpack_require__(35);
	var ControllerBase_1 = __webpack_require__(497);
	/**
	 * Extended camera used to hover round a specified target object.
	 *
	 * @see    away3d.containers.View3D
	 */
	var FirstPersonController = (function (_super) {
	    __extends(FirstPersonController, _super);
	    /**
	     * Creates a new <code>HoverController</code> object.
	     */
	    function FirstPersonController(targetObject, panAngle, tiltAngle, minTiltAngle, maxTiltAngle, steps, wrapPanAngle) {
	        if (targetObject === void 0) { targetObject = null; }
	        if (panAngle === void 0) { panAngle = 0; }
	        if (tiltAngle === void 0) { tiltAngle = 90; }
	        if (minTiltAngle === void 0) { minTiltAngle = -90; }
	        if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
	        if (steps === void 0) { steps = 8; }
	        if (wrapPanAngle === void 0) { wrapPanAngle = false; }
	        _super.call(this, targetObject);
	        this._iCurrentPanAngle = 0;
	        this._iCurrentTiltAngle = 90;
	        this._panAngle = 0;
	        this._tiltAngle = 90;
	        this._minTiltAngle = -90;
	        this._maxTiltAngle = 90;
	        this._steps = 8;
	        this._walkIncrement = 0;
	        this._strafeIncrement = 0;
	        this._wrapPanAngle = false;
	        this.fly = false;
	        this.panAngle = panAngle;
	        this.tiltAngle = tiltAngle;
	        this.minTiltAngle = minTiltAngle;
	        this.maxTiltAngle = maxTiltAngle;
	        this.steps = steps;
	        this.wrapPanAngle = wrapPanAngle;
	        //values passed in contrustor are applied immediately
	        this._iCurrentPanAngle = this._panAngle;
	        this._iCurrentTiltAngle = this._tiltAngle;
	    }
	    Object.defineProperty(FirstPersonController.prototype, "steps", {
	        /**
	         * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
	         *
	         * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
	         *
	         * @see    #tiltAngle
	         * @see    #panAngle
	         */
	        get: function () {
	            return this._steps;
	        },
	        set: function (val) {
	            val = (val < 1) ? 1 : val;
	            if (this._steps == val)
	                return;
	            this._steps = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FirstPersonController.prototype, "panAngle", {
	        /**
	         * Rotation of the camera in degrees around the y axis. Defaults to 0.
	         */
	        get: function () {
	            return this._panAngle;
	        },
	        set: function (val) {
	            if (this._panAngle == val)
	                return;
	            this._panAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FirstPersonController.prototype, "tiltAngle", {
	        /**
	         * Elevation angle of the camera in degrees. Defaults to 90.
	         */
	        get: function () {
	            return this._tiltAngle;
	        },
	        set: function (val) {
	            val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
	            if (this._tiltAngle == val)
	                return;
	            this._tiltAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FirstPersonController.prototype, "minTiltAngle", {
	        /**
	         * Minimum bounds for the <code>tiltAngle</code>. Defaults to -90.
	         *
	         * @see    #tiltAngle
	         */
	        get: function () {
	            return this._minTiltAngle;
	        },
	        set: function (val) {
	            if (this._minTiltAngle == val)
	                return;
	            this._minTiltAngle = val;
	            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FirstPersonController.prototype, "maxTiltAngle", {
	        /**
	         * Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
	         *
	         * @see    #tiltAngle
	         */
	        get: function () {
	            return this._maxTiltAngle;
	        },
	        set: function (val) {
	            if (this._maxTiltAngle == val)
	                return;
	            this._maxTiltAngle = val;
	            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FirstPersonController.prototype, "wrapPanAngle", {
	        /**
	         * Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
	         */
	        get: function () {
	            return this._wrapPanAngle;
	        },
	        set: function (val) {
	            if (this._wrapPanAngle == val)
	                return;
	            this._wrapPanAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Updates the current tilt angle and pan angle values.
	     *
	     * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.
	     *
	     * @param interpolate   If the update to a target pan- or tiltAngle is interpolated. Default is true.
	     *
	     * @see    #tiltAngle
	     * @see    #panAngle
	     * @see    #steps
	     */
	    FirstPersonController.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        if (this._tiltAngle != this._iCurrentTiltAngle || this._panAngle != this._iCurrentPanAngle) {
	            this._pControllerDirty = true;
	            if (this._wrapPanAngle) {
	                if (this._panAngle < 0) {
	                    this._iCurrentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
	                    this._panAngle = this._panAngle % 360 + 360;
	                }
	                else {
	                    this._iCurrentPanAngle += this._panAngle % 360 - this._panAngle;
	                    this._panAngle = this._panAngle % 360;
	                }
	                while (this._panAngle - this._iCurrentPanAngle < -180)
	                    this._iCurrentPanAngle -= 360;
	                while (this._panAngle - this._iCurrentPanAngle > 180)
	                    this._iCurrentPanAngle += 360;
	            }
	            if (interpolate) {
	                this._iCurrentTiltAngle += (this._tiltAngle - this._iCurrentTiltAngle) / (this.steps + 1);
	                this._iCurrentPanAngle += (this._panAngle - this._iCurrentPanAngle) / (this.steps + 1);
	            }
	            else {
	                this._iCurrentTiltAngle = this._tiltAngle;
	                this._iCurrentPanAngle = this._panAngle;
	            }
	            //snap coords if angle differences are close
	            if ((Math.abs(this.tiltAngle - this._iCurrentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._iCurrentPanAngle) < 0.01)) {
	                this._iCurrentTiltAngle = this._tiltAngle;
	                this._iCurrentPanAngle = this._panAngle;
	            }
	        }
	        this.targetObject.rotationX = this._iCurrentTiltAngle;
	        this.targetObject.rotationY = this._iCurrentPanAngle;
	        if (this._walkIncrement) {
	            if (this.fly) {
	                this.targetObject.transform.moveForward(this._walkIncrement);
	            }
	            else {
	                this.targetObject.x += this._walkIncrement * Math.sin(this._panAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	                this.targetObject.z += this._walkIncrement * Math.cos(this._panAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	            }
	            this._walkIncrement = 0;
	        }
	        if (this._strafeIncrement) {
	            this.targetObject.transform.moveRight(this._strafeIncrement);
	            this._strafeIncrement = 0;
	        }
	    };
	    FirstPersonController.prototype.incrementWalk = function (val) {
	        if (val == 0)
	            return;
	        this._walkIncrement += val;
	        this.pNotifyUpdate();
	    };
	    FirstPersonController.prototype.incrementStrafe = function (val) {
	        if (val == 0)
	            return;
	        this._strafeIncrement += val;
	        this.pNotifyUpdate();
	    };
	    return FirstPersonController;
	}(ControllerBase_1.ControllerBase));
	exports.FirstPersonController = FirstPersonController;


/***/ },
/* 499 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var HoverController_1 = __webpack_require__(500);
	/**
	 * Controller used to follow behind an object on the XZ plane, with an optional
	 * elevation (tiltAngle).
	 *
	 * @see    away3d.containers.View3D
	 */
	var FollowController = (function (_super) {
	    __extends(FollowController, _super);
	    function FollowController(targetObject, lookAtObject, tiltAngle, distance) {
	        if (targetObject === void 0) { targetObject = null; }
	        if (lookAtObject === void 0) { lookAtObject = null; }
	        if (tiltAngle === void 0) { tiltAngle = 45; }
	        if (distance === void 0) { distance = 700; }
	        _super.call(this, targetObject, lookAtObject, 0, tiltAngle, distance);
	    }
	    FollowController.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        if (!this.lookAtObject)
	            return;
	        this.panAngle = this._pLookAtObject.rotationY - 180;
	        _super.prototype.update.call(this);
	    };
	    return FollowController;
	}(HoverController_1.HoverController));
	exports.FollowController = FollowController;


/***/ },
/* 500 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var MathConsts_1 = __webpack_require__(35);
	var Vector3D_1 = __webpack_require__(34);
	var LookAtController_1 = __webpack_require__(501);
	/**
	 * Extended camera used to hover round a specified target object.
	 *
	 * @see    away.containers.View
	 */
	var HoverController = (function (_super) {
	    __extends(HoverController, _super);
	    /**
	     * Creates a new <code>HoverController</code> object.
	     */
	    function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
	        if (targetObject === void 0) { targetObject = null; }
	        if (lookAtObject === void 0) { lookAtObject = null; }
	        if (panAngle === void 0) { panAngle = 0; }
	        if (tiltAngle === void 0) { tiltAngle = 90; }
	        if (distance === void 0) { distance = 1000; }
	        if (minTiltAngle === void 0) { minTiltAngle = -90; }
	        if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
	        if (minPanAngle === void 0) { minPanAngle = null; }
	        if (maxPanAngle === void 0) { maxPanAngle = null; }
	        if (steps === void 0) { steps = 8; }
	        if (yFactor === void 0) { yFactor = 2; }
	        if (wrapPanAngle === void 0) { wrapPanAngle = false; }
	        _super.call(this, targetObject, lookAtObject);
	        this._iCurrentPanAngle = 0;
	        this._iCurrentTiltAngle = 90;
	        this._panAngle = 0;
	        this._tiltAngle = 90;
	        this._distance = 1000;
	        this._minPanAngle = -Infinity;
	        this._maxPanAngle = Infinity;
	        this._minTiltAngle = -90;
	        this._maxTiltAngle = 90;
	        this._steps = 8;
	        this._yFactor = 2;
	        this._wrapPanAngle = false;
	        this._upAxis = new Vector3D_1.Vector3D();
	        this.distance = distance;
	        this.panAngle = panAngle;
	        this.tiltAngle = tiltAngle;
	        this.minPanAngle = (minPanAngle != null) ? minPanAngle : -Infinity;
	        this.maxPanAngle = (maxPanAngle != null) ? maxPanAngle : Infinity;
	        this.minTiltAngle = minTiltAngle;
	        this.maxTiltAngle = maxTiltAngle;
	        this.steps = steps;
	        this.yFactor = yFactor;
	        this.wrapPanAngle = wrapPanAngle;
	        //values passed in contrustor are applied immediately
	        this._iCurrentPanAngle = this._panAngle;
	        this._iCurrentTiltAngle = this._tiltAngle;
	    }
	    Object.defineProperty(HoverController.prototype, "steps", {
	        /**
	         * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
	         *
	         * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
	         *
	         * @see    #tiltAngle
	         * @see    #panAngle
	         */
	        get: function () {
	            return this._steps;
	        },
	        set: function (val) {
	            val = (val < 1) ? 1 : val;
	            if (this._steps == val)
	                return;
	            this._steps = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "panAngle", {
	        /**
	         * Rotation of the camera in degrees around the y axis. Defaults to 0.
	         */
	        get: function () {
	            return this._panAngle;
	        },
	        set: function (val) {
	            val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
	            if (this._panAngle == val)
	                return;
	            this._panAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "tiltAngle", {
	        /**
	         * Elevation angle of the camera in degrees. Defaults to 90.
	         */
	        get: function () {
	            return this._tiltAngle;
	        },
	        set: function (val) {
	            val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
	            if (this._tiltAngle == val)
	                return;
	            this._tiltAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "distance", {
	        /**
	         * Distance between the camera and the specified target. Defaults to 1000.
	         */
	        get: function () {
	            return this._distance;
	        },
	        set: function (val) {
	            if (this._distance == val)
	                return;
	            this._distance = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "minPanAngle", {
	        /**
	         * Minimum bounds for the <code>panAngle</code>. Defaults to -Infinity.
	         *
	         * @see    #panAngle
	         */
	        get: function () {
	            return this._minPanAngle;
	        },
	        set: function (val) {
	            if (this._minPanAngle == val)
	                return;
	            this._minPanAngle = val;
	            this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "maxPanAngle", {
	        /**
	         * Maximum bounds for the <code>panAngle</code>. Defaults to Infinity.
	         *
	         * @see    #panAngle
	         */
	        get: function () {
	            return this._maxPanAngle;
	        },
	        set: function (val) {
	            if (this._maxPanAngle == val)
	                return;
	            this._maxPanAngle = val;
	            this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "minTiltAngle", {
	        /**
	         * Minimum bounds for the <code>tiltAngle</code>. Defaults to -90.
	         *
	         * @see    #tiltAngle
	         */
	        get: function () {
	            return this._minTiltAngle;
	        },
	        set: function (val) {
	            if (this._minTiltAngle == val)
	                return;
	            this._minTiltAngle = val;
	            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
	        /**
	         * Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
	         *
	         * @see    #tiltAngle
	         */
	        get: function () {
	            return this._maxTiltAngle;
	        },
	        set: function (val) {
	            if (this._maxTiltAngle == val)
	                return;
	            this._maxTiltAngle = val;
	            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "yFactor", {
	        /**
	         * Fractional difference in distance between the horizontal camera orientation and vertical camera orientation. Defaults to 2.
	         *
	         * @see    #distance
	         */
	        get: function () {
	            return this._yFactor;
	        },
	        set: function (val) {
	            if (this._yFactor == val)
	                return;
	            this._yFactor = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
	        /**
	         * Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
	         */
	        get: function () {
	            return this._wrapPanAngle;
	        },
	        set: function (val) {
	            if (this._wrapPanAngle == val)
	                return;
	            this._wrapPanAngle = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Updates the current tilt angle and pan angle values.
	     *
	     * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.
	     *
	     * @param interpolate   If the update to a target pan- or tiltAngle is interpolated. Default is true.
	     *
	     * @see    #tiltAngle
	     * @see    #panAngle
	     * @see    #steps
	     */
	    HoverController.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        if (this._tiltAngle != this._iCurrentTiltAngle || this._panAngle != this._iCurrentPanAngle) {
	            this._pControllerDirty = true;
	            if (this._wrapPanAngle) {
	                if (this._panAngle < 0) {
	                    this._iCurrentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
	                    this._panAngle = this._panAngle % 360 + 360;
	                }
	                else {
	                    this._iCurrentPanAngle += this._panAngle % 360 - this._panAngle;
	                    this._panAngle = this._panAngle % 360;
	                }
	                while (this._panAngle - this._iCurrentPanAngle < -180)
	                    this._iCurrentPanAngle -= 360;
	                while (this._panAngle - this._iCurrentPanAngle > 180)
	                    this._iCurrentPanAngle += 360;
	            }
	            if (interpolate) {
	                this._iCurrentTiltAngle += (this._tiltAngle - this._iCurrentTiltAngle) / (this.steps + 1);
	                this._iCurrentPanAngle += (this._panAngle - this._iCurrentPanAngle) / (this.steps + 1);
	            }
	            else {
	                this._iCurrentPanAngle = this._panAngle;
	                this._iCurrentTiltAngle = this._tiltAngle;
	            }
	            //snap coords if angle differences are close
	            if ((Math.abs(this.tiltAngle - this._iCurrentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._iCurrentPanAngle) < 0.01)) {
	                this._iCurrentTiltAngle = this._tiltAngle;
	                this._iCurrentPanAngle = this._panAngle;
	            }
	        }
	        var pos = (this.lookAtObject) ? this.lookAtObject.transform.position : (this.lookAtPosition) ? this.lookAtPosition : this._pOrigin;
	        this.targetObject.x = pos.x + this.distance * Math.sin(this._iCurrentPanAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	        this.targetObject.y = pos.y + this.distance * Math.sin(this._iCurrentTiltAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS) * this.yFactor;
	        this.targetObject.z = pos.z + this.distance * Math.cos(this._iCurrentPanAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	        this._upAxis.x = -Math.sin(this._iCurrentPanAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS) * Math.sin(this._iCurrentTiltAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	        this._upAxis.y = Math.cos(this._iCurrentTiltAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	        this._upAxis.z = -Math.cos(this._iCurrentPanAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS) * Math.sin(this._iCurrentTiltAngle * MathConsts_1.MathConsts.DEGREES_TO_RADIANS);
	        if (this._pTargetObject) {
	            if (this._pLookAtPosition)
	                this._pTargetObject.lookAt(this._pLookAtPosition, this._upAxis);
	            else if (this._pLookAtObject)
	                this._pTargetObject.lookAt(this._pLookAtObject.scene ? this._pLookAtObject.scenePosition : this._pLookAtObject.transform.position, this._upAxis);
	        }
	    };
	    return HoverController;
	}(LookAtController_1.LookAtController));
	exports.HoverController = HoverController;


/***/ },
/* 501 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ControllerBase_1 = __webpack_require__(497);
	var DisplayObjectEvent_1 = __webpack_require__(117);
	var LookAtController = (function (_super) {
	    __extends(LookAtController, _super);
	    function LookAtController(targetObject, lookAtObject) {
	        var _this = this;
	        if (targetObject === void 0) { targetObject = null; }
	        if (lookAtObject === void 0) { lookAtObject = null; }
	        _super.call(this, targetObject);
	        this._pOrigin = new Vector3D_1.Vector3D(0.0, 0.0, 0.0);
	        this._onLookAtObjectChangedDelegate = function (event) { return _this.onLookAtObjectChanged(event); };
	        if (lookAtObject)
	            this.lookAtObject = lookAtObject;
	        else
	            this.lookAtPosition = new Vector3D_1.Vector3D();
	    }
	    Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
	        get: function () {
	            return this._pLookAtPosition;
	        },
	        set: function (val) {
	            if (this._pLookAtObject) {
	                this._pLookAtObject.removeEventListener(DisplayObjectEvent_1.DisplayObjectEvent.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
	                this._pLookAtObject = null;
	            }
	            this._pLookAtPosition = val;
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(LookAtController.prototype, "lookAtObject", {
	        get: function () {
	            return this._pLookAtObject;
	        },
	        set: function (val) {
	            if (this._pLookAtPosition)
	                this._pLookAtPosition = null;
	            if (this._pLookAtObject == val)
	                return;
	            if (this._pLookAtObject)
	                this._pLookAtObject.removeEventListener(DisplayObjectEvent_1.DisplayObjectEvent.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
	            this._pLookAtObject = val;
	            if (this._pLookAtObject)
	                this._pLookAtObject.addEventListener(DisplayObjectEvent_1.DisplayObjectEvent.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
	            this.pNotifyUpdate();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    //@override
	    LookAtController.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        if (this._pTargetObject) {
	            if (this._pLookAtPosition)
	                this._pTargetObject.lookAt(this._pLookAtPosition);
	            else if (this._pLookAtObject)
	                this._pTargetObject.lookAt(this._pLookAtObject.scene ? this._pLookAtObject.scenePosition : this._pLookAtObject.transform.position);
	        }
	    };
	    LookAtController.prototype.onLookAtObjectChanged = function (event) {
	        this.pNotifyUpdate();
	    };
	    return LookAtController;
	}(ControllerBase_1.ControllerBase));
	exports.LookAtController = LookAtController;


/***/ },
/* 502 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var LookAtController_1 = __webpack_require__(501);
	/**
	 * Uses spring physics to animate the target object towards a position that is
	 * defined as the lookAtTarget object's position plus the vector defined by the
	 * positionOffset property.
	 */
	var SpringController = (function (_super) {
	    __extends(SpringController, _super);
	    function SpringController(targetObject, lookAtObject, stiffness, mass, damping) {
	        if (targetObject === void 0) { targetObject = null; }
	        if (lookAtObject === void 0) { lookAtObject = null; }
	        if (stiffness === void 0) { stiffness = 1; }
	        if (mass === void 0) { mass = 40; }
	        if (damping === void 0) { damping = 4; }
	        _super.call(this, targetObject, lookAtObject);
	        /**
	         * Offset of spring center from target in target object space, ie: Where the camera should ideally be in the target object space.
	         */
	        this.positionOffset = new Vector3D_1.Vector3D(0, 500, -1000);
	        this.stiffness = stiffness;
	        this.damping = damping;
	        this.mass = mass;
	        this._velocity = new Vector3D_1.Vector3D();
	        this._dv = new Vector3D_1.Vector3D();
	        this._stretch = new Vector3D_1.Vector3D();
	        this._force = new Vector3D_1.Vector3D();
	        this._acceleration = new Vector3D_1.Vector3D();
	        this._desiredPosition = new Vector3D_1.Vector3D();
	    }
	    SpringController.prototype.update = function (interpolate) {
	        if (interpolate === void 0) { interpolate = true; }
	        var offs;
	        if (!this._pLookAtObject || !this._pTargetObject)
	            return;
	        this._pControllerDirty = true;
	        offs = this._pLookAtObject.transform.matrix3D.deltaTransformVector(this.positionOffset);
	        this._desiredPosition.x = this._pLookAtObject.x + offs.x;
	        this._desiredPosition.y = this._pLookAtObject.y + offs.y;
	        this._desiredPosition.z = this._pLookAtObject.z + offs.z;
	        this._stretch = this._pTargetObject.transform.position.add(this._desiredPosition);
	        this._stretch.scaleBy(-this.stiffness);
	        this._dv.copyFrom(this._velocity);
	        this._dv.scaleBy(this.damping);
	        this._force.x = this._stretch.x - this._dv.x;
	        this._force.y = this._stretch.y - this._dv.y;
	        this._force.z = this._stretch.z - this._dv.z;
	        this._acceleration.copyFrom(this._force);
	        this._acceleration.scaleBy(1 / this.mass);
	        this._velocity.incrementBy(this._acceleration);
	        var position = this._pTargetObject.transform.position.add(this._velocity);
	        this._pTargetObject.transform.moveTo(position.x, position.y, position.z);
	        _super.prototype.update.call(this);
	    };
	    return SpringController;
	}(LookAtController_1.LookAtController));
	exports.SpringController = SpringController;


/***/ },
/* 503 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(504));


/***/ },
/* 504 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CapsStyle_1 = __webpack_require__(186);
	exports.CapsStyle = CapsStyle_1.CapsStyle;
	var GradientType_1 = __webpack_require__(505);
	exports.GradientType = GradientType_1.GradientType;
	var GraphicsFactoryFills_1 = __webpack_require__(187);
	exports.GraphicsFactoryFills = GraphicsFactoryFills_1.GraphicsFactoryFills;
	var GraphicsFactoryHelper_1 = __webpack_require__(188);
	exports.GraphicsFactoryHelper = GraphicsFactoryHelper_1.GraphicsFactoryHelper;
	var GraphicsFactoryStrokes_1 = __webpack_require__(189);
	exports.GraphicsFactoryStrokes = GraphicsFactoryStrokes_1.GraphicsFactoryStrokes;
	var GraphicsFillStyle_1 = __webpack_require__(183);
	exports.GraphicsFillStyle = GraphicsFillStyle_1.GraphicsFillStyle;
	var GraphicsStrokeStyle_1 = __webpack_require__(184);
	exports.GraphicsStrokeStyle = GraphicsStrokeStyle_1.GraphicsStrokeStyle;
	var GraphicsPath_1 = __webpack_require__(180);
	exports.GraphicsPath = GraphicsPath_1.GraphicsPath;
	var GraphicsPathCommand_1 = __webpack_require__(182);
	exports.GraphicsPathCommand = GraphicsPathCommand_1.GraphicsPathCommand;
	var GraphicsPathWinding_1 = __webpack_require__(181);
	exports.GraphicsPathWinding = GraphicsPathWinding_1.GraphicsPathWinding;
	var InterpolationMethod_1 = __webpack_require__(506);
	exports.InterpolationMethod = InterpolationMethod_1.InterpolationMethod;
	var JointStyle_1 = __webpack_require__(185);
	exports.JointStyle = JointStyle_1.JointStyle;
	var LineScaleMode_1 = __webpack_require__(507);
	exports.LineScaleMode = LineScaleMode_1.LineScaleMode;
	var PixelSnapping_1 = __webpack_require__(508);
	exports.PixelSnapping = PixelSnapping_1.PixelSnapping;
	var SpreadMethod_1 = __webpack_require__(509);
	exports.SpreadMethod = SpreadMethod_1.SpreadMethod;
	var TriangleCulling_1 = __webpack_require__(510);
	exports.TriangleCulling = TriangleCulling_1.TriangleCulling;


/***/ },
/* 505 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The GradientType class provides values for the <code>type</code> parameter
	 * in the <code>beginGradientFill()</code> and
	 * <code>lineGradientStyle()</code> methods of the flash.display.Graphics
	 * class.
	 */
	var GradientType = (function () {
	    function GradientType() {
	    }
	    /**
	     * Value used to specify a linear gradient fill.
	     */
	    GradientType.LINEAR = "linear";
	    /**
	     * Value used to specify a radial gradient fill.
	     */
	    GradientType.RADIAL = "radial";
	    return GradientType;
	}());
	exports.GradientType = GradientType;


/***/ },
/* 506 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The InterpolationMethod class provides values for the
	 * <code>interpolationMethod</code> parameter in the
	 * <code>Graphics.beginGradientFill()</code> and
	 * <code>Graphics.lineGradientStyle()</code> methods. This parameter
	 * determines the RGB space to use when rendering the gradient.
	 */
	var InterpolationMethod = (function () {
	    function InterpolationMethod() {
	    }
	    /**
	     * Specifies that the RGB interpolation method should be used. This means
	     * that the gradient is rendered with exponential sRGB(standard RGB) space.
	     * The sRGB space is a W3C-endorsed standard that defines a non-linear
	     * conversion between red, green, and blue component values and the actual
	     * intensity of the visible component color.
	     *
	     * <p>For example, consider a simple linear gradient between two colors(with
	     * the <code>spreadMethod</code> parameter set to
	     * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
	     * affect the appearance as follows: </p>
	     */
	    InterpolationMethod.LINEAR_RGB = "linearRGB";
	    /**
	     * Specifies that the RGB interpolation method should be used. This means
	     * that the gradient is rendered with exponential sRGB(standard RGB) space.
	     * The sRGB space is a W3C-endorsed standard that defines a non-linear
	     * conversion between red, green, and blue component values and the actual
	     * intensity of the visible component color.
	     *
	     * <p>For example, consider a simple linear gradient between two colors(with
	     * the <code>spreadMethod</code> parameter set to
	     * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
	     * affect the appearance as follows: </p>
	     */
	    InterpolationMethod.RGB = "rgb";
	    return InterpolationMethod;
	}());
	exports.InterpolationMethod = InterpolationMethod;


/***/ },
/* 507 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The LineScaleMode class provides values for the <code>scaleMode</code>
	 * parameter in the <code>Graphics.lineStyle()</code> method.
	 */
	var LineScaleMode = (function () {
	    function LineScaleMode() {
	    }
	    /**
	     * With this setting used as the <code>scaleMode</code> parameter of the
	     * <code>lineStyle()</code> method, the thickness of the line scales
	     * <i>only</i> vertically. For example, consider the following circles, drawn
	     * with a one-pixel line, and each with the <code>scaleMode</code> parameter
	     * set to <code>LineScaleMode.VERTICAL</code>. The circle on the left is
	     * scaled only vertically, and the circle on the right is scaled both
	     * vertically and horizontally.
	     */
	    LineScaleMode.HORIZONTAL = "horizontal";
	    /**
	     * With this setting used as the <code>scaleMode</code> parameter of the
	     * <code>lineStyle()</code> method, the thickness of the line never scales.
	     */
	    LineScaleMode.NONE = "none";
	    /**
	     * With this setting used as the <code>scaleMode</code> parameter of the
	     * <code>lineStyle()</code> method, the thickness of the line always scales
	     * when the object is scaled(the default).
	     */
	    LineScaleMode.NORMAL = "normal";
	    /**
	     * With this setting used as the <code>scaleMode</code> parameter of the
	     * <code>lineStyle()</code> method, the thickness of the line scales
	     * <i>only</i> horizontally. For example, consider the following circles,
	     * drawn with a one-pixel line, and each with the <code>scaleMode</code>
	     * parameter set to <code>LineScaleMode.HORIZONTAL</code>. The circle on the
	     * left is scaled only horizontally, and the circle on the right is scaled
	     * both vertically and horizontally.
	     */
	    LineScaleMode.VERTICAL = "vertical";
	    return LineScaleMode;
	}());
	exports.LineScaleMode = LineScaleMode;


/***/ },
/* 508 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The PixelSnapping class is an enumeration of constant values for setting
	 * the pixel snapping options by using the <code>pixelSnapping</code> property
	 * of a Bitmap object.
	 */
	var PixelSnapping = (function () {
	    function PixelSnapping() {
	    }
	    /**
	     * A constant value used in the <code>pixelSnapping</code> property of a
	     * Bitmap object to specify that the bitmap image is always snapped to the
	     * nearest pixel, independent of any transformation.
	     */
	    PixelSnapping.ALWAYS = "always";
	    /**
	     * A constant value used in the <code>pixelSnapping</code> property of a
	     * Bitmap object to specify that the bitmap image is snapped to the nearest
	     * pixel if it is drawn with no rotation or skew and it is drawn at a scale
	     * factor of 99.9% to 100.1%. If these conditions are satisfied, the image is
	     * drawn at 100% scale, snapped to the nearest pixel. Internally, this
	     * setting allows the image to be drawn as fast as possible by using the
	     * vector renderer.
	     */
	    PixelSnapping.AUTO = "auto";
	    /**
	     * A constant value used in the <code>pixelSnapping</code> property of a
	     * Bitmap object to specify that no pixel snapping occurs.
	     */
	    PixelSnapping.NEVER = "never";
	    return PixelSnapping;
	}());
	exports.PixelSnapping = PixelSnapping;


/***/ },
/* 509 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The SpreadMethod class provides values for the <code>spreadMethod</code>
	 * parameter in the <code>beginGradientFill()</code> and
	 * <code>lineGradientStyle()</code> methods of the Graphics class.
	 *
	 * <p>The following example shows the same gradient fill using various spread
	 * methods:</p>
	 */
	var SpreadMethod = (function () {
	    function SpreadMethod() {
	    }
	    /**
	     * Specifies that the gradient use the <i>pad</i> spread method.
	     */
	    SpreadMethod.PAD = "pad";
	    /**
	     * Specifies that the gradient use the <i>reflect</i> spread method.
	     */
	    SpreadMethod.REFLECT = "reflect";
	    /**
	     * Specifies that the gradient use the <i>repeat</i> spread method.
	     */
	    SpreadMethod.REPEAT = "repeat";
	    return SpreadMethod;
	}());
	exports.SpreadMethod = SpreadMethod;


/***/ },
/* 510 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * Defines codes for culling algorithms that determine which triangles not to
	 * render when drawing triangle paths.
	 *
	 * <p> The terms <code>POSITIVE</code> and <code>NEGATIVE</code> refer to the
	 * sign of a triangle's normal along the z-axis. The normal is a 3D vector
	 * that is perpendicular to the surface of the triangle. </p>
	 *
	 * <p> A triangle whose vertices 0, 1, and 2 are arranged in a clockwise order
	 * has a positive normal value. That is, its normal points in a positive
	 * z-axis direction, away from the current view point. When the
	 * <code>TriangleCulling.POSITIVE</code> algorithm is used, triangles with
	 * positive normals are not rendered. Another term for this is backface
	 * culling. </p>
	 *
	 * <p> A triangle whose vertices are arranged in a counter-clockwise order has
	 * a negative normal value. That is, its normal points in a negative z-axis
	 * direction, toward the current view point. When the
	 * <code>TriangleCulling.NEGATIVE</code> algorithm is used, triangles with
	 * negative normals will not be rendered. </p>
	 */
	var TriangleCulling = (function () {
	    function TriangleCulling() {
	    }
	    /**
	     * Specifies culling of all triangles facing toward the current view point.
	     */
	    TriangleCulling.NEGATIVE = "negative";
	    /**
	     * Specifies no culling. All triangles in the path are rendered.
	     */
	    TriangleCulling.NONE = "none";
	    /**
	     * Specifies culling of all triangles facing away from the current view
	     * point. This is also known as backface culling.
	     */
	    TriangleCulling.POSITIVE = "positive";
	    return TriangleCulling;
	}());
	exports.TriangleCulling = TriangleCulling;


/***/ },
/* 511 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(512));
	__export(__webpack_require__(514));


/***/ },
/* 512 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AbstractMethodError_1 = __webpack_require__(7);
	exports.AbstractMethodError = AbstractMethodError_1.AbstractMethodError;
	var ArgumentError_1 = __webpack_require__(37);
	exports.ArgumentError = ArgumentError_1.ArgumentError;
	var DocumentError_1 = __webpack_require__(513);
	exports.DocumentError = DocumentError_1.DocumentError;
	var ErrorBase_1 = __webpack_require__(8);
	exports.ErrorBase = ErrorBase_1.ErrorBase;
	var PartialImplementationError_1 = __webpack_require__(190);
	exports.PartialImplementationError = PartialImplementationError_1.PartialImplementationError;
	var RangeError_1 = __webpack_require__(147);
	exports.RangeError = RangeError_1.RangeError;


/***/ },
/* 513 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	var DocumentError = (function (_super) {
	    __extends(DocumentError, _super);
	    function DocumentError(message, id) {
	        if (message === void 0) { message = "DocumentError"; }
	        if (id === void 0) { id = 0; }
	        _super.call(this, message, id);
	    }
	    DocumentError.DOCUMENT_DOES_NOT_EXIST = "documentDoesNotExist";
	    return DocumentError;
	}(ErrorBase_1.ErrorBase));
	exports.DocumentError = DocumentError;


/***/ },
/* 514 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CastError_1 = __webpack_require__(515);
	exports.CastError = CastError_1.CastError;


/***/ },
/* 515 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ErrorBase_1 = __webpack_require__(8);
	var CastError = (function (_super) {
	    __extends(CastError, _super);
	    function CastError(message) {
	        _super.call(this, message);
	    }
	    return CastError;
	}(ErrorBase_1.ErrorBase));
	exports.CastError = CastError;


/***/ },
/* 516 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(517));
	__export(__webpack_require__(518));
	__export(__webpack_require__(521));
	__export(__webpack_require__(522));


/***/ },
/* 517 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AssetEvent_1 = __webpack_require__(9);
	exports.AssetEvent = AssetEvent_1.AssetEvent;
	var EventBase_1 = __webpack_require__(10);
	exports.EventBase = EventBase_1.EventBase;
	var EventDispatcher_1 = __webpack_require__(11);
	exports.EventDispatcher = EventDispatcher_1.EventDispatcher;
	var LoaderEvent_1 = __webpack_require__(167);
	exports.LoaderEvent = LoaderEvent_1.LoaderEvent;
	var ParserEvent_1 = __webpack_require__(168);
	exports.ParserEvent = ParserEvent_1.ParserEvent;
	var ProjectionEvent_1 = __webpack_require__(142);
	exports.ProjectionEvent = ProjectionEvent_1.ProjectionEvent;
	var TimerEvent_1 = __webpack_require__(290);
	exports.TimerEvent = TimerEvent_1.TimerEvent;
	var URLLoaderEvent_1 = __webpack_require__(166);
	exports.URLLoaderEvent = URLLoaderEvent_1.URLLoaderEvent;


/***/ },
/* 518 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CameraEvent_1 = __webpack_require__(148);
	exports.CameraEvent = CameraEvent_1.CameraEvent;
	var DisplayObjectEvent_1 = __webpack_require__(117);
	exports.DisplayObjectEvent = DisplayObjectEvent_1.DisplayObjectEvent;
	var ElementsEvent_1 = __webpack_require__(127);
	exports.ElementsEvent = ElementsEvent_1.ElementsEvent;
	var LightEvent_1 = __webpack_require__(151);
	exports.LightEvent = LightEvent_1.LightEvent;
	var MouseEvent_1 = __webpack_require__(195);
	exports.MouseEvent = MouseEvent_1.MouseEvent;
	var RenderableEvent_1 = __webpack_require__(118);
	exports.RenderableEvent = RenderableEvent_1.RenderableEvent;
	var ResizeEvent_1 = __webpack_require__(519);
	exports.ResizeEvent = ResizeEvent_1.ResizeEvent;
	var StyleEvent_1 = __webpack_require__(25);
	exports.StyleEvent = StyleEvent_1.StyleEvent;
	var SurfaceEvent_1 = __webpack_require__(119);
	exports.SurfaceEvent = SurfaceEvent_1.SurfaceEvent;
	var TouchEvent_1 = __webpack_require__(520);
	exports.TouchEvent = TouchEvent_1.TouchEvent;
	var TransformEvent_1 = __webpack_require__(39);
	exports.TransformEvent = TransformEvent_1.TransformEvent;


/***/ },
/* 519 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var ResizeEvent = (function (_super) {
	    __extends(ResizeEvent, _super);
	    function ResizeEvent(type, oldHeight, oldWidth) {
	        if (oldHeight === void 0) { oldHeight = NaN; }
	        if (oldWidth === void 0) { oldWidth = NaN; }
	        _super.call(this, type);
	        this._oldHeight = oldHeight;
	        this._oldWidth = oldWidth;
	    }
	    Object.defineProperty(ResizeEvent.prototype, "oldHeight", {
	        get: function () {
	            return this._oldHeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ResizeEvent.prototype, "oldWidth", {
	        get: function () {
	            return this._oldWidth;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Clones the event.
	     *
	     * @return An exact duplicate of the current object.
	     */
	    ResizeEvent.prototype.clone = function () {
	        return new ResizeEvent(this.type, this._oldHeight, this._oldWidth);
	    };
	    ResizeEvent.RESIZE = "resize";
	    return ResizeEvent;
	}(EventBase_1.EventBase));
	exports.ResizeEvent = ResizeEvent;


/***/ },
/* 520 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var TouchEvent = (function (_super) {
	    __extends(TouchEvent, _super);
	    /**
	     * Create a new TouchEvent object.
	     * @param type The type of the TouchEvent.
	     */
	    function TouchEvent(type) {
	        _super.call(this, type);
	        // Private.
	        this._iAllowedToPropagate = true;
	    }
	    Object.defineProperty(TouchEvent.prototype, "bubbles", {
	        /**
	         * @inheritDoc
	         */
	        get: function () {
	            var doesBubble = this._iAllowedToPropagate;
	            this._iAllowedToPropagate = true;
	            // Don't bubble if propagation has been stopped.
	            return doesBubble;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * @inheritDoc
	     */
	    TouchEvent.prototype.stopPropagation = function () {
	        this._iAllowedToPropagate = false;
	        if (this._iParentEvent)
	            this._iParentEvent.stopPropagation();
	    };
	    /**
	     * @inheritDoc
	     */
	    TouchEvent.prototype.stopImmediatePropagation = function () {
	        this._iAllowedToPropagate = false;
	        if (this._iParentEvent)
	            this._iParentEvent.stopImmediatePropagation();
	    };
	    /**
	     * Creates a copy of the TouchEvent object and sets the value of each property to match that of the original.
	     */
	    TouchEvent.prototype.clone = function () {
	        var result = new TouchEvent(this.type);
	        /* TODO: Debug / test - look into isDefaultPrevented
	         if (isDefaultPrevented())
	         result.preventDefault();
	         */
	        result.screenX = this.screenX;
	        result.screenY = this.screenY;
	        result.view = this.view;
	        result.entity = this.entity;
	        result.renderable = this.renderable;
	        result.material = this.material;
	        result.uv = this.uv;
	        result.position = this.position;
	        result.normal = this.normal;
	        result.elementIndex = this.elementIndex;
	        result.ctrlKey = this.ctrlKey;
	        result.shiftKey = this.shiftKey;
	        result._iParentEvent = this;
	        return result;
	    };
	    Object.defineProperty(TouchEvent.prototype, "scenePosition", {
	        /**
	         * The position in scene space where the event took place
	         */
	        get: function () {
	            return this.entity.sceneTransform.transformVector(this.position);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(TouchEvent.prototype, "sceneNormal", {
	        /**
	         * The normal in scene space where the event took place
	         */
	        get: function () {
	            var sceneNormal = this.entity.sceneTransform.deltaTransformVector(this.normal);
	            sceneNormal.normalize();
	            return sceneNormal;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    TouchEvent.TOUCH_END = "touchEnd3d";
	    /**
	     *
	     */
	    TouchEvent.TOUCH_BEGIN = "touchBegin3d";
	    /**
	     *
	     */
	    TouchEvent.TOUCH_MOVE = "touchMove3d";
	    /**
	     *
	     */
	    TouchEvent.TOUCH_OUT = "touchOut3d";
	    /**
	     *
	     */
	    TouchEvent.TOUCH_OVER = "touchOver3d";
	    return TouchEvent;
	}(EventBase_1.EventBase));
	exports.TouchEvent = TouchEvent;


/***/ },
/* 521 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var StageEvent_1 = __webpack_require__(60);
	exports.StageEvent = StageEvent_1.StageEvent;


/***/ },
/* 522 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AnimationStateEvent_1 = __webpack_require__(331);
	exports.AnimationStateEvent = AnimationStateEvent_1.AnimationStateEvent;
	var AnimatorEvent_1 = __webpack_require__(325);
	exports.AnimatorEvent = AnimatorEvent_1.AnimatorEvent;
	var PassEvent_1 = __webpack_require__(279);
	exports.PassEvent = PassEvent_1.PassEvent;
	var RendererEvent_1 = __webpack_require__(429);
	exports.RendererEvent = RendererEvent_1.RendererEvent;
	var RTTEvent_1 = __webpack_require__(523);
	exports.RTTEvent = RTTEvent_1.RTTEvent;
	var ShadingMethodEvent_1 = __webpack_require__(227);
	exports.ShadingMethodEvent = ShadingMethodEvent_1.ShadingMethodEvent;


/***/ },
/* 523 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var EventBase_1 = __webpack_require__(10);
	var RTTEvent = (function (_super) {
	    __extends(RTTEvent, _super);
	    function RTTEvent(type, rttManager) {
	        _super.call(this, type);
	        this._rttManager = rttManager;
	    }
	    Object.defineProperty(RTTEvent.prototype, "rttManager", {
	        /**
	         *
	         */
	        get: function () {
	            return this._rttManager;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    RTTEvent.prototype.clone = function () {
	        return new RTTEvent(this.type, this._rttManager);
	    };
	    /**
	     *
	     */
	    RTTEvent.RESIZE = "rttManagerResize";
	    return RTTEvent;
	}(EventBase_1.EventBase));
	exports.RTTEvent = RTTEvent;


/***/ },
/* 524 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(525));


/***/ },
/* 525 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Filter3DCompositeTask_1 = __webpack_require__(526);
	exports.Filter3DCompositeTask = Filter3DCompositeTask_1.Filter3DCompositeTask;
	var Filter3DFXAATask_1 = __webpack_require__(528);
	exports.Filter3DFXAATask = Filter3DFXAATask_1.Filter3DFXAATask;
	var Filter3DHBlurTask_1 = __webpack_require__(529);
	exports.Filter3DHBlurTask = Filter3DHBlurTask_1.Filter3DHBlurTask;
	var Filter3DTaskBase_1 = __webpack_require__(527);
	exports.Filter3DTaskBase = Filter3DTaskBase_1.Filter3DTaskBase;
	var Filter3DVBlurTask_1 = __webpack_require__(530);
	exports.Filter3DVBlurTask = Filter3DVBlurTask_1.Filter3DVBlurTask;
	var BlurFilter3D_1 = __webpack_require__(531);
	exports.BlurFilter3D = BlurFilter3D_1.BlurFilter3D;
	var CompositeFilter3D_1 = __webpack_require__(533);
	exports.CompositeFilter3D = CompositeFilter3D_1.CompositeFilter3D;
	var Filter3DBase_1 = __webpack_require__(532);
	exports.Filter3DBase = Filter3DBase_1.Filter3DBase;
	var FXAAFilter3D_1 = __webpack_require__(534);
	exports.FXAAFilter3D = FXAAFilter3D_1.FXAAFilter3D;


/***/ },
/* 526 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLProgramType_1 = __webpack_require__(47);
	var Filter3DTaskBase_1 = __webpack_require__(527);
	var Filter3DCompositeTask = (function (_super) {
	    __extends(Filter3DCompositeTask, _super);
	    function Filter3DCompositeTask(blendMode, exposure) {
	        if (exposure === void 0) { exposure = 1; }
	        _super.call(this);
	        this._data = new Float32Array([exposure, 0.5, 2.0, -1, 0.0, 0.0, 0.0, 0.0]);
	        this._blendMode = blendMode;
	    }
	    Object.defineProperty(Filter3DCompositeTask.prototype, "overlayTexture", {
	        get: function () {
	            return this._overlayTexture;
	        },
	        set: function (value) {
	            this._overlayTexture = value;
	            this._overlayWidth = this._overlayTexture.width;
	            this._overlayHeight = this._overlayTexture.height;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DCompositeTask.prototype, "exposure", {
	        get: function () {
	            return this._data[0];
	        },
	        set: function (value) {
	            this._data[0] = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DCompositeTask.prototype.getFragmentCode = function () {
	        var temp1 = this._registerCache.getFreeFragmentVectorTemp();
	        this._registerCache.addFragmentTempUsages(temp1, 1);
	        var temp2 = this._registerCache.getFreeFragmentVectorTemp();
	        this._registerCache.addFragmentTempUsages(temp2, 1);
	        var temp3 = this._registerCache.getFreeFragmentVectorTemp();
	        this._registerCache.addFragmentTempUsages(temp3, 1);
	        var temp4 = this._registerCache.getFreeFragmentVectorTemp();
	        this._registerCache.addFragmentTempUsages(temp4, 1);
	        var inputTexture = this._registerCache.getFreeTextureReg();
	        this._inputTextureIndex = inputTexture.index;
	        var overlayTexture = this._registerCache.getFreeTextureReg();
	        this._overlayTextureIndex = overlayTexture.index;
	        var exposure = this._registerCache.getFreeFragmentConstant();
	        this._exposureIndex = exposure.index * 4;
	        var scaling = this._registerCache.getFreeFragmentConstant();
	        this._scalingIndex = scaling.index * 4;
	        var code;
	        code = "tex " + temp1 + ", " + this._uvVarying + ", " + inputTexture + " <2d,linear,clamp>\n" +
	            "mul " + temp2 + ", " + this._uvVarying + ", " + scaling + ".zw\n" +
	            "add " + temp2 + ", " + temp2 + ", " + scaling + ".xy\n" +
	            "tex " + temp2 + ", " + temp2 + ", " + overlayTexture + " <2d,linear,clamp>\n" +
	            "mul " + temp2 + ", " + temp2 + ", " + exposure + ".xxx\n" +
	            "add " + temp2 + ", " + temp2 + ", " + exposure + ".xxx\n";
	        switch (this._blendMode) {
	            case "multiply":
	                code += "mul oc, " + temp1 + ", " + temp2 + "\n";
	                break;
	            case "add":
	                code += "add oc, " + temp1 + ", " + temp2 + "\n";
	                break;
	            case "subtract":
	                code += "sub oc, " + temp1 + ", " + temp2 + "\n";
	                break;
	            case "overlay":
	                code += "sge " + temp3 + ", " + temp1 + ", " + exposure + ".yyy\n"; // t2 = (blend >= 0.5)? 1 : 0
	                code += "sub " + temp1 + ", " + temp3 + ", " + temp1 + "\n"; // base = (1 : 0 - base)
	                code += "sub " + temp2 + ", " + temp2 + ", " + temp3 + "\n"; // blend = (blend - 1 : 0)
	                code += "mul " + temp2 + ", " + temp2 + ", " + temp1 + "\n"; // blend = blend * base
	                code += "sub " + temp4 + ", " + temp3 + ", " + exposure + ".yyy\n"; // t3 = (blend >= 0.5)? 0.5 : -0.5
	                code += "div " + temp2 + ", " + temp2 + ", " + temp4 + "\n"; // blend = blend / ( 0.5 : -0.5)
	                code += "add oc, " + temp2 + ", " + temp3 + "\n";
	                break;
	            case "normal":
	                // for debugging purposes
	                code += "mov oc, " + temp1 + "\n";
	                break;
	            default:
	                throw new Error("Unknown blend mode");
	        }
	        return code;
	    };
	    Filter3DCompositeTask.prototype.activate = function (stage, camera3D, depthTexture) {
	        this._data[4] = -0.5 * (this._textureWidth - this._overlayWidth) / this._overlayWidth;
	        this._data[5] = -0.5 * (this._textureHeight - this._overlayHeight) / this._overlayHeight;
	        this._data[6] = this._textureWidth / this._overlayWidth;
	        this._data[7] = this._textureHeight / this._overlayHeight;
	        var context = stage.context;
	        context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.FRAGMENT, this._data);
	        stage.getAbstraction(this._overlayTexture).activate(this._overlayTextureIndex, false);
	    };
	    Filter3DCompositeTask.prototype.deactivate = function (stage) {
	        stage.context.setTextureAt(1, null);
	    };
	    return Filter3DCompositeTask;
	}(Filter3DTaskBase_1.Filter3DTaskBase));
	exports.Filter3DCompositeTask = Filter3DCompositeTask;


/***/ },
/* 527 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Image2D_1 = __webpack_require__(96);
	var AbstractMethodError_1 = __webpack_require__(7);
	var AGALMiniAssembler_1 = __webpack_require__(419);
	var ShaderRegisterCache_1 = __webpack_require__(273);
	var Filter3DTaskBase = (function () {
	    function Filter3DTaskBase(requireDepthRender) {
	        if (requireDepthRender === void 0) { requireDepthRender = false; }
	        this._scaledTextureWidth = -1;
	        this._scaledTextureHeight = -1;
	        this._textureWidth = -1;
	        this._textureHeight = -1;
	        this._textureDimensionsInvalid = true;
	        this._program3DInvalid = true;
	        this._textureScale = 1;
	        this._requireDepthRender = requireDepthRender;
	        this._registerCache = new ShaderRegisterCache_1.ShaderRegisterCache("baseline");
	    }
	    Object.defineProperty(Filter3DTaskBase.prototype, "textureScale", {
	        /**
	         * The texture scale for the input of this texture. This will define the output of the previous entry in the chain
	         */
	        get: function () {
	            return this._textureScale;
	        },
	        set: function (value) {
	            if (this._textureScale == value)
	                return;
	            this._textureScale = value;
	            this._scaledTextureWidth = this._textureWidth / this._textureScale;
	            this._scaledTextureHeight = this._textureHeight / this._textureScale;
	            this._textureDimensionsInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DTaskBase.prototype, "target", {
	        get: function () {
	            return this._target;
	        },
	        set: function (value) {
	            this._target = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DTaskBase.prototype, "rttManager", {
	        get: function () {
	            return this._rttManager;
	        },
	        set: function (value) {
	            if (this._rttManager == value)
	                return;
	            this._rttManager = value;
	            this._textureDimensionsInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DTaskBase.prototype, "textureWidth", {
	        get: function () {
	            return this._textureWidth;
	        },
	        set: function (value) {
	            if (this._textureWidth == value)
	                return;
	            this._textureWidth = value;
	            this._scaledTextureWidth = this._textureWidth / this._textureScale;
	            this._textureDimensionsInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DTaskBase.prototype, "textureHeight", {
	        get: function () {
	            return this._textureHeight;
	        },
	        set: function (value) {
	            if (this._textureHeight == value)
	                return;
	            this._textureHeight = value;
	            this._scaledTextureHeight = this._textureHeight / this._textureScale;
	            this._textureDimensionsInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DTaskBase.prototype.getMainInputTexture = function (stage) {
	        if (this._textureDimensionsInvalid)
	            this.updateTextures(stage);
	        return this._mainInputTexture;
	    };
	    Filter3DTaskBase.prototype.dispose = function () {
	        if (this._mainInputTexture)
	            this._mainInputTexture.dispose();
	        if (this._program3D)
	            this._program3D.dispose();
	    };
	    Filter3DTaskBase.prototype.invalidateProgram = function () {
	        this._program3DInvalid = true;
	    };
	    Filter3DTaskBase.prototype.updateProgram = function (stage) {
	        if (this._program3D)
	            this._program3D.dispose();
	        this._program3D = stage.context.createProgram();
	        this._registerCache.reset();
	        var vertexByteCode = (new AGALMiniAssembler_1.AGALMiniAssembler().assemble("part vertex 1\n" + this.getVertexCode() + "endpart"))['vertex'].data;
	        var fragmentByteCode = (new AGALMiniAssembler_1.AGALMiniAssembler().assemble("part fragment 1\n" + this.getFragmentCode() + "endpart"))['fragment'].data;
	        this._program3D.upload(vertexByteCode, fragmentByteCode);
	        this._program3DInvalid = false;
	    };
	    Filter3DTaskBase.prototype.getVertexCode = function () {
	        var position = this._registerCache.getFreeVertexAttribute();
	        this._positionIndex = position.index;
	        var uv = this._registerCache.getFreeVertexAttribute();
	        this._uvIndex = uv.index;
	        this._uvVarying = this._registerCache.getFreeVarying();
	        var code;
	        code = "mov op, " + position + "\n" +
	            "mov " + this._uvVarying + ", " + uv + "\n";
	        return code;
	    };
	    Filter3DTaskBase.prototype.getFragmentCode = function () {
	        throw new AbstractMethodError_1.AbstractMethodError();
	    };
	    Filter3DTaskBase.prototype.updateTextures = function (stage) {
	        if (this._mainInputTexture)
	            this._mainInputTexture.dispose();
	        this._mainInputTexture = new Image2D_1.Image2D(this._scaledTextureWidth, this._scaledTextureHeight);
	        this._textureDimensionsInvalid = false;
	    };
	    Filter3DTaskBase.prototype.getProgram = function (stage) {
	        if (this._program3DInvalid)
	            this.updateProgram(stage);
	        return this._program3D;
	    };
	    Filter3DTaskBase.prototype.activate = function (stage, camera, depthTexture) {
	    };
	    Filter3DTaskBase.prototype.deactivate = function (stage) {
	    };
	    Object.defineProperty(Filter3DTaskBase.prototype, "requireDepthRender", {
	        get: function () {
	            return this._requireDepthRender;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return Filter3DTaskBase;
	}());
	exports.Filter3DTaskBase = Filter3DTaskBase;


/***/ },
/* 528 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLProgramType_1 = __webpack_require__(47);
	var Filter3DTaskBase_1 = __webpack_require__(527);
	var Filter3DFXAATask = (function (_super) {
	    __extends(Filter3DFXAATask, _super);
	    /**
	     *
	     * @param amount
	     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
	     */
	    function Filter3DFXAATask(amount, stepSize) {
	        if (amount === void 0) { amount = 1; }
	        if (stepSize === void 0) { stepSize = -1; }
	        _super.call(this);
	        this._stepSize = 1;
	        this._data = new Float32Array(20);
	        //luma
	        this._data.set([0.299, 0.587, 0.114, 0], 0); //0.212, 0.716, 0.072
	        //helpers
	        this._data.set([0.25, 0.5, 0.75, 1], 4);
	        //settings (screen x, screen y, ...)
	        this._data.set([1 / 1024, 1 / 1024, -1, 1], 8);
	        //deltas
	        this._data.set([1 / 128, 1 / 8, 8, 0], 12);
	        //deltas
	        this._data.set([1.0 / 3.0 - 0.5, 2.0 / 3.0 - 0.5, 0.0 / 3.0 - 0.5, 3.0 / 3.0 - 0.5], 16);
	        this.amount = amount;
	        this.stepSize = stepSize;
	    }
	    Object.defineProperty(Filter3DFXAATask.prototype, "amount", {
	        get: function () {
	            return this._amount;
	        },
	        set: function (value) {
	            if (this._amount == value)
	                return;
	            this._amount = value;
	            this.invalidateProgram();
	            this.updateBlurData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DFXAATask.prototype, "stepSize", {
	        get: function () {
	            return this._stepSize;
	        },
	        set: function (value) {
	            if (this._stepSize == value)
	                return;
	            this._stepSize = value;
	            this.calculateStepSize();
	            this.invalidateProgram();
	            this.updateBlurData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DFXAATask.prototype.getFragmentCode = function () {
	        var lum = "fc0"; //	0.299, 0.587, 0.114
	        var _0 = "fc0.w";
	        var _025 = "fc1.x";
	        var _05 = "fc1.y";
	        var _075 = "fc1.z";
	        var _1 = "fc1.w";
	        var pix = "fc2.xy";
	        var dx = "fc2.x"; // 1/1024
	        var dy = "fc2.y"; // 1/1024
	        var mOne = "fc2.z"; // -1.0
	        var mul = "fc2.w"; // 1.0  -- one for now
	        var fxaaReduceMin = "fc3.x"; //1/128
	        var fxaaReduceMul = "fc3.y"; //1/8
	        var fxaaSpanMax = "fc3.z"; //8
	        var delta1 = "fc4.x"; //1.0/3.0 - 0.5
	        var delta2 = "fc4.y"; //2.0/3.0 - 0.5
	        var delta3 = "fc4.z"; //0.0/3.0 - 0.5
	        var delta4 = "fc4.w"; //3.0/3.0 - 0.5
	        var uv_in = "v0";
	        var uv = "ft0.xy";
	        var uvx = "ft0.x";
	        var uvy = "ft0.y";
	        var TL = "ft2.x";
	        var TR = "ft2.y";
	        var BL = "ft2.z";
	        var BR = "ft2.w";
	        var M = "ft3.x";
	        var tempf1 = "ft3.y";
	        var tempf2 = "ft3.z";
	        var tempf3 = "ft3.w";
	        var tex = "ft1";
	        var dir = "ft4";
	        var dirx = "ft4.x";
	        var diry = "ft4.y";
	        var dirxy = "ft4.xy";
	        var dirReduce = "ft5.x";
	        var inverseDirAdjustment = "ft5.y";
	        var result1 = "ft6";
	        var result2 = "ft7";
	        var lumaMin = "ft5.x";
	        var lumaMax = "ft5.y";
	        var sample = "fs0";
	        var temp = tex;
	        var tempxy = temp + ".xy";
	        var code = new Array();
	        //lumas
	        code.push("tex", tex, uv_in, sample, "<2d wrap linear>", "\n");
	        code.push("dp3", M, tex, lum, "\n");
	        code.push("mov", uv, uv_in, "\n");
	        code.push("sub", uv, uv, pix, "\n");
	        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
	        code.push("dp3", TL, tex, lum, "\n");
	        code.push("mov", uv, uv_in, "\n");
	        code.push("add", uv, uv, pix, "\n");
	        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
	        code.push("dp3", BR, tex, lum, "\n");
	        code.push("mov", uv, uv_in, "\n");
	        code.push("sub", uvy, uvy, dy, "\n");
	        code.push("add", uvx, uvx, dx, "\n");
	        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
	        code.push("dp3", TR, tex, lum, "\n");
	        code.push("mov", uv, uv_in, "\n");
	        code.push("add", uvy, uvy, dy, "\n");
	        code.push("sub", uvx, uvx, dx, "\n");
	        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
	        code.push("dp3", BL, tex, lum, "\n");
	        //dir
	        code.push("add", tempf1, TL, TR, "\n");
	        code.push("add", tempf2, BL, BR, "\n");
	        code.push("sub", dirx, tempf1, tempf2, "\n");
	        code.push("neg", dirx, dirx, "\n");
	        code.push("add", tempf1, TL, BL, "\n");
	        code.push("add", tempf2, TR, BR, "\n");
	        code.push("sub", diry, tempf1, tempf2, "\n");
	        code.push("add", tempf1, tempf1, tempf2, "\n");
	        code.push("mul", tempf1, tempf1, fxaaReduceMul, "\n");
	        code.push("mul", tempf1, tempf1, _025, "\n");
	        code.push("max", dirReduce, tempf1, fxaaReduceMin, "\n");
	        code.push("abs", tempf1, dirx, "\n");
	        code.push("abs", tempf2, diry, "\n");
	        code.push("min", tempf1, tempf1, tempf2, "\n");
	        code.push("add", tempf1, tempf1, dirReduce, "\n");
	        code.push("rcp", inverseDirAdjustment, tempf1, "\n");
	        code.push("mul", tempf1, dirx, inverseDirAdjustment, "\n");
	        code.push("mov", tempf2, fxaaSpanMax, "\n");
	        code.push("neg", tempf2, tempf2, "\n");
	        code.push("max", tempf1, tempf1, tempf2, "\n");
	        code.push("min", tempf1, fxaaSpanMax, tempf1, "\n");
	        code.push("mul", dirx, tempf1, dx, "\n");
	        code.push("mul", tempf1, diry, inverseDirAdjustment, "\n");
	        code.push("mov", tempf2, fxaaSpanMax, "\n");
	        code.push("neg", tempf2, tempf2, "\n");
	        code.push("max", tempf1, tempf1, tempf2, "\n");
	        code.push("min", tempf1, fxaaSpanMax, tempf1, "\n");
	        code.push("mul", diry, tempf1, dy, "\n");
	        code.push("mul", tempxy, dirxy, delta1, "\n");
	        code.push("add", uv, uv_in, tempxy, "\n");
	        code.push("tex", result1, uv, sample, "<2d wrap linear>", "\n");
	        code.push("mul", tempxy, dirxy, delta2, "\n");
	        code.push("add", uv, uv_in, tempxy, "\n");
	        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
	        code.push("add", result1, result1, tex, "\n");
	        code.push("mul", result1, result1, _05, "\n");
	        code.push("mul", tempxy, dirxy, delta3, "\n");
	        code.push("add", uv, uv_in, tempxy, "\n");
	        code.push("tex", result2, uv, sample, "<2d wrap linear>", "\n");
	        code.push("mul", tempxy, dirxy, delta4, "\n");
	        code.push("add", uv, uv_in, tempxy, "\n");
	        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
	        code.push("add", result2, result2, tex, "\n");
	        code.push("mul", result2, result2, _025, "\n");
	        code.push("mul", tex, result1, _05, "\n");
	        code.push("add", result2, result2, tex, "\n");
	        code.push("min", tempf1, BL, BR, "\n");
	        code.push("min", tempf2, TL, TR, "\n");
	        code.push("min", tempf1, tempf1, tempf2, "\n");
	        code.push("min", lumaMin, tempf1, M, "\n");
	        code.push("max", tempf1, BL, BR, "\n");
	        code.push("max", tempf2, TL, TR, "\n");
	        code.push("max", tempf1, tempf1, tempf2, "\n");
	        code.push("max", lumaMax, tempf1, M, "\n");
	        code.push("dp3", tempf1, lum, result2, "\n");
	        code.push("slt", tempf2, tempf1, lumaMin, "\n");
	        code.push("sge", tempf3, tempf1, lumaMax, "\n");
	        code.push("mul", tempf2, tempf2, tempf3, "\n");
	        code.push("mul", result1, result1, tempf2, "\n");
	        code.push("sub", tempf2, _1, tempf2, "\n");
	        code.push("mul", result2, result2, tempf2, "\n");
	        code.push("add", "oc", result1, result2, "\n");
	        //this._data[2] = 1/numSamples;
	        return code.join(" ");
	    };
	    Filter3DFXAATask.prototype.activate = function (stage, camera3D, depthTexture) {
	        stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.FRAGMENT, this._data);
	    };
	    Filter3DFXAATask.prototype.updateTextures = function (stage) {
	        _super.prototype.updateTextures.call(this, stage);
	        this.updateBlurData();
	    };
	    Filter3DFXAATask.prototype.updateBlurData = function () {
	        // todo: must be normalized using view size ratio instead of texture
	        if (this._rttManager) {
	            this._data[8] = 1 / this._textureWidth;
	            this._data[9] = 1 / this._textureHeight;
	        }
	    };
	    Filter3DFXAATask.prototype.calculateStepSize = function () {
	        this._realStepSize = 1; //this._stepSize > 0? this._stepSize : this._amount > Filter3DVBlurTask.MAX_AUTO_SAMPLES? this._amount/Filter3DVBlurTask.MAX_AUTO_SAMPLES : 1;
	    };
	    //TODO - remove blur variables and create setters/getters for FXAA
	    Filter3DFXAATask.MAX_AUTO_SAMPLES = 15;
	    return Filter3DFXAATask;
	}(Filter3DTaskBase_1.Filter3DTaskBase));
	exports.Filter3DFXAATask = Filter3DFXAATask;


/***/ },
/* 529 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLProgramType_1 = __webpack_require__(47);
	var Filter3DTaskBase_1 = __webpack_require__(527);
	var Filter3DHBlurTask = (function (_super) {
	    __extends(Filter3DHBlurTask, _super);
	    /**
	     * Creates a new Filter3DHDepthOfFFieldTask
	     * @param amount The maximum amount of blur to apply in pixels at the most out-of-focus areas
	     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
	     */
	    function Filter3DHBlurTask(amount, stepSize) {
	        if (stepSize === void 0) { stepSize = -1; }
	        _super.call(this);
	        this._stepSize = 1;
	        this._amount = amount;
	        this._data = new Float32Array([0, 0, 0, 1]);
	        this.stepSize = stepSize;
	    }
	    Object.defineProperty(Filter3DHBlurTask.prototype, "amount", {
	        get: function () {
	            return this._amount;
	        },
	        set: function (value) {
	            if (this._amount == value)
	                return;
	            this._amount = value;
	            this.invalidateProgram();
	            this.updateBlurData();
	            this.calculateStepSize();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DHBlurTask.prototype, "stepSize", {
	        get: function () {
	            return this._stepSize;
	        },
	        set: function (value) {
	            if (this._stepSize == value)
	                return;
	            this._stepSize = value;
	            this.calculateStepSize();
	            this.invalidateProgram();
	            this.updateBlurData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DHBlurTask.prototype.getFragmentCode = function () {
	        var code;
	        var numSamples = 1;
	        code = "mov ft0, v0	\n" +
	            "sub ft0.x, v0.x, fc0.x\n";
	        code += "tex ft1, ft0, fs0 <2d,linear,clamp>\n";
	        for (var x = this._realStepSize; x <= this._amount; x += this._realStepSize) {
	            code += "add ft0.x, ft0.x, fc0.y\n" +
	                "tex ft2, ft0, fs0 <2d,linear,clamp>\n" +
	                "add ft1, ft1, ft2\n";
	            ++numSamples;
	        }
	        code += "mul oc, ft1, fc0.z\n";
	        this._data[2] = 1 / numSamples;
	        return code;
	    };
	    Filter3DHBlurTask.prototype.activate = function (stage, camera3D, depthTexture) {
	        stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.FRAGMENT, this._data);
	    };
	    Filter3DHBlurTask.prototype.updateTextures = function (stage) {
	        _super.prototype.updateTextures.call(this, stage);
	        this.updateBlurData();
	    };
	    Filter3DHBlurTask.prototype.updateBlurData = function () {
	        // todo: must be normalized using view size ratio instead of texture
	        var invW = 1 / this._textureWidth;
	        this._data[0] = this._amount * .5 * invW;
	        this._data[1] = this._realStepSize * invW;
	    };
	    Filter3DHBlurTask.prototype.calculateStepSize = function () {
	        this._realStepSize = this._stepSize > 0 ? this._stepSize : this._amount > Filter3DHBlurTask.MAX_AUTO_SAMPLES ? this._amount / Filter3DHBlurTask.MAX_AUTO_SAMPLES : 1;
	    };
	    Filter3DHBlurTask.MAX_AUTO_SAMPLES = 15;
	    return Filter3DHBlurTask;
	}(Filter3DTaskBase_1.Filter3DTaskBase));
	exports.Filter3DHBlurTask = Filter3DHBlurTask;


/***/ },
/* 530 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ContextGLProgramType_1 = __webpack_require__(47);
	var Filter3DTaskBase_1 = __webpack_require__(527);
	var Filter3DVBlurTask = (function (_super) {
	    __extends(Filter3DVBlurTask, _super);
	    /**
	     *
	     * @param amount
	     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
	     */
	    function Filter3DVBlurTask(amount, stepSize) {
	        if (stepSize === void 0) { stepSize = -1; }
	        _super.call(this);
	        this._stepSize = 1;
	        this._amount = amount;
	        this._data = new Float32Array([0, 0, 0, 1]);
	        this.stepSize = stepSize;
	    }
	    Object.defineProperty(Filter3DVBlurTask.prototype, "amount", {
	        get: function () {
	            return this._amount;
	        },
	        set: function (value) {
	            if (this._amount == value)
	                return;
	            this._amount = value;
	            this.invalidateProgram();
	            this.updateBlurData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DVBlurTask.prototype, "stepSize", {
	        get: function () {
	            return this._stepSize;
	        },
	        set: function (value) {
	            if (this._stepSize == value)
	                return;
	            this._stepSize = value;
	            this.calculateStepSize();
	            this.invalidateProgram();
	            this.updateBlurData();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DVBlurTask.prototype.getFragmentCode = function () {
	        var code;
	        var numSamples = 1;
	        code = "mov ft0, v0	\n" +
	            "sub ft0.y, v0.y, fc0.x\n";
	        code += "tex ft1, ft0, fs0 <2d,linear,clamp>\n";
	        for (var x = this._realStepSize; x <= this._amount; x += this._realStepSize) {
	            code += "add ft0.y, ft0.y, fc0.y\n";
	            code += "tex ft2, ft0, fs0 <2d,linear,clamp>\n" +
	                "add ft1, ft1, ft2\n";
	            ++numSamples;
	        }
	        code += "mul oc, ft1, fc0.z\n";
	        this._data[2] = 1 / numSamples;
	        return code;
	    };
	    Filter3DVBlurTask.prototype.activate = function (stage, camera3D, depthTexture) {
	        stage.context.setProgramConstantsFromArray(ContextGLProgramType_1.ContextGLProgramType.FRAGMENT, this._data);
	    };
	    Filter3DVBlurTask.prototype.updateTextures = function (stage) {
	        _super.prototype.updateTextures.call(this, stage);
	        this.updateBlurData();
	    };
	    Filter3DVBlurTask.prototype.updateBlurData = function () {
	        // todo: must be normalized using view size ratio instead of texture
	        var invH = 1 / this._textureHeight;
	        this._data[0] = this._amount * .5 * invH;
	        this._data[1] = this._realStepSize * invH;
	    };
	    Filter3DVBlurTask.prototype.calculateStepSize = function () {
	        this._realStepSize = this._stepSize > 0 ? this._stepSize : this._amount > Filter3DVBlurTask.MAX_AUTO_SAMPLES ? this._amount / Filter3DVBlurTask.MAX_AUTO_SAMPLES : 1;
	    };
	    Filter3DVBlurTask.MAX_AUTO_SAMPLES = 15;
	    return Filter3DVBlurTask;
	}(Filter3DTaskBase_1.Filter3DTaskBase));
	exports.Filter3DVBlurTask = Filter3DVBlurTask;


/***/ },
/* 531 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Filter3DHBlurTask_1 = __webpack_require__(529);
	var Filter3DVBlurTask_1 = __webpack_require__(530);
	var Filter3DBase_1 = __webpack_require__(532);
	var BlurFilter3D = (function (_super) {
	    __extends(BlurFilter3D, _super);
	    /**
	     * Creates a new BlurFilter3D object
	     * @param blurX The amount of horizontal blur to apply
	     * @param blurY The amount of vertical blur to apply
	     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
	     */
	    function BlurFilter3D(blurX, blurY, stepSize) {
	        if (blurX === void 0) { blurX = 3; }
	        if (blurY === void 0) { blurY = 3; }
	        if (stepSize === void 0) { stepSize = -1; }
	        _super.call(this);
	        this._hBlurTask = new Filter3DHBlurTask_1.Filter3DHBlurTask(blurX, stepSize);
	        this._vBlurTask = new Filter3DVBlurTask_1.Filter3DVBlurTask(blurY, stepSize);
	        this.addTask(this._hBlurTask);
	        this.addTask(this._vBlurTask);
	    }
	    Object.defineProperty(BlurFilter3D.prototype, "blurX", {
	        get: function () {
	            return this._hBlurTask.amount;
	        },
	        set: function (value) {
	            this._hBlurTask.amount = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BlurFilter3D.prototype, "blurY", {
	        get: function () {
	            return this._vBlurTask.amount;
	        },
	        set: function (value) {
	            this._vBlurTask.amount = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(BlurFilter3D.prototype, "stepSize", {
	        /**
	         * The distance between two blur samples. Set to -1 to autodetect with acceptable quality (default value).
	         * Higher values provide better performance at the cost of reduces quality.
	         */
	        get: function () {
	            return this._hBlurTask.stepSize;
	        },
	        set: function (value) {
	            this._hBlurTask.stepSize = value;
	            this._vBlurTask.stepSize = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    BlurFilter3D.prototype.setRenderTargets = function (mainTarget, stage) {
	        this._hBlurTask.target = this._vBlurTask.getMainInputTexture(stage);
	        _super.prototype.setRenderTargets.call(this, mainTarget, stage);
	    };
	    return BlurFilter3D;
	}(Filter3DBase_1.Filter3DBase));
	exports.BlurFilter3D = BlurFilter3D;


/***/ },
/* 532 */
/***/ function(module, exports) {

	"use strict";
	var Filter3DBase = (function () {
	    function Filter3DBase() {
	        this._textureScale = 1;
	        this._tasks = new Array();
	    }
	    Object.defineProperty(Filter3DBase.prototype, "requireDepthRender", {
	        get: function () {
	            return this._requireDepthRender;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DBase.prototype.addTask = function (filter) {
	        this._tasks.push(filter);
	        if (this._requireDepthRender == null)
	            this._requireDepthRender = filter.requireDepthRender;
	    };
	    Object.defineProperty(Filter3DBase.prototype, "tasks", {
	        get: function () {
	            return this._tasks;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DBase.prototype.getMainInputTexture = function (stage) {
	        return this._tasks[0].getMainInputTexture(stage);
	    };
	    Object.defineProperty(Filter3DBase.prototype, "textureWidth", {
	        get: function () {
	            return this._textureWidth;
	        },
	        set: function (value) {
	            this._textureWidth = value;
	            for (var i = 0; i < this._tasks.length; ++i)
	                this._tasks[i].textureWidth = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DBase.prototype, "rttManager", {
	        get: function () {
	            return this._rttManager;
	        },
	        set: function (value) {
	            this._rttManager = value;
	            for (var i = 0; i < this._tasks.length; ++i)
	                this._tasks[i].rttManager = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DBase.prototype, "textureHeight", {
	        get: function () {
	            return this._textureHeight;
	        },
	        set: function (value) {
	            this._textureHeight = value;
	            for (var i = 0; i < this._tasks.length; ++i)
	                this._tasks[i].textureHeight = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DBase.prototype, "textureScale", {
	        get: function () {
	            return this._textureScale;
	        },
	        set: function (value) {
	            this._textureScale = value;
	            for (var i = 0; i < this._tasks.length; ++i)
	                this._tasks[i].textureScale = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    // link up the filters correctly with the next filter
	    Filter3DBase.prototype.setRenderTargets = function (mainTarget, stage) {
	        this._tasks[this._tasks.length - 1].target = mainTarget;
	    };
	    Filter3DBase.prototype.dispose = function () {
	        for (var i = 0; i < this._tasks.length; ++i)
	            this._tasks[i].dispose();
	    };
	    Filter3DBase.prototype.update = function (stage, camera) {
	    };
	    return Filter3DBase;
	}());
	exports.Filter3DBase = Filter3DBase;


/***/ },
/* 533 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Filter3DCompositeTask_1 = __webpack_require__(526);
	var Filter3DBase_1 = __webpack_require__(532);
	var CompositeFilter3D = (function (_super) {
	    __extends(CompositeFilter3D, _super);
	    /**
	     * Creates a new CompositeFilter3D object
	     * @param blurX The amount of horizontal blur to apply
	     * @param blurY The amount of vertical blur to apply
	     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
	     */
	    function CompositeFilter3D(blendMode, exposure) {
	        if (exposure === void 0) { exposure = 1; }
	        _super.call(this);
	        this._compositeTask = new Filter3DCompositeTask_1.Filter3DCompositeTask(blendMode, exposure);
	        this.addTask(this._compositeTask);
	    }
	    Object.defineProperty(CompositeFilter3D.prototype, "exposure", {
	        get: function () {
	            return this._compositeTask.exposure;
	        },
	        set: function (value) {
	            this._compositeTask.exposure = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(CompositeFilter3D.prototype, "overlayTexture", {
	        get: function () {
	            return this._compositeTask.overlayTexture;
	        },
	        set: function (value) {
	            this._compositeTask.overlayTexture = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return CompositeFilter3D;
	}(Filter3DBase_1.Filter3DBase));
	exports.CompositeFilter3D = CompositeFilter3D;


/***/ },
/* 534 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Filter3DFXAATask_1 = __webpack_require__(528);
	var Filter3DBase_1 = __webpack_require__(532);
	var FXAAFilter3D = (function (_super) {
	    __extends(FXAAFilter3D, _super);
	    /**
	     * Creates a new FXAAFilter3D object
	     * @param amount
	     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
	     */
	    function FXAAFilter3D(amount, stepSize) {
	        if (stepSize === void 0) { stepSize = -1; }
	        _super.call(this);
	        this._fxaaTask = new Filter3DFXAATask_1.Filter3DFXAATask(amount, stepSize);
	        this.addTask(this._fxaaTask);
	    }
	    Object.defineProperty(FXAAFilter3D.prototype, "amount", {
	        get: function () {
	            return this._fxaaTask.amount;
	        },
	        set: function (value) {
	            this._fxaaTask.amount = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(FXAAFilter3D.prototype, "stepSize", {
	        get: function () {
	            return this._fxaaTask.stepSize;
	        },
	        set: function (value) {
	            this._fxaaTask.stepSize = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return FXAAFilter3D;
	}(Filter3DBase_1.Filter3DBase));
	exports.FXAAFilter3D = FXAAFilter3D;


/***/ },
/* 535 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(536));


/***/ },
/* 536 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Box_1 = __webpack_require__(33);
	exports.Box = Box_1.Box;
	var ColorTransform_1 = __webpack_require__(27);
	exports.ColorTransform = ColorTransform_1.ColorTransform;
	var MathConsts_1 = __webpack_require__(35);
	exports.MathConsts = MathConsts_1.MathConsts;
	var Matrix_1 = __webpack_require__(102);
	exports.Matrix = Matrix_1.Matrix;
	var Matrix3D_1 = __webpack_require__(32);
	exports.Matrix3D = Matrix3D_1.Matrix3D;
	var Matrix3DUtils_1 = __webpack_require__(38);
	exports.Matrix3DUtils = Matrix3DUtils_1.Matrix3DUtils;
	var Orientation3D_1 = __webpack_require__(36);
	exports.Orientation3D = Orientation3D_1.Orientation3D;
	var Plane3D_1 = __webpack_require__(140);
	exports.Plane3D = Plane3D_1.Plane3D;
	var PlaneClassification_1 = __webpack_require__(141);
	exports.PlaneClassification = PlaneClassification_1.PlaneClassification;
	var Point_1 = __webpack_require__(58);
	exports.Point = Point_1.Point;
	var PoissonLookup_1 = __webpack_require__(261);
	exports.PoissonLookup = PoissonLookup_1.PoissonLookup;
	var Quaternion_1 = __webpack_require__(329);
	exports.Quaternion = Quaternion_1.Quaternion;
	var Rectangle_1 = __webpack_require__(57);
	exports.Rectangle = Rectangle_1.Rectangle;
	var Sphere_1 = __webpack_require__(114);
	exports.Sphere = Sphere_1.Sphere;
	var Vector3D_1 = __webpack_require__(34);
	exports.Vector3D = Vector3D_1.Vector3D;


/***/ },
/* 537 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(538));
	__export(__webpack_require__(539));
	__export(__webpack_require__(541));
	__export(__webpack_require__(542));


/***/ },
/* 538 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var DefaultMaterialManager_1 = __webpack_require__(120);
	exports.DefaultMaterialManager = DefaultMaterialManager_1.DefaultMaterialManager;
	var FrameScriptManager_1 = __webpack_require__(29);
	exports.FrameScriptManager = FrameScriptManager_1.FrameScriptManager;


/***/ },
/* 539 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RTTBufferManager_1 = __webpack_require__(540);
	exports.RTTBufferManager = RTTBufferManager_1.RTTBufferManager;


/***/ },
/* 540 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Rectangle_1 = __webpack_require__(57);
	var EventDispatcher_1 = __webpack_require__(11);
	var ImageUtils_1 = __webpack_require__(98);
	var RTTEvent_1 = __webpack_require__(523);
	var RTTBufferManager = (function (_super) {
	    __extends(RTTBufferManager, _super);
	    function RTTBufferManager(stage) {
	        _super.call(this);
	        this._viewWidth = -1;
	        this._viewHeight = -1;
	        this._textureWidth = -1;
	        this._textureHeight = -1;
	        this._buffersInvalid = true;
	        this._renderToTextureRect = new Rectangle_1.Rectangle();
	        this._stage = stage;
	    }
	    RTTBufferManager.getInstance = function (stage) {
	        if (!stage)
	            throw new Error("stage key cannot be null!");
	        if (RTTBufferManager._instances == null)
	            RTTBufferManager._instances = new Array();
	        var rttBufferManager = RTTBufferManager.getRTTBufferManagerFromStage(stage);
	        if (rttBufferManager == null) {
	            rttBufferManager = new RTTBufferManager(stage);
	            var vo = new RTTBufferManagerVO();
	            vo.stage3d = stage;
	            vo.rttbfm = rttBufferManager;
	            RTTBufferManager._instances.push(vo);
	        }
	        return rttBufferManager;
	    };
	    RTTBufferManager.getRTTBufferManagerFromStage = function (stage) {
	        var l = RTTBufferManager._instances.length;
	        var r;
	        for (var c = 0; c < l; c++) {
	            r = RTTBufferManager._instances[c];
	            if (r.stage3d === stage)
	                return r.rttbfm;
	        }
	        return null;
	    };
	    RTTBufferManager.deleteRTTBufferManager = function (stage) {
	        var l = RTTBufferManager._instances.length;
	        var r;
	        for (var c = 0; c < l; c++) {
	            r = RTTBufferManager._instances[c];
	            if (r.stage3d === stage) {
	                RTTBufferManager._instances.splice(c, 1);
	                return;
	            }
	        }
	    };
	    Object.defineProperty(RTTBufferManager.prototype, "textureRatioX", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._textureRatioX;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "textureRatioY", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._textureRatioY;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "viewWidth", {
	        get: function () {
	            return this._viewWidth;
	        },
	        set: function (value) {
	            if (value == this._viewWidth)
	                return;
	            this._viewWidth = value;
	            this._buffersInvalid = true;
	            this._textureWidth = ImageUtils_1.ImageUtils.getBestPowerOf2(this._viewWidth);
	            if (this._textureWidth > this._viewWidth) {
	                this._renderToTextureRect.x = Math.floor((this._textureWidth - this._viewWidth) * .5);
	                this._renderToTextureRect.width = this._viewWidth;
	            }
	            else {
	                this._renderToTextureRect.x = 0;
	                this._renderToTextureRect.width = this._textureWidth;
	            }
	            this.dispatchEvent(new RTTEvent_1.RTTEvent(RTTEvent_1.RTTEvent.RESIZE, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "viewHeight", {
	        get: function () {
	            return this._viewHeight;
	        },
	        set: function (value) {
	            if (value == this._viewHeight)
	                return;
	            this._viewHeight = value;
	            this._buffersInvalid = true;
	            this._textureHeight = ImageUtils_1.ImageUtils.getBestPowerOf2(this._viewHeight);
	            if (this._textureHeight > this._viewHeight) {
	                this._renderToTextureRect.y = Math.floor((this._textureHeight - this._viewHeight) * .5);
	                this._renderToTextureRect.height = this._viewHeight;
	            }
	            else {
	                this._renderToTextureRect.y = 0;
	                this._renderToTextureRect.height = this._textureHeight;
	            }
	            this.dispatchEvent(new RTTEvent_1.RTTEvent(RTTEvent_1.RTTEvent.RESIZE, this));
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureVertexBuffer", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._renderToTextureVertexBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "renderToScreenVertexBuffer", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._renderToScreenVertexBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "indexBuffer", {
	        get: function () {
	            return this._indexBuffer;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureRect", {
	        get: function () {
	            if (this._buffersInvalid)
	                this.updateRTTBuffers();
	            return this._renderToTextureRect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "textureWidth", {
	        get: function () {
	            return this._textureWidth;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(RTTBufferManager.prototype, "textureHeight", {
	        get: function () {
	            return this._textureHeight;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    RTTBufferManager.prototype.dispose = function () {
	        RTTBufferManager.deleteRTTBufferManager(this._stage);
	        if (this._indexBuffer) {
	            this._indexBuffer.dispose();
	            this._renderToScreenVertexBuffer.dispose();
	            this._renderToTextureVertexBuffer.dispose();
	            this._renderToScreenVertexBuffer = null;
	            this._renderToTextureVertexBuffer = null;
	            this._indexBuffer = null;
	        }
	    };
	    // todo: place all this in a separate model, since it's used all over the place
	    // maybe it even has a place in the core (together with screenRect etc)?
	    // needs to be stored per view of course
	    RTTBufferManager.prototype.updateRTTBuffers = function () {
	        var context = this._stage.context;
	        var textureVerts;
	        var screenVerts;
	        var x;
	        var y;
	        if (this._renderToTextureVertexBuffer == null)
	            this._renderToTextureVertexBuffer = context.createVertexBuffer(4, 20);
	        if (this._renderToScreenVertexBuffer == null)
	            this._renderToScreenVertexBuffer = context.createVertexBuffer(4, 20);
	        if (!this._indexBuffer) {
	            this._indexBuffer = context.createIndexBuffer(6);
	            this._indexBuffer.uploadFromArray([2, 1, 0, 3, 2, 0], 0, 6);
	        }
	        this._textureRatioX = x = Math.min(this._viewWidth / this._textureWidth, 1);
	        this._textureRatioY = y = Math.min(this._viewHeight / this._textureHeight, 1);
	        var u1 = (1 - x) * .5;
	        var u2 = (x + 1) * .5;
	        var v1 = (1 - y) * .5;
	        var v2 = (y + 1) * .5;
	        // last element contains indices for data per vertex that can be passed to the vertex shader if necessary (ie: frustum corners for deferred rendering)
	        textureVerts = [-x, -y, u1, v1, 0, x, -y, u2, v1, 1, x, y, u2, v2, 2, -x, y, u1, v2, 3];
	        screenVerts = [-1, -1, u1, v1, 0, 1, -1, u2, v1, 1, 1, 1, u2, v2, 2, -1, 1, u1, v2, 3];
	        this._renderToTextureVertexBuffer.uploadFromArray(textureVerts, 0, 4);
	        this._renderToScreenVertexBuffer.uploadFromArray(screenVerts, 0, 4);
	        this._buffersInvalid = false;
	    };
	    return RTTBufferManager;
	}(EventDispatcher_1.EventDispatcher));
	exports.RTTBufferManager = RTTBufferManager;
	var RTTBufferManagerVO = (function () {
	    function RTTBufferManagerVO() {
	    }
	    return RTTBufferManagerVO;
	}());


/***/ },
/* 541 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AudioManager_1 = __webpack_require__(302);
	exports.AudioManager = AudioManager_1.AudioManager;
	var StreamingAudioChannel_1 = __webpack_require__(303);
	exports.StreamingAudioChannel = StreamingAudioChannel_1.StreamingAudioChannel;
	var WebAudioChannel_1 = __webpack_require__(304);
	exports.WebAudioChannel = WebAudioChannel_1.WebAudioChannel;


/***/ },
/* 542 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var MouseManager_1 = __webpack_require__(543);
	exports.MouseManager = MouseManager_1.MouseManager;
	var TouchManager_1 = __webpack_require__(544);
	exports.TouchManager = TouchManager_1.TouchManager;


/***/ },
/* 543 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(34);
	var TouchPoint_1 = __webpack_require__(30);
	var MouseEvent_1 = __webpack_require__(195);
	var FrameScriptManager_1 = __webpack_require__(29);
	/**
	 * MouseManager enforces a singleton pattern and is not intended to be instanced.
	 * it provides a manager class for detecting mouse hits on scene objects and sending out mouse events.
	 */
	var MouseManager = (function () {
	    /**
	     * Creates a new <code>MouseManager</code> object.
	     */
	    function MouseManager() {
	        var _this = this;
	        this._viewLookup = new Array();
	        this._nullVector = new Vector3D_1.Vector3D();
	        this._queuedEvents = new Array();
	        this._mouseUp = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_UP);
	        this._mouseClick = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.CLICK);
	        this._mouseOut = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OUT);
	        this._mouseDown = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_DOWN);
	        this._mouseMove = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_MOVE);
	        this._mouseOver = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_OVER);
	        this._mouseWheel = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.MOUSE_WHEEL);
	        this._mouseDoubleClick = new MouseEvent_1.MouseEvent(MouseEvent_1.MouseEvent.DOUBLE_CLICK);
	        this.onClickDelegate = function (event) { return _this.onClick(event); };
	        this.onDoubleClickDelegate = function (event) { return _this.onDoubleClick(event); };
	        this.onMouseDownDelegate = function (event) { return _this.onMouseDown(event); };
	        this.onMouseMoveDelegate = function (event) { return _this.onMouseMove(event); };
	        this.onMouseUpDelegate = function (event) { return _this.onMouseUp(event); };
	        this.onMouseWheelDelegate = function (event) { return _this.onMouseWheel(event); };
	        this.onMouseOverDelegate = function (event) { return _this.onMouseOver(event); };
	        this.onMouseOutDelegate = function (event) { return _this.onMouseOut(event); };
	    }
	    MouseManager.getInstance = function () {
	        if (this._instance)
	            return this._instance;
	        return (this._instance = new MouseManager());
	    };
	    MouseManager.prototype.fireMouseEvents = function (forceMouseMove) {
	        // If colliding object has changed, queue over/out events.
	        if (this._iCollision != this._previousCollidingObject) {
	            if (this._previousCollidingObject)
	                this.queueDispatch(this._mouseOut, this._mouseMoveEvent, this._previousCollidingObject);
	            if (this._iCollision)
	                this.queueDispatch(this._mouseOver, this._mouseMoveEvent);
	        }
	        // Fire mouse move events here if forceMouseMove is on.
	        if (forceMouseMove && this._iCollision)
	            this.queueDispatch(this._mouseMove, this._mouseMoveEvent);
	        var event;
	        var dispatcher;
	        // Dispatch all queued events.
	        var len = this._queuedEvents.length;
	        for (var i = 0; i < len; ++i) {
	            event = this._queuedEvents[i];
	            dispatcher = event.entity;
	            // bubble event up the heirarchy until the top level parent is reached
	            while (dispatcher) {
	                if (dispatcher._iIsMouseEnabled())
	                    dispatcher.dispatchEvent(event);
	                dispatcher = dispatcher.parent;
	            }
	            // not totally sure, but i think just calling it is easier and cheaper than any options for that
	            // if nothing is queued, the function will return directly anyway
	            FrameScriptManager_1.FrameScriptManager.execute_queue();
	        }
	        this._queuedEvents.length = 0;
	        this._previousCollidingObject = this._iCollision;
	        this._iUpdateDirty = false;
	    };
	    //		public addViewLayer(view:View)
	    //		{
	    //			var stg:Stage = view.stage;
	    //
	    //			// Add instance to mouse3dmanager to fire mouse events for multiple views
	    //			if (!view.stageGL.mouse3DManager)
	    //				view.stageGL.mouse3DManager = this;
	    //
	    //			if (!hasKey(view))
	    //				_view3Ds[view] = 0;
	    //
	    //			_childDepth = 0;
	    //			traverseDisplayObjects(stg);
	    //			_viewCount = _childDepth;
	    //		}
	    MouseManager.prototype.registerView = function (view) {
	        if (view && view.htmlElement) {
	            view.htmlElement.addEventListener("click", this.onClickDelegate);
	            view.htmlElement.addEventListener("dblclick", this.onDoubleClickDelegate);
	            view.htmlElement.addEventListener("touchstart", this.onMouseDownDelegate);
	            view.htmlElement.addEventListener("mousedown", this.onMouseDownDelegate);
	            view.htmlElement.addEventListener("touchmove", this.onMouseMoveDelegate);
	            view.htmlElement.addEventListener("mousemove", this.onMouseMoveDelegate);
	            view.htmlElement.addEventListener("mouseup", this.onMouseUpDelegate);
	            view.htmlElement.addEventListener("touchend", this.onMouseUpDelegate);
	            view.htmlElement.addEventListener("mousewheel", this.onMouseWheelDelegate);
	            view.htmlElement.addEventListener("mouseover", this.onMouseOverDelegate);
	            view.htmlElement.addEventListener("mouseout", this.onMouseOutDelegate);
	            this._viewLookup.push(view);
	        }
	    };
	    MouseManager.prototype.unregisterView = function (view) {
	        if (view && view.htmlElement) {
	            view.htmlElement.removeEventListener("click", this.onClickDelegate);
	            view.htmlElement.removeEventListener("dblclick", this.onDoubleClickDelegate);
	            view.htmlElement.removeEventListener("touchstart", this.onMouseDownDelegate);
	            view.htmlElement.removeEventListener("mousedown", this.onMouseDownDelegate);
	            view.htmlElement.removeEventListener("touchmove", this.onMouseMoveDelegate);
	            view.htmlElement.removeEventListener("mousemove", this.onMouseMoveDelegate);
	            view.htmlElement.removeEventListener("touchend", this.onMouseUpDelegate);
	            view.htmlElement.removeEventListener("mouseup", this.onMouseUpDelegate);
	            view.htmlElement.removeEventListener("mousewheel", this.onMouseWheelDelegate);
	            view.htmlElement.removeEventListener("mouseover", this.onMouseOverDelegate);
	            view.htmlElement.removeEventListener("mouseout", this.onMouseOutDelegate);
	            this._viewLookup.slice(this._viewLookup.indexOf(view), 1);
	        }
	    };
	    // ---------------------------------------------------------------------
	    // Private.
	    // ---------------------------------------------------------------------
	    MouseManager.prototype.queueDispatch = function (event, sourceEvent, collision) {
	        if (collision === void 0) { collision = null; }
	        // 2D properties.
	        if (sourceEvent) {
	            event.ctrlKey = sourceEvent.ctrlKey;
	            event.altKey = sourceEvent.altKey;
	            event.shiftKey = sourceEvent.shiftKey;
	            event.screenX = (sourceEvent.clientX != null) ? sourceEvent.clientX : sourceEvent.changedTouches[0].clientX;
	            event.screenY = (sourceEvent.clientY != null) ? sourceEvent.clientY : sourceEvent.changedTouches[0].clientY;
	        }
	        if (collision == null)
	            collision = this._iCollision;
	        // 3D properties.
	        if (collision) {
	            // Object.
	            event.entity = collision.entity;
	            event.renderable = collision.renderable;
	            // UV.
	            event.uv = collision.uv;
	            // Position.
	            event.position = collision.position ? collision.position.clone() : null;
	            // Normal.
	            event.normal = collision.normal ? collision.normal.clone() : null;
	            // Face index.
	            event.elementIndex = collision.elementIndex;
	        }
	        else {
	            // Set all to null.
	            event.uv = null;
	            event.entity = null;
	            event.position = this._nullVector;
	            event.normal = this._nullVector;
	            event.elementIndex = 0;
	        }
	        // Store event to be dispatched later.
	        this._queuedEvents.push(event);
	    };
	    // ---------------------------------------------------------------------
	    // Listeners.
	    // ---------------------------------------------------------------------
	    MouseManager.prototype.onMouseMove = function (event) {
	        event.preventDefault();
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseMove, this._mouseMoveEvent = event);
	    };
	    MouseManager.prototype.onMouseOut = function (event) {
	        this._iActiveDiv = null;
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseOut, event);
	    };
	    MouseManager.prototype.onMouseOver = function (event) {
	        this._iActiveDiv = event.target;
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseOver, event);
	    };
	    MouseManager.prototype.onClick = function (event) {
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseClick, event);
	    };
	    MouseManager.prototype.onDoubleClick = function (event) {
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseDoubleClick, event);
	    };
	    MouseManager.prototype.onMouseDown = function (event) {
	        event.preventDefault();
	        this._iActiveDiv = event.target;
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseDown, event);
	    };
	    MouseManager.prototype.onMouseUp = function (event) {
	        event.preventDefault();
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseUp, event);
	    };
	    MouseManager.prototype.onMouseWheel = function (event) {
	        this.updateColliders(event);
	        if (this._iCollision)
	            this.queueDispatch(this._mouseWheel, event);
	    };
	    MouseManager.prototype.updateColliders = function (event) {
	        var view;
	        var bounds;
	        var mouseX = (event.clientX != null) ? event.clientX : event.changedTouches[0].clientX;
	        var mouseY = (event.clientY != null) ? event.clientY : event.changedTouches[0].clientY;
	        var len = this._viewLookup.length;
	        for (var i = 0; i < len; i++) {
	            view = this._viewLookup[i];
	            view._pTouchPoints.length = 0;
	            bounds = view.htmlElement.getBoundingClientRect();
	            if (event.touches) {
	                var touch;
	                var len = event.touches.length;
	                for (var i = 0; i < len; i++) {
	                    touch = event.touches[i];
	                    view._pTouchPoints.push(new TouchPoint_1.TouchPoint(touch.clientX + bounds.left, touch.clientY + bounds.top, touch.identifier));
	                }
	            }
	            if (this._iUpdateDirty)
	                continue;
	            if (mouseX < bounds.left || mouseX > bounds.right || mouseY < bounds.top || mouseY > bounds.bottom) {
	                view._pMouseX = null;
	                view._pMouseY = null;
	            }
	            else {
	                view._pMouseX = mouseX + bounds.left;
	                view._pMouseY = mouseY + bounds.top;
	                view.updateCollider();
	                if (view.layeredView && this._iCollision)
	                    break;
	            }
	        }
	        this._iUpdateDirty = true;
	    };
	    return MouseManager;
	}());
	exports.MouseManager = MouseManager;


/***/ },
/* 544 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(34);
	var TouchEvent_1 = __webpack_require__(520);
	var TouchManager = (function () {
	    function TouchManager() {
	        var _this = this;
	        this._updateDirty = true;
	        this._nullVector = new Vector3D_1.Vector3D();
	        this._queuedEvents = new Array();
	        this._touchOut = new TouchEvent_1.TouchEvent(TouchEvent_1.TouchEvent.TOUCH_OUT);
	        this._touchBegin = new TouchEvent_1.TouchEvent(TouchEvent_1.TouchEvent.TOUCH_BEGIN);
	        this._touchMove = new TouchEvent_1.TouchEvent(TouchEvent_1.TouchEvent.TOUCH_MOVE);
	        this._touchEnd = new TouchEvent_1.TouchEvent(TouchEvent_1.TouchEvent.TOUCH_END);
	        this._touchOver = new TouchEvent_1.TouchEvent(TouchEvent_1.TouchEvent.TOUCH_OVER);
	        this._touchPoints = new Array();
	        this._touchPointFromId = new Object();
	        TouchManager._iCollisionFromTouchId = new Object();
	        TouchManager._previousCollidingObjectFromTouchId = new Object();
	        this.onTouchBeginDelegate = function (event) { return _this.onTouchBegin(event); };
	        this.onTouchMoveDelegate = function (event) { return _this.onTouchMove(event); };
	        this.onTouchEndDelegate = function (event) { return _this.onTouchEnd(event); };
	    }
	    TouchManager.getInstance = function () {
	        if (this._instance)
	            return this._instance;
	        return (this._instance = new TouchManager());
	    };
	    // ---------------------------------------------------------------------
	    // Interface.
	    // ---------------------------------------------------------------------
	    TouchManager.prototype.updateCollider = function (forceTouchMove) {
	        //if (forceTouchMove || this._updateDirty) { // If forceTouchMove is off, and no 2D Touch events dirty the update, don't update either.
	        //	for (var i:number; i < this._numTouchPoints; ++i) {
	        //		this._touchPoint = this._touchPoints[ i ];
	        //		this._iCollision = this._touchPicker.getViewCollision(this._touchPoint.x, this._touchPoint.y, this._view);
	        //		TouchManager._iCollisionFromTouchId[ this._touchPoint.id ] = this._iCollision;
	        //	}
	        //}
	    };
	    TouchManager.prototype.fireTouchEvents = function (forceTouchMove) {
	        var i;
	        for (i = 0; i < this._numTouchPoints; ++i) {
	            this._touchPoint = this._touchPoints[i];
	            // If colliding object has changed, queue over/out events.
	            this._iCollision = TouchManager._iCollisionFromTouchId[this._touchPoint.id];
	            this._previousCollidingObject = TouchManager._previousCollidingObjectFromTouchId[this._touchPoint.id];
	            if (this._iCollision != this._previousCollidingObject) {
	                if (this._previousCollidingObject)
	                    this.queueDispatch(this._touchOut, this._touchMoveEvent, this._previousCollidingObject, this._touchPoint);
	                if (this._iCollision)
	                    this.queueDispatch(this._touchOver, this._touchMoveEvent, this._iCollision, this._touchPoint);
	            }
	            // Fire Touch move events here if forceTouchMove is on.
	            if (forceTouchMove && this._iCollision)
	                this.queueDispatch(this._touchMove, this._touchMoveEvent, this._iCollision, this._touchPoint);
	        }
	        var event;
	        var dispatcher;
	        // Dispatch all queued events.
	        var len = this._queuedEvents.length;
	        for (i = 0; i < len; ++i) {
	            // Only dispatch from first implicitly enabled object ( one that is not a child of a TouchChildren = false hierarchy ).
	            event = this._queuedEvents[i];
	            dispatcher = event.entity;
	            while (dispatcher && !dispatcher._iIsMouseEnabled())
	                dispatcher = dispatcher.parent;
	            if (dispatcher)
	                dispatcher.dispatchEvent(event);
	        }
	        this._queuedEvents.length = 0;
	        this._updateDirty = false;
	        for (i = 0; i < this._numTouchPoints; ++i) {
	            this._touchPoint = this._touchPoints[i];
	            TouchManager._previousCollidingObjectFromTouchId[this._touchPoint.id] = TouchManager._iCollisionFromTouchId[this._touchPoint.id];
	        }
	    };
	    TouchManager.prototype.registerView = function (view) {
	        view.htmlElement.addEventListener("touchstart", this.onTouchBeginDelegate);
	        view.htmlElement.addEventListener("touchmove", this.onTouchMoveDelegate);
	        view.htmlElement.addEventListener("touchend", this.onTouchEndDelegate);
	    };
	    TouchManager.prototype.unregisterView = function (view) {
	        view.htmlElement.removeEventListener("touchstart", this.onTouchBeginDelegate);
	        view.htmlElement.removeEventListener("touchmove", this.onTouchMoveDelegate);
	        view.htmlElement.removeEventListener("touchend", this.onTouchEndDelegate);
	    };
	    // ---------------------------------------------------------------------
	    // Private.
	    // ---------------------------------------------------------------------
	    TouchManager.prototype.queueDispatch = function (event, sourceEvent, collider, touch) {
	        // 2D properties.
	        event.ctrlKey = sourceEvent.ctrlKey;
	        event.altKey = sourceEvent.altKey;
	        event.shiftKey = sourceEvent.shiftKey;
	        event.screenX = touch.x;
	        event.screenY = touch.y;
	        event.touchPointID = touch.id;
	        // 3D properties.
	        if (collider) {
	            // Object.
	            event.entity = collider.entity;
	            event.renderable = collider.renderable;
	            // UV.
	            event.uv = collider.uv;
	            // Position.
	            event.position = collider.position ? collider.position.clone() : null;
	            // Normal.
	            event.normal = collider.normal ? collider.normal.clone() : null;
	            // ElementsIndex.
	            event.elementIndex = collider.elementIndex;
	        }
	        else {
	            // Set all to null.
	            event.uv = null;
	            event.entity = null;
	            event.position = this._nullVector;
	            event.normal = this._nullVector;
	            event.elementIndex = 0;
	        }
	        // Store event to be dispatched later.
	        this._queuedEvents.push(event);
	    };
	    // ---------------------------------------------------------------------
	    // Event handlers.
	    // ---------------------------------------------------------------------
	    TouchManager.prototype.onTouchBegin = function (event) {
	        var touch = new TouchPoint();
	        //touch.id = event.touchPointID;
	        //touch.x = event.stageX;
	        //touch.y = event.stageY;
	        this._numTouchPoints++;
	        this._touchPoints.push(touch);
	        this._touchPointFromId[touch.id] = touch;
	        //this.updateCollider(event); // ensures collision check is done with correct mouse coordinates on mobile
	        this._iCollision = TouchManager._iCollisionFromTouchId[touch.id];
	        if (this._iCollision)
	            this.queueDispatch(this._touchBegin, event, this._iCollision, touch);
	        this._updateDirty = true;
	    };
	    TouchManager.prototype.onTouchMove = function (event) {
	        //var touch:TouchPoint = this._touchPointFromId[ event.touchPointID ];
	        //
	        //if (!touch) return;
	        //
	        ////touch.x = event.stageX;
	        ////touch.y = event.stageY;
	        //
	        //this._iCollision = TouchManager._iCollisionFromTouchId[ touch.id ];
	        //
	        //if (this._iCollision)
	        //	this.queueDispatch(this._touchMove, this._touchMoveEvent = event, this._iCollision, touch);
	        //
	        //this._updateDirty = true;
	    };
	    TouchManager.prototype.onTouchEnd = function (event) {
	        //var touch:TouchPoint = this._touchPointFromId[ event.touchPointID ];
	        //
	        //if (!touch) return;
	        //
	        //this._iCollision = TouchManager._iCollisionFromTouchId[ touch.id ];
	        //if (this._iCollision)
	        //	this.queueDispatch(this._touchEnd, event, this._iCollision, touch);
	        //
	        //this._touchPointFromId[ touch.id ] = null;
	        //this._numTouchPoints--;
	        //this._touchPoints.splice(this._touchPoints.indexOf(touch), 1);
	        //
	        //this._updateDirty = true;
	    };
	    return TouchManager;
	}());
	exports.TouchManager = TouchManager;
	var TouchPoint = (function () {
	    function TouchPoint() {
	    }
	    return TouchPoint;
	}());


/***/ },
/* 545 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(546));


/***/ },
/* 546 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CrossDomainPolicy_1 = __webpack_require__(547);
	exports.CrossDomainPolicy = CrossDomainPolicy_1.CrossDomainPolicy;
	var URLLoader_1 = __webpack_require__(162);
	exports.URLLoader = URLLoader_1.URLLoader;
	var URLLoaderDataFormat_1 = __webpack_require__(163);
	exports.URLLoaderDataFormat = URLLoaderDataFormat_1.URLLoaderDataFormat;
	var URLRequest_1 = __webpack_require__(296);
	exports.URLRequest = URLRequest_1.URLRequest;
	var URLRequestMethod_1 = __webpack_require__(164);
	exports.URLRequestMethod = URLRequestMethod_1.URLRequestMethod;
	var URLVariables_1 = __webpack_require__(165);
	exports.URLVariables = URLVariables_1.URLVariables;


/***/ },
/* 547 */
/***/ function(module, exports) {

	"use strict";
	var CrossDomainPolicy = (function () {
	    function CrossDomainPolicy() {
	    }
	    CrossDomainPolicy.ANONYMOUS = 'anonymous';
	    CrossDomainPolicy.USE_CREDENTIALS = 'use-credentials';
	    return CrossDomainPolicy;
	}());
	exports.CrossDomainPolicy = CrossDomainPolicy;


/***/ },
/* 548 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(549));
	__export(__webpack_require__(551));


/***/ },
/* 549 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var JSPickingCollider_1 = __webpack_require__(550);
	exports.JSPickingCollider = JSPickingCollider_1.JSPickingCollider;
	var PickingCollision_1 = __webpack_require__(116);
	exports.PickingCollision = PickingCollision_1.PickingCollision;


/***/ },
/* 550 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(34);
	var Point_1 = __webpack_require__(58);
	/**
	 * Pure JS picking collider for display objects. Used with the <code>RaycastPicker</code> picking object.
	 *
	 * @see away.base.DisplayObject#pickingCollider
	 * @see away.pick.RaycastPicker
	 *
	 * @class away.pick.JSPickingCollider
	 */
	var JSPickingCollider = (function () {
	    /**
	     * Creates a new <code>JSPickingCollider</code> object.
	     *
	     * @param findClosestCollision Determines whether the picking collider searches for the closest collision along the ray. Defaults to false.
	     */
	    function JSPickingCollider(findClosestCollision) {
	        if (findClosestCollision === void 0) { findClosestCollision = false; }
	        this._findClosestCollision = findClosestCollision;
	    }
	    /**
	     * Tests a <code>Billboard</code> object for a collision with the picking ray.
	     *
	     * @param billboard The billboard instance to be tested.
	     * @param pickingCollision The collision object used to store the collision results
	     * @param findClosest
	     */
	    JSPickingCollider.prototype.testBillboardCollision = function (billboard, material, pickingCollision) {
	        pickingCollision.renderable = null;
	        //if (this._testGraphicCollision(<RenderableBase> this._renderablePool.getItem(billboard), pickingCollision, shortestCollisionDistance)) {
	        //	shortestCollisionDistance = pickingCollision.rayEntryDistance;
	        //
	        //	pickingCollision.renderable = billboard;
	        //
	        //	return true;
	        //}
	        return false;
	    };
	    /**
	     * Tests a <code>TriangleElements</code> object for a collision with the picking ray.
	     *
	     * @param triangleElements
	     * @param material
	     * @param pickingCollision
	     * @returns {boolean}
	     */
	    JSPickingCollider.prototype.testTriangleCollision = function (triangleElements, material, pickingCollision, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        var rayPosition = pickingCollision.rayPosition;
	        var rayDirection = pickingCollision.rayDirection;
	        var t;
	        var i0, i1, i2;
	        var rx, ry, rz;
	        var nx, ny, nz;
	        var cx, cy, cz;
	        var coeff, u, v, w;
	        var p0x, p0y, p0z;
	        var p1x, p1y, p1z;
	        var p2x, p2y, p2z;
	        var s0x, s0y, s0z;
	        var s1x, s1y, s1z;
	        var nl, nDotV, D, disToPlane;
	        var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
	        var collisionTriangleIndex = -1;
	        var bothSides = material.bothSides;
	        var positions = triangleElements.positions.get(count, offset);
	        var posDim = triangleElements.positions.dimensions;
	        var posStride = triangleElements.positions.stride;
	        var indices;
	        if (triangleElements.indices) {
	            indices = triangleElements.indices.get(triangleElements.numElements);
	            count = indices.length;
	        }
	        for (var index = 0; index < count; index += 3) {
	            // evaluate triangle indices
	            if (indices) {
	                i0 = indices[index] * posStride;
	                i1 = indices[index + 1] * posStride;
	                i2 = indices[index + 2] * posStride;
	            }
	            else {
	                i0 = index * posStride;
	                i1 = (index + 1) * posStride;
	                i2 = (index + 2) * posStride;
	            }
	            // evaluate triangle positions
	            p0x = positions[i0];
	            p1x = positions[i1];
	            p2x = positions[i2];
	            s0x = p1x - p0x; // s0 = p1 - p0
	            s1x = p2x - p0x; // s1 = p2 - p0
	            p0y = positions[i0 + 1];
	            p1y = positions[i1 + 1];
	            p2y = positions[i2 + 1];
	            s0y = p1y - p0y;
	            s1y = p2y - p0y;
	            if (posDim == 3) {
	                p0z = positions[i0 + 2];
	                p1z = positions[i1 + 2];
	                p2z = positions[i2 + 2];
	                s0z = p1z - p0z;
	                s1z = p2z - p0z;
	                // evaluate sides and triangle normal
	                nx = s0y * s1z - s0z * s1y; // n = s0 x s1
	                ny = s0z * s1x - s0x * s1z;
	                nz = s0x * s1y - s0y * s1x;
	                nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
	                nx *= nl;
	                ny *= nl;
	                nz *= nl;
	            }
	            else {
	                nx = 0;
	                ny = 0;
	                nz = 1;
	            }
	            // -- plane intersection test --
	            nDotV = nx * rayDirection.x + ny * +rayDirection.y + nz * rayDirection.z; // rayDirection . normal
	            if ((!bothSides && nDotV < 0.0) || (bothSides && nDotV != 0.0)) {
	                // find collision t
	                D = -(nx * p0x + ny * p0y + nz * p0z);
	                disToPlane = -(nx * rayPosition.x + ny * rayPosition.y + nz * rayPosition.z + D);
	                t = disToPlane / nDotV;
	                // find collision point
	                cx = rayPosition.x + t * rayDirection.x;
	                cy = rayPosition.y + t * rayDirection.y;
	                cz = rayPosition.z + t * rayDirection.z;
	                // collision point inside triangle? ( using barycentric coordinates )
	                Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
	                Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
	                Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
	                rx = cx - p0x;
	                ry = cy - p0y;
	                rz = cz - p0z;
	                RQ1 = rx * s0x + ry * s0y + rz * s0z;
	                RQ2 = rx * s1x + ry * s1y + rz * s1z;
	                coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
	                v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
	                w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
	                if (v < 0)
	                    continue;
	                if (w < 0)
	                    continue;
	                u = 1 - v - w;
	                if (!(u < 0) && t > 0 && t < pickingCollision.rayEntryDistance) {
	                    collisionTriangleIndex = index / 3;
	                    pickingCollision.rayEntryDistance = t;
	                    pickingCollision.position = new Vector3D_1.Vector3D(cx, cy, cz);
	                    pickingCollision.normal = new Vector3D_1.Vector3D(nx, ny, nz);
	                    if (triangleElements.uvs) {
	                        var uvs = triangleElements.uvs.get(triangleElements.numVertices);
	                        var uvStride = triangleElements.uvs.stride;
	                        var uIndex = indices[index] * uvStride;
	                        var uv0 = new Vector3D_1.Vector3D(uvs[uIndex], uvs[uIndex + 1]);
	                        uIndex = indices[index + 1] * uvStride;
	                        var uv1 = new Vector3D_1.Vector3D(uvs[uIndex], uvs[uIndex + 1]);
	                        uIndex = indices[index + 2] * uvStride;
	                        var uv2 = new Vector3D_1.Vector3D(uvs[uIndex], uvs[uIndex + 1]);
	                        pickingCollision.uv = new Point_1.Point(u * uv0.x + v * uv1.x + w * uv2.x, u * uv0.y + v * uv1.y + w * uv2.y);
	                    }
	                    pickingCollision.elementIndex = collisionTriangleIndex;
	                    // if not looking for best hit, first found will do...
	                    if (!this._findClosestCollision)
	                        return true;
	                }
	            }
	        }
	        if (collisionTriangleIndex >= 0)
	            return true;
	        return false;
	    };
	    //
	    ///**
	    // * Tests a <code>CurveElements</code> object for a collision with the picking ray.
	    // *
	    // * @param triangleElements
	    // * @param material
	    // * @param pickingCollision
	    // * @returns {boolean}
	    // */
	    //public testCurveCollision(curveElements:CurveElements, material:MaterialBase, pickingCollision:PickingCollision, shortestCollisionDistance:number):boolean
	    //{
	    //	var rayPosition:Vector3D = pickingCollision.localRayPosition;
	    //	var rayDirection:Vector3D = pickingCollision.localRayDirection;
	    //
	    //	//project ray onto x/y plane to generate useful test points from mouse coordinates
	    //	//this will only work while all points lie on the x/y plane
	    //	var plane:Vector3D = new Vector3D(0,0,-1,0);
	    //
	    //	var result:Vector3D = new Vector3D();
	    //	var distance:number = plane.x * rayPosition.x + plane.y * rayPosition.y + plane.z * rayPosition.z + plane.w;//distance(position);
	    //	result.x = rayPosition.x - ( plane.x*distance);
	    //	result.y = rayPosition.y - ( plane.y*distance);
	    //	result.z = rayPosition.z - ( plane.z*distance);
	    //	var normal:Vector3D = new Vector3D(plane.x,plane.y,plane.z);
	    //	var t:number = -(rayPosition.dotProduct(normal))/(rayDirection.dotProduct(normal));
	    //	rayDirection.scaleBy(t);
	    //	var p:Vector3D = rayPosition.add(rayDirection);
	    //
	    //	var indices:Uint16Array = curveElements.indices.get(curveElements.numElements);
	    //	var collisionCurveIndex:number = -1;
	    //	var bothSides:boolean = material.bothSides;
	    //
	    //
	    //	var positions:Float32Array = curveElements.positions.get(curveElements.numVertices);
	    //	var posDim:number = curveElements.positions.dimensions;
	    //	var curves:Float32Array = curveElements.curves.get(curveElements.numVertices);
	    //	var curveDim:number = curveElements.curves.dimensions;
	    //	var uvs:ArrayBufferView = curveElements.uvs.get(curveElements.numVertices);
	    //	var uvDim:number = curveElements.uvs.dimensions;
	    //	var numIndices:number = indices.length;
	    //
	    //
	    //	for(var index:number = 0; index < numIndices; index+=3)
	    //	{
	    //		var id0:number = indices[index];
	    //		var id1:number = indices[index + 1] * posDim;
	    //		var id2:number = indices[index + 2] * posDim;
	    //
	    //		var ax:number = positions[id0 * posDim];
	    //		var ay:number = positions[id0 * posDim + 1];
	    //		var bx:number = positions[id1];
	    //		var by:number = positions[id1 + 1];
	    //		var cx:number = positions[id2];
	    //		var cy:number = positions[id2 + 1];
	    //
	    //		var curvex:number = curves[id0 * curveDim];
	    //		var az:number = positions[id0 * posDim + 2];
	    //
	    //		//console.log(ax, ay, bx, by, cx, cy);
	    //
	    //		//from a to p
	    //		var dx:number = ax - p.x;
	    //		var dy:number = ay - p.y;
	    //
	    //		//edge normal (a-b)
	    //		var nx:number = by - ay;
	    //		var ny:number = -(bx - ax);
	    //
	    //		//console.log(ax,ay,bx,by,cx,cy);
	    //
	    //		var dot:number = (dx * nx) + (dy * ny);
	    //		//console.log("dot a",dot);
	    //		if (dot > 0)
	    //			continue;
	    //
	    //		dx = bx - p.x;
	    //		dy = by - p.y;
	    //		nx = cy - by;
	    //		ny = -(cx - bx);
	    //
	    //		dot = (dx * nx) + (dy * ny);
	    //		//console.log("dot b",dot);
	    //		if (dot > 0)
	    //			continue;
	    //
	    //		dx = cx - p.x;
	    //		dy = cy - p.y;
	    //		nx = ay - cy;
	    //		ny = -(ax - cx);
	    //
	    //		dot = (dx * nx) + (dy * ny);
	    //		//console.log("dot c",dot);
	    //		if (dot > 0)
	    //			continue;
	    //
	    //		//check if not solid
	    //		if (curvex != 2) {
	    //
	    //			var v0x:number = bx - ax;
	    //			var v0y:number = by - ay;
	    //			var v1x:number = cx - ax;
	    //			var v1y:number = cy - ay;
	    //			var v2x:number = p.x - ax;
	    //			var v2y:number = p.y - ay;
	    //
	    //			var den:number = v0x * v1y - v1x * v0y;
	    //			var v:number = (v2x * v1y - v1x * v2y) / den;
	    //			var w:number = (v0x * v2y - v2x * v0y) / den;
	    //			var u:number = 1 - v - w;
	    //
	    //			var uu:number = 0.5 * v + w;// (0 * u) + (0.5 * v) + (1 * w);// (lerp(0, 0.5, v) + lerp(0.5, 1, w) + lerp(1, 0, u)) / 1.5;
	    //			var vv:number = w;// (0 * u) + (0 * v) + (1 * w);// (lerp(0, 1, w) + lerp(1, 0, u)) / 1;
	    //
	    //			var d:number = uu * uu - vv;
	    //
	    //			if ((d > 0 && az == -1) || (d < 0 && az == 1))
	    //				continue;
	    //		}
	    //		//TODO optimize away this pointless check as the distance is always the same
	    //		//also this stuff should only be calculated right before the return and not for each hit
	    //		if (distance < shortestCollisionDistance) {
	    //			shortestCollisionDistance = distance;
	    //			collisionCurveIndex = index/3;
	    //			pickingCollision.rayEntryDistance = distance;
	    //			pickingCollision.localPosition = p;
	    //			pickingCollision.localNormal = new Vector3D(0, 0, 1);
	    //			pickingCollision.uv = this._getCollisionUV(indices, uvs, index, v, w, u, uvDim);
	    //			pickingCollision.index = index;
	    //			//						pickingCollision.elementIndex = this.pGetSpriteGraphicIndex(renderable);
	    //
	    //			// if not looking for best hit, first found will do...
	    //			if (!this._findClosestCollision)
	    //				return true;
	    //		}
	    //	}
	    //
	    //	if (collisionCurveIndex >= 0)
	    //		return true;
	    //
	    //	return false;
	    //}
	    /**
	     * Tests a <code>LineElements</code> object for a collision with the picking ray.
	     *
	     * @param triangleElements
	     * @param material
	     * @param pickingCollision
	     * @returns {boolean}
	     */
	    JSPickingCollider.prototype.testLineCollision = function (lineElements, material, pickingCollision, count, offset) {
	        if (offset === void 0) { offset = 0; }
	        return false;
	    };
	    return JSPickingCollider;
	}());
	exports.JSPickingCollider = JSPickingCollider;


/***/ },
/* 551 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var RaycastPicker_1 = __webpack_require__(552);
	exports.RaycastPicker = RaycastPicker_1.RaycastPicker;


/***/ },
/* 552 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Vector3D_1 = __webpack_require__(34);
	/**
	 * Picks a 3d object from a view or scene by 3D raycast calculations.
	 * Performs an initial coarse boundary calculation to return a subset of entities whose bounding volumes intersect with the specified ray,
	 * then triggers an optional picking collider on individual renderable objects to further determine the precise values of the picking ray collision.
	 *
	 * @class away.pick.RaycastPicker
	 */
	var RaycastPicker = (function () {
	    /**
	     * Creates a new <code>RaycastPicker</code> object.
	     *
	     * @param findClosestCollision Determines whether the picker searches for the closest bounds collision along the ray,
	     * or simply returns the first collision encountered. Defaults to false.
	     */
	    function RaycastPicker(findClosestCollision) {
	        if (findClosestCollision === void 0) { findClosestCollision = false; }
	        this._entities = new Array();
	        /**
	         * @inheritDoc
	         */
	        this.onlyMouseEnabled = true;
	        this._findClosestCollision = findClosestCollision;
	    }
	    /**
	     * Returns true if the current node is at least partly in the frustum. If so, the partition node knows to pass on the traverser to its children.
	     *
	     * @param node The Partition3DNode object to frustum-test.
	     */
	    RaycastPicker.prototype.enterNode = function (node) {
	        return node.isIntersectingRay(this._rayPosition, this._rayDirection) && !node.isMask();
	    };
	    /**
	     * @inheritDoc
	     */
	    RaycastPicker.prototype.getCollision = function (rayPosition, rayDirection, view) {
	        this._rayPosition = rayPosition;
	        this._rayDirection = rayDirection;
	        // collect entities to test
	        view.traversePartitions(this);
	        //early out if no collisions detected
	        if (!this._entities.length)
	            return null;
	        var collision = this.getPickingCollision();
	        //discard entities
	        this._entities.length = 0;
	        return collision;
	    };
	    //		public getEntityCollision(position:Vector3D, direction:Vector3D, entities:Array<IEntity>):PickingCollision
	    //		{
	    //			this._numRenderables = 0;
	    //
	    //			var renderable:IEntity;
	    //			var l:number = entities.length;
	    //
	    //			for (var c:number = 0; c < l; c++) {
	    //				renderable = entities[c];
	    //
	    //				if (renderable.isIntersectingRay(position, direction))
	    //					this._renderables[this._numRenderables++] = renderable;
	    //			}
	    //
	    //			return this.getPickingCollision(this._raycastCollector);
	    //		}
	    RaycastPicker.prototype.setIgnoreList = function (entities) {
	        this._ignoredEntities = entities;
	    };
	    RaycastPicker.prototype.isIgnored = function (entity) {
	        if (this.onlyMouseEnabled && !entity._iIsMouseEnabled())
	            return true;
	        if (this._ignoredEntities) {
	            var len = this._ignoredEntities.length;
	            for (var i = 0; i < len; i++)
	                if (this._ignoredEntities[i] == entity)
	                    return true;
	        }
	        return false;
	    };
	    RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
	        return entity1._iPickingCollision.rayEntryDistance > entity2._iPickingCollision.rayEntryDistance ? 1 : -1;
	    };
	    RaycastPicker.prototype.getPickingCollision = function () {
	        // Sort entities from closest to furthest to reduce tests.
	        this._entities = this._entities.sort(this.sortOnNearT); // TODO - test sort filter in JS
	        // ---------------------------------------------------------------------
	        // Evaluate triangle collisions when needed.
	        // Replaces collision data provided by bounds collider with more precise data.
	        // ---------------------------------------------------------------------
	        this._bestCollision = null;
	        var entity;
	        var len = this._entities.length;
	        for (var i = 0; i < len; i++) {
	            entity = this._entities[i];
	            this._testCollision = entity._iPickingCollision;
	            if (this._bestCollision == null || this._testCollision.rayEntryDistance < this._bestCollision.rayEntryDistance) {
	                this._testCollider = entity.pickingCollider;
	                if (this._testCollider) {
	                    this._testCollision.rayEntryDistance = Number.MAX_VALUE;
	                    entity._acceptTraverser(this);
	                    // If a collision exists, update the collision data and stop all checks.
	                    if (this._bestCollision && !this._findClosestCollision)
	                        break;
	                }
	                else if (!this._testCollision.rayOriginIsInsideBounds) {
	                    // A bounds collision with no picking collider stops all checks.
	                    // Note: a bounds collision with a ray origin inside its bounds is ONLY ever used
	                    // to enable the detection of a corresponsding triangle collision.
	                    // Therefore, bounds collisions with a ray origin inside its bounds can be ignored
	                    // if it has been established that there is NO triangle collider to test
	                    this._bestCollision = this._testCollision;
	                    break;
	                }
	            }
	        }
	        if (this._bestCollision)
	            this.updatePosition(this._bestCollision);
	        return this._bestCollision;
	    };
	    RaycastPicker.prototype.updatePosition = function (pickingCollision) {
	        var collisionPos = pickingCollision.position || (pickingCollision.position = new Vector3D_1.Vector3D());
	        var rayDir = pickingCollision.rayDirection;
	        var rayPos = pickingCollision.rayPosition;
	        var t = pickingCollision.rayEntryDistance;
	        collisionPos.x = rayPos.x + t * rayDir.x;
	        collisionPos.y = rayPos.y + t * rayDir.y;
	        collisionPos.z = rayPos.z + t * rayDir.z;
	    };
	    RaycastPicker.prototype.dispose = function () {
	        //TODO
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyEntity = function (entity) {
	        if (!this.isIgnored(entity))
	            this._entities.push(entity);
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyRenderable = function (renderable) {
	        if (renderable._iTestCollision(this._testCollision, this._testCollider))
	            this._bestCollision = this._testCollision;
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyDirectionalLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyLightProbe = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applyPointLight = function (entity) {
	        //don't do anything here
	    };
	    /**
	     *
	     * @param entity
	     */
	    RaycastPicker.prototype.applySkybox = function (entity) {
	        //don't do anything here
	    };
	    return RaycastPicker;
	}());
	exports.RaycastPicker = RaycastPicker;


/***/ },
/* 553 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(554));


/***/ },
/* 554 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PrefabBase_1 = __webpack_require__(308);
	exports.PrefabBase = PrefabBase_1.PrefabBase;
	var PrimitiveCapsulePrefab_1 = __webpack_require__(309);
	exports.PrimitiveCapsulePrefab = PrimitiveCapsulePrefab_1.PrimitiveCapsulePrefab;
	var PrimitiveConePrefab_1 = __webpack_require__(311);
	exports.PrimitiveConePrefab = PrimitiveConePrefab_1.PrimitiveConePrefab;
	var PrimitiveCubePrefab_1 = __webpack_require__(313);
	exports.PrimitiveCubePrefab = PrimitiveCubePrefab_1.PrimitiveCubePrefab;
	var PrimitiveCylinderPrefab_1 = __webpack_require__(312);
	exports.PrimitiveCylinderPrefab = PrimitiveCylinderPrefab_1.PrimitiveCylinderPrefab;
	var PrimitivePlanePrefab_1 = __webpack_require__(314);
	exports.PrimitivePlanePrefab = PrimitivePlanePrefab_1.PrimitivePlanePrefab;
	var PrimitivePolygonPrefab_1 = __webpack_require__(555);
	exports.PrimitivePolygonPrefab = PrimitivePolygonPrefab_1.PrimitivePolygonPrefab;
	var PrimitivePrefabBase_1 = __webpack_require__(310);
	exports.PrimitivePrefabBase = PrimitivePrefabBase_1.PrimitivePrefabBase;
	var PrimitiveSpherePrefab_1 = __webpack_require__(315);
	exports.PrimitiveSpherePrefab = PrimitiveSpherePrefab_1.PrimitiveSpherePrefab;
	var PrimitiveTorusPrefab_1 = __webpack_require__(316);
	exports.PrimitiveTorusPrefab = PrimitiveTorusPrefab_1.PrimitiveTorusPrefab;


/***/ },
/* 555 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var PrimitiveCylinderPrefab_1 = __webpack_require__(312);
	/**
	 * A UV RegularPolygon primitive sprite.
	 */
	var PrimitivePolygonPrefab = (function (_super) {
	    __extends(PrimitivePolygonPrefab, _super);
	    /**
	     * Creates a new RegularPolygon disc object.
	     * @param radius The radius of the regular polygon
	     * @param sides Defines the number of sides of the regular polygon.
	     * @param yUp Defines whether the regular polygon should lay on the Y-axis (true) or on the Z-axis (false).
	     */
	    function PrimitivePolygonPrefab(material, elementsType, radius, sides, yUp) {
	        if (material === void 0) { material = null; }
	        if (elementsType === void 0) { elementsType = "triangle"; }
	        if (radius === void 0) { radius = 100; }
	        if (sides === void 0) { sides = 16; }
	        if (yUp === void 0) { yUp = true; }
	        _super.call(this, material, elementsType, radius, 0, 0, sides, 1, true, false, false, yUp);
	    }
	    Object.defineProperty(PrimitivePolygonPrefab.prototype, "radius", {
	        /**
	         * The radius of the regular polygon.
	         */
	        get: function () {
	            return this._pBottomRadius;
	        },
	        set: function (value) {
	            this._pBottomRadius = value;
	            this._pInvalidatePrimitive();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePolygonPrefab.prototype, "sides", {
	        /**
	         * The number of sides of the regular polygon.
	         */
	        get: function () {
	            return this._pSegmentsW;
	        },
	        set: function (value) {
	            this.setSegmentsW(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(PrimitivePolygonPrefab.prototype, "subdivisions", {
	        /**
	         * The number of subdivisions from the edge to the center of the regular polygon.
	         */
	        get: function () {
	            return this._pSegmentsH;
	        },
	        set: function (value) {
	            this.setSegmentsH(value);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return PrimitivePolygonPrefab;
	}(PrimitiveCylinderPrefab_1.PrimitiveCylinderPrefab));
	exports.PrimitivePolygonPrefab = PrimitivePolygonPrefab;


/***/ },
/* 556 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(557));


/***/ },
/* 557 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CoordinateSystem_1 = __webpack_require__(144);
	exports.CoordinateSystem = CoordinateSystem_1.CoordinateSystem;
	var FreeMatrixProjection_1 = __webpack_require__(153);
	exports.FreeMatrixProjection = FreeMatrixProjection_1.FreeMatrixProjection;
	var ObliqueNearPlaneProjection_1 = __webpack_require__(558);
	exports.ObliqueNearPlaneProjection = ObliqueNearPlaneProjection_1.ObliqueNearPlaneProjection;
	var OrthographicOffCenterProjection_1 = __webpack_require__(307);
	exports.OrthographicOffCenterProjection = OrthographicOffCenterProjection_1.OrthographicOffCenterProjection;
	var OrthographicProjection_1 = __webpack_require__(306);
	exports.OrthographicProjection = OrthographicProjection_1.OrthographicProjection;
	var PerspectiveProjection_1 = __webpack_require__(143);
	exports.PerspectiveProjection = PerspectiveProjection_1.PerspectiveProjection;
	var ProjectionBase_1 = __webpack_require__(145);
	exports.ProjectionBase = ProjectionBase_1.ProjectionBase;


/***/ },
/* 558 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Vector3D_1 = __webpack_require__(34);
	var ProjectionEvent_1 = __webpack_require__(142);
	var ProjectionBase_1 = __webpack_require__(145);
	var ObliqueNearPlaneProjection = (function (_super) {
	    __extends(ObliqueNearPlaneProjection, _super);
	    function ObliqueNearPlaneProjection(baseProjection, plane) {
	        var _this = this;
	        _super.call(this);
	        this.baseProjection = baseProjection;
	        this.plane = plane;
	        this._onProjectionMatrixChangedDelegate = function (event) { return _this.onProjectionMatrixChanged(event); };
	    }
	    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "frustumCorners", {
	        //@override
	        get: function () {
	            return this._baseProjection.frustumCorners;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "near", {
	        //@override
	        get: function () {
	            return this._baseProjection.near;
	        },
	        //@override
	        set: function (value) {
	            this._baseProjection.near = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "far", {
	        //@override
	        get: function () {
	            return this._baseProjection.far;
	        },
	        //@override
	        set: function (value) {
	            this._baseProjection.far = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "iAspectRatio", {
	        //@override
	        get: function () {
	            return this._baseProjection._iAspectRatio;
	        },
	        //@override
	        set: function (value) {
	            this._baseProjection._iAspectRatio = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "plane", {
	        get: function () {
	            return this._plane;
	        },
	        set: function (value) {
	            this._plane = value;
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "baseProjection", {
	        set: function (value) {
	            if (this._baseProjection) {
	                this._baseProjection.removeEventListener(ProjectionEvent_1.ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	            }
	            this._baseProjection = value;
	            if (this._baseProjection) {
	                this._baseProjection.addEventListener(ProjectionEvent_1.ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
	            }
	            this.pInvalidateMatrix();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    ObliqueNearPlaneProjection.prototype.onProjectionMatrixChanged = function (event) {
	        this.pInvalidateMatrix();
	    };
	    //@override
	    ObliqueNearPlaneProjection.prototype.pUpdateMatrix = function () {
	        this._pMatrix.copyFrom(this._baseProjection.matrix);
	        var cx = this._plane.a;
	        var cy = this._plane.b;
	        var cz = this._plane.c;
	        var cw = -this._plane.d + .05;
	        var signX = cx >= 0 ? 1 : -1;
	        var signY = cy >= 0 ? 1 : -1;
	        var p = new Vector3D_1.Vector3D(signX, signY, 1, 1);
	        var inverse = this._pMatrix.clone();
	        inverse.invert();
	        var q = inverse.transformVector(p);
	        this._pMatrix.copyRowTo(3, p);
	        var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);
	        this._pMatrix.copyRowFrom(2, new Vector3D_1.Vector3D(cx * a, cy * a, cz * a, cw * a));
	    };
	    return ObliqueNearPlaneProjection;
	}(ProjectionBase_1.ProjectionBase));
	exports.ObliqueNearPlaneProjection = ObliqueNearPlaneProjection;


/***/ },
/* 559 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(560));


/***/ },
/* 560 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var CompilerBase_1 = __webpack_require__(272);
	exports.CompilerBase = CompilerBase_1.CompilerBase;
	var LightingCompiler_1 = __webpack_require__(277);
	exports.LightingCompiler = LightingCompiler_1.LightingCompiler;
	var LightingShader_1 = __webpack_require__(270);
	exports.LightingShader = LightingShader_1.LightingShader;
	var RegisterPool_1 = __webpack_require__(274);
	exports.RegisterPool = RegisterPool_1.RegisterPool;
	var ShaderBase_1 = __webpack_require__(271);
	exports.ShaderBase = ShaderBase_1.ShaderBase;
	var ShaderRegisterCache_1 = __webpack_require__(273);
	exports.ShaderRegisterCache = ShaderRegisterCache_1.ShaderRegisterCache;
	var ShaderRegisterData_1 = __webpack_require__(276);
	exports.ShaderRegisterData = ShaderRegisterData_1.ShaderRegisterData;
	var ShaderRegisterElement_1 = __webpack_require__(275);
	exports.ShaderRegisterElement = ShaderRegisterElement_1.ShaderRegisterElement;


/***/ },
/* 561 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(562));


/***/ },
/* 562 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AntiAliasType_1 = __webpack_require__(563);
	exports.AntiAliasType = AntiAliasType_1.AntiAliasType;
	var Font_1 = __webpack_require__(354);
	exports.Font = Font_1.Font;
	var GridFitType_1 = __webpack_require__(564);
	exports.GridFitType = GridFitType_1.GridFitType;
	var TesselatedFontTable_1 = __webpack_require__(355);
	exports.TesselatedFontTable = TesselatedFontTable_1.TesselatedFontTable;
	var BitmapFontTable_1 = __webpack_require__(193);
	exports.BitmapFontTable = BitmapFontTable_1.BitmapFontTable;
	var TesselatedFontChar_1 = __webpack_require__(356);
	exports.TesselatedFontChar = TesselatedFontChar_1.TesselatedFontChar;
	var BitmapFontChar_1 = __webpack_require__(194);
	exports.BitmapFontChar = BitmapFontChar_1.BitmapFontChar;
	var TextFieldAutoSize_1 = __webpack_require__(565);
	exports.TextFieldAutoSize = TextFieldAutoSize_1.TextFieldAutoSize;
	var TextFieldType_1 = __webpack_require__(192);
	exports.TextFieldType = TextFieldType_1.TextFieldType;
	var TextFormat_1 = __webpack_require__(358);
	exports.TextFormat = TextFormat_1.TextFormat;
	var TextFormatAlign_1 = __webpack_require__(566);
	exports.TextFormatAlign = TextFormatAlign_1.TextFormatAlign;
	var TextInteractionMode_1 = __webpack_require__(567);
	exports.TextInteractionMode = TextInteractionMode_1.TextInteractionMode;
	var TextLineMetrics_1 = __webpack_require__(568);
	exports.TextLineMetrics = TextLineMetrics_1.TextLineMetrics;


/***/ },
/* 563 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The AntiAliasType class provides values for anti-aliasing in the
	 * away.text.TextField class.
	 */
	var AntiAliasType = (function () {
	    function AntiAliasType() {
	    }
	    /**
	     * Sets anti-aliasing to advanced anti-aliasing. Advanced anti-aliasing
	     * allows font faces to be rendered at very high quality at small sizes. It
	     * is best used with applications that have a lot of small text. Advanced
	     * anti-aliasing is not recommended for very large fonts(larger than 48
	     * points). This constant is used for the <code>antiAliasType</code> property
	     * in the TextField class. Use the syntax
	     * <code>AntiAliasType.ADVANCED</code>.
	     */
	    AntiAliasType.ADVANCED = "advanced";
	    /**
	     * Sets anti-aliasing to the anti-aliasing that is used in Flash Player 7 and
	     * earlier. This setting is recommended for applications that do not have a
	     * lot of text. This constant is used for the <code>antiAliasType</code>
	     * property in the TextField class. Use the syntax
	     * <code>AntiAliasType.NORMAL</code>.
	     */
	    AntiAliasType.NORMAL = "normal";
	    return AntiAliasType;
	}());
	exports.AntiAliasType = AntiAliasType;


/***/ },
/* 564 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The GridFitType class defines values for grid fitting in the TextField class.
	 */
	var GridFitType = (function () {
	    function GridFitType() {
	    }
	    /**
	     * Doesn't set grid fitting. Horizontal and vertical lines in the glyphs are
	     * not forced to the pixel grid. This constant is used in setting the
	     * <code>gridFitType</code> property of the TextField class. This is often a
	     * good setting for animation or for large font sizes. Use the syntax
	     * <code>GridFitType.NONE</code>.
	     */
	    GridFitType.NONE = "none";
	    /**
	     * Fits strong horizontal and vertical lines to the pixel grid. This constant
	     * is used in setting the <code>gridFitType</code> property of the TextField
	     * class. This setting only works for left-justified text fields and acts
	     * like the <code>GridFitType.SUBPIXEL</code> constant in static text. This
	     * setting generally provides the best readability for left-aligned text. Use
	     * the syntax <code>GridFitType.PIXEL</code>.
	     */
	    GridFitType.PIXEL = "pixel";
	    /**
	     * Fits strong horizontal and vertical lines to the sub-pixel grid on LCD
	     * monitors. (Red, green, and blue are actual pixels on an LCD screen.) This
	     * is often a good setting for right-aligned or center-aligned dynamic text,
	     * and it is sometimes a useful tradeoff for animation vs. text quality. This
	     * constant is used in setting the <code>gridFitType</code> property of the
	     * TextField class. Use the syntax <code>GridFitType.SUBPIXEL</code>.
	     */
	    GridFitType.SUBPIXEL = "subpixel";
	    return GridFitType;
	}());
	exports.GridFitType = GridFitType;


/***/ },
/* 565 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextFieldAutoSize class is an enumeration of constant values used in
	 * setting the <code>autoSize</code> property of the TextField class.
	 */
	var TextFieldAutoSize = (function () {
	    function TextFieldAutoSize() {
	    }
	    /**
	     * Specifies that the text is to be treated as center-justified text. Any
	     * resizing of a single line of a text field is equally distributed to both
	     * the right and left sides.
	     */
	    TextFieldAutoSize.CENTER = "center";
	    /**
	     * Specifies that the text is to be treated as left-justified text, meaning
	     * that the left side of the text field remains fixed and any resizing of a
	     * single line is on the right side.
	     */
	    TextFieldAutoSize.LEFT = "left";
	    /**
	     * Specifies that no resizing is to occur.
	     */
	    TextFieldAutoSize.NONE = "none";
	    /**
	     * Specifies that the text is to be treated as right-justified text, meaning
	     * that the right side of the text field remains fixed and any resizing of a
	     * single line is on the left side.
	     */
	    TextFieldAutoSize.RIGHT = "right";
	    return TextFieldAutoSize;
	}());
	exports.TextFieldAutoSize = TextFieldAutoSize;


/***/ },
/* 566 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextFormatAlign class provides values for text alignment in the
	 * TextFormat class.
	 */
	var TextFormatAlign = (function () {
	    function TextFormatAlign() {
	        /**
	         * Constant; centers the text in the text field. Use the syntax
	         * <code>TextFormatAlign.CENTER</code>.
	         */
	        this.CENTER = "center";
	        /**
	         * Constant; justifies text within the text field. Use the syntax
	         * <code>TextFormatAlign.JUSTIFY</code>.
	         */
	        this.JUSTIFY = "justify";
	        /**
	         * Constant; aligns text to the left within the text field. Use the syntax
	         * <code>TextFormatAlign.LEFT</code>.
	         */
	        this.LEFT = "left";
	        /**
	         * Constant; aligns text to the right within the text field. Use the syntax
	         * <code>TextFormatAlign.RIGHT</code>.
	         */
	        this.RIGHT = "right";
	    }
	    return TextFormatAlign;
	}());
	exports.TextFormatAlign = TextFormatAlign;


/***/ },
/* 567 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * A class that defines the Interactive mode of a text field object.
	 *
	 * @see away.entities.TextField#textInteractionMode
	 */
	var TextInteractionMode = (function () {
	    function TextInteractionMode() {
	    }
	    /**
	     * The text field's default interaction mode is NORMAL and it varies across
	     * platform. On Desktop, the normal mode implies that the text field is in
	     * scrollable + selection mode. On Mobile platforms like Android, normal mode
	     * implies that the text field can only be scrolled but the text can not be
	     * selected.
	     */
	    TextInteractionMode.NORMAL = "normal";
	    /**
	     * On mobile platforms like Android, the text field starts in normal mode
	     * (which implies scroll and non-selectable mode). The user can switch to
	     * selection mode through the in-built context menu of the text field object.
	     */
	    TextInteractionMode.SELECTION = "selection";
	    return TextInteractionMode;
	}());
	exports.TextInteractionMode = TextInteractionMode;


/***/ },
/* 568 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * The TextLineMetrics class contains information about the text position and
	 * measurements of a line of text within a text field. All measurements are in
	 * pixels. Objects of this class are returned by the
	 * <code>away.entities.TextField.getLineMetrics()</code> method.
	 */
	var TextLineMetrics = (function () {
	    /**
	     * Creates a TextLineMetrics object. The TextLineMetrics object contains
	     * information about the text metrics of a line of text in a text field.
	     * Objects of this class are returned by the
	     * away.entities.TextField.getLineMetrics() method.
	     *
	     * @param x           The left position of the first character in pixels.
	     * @param width       The width of the text of the selected lines (not
	     *                    necessarily the complete text) in pixels.
	     * @param height      The height of the text of the selected lines (not
	     *                    necessarily the complete text) in pixels.
	     * @param ascent      The length from the baseline to the top of the line
	     *                    height in pixels.
	     * @param descent     The length from the baseline to the bottom depth of
	     *                    the line in pixels.
	     * @param leading     The measurement of the vertical distance between the
	     *                    lines of text.
	     */
	    function TextLineMetrics(x, width, height, ascent, descent, leading) {
	        if (x === void 0) { x = NaN; }
	        if (width === void 0) { width = NaN; }
	        if (height === void 0) { height = NaN; }
	        if (ascent === void 0) { ascent = NaN; }
	        if (descent === void 0) { descent = NaN; }
	        if (leading === void 0) { leading = NaN; }
	    }
	    return TextLineMetrics;
	}());
	exports.TextLineMetrics = TextLineMetrics;


/***/ },
/* 569 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(570));


/***/ },
/* 570 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Merge_1 = __webpack_require__(571);
	exports.Merge = Merge_1.Merge;
	var ParticleGraphicsTransform_1 = __webpack_require__(572);
	exports.ParticleGraphicsTransform = ParticleGraphicsTransform_1.ParticleGraphicsTransform;


/***/ },
/* 571 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AttributesBuffer_1 = __webpack_require__(5);
	var Matrix3DUtils_1 = __webpack_require__(38);
	var TriangleElements_1 = __webpack_require__(179);
	var Sprite_1 = __webpack_require__(177);
	/**
	 *  Class Merge merges two or more static sprites into one.<code>Merge</code>
	 */
	var Merge = (function () {
	    /**
	     * @param    keepMaterial    [optional]    Determines if the merged object uses the recevier sprite material information or keeps its source material(s). Defaults to false.
	     * If false and receiver object has multiple materials, the last material found in receiver subsprites is applied to the merged subsprite(es).
	     * @param    disposeSources  [optional]    Determines if the sprite and geometry source(s) used for the merging are disposed. Defaults to false.
	     * If true, only receiver geometry and resulting sprite are kept in  memory.
	     * @param    objectSpace     [optional]    Determines if source sprite(es) is/are merged using objectSpace or worldspace. Defaults to false.
	     */
	    function Merge(keepMaterial, disposeSources, objectSpace) {
	        if (keepMaterial === void 0) { keepMaterial = false; }
	        if (disposeSources === void 0) { disposeSources = false; }
	        if (objectSpace === void 0) { objectSpace = false; }
	        this._keepMaterial = keepMaterial;
	        this._disposeSources = disposeSources;
	        this._objectSpace = objectSpace;
	    }
	    Object.defineProperty(Merge.prototype, "disposeSources", {
	        get: function () {
	            return this._disposeSources;
	        },
	        /**
	         * Determines if the sprite and geometry source(s) used for the merging are disposed. Defaults to false.
	         */
	        set: function (b) {
	            this._disposeSources = b;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Merge.prototype, "keepMaterial", {
	        get: function () {
	            return this._keepMaterial;
	        },
	        /**
	         * Determines if the material source(s) used for the merging are disposed. Defaults to false.
	         */
	        set: function (b) {
	            this._keepMaterial = b;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Merge.prototype, "objectSpace", {
	        get: function () {
	            return this._objectSpace;
	        },
	        /**
	         * Determines if source sprite(es) is/are merged using objectSpace or worldspace. Defaults to false.
	         */
	        set: function (b) {
	            this._objectSpace = b;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Merges all the children of a container into a single Sprite. If no Sprite object is found, method returns the receiver without modification.
	     *
	     * @param    receiver           The Sprite to receive the merged contents of the container.
	     * @param    objectContainer    The DisplayObjectContainer holding the sprites to be mergd.
	     *
	     * @return The merged Sprite instance.
	     */
	    Merge.prototype.applyToContainer = function (receiver, objectContainer) {
	        this.reset();
	        //collect container sprites
	        this.parseContainer(receiver, objectContainer);
	        //collect receiver
	        this.collect(receiver, false);
	        //merge to receiver
	        this.merge(receiver, this._disposeSources);
	    };
	    /**
	     * Merges all the sprites found in the Array&lt;Sprite&gt; into a single Sprite.
	     *
	     * @param    receiver    The Sprite to receive the merged contents of the sprites.
	     * @param    sprites      A series of Sprites to be merged with the reciever sprite.
	     */
	    Merge.prototype.applyToSprites = function (receiver, sprites) {
	        this.reset();
	        if (!sprites.length)
	            return;
	        //collect sprites in vector
	        for (var i = 0; i < sprites.length; i++)
	            if (sprites[i] != receiver)
	                this.collect(sprites[i], this._disposeSources);
	        //collect receiver
	        this.collect(receiver, false);
	        //merge to receiver
	        this.merge(receiver, this._disposeSources);
	    };
	    /**
	     *  Merges 2 sprites into one. It is recommand to use apply when 2 sprites are to be merged. If more need to be merged, use either applyToSprites or applyToContainer methods.
	     *
	     * @param    receiver    The Sprite to receive the merged contents of both sprites.
	     * @param    sprite        The Sprite to be merged with the receiver sprite
	     */
	    Merge.prototype.apply = function (receiver, sprite) {
	        this.reset();
	        //collect sprite
	        this.collect(sprite, this._disposeSources);
	        //collect receiver
	        this.collect(receiver, false);
	        //merge to receiver
	        this.merge(receiver, this._disposeSources);
	    };
	    Merge.prototype.reset = function () {
	        this._toDispose = new Array();
	        this._graphicVOs = new Array();
	    };
	    Merge.prototype.merge = function (destSprite, dispose) {
	        var i;
	        //var oldGraphics:Graphics;
	        var destGraphics;
	        var useSubMaterials;
	        //oldGraphics = destSprite.graphics.clone();
	        destGraphics = destSprite.graphics;
	        // Only apply materials directly to sub-sprites if necessary,
	        // i.e. if there is more than one material available.
	        useSubMaterials = (this._graphicVOs.length > 1);
	        for (i = 0; i < this._graphicVOs.length; i++) {
	            var elements = new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer());
	            elements.autoDeriveNormals = false;
	            elements.autoDeriveTangents = false;
	            var data = this._graphicVOs[i];
	            elements.setIndices(data.indices);
	            elements.setPositions(data.vertices);
	            elements.setNormals(data.normals);
	            elements.setTangents(data.tangents);
	            elements.setUVs(data.uvs);
	            if (this._keepMaterial && useSubMaterials)
	                destGraphics.addGraphic(elements, data.material);
	            else
	                destGraphics.addGraphic(elements);
	        }
	        if (this._keepMaterial && !useSubMaterials && this._graphicVOs.length)
	            destSprite.material = this._graphicVOs[0].material;
	        if (dispose) {
	            var len = this._toDispose.length;
	            for (var i; i < len; i++)
	                this._toDispose[i].dispose();
	        }
	        this._toDispose = null;
	    };
	    Merge.prototype.collect = function (sprite, dispose) {
	        var subIdx;
	        var calc;
	        for (subIdx = 0; subIdx < sprite.graphics.count; subIdx++) {
	            var i;
	            var len;
	            var iIdx, vIdx, nIdx, tIdx, uIdx;
	            var indexOffset;
	            var elements;
	            var vo;
	            var vertices;
	            var normals;
	            var tangents;
	            var ind;
	            elements = sprite.graphics.getGraphicAt(subIdx).elements;
	            // Get (or create) a VO for this material
	            vo = this.getGraphicData(sprite.graphics.getGraphicAt(subIdx).material);
	            // Vertices and normals are copied to temporary vectors, to be transformed
	            // before concatenated onto those of the data. This is unnecessary if no
	            // transformation will be performed, i.e. for object space merging.
	            vertices = (this._objectSpace) ? vo.vertices : new Array();
	            normals = (this._objectSpace) ? vo.normals : new Array();
	            tangents = (this._objectSpace) ? vo.tangents : new Array();
	            // Copy over vertex attributes
	            vIdx = vertices.length;
	            nIdx = normals.length;
	            tIdx = tangents.length;
	            uIdx = vo.uvs.length;
	            this.copyAttributes(elements.positions, vertices, elements.numVertices, vIdx);
	            this.copyAttributes(elements.normals, normals, elements.numVertices, nIdx);
	            this.copyAttributes(elements.tangents, tangents, elements.numVertices, tIdx);
	            this.copyAttributes(elements.uvs, vo.uvs, elements.numVertices, uIdx);
	            // Copy over triangle indices
	            indexOffset = (!this._objectSpace) ? vo.vertices.length / 3 : 0;
	            iIdx = vo.indices.length;
	            len = elements.numElements;
	            ind = elements.indices.get(len);
	            for (i = 0; i < len; i++) {
	                calc = i * 3;
	                vo.indices[iIdx++] = ind[calc] + indexOffset;
	                vo.indices[iIdx++] = ind[calc + 1] + indexOffset;
	                vo.indices[iIdx++] = ind[calc + 2] + indexOffset;
	            }
	            if (!this._objectSpace) {
	                sprite.sceneTransform.transformVectors(vertices, vertices);
	                Matrix3DUtils_1.Matrix3DUtils.deltaTransformVectors(sprite.sceneTransform, normals, normals);
	                Matrix3DUtils_1.Matrix3DUtils.deltaTransformVectors(sprite.sceneTransform, tangents, tangents);
	                // Copy vertex data from temporary (transformed) vectors
	                vIdx = vo.vertices.length;
	                nIdx = vo.normals.length;
	                tIdx = vo.tangents.length;
	                len = vertices.length;
	                for (i = 0; i < len; i++) {
	                    vo.vertices[vIdx++] = vertices[i];
	                    vo.normals[nIdx++] = normals[i];
	                    vo.tangents[tIdx++] = tangents[i];
	                }
	            }
	        }
	        if (dispose)
	            this._toDispose.push(sprite);
	    };
	    Merge.prototype.copyAttributes = function (attributes, array, count, startIndex) {
	        var vertices = attributes.get(count);
	        var dim = attributes.dimensions;
	        var stride = attributes.stride;
	        var len = count * stride;
	        for (var i = 0; i < len; i += stride)
	            for (var j = 0; j < dim; j++)
	                array[startIndex++] = vertices[i + j];
	    };
	    Merge.prototype.getGraphicData = function (material) {
	        var data;
	        if (this._keepMaterial) {
	            var i;
	            var len;
	            len = this._graphicVOs.length;
	            for (i = 0; i < len; i++) {
	                if (this._graphicVOs[i].material == material) {
	                    data = this._graphicVOs[i];
	                    break;
	                }
	            }
	        }
	        else if (this._graphicVOs.length) {
	            // If materials are not to be kept, all data can be
	            // put into a single VO, so return that one.
	            data = this._graphicVOs[0];
	        }
	        // No data (for this material) found, create new.
	        if (!data) {
	            data = new GraphicVO();
	            data.vertices = new Array();
	            data.normals = new Array();
	            data.tangents = new Array();
	            data.uvs = new Array();
	            data.indices = new Array();
	            data.material = material;
	            this._graphicVOs.push(data);
	        }
	        return data;
	    };
	    Merge.prototype.parseContainer = function (receiver, object) {
	        var child;
	        var i;
	        if (object instanceof Sprite_1.Sprite && object != receiver)
	            this.collect(object, this._disposeSources);
	        for (i = 0; i < object.numChildren; ++i) {
	            child = object.getChildAt(i);
	            this.parseContainer(receiver, child);
	        }
	    };
	    return Merge;
	}());
	exports.Merge = Merge;
	var GraphicVO = (function () {
	    function GraphicVO() {
	    }
	    return GraphicVO;
	}());
	exports.GraphicVO = GraphicVO;


/***/ },
/* 572 */
/***/ function(module, exports) {

	"use strict";
	/**
	 * ...
	 */
	var ParticleGraphicsTransform = (function () {
	    function ParticleGraphicsTransform() {
	    }
	    Object.defineProperty(ParticleGraphicsTransform.prototype, "vertexTransform", {
	        get: function () {
	            return this._defaultVertexTransform;
	        },
	        set: function (value) {
	            this._defaultVertexTransform = value;
	            this._defaultInvVertexTransform = value.clone();
	            this._defaultInvVertexTransform.invert();
	            this._defaultInvVertexTransform.transpose();
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleGraphicsTransform.prototype, "UVTransform", {
	        get: function () {
	            return this._defaultUVTransform;
	        },
	        set: function (value) {
	            this._defaultUVTransform = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(ParticleGraphicsTransform.prototype, "invVertexTransform", {
	        get: function () {
	            return this._defaultInvVertexTransform;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    return ParticleGraphicsTransform;
	}());
	exports.ParticleGraphicsTransform = ParticleGraphicsTransform;


/***/ },
/* 573 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(574));


/***/ },
/* 574 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Keyboard_1 = __webpack_require__(575);
	exports.Keyboard = Keyboard_1.Keyboard;


/***/ },
/* 575 */
/***/ function(module, exports) {

	"use strict";
	var Keyboard = (function () {
	    function Keyboard() {
	    }
	    /**
	     * Constant associated with the key code value for the A key (65).
	     */
	    Keyboard.A = 65;
	    /**
	     * Constant associated with the key code value for the Alternate (Option) key  (18).
	     */
	    Keyboard.ALTERNATE = 18;
	    /**
	     * Select the audio mode
	     */
	    Keyboard.AUDIO = 0x01000017;
	    /**
	     * Constant associated with the key code value for the B key (66).
	     */
	    Keyboard.B = 66;
	    /**
	     * Return to previous page in application
	     */
	    Keyboard.BACK = 0x01000016;
	    /**
	     * Constant associated with the key code value for the ` key (192).
	     */
	    Keyboard.BACKQUOTE = 192;
	    /**
	     * Constant associated with the key code value for the \ key (220).
	     */
	    Keyboard.BACKSLASH = 220;
	    /**
	     * Constant associated with the key code value for the Backspace key (8).
	     */
	    Keyboard.BACKSPACE = 8;
	    /**
	     * Blue function key button
	     */
	    Keyboard.BLUE = 0x01000003;
	    /**
	     * Constant associated with the key code value for the C key (67).
	     */
	    Keyboard.C = 67;
	    /**
	     * Constant associated with the key code value for the Caps Lock key (20).
	     */
	    Keyboard.CAPS_LOCK = 20;
	    /**
	     * Channel down
	     */
	    Keyboard.CHANNEL_DOWN = 0x01000005;
	    /**
	     * Channel up
	     */
	    Keyboard.CHANNEL_UP = 0x01000005;
	    /**
	     * Constant associated with the key code value for the , key (188).
	     */
	    Keyboard.COMMA = 188;
	    /**
	     * Constant associated with the Mac command key (15). This constant is
	     * currently only used for setting menu key equivalents.
	     */
	    Keyboard.COMMAND = 15;
	    /**
	     * Constant associated with the key code value for the Control key (17).
	     */
	    Keyboard.CONTROL = 17;
	    /**
	     * Constant associated with the key code value for the D key (68).
	     */
	    Keyboard.D = 68;
	    /**
	     * Constant associated with the key code value for the Delete key (46).
	     */
	    Keyboard.DELETE = 46;
	    /**
	     * Constant associated with the key code value for the Down Arrow key (40).
	     */
	    Keyboard.DOWN = 40;
	    /**
	     * Engage DVR application mode
	     */
	    Keyboard.DVR = 0x01000019;
	    /**
	     * Constant associated with the key code value for the E key (69).
	     */
	    Keyboard.E = 69;
	    /**
	     * Constant associated with the key code value for the End key (35).
	     */
	    Keyboard.END = 35;
	    /**
	     * Constant associated with the key code value for the Enter key (13).
	     */
	    Keyboard.ENTER = 13;
	    /**
	     * Constant associated with the key code value for the = key (187).
	     */
	    Keyboard.EQUAL = 187;
	    /**
	     * Constant associated with the key code value for the Escape key (27).
	     */
	    Keyboard.ESCAPE = 27;
	    /**
	     * Exits current application mode
	     */
	    Keyboard.EXIT = 0x01000015;
	    /**
	     * Constant associated with the key code value for the F key (70).
	     */
	    Keyboard.F = 70;
	    /**
	     * Constant associated with the key code value for the F1 key (112).
	     */
	    Keyboard.F1 = 112;
	    /**
	     * Constant associated with the key code value for the F10 key (121).
	     */
	    Keyboard.F10 = 121;
	    /**
	     * Constant associated with the key code value for the F11 key (122).
	     */
	    Keyboard.F11 = 122;
	    /**
	     * Constant associated with the key code value for the F12 key (123).
	     */
	    Keyboard.F12 = 123;
	    /**
	     * Constant associated with the key code value for the F13 key (124).
	     */
	    Keyboard.F13 = 124;
	    /**
	     * Constant associated with the key code value for the F14 key (125).
	     */
	    Keyboard.F14 = 125;
	    /**
	     * Constant associated with the key code value for the F15 key (126).
	     */
	    Keyboard.F15 = 126;
	    /**
	     * Constant associated with the key code value for the F2 key (113).
	     */
	    Keyboard.F2 = 113;
	    /**
	     * Constant associated with the key code value for the F3 key (114).
	     */
	    Keyboard.F3 = 114;
	    /**
	     * Constant associated with the key code value for the F4 key (115).
	     */
	    Keyboard.F4 = 115;
	    /**
	     * Constant associated with the key code value for the F5 key (116).
	     */
	    Keyboard.F5 = 116;
	    /**
	     * Constant associated with the key code value for the F6 key (117).
	     */
	    Keyboard.F6 = 117;
	    /**
	     * Constant associated with the key code value for the F7 key (118).
	     */
	    Keyboard.F7 = 118;
	    /**
	     * Constant associated with the key code value for the F8 key (119).
	     */
	    Keyboard.F8 = 119;
	    /**
	     * Constant associated with the key code value for the F9 key (120).
	     */
	    Keyboard.F9 = 120;
	    /**
	     * Engage fast-forward transport mode
	     */
	    Keyboard.FAST_FORWARD = 0x0100000A;
	    /**
	     * Constant associated with the key code value for the G key (71).
	     */
	    Keyboard.G = 71;
	    /**
	     * Green function key button
	     */
	    Keyboard.GREEN = 0x01000001;
	    /**
	     * Engage program guide
	     */
	    Keyboard.GUIDE = 0x01000014;
	    /**
	     * Constant associated with the key code value for the H key (72).
	     */
	    Keyboard.H = 72;
	    /**
	     * Engage help application or context-sensitive help
	     */
	    Keyboard.HELP = 0x0100001D;
	    /**
	     * Constant associated with the key code value for the Home key (36).
	     */
	    Keyboard.HOME = 36;
	    /**
	     * Constant associated with the key code value for the I key (73).
	     */
	    Keyboard.I = 73;
	    /**
	     * Info button
	     */
	    Keyboard.INFO = 0x01000013;
	    /**
	     * Cycle input
	     */
	    Keyboard.INPUT = 0x0100001B;
	    /**
	     * Constant associated with the key code value for the Insert key (45).
	     */
	    Keyboard.INSERT = 45;
	    /**
	     * Constant associated with the key code value for the J key (74).
	     */
	    Keyboard.J = 74;
	    /**
	     * Constant associated with the key code value for the K key (75).
	     */
	    Keyboard.K = 75;
	    /**
	     * The Begin key
	     */
	    Keyboard.KEYNAME_BEGIN = "Begin";
	    /**
	     * The Break key
	     */
	    Keyboard.KEYNAME_BREAK = "Break";
	    /**
	     * The Clear Display key
	     */
	    Keyboard.KEYNAME_CLEARDISPLAY = "ClrDsp";
	    /**
	     * The Clear Line key
	     */
	    Keyboard.KEYNAME_CLEARLINE = "ClrLn";
	    /**
	     * The Delete key
	     */
	    Keyboard.KEYNAME_DELETE = "Delete";
	    /**
	     * The Delete Character key
	     */
	    Keyboard.KEYNAME_DELETECHAR = "DelChr";
	    /**
	     * The Delete Line key
	     */
	    Keyboard.KEYNAME_DELETELINE = "DelLn";
	    /**
	     * The down arrow
	     */
	    Keyboard.KEYNAME_DOWNARROW = "Down";
	    /**
	     * The End key
	     */
	    Keyboard.KEYNAME_END = "End";
	    /**
	     * The Execute key
	     */
	    Keyboard.KEYNAME_EXECUTE = "Exec";
	    /**
	     * The F1 key
	     */
	    Keyboard.KEYNAME_F1 = "F1";
	    /**
	     * The F10 key
	     */
	    Keyboard.KEYNAME_F10 = "F10";
	    /**
	     * The F11 key
	     */
	    Keyboard.KEYNAME_F11 = "F11";
	    /**
	     * The F12 key
	     */
	    Keyboard.KEYNAME_F12 = "F12";
	    /**
	     * The F13 key
	     */
	    Keyboard.KEYNAME_F13 = "F13";
	    /**
	     * The F14 key
	     */
	    Keyboard.KEYNAME_F14 = "F14";
	    /**
	     * The F15 key
	     */
	    Keyboard.KEYNAME_F15 = "F15";
	    /**
	     * The F16 key
	     */
	    Keyboard.KEYNAME_F16 = "F16";
	    /**
	     * The F17 key
	     */
	    Keyboard.KEYNAME_F17 = "F17";
	    /**
	     * The F18 key
	     */
	    Keyboard.KEYNAME_F18 = "F18";
	    /**
	     * The F19 key
	     */
	    Keyboard.KEYNAME_F19 = "F19";
	    /**
	     * The F2 key
	     */
	    Keyboard.KEYNAME_F2 = "F2";
	    /**
	     * The F20 key
	     */
	    Keyboard.KEYNAME_F20 = "F20";
	    /**
	     * The F21 key
	     */
	    Keyboard.KEYNAME_F21 = "F21";
	    /**
	     * The F22 key
	     */
	    Keyboard.KEYNAME_F22 = "F22";
	    /**
	     * The F23 key
	     */
	    Keyboard.KEYNAME_F23 = "F23";
	    /**
	     * The F24 key
	     */
	    Keyboard.KEYNAME_F24 = "F24";
	    /**
	     * The F25 key
	     */
	    Keyboard.KEYNAME_F25 = "F25";
	    /**
	     * The F26 key
	     */
	    Keyboard.KEYNAME_F26 = "F26";
	    /**
	     * The F27 key
	     */
	    Keyboard.KEYNAME_F27 = "F27";
	    /**
	     * The F28 key
	     */
	    Keyboard.KEYNAME_F28 = "F28";
	    /**
	     * The F29 key
	     */
	    Keyboard.KEYNAME_F29 = "F29";
	    /**
	     * The F3 key
	     */
	    Keyboard.KEYNAME_F3 = "F3";
	    /**
	     * The F30 key
	     */
	    Keyboard.KEYNAME_F30 = "F30";
	    /**
	     * The F31 key
	     */
	    Keyboard.KEYNAME_F31 = "F31";
	    /**
	     * The F32 key
	     */
	    Keyboard.KEYNAME_F32 = "F32";
	    /**
	     * The F33 key
	     */
	    Keyboard.KEYNAME_F33 = "F33";
	    /**
	     * The F34 key
	     */
	    Keyboard.KEYNAME_F34 = "F34";
	    /**
	     * The F35 key
	     */
	    Keyboard.KEYNAME_F35 = "F35";
	    /**
	     * The F4 key
	     */
	    Keyboard.KEYNAME_F4 = "F4";
	    /**
	     * The F5 key
	     */
	    Keyboard.KEYNAME_F5 = "F5";
	    /**
	     * The F6 key
	     */
	    Keyboard.KEYNAME_F6 = "F6";
	    /**
	     * The F7 key
	     */
	    Keyboard.KEYNAME_F7 = "F7";
	    /**
	     * The F8 key
	     */
	    Keyboard.KEYNAME_F8 = "F8";
	    /**
	     * The F9 key
	     */
	    Keyboard.KEYNAME_F9 = "F9";
	    /**
	     * The Find key
	     */
	    Keyboard.KEYNAME_FIND = "Find";
	    /**
	     * The Help key
	     */
	    Keyboard.KEYNAME_HELP = "Help";
	    /**
	     * The Home key
	     */
	    Keyboard.KEYNAME_HOME = "Home";
	    /**
	     * The Insert key
	     */
	    Keyboard.KEYNAME_INSERT = "Insert";
	    /**
	     * The Insert Character key
	     */
	    Keyboard.KEYNAME_INSERTCHAR = "InsChr";
	    /**
	     * The Insert Line key
	     */
	    Keyboard.KEYNAME_INSERTLINE = "LnsLn";
	    /**
	     * The left arrow
	     */
	    Keyboard.KEYNAME_LEFTARROW = "Left";
	    /**
	     * The Menu key
	     */
	    Keyboard.KEYNAME_MENU = "Menu";
	    /**
	     * The Mode Switch key
	     */
	    Keyboard.KEYNAME_MODESWITCH = "ModeSw";
	    /**
	     * The Next key
	     */
	    Keyboard.KEYNAME_NEXT = "Next";
	    /**
	     * The Page Down key
	     */
	    Keyboard.KEYNAME_PAGEDOWN = "PgDn";
	    /**
	     * The Page Up key
	     */
	    Keyboard.KEYNAME_PAGEUP = "PgUp";
	    /**
	     * The Pause key
	     */
	    Keyboard.KEYNAME_PAUSE = "Pause";
	    /**
	     * The Previous key
	     */
	    Keyboard.KEYNAME_PREV = "Prev";
	    /**
	     * The PRINT key
	     */
	    Keyboard.KEYNAME_PRINT = "Print";
	    /**
	     * The PRINT Screen
	     */
	    Keyboard.KEYNAME_PRINTSCREEN = "PrntScrn";
	    /**
	     * The Redo key
	     */
	    Keyboard.KEYNAME_REDO = "Redo";
	    /**
	     * The Reset key
	     */
	    Keyboard.KEYNAME_RESET = "Reset";
	    /**
	     * The right arrow
	     */
	    Keyboard.KEYNAME_RIGHTARROW = "Right";
	    /**
	     * The Scroll Lock key
	     */
	    Keyboard.KEYNAME_SCROLLLOCK = "ScrlLck";
	    /**
	     * The Select key
	     */
	    Keyboard.KEYNAME_SELECT = "Select";
	    /**
	     * The Stop key
	     */
	    Keyboard.KEYNAME_STOP = "Stop";
	    /**
	     * The System Request key
	     */
	    Keyboard.KEYNAME_SYSREQ = "SysReq";
	    /**
	     * The System key
	     */
	    Keyboard.KEYNAME_SYSTEM = "Sys";
	    /**
	     * The Undo key
	     */
	    Keyboard.KEYNAME_UNDO = "Undo";
	    /**
	     * The up arrow
	     */
	    Keyboard.KEYNAME_UPARROW = "Up";
	    /**
	     * The User key
	     */
	    Keyboard.KEYNAME_USER = "User";
	    /**
	     * Constant associated with the key code value for the L key (76).
	     */
	    Keyboard.L = 76;
	    /**
	     * Watch last channel or show watched
	     */
	    Keyboard.LAST = 0x01000011;
	    /**
	     * Constant associated with the key code value for the Left Arrow key (37).
	     */
	    Keyboard.LEFT = 37;
	    /**
	     * Constant associated with the key code value for the [ key (219).
	     */
	    Keyboard.LEFTBRACKET = 219;
	    /**
	     * Return to live [position in broadcast]
	     */
	    Keyboard.LIVE = 0x01000010;
	    /**
	     * Constant associated with the key code value for the M key (77).
	     */
	    Keyboard.M = 77;
	    /**
	     * Engage "Master Shell" e.g. TiVo or other vendor button
	     */
	    Keyboard.MASTER_SHELL = 0x0100001E;
	    /**
	     * Engage menu
	     */
	    Keyboard.MENU = 0x01000012;
	    /**
	     * Constant associated with the key code value for the - key (189).
	     */
	    Keyboard.MINUS = 189;
	    /**
	     * Constant associated with the key code value for the N key (78).
	     */
	    Keyboard.N = 78;
	    /**
	     * Skip to next track or chapter
	     */
	    Keyboard.NEXT = 0x0100000E;
	    /**
	     * Constant associated with the key code value for the 0 key (48).
	     */
	    Keyboard.NUMBER_0 = 48;
	    /**
	     * Constant associated with the key code value for the 1 key (49).
	     */
	    Keyboard.NUMBER_1 = 49;
	    /**
	     * Constant associated with the key code value for the 2 key (50).
	     */
	    Keyboard.NUMBER_2 = 50;
	    /**
	     * Constant associated with the key code value for the 3 key (51).
	     */
	    Keyboard.NUMBER_3 = 51;
	    /**
	     * Constant associated with the key code value for the 4 key (52).
	     */
	    Keyboard.NUMBER_4 = 52;
	    /**
	     * Constant associated with the key code value for the 5 key (53).
	     */
	    Keyboard.NUMBER_5 = 53;
	    /**
	     * Constant associated with the key code value for the 6 key (54).
	     */
	    Keyboard.NUMBER_6 = 54;
	    /**
	     * Constant associated with the key code value for the 7 key (55).
	     */
	    Keyboard.NUMBER_7 = 55;
	    /**
	     * Constant associated with the key code value for the 8 key (56).
	     */
	    Keyboard.NUMBER_8 = 56;
	    /**
	     * Constant associated with the key code value for the 9 key (57).
	     */
	    Keyboard.NUMBER_9 = 57;
	    /**
	     * Constant associated with the pseudo-key code for the the number pad (21). Use to set numpad modifier on key equivalents
	     */
	    Keyboard.NUMPAD = 21;
	    /**
	     * Constant associated with the key code value for the number 0 key on the number pad (96).
	     */
	    Keyboard.NUMPAD_0 = 96;
	    /**
	     * Constant associated with the key code value for the number 1 key on the number pad (97).
	     */
	    Keyboard.NUMPAD_1 = 97;
	    /**
	     * Constant associated with the key code value for the number 2 key on the number pad (98).
	     */
	    Keyboard.NUMPAD_2 = 98;
	    /**
	     * Constant associated with the key code value for the number 3 key on the number pad (99).
	     */
	    Keyboard.NUMPAD_3 = 99;
	    /**
	     * Constant associated with the key code value for the number 4 key on the number pad (100).
	     */
	    Keyboard.NUMPAD_4 = 100;
	    /**
	     * Constant associated with the key code value for the number 5 key on the number pad (101).
	     */
	    Keyboard.NUMPAD_5 = 101;
	    /**
	     * Constant associated with the key code value for the number 6 key on the number pad (102).
	     */
	    Keyboard.NUMPAD_6 = 102;
	    /**
	     * Constant associated with the key code value for the number 7 key on the number pad (103).
	     */
	    Keyboard.NUMPAD_7 = 103;
	    /**
	     * Constant associated with the key code value for the number 8 key on the number pad (104).
	     */
	    Keyboard.NUMPAD_8 = 104;
	    /**
	     * Constant associated with the key code value for the number 9 key on the number pad (105).
	     */
	    Keyboard.NUMPAD_9 = 105;
	    /**
	     * Constant associated with the key code value for the addition key on the number pad (107).
	     */
	    Keyboard.NUMPAD_ADD = 107;
	    /**
	     * Constant associated with the key code value for the decimal key on the number pad (110).
	     */
	    Keyboard.NUMPAD_DECIMAL = 110;
	    /**
	     * Constant associated with the key code value for the division key on the number pad (111).
	     */
	    Keyboard.NUMPAD_DIVIDE = 111;
	    /**
	     * Constant associated with the key code value for the Enter key on the number pad (108).
	     */
	    Keyboard.NUMPAD_ENTER = 108;
	    /**
	     * Constant associated with the key code value for the multiplication key on the number pad (106).
	     */
	    Keyboard.NUMPAD_MULTIPLY = 106;
	    /**
	     * Constant associated with the key code value for the subtraction key on the number pad (109).
	     */
	    Keyboard.NUMPAD_SUBTRACT = 109;
	    /**
	     * Constant associated with the key code value for the O key (79).
	     */
	    Keyboard.O = 79;
	    /**
	     * Constant associated with the key code value for the P key (80).
	     */
	    Keyboard.P = 80;
	    /**
	     * Constant associated with the key code value for the Page Down key (34).
	     */
	    Keyboard.PAGE_DOWN = 34;
	    /**
	     * Constant associated with the key code value for the Page Up key (33).
	     */
	    Keyboard.PAGE_UP = 33;
	    /**
	     * Engage pause transport mode
	     */
	    Keyboard.PAUSE = 0x01000008;
	    /**
	     * Constant associated with the key code value for the . key (190).
	     */
	    Keyboard.PERIOD = 190;
	    /**
	     * Engage play transport mode
	     */
	    Keyboard.PLAY = 0x01000007;
	    /**
	     * Skip to previous track or chapter
	     */
	    Keyboard.PREVIOUS = 0x0100000F;
	    /**
	     * Constant associated with the key code value for the Q key (81).
	     */
	    Keyboard.Q = 81;
	    /**
	     * Constant associated with the key code value for the ' key (222).
	     */
	    Keyboard.QUOTE = 222;
	    /**
	     * Constant associated with the key code value for the R key (82).
	     */
	    Keyboard.R = 82;
	    /**
	     * Record item or engage record transport mode
	     */
	    Keyboard.RECORD = 0x01000006;
	    /**
	     * Red function key button
	     */
	    Keyboard.RED = 0x01000000;
	    /**
	     * Engage rewind transport mode
	     */
	    Keyboard.REWIND = 0x0100000B;
	    /**
	     * Constant associated with the key code value for the Right Arrow key (39).
	     */
	    Keyboard.RIGHT = 39;
	    /**
	     * Constant associated with the key code value for the ] key (221).
	     */
	    Keyboard.RIGHTBRACKET = 221;
	    /**
	     * Constant associated with the key code value for the S key (83).
	     */
	    Keyboard.S = 83;
	    /**
	     * Search button
	     */
	    Keyboard.SEARCH = 0x0100001F;
	    /**
	     * Constant associated with the key code value for the ; key (186).
	     */
	    Keyboard.SEMICOLON = 186;
	    /**
	     * Engage setup application or menu
	     */
	    Keyboard.SETUP = 0x0100001C;
	    /**
	     * Constant associated with the key code value for the Shift key (16).
	     */
	    Keyboard.SHIFT = 16;
	    /**
	     * Quick skip backward (usually 7-10 seconds)
	     */
	    Keyboard.SKIP_BACKWARD = 0x0100000D;
	    /**
	     * Quick skip ahead (usually 30 seconds)
	     */
	    Keyboard.SKIP_FORWARD = 0x0100000C;
	    /**
	     * Constant associated with the key code value for the / key (191).
	     */
	    Keyboard.SLASH = 191;
	    /**
	     * Constant associated with the key code value for the Spacebar (32).
	     */
	    Keyboard.SPACE = 32;
	    /**
	     * Engage stop transport mode
	     */
	    Keyboard.STOP = 0x01000009;
	    /**
	     * Toggle subtitles
	     */
	    Keyboard.SUBTITLE = 0x01000018;
	    /**
	     * Constant associated with the key code value for the T key (84).
	     */
	    Keyboard.T = 84;
	    /**
	     * Constant associated with the key code value for the Tab key (9).
	     */
	    Keyboard.TAB = 9;
	    /**
	     * Constant associated with the key code value for the U key (85).
	     */
	    Keyboard.U = 85;
	    /**
	     * Constant associated with the key code value for the Up Arrow key (38).
	     */
	    Keyboard.UP = 38;
	    /**
	     * Constant associated with the key code value for the V key (86).
	     */
	    Keyboard.V = 86;
	    /**
	     * Engage video-on-demand
	     */
	    Keyboard.VOD = 0x0100001A;
	    /**
	     * Constant associated with the key code value for the W key (87).
	     */
	    Keyboard.W = 87;
	    /**
	     * Constant associated with the key code value for the X key (88).
	     */
	    Keyboard.X = 88;
	    /**
	     * Constant associated with the key code value for the Y key (89).
	     */
	    Keyboard.Y = 89;
	    /**
	     * Yellow function key button
	     */
	    Keyboard.YELLOW = 0x01000002;
	    /**
	     * Constant associated with the key code value for the Z key (90).
	     */
	    Keyboard.Z = 90;
	    return Keyboard;
	}());
	exports.Keyboard = Keyboard;


/***/ },
/* 576 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	function __export(m) {
	    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
	}
	__export(__webpack_require__(577));
	__export(__webpack_require__(581));
	__export(__webpack_require__(583));


/***/ },
/* 577 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var BitmapImageUtils_1 = __webpack_require__(99);
	exports.BitmapImageUtils = BitmapImageUtils_1.BitmapImageUtils;
	var ByteArray_1 = __webpack_require__(292);
	exports.ByteArray = ByteArray_1.ByteArray;
	var ByteArrayBase_1 = __webpack_require__(87);
	exports.ByteArrayBase = ByteArrayBase_1.ByteArrayBase;
	var ByteArrayBuffer_1 = __webpack_require__(578);
	exports.ByteArrayBuffer = ByteArrayBuffer_1.ByteArrayBuffer;
	var ColorUtils_1 = __webpack_require__(28);
	exports.ColorUtils = ColorUtils_1.ColorUtils;
	var CSS_1 = __webpack_require__(59);
	exports.CSS = CSS_1.CSS;
	var Debug_1 = __webpack_require__(579);
	exports.Debug = Debug_1.Debug;
	var Extensions_1 = __webpack_require__(580);
	exports.Extensions = Extensions_1.Extensions;
	var getTimer_1 = __webpack_require__(294);
	exports.getTimer = getTimer_1.getTimer;
	var ImageUtils_1 = __webpack_require__(98);
	exports.ImageUtils = ImageUtils_1.ImageUtils;
	var MipmapGenerator_1 = __webpack_require__(391);
	exports.MipmapGenerator = MipmapGenerator_1.MipmapGenerator;
	var RequestAnimationFrame_1 = __webpack_require__(324);
	exports.RequestAnimationFrame = RequestAnimationFrame_1.RequestAnimationFrame;
	var Timer_1 = __webpack_require__(293);
	exports.Timer = Timer_1.Timer;
	var XmlUtils_1 = __webpack_require__(299);
	exports.XmlUtils = XmlUtils_1.XmlUtils;


/***/ },
/* 578 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var ByteArrayBase_1 = __webpack_require__(87);
	var ByteArrayBuffer = (function (_super) {
	    __extends(ByteArrayBuffer, _super);
	    function ByteArrayBuffer() {
	        _super.call(this);
	        this._bytes = [];
	        this._mode = "Array";
	    }
	    ByteArrayBuffer.prototype.writeByte = function (b) {
	        var bi = ~~b;
	        this._bytes[this.position++] = bi;
	        if (this.position > this.length) {
	            this.length = this.position;
	        }
	    };
	    ByteArrayBuffer.prototype.readByte = function () {
	        if (this.position >= this.length) {
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        }
	        return this._bytes[this.position++];
	    };
	    ByteArrayBuffer.prototype.writeUnsignedByte = function (b) {
	        var bi = ~~b;
	        this._bytes[this.position++] = bi & 0xff;
	        if (this.position > this.length) {
	            this.length = this.position;
	        }
	    };
	    ByteArrayBuffer.prototype.readUnsignedByte = function () {
	        if (this.position >= this.length) {
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        }
	        return this._bytes[this.position++];
	    };
	    ByteArrayBuffer.prototype.writeUnsignedShort = function (b) {
	        var bi = ~~b;
	        this._bytes[this.position++] = bi & 0xff;
	        this._bytes[this.position++] = (bi >> 8) & 0xff;
	        if (this.position > this.length) {
	            this.length = this.position;
	        }
	    };
	    ByteArrayBuffer.prototype.readUnsignedShort = function () {
	        if (this.position + 2 > this.length)
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        var r = this._bytes[this.position] | (this._bytes[this.position + 1] << 8);
	        this.position += 2;
	        return r;
	    };
	    ByteArrayBuffer.prototype.writeUnsignedInt = function (b) {
	        var bi = ~~b;
	        this._bytes[this.position++] = bi & 0xff;
	        this._bytes[this.position++] = (bi >>> 8) & 0xff;
	        this._bytes[this.position++] = (bi >>> 16) & 0xff;
	        this._bytes[this.position++] = (bi >>> 24) & 0xff;
	        if (this.position > this.length) {
	            this.length = this.position;
	        }
	    };
	    ByteArrayBuffer.prototype.readUnsignedInt = function () {
	        if (this.position + 4 > this.length) {
	            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
	        }
	        var r = this._bytes[this.position] | (this._bytes[this.position + 1] << 8) | (this._bytes[this.position + 2] << 16) | (this._bytes[this.position + 3] << 24);
	        this.position += 4;
	        return r >>> 0;
	    };
	    ByteArrayBuffer.prototype.writeFloat = function (b) {
	        // this is crazy slow and silly, but as a fallback...
	        this.writeUnsignedInt(this.toFloatBits(Number(b)));
	    };
	    ByteArrayBuffer.prototype.toFloatBits = function (x) {
	        // don't handle inf/nan yet
	        // special case zero
	        if (x == 0) {
	            return 0;
	        }
	        // remove the sign, after this we only deal with positive numbers
	        var sign = 0;
	        if (x < 0) {
	            x = -x;
	            sign = 1;
	        }
	        else {
	            sign = 0;
	        }
	        // a float value is now defined as: x = (1+(mantissa*2^-23))*(2^(exponent-127))
	        var exponent = Math.log(x) / Math.log(2); // rough exponent
	        exponent = Math.floor(exponent);
	        x = x * Math.pow(2, 23 - exponent); // normalize to 24 bits
	        var mantissa = Math.floor(x) - 0x800000;
	        exponent = exponent + 127;
	        return ((sign << 31) >>> 0) | (exponent << 23) | mantissa;
	    };
	    ByteArrayBuffer.prototype.readFloat = function (b) {
	        return this.fromFloatBits(this.readUnsignedInt());
	    };
	    ByteArrayBuffer.prototype.fromFloatBits = function (x) {
	        if (x == 0) {
	            return 0;
	        }
	        var exponent = (x >>> 23) & 0xff;
	        var mantissa = (x & 0x7fffff) | 0x800000;
	        var y = Math.pow(2, (exponent - 127) - 23) * mantissa;
	        if (x >>> 31 != 0) {
	            y = -y;
	        }
	        return y;
	    };
	    return ByteArrayBuffer;
	}(ByteArrayBase_1.ByteArrayBase));
	exports.ByteArrayBuffer = ByteArrayBuffer;


/***/ },
/* 579 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var PartialImplementationError_1 = __webpack_require__(190);
	/**
	 *
	 */
	var Debug = (function () {
	    function Debug() {
	    }
	    Debug.breakpoint = function () {
	        Debug['break']();
	    };
	    Debug.throwPIROnKeyWordOnly = function (str, enable) {
	        if (enable === void 0) { enable = true; }
	        if (!enable)
	            Debug.keyword = null;
	        else
	            Debug.keyword = str;
	    };
	    Debug.throwPIR = function (clss, fnc, msg) {
	        Debug.logPIR('PartialImplementationError ' + clss, fnc, msg);
	        if (Debug.THROW_ERRORS) {
	            if (Debug.keyword) {
	                var e = clss + fnc + msg;
	                if (e.indexOf(Debug.keyword) == -1)
	                    return;
	            }
	            throw new PartialImplementationError_1.PartialImplementationError(clss + '.' + fnc + ': ' + msg);
	        }
	    };
	    Debug.logPIR = function (clss, fnc, msg) {
	        if (msg === void 0) { msg = ''; }
	        if (Debug.LOG_PI_ERRORS)
	            console.log(clss + '.' + fnc + ': ' + msg);
	    };
	    Debug.log = function () {
	        var args = [];
	        for (var _i = 0; _i < arguments.length; _i++) {
	            args[_i - 0] = arguments[_i];
	        }
	        if (Debug.ENABLE_LOG)
	            console.log(args);
	    };
	    Debug.THROW_ERRORS = true;
	    Debug.ENABLE_LOG = true;
	    Debug.LOG_PI_ERRORS = true;
	    Debug.keyword = null;
	    return Debug;
	}());
	exports.Debug = Debug;


/***/ },
/* 580 */
/***/ function(module, exports) {

	"use strict";
	/**
	 *
	 */
	var Extensions = (function () {
	    function Extensions() {
	    }
	    Extensions.SIMD = Boolean(typeof (SIMD) !== "undefined");
	    return Extensions;
	}());
	exports.Extensions = Extensions;


/***/ },
/* 581 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Cast_1 = __webpack_require__(582);
	exports.Cast = Cast_1.Cast;
	var ElementsUtils_1 = __webpack_require__(128);
	exports.ElementsUtils = ElementsUtils_1.ElementsUtils;


/***/ },
/* 582 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Image2D_1 = __webpack_require__(96);
	var ByteArray_1 = __webpack_require__(292);
	var CastError_1 = __webpack_require__(515);
	var Single2DTexture_1 = __webpack_require__(136);
	/**
	 * Helper class for casting assets to usable objects
	 */
	var Cast = (function () {
	    function Cast() {
	    }
	    Cast.string = function (data) {
	        if (typeof (data) == 'function')
	            data = new data;
	        if (typeof (data) == 'string')
	            return data;
	        return data;
	    };
	    Cast.byteArray = function (data) {
	        if (typeof (data) == 'function')
	            data = new data;
	        if (data instanceof ByteArray_1.ByteArray)
	            return data;
	        return data;
	    };
	    //        public static xml(data:any):XML
	    //        {
	    //            if (typeof(data) == 'function')
	    //                data = new data;
	    //
	    //            if (data is XML)
	    //                return data;
	    //
	    //            return XML(data);
	    //        }
	    Cast.isHex = function (str) {
	        var length = str.length;
	        for (var i = 0; i < length; ++i) {
	            if (this._hexChars.indexOf(str.charAt(i)) == -1)
	                return false;
	        }
	        return true;
	    };
	    Cast.tryColor = function (data) {
	        if (typeof (data) == 'number' /*uint*/)
	            return Math.floor(data);
	        if (typeof (data) == 'string') {
	            if (data == "random")
	                return Math.floor(Math.random() * 0x1000000);
	            if (this._colorNames == null) {
	                this._colorNames = new Object();
	                this._colorNames["steelblue"] = 0x4682B4;
	                this._colorNames["royalblue"] = 0x041690;
	                this._colorNames["cornflowerblue"] = 0x6495ED;
	                this._colorNames["lightsteelblue"] = 0xB0C4DE;
	                this._colorNames["mediumslateblue"] = 0x7B68EE;
	                this._colorNames["slateblue"] = 0x6A5ACD;
	                this._colorNames["darkslateblue"] = 0x483D8B;
	                this._colorNames["midnightblue"] = 0x191970;
	                this._colorNames["navy"] = 0x000080;
	                this._colorNames["darkblue"] = 0x00008B;
	                this._colorNames["mediumblue"] = 0x0000CD;
	                this._colorNames["blue"] = 0x0000FF;
	                this._colorNames["dodgerblue"] = 0x1E90FF;
	                this._colorNames["deepskyblue"] = 0x00BFFF;
	                this._colorNames["lightskyblue"] = 0x87CEFA;
	                this._colorNames["skyblue"] = 0x87CEEB;
	                this._colorNames["lightblue"] = 0xADD8E6;
	                this._colorNames["powderblue"] = 0xB0E0E6;
	                this._colorNames["azure"] = 0xF0FFFF;
	                this._colorNames["lightcyan"] = 0xE0FFFF;
	                this._colorNames["paleturquoise"] = 0xAFEEEE;
	                this._colorNames["mediumturquoise"] = 0x48D1CC;
	                this._colorNames["lightseagreen"] = 0x20B2AA;
	                this._colorNames["darkcyan"] = 0x008B8B;
	                this._colorNames["teal"] = 0x008080;
	                this._colorNames["cadetblue"] = 0x5F9EA0;
	                this._colorNames["darkturquoise"] = 0x00CED1;
	                this._colorNames["aqua"] = 0x00FFFF;
	                this._colorNames["cyan"] = 0x00FFFF;
	                this._colorNames["turquoise"] = 0x40E0D0;
	                this._colorNames["aquamarine"] = 0x7FFFD4;
	                this._colorNames["mediumaquamarine"] = 0x66CDAA;
	                this._colorNames["darkseagreen"] = 0x8FBC8F;
	                this._colorNames["mediumseagreen"] = 0x3CB371;
	                this._colorNames["seagreen"] = 0x2E8B57;
	                this._colorNames["darkgreen"] = 0x006400;
	                this._colorNames["green"] = 0x008000;
	                this._colorNames["forestgreen"] = 0x228B22;
	                this._colorNames["limegreen"] = 0x32CD32;
	                this._colorNames["lime"] = 0x00FF00;
	                this._colorNames["chartreuse"] = 0x7FFF00;
	                this._colorNames["lawngreen"] = 0x7CFC00;
	                this._colorNames["greenyellow"] = 0xADFF2F;
	                this._colorNames["yellowgreen"] = 0x9ACD32;
	                this._colorNames["palegreen"] = 0x98FB98;
	                this._colorNames["lightgreen"] = 0x90EE90;
	                this._colorNames["springgreen"] = 0x00FF7F;
	                this._colorNames["mediumspringgreen"] = 0x00FA9A;
	                this._colorNames["darkolivegreen"] = 0x556B2F;
	                this._colorNames["olivedrab"] = 0x6B8E23;
	                this._colorNames["olive"] = 0x808000;
	                this._colorNames["darkkhaki"] = 0xBDB76B;
	                this._colorNames["darkgoldenrod"] = 0xB8860B;
	                this._colorNames["goldenrod"] = 0xDAA520;
	                this._colorNames["gold"] = 0xFFD700;
	                this._colorNames["yellow"] = 0xFFFF00;
	                this._colorNames["khaki"] = 0xF0E68C;
	                this._colorNames["palegoldenrod"] = 0xEEE8AA;
	                this._colorNames["blanchedalmond"] = 0xFFEBCD;
	                this._colorNames["moccasin"] = 0xFFE4B5;
	                this._colorNames["wheat"] = 0xF5DEB3;
	                this._colorNames["navajowhite"] = 0xFFDEAD;
	                this._colorNames["burlywood"] = 0xDEB887;
	                this._colorNames["tan"] = 0xD2B48C;
	                this._colorNames["rosybrown"] = 0xBC8F8F;
	                this._colorNames["sienna"] = 0xA0522D;
	                this._colorNames["saddlebrown"] = 0x8B4513;
	                this._colorNames["chocolate"] = 0xD2691E;
	                this._colorNames["peru"] = 0xCD853F;
	                this._colorNames["sandybrown"] = 0xF4A460;
	                this._colorNames["darkred"] = 0x8B0000;
	                this._colorNames["maroon"] = 0x800000;
	                this._colorNames["brown"] = 0xA52A2A;
	                this._colorNames["firebrick"] = 0xB22222;
	                this._colorNames["indianred"] = 0xCD5C5C;
	                this._colorNames["lightcoral"] = 0xF08080;
	                this._colorNames["salmon"] = 0xFA8072;
	                this._colorNames["darksalmon"] = 0xE9967A;
	                this._colorNames["lightsalmon"] = 0xFFA07A;
	                this._colorNames["coral"] = 0xFF7F50;
	                this._colorNames["tomato"] = 0xFF6347;
	                this._colorNames["darkorange"] = 0xFF8C00;
	                this._colorNames["orange"] = 0xFFA500;
	                this._colorNames["orangered"] = 0xFF4500;
	                this._colorNames["crimson"] = 0xDC143C;
	                this._colorNames["red"] = 0xFF0000;
	                this._colorNames["deeppink"] = 0xFF1493;
	                this._colorNames["fuchsia"] = 0xFF00FF;
	                this._colorNames["magenta"] = 0xFF00FF;
	                this._colorNames["hotpink"] = 0xFF69B4;
	                this._colorNames["lightpink"] = 0xFFB6C1;
	                this._colorNames["pink"] = 0xFFC0CB;
	                this._colorNames["palevioletred"] = 0xDB7093;
	                this._colorNames["mediumvioletred"] = 0xC71585;
	                this._colorNames["purple"] = 0x800080;
	                this._colorNames["darkmagenta"] = 0x8B008B;
	                this._colorNames["mediumpurple"] = 0x9370DB;
	                this._colorNames["blueviolet"] = 0x8A2BE2;
	                this._colorNames["indigo"] = 0x4B0082;
	                this._colorNames["darkviolet"] = 0x9400D3;
	                this._colorNames["darkorchid"] = 0x9932CC;
	                this._colorNames["mediumorchid"] = 0xBA55D3;
	                this._colorNames["orchid"] = 0xDA70D6;
	                this._colorNames["violet"] = 0xEE82EE;
	                this._colorNames["plum"] = 0xDDA0DD;
	                this._colorNames["thistle"] = 0xD8BFD8;
	                this._colorNames["lavender"] = 0xE6E6FA;
	                this._colorNames["ghostwhite"] = 0xF8F8FF;
	                this._colorNames["aliceblue"] = 0xF0F8FF;
	                this._colorNames["mintcream"] = 0xF5FFFA;
	                this._colorNames["honeydew"] = 0xF0FFF0;
	                this._colorNames["lightgoldenrodyellow"] = 0xFAFAD2;
	                this._colorNames["lemonchiffon"] = 0xFFFACD;
	                this._colorNames["cornsilk"] = 0xFFF8DC;
	                this._colorNames["lightyellow"] = 0xFFFFE0;
	                this._colorNames["ivory"] = 0xFFFFF0;
	                this._colorNames["floralwhite"] = 0xFFFAF0;
	                this._colorNames["linen"] = 0xFAF0E6;
	                this._colorNames["oldlace"] = 0xFDF5E6;
	                this._colorNames["antiquewhite"] = 0xFAEBD7;
	                this._colorNames["bisque"] = 0xFFE4C4;
	                this._colorNames["peachpuff"] = 0xFFDAB9;
	                this._colorNames["papayawhip"] = 0xFFEFD5;
	                this._colorNames["beige"] = 0xF5F5DC;
	                this._colorNames["seashell"] = 0xFFF5EE;
	                this._colorNames["lavenderblush"] = 0xFFF0F5;
	                this._colorNames["mistyrose"] = 0xFFE4E1;
	                this._colorNames["snow"] = 0xFFFAFA;
	                this._colorNames["white"] = 0xFFFFFF;
	                this._colorNames["whitesmoke"] = 0xF5F5F5;
	                this._colorNames["gainsboro"] = 0xDCDCDC;
	                this._colorNames["lightgrey"] = 0xD3D3D3;
	                this._colorNames["silver"] = 0xC0C0C0;
	                this._colorNames["darkgrey"] = 0xA9A9A9;
	                this._colorNames["grey"] = 0x808080;
	                this._colorNames["lightslategrey"] = 0x778899;
	                this._colorNames["slategrey"] = 0x708090;
	                this._colorNames["dimgrey"] = 0x696969;
	                this._colorNames["darkslategrey"] = 0x2F4F4F;
	                this._colorNames["black"] = 0x000000;
	                this._colorNames["transparent"] = 0xFF000000;
	            }
	            if (this._colorNames[data] != null)
	                return this._colorNames[data];
	            if ((data.length == 6) && this.isHex(data))
	                return parseInt("0x" + data);
	        }
	        return null;
	    };
	    Cast.color = function (data) {
	        var result = this.tryColor(data);
	        if (result == null)
	            throw new CastError_1.CastError("Can't cast to color: " + data);
	        return result;
	    };
	    Cast.tryClass = function (name) {
	        if (this._notClasses[name])
	            return name;
	        var result = this._classes[name];
	        if (result != null)
	            return result;
	        try {
	            result = window[name];
	            this._classes[name] = result;
	            return result;
	        }
	        catch (e /*ReferenceError*/) {
	        }
	        this._notClasses[name] = true;
	        return name;
	    };
	    Cast.image2D = function (data) {
	        if (data == null)
	            return null;
	        if (typeof (data) == 'string')
	            data = this.tryClass(data);
	        if (typeof (data) == 'function') {
	            try {
	                data = new data();
	            }
	            catch (e /*ArgumentError*/) {
	                data = new data(0, 0);
	            }
	        }
	        if (data instanceof Image2D_1.Image2D)
	            return data;
	        if (data instanceof Single2DTexture_1.Single2DTexture)
	            data = data.image2D;
	        throw new CastError_1.CastError("Can't cast to BitmapImage2D: " + data);
	    };
	    Cast.bitmapTexture = function (data) {
	        if (data == null)
	            return null;
	        if (typeof (data) == 'string')
	            data = this.tryClass(data);
	        if (typeof (data) == 'function') {
	            try {
	                data = new data();
	            }
	            catch (e /*ArgumentError*/) {
	                data = new data(0, 0);
	            }
	        }
	        if (data instanceof Single2DTexture_1.Single2DTexture)
	            return data;
	        try {
	            var bmd = Cast.image2D(data);
	            return new Single2DTexture_1.Single2DTexture(bmd);
	        }
	        catch (e /*CastError*/) {
	        }
	        throw new CastError_1.CastError("Can't cast to Single2DTexture: " + data);
	    };
	    Cast._hexChars = "0123456789abcdefABCDEF";
	    Cast._notClasses = new Object();
	    Cast._classes = new Object();
	    return Cast;
	}());
	exports.Cast = Cast;


/***/ },
/* 583 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var ParticleGraphicsHelper_1 = __webpack_require__(584);
	exports.ParticleGraphicsHelper = ParticleGraphicsHelper_1.ParticleGraphicsHelper;
	var PerspectiveMatrix3D_1 = __webpack_require__(585);
	exports.PerspectiveMatrix3D = PerspectiveMatrix3D_1.PerspectiveMatrix3D;


/***/ },
/* 584 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var AttributesBuffer_1 = __webpack_require__(5);
	var Point_1 = __webpack_require__(58);
	var Vector3D_1 = __webpack_require__(34);
	var ParticleData_1 = __webpack_require__(435);
	var TriangleElements_1 = __webpack_require__(179);
	/**
	 * ...
	 */
	var ParticleGraphicsHelper = (function () {
	    function ParticleGraphicsHelper() {
	    }
	    ParticleGraphicsHelper.generateGraphics = function (output, graphicsArray, transforms) {
	        if (transforms === void 0) { transforms = null; }
	        var indicesVector = new Array();
	        var positionsVector = new Array();
	        var normalsVector = new Array();
	        var tangentsVector = new Array();
	        var uvsVector = new Array();
	        var vertexCounters = new Array();
	        var particles = new Array();
	        var elementsArray = new Array();
	        var numParticles = graphicsArray.length;
	        var sourceGraphics;
	        var sourceElements;
	        var numGraphics;
	        var indices;
	        var positions;
	        var normals;
	        var tangents;
	        var uvs;
	        var vertexCounter;
	        var elements;
	        var i;
	        var j;
	        var sub2SubMap = new Array();
	        var tempVertex = new Vector3D_1.Vector3D;
	        var tempNormal = new Vector3D_1.Vector3D;
	        var tempTangents = new Vector3D_1.Vector3D;
	        var tempUV = new Point_1.Point;
	        for (i = 0; i < numParticles; i++) {
	            sourceGraphics = graphicsArray[i];
	            numGraphics = sourceGraphics.count;
	            for (var srcIndex = 0; srcIndex < numGraphics; srcIndex++) {
	                //create a different particle subgeometry group for each source subgeometry in a particle.
	                if (sub2SubMap.length <= srcIndex) {
	                    sub2SubMap.push(elementsArray.length);
	                    indicesVector.push(new Array());
	                    positionsVector.push(new Array());
	                    normalsVector.push(new Array());
	                    tangentsVector.push(new Array());
	                    uvsVector.push(new Array());
	                    elementsArray.push(new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer()));
	                    vertexCounters.push(0);
	                }
	                sourceElements = sourceGraphics.getGraphicAt(srcIndex).elements;
	                //add a new particle subgeometry if this source subgeometry will take us over the maxvertex limit
	                if (sourceElements.numVertices + vertexCounters[sub2SubMap[srcIndex]] > ParticleGraphicsHelper.MAX_VERTEX) {
	                    //update submap and add new subgeom vectors
	                    sub2SubMap[srcIndex] = elementsArray.length;
	                    indicesVector.push(new Array());
	                    positionsVector.push(new Array());
	                    normalsVector.push(new Array());
	                    tangentsVector.push(new Array());
	                    uvsVector.push(new Array());
	                    elementsArray.push(new TriangleElements_1.TriangleElements(new AttributesBuffer_1.AttributesBuffer()));
	                    vertexCounters.push(0);
	                }
	                j = sub2SubMap[srcIndex];
	                //select the correct vector
	                indices = indicesVector[j];
	                positions = positionsVector[j];
	                normals = normalsVector[j];
	                tangents = tangentsVector[j];
	                uvs = uvsVector[j];
	                vertexCounter = vertexCounters[j];
	                elements = elementsArray[j];
	                var particleData = new ParticleData_1.ParticleData();
	                particleData.numVertices = sourceElements.numVertices;
	                particleData.startVertexIndex = vertexCounter;
	                particleData.particleIndex = i;
	                particleData.elements = elements;
	                particles.push(particleData);
	                vertexCounters[j] += sourceElements.numVertices;
	                var k;
	                var index;
	                var posIndex;
	                var normalIndex;
	                var tangentIndex;
	                var uvIndex;
	                var tempLen;
	                var compact = sourceElements;
	                var sourcePositions;
	                var posStride;
	                var sourceNormals;
	                var normalStride;
	                var sourceTangents;
	                var tangentStride;
	                var sourceUVs;
	                var uvStride;
	                if (compact) {
	                    tempLen = compact.numVertices;
	                    sourcePositions = compact.positions.get(tempLen);
	                    posStride = compact.positions.stride;
	                    sourceNormals = compact.normals.get(tempLen);
	                    normalStride = compact.normals.stride;
	                    sourceTangents = compact.tangents.get(tempLen);
	                    tangentStride = compact.tangents.stride;
	                    sourceUVs = compact.uvs.get(tempLen);
	                    uvStride = compact.uvs.stride;
	                    if (transforms) {
	                        var particleGraphicsTransform = transforms[i];
	                        var vertexTransform = particleGraphicsTransform.vertexTransform;
	                        var invVertexTransform = particleGraphicsTransform.invVertexTransform;
	                        var UVTransform = particleGraphicsTransform.UVTransform;
	                        for (k = 0; k < tempLen; k++) {
	                            /*
	                             * 0 - 2: vertex position X, Y, Z
	                             * 3 - 5: normal X, Y, Z
	                             * 6 - 8: tangent X, Y, Z
	                             * 9 - 10: U V
	                             * 11 - 12: Secondary U V*/
	                            posIndex = k * posStride;
	                            tempVertex.x = sourcePositions[posIndex];
	                            tempVertex.y = sourcePositions[posIndex + 1];
	                            tempVertex.z = sourcePositions[posIndex + 2];
	                            normalIndex = k * normalStride;
	                            tempNormal.x = sourceNormals[normalIndex];
	                            tempNormal.y = sourceNormals[normalIndex + 1];
	                            tempNormal.z = sourceNormals[normalIndex + 2];
	                            tangentIndex = k * tangentStride;
	                            tempTangents.x = sourceTangents[tangentIndex];
	                            tempTangents.y = sourceTangents[tangentIndex + 1];
	                            tempTangents.z = sourceTangents[tangentIndex + 2];
	                            uvIndex = k * uvStride;
	                            tempUV.x = sourceUVs[uvIndex];
	                            tempUV.y = sourceUVs[uvIndex + 1];
	                            if (vertexTransform) {
	                                tempVertex = vertexTransform.transformVector(tempVertex);
	                                tempNormal = invVertexTransform.deltaTransformVector(tempNormal);
	                                tempTangents = invVertexTransform.deltaTransformVector(tempNormal);
	                            }
	                            if (UVTransform)
	                                tempUV = UVTransform.transformPoint(tempUV);
	                            //this is faster than that only push one data
	                            positions.push(tempVertex.x, tempVertex.y, tempVertex.z);
	                            normals.push(tempNormal.x, tempNormal.y, tempNormal.z);
	                            tangents.push(tempTangents.x, tempTangents.y, tempTangents.z);
	                            uvs.push(tempUV.x, tempUV.y);
	                        }
	                    }
	                    else {
	                        for (k = 0; k < tempLen; k++) {
	                            posIndex = k * posStride;
	                            normalIndex = k * normalStride;
	                            tangentIndex = k * tangentStride;
	                            uvIndex = k * uvStride;
	                            //this is faster than that only push one data
	                            positions.push(sourcePositions[posIndex], sourcePositions[posIndex + 1], sourcePositions[posIndex + 2]);
	                            normals.push(sourceNormals[normalIndex], sourceNormals[normalIndex + 1], sourceNormals[normalIndex + 2]);
	                            tangents.push(sourceTangents[tangentIndex], sourceTangents[tangentIndex + 1], sourceTangents[tangentIndex + 2]);
	                            uvs.push(sourceUVs[uvIndex], sourceUVs[uvIndex + 1]);
	                        }
	                    }
	                }
	                else {
	                }
	                tempLen = sourceElements.numElements;
	                var sourceIndices = sourceElements.indices.get(tempLen);
	                for (k = 0; k < tempLen; k++) {
	                    index = k * 3;
	                    indices.push(sourceIndices[index] + vertexCounter, sourceIndices[index + 1] + vertexCounter, sourceIndices[index + 2] + vertexCounter);
	                }
	            }
	        }
	        output.particles = particles;
	        output.numParticles = numParticles;
	        numParticles = elementsArray.length;
	        for (i = 0; i < numParticles; i++) {
	            elements = elementsArray[i];
	            elements.autoDeriveNormals = false;
	            elements.autoDeriveTangents = false;
	            elements.setIndices(indicesVector[i]);
	            elements.setPositions(positionsVector[i]);
	            elements.setNormals(normalsVector[i]);
	            elements.setTangents(tangentsVector[i]);
	            elements.setUVs(uvsVector[i]);
	            output.addGraphic(elements);
	        }
	    };
	    ParticleGraphicsHelper.MAX_VERTEX = 65535;
	    return ParticleGraphicsHelper;
	}());
	exports.ParticleGraphicsHelper = ParticleGraphicsHelper;


/***/ },
/* 585 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var Matrix3D_1 = __webpack_require__(32);
	/**
	 *
	 */
	var PerspectiveMatrix3D = (function (_super) {
	    __extends(PerspectiveMatrix3D, _super);
	    function PerspectiveMatrix3D(v) {
	        if (v === void 0) { v = null; }
	        _super.call(this, v);
	    }
	    PerspectiveMatrix3D.prototype.perspectiveFieldOfViewLH = function (fieldOfViewY, aspectRatio, zNear, zFar) {
	        var yScale = 1 / Math.tan(fieldOfViewY / 2);
	        var xScale = yScale / aspectRatio;
	        this.rawData[0] = xScale;
	        this.rawData[1] = 0.0;
	        this.rawData[2] = 0.0;
	        this.rawData[3] = 0.0;
	        this.rawData[4] = 0.0;
	        this.rawData[5] = yScale;
	        this.rawData[6] = 0.0;
	        this.rawData[7] = 0.0;
	        this.rawData[8] = 0.0;
	        this.rawData[9] = 0.0;
	        this.rawData[10] = zFar / (zFar - zNear);
	        this.rawData[11] = 1.0;
	        this.rawData[12] = 0.0;
	        this.rawData[13] = 0.0;
	        this.rawData[14] = (zNear * zFar) / (zNear - zFar);
	        this.rawData[15] = 0.0;
	    };
	    return PerspectiveMatrix3D;
	}(Matrix3D_1.Matrix3D));
	exports.PerspectiveMatrix3D = PerspectiveMatrix3D;


/***/ },
/* 586 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var getTimer_1 = __webpack_require__(294);
	var TouchPoint_1 = __webpack_require__(30);
	var Scene_1 = __webpack_require__(198);
	var Camera_1 = __webpack_require__(139);
	var CameraEvent_1 = __webpack_require__(148);
	var RendererEvent_1 = __webpack_require__(429);
	var RaycastPicker_1 = __webpack_require__(552);
	var MouseManager_1 = __webpack_require__(543);
	var BasicPartition_1 = __webpack_require__(371);
	var View = (function () {
	    /*
	     ***********************************************************************
	     * Disabled / Not yet implemented
	     ***********************************************************************
	     *
	     * private _background:away.textures.Texture2DBase;
	     *
	     * public _pTouch3DManager:away.managers.Touch3DManager;
	     *
	     */
	    function View(renderer, scene, camera) {
	        var _this = this;
	        if (scene === void 0) { scene = null; }
	        if (camera === void 0) { camera = null; }
	        this._width = 0;
	        this._height = 0;
	        this._time = 0;
	        this._deltaTime = 0;
	        this._backgroundColor = 0x000000;
	        this._backgroundAlpha = 1;
	        this._viewportDirty = true;
	        this._scissorDirty = true;
	        this._mousePicker = new RaycastPicker_1.RaycastPicker();
	        this._partitions = new Object();
	        this._pTouchPoints = new Array();
	        this._onProjectionChangedDelegate = function (event) { return _this._onProjectionChanged(event); };
	        this._onViewportUpdatedDelegate = function (event) { return _this._onViewportUpdated(event); };
	        this._onScissorUpdatedDelegate = function (event) { return _this._onScissorUpdated(event); };
	        this.scene = scene || new Scene_1.Scene();
	        this.camera = camera || new Camera_1.Camera();
	        this.renderer = renderer;
	        //make sure document border is zero
	        if (typeof document !== "undefined") {
	            document.body.style.margin = "0px";
	            this._htmlElement = document.createElement("div");
	            this._htmlElement.style.position = "absolute";
	            document.body.appendChild(this._htmlElement);
	        }
	        this._mouseManager = MouseManager_1.MouseManager.getInstance();
	        this._mouseManager.registerView(this);
	        //			if (this._shareContext)
	        //				this._mouse3DManager.addViewLayer(this);
	    }
	    View.prototype.getPartition = function (displayObject) {
	        //use registered partition for the displayobject or fallback for scene
	        return this._partitions[displayObject.partition.id] || this._partitions[this._pScene.id];
	    };
	    View.prototype.setPartition = function (displayObject, partition) {
	        var oldPartition = this._partitions[displayObject.id];
	        if (oldPartition == partition)
	            return;
	        //clears all existing entities on the partition
	        displayObject.isPartition = false;
	        if (oldPartition) {
	            oldPartition.dispose();
	            delete this._partitions[displayObject.id];
	        }
	        if (partition) {
	            this._partitions[displayObject.id] = partition;
	            displayObject.isPartition = true;
	        }
	    };
	    Object.defineProperty(View.prototype, "mouseX", {
	        get: function () {
	            return this._pMouseX;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "mouseY", {
	        get: function () {
	            return this._pMouseY;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "touchPoints", {
	        get: function () {
	            return this._pTouchPoints;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    View.prototype.getLocalMouseX = function (displayObject) {
	        return displayObject.inverseSceneTransform.transformVector(this.unproject(this._pMouseX, this._pMouseY, 1000)).x;
	    };
	    View.prototype.getLocalMouseY = function (displayObject) {
	        return displayObject.inverseSceneTransform.transformVector(this.unproject(this._pMouseX, this._pMouseY, 1000)).y;
	    };
	    View.prototype.getLocalTouchPoints = function (displayObject) {
	        var localPosition;
	        var localTouchPoints = new Array();
	        var len = this._pTouchPoints.length;
	        for (var i = 0; i < len; i++) {
	            localPosition = displayObject.inverseSceneTransform.transformVector(this.unproject(this._pTouchPoints[i].x, this._pTouchPoints[i].y, 1000));
	            localTouchPoints.push(new TouchPoint_1.TouchPoint(localPosition.x, localPosition.y, this._pTouchPoints[i].id));
	        }
	        return localTouchPoints;
	    };
	    Object.defineProperty(View.prototype, "htmlElement", {
	        /**
	         *
	         */
	        get: function () {
	            return this._htmlElement;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "renderer", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pRenderer;
	        },
	        set: function (value) {
	            if (this._pRenderer == value)
	                return;
	            if (this._pRenderer) {
	                this._pRenderer.dispose();
	                this._pRenderer.removeEventListener(RendererEvent_1.RendererEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	                this._pRenderer.removeEventListener(RendererEvent_1.RendererEvent.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
	            }
	            this._pRenderer = value;
	            this._pRenderer.addEventListener(RendererEvent_1.RendererEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
	            this._pRenderer.addEventListener(RendererEvent_1.RendererEvent.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
	            //reset back buffer
	            this._pRenderer._iBackgroundR = ((this._backgroundColor >> 16) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundG = ((this._backgroundColor >> 8) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundB = (this._backgroundColor & 0xff) / 0xff;
	            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha;
	            this._pRenderer.width = this._width;
	            this._pRenderer.height = this._height;
	            this._pRenderer.shareContext = this._shareContext;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "shareContext", {
	        /**
	         *
	         */
	        get: function () {
	            return this._shareContext;
	        },
	        set: function (value) {
	            if (this._shareContext == value)
	                return;
	            this._shareContext = value;
	            if (this._pRenderer)
	                this._pRenderer.shareContext = this._shareContext;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "backgroundColor", {
	        /**
	         *
	         */
	        get: function () {
	            return this._backgroundColor;
	        },
	        set: function (value) {
	            if (this._backgroundColor == value)
	                return;
	            this._backgroundColor = value;
	            this._pRenderer._iBackgroundR = ((value >> 16) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundG = ((value >> 8) & 0xff) / 0xff;
	            this._pRenderer._iBackgroundB = (value & 0xff) / 0xff;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "backgroundAlpha", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._backgroundAlpha;
	        },
	        /**
	         *
	         * @param value
	         */
	        set: function (value) {
	            if (value > 1)
	                value = 1;
	            else if (value < 0)
	                value = 0;
	            if (this._backgroundAlpha == value)
	                return;
	            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "camera", {
	        /**
	         *
	         * @returns {Camera3D}
	         */
	        get: function () {
	            return this._pCamera;
	        },
	        /**
	         * Set camera that's used to render the scene for this viewport
	         */
	        set: function (value) {
	            if (this._pCamera == value)
	                return;
	            if (this._pCamera)
	                this._pCamera.removeEventListener(CameraEvent_1.CameraEvent.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
	            this._pCamera = value;
	            if (this._pScene)
	                this._partitions[this._pScene.id]._iRegisterEntity(this._pCamera);
	            this._pCamera.addEventListener(CameraEvent_1.CameraEvent.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
	            this._scissorDirty = true;
	            this._viewportDirty = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "scene", {
	        /**
	         *
	         * @returns {away.containers.Scene3D}
	         */
	        get: function () {
	            return this._pScene;
	        },
	        /**
	         * Set the scene that's used to render for this viewport
	         */
	        set: function (value) {
	            if (this._pScene == value)
	                return;
	            if (this._pScene) {
	                this._pScene._iUnregisterView(this);
	                this._partitions[this._pScene.id].dispose();
	            }
	            this._pScene = value;
	            this._partitions[this._pScene.id] = new BasicPartition_1.BasicPartition(this._pScene);
	            this._pScene._iRegisterView(this);
	            if (this._pCamera)
	                this._partitions[this._pScene.id]._iRegisterEntity(this._pCamera);
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "deltaTime", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return this._deltaTime;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "width", {
	        /**
	         *
	         */
	        get: function () {
	            return this._width;
	        },
	        set: function (value) {
	            if (this._width == value)
	                return;
	            this._width = value;
	            this._aspectRatio = this._width / this._height;
	            this._pCamera.projection._iAspectRatio = this._aspectRatio;
	            this._pRenderer.width = value;
	            if (this._htmlElement) {
	                this._htmlElement.style.width = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "height", {
	        /**
	         *
	         */
	        get: function () {
	            return this._height;
	        },
	        set: function (value) {
	            if (this._height == value)
	                return;
	            this._height = value;
	            this._aspectRatio = this._width / this._height;
	            this._pCamera.projection._iAspectRatio = this._aspectRatio;
	            this._pRenderer.height = value;
	            if (this._htmlElement) {
	                this._htmlElement.style.height = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "mousePicker", {
	        /**
	         *
	         */
	        get: function () {
	            return this._mousePicker;
	        },
	        set: function (value) {
	            if (this._mousePicker == value)
	                return;
	            if (value == null)
	                this._mousePicker = new RaycastPicker_1.RaycastPicker();
	            else
	                this._mousePicker = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "x", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pRenderer.x;
	        },
	        set: function (value) {
	            if (this._pRenderer.x == value)
	                return;
	            this._pRenderer.x = value;
	            if (this._htmlElement) {
	                this._htmlElement.style.left = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "y", {
	        /**
	         *
	         */
	        get: function () {
	            return this._pRenderer.y;
	        },
	        set: function (value) {
	            if (this._pRenderer.y == value)
	                return;
	            this._pRenderer.y = value;
	            if (this._htmlElement) {
	                this._htmlElement.style.top = value + "px";
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "visible", {
	        /**
	         *
	         */
	        get: function () {
	            return (this._htmlElement && this._htmlElement.style.visibility == "visible");
	        },
	        set: function (value) {
	            if (this._htmlElement) {
	                this._htmlElement.style.visibility = value ? "visible" : "hidden";
	            }
	            //TODO transfer visible property to associated context (if one exists)
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(View.prototype, "renderedFacesCount", {
	        /**
	         *
	         * @returns {number}
	         */
	        get: function () {
	            return 0; //TODO
	            //return this._pEntityCollector._pNumTriangles;//numTriangles;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     * Renders the view.
	     */
	    View.prototype.render = function () {
	        this.pUpdateTime();
	        //update view and size data
	        this._pCamera.projection._iAspectRatio = this._aspectRatio;
	        if (this._scissorDirty) {
	            this._scissorDirty = false;
	            this._pCamera.projection._iUpdateScissorRect(this._pRenderer.scissorRect.x, this._pRenderer.scissorRect.y, this._pRenderer.scissorRect.width, this._pRenderer.scissorRect.height);
	        }
	        if (this._viewportDirty) {
	            this._viewportDirty = false;
	            this._pCamera.projection._iUpdateViewport(this._pRenderer.viewPort.x, this._pRenderer.viewPort.y, this._pRenderer.viewPort.width, this._pRenderer.viewPort.height);
	        }
	        // update picking
	        if (!this._shareContext) {
	            if (this.forceMouseMove && this._htmlElement == this._mouseManager._iActiveDiv && !this._mouseManager._iUpdateDirty)
	                this._mouseManager._iCollision = this.getViewCollision(this._pMouseX, this._pMouseY, this);
	            this._mouseManager.fireMouseEvents(this.forceMouseMove);
	        }
	        //_touch3DManager.updateCollider();
	        //render the contents of the scene
	        this._pRenderer.render(this);
	    };
	    /**
	     *
	     */
	    View.prototype.pUpdateTime = function () {
	        var time = getTimer_1.getTimer();
	        if (this._time == 0)
	            this._time = time;
	        this._deltaTime = time - this._time;
	        this._time = time;
	    };
	    /**
	     *
	     */
	    View.prototype.dispose = function () {
	        this._pRenderer.dispose();
	        // TODO: imeplement mouseManager / touch3DManager
	        this._mouseManager.unregisterView(this);
	        //this._touch3DManager.disableTouchListeners(this);
	        //this._touch3DManager.dispose();
	        this._mouseManager = null;
	        //this._touch3DManager = null;
	        this._pRenderer = null;
	    };
	    /**
	     *
	     */
	    View.prototype._onProjectionChanged = function (event) {
	        this._scissorDirty = true;
	        this._viewportDirty = true;
	    };
	    /**
	     *
	     */
	    View.prototype._onViewportUpdated = function (event) {
	        this._viewportDirty = true;
	    };
	    /**
	     *
	     */
	    View.prototype._onScissorUpdated = function (event) {
	        this._scissorDirty = true;
	    };
	    View.prototype.project = function (point3d) {
	        var v = this._pCamera.project(point3d);
	        v.x = v.x * this._pRenderer.viewPort.width / 2 + this._width * this._pCamera.projection.originX;
	        v.y = v.y * this._pRenderer.viewPort.height / 2 + this._height * this._pCamera.projection.originY;
	        return v;
	    };
	    View.prototype.unproject = function (sX, sY, sZ) {
	        return this._pCamera.unproject(2 * (sX - this._width * this._pCamera.projection.originX) / this._pRenderer.viewPort.width, 2 * (sY - this._height * this._pCamera.projection.originY) / this._pRenderer.viewPort.height, sZ);
	    };
	    View.prototype.getRay = function (sX, sY, sZ) {
	        return this._pCamera.getRay((sX * 2 - this._width) / this._width, (sY * 2 - this._height) / this._height, sZ);
	    };
	    /*TODO: implement Background
	     public get background():away.textures.Texture2DBase
	     {
	     return this._background;
	     }
	     */
	    /*TODO: implement Background
	     public set background( value:away.textures.Texture2DBase )
	     {
	     this._background = value;
	     this._renderer.background = _background;
	     }
	     */
	    // TODO: required dependency stageGL
	    View.prototype.updateCollider = function () {
	        if (!this._shareContext) {
	            if (this._htmlElement == this._mouseManager._iActiveDiv)
	                this._mouseManager._iCollision = this.getViewCollision(this._pMouseX, this._pMouseY, this);
	        }
	        else {
	            var collidingObject = this.getViewCollision(this._pMouseX, this._pMouseY, this);
	            if (this.layeredView || this._mouseManager._iCollision == null || collidingObject.rayEntryDistance < this._mouseManager._iCollision.rayEntryDistance)
	                this._mouseManager._iCollision = collidingObject;
	        }
	    };
	    View.prototype.getViewCollision = function (x, y, view) {
	        //update ray
	        var rayPosition = view.unproject(x, y, 0);
	        var rayDirection = view.unproject(x, y, 1).subtract(rayPosition);
	        return this._mousePicker.getCollision(rayPosition, rayDirection, this);
	    };
	    View.prototype.traversePartitions = function (traverser) {
	        for (var key in this._partitions)
	            this._partitions[key].traverse(traverser);
	    };
	    View.prototype.registerObject = function (displayObject) {
	        this.getPartition(displayObject)._iRegisterEntity(displayObject);
	    };
	    View.prototype.unRegisterObject = function (displayObject) {
	        this.getPartition(displayObject)._iUnregisterEntity(displayObject);
	    };
	    return View;
	}());
	exports.View = View;


/***/ },
/* 587 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var BitmapImage2D_1 = __webpack_require__(95);
	var ContextGLClearMask_1 = __webpack_require__(42);
	var RendererBase_1 = __webpack_require__(418);
	var DepthRenderer_1 = __webpack_require__(588);
	var DistanceRenderer_1 = __webpack_require__(590);
	var Filter3DRenderer_1 = __webpack_require__(592);
	var RTTBufferManager_1 = __webpack_require__(540);
	/**
	 * The DefaultRenderer class provides the default rendering method. It renders the scene graph objects using the
	 * materials assigned to them.
	 *
	 * @class away.render.DefaultRenderer
	 */
	var DefaultRenderer = (function (_super) {
	    __extends(DefaultRenderer, _super);
	    /**
	     * Creates a new DefaultRenderer object.
	     *
	     * @param antiAlias The amount of anti-aliasing to use.
	     * @param renderMode The render mode to use.
	     */
	    function DefaultRenderer(stage, forceSoftware, profile, mode) {
	        if (stage === void 0) { stage = null; }
	        if (forceSoftware === void 0) { forceSoftware = false; }
	        if (profile === void 0) { profile = "baseline"; }
	        if (mode === void 0) { mode = "auto"; }
	        _super.call(this, stage, null, forceSoftware, profile, mode);
	        this._antiAlias = 0;
	        this._directionalLights = new Array();
	        this._pointLights = new Array();
	        this._lightProbes = new Array();
	        if (stage)
	            this.shareContext = true;
	        this._pRttBufferManager = RTTBufferManager_1.RTTBufferManager.getInstance(this._pStage);
	        this._pDepthRenderer = new DepthRenderer_1.DepthRenderer(this._pStage);
	        this._pDistanceRenderer = new DistanceRenderer_1.DistanceRenderer(this._pStage);
	        if (this._width == 0)
	            this.width = window.innerWidth;
	        else
	            this._pRttBufferManager.viewWidth = this._width;
	        if (this._height == 0)
	            this.height = window.innerHeight;
	        else
	            this._pRttBufferManager.viewHeight = this._height;
	    }
	    Object.defineProperty(DefaultRenderer.prototype, "antiAlias", {
	        get: function () {
	            return this._antiAlias;
	        },
	        set: function (value) {
	            if (this._antiAlias == value)
	                return;
	            this._antiAlias = value;
	            this._pBackBufferInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultRenderer.prototype, "depthPrepass", {
	        /**
	         *
	         */
	        get: function () {
	            return this._depthPrepass;
	        },
	        set: function (value) {
	            this._depthPrepass = value;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(DefaultRenderer.prototype, "filters3d", {
	        /**
	         *
	         * @returns {*}
	         */
	        get: function () {
	            return this._pFilter3DRenderer ? this._pFilter3DRenderer.filters : null;
	        },
	        set: function (value) {
	            if (value && value.length == 0)
	                value = null;
	            if (this._pFilter3DRenderer && !value) {
	                this._pFilter3DRenderer.dispose();
	                this._pFilter3DRenderer = null;
	            }
	            else if (!this._pFilter3DRenderer && value) {
	                this._pFilter3DRenderer = new Filter3DRenderer_1.Filter3DRenderer(this._pStage);
	                this._pFilter3DRenderer.filters = value;
	            }
	            if (this._pFilter3DRenderer) {
	                this._pFilter3DRenderer.filters = value;
	                this._pRequireDepthRender = this._pFilter3DRenderer.requireDepthRender;
	            }
	            else {
	                this._pRequireDepthRender = false;
	                if (this._pDepthRender) {
	                    this._pDepthRender.dispose();
	                    this._pDepthRender = null;
	                }
	            }
	        },
	        enumerable: true,
	        configurable: true
	    });
	    /**
	     *
	     */
	    DefaultRenderer.prototype.enterNode = function (node) {
	        var enter = _super.prototype.enterNode.call(this, node);
	        if (enter && node.debugVisible)
	            this.applyEntity(node.bounds.boundsPrimitive);
	        return enter;
	    };
	    DefaultRenderer.prototype.render = function (view) {
	        _super.prototype.render.call(this, view);
	        if (!this._pStage.recoverFromDisposal()) {
	            this._pBackBufferInvalid = true;
	            return;
	        }
	        if (this._pBackBufferInvalid)
	            this.pUpdateBackBuffer();
	        if (this.shareContext && this._pContext)
	            this._pContext.clear(0, 0, 0, 1, 1, 0, ContextGLClearMask_1.ContextGLClearMask.DEPTH);
	        if (this._pFilter3DRenderer) {
	            this.textureRatioX = this._pRttBufferManager.textureRatioX;
	            this.textureRatioY = this._pRttBufferManager.textureRatioY;
	        }
	        else {
	            this.textureRatioX = 1;
	            this.textureRatioY = 1;
	        }
	        if (this._pRequireDepthRender)
	            this.pRenderSceneDepthToTexture(view);
	        if (this._depthPrepass)
	            this.pRenderDepthPrepass(view);
	        //reset lights
	        this._directionalLights.length = 0;
	        this._pointLights.length = 0;
	        this._lightProbes.length = 0;
	        if (this._pFilter3DRenderer && this._pContext) {
	            this._iRender(view.camera, view, this._pFilter3DRenderer.getMainInputTexture(this._pStage), this._pFilter3DRenderer.renderToTextureRect);
	            this._pFilter3DRenderer.render(this._pStage, view.camera, this._pDepthRender);
	        }
	        else {
	            if (this.shareContext)
	                this._iRender(view.camera, view, null, this._pScissorRect);
	            else
	                this._iRender(view.camera, view);
	        }
	        if (!this.shareContext && this._pContext)
	            this._pContext.present();
	        // register that a view has been rendered
	        this._pStage.bufferClear = false;
	    };
	    DefaultRenderer.prototype.pExecuteRender = function (camera, view, target, scissorRect, surfaceSelector) {
	        if (target === void 0) { target = null; }
	        if (scissorRect === void 0) { scissorRect = null; }
	        if (surfaceSelector === void 0) { surfaceSelector = 0; }
	        this.updateLights(camera, view);
	        _super.prototype.pExecuteRender.call(this, camera, view, target, scissorRect, surfaceSelector);
	    };
	    DefaultRenderer.prototype.updateLights = function (camera, view) {
	        var len, i;
	        var light;
	        var shadowMapper;
	        len = this._directionalLights.length;
	        for (i = 0; i < len; ++i) {
	            light = this._directionalLights[i];
	            shadowMapper = light.shadowMapper;
	            if (light.shadowsEnabled && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
	                shadowMapper.iRenderDepthMap(view, this._pDepthRenderer);
	        }
	        len = this._pointLights.length;
	        for (i = 0; i < len; ++i) {
	            light = this._pointLights[i];
	            shadowMapper = light.shadowMapper;
	            if (light.shadowsEnabled && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
	                shadowMapper.iRenderDepthMap(view, this._pDistanceRenderer);
	        }
	    };
	    /**
	     *
	     * @param entity
	     */
	    DefaultRenderer.prototype.applyDirectionalLight = function (entity) {
	        this._directionalLights.push(entity);
	    };
	    /**
	     *
	     * @param entity
	     */
	    DefaultRenderer.prototype.applyLightProbe = function (entity) {
	        this._lightProbes.push(entity);
	    };
	    /**
	     *
	     * @param entity
	     */
	    DefaultRenderer.prototype.applyPointLight = function (entity) {
	        this._pointLights.push(entity);
	    };
	    DefaultRenderer.prototype.dispose = function () {
	        if (!this.shareContext)
	            this._pStage.dispose();
	        this._pRttBufferManager.dispose();
	        this._pRttBufferManager = null;
	        this._pDepthRenderer.dispose();
	        this._pDistanceRenderer.dispose();
	        this._pDepthRenderer = null;
	        this._pDistanceRenderer = null;
	        this._pDepthRender = null;
	        _super.prototype.dispose.call(this);
	    };
	    /**
	     *
	     */
	    DefaultRenderer.prototype.pRenderDepthPrepass = function (view) {
	        this._pDepthRenderer.disableColor = true;
	        if (this._pFilter3DRenderer) {
	            this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
	            this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
	            this._pDepthRenderer._iRender(view.camera, view, this._pFilter3DRenderer.getMainInputTexture(this._pStage), this._pRttBufferManager.renderToTextureRect);
	        }
	        else {
	            this._pDepthRenderer.textureRatioX = 1;
	            this._pDepthRenderer.textureRatioY = 1;
	            this._pDepthRenderer._iRender(view.camera, view);
	        }
	        this._pDepthRenderer.disableColor = false;
	    };
	    /**
	     *
	     */
	    DefaultRenderer.prototype.pRenderSceneDepthToTexture = function (view) {
	        if (this._pDepthTextureInvalid || !this._pDepthRender)
	            this.initDepthTexture(this._pStage.context);
	        this._pDepthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
	        this._pDepthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
	        this._pDepthRenderer._iRender(view.camera, view, this._pDepthRender);
	    };
	    /**
	     * Updates the backbuffer dimensions.
	     */
	    DefaultRenderer.prototype.pUpdateBackBuffer = function () {
	        // No reason trying to configure back buffer if there is no context available.
	        // Doing this anyway (and relying on _stage to cache width/height for
	        // context does get available) means usesSoftwareRendering won't be reliable.
	        if (this._pStage.context && !this.shareContext) {
	            if (this._width && this._height) {
	                this._pStage.configureBackBuffer(this._width, this._height, this._antiAlias, true);
	                this._pBackBufferInvalid = false;
	            }
	        }
	    };
	    /**
	     *
	     */
	    DefaultRenderer.prototype.initDepthTexture = function (context) {
	        this._pDepthTextureInvalid = false;
	        if (this._pDepthRender)
	            this._pDepthRender.dispose();
	        this._pDepthRender = new BitmapImage2D_1.BitmapImage2D(this._pRttBufferManager.textureWidth, this._pRttBufferManager.textureHeight);
	    };
	    return DefaultRenderer;
	}(RendererBase_1.RendererBase));
	exports.DefaultRenderer = DefaultRenderer;


/***/ },
/* 588 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var RendererBase_1 = __webpack_require__(418);
	var GL_DepthSurface_1 = __webpack_require__(589);
	/**
	 * The DepthRenderer class renders 32-bit depth information encoded as RGBA
	 *
	 * @class away.render.DepthRenderer
	 */
	var DepthRenderer = (function (_super) {
	    __extends(DepthRenderer, _super);
	    /**
	     * Creates a new DepthRenderer object.
	     * @param renderBlended Indicates whether semi-transparent objects should be rendered.
	     * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
	     */
	    function DepthRenderer(stage) {
	        if (stage === void 0) { stage = null; }
	        _super.call(this, stage, GL_DepthSurface_1.GL_DepthSurface);
	        this._iBackgroundR = 1;
	        this._iBackgroundG = 1;
	        this._iBackgroundB = 1;
	    }
	    /**
	     *
	     */
	    DepthRenderer.prototype.enterNode = function (node) {
	        var enter = node._iCollectionMark != RendererBase_1.RendererBase._iCollectionMark && node.isCastingShadow();
	        if (!enter) {
	            node._iCollectionMark = RendererBase_1.RendererBase._iCollectionMark;
	            return false;
	        }
	        return _super.prototype.enterNode.call(this, node);
	    };
	    return DepthRenderer;
	}(RendererBase_1.RendererBase));
	exports.DepthRenderer = DepthRenderer;


/***/ },
/* 589 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_SurfacePassBase_1 = __webpack_require__(413);
	var ShaderBase_1 = __webpack_require__(271);
	/**
	 * GL_DepthSurface forms an abstract base class for the default shaded materials provided by Stage,
	 * using material methods to define their appearance.
	 */
	var GL_DepthSurface = (function (_super) {
	    __extends(GL_DepthSurface, _super);
	    /**
	     *
	     * @param pool
	     * @param surface
	     * @param elementsClass
	     * @param stage
	     */
	    function GL_DepthSurface(surface, elementsClass, renderPool) {
	        _super.call(this, surface, elementsClass, renderPool);
	        this._shader = new ShaderBase_1.ShaderBase(elementsClass, this, this._stage);
	        this._pAddPass(this);
	    }
	    GL_DepthSurface.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._textureVO = this._surface.getTextureAt(0) ? this._shader.getAbstraction(this._surface.getTextureAt(0)) : null;
	    };
	    GL_DepthSurface.prototype._iIncludeDependencies = function (shader) {
	        _super.prototype._iIncludeDependencies.call(this, shader);
	        shader.projectionDependencies++;
	        if (shader.alphaThreshold > 0)
	            shader.uvDependencies++;
	    };
	    GL_DepthSurface.prototype._iInitConstantData = function (shader) {
	        _super.prototype._iInitConstantData.call(this, shader);
	        var index = this._fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index] = 1.0;
	        data[index + 1] = 255.0;
	        data[index + 2] = 65025.0;
	        data[index + 3] = 16581375.0;
	        data[index + 4] = 1.0 / 255.0;
	        data[index + 5] = 1.0 / 255.0;
	        data[index + 6] = 1.0 / 255.0;
	        data[index + 7] = 0.0;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_DepthSurface.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code = "";
	        var targetReg = sharedRegisters.shadedTarget;
	        var dataReg1 = registerCache.getFreeFragmentConstant();
	        var dataReg2 = registerCache.getFreeFragmentConstant();
	        this._fragmentConstantsIndex = dataReg1.index * 4;
	        var temp1 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp1, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        code += "div " + temp1 + ", " + sharedRegisters.projectionFragment + ", " + sharedRegisters.projectionFragment + ".w\n" +
	            "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" +
	            "frc " + temp1 + ", " + temp1 + "\n" +
	            "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
	        //codeF += "mov ft1.w, fc1.w	\n" +
	        //    "mov ft0.w, fc0.x	\n";
	        if (this._textureVO && shader.alphaThreshold > 0) {
	            var albedo = registerCache.getFreeFragmentVectorTemp();
	            code += this._textureVO._iGetFragmentCode(albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	            var cutOffReg = registerCache.getFreeFragmentConstant();
	            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" +
	                "kil " + albedo + ".w\n";
	        }
	        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
	        registerCache.removeFragmentTempUsage(temp1);
	        registerCache.removeFragmentTempUsage(temp2);
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_DepthSurface.prototype._iActivate = function (camera) {
	        _super.prototype._iActivate.call(this, camera);
	        if (this._textureVO && this._shader.alphaThreshold > 0) {
	            this._textureVO.activate(this);
	            this._shader.fragmentConstantData[this._fragmentConstantsIndex + 8] = this._shader.alphaThreshold;
	        }
	    };
	    return GL_DepthSurface;
	}(GL_SurfacePassBase_1.GL_SurfacePassBase));
	exports.GL_DepthSurface = GL_DepthSurface;


/***/ },
/* 590 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var RendererBase_1 = __webpack_require__(418);
	var GL_DistanceSurface_1 = __webpack_require__(591);
	/**
	 * The DistanceRenderer class renders 32-bit depth information encoded as RGBA
	 *
	 * @class away.render.DistanceRenderer
	 */
	var DistanceRenderer = (function (_super) {
	    __extends(DistanceRenderer, _super);
	    /**
	     * Creates a new DistanceRenderer object.
	     * @param renderBlended Indicates whether semi-transparent objects should be rendered.
	     * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
	     */
	    function DistanceRenderer(stage) {
	        if (stage === void 0) { stage = null; }
	        _super.call(this, stage, GL_DistanceSurface_1.GL_DistanceSurface);
	        this._iBackgroundR = 1;
	        this._iBackgroundG = 1;
	        this._iBackgroundB = 1;
	    }
	    /**
	     *
	     */
	    DistanceRenderer.prototype.enterNode = function (node) {
	        var enter = node._iCollectionMark != RendererBase_1.RendererBase._iCollectionMark && node.isCastingShadow();
	        if (!enter) {
	            node._iCollectionMark = RendererBase_1.RendererBase._iCollectionMark;
	            return false;
	        }
	        return _super.prototype.enterNode.call(this, node);
	    };
	    return DistanceRenderer;
	}(RendererBase_1.RendererBase));
	exports.DistanceRenderer = DistanceRenderer;


/***/ },
/* 591 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var __extends = (this && this.__extends) || function (d, b) {
	    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
	    function __() { this.constructor = d; }
	    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
	};
	var GL_SurfacePassBase_1 = __webpack_require__(413);
	var ShaderBase_1 = __webpack_require__(271);
	/**
	 * DistanceRender is a pass that writes distance values to a depth map as a 32-bit value exploded over the 4 texture channels.
	 * This is used to render omnidirectional shadow maps.
	 */
	var GL_DistanceSurface = (function (_super) {
	    __extends(GL_DistanceSurface, _super);
	    /**
	     * Creates a new DistanceRender object.
	     *
	     * @param material The material to which this pass belongs.
	     */
	    function GL_DistanceSurface(surface, elementsClass, renderPool) {
	        _super.call(this, surface, elementsClass, renderPool);
	        this._shader = new ShaderBase_1.ShaderBase(elementsClass, this, this._stage);
	        this._pAddPass(this);
	    }
	    GL_DistanceSurface.prototype.invalidate = function () {
	        _super.prototype.invalidate.call(this);
	        this._textureVO = this._surface.getTextureAt(0) ? this._shader.getAbstraction(this._surface.getTextureAt(0)) : null;
	    };
	    /**
	     * Initializes the unchanging constant data for this material.
	     */
	    GL_DistanceSurface.prototype._iInitConstantData = function (shader) {
	        _super.prototype._iInitConstantData.call(this, shader);
	        var index = this._fragmentConstantsIndex;
	        var data = shader.fragmentConstantData;
	        data[index + 4] = 1.0 / 255.0;
	        data[index + 5] = 1.0 / 255.0;
	        data[index + 6] = 1.0 / 255.0;
	        data[index + 7] = 0.0;
	    };
	    GL_DistanceSurface.prototype._iIncludeDependencies = function (shader) {
	        _super.prototype._iIncludeDependencies.call(this, shader);
	        shader.projectionDependencies++;
	        shader.viewDirDependencies++;
	        if (shader.alphaThreshold > 0)
	            shader.uvDependencies++;
	        if (shader.viewDirDependencies > 0)
	            shader.globalPosDependencies++;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_DistanceSurface.prototype._iGetFragmentCode = function (shader, registerCache, sharedRegisters) {
	        var code;
	        var targetReg = sharedRegisters.shadedTarget;
	        var dataReg1 = registerCache.getFreeFragmentConstant();
	        var dataReg2 = registerCache.getFreeFragmentConstant();
	        this._fragmentConstantsIndex = dataReg1.index * 4;
	        var temp1 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp1, 1);
	        var temp2 = registerCache.getFreeFragmentVectorTemp();
	        registerCache.addFragmentTempUsages(temp2, 1);
	        // squared distance to view
	        code = "dp3 " + temp1 + ".z, " + sharedRegisters.viewDirVarying + ".xyz, " + sharedRegisters.viewDirVarying + ".xyz\n" +
	            "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" +
	            "frc " + temp1 + ", " + temp1 + "\n" +
	            "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
	        if (this._textureVO && shader.alphaThreshold > 0) {
	            var albedo = registerCache.getFreeFragmentVectorTemp();
	            code += this._textureVO._iGetFragmentCode(albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);
	            var cutOffReg = registerCache.getFreeFragmentConstant();
	            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" +
	                "kil " + albedo + ".w\n";
	        }
	        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
	        return code;
	    };
	    /**
	     * @inheritDoc
	     */
	    GL_DistanceSurface.prototype._iActivate = function (camera) {
	        _super.prototype._iActivate.call(this, camera);
	        var f = camera.projection.far;
	        f = 1 / (2 * f * f);
	        // sqrt(f*f+f*f) is largest possible distance for any frustum, so we need to divide by it. Rarely a tight fit, but with 32 bits precision, it's enough.
	        var index = this._fragmentConstantsIndex;
	        var data = this._shader.fragmentConstantData;
	        data[index] = 1.0 * f;
	        data[index + 1] = 255.0 * f;
	        data[index + 2] = 65025.0 * f;
	        data[index + 3] = 16581375.0 * f;
	        if (this._textureVO && this._shader.alphaThreshold > 0) {
	            this._textureVO.activate(this);
	            data[index + 8] = this._shader.alphaThreshold;
	        }
	    };
	    return GL_DistanceSurface;
	}(GL_SurfacePassBase_1.GL_SurfacePassBase));
	exports.GL_DistanceSurface = GL_DistanceSurface;


/***/ },
/* 592 */
/***/ function(module, exports, __webpack_require__) {

	"use strict";
	var Sampler2D_1 = __webpack_require__(121);
	var Rectangle_1 = __webpack_require__(57);
	var ContextGLDrawMode_1 = __webpack_require__(44);
	var ContextGLBlendFactor_1 = __webpack_require__(41);
	var ContextGLVertexBufferFormat_1 = __webpack_require__(52);
	var RTTEvent_1 = __webpack_require__(523);
	var RTTBufferManager_1 = __webpack_require__(540);
	/**
	 * @class away.render.Filter3DRenderer
	 */
	var Filter3DRenderer = (function () {
	    function Filter3DRenderer(stage) {
	        var _this = this;
	        this._filterSizesInvalid = true;
	        this._onRTTResizeDelegate = function (event) { return _this.onRTTResize(event); };
	        this._stage = stage;
	        this._rttManager = RTTBufferManager_1.RTTBufferManager.getInstance(stage);
	        this._rttManager.addEventListener(RTTEvent_1.RTTEvent.RESIZE, this._onRTTResizeDelegate);
	        this._sampler = new Sampler2D_1.Sampler2D(false, false, false);
	        this._renderToTextureRect = new Rectangle_1.Rectangle();
	    }
	    Filter3DRenderer.prototype.onRTTResize = function (event) {
	        this._filterSizesInvalid = true;
	    };
	    Object.defineProperty(Filter3DRenderer.prototype, "requireDepthRender", {
	        get: function () {
	            return this._requireDepthRender;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DRenderer.prototype.getMainInputTexture = function (stage) {
	        if (this._filterTasksInvalid)
	            this.updateFilterTasks(stage);
	        return this._mainInputTexture;
	    };
	    Object.defineProperty(Filter3DRenderer.prototype, "filters", {
	        get: function () {
	            return this._filters;
	        },
	        set: function (value) {
	            this._filters = value;
	            this._filterTasksInvalid = true;
	            this._requireDepthRender = false;
	            if (!this._filters)
	                return;
	            for (var i = 0; i < this._filters.length; ++i)
	                if (this._filters[i].requireDepthRender)
	                    this._requireDepthRender = true;
	            this._filterSizesInvalid = true;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DRenderer.prototype, "sampler", {
	        get: function () {
	            return this._sampler;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Object.defineProperty(Filter3DRenderer.prototype, "renderToTextureRect", {
	        get: function () {
	            if (this._filterSizesInvalid)
	                this.updateFilterSizes();
	            return this._renderToTextureRect;
	        },
	        enumerable: true,
	        configurable: true
	    });
	    Filter3DRenderer.prototype.updateFilterTasks = function (stage) {
	        var len;
	        if (this._filterSizesInvalid)
	            this.updateFilterSizes();
	        if (!this._filters) {
	            this._tasks = null;
	            return;
	        }
	        this._tasks = new Array();
	        len = this._filters.length - 1;
	        var filter;
	        for (var i = 0; i <= len; ++i) {
	            // make sure all internal tasks are linked together
	            filter = this._filters[i];
	            filter.setRenderTargets(i == len ? null : this._filters[i + 1].getMainInputTexture(stage), stage);
	            this._tasks = this._tasks.concat(filter.tasks);
	        }
	        this._mainInputTexture = this._filters[0].getMainInputTexture(stage);
	    };
	    Filter3DRenderer.prototype.render = function (stage, camera, depthTexture) {
	        var len;
	        var i;
	        var task;
	        var context = stage.context;
	        var indexBuffer = this._rttManager.indexBuffer;
	        var vertexBuffer = this._rttManager.renderToTextureVertexBuffer;
	        if (!this._filters)
	            return;
	        if (this._filterSizesInvalid)
	            this.updateFilterSizes();
	        if (this._filterTasksInvalid)
	            this.updateFilterTasks(stage);
	        len = this._filters.length;
	        for (i = 0; i < len; ++i)
	            this._filters[i].update(stage, camera);
	        len = this._tasks.length;
	        if (len > 1) {
	            context.setProgram(this._tasks[0].getProgram(stage));
	            context.setVertexBufferAt(this._tasks[0]._positionIndex, vertexBuffer, 0, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2);
	            context.setVertexBufferAt(this._tasks[0]._uvIndex, vertexBuffer, 8, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2);
	        }
	        for (i = 0; i < len; ++i) {
	            task = this._tasks[i];
	            stage.setRenderTarget(task.target);
	            context.setProgram(task.getProgram(stage));
	            stage.getAbstraction(this._sampler).activate(task._inputTextureIndex);
	            stage.getAbstraction(task.getMainInputTexture(stage)).activate(task._inputTextureIndex, this._sampler.mipmap);
	            if (!task.target) {
	                stage.scissorRect = null;
	                vertexBuffer = this._rttManager.renderToScreenVertexBuffer;
	                context.setVertexBufferAt(task._positionIndex, vertexBuffer, 0, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2);
	                context.setVertexBufferAt(task._uvIndex, vertexBuffer, 8, ContextGLVertexBufferFormat_1.ContextGLVertexBufferFormat.FLOAT_2);
	            }
	            context.clear(0.0, 0.0, 0.0, 0.0);
	            task.activate(stage, camera, depthTexture);
	            context.setBlendFactors(ContextGLBlendFactor_1.ContextGLBlendFactor.ONE, ContextGLBlendFactor_1.ContextGLBlendFactor.ZERO);
	            context.drawIndices(ContextGLDrawMode_1.ContextGLDrawMode.TRIANGLES, indexBuffer, 0, 6);
	            task.deactivate(stage);
	        }
	        context.setTextureAt(0, null);
	        context.setVertexBufferAt(0, null);
	        context.setVertexBufferAt(1, null);
	    };
	    Filter3DRenderer.prototype.updateFilterSizes = function () {
	        for (var i = 0; i < this._filters.length; ++i) {
	            this._filters[i].textureWidth = this._rttManager.textureWidth;
	            this._filters[i].textureHeight = this._rttManager.textureHeight;
	            this._filters[i].rttManager = this._rttManager;
	        }
	        var scale = this._filters[0].textureScale;
	        this._renderToTextureRect.x = this._rttManager.renderToTextureRect.x / scale;
	        this._renderToTextureRect.y = this._rttManager.renderToTextureRect.y / scale;
	        this._renderToTextureRect.width = this._rttManager.renderToTextureRect.width / scale;
	        this._renderToTextureRect.height = this._rttManager.renderToTextureRect.height / scale;
	        this._filterSizesInvalid = false;
	    };
	    Filter3DRenderer.prototype.dispose = function () {
	        this._rttManager.removeEventListener(RTTEvent_1.RTTEvent.RESIZE, this._onRTTResizeDelegate);
	        this._rttManager = null;
	        this._stage = null;
	    };
	    return Filter3DRenderer;
	}());
	exports.Filter3DRenderer = Filter3DRenderer;


/***/ }
/******/ ]);
//# sourceMappingURL=awayjs-full.bundle.js.map