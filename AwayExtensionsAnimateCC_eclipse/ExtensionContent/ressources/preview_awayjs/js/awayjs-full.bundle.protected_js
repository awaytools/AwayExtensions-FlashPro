/******/ (function(modules) { // webpackBootstrap
/******/ 	// install a JSONP callback for chunk loading
/******/ 	var parentJsonpFunction = window["webpackJsonp"];
/******/ 	window["webpackJsonp"] = function webpackJsonpCallback(chunkIds, moreModules, executeModules) {
/******/ 		// add "moreModules" to the modules object,
/******/ 		// then flag all "chunkIds" as loaded and fire callback
/******/ 		var moduleId, chunkId, i = 0, resolves = [], result;
/******/ 		for(;i < chunkIds.length; i++) {
/******/ 			chunkId = chunkIds[i];
/******/ 			if(installedChunks[chunkId])
/******/ 				resolves.push(installedChunks[chunkId][0]);
/******/ 			installedChunks[chunkId] = 0;
/******/ 		}
/******/ 		for(moduleId in moreModules) {
/******/ 			if(Object.prototype.hasOwnProperty.call(moreModules, moduleId)) {
/******/ 				modules[moduleId] = moreModules[moduleId];
/******/ 			}
/******/ 		}
/******/ 		if(parentJsonpFunction) parentJsonpFunction(chunkIds, moreModules, executeModules);
/******/ 		while(resolves.length)
/******/ 			resolves.shift()();
/******/ 		if(executeModules) {
/******/ 			for(i=0; i < executeModules.length; i++) {
/******/ 				result = __webpack_require__(__webpack_require__.s = executeModules[i]);
/******/ 			}
/******/ 		}
/******/ 		return result;
/******/ 	};
/******/
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// objects to store loaded and loading chunks
/******/ 	var installedChunks = {
/******/ 		22: 0
/******/ 	};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/ 	// This file contains only the entry chunk.
/******/ 	// The chunk loading function for additional chunks
/******/ 	__webpack_require__.e = function requireEnsure(chunkId) {
/******/ 		if(installedChunks[chunkId] === 0)
/******/ 			return Promise.resolve();
/******/
/******/ 		// an Promise means "currently loading".
/******/ 		if(installedChunks[chunkId]) {
/******/ 			return installedChunks[chunkId][2];
/******/ 		}
/******/ 		// start chunk loading
/******/ 		var head = document.getElementsByTagName('head')[0];
/******/ 		var script = document.createElement('script');
/******/ 		script.type = 'text/javascript';
/******/ 		script.charset = 'utf-8';
/******/ 		script.async = true;
/******/ 		script.timeout = 120000;
/******/
/******/ 		script.src = __webpack_require__.p + "js/" + chunkId + ".js";
/******/ 		var timeout = setTimeout(onScriptComplete, 120000);
/******/ 		script.onerror = script.onload = onScriptComplete;
/******/ 		function onScriptComplete() {
/******/ 			// avoid mem leaks in IE.
/******/ 			script.onerror = script.onload = null;
/******/ 			clearTimeout(timeout);
/******/ 			var chunk = installedChunks[chunkId];
/******/ 			if(chunk !== 0) {
/******/ 				if(chunk) chunk[1](new Error('Loading chunk ' + chunkId + ' failed.'));
/******/ 				installedChunks[chunkId] = undefined;
/******/ 			}
/******/ 		};
/******/ 		head.appendChild(script);
/******/
/******/ 		var promise = new Promise(function(resolve, reject) {
/******/ 			installedChunks[chunkId] = [resolve, reject];
/******/ 		});
/******/ 		return installedChunks[chunkId][2] = promise;
/******/ 	};
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmory imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmory exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		Object.defineProperty(exports, name, {
/******/ 			configurable: false,
/******/ 			enumerable: true,
/******/ 			get: getter
/******/ 		});
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// on error function for async loading
/******/ 	__webpack_require__.oe = function(err) { console.error(err); throw err; };
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 43);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_core__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_core__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_core__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_scene__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_scene___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_scene__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_scene__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_scene__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_core__ = __webpack_require__(7);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_core___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_core__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__awayjs_stage__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__awayjs_stage___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__ = __webpack_require__(10);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__awayjs_scene___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_3__awayjs_scene__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__awayjs_renderer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__awayjs_materials__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__awayjs_materials___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_5__awayjs_materials__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__awayjs_view__ = __webpack_require__(16);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__awayjs_view___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_6__awayjs_view__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_6__awayjs_view__[key]; }) }(__WEBPACK_IMPORT_KEY__));








//enable parsers
__WEBPACK_IMPORTED_MODULE_0__awayjs_core__["Loader"].enableParser(__WEBPACK_IMPORTED_MODULE_0__awayjs_core__["WaveAudioParser"]);
__WEBPACK_IMPORTED_MODULE_0__awayjs_core__["Loader"].enableParser(__WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["Image2DParser"]);
__WEBPACK_IMPORTED_MODULE_0__awayjs_core__["Loader"].enableParser(__WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["ImageCubeParser"]);
__WEBPACK_IMPORTED_MODULE_0__awayjs_core__["Loader"].enableParser(__WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["TextureAtlasParser"]);
//register core attributes
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_AttributesBuffer"], __WEBPACK_IMPORTED_MODULE_0__awayjs_core__["AttributesBuffer"]);
//register scene entities
__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["DefaultMaterialGroup"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["GL_SkyboxMaterial"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Skybox"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["RenderablePool"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["GL_BillboardRenderable"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Billboard"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["RenderablePool"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["GL_LineSegmentRenderable"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["LineSegment"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["RenderablePool"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_ShapeRenderable"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["Shape"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["RenderablePool"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["GL_SkyboxRenderable"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Skybox"]);
//register graphics images
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_RenderImage2D"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["Image2D"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_RenderImageCube"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["ImageCube"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_BitmapImage2D"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["BitmapImage2D"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_ExternalImage2D"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["ExternalImage2D"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_BitmapImageCube"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["BitmapImageCube"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_BitmapImage2D"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["SpecularImage2D"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_Sampler2D"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["Sampler2D"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_SamplerCube"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["SamplerCube"]);
//register graphics elements
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["GL_LineElements"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["LineElements"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["Stage"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_TriangleElements"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["TriangleElements"]);
//register graphics textures
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["ShaderBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_Single2DTexture"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["Single2DTexture"]);
__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["ShaderBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_SingleCubeTexture"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["SingleCubeTexture"]);
//register graphics materials
__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["DefaultMaterialGroup"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_2__awayjs_stage__["GL_BasicMaterial"], __WEBPACK_IMPORTED_MODULE_1__awayjs_graphics__["BasicMaterial"]);
//regiater material materials
__WEBPACK_IMPORTED_MODULE_4__awayjs_renderer__["DefaultMaterialGroup"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_5__awayjs_materials__["GL_MethodMaterial"], __WEBPACK_IMPORTED_MODULE_5__awayjs_materials__["MethodMaterial"]);
//register view nodes
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["CameraNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Camera"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["DirectionalLight"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Sprite"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["DisplayObjectContainer"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Scene"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["MovieClip"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Billboard"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["LineSegment"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["TextField"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["LightProbe"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["EntityNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["PointLight"]);
__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["PartitionBase"].registerAbstraction(__WEBPACK_IMPORTED_MODULE_6__awayjs_view__["SkyboxNode"], __WEBPACK_IMPORTED_MODULE_3__awayjs_scene__["Skybox"]);


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_graphics__ = __webpack_require__(9);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_graphics___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_graphics__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_graphics__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_graphics__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_materials__ = __webpack_require__(14);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_materials___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_materials__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_materials__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_materials__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_parsers__ = __webpack_require__(15);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_parsers___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_parsers__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_parsers__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_parsers__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 6 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_renderer__ = __webpack_require__(12);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_renderer___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_renderer__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_renderer__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_renderer__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (factory((global.AwayjsCore = global.AwayjsCore || {})));
}(this, (function (exports) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

var ErrorBase = (function () {
    function ErrorBase(message, id, _name) {
        if (message === void 0) { message = ''; }
        if (id === void 0) { id = 0; }
        if (_name === void 0) { _name = ''; }
        this._errorID = 0; //Contains the reference number associated with the specific error message.
        this._messsage = ''; //Contains the message associated with the Error object.
        this._name = ''; // Contains the name of the Error object.
        this._messsage = message;
        this._name = name;
        this._errorID = id;
    }
    Object.defineProperty(ErrorBase.prototype, "message", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._messsage;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            this._messsage = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorBase.prototype, "name", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._name;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            this._name = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ErrorBase.prototype, "errorID", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._errorID;
        },
        enumerable: true,
        configurable: true
    });
    return ErrorBase;
}());

/**
 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
 * by a concrete subclass.
 */
var AbstractMethodError = (function (_super) {
    __extends(AbstractMethodError, _super);
    /**
     * Create a new AbstractMethodError.
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function AbstractMethodError(message, id) {
        if (message === void 0) { message = null; }
        if (id === void 0) { id = 0; }
        return _super.call(this, message || "An abstract method was called! Either an instance of an abstract export class was created, or an abstract method was not overridden by the subclass.", id) || this;
    }
    return AbstractMethodError;
}(ErrorBase));

var EventBase = (function () {
    function EventBase(type) {
        /**
         * Type of event
         * @property type
         * @type String
         */
        this.type = undefined;
        /**
         * Reference to target object
         * @property target
         * @type Object
         */
        this.target = undefined;
        this.type = type;
    }
    /**
     * Clones the current event.
     * @return An exact duplicate of the current event.
     */
    EventBase.prototype.clone = function () {
        return new EventBase(this.type);
    };
    return EventBase;
}());

/**
 * @export class away.events.AssetEvent
 */
var AssetEvent = (function (_super) {
    __extends(AssetEvent, _super);
    /**
     *
     */
    function AssetEvent(type, asset, prevName) {
        if (prevName === void 0) { prevName = null; }
        var _this = _super.call(this, type) || this;
        _this._asset = asset;
        _this._prevName = prevName || _this._asset.name;
        return _this;
    }
    Object.defineProperty(AssetEvent.prototype, "asset", {
        /**
         *
         */
        get: function () {
            return this._asset;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetEvent.prototype, "prevName", {
        /**
         *
         */
        get: function () {
            return this._prevName;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    AssetEvent.prototype.clone = function () {
        return new AssetEvent(this.type, this._asset, this._prevName);
    };
    return AssetEvent;
}(EventBase));
/**
 * Dispatched when the content of an asset is invalidated
 */
AssetEvent.INVALIDATE = "invalidate";
/**
 * Dispatched when an asset is diposed
 */
AssetEvent.DISPOSE = "dispose";
/**
 * Dispatched when an asset is cleared
 */
AssetEvent.CLEAR = "clear";
/**
 *
 */
AssetEvent.RENAME = 'rename';
/**
 *
 */
AssetEvent.ENTER_FRAME = 'enterFrame';
/**
 *
 */
AssetEvent.EXIT_FRAME = 'exitFrame';
/**
 *
 */
AssetEvent.ASSET_CONFLICT_RESOLVED = 'assetConflictResolved';
/**
 * Dispatched when the loading of an asset and all of its dependencies is complete.
 */
AssetEvent.ASSET_COMPLETE = "assetComplete";
/**
 *
 */
AssetEvent.TEXTURE_SIZE_ERROR = 'textureSizeError';

/**
 * Base export class for dispatching events
*
* @export class away.events.EventDispatcher
*
*/
var EventDispatcher = (function () {
    function EventDispatcher(target) {
        if (target === void 0) { target = null; }
        this.listenerObjects = new Array();
        this.target = target || this;
    }
    /**
     * Add an event listener
     * @method addEventListener
     * @param {String} Name of event to add a listener for
     * @param {Function} Callback function
     */
    EventDispatcher.prototype.addEventListener = function (type, listener) {
        var l = this.listenerObjects[type];
        if (l === undefined)
            l = this.listenerObjects[type] = new ListenerObject();
        l.addEventListener(listener);
    };
    /**
     * Remove an event listener
     * @method removeEventListener
     * @param {String} Name of event to remove a listener for
     * @param {Function} Callback function
     */
    EventDispatcher.prototype.removeEventListener = function (type, listener) {
        var l = this.listenerObjects[type];
        if (l) {
            l.removeEventListener(listener);
            if (l.numListeners == 0)
                delete this.listenerObjects[type];
        }
    };
    /**
     * Dispatch an event
     * @method dispatchEvent
     * @param {Event} Event to dispatch
     */
    EventDispatcher.prototype.dispatchEvent = function (event) {
        var l = this.listenerObjects[event.type];
        if (l) {
            event.target = this.target;
            l.dispatchEvent(event);
        }
    };
    /**
     * check if an object has an event listener assigned to it
     * @method hasListener
     * @param {String} Name of event to remove a listener for
     * @param {Function} Callback function
     */
    EventDispatcher.prototype.hasEventListener = function (type, listener) {
        if (this.listenerObjects[type] === undefined)
            return false;
        if (listener != null)
            return this.listenerObjects[type].getEventListenerIndex(listener) !== -1;
        return this.listenerObjects[type].numListeners > 0;
    };
    return EventDispatcher;
}());
var ListenerObject = (function () {
    function ListenerObject() {
        this.index = 0;
        this.listeners = new Array();
        this.numListeners = 0;
    }
    ListenerObject.prototype.addEventListener = function (listener) {
        //check if listener already added
        if (this.getEventListenerIndex(listener) !== -1)
            return;
        this.listeners.push(listener);
        this.numListeners++;
    };
    ListenerObject.prototype.removeEventListener = function (listener) {
        //check if listener exists
        var index = this.getEventListenerIndex(listener);
        if (index === -1)
            return;
        this.listeners.splice(index, 1);
        if (index <= this.index)
            this.index--;
        this.numListeners--;
    };
    ListenerObject.prototype.dispatchEvent = function (event) {
        var len = this.numListeners;
        for (this.index = 0; this.index < len && this.index < this.numListeners; this.index++)
            this.listeners[this.index](event);
    };
    /**
     * get Event Listener Index in array. Returns -1 if no listener is added
     * @method getEventListenerIndex
     * @param {String} Name of event to remove a listener for
     * @param {Function} Callback function
     */
    ListenerObject.prototype.getEventListenerIndex = function (listener) {
        for (var index = 0; index < this.numListeners; index++)
            if (listener == this.listeners[index])
                return index;
        return -1;
    };
    return ListenerObject;
}());

var AssetBase = (function (_super) {
    __extends(AssetBase, _super);
    function AssetBase(name) {
        if (name === void 0) { name = null; }
        var _this = _super.call(this) || this;
        _this._id = AssetBase.ID_COUNT++;
        if (name == null)
            name = 'null';
        _this._name = name;
        _this._originalName = name;
        _this.updateFullPath();
        return _this;
    }
    Object.defineProperty(AssetBase.prototype, "adaptee", {
        get: function () {
            return this;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetBase.prototype, "adapter", {
        /**
         * adapter is used to provide MovieClip to scripts taken from different platforms
         * setter typically managed by factory. getter defaults to AwayJS class
         */
        get: function () {
            return this._adapter || this;
        },
        set: function (value) {
            this._adapter = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetBase.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            throw new AbstractMethodError();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetBase.prototype, "originalName", {
        /**
         * The original name used for this asset in the resource (e.g. file) in which
         * it was found. This may not be the same as <code>name</code>, which may
         * have changed due to of a name conflict.
         */
        get: function () {
            return this._originalName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetBase.prototype, "id", {
        /**
         * A unique id for the asset, used to identify assets in an associative array
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetBase.prototype, "name", {
        get: function () {
            return this._name;
        },
        set: function (val) {
            var prev;
            prev = this._name;
            this._name = val;
            if (this._name == null)
                this._name = 'null';
            this.updateFullPath();
            this.dispatchEvent(new AssetEvent(AssetEvent.RENAME, this, prev));
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    AssetBase.prototype.invalidate = function () {
        this.dispatchEvent(new AssetEvent(AssetEvent.INVALIDATE, this));
    };
    /**
     * @inheritDoc
     */
    AssetBase.prototype.dispose = function () {
        this.dispatchEvent(new AssetEvent(AssetEvent.DISPOSE, this));
    };
    AssetBase.prototype.clear = function () {
        this.dispatchEvent(new AssetEvent(AssetEvent.CLEAR, this));
    };
    Object.defineProperty(AssetBase.prototype, "assetNamespace", {
        get: function () {
            return this._namespace;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetBase.prototype, "assetFullPath", {
        get: function () {
            return this._full_path;
        },
        enumerable: true,
        configurable: true
    });
    AssetBase.prototype.assetPathEquals = function (name, ns) {
        return (this._name == name && (!ns || this._namespace == ns));
    };
    AssetBase.prototype.isAsset = function (assetClass) {
        return this.assetType == assetClass.assetType;
    };
    AssetBase.prototype.resetAssetPath = function (name, ns, overrideOriginal) {
        if (ns === void 0) { ns = null; }
        if (overrideOriginal === void 0) { overrideOriginal = true; }
        this._name = name ? name : 'null';
        this._namespace = ns ? ns : AssetBase.DEFAULT_NAMESPACE;
        if (overrideOriginal)
            this._originalName = this._name;
        this.updateFullPath();
    };
    AssetBase.prototype.updateFullPath = function () {
        this._full_path = [this._namespace, this._name];
    };
    return AssetBase;
}(EventDispatcher));
AssetBase.ID_COUNT = 0;
AssetBase.DEFAULT_NAMESPACE = 'default';

var AttributesBuffer = (function (_super) {
    __extends(AttributesBuffer, _super);
    /**
     *
     */
    function AttributesBuffer(stride, count) {
        if (stride === void 0) { stride = 0; }
        if (count === void 0) { count = 0; }
        var _this = _super.call(this) || this;
        _this._count = 0;
        _this._newCount = 0;
        _this._stride = 0;
        _this._newStride = 0;
        _this._viewVOs = new Array();
        _this._stride = _this._newStride = stride;
        _this._count = _this._newCount = count;
        _this._buffer = new ArrayBuffer(_this._stride * _this._count);
        _this._bufferView = new Uint8Array(_this._buffer, 0, _this._buffer.byteLength);
        return _this;
    }
    Object.defineProperty(AttributesBuffer.prototype, "assetType", {
        /**
         * @returns {string}
         */
        get: function () {
            return AttributesBuffer.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesBuffer.prototype, "stride", {
        get: function () {
            if (this._lengthDirty)
                this._updateLength();
            return this._stride;
        },
        set: function (value) {
            if (this._newStride == value)
                return;
            this._newStride = value;
            this.resize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesBuffer.prototype, "newCount", {
        get: function () {
            return this._newCount;
        },
        set: function (value) {
            if (this._newCount == value)
                return;
            this._newCount = value;
            this.resize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesBuffer.prototype, "count", {
        get: function () {
            return this._count;
        },
        set: function (value) {
            if (this._count == value)
                return;
            this._count = value;
            this.resize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesBuffer.prototype, "buffer", {
        get: function () {
            if (this._lengthDirty)
                this._updateLength();
            this._contentDirty = false;
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesBuffer.prototype, "bufferView", {
        get: function () {
            if (this._lengthDirty)
                this._updateLength();
            this._contentDirty = false;
            return this._bufferView;
        },
        set: function (value) {
            this._bufferView = value;
            this._buffer = this._bufferView.buffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesBuffer.prototype, "length", {
        get: function () {
            return this._count * this.stride;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    AttributesBuffer.prototype.invalidate = function () {
        if (this._contentDirty)
            return;
        _super.prototype.invalidate.call(this);
        this._contentDirty = true;
    };
    /**
     *
     * @private
     */
    AttributesBuffer.prototype.resize = function () {
        if (this._lengthDirty)
            return;
        this.clear();
        this._lengthDirty = true;
        //dispose buffer if stride is 0
        if (!this._newStride) {
            this._buffer = null;
            this._bufferView = null;
        }
    };
    AttributesBuffer.prototype.clone = function () {
        var attributesBuffer = new AttributesBuffer(this._stride, this._count);
        attributesBuffer.bufferView.set(this.bufferView);
        var len = this._viewVOs.length;
        for (var i = 0; i < len; i++)
            this._viewVOs[i].view._internalClone(attributesBuffer);
        return attributesBuffer;
    };
    AttributesBuffer.prototype.getView = function (index) {
        if (index < this._viewVOs.length)
            return this._viewVOs[index].view;
        return null;
    };
    AttributesBuffer.prototype._setAttributes = function (viewIndex, arrayBufferView, offset) {
        if (offset === void 0) { offset = 0; }
        var array = (arrayBufferView instanceof Uint8Array) ? arrayBufferView : new Uint8Array(arrayBufferView.buffer);
        var viewVO = this._viewVOs[viewIndex];
        var vLength = viewVO.length;
        var vOffset = viewVO.offset;
        var vCount = array.length / vLength;
        //make sure there is enough space in the buffer
        if (this.newCount < vCount + offset)
            this.newCount = vCount + offset;
        if (this._lengthDirty)
            this._updateLength();
        //fast path for separate buffers
        if (this._viewVOs.length == 1) {
            this._bufferView.set(array);
        }
        else {
            for (var i = 0; i < vCount; i++)
                this._bufferView.set(array.subarray(i * vLength, (i + 1) * vLength), (i + offset) * this._stride + vOffset);
        }
        this.invalidate();
    };
    AttributesBuffer.prototype._addView = function (view) {
        var viewVO = new ViewVO(view);
        var len = this._viewVOs.length;
        viewVO.offset = len ? this._viewVOs[len - 1].offset + this._viewVOs[len - 1].length : 0;
        this._viewVOs.push(viewVO);
        if (this._newStride < viewVO.offset + viewVO.length) {
            this._newStride = viewVO.offset + viewVO.length;
            this.resize();
        }
        view._index = len;
    };
    AttributesBuffer.prototype._removeView = function (view) {
        var viewIndex = view._index;
        var viewVO = this._viewVOs.splice(viewIndex, 1)[0];
        var len = this._viewVOs.length;
        viewVO.dispose();
        for (var i = viewIndex; i < len; i++) {
            viewVO = this._viewVOs[i];
            viewVO.offset = i ? this._viewVOs[i - 1].offset + this._viewVOs[i - 1].length : 0;
            viewVO.view._index = i;
        }
        this._newStride = viewVO.offset + viewVO.length;
        this.resize();
    };
    AttributesBuffer.prototype._getOffset = function (viewIndex) {
        return this._viewVOs[viewIndex].offset;
    };
    AttributesBuffer.prototype._updateLength = function () {
        this._lengthDirty = false;
        var i;
        var j;
        var len = this._viewVOs.length;
        var newLength = this._newStride * this._newCount;
        if (!this._buffer || this._buffer.byteLength != newLength) {
            var newBuffer = new ArrayBuffer(newLength);
            var newView = new Uint8Array(newBuffer, 0, newBuffer.byteLength);
            var viewVO;
            var vLength;
            var vOffset;
            var vOldOffset;
            if (this._stride != this._newStride) {
                for (i = 0; i < len; i++) {
                    viewVO = this._viewVOs[i];
                    vLength = viewVO.length;
                    vOffset = viewVO.offset;
                    vOldOffset = viewVO.oldOffset;
                    for (j = 0; j < this._count; j++)
                        if (vOldOffset != null)
                            newView.set(new Uint8Array(this._buffer, j * this._stride + vOldOffset, vLength), j * this._newStride + vOffset);
                    viewVO.oldOffset = viewVO.offset;
                }
                this._stride = this._newStride;
            }
            else {
                newView.set(new Uint8Array(this._buffer, 0, Math.min(newLength, this._buffer.byteLength))); //TODO: bypass quantisation of bytearray on instantiation
            }
            this._buffer = newBuffer;
            this._bufferView = newView;
        }
        this._count = this._newCount;
    };
    return AttributesBuffer;
}(AssetBase));
AttributesBuffer.assetType = "[assets AttributesBuffer]";
var ViewVO = (function () {
    function ViewVO(view) {
        this.view = view;
        this.length = view.size * view.dimensions;
    }
    ViewVO.prototype.dispose = function () {
        this.view = null;
    };
    ViewVO.prototype.clone = function () {
        return new ViewVO(this.view);
    };
    return ViewVO;
}());

var AttributesView = (function (_super) {
    __extends(AttributesView, _super);
    function AttributesView(arrayClass, dimensions, attributesBufferCount, unsigned) {
        if (attributesBufferCount === void 0) { attributesBufferCount = 0; }
        if (unsigned === void 0) { unsigned = false; }
        var _this = _super.call(this) || this;
        _this._arrayClass = arrayClass;
        _this._size = arrayClass.BYTES_PER_ELEMENT;
        _this._dimensions = dimensions;
        _this._attributesBuffer = (attributesBufferCount instanceof AttributesBuffer) ? attributesBufferCount : new AttributesBuffer(_this._dimensions * _this._size, attributesBufferCount);
        _this._attributesBuffer._addView(_this);
        _this._unsigned = unsigned;
        return _this;
    }
    Object.defineProperty(AttributesView.prototype, "assetType", {
        /**
         *
         *
         */
        get: function () {
            return AttributesView.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "attributesBuffer", {
        get: function () {
            return this._attributesBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "size", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._size;
        },
        set: function (value) {
            if (this._size == value)
                return;
            this._size = value;
            this._attributesBuffer._removeView(this);
            this._attributesBuffer._addView(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "dimensions", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._dimensions;
        },
        set: function (value) {
            if (this._dimensions == value)
                return;
            this._dimensions = value;
            //reset view
            this._attributesBuffer._removeView(this);
            this._attributesBuffer._addView(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "unsigned", {
        get: function () {
            return this._unsigned;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "count", {
        get: function () {
            return this._attributesBuffer.count;
        },
        set: function (value) {
            this._attributesBuffer.count = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "offset", {
        get: function () {
            return this._attributesBuffer._getOffset(this._index);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "length", {
        get: function () {
            return this._attributesBuffer.count * this._dimensions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AttributesView.prototype, "stride", {
        get: function () {
            return this._attributesBuffer.stride / this._size;
        },
        enumerable: true,
        configurable: true
    });
    AttributesView.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        this._attributesBuffer._setAttributes(this._index, (values instanceof Array) ? new (this._arrayClass)(values) : values, offset);
    };
    AttributesView.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return new (this._arrayClass)(this._attributesBuffer.buffer, offset * this._attributesBuffer.stride + this.offset, count * this.stride - this.offset / this.size);
    };
    AttributesView.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new AttributesView(this._arrayClass, this._dimensions, attributesBuffer, this._unsigned));
    };
    AttributesView.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        if (attributesBuffer)
            this._internalClone(attributesBuffer);
        if (!this._cloneCache)
            this._attributesBuffer.clone();
        var cloneCache = this._cloneCache;
        this._cloneCache = null;
        return cloneCache;
    };
    AttributesView.prototype.invalidate = function () {
        _super.prototype.invalidate.call(this);
        this._attributesBuffer.invalidate();
    };
    /**
     * @inheritDoc
     */
    AttributesView.prototype.dispose = function () {
        if (!this._attributesBuffer)
            return;
        this._attributesBuffer._removeView(this);
        this._attributesBuffer = null;
    };
    return AttributesView;
}(AssetBase));
AttributesView.assetType = "[attributes AttributesView]";

var Byte4Attributes = (function (_super) {
    __extends(Byte4Attributes, _super);
    function Byte4Attributes(attributesBufferLength, unsigned) {
        if (unsigned === void 0) { unsigned = true; }
        return _super.call(this, unsigned ? Uint8Array : Int8Array, 4, attributesBufferLength, unsigned) || this;
    }
    Object.defineProperty(Byte4Attributes.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Byte4Attributes.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Byte4Attributes.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.set.call(this, values, offset);
    };
    Byte4Attributes.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.prototype.get.call(this, count, offset);
    };
    Byte4Attributes.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new Byte4Attributes(attributesBuffer, this._arrayClass == Uint8Array));
    };
    Byte4Attributes.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        return _super.prototype.clone.call(this, attributesBuffer);
    };
    return Byte4Attributes;
}(AttributesView));
Byte4Attributes.assetType = "[attributes Byte4Attributes]";

var Float1Attributes = (function (_super) {
    __extends(Float1Attributes, _super);
    function Float1Attributes(attributesBufferLength) {
        return _super.call(this, Float32Array, 1, attributesBufferLength) || this;
    }
    Object.defineProperty(Float1Attributes.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Float1Attributes.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Float1Attributes.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.set.call(this, values, offset);
    };
    Float1Attributes.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.prototype.get.call(this, count, offset);
    };
    Float1Attributes.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new Float1Attributes(attributesBuffer));
    };
    Float1Attributes.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        return _super.prototype.clone.call(this, attributesBuffer);
    };
    return Float1Attributes;
}(AttributesView));
Float1Attributes.assetType = "[attributes Float1Attributes]";

var Float2Attributes = (function (_super) {
    __extends(Float2Attributes, _super);
    function Float2Attributes(attributesBufferLength) {
        return _super.call(this, Float32Array, 2, attributesBufferLength) || this;
    }
    Object.defineProperty(Float2Attributes.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Float2Attributes.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Float2Attributes.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.set.call(this, values, offset);
    };
    Float2Attributes.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.prototype.get.call(this, count, offset);
    };
    Float2Attributes.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new Float2Attributes(attributesBuffer));
    };
    Float2Attributes.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        return _super.prototype.clone.call(this, attributesBuffer);
    };
    return Float2Attributes;
}(AttributesView));
Float2Attributes.assetType = "[attributes Float2Attributes]";

var Float3Attributes = (function (_super) {
    __extends(Float3Attributes, _super);
    function Float3Attributes(attributesBufferLength) {
        return _super.call(this, Float32Array, 3, attributesBufferLength) || this;
    }
    Object.defineProperty(Float3Attributes.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Float3Attributes.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Float3Attributes.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.set.call(this, values, offset);
    };
    Float3Attributes.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.prototype.get.call(this, count, offset);
    };
    Float3Attributes.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new Float3Attributes(attributesBuffer));
    };
    Float3Attributes.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        return _super.prototype.clone.call(this, attributesBuffer);
    };
    return Float3Attributes;
}(AttributesView));
Float3Attributes.assetType = "[attributes Float3Attributes]";

var Float4Attributes = (function (_super) {
    __extends(Float4Attributes, _super);
    function Float4Attributes(attributesBufferLength) {
        return _super.call(this, Float32Array, 4, attributesBufferLength) || this;
    }
    Object.defineProperty(Float4Attributes.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Float4Attributes.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Float4Attributes.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.set.call(this, values, offset);
    };
    Float4Attributes.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.prototype.get.call(this, count, offset);
    };
    Float4Attributes.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new Float4Attributes(attributesBuffer));
    };
    Float4Attributes.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        return _super.prototype.clone.call(this, attributesBuffer);
    };
    return Float4Attributes;
}(AttributesView));
Float4Attributes.assetType = "[attributes Float4Attributes]";

var Short2Attributes = (function (_super) {
    __extends(Short2Attributes, _super);
    function Short2Attributes(attributesBufferLength, unsigned) {
        if (unsigned === void 0) { unsigned = true; }
        return _super.call(this, unsigned ? Uint16Array : Int16Array, 2, attributesBufferLength, unsigned) || this;
    }
    Object.defineProperty(Short2Attributes.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Short2Attributes.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Short2Attributes.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.set.call(this, values, offset);
    };
    Short2Attributes.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.prototype.get.call(this, count, offset);
    };
    Short2Attributes.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new Short2Attributes(attributesBuffer, this._arrayClass == Uint16Array));
    };
    Short2Attributes.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        return _super.prototype.clone.call(this, attributesBuffer);
    };
    return Short2Attributes;
}(AttributesView));
Short2Attributes.assetType = "[attributes Short2Attributes]";

var Short3Attributes = (function (_super) {
    __extends(Short3Attributes, _super);
    function Short3Attributes(attributesBufferLength, unsigned) {
        if (unsigned === void 0) { unsigned = true; }
        return _super.call(this, unsigned ? Uint16Array : Int16Array, 3, attributesBufferLength, unsigned) || this;
    }
    Object.defineProperty(Short3Attributes.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Short3Attributes.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Short3Attributes.prototype.set = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.set.call(this, values, offset);
    };
    Short3Attributes.prototype.get = function (count, offset) {
        if (offset === void 0) { offset = 0; }
        return _super.prototype.get.call(this, count, offset);
    };
    Short3Attributes.prototype._internalClone = function (attributesBuffer) {
        return (this._cloneCache = new Short3Attributes(attributesBuffer, this._arrayClass == Uint16Array));
    };
    Short3Attributes.prototype.clone = function (attributesBuffer) {
        if (attributesBuffer === void 0) { attributesBuffer = null; }
        return _super.prototype.clone.call(this, attributesBuffer);
    };
    return Short3Attributes;
}(AttributesView));
Short3Attributes.assetType = "[attributes Short3Attributes]";

var StreamingAudioChannel = (function () {
    function StreamingAudioChannel() {
        var _this = this;
        this._isPlaying = false;
        this._isLooping = false;
        this._startTime = 0;
        this._sourceOpenDelegate = function (event) { return _this._sourceOpen(event); };
        this._updateEndDelegate = function (event) { return _this._updateEnd(event); };
        this._audio = new Audio();
        this._audio.ontimeupdate = function (event) { return _this._onTimeUpdate(event); };
        this._updateSource();
    }
    StreamingAudioChannel.stopAllSounds = function () {
        var len = StreamingAudioChannel._channels.length;
        for (var j = 0; j < len; j++) {
            StreamingAudioChannel._channels[j].stop();
        }
        StreamingAudioChannel._channels.length = 0;
    };
    Object.defineProperty(StreamingAudioChannel.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StreamingAudioChannel.prototype, "currentTime", {
        get: function () {
            return this._audio.currentTime - this._startTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StreamingAudioChannel.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            if (this._volume == value)
                return;
            this._volume = value;
            this._audio.volume = this._volume;
        },
        enumerable: true,
        configurable: true
    });
    StreamingAudioChannel.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    StreamingAudioChannel.prototype.isLooping = function () {
        return this._isLooping;
    };
    StreamingAudioChannel.prototype.isDecoding = function () {
        return false;
    };
    Object.defineProperty(StreamingAudioChannel.prototype, "pan", {
        get: function () {
            //todo
            return 0;
        },
        set: function (value) {
            //todo
        },
        enumerable: true,
        configurable: true
    });
    StreamingAudioChannel.prototype.play = function (buffer, offset, loop) {
        if (offset === void 0) { offset = 0; }
        if (loop === void 0) { loop = false; }
        this._isPlaying = true;
        if (this._isLooping || this._isLooping != loop) {
            this._isLooping = loop;
            this._sourceDirty = true;
        }
        if (this._sourceDirty)
            this._updateSource();
        this._buffer = buffer;
        this._offset = offset;
        this._audio.volume = this._volume;
        if (!this._isQueuing && !this._isOpening)
            this._queueBuffer();
    };
    StreamingAudioChannel.prototype.stop = function () {
        this._audio.pause();
        this._isPlaying = false;
        this._isLooping = false;
    };
    StreamingAudioChannel.prototype._sourceOpen = function (event) {
        this._isOpening = false;
        //TODO: find out how in the name of all that is holy how this can be executed more than once on a MediaSource object
        if (this._mediaSource.activeSourceBuffers.length) {
            console.log("ERR: double sourceopen event called");
            return;
        }
        this._sourceBuffer = this._mediaSource.addSourceBuffer('audio/mpeg');
        this._sourceBuffer.addEventListener("updateend", this._updateEndDelegate);
        if (this._isPlaying)
            this._queueBuffer();
    };
    StreamingAudioChannel.prototype._queueBuffer = function () {
        this._isQueuing = true;
        this._startTime = this._sourceBuffer.timestampOffset;
        this._sourceBuffer.appendBuffer(this._buffer);
    };
    StreamingAudioChannel.prototype._updateEnd = function (event) {
        this._isQueuing = false;
        if (this._isLooping)
            this._mediaSource.endOfStream();
        this._duration = this._sourceBuffer.timestampOffset - this._startTime;
        this._audio.currentTime = this._startTime + this._offset;
        this._audio.play();
    };
    StreamingAudioChannel.prototype._onTimeUpdate = function (event) {
        //TODO: more accurate end detection
        if (!this._isLooping && this._duration < this._audio.currentTime - this._startTime + 0.1)
            this.stop();
    };
    StreamingAudioChannel.prototype._updateSource = function () {
        if (this._mediaSource)
            this._disposeSource();
        this._isQueuing = false;
        this._isOpening = true;
        this._mediaSource = new MediaSource();
        this._mediaSource.addEventListener("sourceopen", this._sourceOpenDelegate);
        this._urlString = URL.createObjectURL(this._mediaSource);
        this._audio.src = this._urlString;
        this._audio.loop = this._isLooping;
        this._sourceDirty = false;
    };
    StreamingAudioChannel.prototype._disposeSource = function () {
        if (!this._isOpening) {
            if (this._sourceBuffer.timestampOffset)
                this._sourceBuffer.remove(0, this._sourceBuffer.timestampOffset);
            this._sourceBuffer.removeEventListener("updateend", this._updateEndDelegate);
            this._mediaSource.removeSourceBuffer(this._sourceBuffer);
            delete this._sourceBuffer;
            this._sourceBuffer = null;
        }
        this._mediaSource.removeEventListener("sourceopen", this._sourceOpenDelegate);
        URL.revokeObjectURL(this._urlString);
        delete this._mediaSource;
        this._mediaSource = null;
    };
    return StreamingAudioChannel;
}());
StreamingAudioChannel.maxChannels = 4;
StreamingAudioChannel._channels = new Array();

var WebAudioChannel = (function () {
    function WebAudioChannel() {
        var _this = this;
        this._isPlaying = false;
        this._isLooping = false;
        this._isDecoding = false;
        this._volume = 1;
        this._pan = 0;
        this._startTime = 0;
        this._audioCtx = WebAudioChannel.getAudioContext();
        this._usingNativePanner = typeof this._audioCtx.createStereoPanner === 'function';
        this._gainNode = this._audioCtx.createGain();
        this._gainNode.gain.value = this._volume;
        this._pannerNode = this._usingNativePanner ? this._audioCtx.createStereoPanner() : this._audioCtx.createPanner();
        if (this._usingNativePanner)
            this._pannerNode.pan.value = this._pan;
        else
            this._pannerNode.setPosition(Math.sin(this._pan * (Math.PI / 2)), 0, Math.cos(this._pan * (Math.PI / 2)));
        this._gainNode.connect(this._pannerNode);
        this._pannerNode.connect(this._audioCtx.destination);
        this._onEndedDelegate = function (event) { return _this._onEnded(event); };
    }
    WebAudioChannel.getAudioContext = function () {
        if (!WebAudioChannel._audioCtx && (window["AudioContext"] || window["webkitAudioContext"]))
            WebAudioChannel._audioCtx = new (window["AudioContext"] || window["webkitAudioContext"])();
        return WebAudioChannel._audioCtx;
    };
    WebAudioChannel.stopAllSounds = function () {
        var len = WebAudioChannel._channels.length;
        for (var j = 0; j < len; j++) {
            WebAudioChannel._channels[j].stop();
        }
        WebAudioChannel._channels.length = 0;
    };
    Object.defineProperty(WebAudioChannel.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebAudioChannel.prototype, "currentTime", {
        get: function () {
            return this._audioCtx.currentTime - this._startTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebAudioChannel.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            //if (this._volume == value)
            //	return;
            this._volume = value;
            this._gainNode.gain.value = this._volume;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WebAudioChannel.prototype, "pan", {
        get: function () {
            return this._pan;
        },
        set: function (value) {
            if (this._pan == value)
                return;
            this._pan = value;
            if (this._usingNativePanner)
                this._pannerNode.pan.value = this._pan;
            else
                this._pannerNode.setPosition(Math.sin(this._pan * (Math.PI / 2)), 0, Math.cos(this._pan * (Math.PI / 2)));
        },
        enumerable: true,
        configurable: true
    });
    WebAudioChannel.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    WebAudioChannel.prototype.isLooping = function () {
        return this._isLooping;
    };
    WebAudioChannel.prototype.isDecoding = function () {
        return this._isDecoding;
    };
    WebAudioChannel.prototype.play = function (buffer, offset, loop, id) {
        var _this = this;
        if (offset === void 0) { offset = 0; }
        if (loop === void 0) { loop = false; }
        if (id === void 0) { id = 0; }
        this._isPlaying = true;
        this._isLooping = loop;
        this._currentTime = offset;
        this._id = id;
        this._isDecoding = true;
        buffer = buffer.slice(0);
        //fast path for short sounds
        if (WebAudioChannel._decodeCache[id])
            this._onDecodeComplete(WebAudioChannel._decodeCache[id]);
        else if (!WebAudioChannel._errorCache[id])
            this._audioCtx.decodeAudioData(buffer, function (buffer) { return _this._onDecodeComplete(buffer); }, function (event) { return _this._onError(event); });
        else
            this.stop();
    };
    WebAudioChannel.prototype.stop = function () {
        if (!this._isPlaying)
            return;
        this._isPlaying = false;
        this._isLooping = false;
        this._isDecoding = false;
        if (this._source)
            this._disposeSource();
    };
    WebAudioChannel.prototype._onDecodeComplete = function (buffer) {
        if (!this._isPlaying)
            return;
        this._isDecoding = false;
        //if (buffer.duration < 2) //cache all buffers?
        WebAudioChannel._decodeCache[this._id] = buffer;
        if (this._source)
            this._disposeSource();
        this._source = this._audioCtx.createBufferSource();
        this._source.loop = this._isLooping;
        this._source.connect(this._gainNode);
        this._source.buffer = buffer;
        this._duration = buffer.duration;
        this._pan = 0;
        this._startTime = this._audioCtx.currentTime - this._currentTime;
        this._source.onended = this._onEndedDelegate;
        try {
            this._gainNode.gain.value = this._volume;
            if (this._usingNativePanner)
                this._pannerNode.pan.value = this._pan;
            else
                this._pannerNode.setPosition(Math.sin(this._pan * (Math.PI / 2)), 0, Math.cos(this._pan * (Math.PI / 2)));
            this._source.start(this._audioCtx.currentTime, this._currentTime);
        }
        catch (error) {
            console.log("Error starting audio: " + error);
            this._disposeSource();
        }
    };
    WebAudioChannel.prototype._onError = function (event) {
        console.log("Error with decoding audio data");
        WebAudioChannel._errorCache[this._id] = true;
        this.stop();
    };
    WebAudioChannel.prototype._onEnded = function (event) {
        if (this.onSoundComplete) {
            this.onSoundComplete();
        }
        this.stop();
    };
    WebAudioChannel.prototype._disposeSource = function () {
        //clean up
        this._source.stop(this._audioCtx.currentTime);
        this._source.onended = null;
        this._source.disconnect();
        // delete this._source.buffer;
        // delete this._source;
        this._source = null;
    };
    return WebAudioChannel;
}());
WebAudioChannel.maxChannels = 128;
WebAudioChannel._channels = new Array();
WebAudioChannel._decodeCache = new Object();
WebAudioChannel._errorCache = new Object();
var audioCtx = WebAudioChannel.getAudioContext();
// context state at this time is `undefined` in iOS8 Safari
if (audioCtx && audioCtx.state === 'suspended') {
    var resume = function () {
        audioCtx.resume();
        //create empty buffer
        var buffer = audioCtx.createBuffer(1, 1, 22050);
        var source = audioCtx.createBufferSource();
        source.buffer = buffer;
        source.connect(audioCtx.destination);
        source.start();
        setTimeout(function () {
            if (audioCtx.state === 'running') {
                document.removeEventListener('touchend', resume, false);
            }
        }, 0);
    };
    document.addEventListener('touchend', resume, false);
}

var ByteArrayBase = (function () {
    function ByteArrayBase() {
        this.position = 0;
        this.length = 0;
        this._mode = "";
    }
    ByteArrayBase.prototype.writeByte = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readByte = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeUnsignedByte = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readUnsignedByte = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeUnsignedShort = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readUnsignedShort = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeUnsignedInt = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readUnsignedInt = function () {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.writeFloat = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.toFloatBits = function (x) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.readFloat = function (b) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.fromFloatBits = function (x) {
        throw "Virtual method";
    };
    ByteArrayBase.prototype.getBytesAvailable = function () {
        throw new AbstractMethodError('ByteArrayBase, getBytesAvailable() not implemented ');
    };
    ByteArrayBase.prototype.toString = function () {
        return "[ByteArray] ( " + this._mode + " ) position=" + this.position + " length=" + this.length;
    };
    ByteArrayBase.prototype.compareEqual = function (other, count) {
        if (count == undefined || count > this.length - this.position)
            count = this.length - this.position;
        if (count > other.length - other.position)
            count = other.length - other.position;
        var co0 = count;
        var r = true;
        while (r && count >= 4) {
            count -= 4;
            if (this.readUnsignedInt() != other.readUnsignedInt())
                r = false;
        }
        while (r && count >= 1) {
            count--;
            if (this.readUnsignedByte() != other.readUnsignedByte())
                r = false;
        }
        var c0;
        this.position -= (c0 - count);
        other.position -= (c0 - count);
        return r;
    };
    ByteArrayBase.prototype.writeBase64String = function (s) {
        for (var i = 0; i < s.length; i++) {
            var v = s.charAt(i);
        }
    };
    ByteArrayBase.prototype.dumpToConsole = function () {
        var oldpos = this.position;
        this.position = 0;
        var nstep = 8;
        function asHexString(x, digits) {
            var lut = ["0", "1", "2", "3", "4", "5", "6", "7", "8", "9", "a", "b", "c", "d", "e", "f"];
            var sh = "";
            for (var d = 0; d < digits; d++) {
                sh = lut[(x >> (d << 2)) & 0xf] + sh;
            }
            return sh;
        }
        for (var i = 0; i < this.length; i += nstep) {
            var s = asHexString(i, 4) + ":";
            for (var j = 0; j < nstep && i + j < this.length; j++) {
                s += " " + asHexString(this.readUnsignedByte(), 2);
            }
            console.log(s);
        }
        this.position = oldpos;
    };
    ByteArrayBase.prototype.readBase64String = function (count) {
        if (count == undefined || count > this.length - this.position)
            count = this.length - this.position;
        if (!(count > 0))
            return "";
        return ByteArrayBase.internalGetBase64String(count, this.readUnsignedByte, this);
    };
    ByteArrayBase.internalGetBase64String = function (count, getUnsignedByteFunc, self) {
        var r = "";
        var b0, b1, b2, enc1, enc2, enc3, enc4;
        var base64Key = ByteArrayBase.Base64Key;
        while (count >= 3) {
            b0 = getUnsignedByteFunc.apply(self);
            b1 = getUnsignedByteFunc.apply(self);
            b2 = getUnsignedByteFunc.apply(self);
            enc1 = b0 >> 2;
            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
            enc3 = ((b1 & 15) << 2) | (b2 >> 6);
            enc4 = b2 & 63;
            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + base64Key.charAt(enc4);
            count -= 3;
        }
        // pad
        if (count == 2) {
            b0 = getUnsignedByteFunc.apply(self);
            b1 = getUnsignedByteFunc.apply(self);
            enc1 = b0 >> 2;
            enc2 = ((b0 & 3) << 4) | (b1 >> 4);
            enc3 = ((b1 & 15) << 2);
            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + base64Key.charAt(enc3) + "=";
        }
        else if (count == 1) {
            b0 = getUnsignedByteFunc.apply(self);
            enc1 = b0 >> 2;
            enc2 = ((b0 & 3) << 4);
            r += base64Key.charAt(enc1) + base64Key.charAt(enc2) + "==";
        }
        return r;
    };
    return ByteArrayBase;
}());
ByteArrayBase.Base64Key = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";

var ByteArray = (function (_super) {
    __extends(ByteArray, _super);
    function ByteArray(maxlength) {
        if (maxlength === void 0) { maxlength = 4; }
        var _this = _super.call(this) || this;
        _this._mode = "Typed array";
        _this.maxlength = Math.max((maxlength + 255) & (~255), 4);
        _this.arraybytes = new ArrayBuffer(_this.maxlength);
        _this.unalignedarraybytestemp = new ArrayBuffer(16);
        return _this;
    }
    ByteArray.prototype.ensureWriteableSpace = function (n) {
        this.ensureSpace(n + this.position);
    };
    ByteArray.prototype.setArrayBuffer = function (aBuffer) {
        this.ensureSpace(aBuffer.byteLength);
        this.length = aBuffer.byteLength;
        var inInt8AView = new Int8Array(aBuffer);
        var localInt8View = new Int8Array(this.arraybytes, 0, this.length);
        localInt8View.set(inInt8AView);
        this.position = 0;
    };
    ByteArray.prototype.writeArrayBuffer = function (aBuffer) {
        this.ensureWriteableSpace(aBuffer.byteLength);
        var inInt8AView = new Int8Array(aBuffer);
        var localInt8View = new Int8Array(this.arraybytes, this.length, aBuffer.byteLength);
        localInt8View.set(inInt8AView);
        this.length += aBuffer.byteLength;
        this.position = this.length;
    };
    ByteArray.prototype.writeByteArray = function (ba) {
        this.ensureWriteableSpace(ba.length);
        var inInt8AView = new Int8Array(ba.arraybytes, 0, ba.length);
        var localInt8View = new Int8Array(this.arraybytes, this.length, ba.length);
        localInt8View.set(inInt8AView);
        this.length += ba.length;
        this.position = this.length;
    };
    ByteArray.prototype.getBytesAvailable = function () {
        return (this.length) - (this.position);
    };
    ByteArray.prototype.ensureSpace = function (n) {
        if (n > this.maxlength) {
            var newmaxlength = (n + 255) & (~255);
            var newarraybuffer = new ArrayBuffer(newmaxlength);
            var view = new Uint8Array(this.arraybytes, 0, this.length);
            var newview = new Uint8Array(newarraybuffer, 0, this.length);
            newview.set(view); // memcpy
            this.arraybytes = newarraybuffer;
            this.maxlength = newmaxlength;
        }
    };
    ByteArray.prototype.writeObject = function (object) {
        console.log("writeObject not implemented yet in core/ByteArray");
    };
    ByteArray.prototype.readObject = function () {
        console.log("readObject not implemented yet in core/ByteArray");
        return {};
    };
    ByteArray.prototype.writeByte = function (b) {
        this.ensureWriteableSpace(1);
        var view = new Int8Array(this.arraybytes);
        view[this.position++] = (~~b); // ~~ is cast to int in js...
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArray.prototype.readByte = function () {
        if (this.position >= this.length)
            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
        var view = new Int8Array(this.arraybytes);
        return view[this.position++];
    };
    ByteArray.prototype.readBytes = function (bytes, offset, length) {
        if (offset === void 0) { offset = 0; }
        if (length === void 0) { length = 0; }
        if (length == null)
            length = bytes.length;
        bytes.ensureWriteableSpace(offset + length);
        var byteView = new Int8Array(bytes.arraybytes);
        var localByteView = new Int8Array(this.arraybytes);
        byteView.set(localByteView.subarray(this.position, this.position + length), offset);
        this.position += length;
        if (length + offset > bytes.length)
            bytes.length += (length + offset) - bytes.length;
    };
    ByteArray.prototype.writeUnsignedByte = function (b) {
        this.ensureWriteableSpace(1);
        var view = new Uint8Array(this.arraybytes);
        view[this.position++] = (~~b) & 0xff; // ~~ is cast to int in js...
        if (this.position > this.length)
            this.length = this.position;
    };
    ByteArray.prototype.readUnsignedByte = function () {
        if (this.position >= this.length)
            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
        var view = new Uint8Array(this.arraybytes);
        return view[this.position++];
    };
    ByteArray.prototype.writeUnsignedShort = function (b) {
        this.ensureWriteableSpace(2);
        if ((this.position & 1) == 0) {
            var view = new Uint16Array(this.arraybytes);
            view[this.position >> 1] = (~~b) & 0xffff; // ~~ is cast to int in js...
        }
        else {
            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
            view[0] = (~~b) & 0xffff;
            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
            view2.set(view3);
        }
        this.position += 2;
        if (this.position > this.length)
            this.length = this.position;
    };
    ByteArray.prototype.readUTFBytes = function (len) {
        var value = "";
        var max = this.position + len;
        var data = new DataView(this.arraybytes);
        // utf8-encode
        while (this.position < max) {
            var c = data.getUint8(this.position++);
            if (c < 0x80) {
                if (c == 0)
                    break;
                value += String.fromCharCode(c);
            }
            else if (c < 0xE0) {
                value += String.fromCharCode(((c & 0x3F) << 6) | (data.getUint8(this.position++) & 0x7F));
            }
            else if (c < 0xF0) {
                var c2 = data.getUint8(this.position++);
                value += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (data.getUint8(this.position++) & 0x7F));
            }
            else {
                var c2 = data.getUint8(this.position++);
                var c3 = data.getUint8(this.position++);
                value += String.fromCharCode(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (data.getUint8(this.position++) & 0x7F));
            }
        }
        return value;
    };
    ByteArray.prototype.writeUTFBytes = function (s) {
        var escstr = encodeURIComponent(s);
        var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {
            return String.fromCharCode(parseInt('0x' + p1));
        });
        this.ensureWriteableSpace(4 + binstr.length);
        this.writeInt(binstr.length);
        for (var i = 0; i < binstr.length; i++) {
            this.writeUnsignedByte(binstr.charCodeAt(i)); //todo: there are probably faster ways to do this
        }
        if (binstr.length % 4) {
            var paddingbytes = binstr.length % 4;
            for (var i = 0; i < paddingbytes; i++) {
                this.writeUnsignedByte(0);
            }
        }
        return binstr.length;
    };
    ByteArray.prototype.readInt = function () {
        var data = new DataView(this.arraybytes);
        var int = data.getInt32(this.position, true);
        this.position += 4;
        return int;
    };
    ByteArray.prototype.readShort = function () {
        var data = new DataView(this.arraybytes);
        var short = data.getInt16(this.position, true);
        this.position += 2;
        return short;
    };
    ByteArray.prototype.readDouble = function () {
        var data = new DataView(this.arraybytes);
        var double = data.getFloat64(this.position, true);
        this.position += 8;
        return double;
    };
    ByteArray.prototype.readUnsignedShort = function () {
        if (this.position > this.length + 2)
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        if ((this.position & 1) == 0) {
            var view = new Uint16Array(this.arraybytes);
            var pa = this.position >> 1;
            this.position += 2;
            return view[pa];
        }
        else {
            var view = new Uint16Array(this.unalignedarraybytestemp, 0, 1);
            var view2 = new Uint8Array(this.arraybytes, this.position, 2);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 2);
            view3.set(view2);
            this.position += 2;
            return view[0];
        }
    };
    ByteArray.prototype.writeUnsignedInt = function (b) {
        this.ensureWriteableSpace(4);
        if ((this.position & 3) == 0) {
            var view = new Uint32Array(this.arraybytes);
            view[this.position >> 2] = (~~b) & 0xffffffff; // ~~ is cast to int in js...
        }
        else {
            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
            view[0] = (~~b) & 0xffffffff;
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view2.set(view3);
        }
        this.position += 4;
        if (this.position > this.length)
            this.length = this.position;
    };
    ByteArray.prototype.writeInt = function (b) {
        this.ensureWriteableSpace(4);
        if ((this.position & 3) == 0) {
            var view = new Int32Array(this.arraybytes);
            view[this.position >> 2] = (~~b); // ~~ is cast to int in js...
        }
        else {
            var view = new Int32Array(this.unalignedarraybytestemp, 0, 1);
            view[0] = (~~b);
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view2.set(view3);
        }
        this.position += 4;
        if (this.position > this.length)
            this.length = this.position;
    };
    ByteArray.prototype.readUnsignedInt = function () {
        if (this.position > this.length + 4)
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        if ((this.position & 3) == 0) {
            var view = new Uint32Array(this.arraybytes);
            var pa = this.position >> 2;
            this.position += 4;
            return view[pa];
        }
        else {
            var view = new Uint32Array(this.unalignedarraybytestemp, 0, 1);
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view3.set(view2);
            this.position += 4;
            return view[0];
        }
    };
    ByteArray.prototype.writeFloat = function (b) {
        this.ensureWriteableSpace(4);
        if ((this.position & 3) == 0) {
            var view = new Float32Array(this.arraybytes);
            view[this.position >> 2] = b;
        }
        else {
            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
            view[0] = b;
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view2.set(view3);
        }
        this.position += 4;
        if (this.position > this.length)
            this.length = this.position;
    };
    ByteArray.prototype.readFloat = function () {
        if (this.position > this.length + 4)
            throw "ByteArray out of bounds read. Positon=" + this.position + ", Length=" + this.length;
        if ((this.position & 3) == 0) {
            var view = new Float32Array(this.arraybytes);
            var pa = this.position >> 2;
            this.position += 4;
            return view[pa];
        }
        else {
            var view = new Float32Array(this.unalignedarraybytestemp, 0, 1);
            var view2 = new Uint8Array(this.arraybytes, this.position, 4);
            var view3 = new Uint8Array(this.unalignedarraybytestemp, 0, 4);
            view3.set(view2);
            this.position += 4;
            return view[0];
        }
    };
    return ByteArray;
}(ByteArrayBase));

var ParserUtils = (function () {
    function ParserUtils() {
    }
    ParserUtils.arrayBufferToBase64 = function (data, mimeType) {
        var byteStr = '';
        var bytes = new Uint8Array(data);
        var len = bytes.byteLength;
        for (var i = 0; i < len; i++)
            byteStr += String.fromCharCode(bytes[i]);
        var base64Image = window.btoa(byteStr);
        return 'data:' + mimeType + ';base64,' + base64Image;
    };
    ParserUtils.arrayBufferToAudio = function (data, fileType) {
        var str = ParserUtils.arrayBufferToBase64(data, 'audio/' + fileType);
        var audio = new Audio();
        audio.src = str;
        return audio;
    };
    /**
     * Converts an ArrayBuffer to a base64 string
     *
     * @param image data as a ByteArray
     *
     * @return HTMLImageElement
     *
     */
    ParserUtils.arrayBufferToImage = function (data) {
        var str = ParserUtils.arrayBufferToBase64(data, 'image/png');
        var img = new Image();
        img.src = str;
        return img;
    };
    /**
     * Converts an ByteArray to an Image - returns an HTMLImageElement
     *
     * @param image data as a ByteArray
     *
     * @return HTMLImageElement
     *
     */
    ParserUtils.byteArrayToImage = function (data) {
        var str = ParserUtils.arrayBufferToBase64(data.arraybytes, 'image/png');
        var img = new Image();
        img.src = str;
        return img;
    };
    ParserUtils.byteArrayToAudio = function (data, filetype) {
        var str = ParserUtils.arrayBufferToBase64(data.arraybytes, 'audio/' + filetype);
        var audio = new Audio();
        audio.src = str;
        return audio;
    };
    /**
     * Converts an Blob to an Image - returns an HTMLImageElement
     *
     * @param image data as a Blob
     *
     * @return HTMLImageElement
     *
     */
    ParserUtils.blobToImage = function (data) {
        var URLObj = window['URL'] || window['webkitURL'];
        var src = URLObj.createObjectURL(data);
        var img = new Image();
        img.src = src;
        return img;
    };
    /**
     * Converts an Blob to audio - returns an HTMLAudioElement
     *
     * @param audio data as a Blob
     *
     * @return HTMLAudioElement
     *
     */
    ParserUtils.blobToAudio = function (data) {
        var URLObj = window['URL'] || window['webkitURL'];
        var src = URLObj.createObjectURL(data);
        var img = new Audio();
        img.src = src;
        return img;
    };
    /**
     * Returns a object as ByteArray, if possible.
     *
     * @param data The object to return as ByteArray
     *
     * @return The ByteArray or null
     *
     */
    ParserUtils.toByteArray = function (data) {
        var b = new ByteArray();
        b.setArrayBuffer(data);
        return b;
    };
    /**
     * Returns a object as String, if possible.
     *
     * @param data The object to return as String
     * @param length The length of the returned String
     *
     * @return The String or null
     *
     */
    ParserUtils.toString = function (data, length) {
        if (length === void 0) { length = 0; }
        if (typeof data === 'string') {
            var s = data;
            if (s['substr'] != null)
                return s.substr(0, s.length);
        }
        if (data instanceof ByteArray) {
            var ba = data;
            ba.position = 0;
            return ba.readUTFBytes(Math.min(ba.getBytesAvailable(), length));
        }
        return null;
        /*
         var ba:ByteArray;

         length ||= uint.MAX_VALUE;

         if (data is String)
         return String(data).substr(0, length);

         ba = toByteArray(data);
         if (ba) {
         ba.position = 0;
         return ba.readUTFBytes(Math.min(ba.bytesAvailable, length));
         }

         return null;

         */
    };
    return ParserUtils;
}());

var EventAudioChannel = (function () {
    function EventAudioChannel() {
        var _this = this;
        this._isPlaying = false;
        this._isLooping = false;
        this._startTime = 0;
        this._audio = new Audio();
        this._audio.ontimeupdate = function (event) { return _this._onTimeUpdate(event); };
    }
    EventAudioChannel.stopAllSounds = function () {
        var channel;
        var len = EventAudioChannel._channels.length;
        for (var j = 0; j < len; j++) {
            channel = EventAudioChannel._channels[j];
            channel.stop();
        }
        EventAudioChannel._channels.length = 0;
    };
    Object.defineProperty(EventAudioChannel.prototype, "duration", {
        get: function () {
            return this._duration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventAudioChannel.prototype, "currentTime", {
        get: function () {
            return this._audio.currentTime - this._startTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventAudioChannel.prototype, "pan", {
        get: function () {
            //todo
            return 0;
        },
        set: function (value) {
            //todo
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EventAudioChannel.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            if (this._volume == value)
                return;
            this._volume = value;
            this._audio.volume = this._volume;
        },
        enumerable: true,
        configurable: true
    });
    EventAudioChannel.prototype.isPlaying = function () {
        return this._isPlaying;
    };
    EventAudioChannel.prototype.isLooping = function () {
        return this._isLooping;
    };
    EventAudioChannel.prototype.isDecoding = function () {
        return false;
    };
    EventAudioChannel.prototype.play = function (buffer, offset, loop, id) {
        if (offset === void 0) { offset = 0; }
        if (loop === void 0) { loop = false; }
        if (id === void 0) { id = 0; }
        this._isPlaying = true;
        this._isLooping = loop;
        this._audio.src = EventAudioChannel._base64Cache[id] || (EventAudioChannel._base64Cache[id] = ParserUtils.arrayBufferToBase64(buffer, "audio/mp3"));
        this._audio.loop = this._isLooping;
        var thisAudio = this._audio;
        this._audio.addEventListener('loadedmetadata', function () {
            thisAudio.currentTime = offset;
            thisAudio.play();
        }, false);
    };
    EventAudioChannel.prototype.stop = function () {
        this._audio.pause();
        this._isPlaying = false;
        this._isLooping = false;
    };
    EventAudioChannel.prototype._onTimeUpdate = function (event) {
        //TODO: more accurate end detection
        if (!this._isLooping && this._duration < this._audio.currentTime - this._startTime + 0.1)
            this.stop();
    };
    return EventAudioChannel;
}());
EventAudioChannel.maxChannels = 4;
EventAudioChannel._channels = new Array();
EventAudioChannel._base64Cache = new Object();

var AudioManager = (function () {
    function AudioManager() {
    }
    AudioManager.setExternalSoundInterface = function (new_obj) {
        if (new_obj.startSound == null) {
            console.log("Could not set the externalSoundInterface, because it does not provide a 'startSound' function");
            return;
        }
        if (new_obj.stopSound == null) {
            console.log("Could not set the externalSoundInterface, because it does not provide a 'stopSound' function");
            return;
        }
        AudioManager._externalSoundInterface = new_obj;
    };
    AudioManager.getExternalSoundInterface = function () {
        return AudioManager._externalSoundInterface;
    };
    AudioManager.stopAllSounds = function () {
        WebAudioChannel.stopAllSounds();
        StreamingAudioChannel.stopAllSounds();
        //EventAudioChannel.stopAllSounds();
        //AudioChannel.stopAllSounds();
    };
    AudioManager.getChannel = function (byteLength) {
        //choose best audio channel by bytelength
        //todo: StreamingAudioChannel doesnt seem to be working. no error, but also no sound is playing
        var channelClass = (byteLength > 50000000) ? StreamingAudioChannel : WebAudioChannel;
        if (AudioManager.isIE) {
            channelClass = EventAudioChannel;
        }
        //var channelClass:IAudioChannelClass = WebAudioChannel;
        var i = 0;
        while (channelClass._channels[i] && channelClass._channels[i].isPlaying())
            i++;
        if (i == channelClass.maxChannels) {
            //pick the oldest channel to reuse, ignoring looping channels
            var channel;
            var len = channelClass._channels.length;
            for (var j = 0; j < len; j++) {
                channel = channelClass._channels[j];
                if (!channel.isLooping() && !channel.isDecoding()) {
                    channelClass._channels.push(channelClass._channels.splice(j, 1)[0]);
                    channel.stop();
                    return channel;
                }
            }
            //do not return channel until one is freed up
            return null;
        }
        return (channelClass._channels[i] = new channelClass());
    };
    return AudioManager;
}());
AudioManager.isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g);
//todo: make AudioPlaybackManager keep track of active sounds + implement global playback control
AudioManager._externalSoundInterface = null;

// TODO: Audio should probably be an interface containing play/stop/seek functionality
var WaveAudio = (function (_super) {
    __extends(WaveAudio, _super);
    /**
     *
     */
    function WaveAudio(buffer) {
        var _this = _super.call(this) || this;
        _this._volume = 1;
        _this._pan = 0;
        _this._audioChannels = [];
        _this._buffer = buffer;
        return _this;
    }
    Object.defineProperty(WaveAudio.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return WaveAudio.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaveAudio.prototype, "pan", {
        get: function () {
            return this._pan;
        },
        set: function (value) {
            if (this._pan == value)
                return;
            this._pan = value;
            if (this._audioChannel)
                this._audioChannel.pan = this._pan;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaveAudio.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            /*if (this._volume == value)
                return;*/
            this._volume = value;
            if (this._audioChannel)
                this._audioChannel.volume = this._volume;
            for (var i = 0; i < this._audioChannels.length; i++) {
                this._audioChannels[i].volume = this._volume;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaveAudio.prototype, "currentTime", {
        get: function () {
            if (this._audioChannel)
                return this._audioChannel.currentTime;
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(WaveAudio.prototype, "duration", {
        get: function () {
            if (this._audioChannel)
                return this._audioChannel.duration;
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    WaveAudio.prototype.dispose = function () {
        this.stop();
    };
    WaveAudio.prototype.play = function (offset, loop) {
        if (loop === void 0) { loop = false; }
        this._audioChannel = AudioManager.getChannel(this._buffer.byteLength);
        if (this._audioChannel) {
            this._audioChannels.push(this._audioChannel);
            this._audioChannel.volume = this._volume;
            this._audioChannel.play(this._buffer, offset, loop, this.id);
            if (this._onSoundComplete) {
                this._audioChannel.onSoundComplete = this._onSoundComplete;
            }
        }
    };
    Object.defineProperty(WaveAudio.prototype, "onSoundComplete", {
        set: function (value) {
            this._onSoundComplete = value;
            if (this._audioChannel) {
                this._audioChannel.onSoundComplete = this._onSoundComplete;
            }
        },
        enumerable: true,
        configurable: true
    });
    WaveAudio.prototype.stop = function () {
        for (var i = 0; i < this._audioChannels.length; i++) {
            this._audioChannels[i].stop();
            delete this._audioChannels[i];
        }
        this._audioChannels.length = 0;
        this._audioChannel = null;
    };
    WaveAudio.prototype.clone = function () {
        var newInstance = new WaveAudio(this._buffer);
        newInstance.name = this.name;
        return newInstance;
    };
    return WaveAudio;
}(AssetBase));
WaveAudio.assetType = "[asset WaveAudio]";

/**
 *
 */
var ColorUtils = (function () {
    function ColorUtils() {
    }
    ColorUtils.float32ColorToARGB = function (float32Color) {
        var a = (float32Color & 0xff000000) >>> 24;
        var r = (float32Color & 0xff0000) >>> 16;
        var g = (float32Color & 0xff00) >>> 8;
        var b = float32Color & 0xff;
        var result = [a, r, g, b];
        return result;
    };
    ColorUtils.ARGBtoFloat32 = function (a, r, g, b) {
        return ((a << 24) | (r << 16) | (g << 8) | b);
    };
    ColorUtils.componentToHex = function (c) {
        var hex = c.toString(16);
        return hex.length == 1 ? "0" + hex : hex;
    };
    ColorUtils.RGBToHexString = function (argb) {
        return "#" + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
    };
    ColorUtils.ARGBToHexString = function (argb) {
        return "#" + ColorUtils.componentToHex(argb[0]) + ColorUtils.componentToHex(argb[1]) + ColorUtils.componentToHex(argb[2]) + ColorUtils.componentToHex(argb[3]);
    };
    return ColorUtils;
}());

/**
 * The ColorTransform export class lets you adjust the color values in a display
 * object. The color adjustment or <i>color transformation</i> can be applied
 * to all four channels: red, green, blue, and alpha transparency.
 *
 * <p>When a ColorTransform object is applied to a display object, a new value
 * for each color channel is calculated like this:</p>
 *
 * <ul>
 *   <li>New red value = (old red value * <code>redMultiplier</code>) +
 * <code>redOffset</code></li>
 *   <li>New green value = (old green value * <code>greenMultiplier</code>) +
 * <code>greenOffset</code></li>
 *   <li>New blue value = (old blue value * <code>blueMultiplier</code>) +
 * <code>blueOffset</code></li>
 *   <li>New alpha value = (old alpha value * <code>alphaMultiplier</code>) +
 * <code>alphaOffset</code></li>
 * </ul>
 *
 * <p>If any of the color channel values is greater than 255 after the
 * calculation, it is set to 255. If it is less than 0, it is set to 0.</p>
 *
 * <p>You can use ColorTransform objects in the following ways:</p>
 *
 * <ul>
 *   <li>In the <code>colorTransform</code> parameter of the
 * <code>colorTransform()</code> method of the BitmapData class</li>
 *   <li>As the <code>colorTransform</code> property of a Transform object
 * (which can be used as the <code>transform</code> property of a display
 * object)</li>
 * </ul>
 *
 * <p>You must use the <code>new ColorTransform()</code> constructor to create
 * a ColorTransform object before you can call the methods of the
 * ColorTransform object.</p>
 *
 * <p>Color transformations do not apply to the background color of a movie
 * clip(such as a loaded SWF object). They apply only to graphics and symbols
 * that are attached to the movie clip.</p>
 */
var ColorTransform = (function () {
    function ColorTransform(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset) {
        if (redMultiplier === void 0) { redMultiplier = 1; }
        if (greenMultiplier === void 0) { greenMultiplier = 1; }
        if (blueMultiplier === void 0) { blueMultiplier = 1; }
        if (alphaMultiplier === void 0) { alphaMultiplier = 1; }
        if (redOffset === void 0) { redOffset = 0; }
        if (greenOffset === void 0) { greenOffset = 0; }
        if (blueOffset === void 0) { blueOffset = 0; }
        if (alphaOffset === void 0) { alphaOffset = 0; }
        if (redMultiplier instanceof Float32Array) {
            this._rawData = redMultiplier;
        }
        else {
            this._rawData = new Float32Array(8);
            this.redMultiplier = Number(redMultiplier);
            this.greenMultiplier = greenMultiplier;
            this.blueMultiplier = blueMultiplier;
            this.alphaMultiplier = alphaMultiplier;
            this.redOffset = redOffset;
            this.greenOffset = greenOffset;
            this.blueOffset = blueOffset;
            this.alphaOffset = alphaOffset;
        }
    }
    Object.defineProperty(ColorTransform.prototype, "alphaMultiplier", {
        /**
         * A decimal value that is multiplied with the alpha transparency channel
         * value.
         *
         * <p>If you set the alpha transparency value of a display object directly by
         * using the <code>alpha</code> property of the DisplayObject instance, it
         * affects the value of the <code>alphaMultiplier</code> property of that
         * display object's <code>transform.colorTransform</code> property.</p>
         */
        get: function () {
            return this._rawData[3];
        },
        set: function (value) {
            this._rawData[3] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "alphaOffset", {
        /**
         * A number from -255 to 255 that is added to the alpha transparency channel
         * value after it has been multiplied by the <code>alphaMultiplier</code>
         * value.
         */
        get: function () {
            return this._rawData[7];
        },
        set: function (value) {
            this._rawData[7] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "blueMultiplier", {
        /**
         * A decimal value that is multiplied with the blue channel value.
         */
        get: function () {
            return this._rawData[2];
        },
        set: function (value) {
            this._rawData[2] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "blueOffset", {
        /**
         * A number from -255 to 255 that is added to the blue channel value after it
         * has been multiplied by the <code>blueMultiplier</code> value.
         */
        get: function () {
            return this._rawData[6];
        },
        set: function (value) {
            this._rawData[6] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "greenMultiplier", {
        /**
         * A decimal value that is multiplied with the green channel value.
         */
        get: function () {
            return this._rawData[1];
        },
        set: function (value) {
            this._rawData[1] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "greenOffset", {
        /**
         * A number from -255 to 255 that is added to the green channel value after
         * it has been multiplied by the <code>greenMultiplier</code> value.
         */
        get: function () {
            return this._rawData[5];
        },
        set: function (value) {
            this._rawData[5] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "redMultiplier", {
        /**
         * A decimal value that is multiplied with the red channel value.
         */
        get: function () {
            return this._rawData[0];
        },
        set: function (value) {
            this._rawData[0] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "redOffset", {
        /**
         * A number from -255 to 255 that is added to the red channel value after it
         * has been multiplied by the <code>redMultiplier</code> value.
         */
        get: function () {
            return this._rawData[4];
        },
        set: function (value) {
            this._rawData[4] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorTransform.prototype, "color", {
        /**
         * The RGB color value for a ColorTransform object.
         *
         * <p>When you set this property, it changes the three color offset values
         * (<code>redOffset</code>, <code>greenOffset</code>, and
         * <code>blueOffset</code>) accordingly, and it sets the three color
         * multiplier values(<code>redMultiplier</code>,
         * <code>greenMultiplier</code>, and <code>blueMultiplier</code>) to 0. The
         * alpha transparency multiplier and offset values do not change.</p>
         *
         * <p>When you pass a value for this property, use the format
         * 0x<i>RRGGBB</i>. <i>RR</i>, <i>GG</i>, and <i>BB</i> each consist of two
         * hexadecimal digits that specify the offset of each color component. The 0x
         * tells the ActionScript compiler that the number is a hexadecimal
         * value.</p>
         */
        get: function () {
            return ((this._rawData[4] << 16) | (this._rawData[5] << 8) | this._rawData[6]);
        },
        set: function (value) {
            var argb = ColorUtils.float32ColorToARGB(value);
            this._rawData[4] = argb[1]; //(value >> 16) & 0xFF;
            this._rawData[5] = argb[2]; //(value >> 8) & 0xFF;
            this._rawData[6] = argb[3]; //value & 0xFF;
            this._rawData[0] = 0;
            this._rawData[1] = 0;
            this._rawData[2] = 0;
        },
        enumerable: true,
        configurable: true
    });
    ColorTransform.prototype.copyRawDataFrom = function (sourceData) {
        var targetData = this._rawData;
        targetData[0] = sourceData[0];
        targetData[1] = sourceData[1];
        targetData[2] = sourceData[2];
        targetData[3] = sourceData[3];
        targetData[4] = sourceData[4];
        targetData[5] = sourceData[5];
        targetData[6] = sourceData[6];
        targetData[7] = sourceData[7];
    };
    ColorTransform.prototype.clear = function () {
        this._rawData[0] = 1;
        this._rawData[1] = 1;
        this._rawData[2] = 1;
        this._rawData[3] = 1;
        this._rawData[4] = 0;
        this._rawData[5] = 0;
        this._rawData[6] = 0;
        this._rawData[7] = 0;
    };
    ColorTransform.prototype.clone = function () {
        var colorTransform = new ColorTransform();
        colorTransform.copyFrom(this);
        return colorTransform;
    };
    ColorTransform.prototype.copyFrom = function (source) {
        var sourceData = source._rawData, targetData = this._rawData;
        targetData[0] = sourceData[0];
        targetData[1] = sourceData[1];
        targetData[2] = sourceData[2];
        targetData[3] = sourceData[3];
        targetData[4] = sourceData[4];
        targetData[5] = sourceData[5];
        targetData[6] = sourceData[6];
        targetData[7] = sourceData[7];
    };
    ColorTransform.prototype.copyTo = function (target) {
        target.copyFrom(this);
    };
    ColorTransform.prototype.prepend = function (ct) {
        this._rawData[4] += ct._rawData[4] * this._rawData[0];
        this._rawData[5] += ct._rawData[5] * this._rawData[1];
        this._rawData[6] += ct._rawData[6] * this._rawData[2];
        this._rawData[7] += ct._rawData[7] * this._rawData[3];
        this.redMultiplier *= ct.redMultiplier;
        this.greenMultiplier *= ct.greenMultiplier;
        this.blueMultiplier *= ct.blueMultiplier;
        this.alphaMultiplier *= ct.alphaMultiplier;
    };
    ColorTransform.prototype._isRenderable = function () {
        return this._rawData[3] != 0 || this._rawData[7] > 0;
    };
    return ColorTransform;
}());

/**
 * The Vector3D export class represents a point or a location in the three-dimensional
 * space using the Cartesian coordinates x, y, and z. As in a two-dimensional
 * space, the x property represents the horizontal axis and the y property
 * represents the vertical axis. In three-dimensional space, the z property
 * represents depth. The value of the x property increases as the object moves
 * to the right. The value of the y property increases as the object moves
 * down. The z property increases as the object moves farther from the point
 * of view. Using perspective projection and scaling, the object is seen to be
 * bigger when near and smaller when farther away from the screen. As in a
 * right-handed three-dimensional coordinate system, the positive z-axis points
 * away from the viewer and the value of the z property increases as the object
 * moves away from the viewer's eye. The origin point (0,0,0) of the global
 * space is the upper-left corner of the stage.
 *
 * <p>The Vector3D export class can also represent a direction, an arrow pointing from
 * the origin of the coordinates, such as (0,0,0), to an endpoint; or a
 * floating-point component of an RGB (Red, Green, Blue) color model.</p>
 *
 * <p>Quaternion notation introduces a fourth element, the w property, which
 * provides additional orientation information. For example, the w property can
 * define an angle of rotation of a Vector3D object. The combination of the
 * angle of rotation and the coordinates x, y, and z can determine the display
 * object's orientation. Here is a representation of Vector3D elements in
 * matrix notation:</p>
 */
var Vector3D = (function () {
    /**
     * Creates an instance of a Vector3D object. If you do not specify a
     * parameter for the constructor, a Vector3D object is created with
     * the elements (0,0,0,0).
     *
     * @param x The first element, such as the x coordinate.
     * @param y The second element, such as the y coordinate.
     * @param z The third element, such as the z coordinate.
     * @param w An optional element for additional data such as the angle
     *          of rotation.
     */
    function Vector3D(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 1; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    Object.defineProperty(Vector3D.prototype, "length", {
        /**
         * The length, magnitude, of the current Vector3D object from the
         * origin (0,0,0) to the object's x, y, and z coordinates. The w
         * property is ignored. A unit vector has a length or magnitude of
         * one.
         */
        get: function () {
            return Math.sqrt(this.lengthSquared);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vector3D.prototype, "lengthSquared", {
        /**
         * The square of the length of the current Vector3D object, calculated
         * using the x, y, and z properties. The w property is ignored. Use the
         * <code>lengthSquared()</code> method whenever possible instead of the
         * slower <code>Math.sqrt()</code> method call of the
         * <code>Vector3D.length()</code> method.
         */
        get: function () {
            return this.x * this.x + this.y * this.y + this.z * this.z;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the value of the x, y, and z elements of the current Vector3D
     * object to the values of the x, y, and z elements of another Vector3D
     * object. The <code>add()</code> method does not change the current
     * Vector3D object. Instead, it returns a new Vector3D object with
     * the new values.
     *
     * <p>The result of adding two vectors together is a resultant vector.
     * One way to visualize the result is by drawing a vector from the
     * origin or tail of the first vector to the end or head of the second
     * vector. The resultant vector is the distance between the origin
     * point of the first vector and the end point of the second vector.
     * </p>
     */
    Vector3D.prototype.add = function (a) {
        return new Vector3D(this.x + a.x, this.y + a.y, this.z + a.z);
    };
    /**
     * Returns the angle in radians between two vectors. The returned angle
     * is the smallest radian the first Vector3D object rotates until it
     * aligns with the second Vector3D object.
     *
     * <p>The <code>angleBetween()</code> method is a static method. You
     * can use it directly as a method of the Vector3D class.</p>
     *
     * <p>To convert a degree to a radian, you can use the following
     * formula:</p>
     *
     * <p><code>radian = Math.PI/180 * degree</code></p>
     *
     * @param a The first Vector3D object.
     * @param b The second Vector3D object.
     * @returns The angle between two Vector3D objects.
     */
    Vector3D.angleBetween = function (a, b) {
        return Math.acos(a.dotProduct(b) / (a.length * b.length));
    };
    /**
     * Returns a new Vector3D object that is an exact copy of the current
     * Vector3D object.
     *
     * @returns A new Vector3D object that is a copy of the current
     * Vector3D object.
     */
    Vector3D.prototype.clone = function () {
        return new Vector3D(this.x, this.y, this.z, this.w);
    };
    Vector3D.combine = function (a, b, ascl, bscl) {
        return new Vector3D(a.x * ascl + b.x * bscl, a.y * ascl + b.y * bscl, a.z * ascl + b.z * bscl);
    };
    /**
     * Copies all of vector data from the source Vector3D object into the
     * calling Vector3D object.
     *
     * @param src The Vector3D object from which to copy the data.
     */
    Vector3D.prototype.copyFrom = function (src) {
        this.x = src.x;
        this.y = src.y;
        this.z = src.z;
        this.w = src.w;
    };
    /**
     * Returns a new Vector3D object that is perpendicular (at a right
     * angle) to the current Vector3D and another Vector3D object. If the
     * returned Vector3D object's coordinates are (0,0,0), then the two
     * Vector3D objects are parallel to each other.
     *
     * <p>You can use the normalized cross product of two vertices of a
     * polygon surface with the normalized vector of the camera or eye
     * viewpoint to get a dot product. The value of the dot product can
     * identify whether a surface of a three-dimensional object is hidden
     * from the viewpoint.</p>
     *
     * @param a A second Vector3D object.
     * @returns A new Vector3D object that is perpendicular to the current
     *          Vector3D object and the Vector3D object specified as the
     *          parameter.
     */
    Vector3D.prototype.crossProduct = function (a, t) {
        if (t === void 0) { t = null; }
        if (t == null)
            t = new Vector3D();
        t.x = this.y * a.z - this.z * a.y;
        t.y = this.z * a.x - this.x * a.z;
        t.z = this.x * a.y - this.y * a.x;
        return t;
    };
    /**
     * Decrements the value of the x, y, and z elements of the current
     * Vector3D object by the values of the x, y, and z elements of
     * specified Vector3D object. Unlike the
     * <code>Vector3D.subtract()</code> method, the
     * <code>decrementBy()</code> method changes the current Vector3D
     * object and does not return a new Vector3D object.
     *
     * @param a The Vector3D object containing the values to subtract from
     *          the current Vector3D object.
     */
    Vector3D.prototype.decrementBy = function (a) {
        this.x -= a.x;
        this.y -= a.y;
        this.z -= a.z;
    };
    /**
     * Returns the distance between two Vector3D objects. The
     * <code>distance()</code> method is a static method. You can use it
     * directly as a method of the Vector3D export class to get the Euclidean
     * distance between two three-dimensional points.
     *
     * @param pt1 A Vector3D object as the first three-dimensional point.
     * @param pt2 A Vector3D object as the second three-dimensional point.
     * @returns The distance between two Vector3D objects.
     */
    Vector3D.distance = function (pt1, pt2) {
        var x = (pt1.x - pt2.x);
        var y = (pt1.y - pt2.y);
        var z = (pt1.z - pt2.z);
        return Math.sqrt(x * x + y * y + z * z);
    };
    /**
     * If the current Vector3D object and the one specified as the
     * parameter are unit vertices, this method returns the cosine of the
     * angle between the two vertices. Unit vertices are vertices that
     * point to the same direction but their length is one. They remove the
     * length of the vector as a factor in the result. You can use the
     * <code>normalize()</code> method to convert a vector to a unit
     * vector.
     *
     * <p>The <code>dotProduct()</code> method finds the angle between two
     * vertices. It is also used in backface culling or lighting
     * calculations. Backface culling is a procedure for determining which
     * surfaces are hidden from the viewpoint. You can use the normalized
     * vertices from the camera, or eye, viewpoint and the cross product of
     * the vertices of a polygon surface to get the dot product. If the dot
     * product is less than zero, then the surface is facing the camera or
     * the viewer. If the two unit vertices are perpendicular to each
     * other, they are orthogonal and the dot product is zero. If the two
     * vertices are parallel to each other, the dot product is one.</p>
     *
     * @param a The second Vector3D object.
     * @returns A scalar which is the dot product of the current Vector3D
     *          object and the specified Vector3D object.
     *
     * @see away.geom.Vector3D#crossProduct()
     * @see away.geom.Vector3D#normalize()
     */
    Vector3D.prototype.dotProduct = function (a) {
        return this.x * a.x + this.y * a.y + this.z * a.z;
    };
    /**
     * Determines whether two Vector3D objects are equal by comparing the
     * x, y, and z elements of the current Vector3D object with a
     * specified Vector3D object. If the values of these elements are the
     * same, the two Vector3D objects are equal. If the second optional
     * parameter is set to true, all four elements of the Vector3D objects,
     * including the w property, are compared.
     */
    /**
     *
     * @param toCompare The Vector3D object to be compared with the current
     *                  Vector3D object.
     * @param allFour   An optional parameter that specifies whether the w
     *                  property of the Vector3D objects is used in the
     *                  comparison.
     * @returns A value of true if the specified Vector3D object is equal
     *          to the current Vector3D object; false if it is not equal.
     */
    Vector3D.prototype.equals = function (toCompare, allFour) {
        if (allFour === void 0) { allFour = false; }
        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && (!allFour || this.w == toCompare.w));
    };
    /**
     * Increments the value of the x, y, and z elements of the current
     * Vector3D object by the values of the x, y, and z elements of a
     * specified Vector3D object. Unlike the <code>Vector3D.add()</code>
     * method, the <code>incrementBy()</code> method changes the current
     * Vector3D object and does not return a new Vector3D object.
     *
     * @param a The Vector3D object to be added to the current Vector3D
     *          object.
     */
    Vector3D.prototype.incrementBy = function (a) {
        this.x += a.x;
        this.y += a.y;
        this.z += a.z;
    };
    /**
     * Compares the elements of the current Vector3D object with the
     * elements of a specified Vector3D object to determine whether they
     * are nearly equal. The two Vector3D objects are nearly equal if the
     * value of all the elements of the two vertices are equal, or the
     * result of the comparison is within the tolerance range. The
     * difference between two elements must be less than the number
     * specified as the tolerance parameter. If the third optional
     * parameter is set to <code>true</code>, all four elements of the
     * Vector3D objects, including the <code>w</code> property, are
     * compared. Otherwise, only the x, y, and z elements are included in
     * the comparison.
     */
    /**
     *
     * @param toCompare The Vector3D object to be compared with the current
     *                  Vector3D object.
     * @param tolerance A number determining the tolerance factor. If the
     *                  difference between the values of the Vector3D
     *                  element specified in the toCompare parameter and
     *                  the current Vector3D element is less than the
     *                  tolerance number, the two values are considered
     *                  nearly equal.
     * @param allFour   An optional parameter that specifies whether the w
     *                  property of the Vector3D objects is used in the
     *                  comparison.
     * @returns A value of true if the specified Vector3D object is nearly
     *          equal to the current Vector3D object; false if it is not
     *          equal.
     *
     * @see away.geom.Vector3D#equals()
     */
    Vector3D.prototype.nearEquals = function (toCompare, tolerance, allFour) {
        if (allFour === void 0) { allFour = true; }
        return ((Math.abs(this.x - toCompare.x) < tolerance) && (Math.abs(this.y - toCompare.y) < tolerance) && (Math.abs(this.z - toCompare.z) < tolerance) && (!allFour || Math.abs(this.w - toCompare.w) < tolerance));
    };
    /**
     * Sets the current Vector3D object to its inverse. The inverse object
     * is also considered the opposite of the original object. The value of
     * the x, y, and z properties of the current Vector3D object is changed
     * to -x, -y, and -z.
     */
    Vector3D.prototype.negate = function () {
        this.x = -this.x;
        this.y = -this.y;
        this.z = -this.z;
    };
    /**
     * Converts a Vector3D object to a unit vector by dividing the first
     * three elements (x, y, z) by the length of the vector. Unit vertices
     * are vertices that have a direction but their length is one. They
     * simplify vector calculations by removing length as a factor.
     */
    /**
     * Scales the line segment between(0,0) and the current point to a set
     * length.
     *
     * @param thickness The scaling value. For example, if the current
     *                  Vector3D object is (0,3,4), and you normalize it to
     *                  1, the point returned is at(0,0.6,0.8).
     */
    Vector3D.prototype.normalize = function (thickness) {
        if (thickness === void 0) { thickness = 1; }
        var len = this.length;
        if (len) {
            var invLength = thickness / len;
            this.x *= invLength;
            this.y *= invLength;
            this.z *= invLength;
        }
    };
    /**
     * Divides the value of the <code>x</code>, <code>y</code>, and
     * <code>z</code> properties of the current Vector3D object by the
     * value of its <code>w</code> property.
     *
     * <p>If the current Vector3D object is the result of multiplying a
     * Vector3D object by a projection Matrix3D object, the w property can
     * hold the transform value. The <code>project()</code> method then can
     * complete the projection by dividing the elements by the
     * <code>w</code> property. Use the <code>Matrix3D.rawData</code>
     * property to create a projection Matrix3D object.</p>
     */
    Vector3D.prototype.project = function () {
        this.x /= this.w;
        this.y /= this.w;
        this.z /= this.w;
    };
    /**
     * Scales the current Vector3D object by a scalar, a magnitude. The
     * Vector3D object's x, y, and z elements are multiplied by the scalar
     * number specified in the parameter. For example, if the vector is
     * scaled by ten, the result is a vector that is ten times longer. The
     * scalar can also change the direction of the vector. Multiplying the
     * vector by a negative number reverses its direction.
     *
     * @param s A multiplier (scalar) used to scale a Vector3D object.

     */
    Vector3D.prototype.scaleBy = function (s) {
        this.x *= s;
        this.y *= s;
        this.z *= s;
    };
    /**
     * Sets the members of Vector3D to the specified values
     *
     * @param xa The first element, such as the x coordinate.
     * @param ya The second element, such as the y coordinate.
     * @param za The third element, such as the z coordinate.
     */
    Vector3D.prototype.setTo = function (xa, ya, za, wa) {
        if (wa === void 0) { wa = 1; }
        this.x = xa;
        this.y = ya;
        this.z = za;
        this.w = wa;
    };
    /**
     * Subtracts the value of the x, y, and z elements of the current
     * Vector3D object from the values of the x, y, and z elements of
     * another Vector3D object. The <code>subtract()</code> method does not
     * change the current Vector3D object. Instead, this method returns a
     * new Vector3D object with the new values.
     *
     * @param a The Vector3D object to be subtracted from the current
     *          Vector3D object.
     * @returns A new Vector3D object that is the difference between the
     *          current Vector3D and the specified Vector3D object.
     *
     * @see away.geom.Vector3D#decrementBy()
     */
    Vector3D.prototype.subtract = function (a) {
        return new Vector3D(this.x - a.x, this.y - a.y, this.z - a.z);
    };
    /**
     * Returns a string representation of the current Vector3D object. The
     * string contains the values of the x, y, and z properties.
     */
    Vector3D.prototype.toString = function () {
        return "[Vector3D] (x:" + this.x + " ,y:" + this.y + ", z" + this.z + ", w:" + this.w + ")";
    };
    return Vector3D;
}());
/**
 * The x axis defined as a Vector3D object with coordinates (1,0,0).
 */
Vector3D.X_AXIS = new Vector3D(1, 0, 0);
/**
 * The y axis defined as a Vector3D object with coordinates (0,1,0).
 */
Vector3D.Y_AXIS = new Vector3D(0, 1, 0);
/**
 * The z axis defined as a Vector3D object with coordinates (0,0,1).
 */
Vector3D.Z_AXIS = new Vector3D(0, 0, 1);

/**
 * A Box object is an area defined by its position, as indicated by its
 * top-left-front corner point(<i>x</i>, <i>y</i>, <i>z</i>) and by its width,
 * height and depth.
 *
 *
 * <p>The <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
 * <code>height</code> <code>depth</code> properties of the Box export class are
 * independent of each other; changing the value of one property has no effect
 * on the others. However, the <code>right</code>, <code>bottom</code> and
 * <code>back</code> properties are integrally related to those six
 * properties. For example, if you change the value of the <code>right</code>
 * property, the value of the <code>width</code> property changes; if you
 * change the <code>bottom</code> property, the value of the
 * <code>height</code> property changes. </p>
 *
 * <p>The following methods and properties use Box objects:</p>
 *
 * <ul>
 *   <li>The <code>bounds</code> property of the DisplayObject class</li>
 * </ul>
 *
 * <p>You can use the <code>new Box()</code> constructor to create a
 * Box object.</p>
 *
 * <p><b>Note:</b> The Box export class does not define a cubic Shape
 * display object.
 */
var Box = (function () {
    /**
     * Creates a new Box object with the top-left-front corner specified by the
     * <code>x</code>, <code>y</code> and <code>z</code> parameters and with the
     * specified <code>width</code>, <code>height</code> and <code>depth</code>
     * parameters. If you call this public without parameters, a box with
     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
     * <code>height</code> and <code>depth</code> properties set to 0 is created.
     *
     * @param x      The <i>x</i> coordinate of the top-left-front corner of the
     *               box.
     * @param y      The <i>y</i> coordinate of the top-left-front corner of the
     *               box.
     * @param z      The <i>z</i> coordinate of the top-left-front corner of the
     *               box.
     * @param width  The width of the box, in pixels.
     * @param height The height of the box, in pixels.
     * @param depth The depth of the box, in pixels.
     */
    function Box(x, y, z, width, height, depth) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        if (depth === void 0) { depth = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.width = width;
        this.height = height;
        this.depth = depth;
    }
    Object.defineProperty(Box.prototype, "back", {
        /**
         * The sum of the <code>z</code> and <code>height</code> properties.
         */
        get: function () {
            return this.z + this.depth;
        },
        set: function (val) {
            this.depth = val - this.z;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottom", {
        /**
         * The sum of the <code>y</code> and <code>height</code> properties.
         */
        get: function () {
            return this.y + this.height;
        },
        set: function (val) {
            this.height = val - this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "bottomRightBack", {
        /**
         * The location of the Box object's bottom-right corner, determined by the
         * values of the <code>right</code> and <code>bottom</code> properties.
         */
        get: function () {
            if (this._bottomRightBack == null)
                this._bottomRightBack = new Vector3D();
            this._bottomRightBack.x = this.x + this.width;
            this._bottomRightBack.y = this.y + this.height;
            this._bottomRightBack.z = this.z + this.depth;
            return this._bottomRightBack;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "front", {
        /**
         * The <i>z</i> coordinate of the top-left-front corner of the box. Changing
         * the <code>front</code> property of a Box object has no effect on the
         * <code>x</code>, <code>y</code>, <code>width</code> and <code>height</code>
         * properties. However it does affect the <code>depth</code> property,
         * whereas changing the <code>z</code> value does <i>not</i> affect the
         * <code>depth</code> property.
         *
         * <p>The value of the <code>left</code> property is equal to the value of
         * the <code>x</code> property.</p>
         */
        get: function () {
            return this.z;
        },
        set: function (val) {
            this.depth += this.z - val;
            this.z = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "left", {
        /**
         * The <i>x</i> coordinate of the top-left corner of the box. Changing the
         * <code>left</code> property of a Box object has no effect on the
         * <code>y</code> and <code>height</code> properties. However it does affect
         * the <code>width</code> property, whereas changing the <code>x</code> value
         * does <i>not</i> affect the <code>width</code> property.
         *
         * <p>The value of the <code>left</code> property is equal to the value of
         * the <code>x</code> property.</p>
         */
        get: function () {
            return this.x;
        },
        set: function (val) {
            this.width += this.x - val;
            this.x = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "right", {
        /**
         * The sum of the <code>x</code> and <code>width</code> properties.
         */
        get: function () {
            return this.x + this.width;
        },
        set: function (val) {
            this.width = val - this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "size", {
        /**
         * The size of the Box object, expressed as a Vector3D object with the
         * values of the <code>width</code>, <code>height</code> and
         * <code>depth</code> properties.
         */
        get: function () {
            if (this._size == null)
                this._size = new Vector3D();
            this._size.x = this.width;
            this._size.y = this.height;
            this._size.z = this.depth;
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "top", {
        /**
         * The <i>y</i> coordinate of the top-left-front corner of the box. Changing
         * the <code>top</code> property of a Box object has no effect on the
         * <code>x</code> and <code>width</code> properties. However it does affect
         * the <code>height</code> property, whereas changing the <code>y</code>
         * value does <i>not</i> affect the <code>height</code> property.
         *
         * <p>The value of the <code>top</code> property is equal to the value of the
         * <code>y</code> property.</p>
         */
        get: function () {
            return this.y;
        },
        set: function (val) {
            this.height += (this.y - val);
            this.y = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Box.prototype, "topLeftFront", {
        /**
         * The location of the Box object's top-left-front corner, determined by the
         * <i>x</i>, <i>y</i> and <i>z</i> coordinates of the point.
         */
        get: function () {
            if (this._topLeftFront == null)
                this._topLeftFront = new Vector3D();
            this._topLeftFront.x = this.x;
            this._topLeftFront.y = this.y;
            this._topLeftFront.z = this.z;
            return this._topLeftFront;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new Box object with the same values for the <code>x</code>,
     * <code>y</code>, <code>z</code>, <code>width</code>, <code>height</code>
     * and <code>depth</code> properties as the original Box object.
     *
     * @return A new Box object with the same values for the <code>x</code>,
     *         <code>y</code>, <code>z</code>, <code>width</code>,
     *         <code>height</code> and <code>depth</code> properties as the
     *         original Box object.
     */
    Box.prototype.clone = function () {
        return new Box(this.x, this.y, this.z, this.width, this.height, this.depth);
    };
    /**
     * Determines whether the specified position is contained within the cubic
     * region defined by this Box object.
     *
     * @param x The <i>x</i> coordinate(horizontal component) of the position.
     * @param y The <i>y</i> coordinate(vertical component) of the position.
     * @param z The <i>z</i> coordinate(longitudinal component) of the position.
     * @return A value of <code>true</code> if the Box object contains the
     *         specified position; otherwise <code>false</code>.
     */
    Box.prototype.contains = function (x, y, z) {
        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y && this.z <= z && this.z + this.depth >= z);
    };
    /**
     * Determines whether the specified position is contained within the cubic
     * region defined by this Box object. This method is similar to the
     * <code>Box.contains()</code> method, except that it takes a Vector3D
     * object as a parameter.
     *
     * @param position The position, as represented by its <i>x</i>, <i>y</i> and
     *                 <i>z</i> coordinates.
     * @return A value of <code>true</code> if the Box object contains the
     *         specified position; otherwise <code>false</code>.
     */
    Box.prototype.containsPoint = function (position) {
        return (this.x <= position.x && this.x + this.width >= position.x && this.y <= position.y && this.y + this.height >= position.y && this.z <= position.z && this.z + this.depth >= position.z);
    };
    /**
     * Determines whether the Box object specified by the <code>box</code>
     * parameter is contained within this Box object. A Box object is said to
     * contain another if the second Box object falls entirely within the
     * boundaries of the first.
     *
     * @param box The Box object being checked.
     * @return A value of <code>true</code> if the Box object that you specify
     *         is contained by this Box object; otherwise <code>false</code>.
     */
    Box.prototype.containsBox = function (box) {
        return (this.x <= box.x && this.x + this.width >= box.x + box.width && this.y <= box.y && this.y + this.height >= box.y + box.height && this.z <= box.z && this.z + this.depth >= box.z + box.depth);
    };
    /**
     * Copies all of box data from the source Box object into the calling
     * Box object.
     *
     * @param sourceBox The Box object from which to copy the data.
     */
    Box.prototype.copyFrom = function (sourceBox) {
        this.x = sourceBox.x;
        this.y = sourceBox.y;
        this.z = sourceBox.z;
        this.width = sourceBox.width;
        this.height = sourceBox.height;
        this.depth = sourceBox.depth;
    };
    /**
     * Determines whether the object specified in the <code>toCompare</code>
     * parameter is equal to this Box object. This method compares the
     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
     * <code>height</code> and <code>depth</code> properties of an object against
     * the same properties of this Box object.
     *
     * @param toCompare The box to compare to this Box object.
     * @return A value of <code>true</code> if the object has exactly the same
     *         values for the <code>x</code>, <code>y</code>, <code>z</code>,
     *         <code>width</code>, <code>height</code> and <code>depth</code>
     *         properties as this Box object; otherwise <code>false</code>.
     */
    Box.prototype.equals = function (toCompare) {
        return (this.x == toCompare.x && this.y == toCompare.y && this.z == toCompare.z && this.width == toCompare.width && this.height == toCompare.height && this.depth == toCompare.depth);
    };
    /**
     * Increases the size of the Box object by the specified amounts, in
     * pixels. The center point of the Box object stays the same, and its
     * size increases to the left and right by the <code>dx</code> value, to
     * the top and the bottom by the <code>dy</code> value, and to
     * the front and the back by the <code>dz</code> value.
     *
     * @param dx The value to be added to the left and the right of the Box
     *           object. The following equation is used to calculate the new
     *           width and position of the box:
     * @param dy The value to be added to the top and the bottom of the Box
     *           object. The following equation is used to calculate the new
     *           height and position of the box:
     * @param dz The value to be added to the front and the back of the Box
     *           object. The following equation is used to calculate the new
     *           depth and position of the box:
     */
    Box.prototype.inflate = function (dx, dy, dz) {
        this.x -= dx / 2;
        this.y -= dy / 2;
        this.z -= dz / 2;
        this.width += dx / 2;
        this.height += dy / 2;
        this.depth += dz / 2;
    };
    /**
     * Increases the size of the Box object. This method is similar to the
     * <code>Box.inflate()</code> method except it takes a Vector3D object as
     * a parameter.
     *
     * <p>The following two code examples give the same result:</p>
     *
     * @param delta The <code>x</code> property of this Vector3D object is used to
     *              increase the horizontal dimension of the Box object.
     *              The <code>y</code> property is used to increase the vertical
     *              dimension of the Box object.
     *              The <code>z</code> property is used to increase the
     *              longitudinal dimension of the Box object.
     */
    Box.prototype.inflatePoint = function (delta) {
        this.x -= delta.x / 2;
        this.y -= delta.y / 2;
        this.z -= delta.z / 2;
        this.width += delta.x / 2;
        this.height += delta.y / 2;
        this.depth += delta.z / 2;
    };
    /**
     * If the Box object specified in the <code>toIntersect</code> parameter
     * intersects with this Box object, returns the area of intersection
     * as a Box object. If the boxes do not intersect, this method returns an
     * empty Box object with its properties set to 0.
     *
     * @param toIntersect The Box object to compare against to see if it
     *                    intersects with this Box object.
     * @return A Box object that equals the area of intersection. If the
     *         boxes do not intersect, this method returns an empty Box
     *         object; that is, a box with its <code>x</code>, <code>y</code>,
     *         <code>z</code>, <code>width</code>,  <code>height</code>, and
     *         <code>depth</code> properties set to 0.
     */
    Box.prototype.intersection = function (toIntersect) {
        if (this.intersects(toIntersect)) {
            var i = new Box();
            if (this.x > toIntersect.x) {
                i.x = this.x;
                i.width = toIntersect.x - this.x + toIntersect.width;
                if (i.width > this.width)
                    i.width = this.width;
            }
            else {
                i.x = toIntersect.x;
                i.width = this.x - toIntersect.x + this.width;
                if (i.width > toIntersect.width)
                    i.width = toIntersect.width;
            }
            if (this.y > toIntersect.y) {
                i.y = this.y;
                i.height = toIntersect.y - this.y + toIntersect.height;
                if (i.height > this.height)
                    i.height = this.height;
            }
            else {
                i.y = toIntersect.y;
                i.height = this.y - toIntersect.y + this.height;
                if (i.height > toIntersect.height)
                    i.height = toIntersect.height;
            }
            if (this.z > toIntersect.z) {
                i.z = this.z;
                i.depth = toIntersect.z - this.z + toIntersect.depth;
                if (i.depth > this.depth)
                    i.depth = this.depth;
            }
            else {
                i.z = toIntersect.z;
                i.depth = this.z - toIntersect.z + this.depth;
                if (i.depth > toIntersect.depth)
                    i.depth = toIntersect.depth;
            }
            return i;
        }
        return new Box();
    };
    /**
     * Determines whether the object specified in the <code>toIntersect</code>
     * parameter intersects with this Box object. This method checks the
     * <code>x</code>, <code>y</code>, <code>z</code>, <code>width</code>,
     * <code>height</code>, and <code>depth</code> properties of the specified
     * Box object to see if it intersects with this Box object.
     *
     * @param toIntersect The Box object to compare against this Box object.
     * @return A value of <code>true</code> if the specified object intersects
     *         with this Box object; otherwise <code>false</code>.
     */
    Box.prototype.intersects = function (toIntersect) {
        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height && this.z + this.depth > toIntersect.z && this.z < toIntersect.z + toIntersect.depth);
    };
    Box.prototype.rayIntersection = function (position, direction, targetNormal) {
        if (this.containsPoint(position))
            return 0;
        var halfExtentsX = this.width / 2;
        var halfExtentsY = this.height / 2;
        var halfExtentsZ = this.depth / 2;
        var centerX = this.x + halfExtentsX;
        var centerY = this.y + halfExtentsY;
        var centerZ = this.z + halfExtentsZ;
        var px = position.x - centerX;
        var py = position.y - centerY;
        var pz = position.z - centerZ;
        var vx = direction.x;
        var vy = direction.y;
        var vz = direction.z;
        var ix;
        var iy;
        var iz;
        var rayEntryDistance;
        // ray-plane tests
        var intersects;
        if (vx < 0) {
            rayEntryDistance = (halfExtentsX - px) / vx;
            if (rayEntryDistance > 0) {
                iy = py + rayEntryDistance * vy;
                iz = pz + rayEntryDistance * vz;
                if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
                    targetNormal.x = 1;
                    targetNormal.y = 0;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vx > 0) {
            rayEntryDistance = (-halfExtentsX - px) / vx;
            if (rayEntryDistance > 0) {
                iy = py + rayEntryDistance * vy;
                iz = pz + rayEntryDistance * vz;
                if (iy > -halfExtentsY && iy < halfExtentsY && iz > -halfExtentsZ && iz < halfExtentsZ) {
                    targetNormal.x = -1;
                    targetNormal.y = 0;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vy < 0) {
            rayEntryDistance = (halfExtentsY - py) / vy;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iz = pz + rayEntryDistance * vz;
                if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
                    targetNormal.x = 0;
                    targetNormal.y = 1;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vy > 0) {
            rayEntryDistance = (-halfExtentsY - py) / vy;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iz = pz + rayEntryDistance * vz;
                if (ix > -halfExtentsX && ix < halfExtentsX && iz > -halfExtentsZ && iz < halfExtentsZ) {
                    targetNormal.x = 0;
                    targetNormal.y = -1;
                    targetNormal.z = 0;
                    intersects = true;
                }
            }
        }
        if (!intersects && vz < 0) {
            rayEntryDistance = (halfExtentsZ - pz) / vz;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iy = py + rayEntryDistance * vy;
                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
                    targetNormal.x = 0;
                    targetNormal.y = 0;
                    targetNormal.z = 1;
                    intersects = true;
                }
            }
        }
        if (!intersects && vz > 0) {
            rayEntryDistance = (-halfExtentsZ - pz) / vz;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iy = py + rayEntryDistance * vy;
                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
                    targetNormal.x = 0;
                    targetNormal.y = 0;
                    targetNormal.z = -1;
                    intersects = true;
                }
            }
        }
        return intersects ? rayEntryDistance : -1;
    };
    /**
     * Finds the closest point on the Box to another given point. This can be used for maximum error calculations for content within a given Box.
     *
     * @param point The point for which to find the closest point on the Box
     * @param target An optional Vector3D to store the result to prevent creating a new object.
     * @return
     */
    Box.prototype.closestPointToPoint = function (point, target) {
        if (target === void 0) { target = null; }
        var p;
        if (target == null)
            target = new Vector3D();
        p = point.x;
        if (p < this.x)
            p = this.x;
        if (p > this.x + this.width)
            p = this.x + this.width;
        target.x = p;
        p = point.y;
        if (p < this.y + this.height)
            p = this.y + this.height;
        if (p > this.y)
            p = this.y;
        target.y = p;
        p = point.z;
        if (p < this.z)
            p = this.z;
        if (p > this.z + this.depth)
            p = this.z + this.depth;
        target.z = p;
        return target;
    };
    /**
     * Determines whether or not this Box object is empty.
     *
     * @return A value of <code>true</code> if the Box object's width, height or
     *         depth is less than or equal to 0; otherwise <code>false</code>.
     */
    Box.prototype.isEmpty = function () {
        return (this.x == 0 && this.y == 0 && this.z == 0 && this.width == 0 && this.height == 0 && this.depth == 0);
    };
    /**
     * Adjusts the location of the Box object, as determined by its
     * top-left-front corner, by the specified amounts.
     *
     * @param dx Moves the <i>x</i> value of the Box object by this amount.
     * @param dy Moves the <i>y</i> value of the Box object by this amount.
     * @param dz Moves the <i>z</i> value of the Box object by this amount.
     */
    Box.prototype.offset = function (dx, dy, dz) {
        this.x += dx;
        this.y += dy;
        this.z += dz;
    };
    /**
     * Adjusts the location of the Box object using a Vector3D object as a
     * parameter. This method is similar to the <code>Box.offset()</code>
     * method, except that it takes a Vector3D object as a parameter.
     *
     * @param position A Vector3D object to use to offset this Box object.
     */
    Box.prototype.offsetPosition = function (position) {
        this.x += position.x;
        this.y += position.y;
        this.z += position.z;
    };
    /**
     * Sets all of the Box object's properties to 0. A Box object is empty if its
     * width, height or depth is less than or equal to 0.
     *
     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
     * <code>z</code>, <code>width</code>, <code>height</code>, and
     * <code>depth</code> properties to 0.</p>
     *
     */
    Box.prototype.setEmpty = function () {
        this.x = 0;
        this.y = 0;
        this.z = 0;
        this.width = 0;
        this.height = 0;
        this.depth = 0;
    };
    /**
     * Sets the members of Box to the specified values
     *
     * @param xa      The <i>x</i> coordinate of the top-left-front corner of the
     *                box.
     * @param ya      The <i>y</i> coordinate of the top-left-front corner of the
     *                box.
     * @param yz      The <i>z</i> coordinate of the top-left-front corner of the
     *                box.
     * @param widtha  The width of the box, in pixels.
     * @param heighta The height of the box, in pixels.
     * @param deptha  The depth of the box, in pixels.
     */
    Box.prototype.setTo = function (xa, ya, za, widtha, heighta, deptha) {
        this.x = xa;
        this.y = ya;
        this.z = za;
        this.width = widtha;
        this.height = heighta;
        this.depth = deptha;
    };
    /**
     * Builds and returns a string that lists the horizontal, vertical and
     * longitudinal positions and the width, height and depth of the Box object.
     *
     * @return A string listing the value of each of the following properties of
     *         the Box object: <code>x</code>, <code>y</code>, <code>z</code>,
     *         <code>width</code>, <code>height</code>, and <code>depth</code>.
     */
    Box.prototype.toString = function () {
        return "[Box] (x=" + this.x + ", y=" + this.y + ", z=" + this.z + ", width=" + this.width + ", height=" + this.height + ", depth=" + this.depth + ")";
    };
    /**
     * Adds two boxes together to create a new Box object, by filling
     * in the horizontal, vertical and longitudinal space between the two boxes.
     *
     * <p><b>Note:</b> The <code>union()</code> method ignores boxes with
     * <code>0</code> as the height, width or depth value, such as: <code>var
     * box2:Box = new Box(300,300,300,50,50,0);</code></p>
     *
     * @param toUnion A Box object to add to this Box object.
     * @return A new Box object that is the union of the two boxes.
     */
    Box.prototype.union = function (toUnion, target) {
        if (target === void 0) { target = null; }
        var width;
        var height;
        var depth;
        if (target == null)
            target = new Box();
        if (this.x < toUnion.x) {
            width = toUnion.x - this.x + toUnion.width;
            target.x = this.x;
            target.width = (width < this.width) ? this.width : width;
        }
        else {
            width = this.x - toUnion.x + this.width;
            target.x = toUnion.x;
            target.width = (width < toUnion.width) ? toUnion.width : width;
        }
        if (this.y < toUnion.y) {
            height = toUnion.y - this.y + toUnion.height;
            target.y = this.y;
            target.height = (height < this.height) ? this.height : height;
        }
        else {
            height = this.y - toUnion.y + this.height;
            target.y = toUnion.y;
            target.height = (height < toUnion.height) ? toUnion.height : height;
        }
        if (this.z < toUnion.z) {
            depth = toUnion.z - this.z + toUnion.depth;
            target.z = this.z;
            target.depth = (depth < this.depth) ? this.depth : depth;
        }
        else {
            depth = this.z - toUnion.z + this.depth;
            target.z = toUnion.z;
            target.depth = (depth < toUnion.depth) ? toUnion.depth : depth;
        }
        return target;
    };
    return Box;
}());

/**
* MathConsts provides some commonly used mathematical constants
*/
var MathConsts = (function () {
    function MathConsts() {
    }
    return MathConsts;
}());
/**
 * The amount to multiply with when converting radians to degrees.
 */
MathConsts.RADIANS_TO_DEGREES = 180 / Math.PI;
/**
 * The amount to multiply with when converting degrees to radians.
 */
MathConsts.DEGREES_TO_RADIANS = Math.PI / 180;

/**
 * A Quaternion object which can be used to represent rotations.
 */
var Orientation3D = (function () {
    function Orientation3D() {
    }
    return Orientation3D;
}());
/**
 * The axis angle orientation uses a combination of an axis and an angle to determine the orientation.
 * @type {string}
 */
Orientation3D.AXIS_ANGLE = "axisAngle";
/**
 * The default orientation for decompose() and recompose() methods, defines the orientation with three separate angles of rotation for each axis.
 * @type {string}
 */
Orientation3D.EULER_ANGLES = "eulerAngles";
/**
 * The quaternion orientation uses complex numbers.
 * @type {string}
 */
Orientation3D.QUATERNION = "quaternion";

/**
 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
 * by a concrete subclass.
 */
var ArgumentError = (function (_super) {
    __extends(ArgumentError, _super);
    /**
     * Create a new ArgumentError.
     *
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function ArgumentError(message, id) {
        if (message === void 0) { message = null; }
        if (id === void 0) { id = 0; }
        return _super.call(this, message || "ArgumentError", id) || this;
    }
    return ArgumentError;
}(ErrorBase));

var Matrix3D = (function () {
    /**
     * Creates a Matrix3D object.
     */
    function Matrix3D(rawData) {
        if (rawData === void 0) { rawData = null; }
        this._position = new Vector3D();
        this._positionDirty = true;
        if (rawData != null) {
            this._rawData = rawData;
        }
        else {
            this._rawData = new Float32Array(16);
            this.identity();
        }
    }
    Matrix3D.getAxisRotationMatrix = function (x, y, z, degrees, target) {
        if (target === void 0) { target = null; }
        if (target == null)
            target = new Matrix3D();
        var targetData = target._rawData;
        var rad = degrees * MathConsts.DEGREES_TO_RADIANS;
        var c = Math.cos(rad);
        var s = Math.sin(rad);
        var t = 1 - c;
        var tmp1, tmp2;
        targetData[0] = c + x * x * t;
        targetData[5] = c + y * y * t;
        targetData[10] = c + z * z * t;
        tmp1 = x * y * t;
        tmp2 = z * s;
        targetData[1] = tmp1 + tmp2;
        targetData[4] = tmp1 - tmp2;
        tmp1 = x * z * t;
        tmp2 = y * s;
        targetData[8] = tmp1 + tmp2;
        targetData[2] = tmp1 - tmp2;
        tmp1 = y * z * t;
        tmp2 = x * s;
        targetData[9] = tmp1 - tmp2;
        targetData[6] = tmp1 + tmp2;
        targetData[3] = 0;
        targetData[7] = 0;
        targetData[11] = 0;
        targetData[12] = 0;
        targetData[13] = 0;
        targetData[14] = 0;
        targetData[15] = 1;
        target.invalidatePosition();
        return target;
    };
    Matrix3D.getPointAtMatrix = function (pos, dir, up, target) {
        if (target === void 0) { target = null; }
        var dirN;
        var upN;
        var lftN;
        if (target == null)
            target = new Matrix3D();
        var targetData = target._rawData;
        dirN = dir.clone();
        dirN.normalize();
        upN = up.clone();
        upN.normalize();
        lftN = upN.crossProduct(dirN);
        lftN.normalize();
        if (lftN.length < 0.05) {
            lftN.x = upN.y;
            lftN.y = upN.x;
            lftN.z = 0;
            lftN.normalize();
        }
        upN = dirN.crossProduct(lftN);
        targetData[0] = lftN.x;
        targetData[1] = lftN.y;
        targetData[2] = lftN.z;
        targetData[3] = 0;
        targetData[4] = upN.x;
        targetData[5] = upN.y;
        targetData[6] = upN.z;
        targetData[7] = 0;
        targetData[8] = dirN.x;
        targetData[9] = dirN.y;
        targetData[10] = dirN.z;
        targetData[11] = 0;
        targetData[12] = lftN.dotProduct(pos);
        targetData[13] = upN.dotProduct(pos);
        targetData[14] = dirN.dotProduct(pos);
        targetData[15] = 1;
        target.invalidatePosition();
        return target;
    };
    /**
     * Fills the 3d matrix with values representing the transformation made by the given quaternion.
     *
     * @param    quarternion    The quarterion object to convert.
     */
    Matrix3D.getQuaternionMatrix = function (quarternion, target) {
        if (target === void 0) { target = null; }
        if (target == null)
            target = new Matrix3D();
        var targetData = target._rawData;
        var x = quarternion.x;
        var y = quarternion.y;
        var z = quarternion.z;
        var w = quarternion.w;
        var xx = x * x;
        var xy = x * y;
        var xz = x * z;
        var xw = x * w;
        var yy = y * y;
        var yz = y * z;
        var yw = y * w;
        var zz = z * z;
        var zw = z * w;
        targetData[0] = 1 - 2 * (yy + zz);
        targetData[1] = 2 * (xy + zw);
        targetData[2] = 2 * (xz - yw);
        targetData[4] = 2 * (xy - zw);
        targetData[5] = 1 - 2 * (xx + zz);
        targetData[6] = 2 * (yz + xw);
        targetData[8] = 2 * (xz + yw);
        targetData[9] = 2 * (yz - xw);
        targetData[10] = 1 - 2 * (xx + yy);
        targetData[3] = 0;
        targetData[7] = 0;
        targetData[11] = 0;
        targetData[12] = 0;
        targetData[13] = 0;
        targetData[14] = 0;
        targetData[15] = 1;
        target.invalidatePosition();
        return target;
    };
    /**
     * Returns a boolean value representing whether there is any difference between the two given 3d matrices.
     */
    Matrix3D.compare = function (m1, m2) {
        var r1 = m1._rawData;
        var r2 = m2._rawData;
        for (var i = 0; i < 16; ++i)
            if (r1[i] != r2[i])
                return false;
        return true;
    };
    Object.defineProperty(Matrix3D.prototype, "determinant", {
        /**
         * [read-only] A number that determines whether a matrix is invertible.
         */
        get: function () {
            return ((this._rawData[0] * this._rawData[5] - this._rawData[4] * this._rawData[1]) * (this._rawData[10] * this._rawData[15] - this._rawData[14] * this._rawData[11]) - (this._rawData[0] * this._rawData[9] - this._rawData[8] * this._rawData[1]) * (this._rawData[6] * this._rawData[15] - this._rawData[14] * this._rawData[7]) + (this._rawData[0] * this._rawData[13] - this._rawData[12] * this._rawData[1]) * (this._rawData[6] * this._rawData[11] - this._rawData[10] * this._rawData[7]) + (this._rawData[4] * this._rawData[9] - this._rawData[8] * this._rawData[5]) * (this._rawData[2] * this._rawData[15] - this._rawData[14] * this._rawData[3]) - (this._rawData[4] * this._rawData[13] - this._rawData[12] * this._rawData[5]) * (this._rawData[2] * this._rawData[11] - this._rawData[10] * this._rawData[3]) + (this._rawData[8] * this._rawData[13] - this._rawData[12] * this._rawData[9]) * (this._rawData[2] * this._rawData[7] - this._rawData[6] * this._rawData[3]));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix3D.prototype, "position", {
        /**
         * A Vector3D object that holds the position, the 3D coordinate (x,y,z) of a display object within the
         * transformation's frame of reference.
         */
        get: function () {
            if (this._positionDirty) {
                this._positionDirty = false;
                this._position.x = this._rawData[12];
                this._position.y = this._rawData[13];
                this._position.z = this._rawData[14];
            }
            return this._position;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Appends the matrix by multiplying another Matrix3D object by the current Matrix3D object.
     */
    Matrix3D.prototype.append = function (lhs) {
        var lrd = lhs._rawData;
        var m111 = this._rawData[0];
        var m112 = this._rawData[1];
        var m113 = this._rawData[2];
        var m114 = this._rawData[3];
        var m121 = this._rawData[4];
        var m122 = this._rawData[5];
        var m123 = this._rawData[6];
        var m124 = this._rawData[7];
        var m131 = this._rawData[8];
        var m132 = this._rawData[9];
        var m133 = this._rawData[10];
        var m134 = this._rawData[11];
        var m141 = this._rawData[12];
        var m142 = this._rawData[13];
        var m143 = this._rawData[14];
        var m144 = this._rawData[15];
        var m211 = lrd[0];
        var m212 = lrd[1];
        var m213 = lrd[2];
        var m214 = lrd[3];
        var m221 = lrd[4];
        var m222 = lrd[5];
        var m223 = lrd[6];
        var m224 = lrd[7];
        var m231 = lrd[8];
        var m232 = lrd[9];
        var m233 = lrd[10];
        var m234 = lrd[11];
        var m241 = lrd[12];
        var m242 = lrd[13];
        var m243 = lrd[14];
        var m244 = lrd[15];
        this._rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
        this._rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
        this._rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
        this._rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
        this._rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
        this._rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
        this._rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
        this._rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
        this._rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
        this._rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
        this._rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
        this._rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
        this._rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
        this._rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
        this._rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
        this._rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
        this._positionDirty = true;
    };
    /**
     * Appends an incremental rotation to a Matrix3D object.
     */
    Matrix3D.prototype.appendRotation = function (degrees, axis) {
        this.append(Matrix3D.getAxisRotationMatrix(axis.x, axis.y, axis.z, degrees, Matrix3D._tempMatrix));
    };
    /**
     * Appends an incremental skew change along the x, y, and z axes to a Matrix3D object.
     */
    Matrix3D.prototype.appendSkew = function (xSkew, ySkew, zSkew) {
        if (xSkew == 0 && ySkew == 0 && zSkew == 0)
            return;
        var rawData = Matrix3D._tempMatrix._rawData;
        rawData[0] = 1;
        rawData[1] = 0;
        rawData[2] = 0;
        rawData[3] = 0;
        rawData[4] = xSkew;
        rawData[5] = 1;
        rawData[6] = 0;
        rawData[7] = 0;
        rawData[8] = ySkew;
        rawData[9] = zSkew;
        rawData[10] = 1;
        rawData[11] = 0;
        rawData[12] = 0;
        rawData[13] = 0;
        rawData[14] = 0;
        rawData[15] = 1;
        this.append(Matrix3D._tempMatrix);
    };
    /**
     * Appends an incremental scale change along the x, y, and z axes to a Matrix3D object.
     */
    Matrix3D.prototype.appendScale = function (xScale, yScale, zScale) {
        if (xScale == 1 && yScale == 1 && zScale == 1)
            return;
        var rawData = Matrix3D._tempMatrix._rawData;
        rawData[0] = xScale;
        rawData[1] = 0;
        rawData[2] = 0;
        rawData[3] = 0;
        rawData[4] = 0;
        rawData[5] = yScale;
        rawData[6] = 0;
        rawData[7] = 0;
        rawData[8] = 0;
        rawData[9] = 0;
        rawData[10] = zScale;
        rawData[11] = 0;
        rawData[12] = 0;
        rawData[13] = 0;
        rawData[14] = 0;
        rawData[15] = 1;
        this.append(Matrix3D._tempMatrix);
    };
    /**
     * Appends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
     */
    Matrix3D.prototype.appendTranslation = function (x, y, z) {
        this._rawData[12] += x;
        this._rawData[13] += y;
        this._rawData[14] += z;
        this._positionDirty = true;
    };
    /**
     * Returns a new Matrix3D object that is an exact copy of the current Matrix3D object.
     */
    Matrix3D.prototype.clone = function () {
        var matrix3D = new Matrix3D();
        matrix3D.copyFrom(this);
        return matrix3D;
    };
    /**
     * Copies a Vector3D object into specific column of the calling Matrix3D object.
     */
    Matrix3D.prototype.copyColumnFrom = function (column, vector3D) {
        if (column < 0 || column > 3)
            throw new ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
        column *= 4;
        this._rawData[column] = vector3D.x;
        this._rawData[column + 1] = vector3D.y;
        this._rawData[column + 2] = vector3D.z;
        this._rawData[column + 3] = vector3D.w;
        this._positionDirty = true;
    };
    /**
     * Copies specific column of the calling Matrix3D object into the Vector3D object.
     */
    Matrix3D.prototype.copyColumnTo = function (column, vector3D, negate) {
        if (negate === void 0) { negate = false; }
        if (column < 0 || column > 3)
            throw new ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 3]");
        column *= 4;
        var sourceData = this._rawData;
        if (negate) {
            vector3D.x = -sourceData[column];
            vector3D.y = -sourceData[column + 1];
            vector3D.z = -sourceData[column + 2];
            vector3D.w = -sourceData[column + 3];
        }
        else {
            vector3D.x = sourceData[column];
            vector3D.y = sourceData[column + 1];
            vector3D.z = sourceData[column + 2];
            vector3D.w = sourceData[column + 3];
        }
    };
    /**
     * Copies all of the matrix data from the source Matrix3D object into the calling Matrix3D object.
     */
    Matrix3D.prototype.copyFrom = function (source, transpose) {
        if (transpose === void 0) { transpose = false; }
        var sourceData = source._rawData, targetData = this._rawData;
        targetData[0] = sourceData[0];
        targetData[5] = sourceData[5];
        targetData[10] = sourceData[10];
        targetData[15] = sourceData[15];
        if (transpose) {
            targetData[1] = sourceData[4];
            targetData[2] = sourceData[8];
            targetData[3] = sourceData[12];
            targetData[4] = sourceData[1];
            targetData[6] = sourceData[9];
            targetData[7] = sourceData[13];
            targetData[8] = sourceData[2];
            targetData[9] = sourceData[6];
            targetData[11] = sourceData[14];
            targetData[12] = sourceData[3];
            targetData[13] = sourceData[7];
            targetData[14] = sourceData[11];
        }
        else {
            targetData[1] = sourceData[1];
            targetData[2] = sourceData[2];
            targetData[3] = sourceData[3];
            targetData[4] = sourceData[4];
            targetData[6] = sourceData[6];
            targetData[7] = sourceData[7];
            targetData[8] = sourceData[8];
            targetData[9] = sourceData[9];
            targetData[11] = sourceData[11];
            targetData[12] = sourceData[12];
            targetData[13] = sourceData[13];
            targetData[14] = sourceData[14];
        }
        this._positionDirty = true;
    };
    /**
     * Copies this Matrix3D object into a destination Matrix3D object.
     */
    Matrix3D.prototype.copyTo = function (target, transpose) {
        if (transpose === void 0) { transpose = false; }
        target.copyFrom(this, transpose);
    };
    Matrix3D.prototype.copyRawDataFrom = function (sourceData, offset, transpose) {
        if (offset === void 0) { offset = 0; }
        if (transpose === void 0) { transpose = false; }
        var targetData = this._rawData;
        targetData[0] = sourceData[offset + 0];
        targetData[5] = sourceData[offset + 5];
        targetData[10] = sourceData[offset + 10];
        targetData[15] = sourceData[offset + 15];
        if (transpose) {
            targetData[offset + 1] = sourceData[4];
            targetData[offset + 2] = sourceData[8];
            targetData[offset + 3] = sourceData[12];
            targetData[offset + 4] = sourceData[1];
            targetData[offset + 6] = sourceData[9];
            targetData[offset + 7] = sourceData[13];
            targetData[offset + 8] = sourceData[2];
            targetData[offset + 9] = sourceData[6];
            targetData[offset + 11] = sourceData[14];
            targetData[offset + 12] = sourceData[3];
            targetData[offset + 13] = sourceData[7];
            targetData[offset + 14] = sourceData[11];
        }
        else {
            targetData[1] = sourceData[offset + 1];
            targetData[2] = sourceData[offset + 2];
            targetData[3] = sourceData[offset + 3];
            targetData[4] = sourceData[offset + 4];
            targetData[6] = sourceData[offset + 6];
            targetData[7] = sourceData[offset + 7];
            targetData[8] = sourceData[offset + 8];
            targetData[9] = sourceData[offset + 9];
            targetData[11] = sourceData[offset + 11];
            targetData[12] = sourceData[offset + 12];
            targetData[13] = sourceData[offset + 13];
            targetData[14] = sourceData[offset + 14];
        }
        this._positionDirty = true;
    };
    Matrix3D.prototype.copyRawDataTo = function (targetData, offset, transpose) {
        if (offset === void 0) { offset = 0; }
        if (transpose === void 0) { transpose = false; }
        var sourceData = this._rawData;
        targetData[offset] = sourceData[0];
        targetData[offset + 5] = sourceData[5];
        targetData[offset + 10] = sourceData[10];
        targetData[offset + 15] = sourceData[15];
        if (transpose) {
            targetData[offset + 1] = sourceData[4];
            targetData[offset + 2] = sourceData[8];
            targetData[offset + 3] = sourceData[12];
            targetData[offset + 4] = sourceData[1];
            targetData[offset + 6] = sourceData[9];
            targetData[offset + 7] = sourceData[13];
            targetData[offset + 8] = sourceData[2];
            targetData[offset + 9] = sourceData[6];
            targetData[offset + 11] = sourceData[14];
            targetData[offset + 12] = sourceData[3];
            targetData[offset + 13] = sourceData[7];
            targetData[offset + 14] = sourceData[11];
        }
        else {
            targetData[offset + 1] = sourceData[1];
            targetData[offset + 2] = sourceData[2];
            targetData[offset + 3] = sourceData[3];
            targetData[offset + 4] = sourceData[4];
            targetData[offset + 6] = sourceData[6];
            targetData[offset + 7] = sourceData[7];
            targetData[offset + 8] = sourceData[8];
            targetData[offset + 9] = sourceData[9];
            targetData[offset + 11] = sourceData[11];
            targetData[offset + 12] = sourceData[12];
            targetData[offset + 13] = sourceData[13];
            targetData[offset + 14] = sourceData[14];
        }
    };
    /**
     * Copies a Vector3D object into specific row of the calling Matrix3D object.
     */
    Matrix3D.prototype.copyRowFrom = function (row, vector3D) {
        if (row < 0 || row > 3)
            throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
        this._rawData[row] = vector3D.x;
        this._rawData[row + 4] = vector3D.y;
        this._rawData[row + 8] = vector3D.z;
        this._rawData[row + 12] = vector3D.w;
        this._positionDirty = true;
    };
    /**
     * Copies specific row of the calling Matrix3D object into the Vector3D object.
     */
    Matrix3D.prototype.copyRowTo = function (row, vector3D, negate) {
        if (negate === void 0) { negate = false; }
        if (row < 0 || row > 3)
            throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 3]");
        var sourceData = this._rawData;
        if (negate) {
            vector3D.x = -sourceData[row];
            vector3D.y = -sourceData[row + 4];
            vector3D.z = -sourceData[row + 8];
            vector3D.w = -sourceData[row + 12];
        }
        else {
            vector3D.x = sourceData[row];
            vector3D.y = sourceData[row + 4];
            vector3D.z = sourceData[row + 8];
            vector3D.w = sourceData[row + 12];
        }
    };
    /**
     * Returns the transformation matrix's translation, rotation, and scale settings as a Vector of three Vector3D objects.
     */
    Matrix3D.prototype.decompose = function (orientationStyle) {
        if (orientationStyle === void 0) { orientationStyle = "eulerAngles"; }
        var q;
        if (this._components == null)
            this._components = [new Vector3D(), new Vector3D(), new Vector3D(), new Vector3D()];
        var colX = new Vector3D(this._rawData[0], this._rawData[1], this._rawData[2]);
        var colY = new Vector3D(this._rawData[4], this._rawData[5], this._rawData[6]);
        var colZ = new Vector3D(this._rawData[8], this._rawData[9], this._rawData[10]);
        var scale = this._components[3];
        var skew = this._components[2];
        //compute X scale factor and normalise colX
        scale.x = colX.length;
        colX.scaleBy(1 / scale.x);
        //compute XY shear factor and make colY orthogonal to colX
        skew.x = colX.dotProduct(colY);
        colY = Vector3D.combine(colY, colX, 1, -skew.x);
        //compute Y scale factor and normalise colY
        scale.y = colY.length;
        colY.scaleBy(1 / scale.y);
        skew.x /= scale.y;
        //compute XZ and YZ shears and make colZ orthogonal to colX and colY
        skew.y = colX.dotProduct(colZ);
        colZ = Vector3D.combine(colZ, colX, 1, -skew.y);
        skew.z = colY.dotProduct(colZ);
        colZ = Vector3D.combine(colZ, colY, 1, -skew.z);
        //compute Z scale and normalise colZ
        scale.z = colZ.length;
        colZ.scaleBy(1 / scale.z);
        skew.y /= scale.z;
        skew.z /= scale.z;
        //at this point, the matrix (in cols) is orthonormal
        //check for a coordinate system flip. If the determinant is -1, negate the z scaling factor
        if (colX.dotProduct(colY.crossProduct(colZ)) < 0) {
            scale.z = -scale.z;
            colZ.x = -colZ.x;
            colZ.y = -colZ.y;
            colZ.z = -colZ.z;
        }
        var rot = this._components[1];
        switch (orientationStyle) {
            case Orientation3D.AXIS_ANGLE:
                rot.w = Math.acos((colX.x + colY.y + colZ.z - 1) / 2);
                var len = Math.sqrt((colY.z - colZ.y) * (colY.z - colZ.y) + (colZ.x - colX.z) * (colZ.x - colX.z) + (colX.y - colY.x) * (colX.y - colY.x));
                rot.x = (colY.z - colZ.y) / len;
                rot.y = (colZ.x - colX.z) / len;
                rot.z = (colX.y - colY.x) / len;
                break;
            case Orientation3D.QUATERNION:
                var tr = colX.x + colY.y + colZ.z;
                if (tr > 0) {
                    rot.w = Math.sqrt(1 + tr) / 2;
                    rot.x = (colY.z - colZ.y) / (4 * rot.w);
                    rot.y = (colZ.x - colX.z) / (4 * rot.w);
                    rot.z = (colX.y - colY.x) / (4 * rot.w);
                }
                else if ((colX.x > colY.y) && (colX.x > colZ.z)) {
                    rot.x = Math.sqrt(1 + colX.x - colY.y - colZ.z) / 2;
                    rot.w = (colY.z - colZ.y) / (4 * rot.x);
                    rot.y = (colX.y + colY.x) / (4 * rot.x);
                    rot.z = (colZ.x + colX.z) / (4 * rot.x);
                }
                else if (colY.y > colZ.z) {
                    rot.y = Math.sqrt(1 + colY.y - colX.x - colZ.z) / 2;
                    rot.x = (colX.y + colY.x) / (4 * rot.y);
                    rot.w = (colZ.x - colX.z) / (4 * rot.y);
                    rot.z = (colY.z + colZ.y) / (4 * rot.y);
                }
                else {
                    rot.z = Math.sqrt(1 + colZ.z - colX.x - colY.y) / 2;
                    rot.x = (colZ.x + colX.z) / (4 * rot.z);
                    rot.y = (colY.z + colZ.y) / (4 * rot.z);
                    rot.w = (colX.y - colY.x) / (4 * rot.z);
                }
                break;
            case Orientation3D.EULER_ANGLES:
                rot.y = Math.asin(-colX.z);
                //var cos:number = Math.cos(rot.y);
                if (colX.z != 1 && colX.z != -1) {
                    rot.x = Math.atan2(colY.z, colZ.z);
                    rot.z = Math.atan2(colX.y, colX.x);
                }
                else {
                    rot.z = 0;
                    rot.x = Math.atan2(colY.x, colY.y);
                }
                break;
        }
        this._components[0].copyFrom(this.position);
        return this._components;
    };
    /**
     * Uses the transformation matrix without its translation elements to transform a Vector3D object from one space
     * coordinate to another.
     */
    Matrix3D.prototype.deltaTransformVector = function (v, t) {
        if (t === void 0) { t = null; }
        var x = v.x;
        var y = v.y;
        var z = v.z;
        if (!t)
            t = new Vector3D();
        t.x = x * this._rawData[0] + y * this._rawData[4] + z * this._rawData[8];
        t.y = x * this._rawData[1] + y * this._rawData[5] + z * this._rawData[9];
        t.z = x * this._rawData[2] + y * this._rawData[6] + z * this._rawData[10];
        t.w = x * this._rawData[3] + y * this._rawData[7] + z * this._rawData[11];
        return t;
    };
    Matrix3D.prototype.deltaTransformVectors = function (vin, vout) {
        var rawData = this._rawData;
        var a = rawData[0];
        var e = rawData[1];
        var i = rawData[2];
        var m = rawData[3];
        var b = rawData[4];
        var f = rawData[5];
        var j = rawData[6];
        var n = rawData[7];
        var c = rawData[8];
        var g = rawData[9];
        var k = rawData[10];
        var o = rawData[11];
        var outIndex = 0;
        var length = vin.length;
        for (var index = 0; index < length; index += 3) {
            var x = vin[index];
            var y = vin[index + 1];
            var z = vin[index + 2];
            vout[outIndex++] = a * x + b * y + c * z;
            vout[outIndex++] = e * x + f * y + g * z;
            vout[outIndex++] = i * x + j * y + k * z;
        }
    };
    /**
     * Converts the current matrix to an identity or unit matrix.
     */
    Matrix3D.prototype.identity = function () {
        this._rawData[0] = 1;
        this._rawData[1] = 0;
        this._rawData[2] = 0;
        this._rawData[3] = 0;
        this._rawData[4] = 0;
        this._rawData[5] = 1;
        this._rawData[6] = 0;
        this._rawData[7] = 0;
        this._rawData[8] = 0;
        this._rawData[9] = 0;
        this._rawData[10] = 1;
        this._rawData[11] = 0;
        this._rawData[12] = 0;
        this._rawData[13] = 0;
        this._rawData[14] = 0;
        this._rawData[15] = 1;
        this._positionDirty = true;
    };
    /**
     * Inverts the current matrix.
     */
    Matrix3D.prototype.invert = function () {
        var d = this.determinant;
        var invertable = Math.abs(d) > 0.00000000001;
        if (invertable) {
            d = 1 / d;
            var m11 = this._rawData[0];
            var m12 = this._rawData[1];
            var m13 = this._rawData[2];
            var m14 = this._rawData[3];
            var m21 = this._rawData[4];
            var m22 = this._rawData[5];
            var m23 = this._rawData[6];
            var m24 = this._rawData[7];
            var m31 = this._rawData[8];
            var m32 = this._rawData[9];
            var m33 = this._rawData[10];
            var m34 = this._rawData[11];
            var m41 = this._rawData[12];
            var m42 = this._rawData[13];
            var m43 = this._rawData[14];
            var m44 = this._rawData[15];
            this._rawData[0] = d * (m22 * (m33 * m44 - m43 * m34) - m32 * (m23 * m44 - m43 * m24) + m42 * (m23 * m34 - m33 * m24));
            this._rawData[1] = -d * (m12 * (m33 * m44 - m43 * m34) - m32 * (m13 * m44 - m43 * m14) + m42 * (m13 * m34 - m33 * m14));
            this._rawData[2] = d * (m12 * (m23 * m44 - m43 * m24) - m22 * (m13 * m44 - m43 * m14) + m42 * (m13 * m24 - m23 * m14));
            this._rawData[3] = -d * (m12 * (m23 * m34 - m33 * m24) - m22 * (m13 * m34 - m33 * m14) + m32 * (m13 * m24 - m23 * m14));
            this._rawData[4] = -d * (m21 * (m33 * m44 - m43 * m34) - m31 * (m23 * m44 - m43 * m24) + m41 * (m23 * m34 - m33 * m24));
            this._rawData[5] = d * (m11 * (m33 * m44 - m43 * m34) - m31 * (m13 * m44 - m43 * m14) + m41 * (m13 * m34 - m33 * m14));
            this._rawData[6] = -d * (m11 * (m23 * m44 - m43 * m24) - m21 * (m13 * m44 - m43 * m14) + m41 * (m13 * m24 - m23 * m14));
            this._rawData[7] = d * (m11 * (m23 * m34 - m33 * m24) - m21 * (m13 * m34 - m33 * m14) + m31 * (m13 * m24 - m23 * m14));
            this._rawData[8] = d * (m21 * (m32 * m44 - m42 * m34) - m31 * (m22 * m44 - m42 * m24) + m41 * (m22 * m34 - m32 * m24));
            this._rawData[9] = -d * (m11 * (m32 * m44 - m42 * m34) - m31 * (m12 * m44 - m42 * m14) + m41 * (m12 * m34 - m32 * m14));
            this._rawData[10] = d * (m11 * (m22 * m44 - m42 * m24) - m21 * (m12 * m44 - m42 * m14) + m41 * (m12 * m24 - m22 * m14));
            this._rawData[11] = -d * (m11 * (m22 * m34 - m32 * m24) - m21 * (m12 * m34 - m32 * m14) + m31 * (m12 * m24 - m22 * m14));
            this._rawData[12] = -d * (m21 * (m32 * m43 - m42 * m33) - m31 * (m22 * m43 - m42 * m23) + m41 * (m22 * m33 - m32 * m23));
            this._rawData[13] = d * (m11 * (m32 * m43 - m42 * m33) - m31 * (m12 * m43 - m42 * m13) + m41 * (m12 * m33 - m32 * m13));
            this._rawData[14] = -d * (m11 * (m22 * m43 - m42 * m23) - m21 * (m12 * m43 - m42 * m13) + m41 * (m12 * m23 - m22 * m13));
            this._rawData[15] = d * (m11 * (m22 * m33 - m32 * m23) - m21 * (m12 * m33 - m32 * m13) + m31 * (m12 * m23 - m22 * m13));
        }
        this._positionDirty = true;
        return invertable;
    };
    Matrix3D.prototype.isIdentity = function () {
        if (this._rawData[0] == 1 &&
            this._rawData[1] == 0 &&
            this._rawData[2] == 0 &&
            this._rawData[3] == 0 &&
            this._rawData[4] == 0 &&
            this._rawData[5] == 1 &&
            this._rawData[6] == 0 &&
            this._rawData[7] == 0 &&
            this._rawData[8] == 0 &&
            this._rawData[9] == 0 &&
            this._rawData[10] == 1 &&
            this._rawData[11] == 0 &&
            this._rawData[12] == 0 &&
            this._rawData[13] == 0 &&
            this._rawData[14] == 0 &&
            this._rawData[15] == 1)
            return true;
        return false;
    };
    /**
     * Prepends a matrix by multiplying the current Matrix3D object by another Matrix3D object.
     */
    Matrix3D.prototype.prepend = function (rhs) {
        var m111 = rhs._rawData[0];
        var m112 = rhs._rawData[1];
        var m113 = rhs._rawData[2];
        var m114 = rhs._rawData[3];
        var m121 = rhs._rawData[4];
        var m122 = rhs._rawData[5];
        var m123 = rhs._rawData[6];
        var m124 = rhs._rawData[7];
        var m131 = rhs._rawData[8];
        var m132 = rhs._rawData[9];
        var m133 = rhs._rawData[10];
        var m134 = rhs._rawData[11];
        var m141 = rhs._rawData[12];
        var m142 = rhs._rawData[13];
        var m143 = rhs._rawData[14];
        var m144 = rhs._rawData[15];
        var m211 = this._rawData[0];
        var m212 = this._rawData[1];
        var m213 = this._rawData[2];
        var m214 = this._rawData[3];
        var m221 = this._rawData[4];
        var m222 = this._rawData[5];
        var m223 = this._rawData[6];
        var m224 = this._rawData[7];
        var m231 = this._rawData[8];
        var m232 = this._rawData[9];
        var m233 = this._rawData[10];
        var m234 = this._rawData[11];
        var m241 = this._rawData[12];
        var m242 = this._rawData[13];
        var m243 = this._rawData[14];
        var m244 = this._rawData[15];
        this._rawData[0] = m111 * m211 + m112 * m221 + m113 * m231 + m114 * m241;
        this._rawData[1] = m111 * m212 + m112 * m222 + m113 * m232 + m114 * m242;
        this._rawData[2] = m111 * m213 + m112 * m223 + m113 * m233 + m114 * m243;
        this._rawData[3] = m111 * m214 + m112 * m224 + m113 * m234 + m114 * m244;
        this._rawData[4] = m121 * m211 + m122 * m221 + m123 * m231 + m124 * m241;
        this._rawData[5] = m121 * m212 + m122 * m222 + m123 * m232 + m124 * m242;
        this._rawData[6] = m121 * m213 + m122 * m223 + m123 * m233 + m124 * m243;
        this._rawData[7] = m121 * m214 + m122 * m224 + m123 * m234 + m124 * m244;
        this._rawData[8] = m131 * m211 + m132 * m221 + m133 * m231 + m134 * m241;
        this._rawData[9] = m131 * m212 + m132 * m222 + m133 * m232 + m134 * m242;
        this._rawData[10] = m131 * m213 + m132 * m223 + m133 * m233 + m134 * m243;
        this._rawData[11] = m131 * m214 + m132 * m224 + m133 * m234 + m134 * m244;
        this._rawData[12] = m141 * m211 + m142 * m221 + m143 * m231 + m144 * m241;
        this._rawData[13] = m141 * m212 + m142 * m222 + m143 * m232 + m144 * m242;
        this._rawData[14] = m141 * m213 + m142 * m223 + m143 * m233 + m144 * m243;
        this._rawData[15] = m141 * m214 + m142 * m224 + m143 * m234 + m144 * m244;
        this._positionDirty = true;
    };
    /**
     * Prepends an incremental rotation to a Matrix3D object.
     */
    Matrix3D.prototype.prependRotation = function (degrees, axis) {
        this.prepend(Matrix3D.getAxisRotationMatrix(axis.x, axis.y, axis.z, degrees, Matrix3D._tempMatrix));
    };
    /**
     * Prepends an incremental scale change along the x, y, and z axes to a Matrix3D object.
     */
    Matrix3D.prototype.prependScale = function (xScale, yScale, zScale) {
        if (xScale == 1 && yScale == 1 && zScale == 1)
            return;
        var rawData = Matrix3D._tempMatrix._rawData;
        rawData[0] = xScale;
        rawData[1] = 0;
        rawData[2] = 0;
        rawData[3] = 0;
        rawData[4] = 0;
        rawData[5] = yScale;
        rawData[6] = 0;
        rawData[7] = 0;
        rawData[8] = 0;
        rawData[9] = 0;
        rawData[10] = zScale;
        rawData[11] = 0;
        rawData[12] = 0;
        rawData[13] = 0;
        rawData[14] = 0;
        rawData[15] = 1;
        this.prepend(Matrix3D._tempMatrix);
    };
    /**
     * Prepends an incremental translation, a repositioning along the x, y, and z axes, to a Matrix3D object.
     */
    Matrix3D.prototype.prependTranslation = function (x, y, z) {
        var rawData = Matrix3D._tempMatrix._rawData;
        rawData[0] = 1;
        rawData[1] = 0;
        rawData[2] = 0;
        rawData[3] = 0;
        rawData[4] = 0;
        rawData[5] = 1;
        rawData[6] = 0;
        rawData[7] = 0;
        rawData[8] = 0;
        rawData[9] = 0;
        rawData[10] = 1;
        rawData[11] = 0;
        rawData[12] = x;
        rawData[13] = y;
        rawData[14] = z;
        rawData[15] = 1;
        this.prepend(Matrix3D._tempMatrix);
    };
    // TODO orientationStyle
    /**
     * Sets the transformation matrix's translation, rotation, and scale settings.
     */
    Matrix3D.prototype.recompose = function (components) {
        var pos = components[0] || this.position;
        this.identity();
        var scale = components[3];
        if (scale && (scale.x != 1 || scale.y != 1 || scale.z != 1))
            this.appendScale(scale.x, scale.y, scale.z);
        var skew = components[2];
        if (skew && (skew.x != 0 || skew.y != 0 || skew.z != 0))
            this.appendSkew(skew.x, skew.y, skew.z);
        var sin;
        var cos;
        var rawData = Matrix3D._tempMatrix._rawData;
        rawData[12] = 0;
        rawData[13] = 0;
        rawData[14] = 0;
        rawData[15] = 0;
        var rotation = components[1];
        if (rotation) {
            var angle = -rotation.x;
            if (angle != 0) {
                sin = Math.sin(angle);
                cos = Math.cos(angle);
                rawData[0] = 1;
                rawData[1] = 0;
                rawData[2] = 0;
                rawData[3] = 0;
                rawData[4] = 0;
                rawData[5] = cos;
                rawData[6] = -sin;
                rawData[7] = 0;
                rawData[8] = 0;
                rawData[9] = sin;
                rawData[10] = cos;
                rawData[11] = 0;
                this.append(Matrix3D._tempMatrix);
            }
            angle = -rotation.y;
            if (angle != 0) {
                sin = Math.sin(angle);
                cos = Math.cos(angle);
                rawData[0] = cos;
                rawData[1] = 0;
                rawData[2] = sin;
                rawData[3] = 0;
                rawData[4] = 0;
                rawData[5] = 1;
                rawData[6] = 0;
                rawData[7] = 0;
                rawData[8] = -sin;
                rawData[9] = 0;
                rawData[10] = cos;
                rawData[11] = 0;
                this.append(Matrix3D._tempMatrix);
            }
            angle = -rotation.z;
            if (angle != 0) {
                sin = Math.sin(angle);
                cos = Math.cos(angle);
                rawData[0] = cos;
                rawData[1] = -sin;
                rawData[2] = 0;
                rawData[3] = 0;
                rawData[4] = sin;
                rawData[5] = cos;
                rawData[6] = 0;
                rawData[7] = 0;
                rawData[8] = 0;
                rawData[9] = 0;
                rawData[10] = 1;
                rawData[11] = 0;
                this.append(Matrix3D._tempMatrix);
            }
        }
        this._rawData[12] = pos.x;
        this._rawData[13] = pos.y;
        this._rawData[14] = pos.z;
        if (components[0])
            this._positionDirty = true;
        this._rawData[15] = 1;
        return true;
    };
    Matrix3D.prototype.reflect = function (plane) {
        var a = plane.a, b = plane.b, c = plane.c, d = plane.d;
        var ab2 = -2 * a * b;
        var ac2 = -2 * a * c;
        var bc2 = -2 * b * c;
        // reflection matrix
        var rawData = this._rawData;
        rawData[0] = 1 - 2 * a * a;
        rawData[4] = ab2;
        rawData[8] = ac2;
        rawData[12] = -2 * a * d;
        rawData[1] = ab2;
        rawData[5] = 1 - 2 * b * b;
        rawData[9] = bc2;
        rawData[13] = -2 * b * d;
        rawData[2] = ac2;
        rawData[6] = bc2;
        rawData[10] = 1 - 2 * c * c;
        rawData[14] = -2 * c * d;
        rawData[3] = 0;
        rawData[7] = 0;
        rawData[11] = 0;
        rawData[15] = 1;
        this._positionDirty = true;
    };
    Matrix3D.prototype.transformBox = function (box, target) {
        if (target === void 0) { target = null; }
        if (box == null)
            throw new ArgumentError("ArgumentError, box cannot be null");
        var minX, minY, minZ;
        var maxX, maxY, maxZ;
        maxX = box.width + (minX = box.x);
        maxY = box.height + (minY = box.y);
        maxZ = box.depth + (minZ = box.z);
        if (!target)
            target = new Box();
        var hx = box.width / 2;
        var hy = box.height / 2;
        var hz = box.depth / 2;
        var cx = box.x + hx;
        var cy = box.y + hy;
        var cz = box.z + hz;
        var m11 = this._rawData[0], m12 = this._rawData[4], m13 = this._rawData[8], m14 = this._rawData[12];
        var m21 = this._rawData[1], m22 = this._rawData[5], m23 = this._rawData[9], m24 = this._rawData[13];
        var m31 = this._rawData[2], m32 = this._rawData[6], m33 = this._rawData[10], m34 = this._rawData[14];
        var centerX = cx * m11 + cy * m12 + cz * m13 + m14;
        var centerY = cx * m21 + cy * m22 + cz * m23 + m24;
        var centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
        var halfExtentsX = Math.max(Math.abs(hx * m11 + hy * m12 + hz * m13), Math.abs(-hx * m11 + hy * m12 + hz * m13), Math.abs(hx * m11 - hy * m12 + hz * m13), Math.abs(hx * m11 + hy * m12 - hz * m13));
        var halfExtentsY = Math.max(Math.abs(hx * m21 + hy * m22 + hz * m23), Math.abs(-hx * m21 + hy * m22 + hz * m23), Math.abs(hx * m21 - hy * m22 + hz * m23), Math.abs(hx * m21 + hy * m22 - hz * m23));
        var halfExtentsZ = Math.max(Math.abs(hx * m31 + hy * m32 + hz * m33), Math.abs(-hx * m31 + hy * m32 + hz * m33), Math.abs(hx * m31 - hy * m32 + hz * m33), Math.abs(hx * m31 + hy * m32 - hz * m33));
        target.width = halfExtentsX * 2;
        target.height = halfExtentsY * 2;
        target.depth = halfExtentsZ * 2;
        target.x = centerX - halfExtentsX;
        target.y = centerY - halfExtentsY;
        target.z = centerZ - halfExtentsZ;
        return target;
    };
    Matrix3D.prototype.transformVector = function (vector, target) {
        if (target === void 0) { target = null; }
        if (vector == null)
            throw new ArgumentError("ArgumentError, vector cannot be null");
        var x = vector.x;
        var y = vector.y;
        var z = vector.z;
        var w = vector.w;
        if (!target)
            target = new Vector3D();
        target.x = x * this._rawData[0] + y * this._rawData[4] + z * this._rawData[8] + w * this._rawData[12];
        target.y = x * this._rawData[1] + y * this._rawData[5] + z * this._rawData[9] + w * this._rawData[13];
        target.z = x * this._rawData[2] + y * this._rawData[6] + z * this._rawData[10] + w * this._rawData[14];
        target.w = x * this._rawData[3] + y * this._rawData[7] + z * this._rawData[11] + w * this._rawData[15];
        return target;
    };
    /**
     * Uses the transformation matrix to transform a Vector of Numbers from one coordinate space to another.
     */
    Matrix3D.prototype.transformVectors = function (vin, vout) {
        var i = 0;
        var x = 0, y = 0, z = 0;
        while (i + 3 <= vin.length) {
            x = vin[i];
            y = vin[i + 1];
            z = vin[i + 2];
            vout[i] = x * this._rawData[0] + y * this._rawData[4] + z * this._rawData[8] + this._rawData[12];
            vout[i + 1] = x * this._rawData[1] + y * this._rawData[5] + z * this._rawData[9] + this._rawData[13];
            vout[i + 2] = x * this._rawData[2] + y * this._rawData[6] + z * this._rawData[10] + this._rawData[14];
            i += 3;
        }
    };
    /**
     * Converts the current Matrix3D object to a matrix where the rows and columns are swapped.
     */
    Matrix3D.prototype.transpose = function () {
        var rawData = Matrix3D._tempMatrix._rawData;
        this.copyRawDataTo(rawData, 0, true);
        this._rawData[1] = rawData[1];
        this._rawData[2] = rawData[2];
        this._rawData[3] = rawData[3];
        this._rawData[4] = rawData[4];
        this._rawData[6] = rawData[6];
        this._rawData[7] = rawData[7];
        this._rawData[8] = rawData[8];
        this._rawData[9] = rawData[9];
        this._rawData[11] = rawData[11];
        this._rawData[12] = rawData[12];
        this._rawData[13] = rawData[13];
        this._rawData[14] = rawData[14];
        this._positionDirty = true;
    };
    Matrix3D.prototype.invalidatePosition = function () {
        this._positionDirty = true;
    };
    Matrix3D.prototype.toFixed = function (decimalPlace) {
        var magnitude = Math.pow(10, decimalPlace);
        return "matrix3d(" + Math.round(this._rawData[0] * magnitude) / magnitude + "," + Math.round(this._rawData[1] * magnitude) / magnitude + "," + Math.round(this._rawData[2] * magnitude) / magnitude + "," + Math.round(this._rawData[3] * magnitude) / magnitude + "," + Math.round(this._rawData[4] * magnitude) / magnitude + "," + Math.round(this._rawData[5] * magnitude) / magnitude + "," + Math.round(this._rawData[6] * magnitude) / magnitude + "," + Math.round(this._rawData[7] * magnitude) / magnitude + "," + Math.round(this._rawData[8] * magnitude) / magnitude + "," + Math.round(this._rawData[9] * magnitude) / magnitude + "," + Math.round(this._rawData[10] * magnitude) / magnitude + "," + Math.round(this._rawData[11] * magnitude) / magnitude + "," + Math.round(this._rawData[12] * magnitude) / magnitude + "," + Math.round(this._rawData[13] * magnitude) / magnitude + "," + Math.round(this._rawData[14] * magnitude) / magnitude + "," + Math.round(this._rawData[15] * magnitude) / magnitude + ")";
    };
    Matrix3D.prototype.toString = function () {
        return "matrix3d(" + Math.round(this._rawData[0] * 1000) / 1000 + "," + Math.round(this._rawData[1] * 1000) / 1000 + "," + Math.round(this._rawData[2] * 1000) / 1000 + "," + Math.round(this._rawData[3] * 1000) / 1000 + "," + Math.round(this._rawData[4] * 1000) / 1000 + "," + Math.round(this._rawData[5] * 1000) / 1000 + "," + Math.round(this._rawData[6] * 1000) / 1000 + "," + Math.round(this._rawData[7] * 1000) / 1000 + "," + Math.round(this._rawData[8] * 1000) / 1000 + "," + Math.round(this._rawData[9] * 1000) / 1000 + "," + Math.round(this._rawData[10] * 1000) / 1000 + "," + Math.round(this._rawData[11] * 1000) / 1000 + "," + Math.round(this._rawData[12] * 1000) / 1000 + "," + Math.round(this._rawData[13] * 1000) / 1000 + "," + Math.round(this._rawData[14] * 1000) / 1000 + "," + Math.round(this._rawData[15] * 1000) / 1000 + ")";
    };
    return Matrix3D;
}());
/**
 * A reference to a Matrix3D to be used as a temporary data container, preventing object creation.
 */
Matrix3D.CALCULATION_MATRIX = new Matrix3D();
Matrix3D._tempMatrix = new Matrix3D();

var TransformEvent = (function (_super) {
    __extends(TransformEvent, _super);
    function TransformEvent(type, transform) {
        var _this = _super.call(this, type) || this;
        _this._transform = transform;
        return _this;
    }
    Object.defineProperty(TransformEvent.prototype, "transform", {
        /**
         *
         * @returns {Transform}
         */
        get: function () {
            return this._transform;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     * @return An exact duplicate of the current object.
     */
    TransformEvent.prototype.clone = function () {
        return new TransformEvent(this.type, this._transform);
    };
    return TransformEvent;
}(EventBase));
/**
 *
 */
TransformEvent.INVALIDATE_MATRIX3D = "invalidateMatrix3D";
/**
 *
 */
TransformEvent.INVALIDATE_CONCATENATED_MATRIX3D = "invalidateConcatenatedMatrix3D";
/**
 *
 */
TransformEvent.UPDATE_CONCATENATED_MATRIX3D = "updateConcatenatedMatrix3D";
/**
 *
 */
TransformEvent.INVALIDATE_COLOR_TRANSFORM = "invalidateColorTransform";

/**
 * The Transform class provides access to color adjustment properties and two-
 * or three-dimensional transformation objects that can be applied to a
 * display object. During the transformation, the color or the orientation and
 * position of a display object is adjusted(offset) from the current values
 * or coordinates to new values or coordinates. The Transform class also
 * collects data about color and two-dimensional matrix transformations that
 * are applied to a display object and all of its parent objects. You can
 * access these combined transformations through the
 * <code>concatenatedColorTransform</code> and <code>concatenatedMatrix</code>
 * properties.
 *
 * <p>To apply color transformations: create a ColorTransform object, set the
 * color adjustments using the object's methods and properties, and then
 * assign the <code>colorTransformation</code> property of the
 * <code>transform</code> property of the display object to the new
 * ColorTransformation object.</p>
 *
 * <p>To apply two-dimensional transformations: create a Matrix object, set
 * the matrix's two-dimensional transformation, and then assign the
 * <code>transform.matrix</code> property of the display object to the new
 * Matrix object.</p>
 *
 * <p>To apply three-dimensional transformations: start with a
 * three-dimensional display object. A three-dimensional display object has a
 * <code>z</code> property value other than zero. You do not need to create
 * the Matrix3D object. For all three-dimensional objects, a Matrix3D object
 * is created automatically when you assign a <code>z</code> value to a
 * display object. You can access the display object's Matrix3D object through
 * the display object's <code>transform</code> property. Using the methods of
 * the Matrix3D class, you can add to or modify the existing transformation
 * settings. Also, you can create a custom Matrix3D object, set the custom
 * Matrix3D object's transformation elements, and then assign the new Matrix3D
 * object to the display object using the <code>transform.matrix</code>
 * property.</p>
 *
 * <p>To modify a perspective projection of the stage or root object: use the
 * <code>transform.matrix</code> property of the root display object to gain
 * access to the PerspectiveProjection object. Or, apply different perspective
 * projection properties to a display object by setting the perspective
 * projection properties of the display object's parent. The child display
 * object inherits the new properties. Specifically, create a
 * PerspectiveProjection object and set its properties, then assign the
 * PerspectiveProjection object to the <code>perspectiveProjection</code>
 * property of the parent display object's <code>transform</code> property.
 * The specified projection transformation then applies to all the display
 * object's three-dimensional children.</p>
 *
 * <p>Since both PerspectiveProjection and Matrix3D objects perform
 * perspective transformations, do not assign both to a display object at the
 * same time. Use the PerspectiveProjection object for focal length and
 * projection center changes. For more control over the perspective
 * transformation, create a perspective projection Matrix3D object.</p>
 */
var Transform = (function (_super) {
    __extends(Transform, _super);
    function Transform(rawData, concatenatedMatrix3D) {
        if (rawData === void 0) { rawData = null; }
        if (concatenatedMatrix3D === void 0) { concatenatedMatrix3D = null; }
        var _this = _super.call(this) || this;
        _this._inverseConcatenatedMatrix3D = new Matrix3D();
        _this._rotation = new Vector3D();
        _this._skew = new Vector3D();
        _this._scale = new Vector3D(1, 1, 1);
        _this._rawData = rawData || new Float32Array(24);
        //create the view for matrix3D
        _this._matrix3D = new Matrix3D(new Float32Array(_this._rawData.buffer, 0, 16));
        //create the view for colorTransform
        _this._colorTransform = new ColorTransform(new Float32Array(_this._rawData.buffer, 64, 8));
        //create the concatenatedMatrix3D if required
        _this._concatenatedMatrix3D = concatenatedMatrix3D || _this._matrix3D;
        if (rawData == null) {
            _this._matrix3D.identity();
            _this._colorTransform.clear();
        }
        // Cached vector of transformation components used when
        // recomposing the transform matrix in updateTransform()
        _this._components = new Array(4);
        _this._components[1] = _this._rotation;
        _this._components[2] = _this._skew;
        _this._components[3] = _this._scale;
        _this.invalidateComponents();
        return _this;
    }
    Object.defineProperty(Transform.prototype, "backVector", {
        /**
         *
         */
        get: function () {
            if (!this._backVector)
                this._backVector = new Vector3D();
            this._matrix3D.copyColumnTo(2, this._backVector, true);
            return this._backVector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "colorTransform", {
        /**
         * A ColorTransform object containing values that universally adjust the
         * colors in the display object.
         *
         * @throws TypeError The colorTransform is null when being set
         */
        get: function () {
            return this._colorTransform;
        },
        set: function (val) {
            if (val) {
                var sourceData = val._rawData, targetData = this._colorTransform._rawData;
                targetData[0] = sourceData[0];
                targetData[1] = sourceData[1];
                targetData[2] = sourceData[2];
                targetData[3] = sourceData[3];
                targetData[4] = sourceData[4];
                targetData[5] = sourceData[5];
                targetData[6] = sourceData[6];
                targetData[7] = sourceData[7];
            }
            else {
                this._colorTransform.clear();
            }
            this.invalidateColorTransform();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "concatenatedMatrix3D", {
        /**
         * A Matrix object representing the combined transformation matrixes of the
         * display object and all of its parent objects, back to the root level. If
         * different transformation matrixes have been applied at different levels,
         * all of those matrixes are concatenated into one matrix for this property.
         * Also, for resizeable SWF content running in the browser, this property
         * factors in the difference between stage coordinates and window coordinates
         * due to window resizing. Thus, the property converts local coordinates to
         * window coordinates, which may not be the same coordinate space as that of
         * the Scene.
         */
        get: function () {
            if (this._concatenatedMatrix3DDirty) {
                this._concatenatedMatrix3DDirty = false;
                this.dispatchEvent(this._updateConcatenatedMatrix3D || (this._updateConcatenatedMatrix3D = new TransformEvent(TransformEvent.UPDATE_CONCATENATED_MATRIX3D, this)));
            }
            return this._concatenatedMatrix3D;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "inverseConcatenatedMatrix3D", {
        /**
         *
         */
        get: function () {
            if (this._inverseConcatenatedMatrix3DDirty) {
                this._inverseConcatenatedMatrix3DDirty = false;
                this._inverseConcatenatedMatrix3D.copyFrom(this.concatenatedMatrix3D);
                this._inverseConcatenatedMatrix3D.invert();
            }
            return this._inverseConcatenatedMatrix3D;
        },
        enumerable: true,
        configurable: true
    });
    Transform.prototype.append = function (value) {
        console.log("append not implemented yet in core/Transform");
    };
    Object.defineProperty(Transform.prototype, "downVector", {
        /**
         *
         */
        get: function () {
            if (!this._downVector)
                this._downVector = new Vector3D();
            this._matrix3D.copyColumnTo(1, this._downVector, true);
            return this._downVector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "forwardVector", {
        /**
         *
         */
        get: function () {
            if (!this._forwardVector)
                this._forwardVector = new Vector3D();
            this._matrix3D.copyColumnTo(2, this._forwardVector);
            return this._forwardVector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "leftVector", {
        /**
         *
         */
        get: function () {
            if (!this._leftVector)
                this._leftVector = new Vector3D();
            this._matrix3D.copyColumnTo(0, this._backVector, true);
            return this._leftVector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "matrix3D", {
        /**
         * Provides access to the Matrix3D object of a three-dimensional display
         * object. The Matrix3D object represents a transformation matrix that
         * determines the display object's position and orientation. A Matrix3D
         * object can also perform perspective projection.
         *
         * <p>If the <code>matrix</code> property is set to a value(not
         * <code>null</code>), the <code>matrix3D</code> property is
         * <code>null</code>. And if the <code>matrix3D</code> property is set to a
         * value(not <code>null</code>), the <code>matrix</code> property is
         * <code>null</code>.</p>
         */
        get: function () {
            if (this._matrix3DDirty)
                this.updateMatrix3D();
            return this._matrix3D;
        },
        set: function (val) {
            var sourceData = val._rawData, targetData = this._matrix3D._rawData;
            targetData[0] = sourceData[0];
            targetData[1] = sourceData[1];
            targetData[2] = sourceData[2];
            targetData[3] = sourceData[3];
            targetData[4] = sourceData[4];
            targetData[5] = sourceData[5];
            targetData[6] = sourceData[6];
            targetData[7] = sourceData[7];
            targetData[8] = sourceData[8];
            targetData[9] = sourceData[9];
            targetData[10] = sourceData[10];
            targetData[11] = sourceData[11];
            targetData[12] = sourceData[12];
            targetData[13] = sourceData[13];
            targetData[14] = sourceData[14];
            targetData[15] = sourceData[15];
            this.invalidateComponents();
            this.invalidateConcatenatedMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "pixelBounds", {
        /**
         * A Rectangle object that defines the bounding rectangle of the display
         * object on the stage.
         */
        get: function () {
            return this._pixelBounds;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "position", {
        /**
         * Defines the position of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         */
        get: function () {
            return this._matrix3D.position;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "rightVector", {
        /**
         *
         */
        get: function () {
            if (!this._rightVector)
                this._rightVector = new Vector3D();
            this._matrix3D.copyColumnTo(0, this._rightVector);
            return this._rightVector;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Transform.prototype, "rotation", {
        /**
         * Defines the rotation of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         */
        get: function () {
            if (this._componentsDirty)
                this._updateComponents();
            return this._rotation;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Rotates the 3d object directly to a euler angle
     *
     * @param    ax        The angle in degrees of the rotation around the x axis.
     * @param    ay        The angle in degrees of the rotation around the y axis.
     * @param    az        The angle in degrees of the rotation around the z axis.
     */
    Transform.prototype.rotateTo = function (ax, ay, az) {
        if (this._componentsDirty)
            this._updateComponents();
        this._rotation.x = ax;
        this._rotation.y = ay;
        this._rotation.z = az;
        this.invalidateMatrix3D();
    };
    Object.defineProperty(Transform.prototype, "scale", {
        /**
         * Defines the scale of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         */
        get: function () {
            if (this._componentsDirty)
                this._updateComponents();
            return this._scale;
        },
        enumerable: true,
        configurable: true
    });
    Transform.prototype.scaleTo = function (sx, sy, sz) {
        if (this._componentsDirty)
            this._updateComponents();
        this._scale.x = sx;
        this._scale.y = sy;
        this._scale.z = sz;
        this.invalidateMatrix3D();
    };
    Object.defineProperty(Transform.prototype, "skew", {
        /**
         * Defines the scale of the 3d object, relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
         */
        get: function () {
            if (this._componentsDirty)
                this._updateComponents();
            return this._skew;
        },
        enumerable: true,
        configurable: true
    });
    Transform.prototype.skewTo = function (sx, sy, sz) {
        if (this._componentsDirty)
            this._updateComponents();
        this._skew.x = sx;
        this._skew.y = sy;
        this._skew.z = sz;
        this.invalidateMatrix3D();
    };
    Object.defineProperty(Transform.prototype, "upVector", {
        /**
         *
         */
        get: function () {
            if (!this._upVector)
                this._upVector = new Vector3D();
            this._matrix3D.copyColumnTo(1, this._upVector);
            return this._upVector;
        },
        enumerable: true,
        configurable: true
    });
    Transform.prototype.copyRawDataTo = function (transform) {
        if (this._matrix3DDirty)
            this.updateMatrix3D();
        var targetData = transform._rawData;
        var sourceData = this._rawData;
        //Matrix3D data
        targetData[0] = sourceData[0];
        targetData[1] = sourceData[1];
        targetData[2] = sourceData[2];
        targetData[3] = sourceData[3];
        targetData[4] = sourceData[4];
        targetData[5] = sourceData[5];
        targetData[6] = sourceData[6];
        targetData[7] = sourceData[7];
        targetData[8] = sourceData[8];
        targetData[9] = sourceData[9];
        targetData[10] = sourceData[10];
        targetData[11] = sourceData[11];
        targetData[12] = sourceData[12];
        targetData[13] = sourceData[13];
        targetData[14] = sourceData[14];
        targetData[15] = sourceData[15];
        //ColorTransform data
        targetData[16] = sourceData[16];
        targetData[17] = sourceData[17];
        targetData[18] = sourceData[18];
        targetData[19] = sourceData[19];
        targetData[20] = sourceData[20];
        targetData[21] = sourceData[21];
        targetData[22] = sourceData[22];
        targetData[23] = sourceData[23];
        this.invalidateComponents();
        this.invalidateColorTransform();
    };
    Transform.prototype.clone = function () {
        var transform = new Transform();
        this.copyRawDataTo(transform);
        return transform;
    };
    Transform.prototype.dispose = function () {
    };
    /**
     * Moves the 3d object forwards along it's local z axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveForward = function (distance) {
        this.translateLocal(Vector3D.Z_AXIS, distance);
    };
    /**
     * Moves the 3d object backwards along it's local z axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveBackward = function (distance) {
        this.translateLocal(Vector3D.Z_AXIS, -distance);
    };
    /**
     * Moves the 3d object backwards along it's local x axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveLeft = function (distance) {
        this.translateLocal(Vector3D.X_AXIS, -distance);
    };
    /**
     * Moves the 3d object forwards along it's local x axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveRight = function (distance) {
        this.translateLocal(Vector3D.X_AXIS, distance);
    };
    /**
     * Moves the 3d object forwards along it's local y axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveUp = function (distance) {
        this.translateLocal(Vector3D.Y_AXIS, distance);
    };
    /**
     * Moves the 3d object backwards along it's local y axis
     *
     * @param    distance    The length of the movement
     */
    Transform.prototype.moveDown = function (distance) {
        this.translateLocal(Vector3D.Y_AXIS, -distance);
    };
    /**
     * Moves the 3d object directly to a point in space
     *
     * @param    dx        The amount of movement along the local x axis.
     * @param    dy        The amount of movement along the local y axis.
     * @param    dz        The amount of movement along the local z axis.
     */
    Transform.prototype.moveTo = function (dx, dy, dz) {
        this._matrix3D._rawData[12] = dx;
        this._matrix3D._rawData[13] = dy;
        this._matrix3D._rawData[14] = dz;
        this.invalidatePosition();
    };
    /**
     * Rotates the 3d object around it's local x-axis
     *
     * @param    angle        The amount of rotation in degrees
     */
    Transform.prototype.pitch = function (angle) {
        this.rotate(Vector3D.X_AXIS, angle);
    };
    /**
     * Rotates the 3d object around it's local z-axis
     *
     * @param    angle        The amount of rotation in degrees
     */
    Transform.prototype.roll = function (angle) {
        this.rotate(Vector3D.Z_AXIS, angle);
    };
    /**
     * Rotates the 3d object around it's local y-axis
     *
     * @param    angle        The amount of rotation in degrees
     */
    Transform.prototype.yaw = function (angle) {
        this.rotate(Vector3D.Y_AXIS, angle);
    };
    /**
     * Rotates the 3d object around an axis by a defined angle
     *
     * @param    axis        The vector defining the axis of rotation
     * @param    angle        The amount of rotation in degrees
     */
    Transform.prototype.rotate = function (axis, angle) {
        this.matrix3D.prependRotation(angle, axis);
        this.invalidateComponents();
    };
    /**
     * Moves the 3d object along a vector by a defined length
     *
     * @param    axis        The vector defining the axis of movement
     * @param    distance    The length of the movement
     */
    Transform.prototype.translate = function (axis, distance) {
        var x = axis.x, y = axis.y, z = axis.z;
        var len = distance / Math.sqrt(x * x + y * y + z * z);
        this.matrix3D.appendTranslation(x * len, y * len, z * len);
        this.invalidatePosition();
    };
    /**
     * Moves the 3d object along a vector by a defined length
     *
     * @param    axis        The vector defining the axis of movement
     * @param    distance    The length of the movement
     */
    Transform.prototype.translateLocal = function (axis, distance) {
        var x = axis.x, y = axis.y, z = axis.z;
        var len = distance / Math.sqrt(x * x + y * y + z * z);
        this.matrix3D.prependTranslation(x * len, y * len, z * len);
        this.invalidatePosition();
    };
    Transform.prototype.clearMatrix3D = function () {
        this._matrix3D.identity();
        this.invalidateComponents();
    };
    Transform.prototype.clearColorTransform = function () {
        if (!this._colorTransform)
            return;
        this._colorTransform.clear();
        this.invalidateColorTransform();
    };
    /**
     * Invalidates the 3D transformation matrix, causing it to be updated upon the next request
     *
     * @private
     */
    Transform.prototype.invalidateMatrix3D = function () {
        this._matrix3DDirty = true;
        this.dispatchEvent(this._invalidateMatrix3D || (this._invalidateMatrix3D = new TransformEvent(TransformEvent.INVALIDATE_MATRIX3D, this)));
    };
    Transform.prototype.invalidateComponents = function () {
        this.invalidatePosition();
        this._componentsDirty = true;
    };
    Transform.prototype.invalidateConcatenatedMatrix3D = function () {
        this._concatenatedMatrix3DDirty = true;
        this._inverseConcatenatedMatrix3DDirty = true;
        this.dispatchEvent(this._invalidateConcatenatedMatrix3D || (this._invalidateConcatenatedMatrix3D = new TransformEvent(TransformEvent.INVALIDATE_CONCATENATED_MATRIX3D, this)));
    };
    /**
     *
     */
    Transform.prototype.invalidatePosition = function () {
        this._matrix3D.invalidatePosition();
        this.dispatchEvent(this._invalidateMatrix3D || (this._invalidateMatrix3D = new TransformEvent(TransformEvent.INVALIDATE_MATRIX3D, this)));
    };
    Transform.prototype.invalidateColorTransform = function () {
        this.dispatchEvent(this._invalidateColorTransform || (this._invalidateColorTransform = new TransformEvent(TransformEvent.INVALIDATE_COLOR_TRANSFORM, this)));
    };
    /**
     *
     */
    Transform.prototype.updateMatrix3D = function () {
        this._matrix3D.recompose(this._components);
        this._matrix3DDirty = false;
    };
    Transform.prototype._updateComponents = function () {
        var elements = this._matrix3D.decompose();
        var vec;
        vec = elements[1];
        this._rotation.x = vec.x;
        this._rotation.y = vec.y;
        this._rotation.z = vec.z;
        vec = elements[2];
        this._skew.x = vec.x;
        this._skew.y = vec.y;
        this._skew.z = vec.z;
        vec = elements[3];
        this._scale.x = vec.x;
        this._scale.y = vec.y;
        this._scale.z = vec.z;
        this._componentsDirty = false;
    };
    return Transform;
}(EventDispatcher));

var DocumentError = (function (_super) {
    __extends(DocumentError, _super);
    function DocumentError(message, id) {
        if (message === void 0) { message = "DocumentError"; }
        if (id === void 0) { id = 0; }
        return _super.call(this, message, id) || this;
    }
    return DocumentError;
}(ErrorBase));
DocumentError.DOCUMENT_DOES_NOT_EXIST = "documentDoesNotExist";

/**
 * AbstractMethodError is thrown when an abstract method is called. The method in question should be overridden
 * by a concrete subclass.
 */
var PartialImplementationError = (function (_super) {
    __extends(PartialImplementationError, _super);
    /**
     * Create a new AbstractMethodError.
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function PartialImplementationError(dependency, id) {
        if (dependency === void 0) { dependency = ''; }
        if (id === void 0) { id = 0; }
        return _super.call(this, "PartialImplementationError - this function is in development. Required Dependency: " + dependency, id) || this;
    }
    return PartialImplementationError;
}(ErrorBase));

/**
 * RangeError is thrown when an index is accessed out of range of the number of
 * available indices on an Array.
 */
var RangeError = (function (_super) {
    __extends(RangeError, _super);
    /**
     * Create a new RangeError.
     *
     * @param message An optional message to override the default error message.
     * @param id The id of the error.
     */
    function RangeError(message, id) {
        if (message === void 0) { message = null; }
        if (id === void 0) { id = 0; }
        return _super.call(this, message || "RangeError", id) || this;
    }
    return RangeError;
}(ErrorBase));

var LoaderEvent = (function (_super) {
    __extends(LoaderEvent, _super);
    /**
     * Create a new LoaderEvent object.
     *
     * @param type The event type.
     * @param url The url of the loaded resource.
     * @param assets The assets of the loaded resource.
     */
    function LoaderEvent(type, url, content, assets) {
        if (url === void 0) { url = null; }
        if (content === void 0) { content = null; }
        if (assets === void 0) { assets = null; }
        var _this = _super.call(this, type) || this;
        _this._url = url;
        _this._content = content;
        _this._assets = assets;
        return _this;
    }
    Object.defineProperty(LoaderEvent.prototype, "content", {
        /**
         * The content returned if the resource has been loaded inside a <code>Loader</code> object.
         */
        get: function () {
            return this._content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderEvent.prototype, "url", {
        /**
         * The url of the loaded resource.
         */
        get: function () {
            return this._url;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderEvent.prototype, "assets", {
        /**
         * The error string on loadError.
         */
        get: function () {
            return this._assets;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the current event.
     * @return An exact duplicate of the current event.
     */
    LoaderEvent.prototype.clone = function () {
        return new LoaderEvent(this.type, this._url, this._content, this._assets);
    };
    return LoaderEvent;
}(EventBase));
/**
 * Dispatched when the loading of a session and all of its dependencies is complete.
 */
LoaderEvent.LOAD_COMPLETE = "loadComplete";

var ParserEvent = (function (_super) {
    __extends(ParserEvent, _super);
    function ParserEvent(type, message) {
        if (message === void 0) { message = ''; }
        var _this = _super.call(this, type) || this;
        _this._message = message;
        return _this;
    }
    Object.defineProperty(ParserEvent.prototype, "message", {
        /**
         * Additional human-readable message. Usually supplied for ParserEvent.PARSE_ERROR events.
         */
        get: function () {
            return this._message;
        },
        enumerable: true,
        configurable: true
    });
    ParserEvent.prototype.clone = function () {
        return new ParserEvent(this.type, this._message);
    };
    return ParserEvent;
}(EventBase));
/**
 * Dispatched when parsing of an asset completed.
 */
ParserEvent.PARSE_COMPLETE = 'parseComplete';
/**
 * Dispatched when an error occurs while parsing the data (e.g. because it's
 * incorrectly formatted.)
 */
ParserEvent.PARSE_ERROR = 'parseError';
/**
 * Dispatched when a parser is ready to have dependencies retrieved and resolved.
 * This is an internal event that should rarely (if ever) be listened for by
 * external classes.
 */
ParserEvent.READY_FOR_DEPENDENCIES = 'readyForDependencies';

var ProjectionEvent = (function (_super) {
    __extends(ProjectionEvent, _super);
    function ProjectionEvent(type, projection) {
        var _this = _super.call(this, type) || this;
        _this._projection = projection;
        return _this;
    }
    Object.defineProperty(ProjectionEvent.prototype, "projection", {
        get: function () {
            return this._projection;
        },
        enumerable: true,
        configurable: true
    });
    return ProjectionEvent;
}(EventBase));
ProjectionEvent.MATRIX_CHANGED = "matrixChanged";

var TimerEvent = (function (_super) {
    __extends(TimerEvent, _super);
    function TimerEvent(type) {
        return _super.call(this, type) || this;
    }
    return TimerEvent;
}(EventBase));
/**
 *
 */
TimerEvent.TIMER = "timer";
/**
 *
 */
TimerEvent.TIMER_COMPLETE = "timerComplete";

var URLLoaderEvent = (function (_super) {
    __extends(URLLoaderEvent, _super);
    function URLLoaderEvent(type, urlLoader) {
        var _this = _super.call(this, type) || this;
        _this._urlLoader = urlLoader;
        return _this;
    }
    Object.defineProperty(URLLoaderEvent.prototype, "urlLoader", {
        /**
         *
         */
        get: function () {
            return this._urlLoader;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    URLLoaderEvent.prototype.clone = function () {
        return new URLLoaderEvent(this.type, this._urlLoader);
    };
    return URLLoaderEvent;
}(EventBase));
URLLoaderEvent.HTTP_STATUS = "httpStatus";
URLLoaderEvent.LOAD_ERROR = "loadError";
URLLoaderEvent.LOAD_PROGRESS = "loadProgress";
URLLoaderEvent.LOAD_START = "loadStart";
URLLoaderEvent.LOAD_COMPLETE = "loadComplete";

/**
 * The Point object represents a location in a two-dimensional coordinate
 * system, where <i>x</i> represents the horizontal axis and <i>y</i>
 * represents the vertical axis.
 *
 * <p>The following code creates a point at(0,0):</p>
 *
 * <p>Methods and properties of the following classes use Point objects:</p>
 *
 * <ul>
 *   <li>BitmapData</li>
 *   <li>DisplayObject</li>
 *   <li>DisplayObjectContainer</li>
 *   <li>DisplacementMapFilter</li>
 *   <li>NativeWindow</li>
 *   <li>Matrix</li>
 *   <li>Rectangle</li>
 * </ul>
 *
 * <p>You can use the <code>new Point()</code> constructor to create a Point
 * object.</p>
 */
var Point = (function () {
    /**
     * Creates a new point. If you pass no parameters to this method, a point is
     * created at(0,0).
     *
     * @param x The horizontal coordinate.
     * @param y The vertical coordinate.
     */
    function Point(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.x = x;
        this.y = y;
    }
    Object.defineProperty(Point.prototype, "length", {
        /**
         * The length of the line segment from(0,0) to this point.
         */
        get: function () {
            return Math.sqrt(this.x * this.x + this.y * this.y);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds the coordinates of another point to the coordinates of this point to
     * create a new point.
     *
     * @param v The point to be added.
     * @return The new point.
     */
    Point.prototype.add = function (v) {
        return new Point(this.x + v.x, this.y + v.y);
    };
    /**
     * Creates a copy of this Point object.
     *
     * @return The new Point object.
     */
    Point.prototype.clone = function () {
        return new Point(this.x, this.y);
    };
    Point.prototype.copyFrom = function (sourcePoint) {
    };
    /**
     * Determines whether two points are equal. Two points are equal if they have
     * the same <i>x</i> and <i>y</i> values.
     *
     * @param toCompare The point to be compared.
     * @return A value of <code>true</code> if the object is equal to this Point
     *         object; <code>false</code> if it is not equal.
     */
    Point.prototype.equals = function (toCompare) {
        return (this.x == toCompare.x && this.y == toCompare.y);
    };
    /**
     * Scales the line segment between(0,0) and the current point to a set
     * length.
     *
     * @param thickness The scaling value. For example, if the current point is
     *                 (0,5), and you normalize it to 1, the point returned is
     *                  at(0,1).
     */
    Point.prototype.normalize = function (thickness) {
        if (thickness === void 0) { thickness = 1; }
        var len = this.length;
        if (len) {
            var invLength = thickness / len;
            this.x *= invLength;
            this.y *= invLength;
        }
    };
    /**
     * Offsets the Point object by the specified amount. The value of
     * <code>dx</code> is added to the original value of <i>x</i> to create the
     * new <i>x</i> value. The value of <code>dy</code> is added to the original
     * value of <i>y</i> to create the new <i>y</i> value.
     *
     * @param dx The amount by which to offset the horizontal coordinate,
     *           <i>x</i>.
     * @param dy The amount by which to offset the vertical coordinate, <i>y</i>.
     */
    Point.prototype.offset = function (dx, dy) {
        this.x += dx;
        this.y += dy;
    };
    Point.prototype.setTo = function (xa, ya) {
        this.x = xa;
        this.y = ya;
    };
    /**
     * Subtracts the coordinates of another point from the coordinates of this
     * point to create a new point.
     *
     * @param v The point to be subtracted.
     * @return The new point.
     */
    Point.prototype.subtract = function (v) {
        return new Point(this.x - v.x, this.y - v.y);
    };
    /**
     * Returns a string that contains the values of the <i>x</i> and <i>y</i>
     * coordinates. The string has the form <code>"(x=<i>x</i>,
     * y=<i>y</i>)"</code>, so calling the <code>toString()</code> method for a
     * point at 23,17 would return <code>"(x=23, y=17)"</code>.
     *
     * @return The string representation of the coordinates.
     */
    Point.prototype.toString = function () {
        return "[Point] (x=" + this.x + ", y=" + this.y + ")";
    };
    /**
     * Returns the distance between <code>pt1</code> and <code>pt2</code>.
     *
     * @param pt1 The first point.
     * @param pt2 The second point.
     * @return The distance between the first and second points.
     */
    Point.distance = function (pt1, pt2) {
        var dx = pt2.x - pt1.x;
        var dy = pt2.y - pt1.y;
        return Math.sqrt(dx * dx + dy * dy);
    };
    /**
     * Determines a point between two specified points. The parameter
     * <code>f</code> determines where the new interpolated point is located
     * relative to the two end points specified by parameters <code>pt1</code>
     * and <code>pt2</code>. The closer the value of the parameter <code>f</code>
     * is to <code>1.0</code>, the closer the interpolated point is to the first
     * point(parameter <code>pt1</code>). The closer the value of the parameter
     * <code>f</code> is to 0, the closer the interpolated point is to the second
     * point(parameter <code>pt2</code>).
     *
     * @param pt1 The first point.
     * @param pt2 The second point.
     * @param f   The level of interpolation between the two points. Indicates
     *            where the new point will be, along the line between
     *            <code>pt1</code> and <code>pt2</code>. If <code>f</code>=1,
     *            <code>pt1</code> is returned; if <code>f</code>=0,
     *            <code>pt2</code> is returned.
     * @return The new, interpolated point.
     */
    Point.interpolate = function (pt1, pt2, f) {
        return new Point(pt2.x + (pt1.x - pt2.x) * f, pt2.y + (pt1.y - pt2.y) * f);
    };
    /**
     * Converts a pair of polar coordinates to a Cartesian point coordinate.
     *
     * @param len   The length coordinate of the polar pair.
     * @param angle The angle, in radians, of the polar pair.
     * @return The Cartesian point.
     */
    Point.polar = function (len, angle) {
        return new Point(len * Math.cos(angle), len * Math.sin(angle));
    };
    return Point;
}());

/**
 * The Matrix export class represents a transformation matrix that determines how to
 * map points from one coordinate space to another. You can perform various
 * graphical transformations on a display object by setting the properties of
 * a Matrix object, applying that Matrix object to the <code>matrix</code>
 * property of a Transform object, and then applying that Transform object as
 * the <code>transform</code> property of the display object. These
 * transformation functions include translation(<i>x</i> and <i>y</i>
 * repositioning), rotation, scaling, and skewing.
 *
 * <p>Together these types of transformations are known as <i>affine
 * transformations</i>. Affine transformations preserve the straightness of
 * lines while transforming, so that parallel lines stay parallel.</p>
 *
 * <p>To apply a transformation matrix to a display object, you create a
 * Transform object, set its <code>matrix</code> property to the
 * transformation matrix, and then set the <code>transform</code> property of
 * the display object to the Transform object. Matrix objects are also used as
 * parameters of some methods, such as the following:</p>
 *
 * <ul>
 *   <li>The <code>draw()</code> method of a BitmapData object</li>
 *   <li>The <code>beginBitmapFill()</code> method,
 * <code>beginGradientFill()</code> method, or
 * <code>lineGradientStyle()</code> method of a Graphics object</li>
 * </ul>
 *
 * <p>A transformation matrix object is a 3 x 3 matrix with the following
 * contents:</p>
 *
 * <p>In traditional transformation matrixes, the <code>u</code>,
 * <code>v</code>, and <code>w</code> properties provide extra capabilities.
 * The Matrix export class can only operate in two-dimensional space, so it always
 * assumes that the property values <code>u</code> and <code>v</code> are 0.0,
 * and that the property value <code>w</code> is 1.0. The effective values of
 * the matrix are as follows:</p>
 *
 * <p>You can get and set the values of all six of the other properties in a
 * Matrix object: <code>a</code>, <code>b</code>, <code>c</code>,
 * <code>d</code>, <code>tx</code>, and <code>ty</code>.</p>
 *
 * <p>The Matrix export class supports the four major types of transformations:
 * translation, scaling, rotation, and skewing. You can set three of these
 * transformations by using specialized methods, as described in the following
 * table: </p>
 *
 * <p>Each transformation function alters the current matrix properties so
 * that you can effectively combine multiple transformations. To do this, you
 * call more than one transformation function before applying the matrix to
 * its display object target(by using the <code>transform</code> property of
 * that display object).</p>
 *
 * <p>Use the <code>new Matrix()</code> constructor to create a Matrix object
 * before you can call the methods of the Matrix object.</p>
 */
var Matrix = (function () {
    function Matrix(a, b, c, d, tx, ty) {
        if (a === void 0) { a = 1; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 1; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.rawData = new Float32Array(6);
        if (a instanceof Float32Array) {
            this.copyRawDataFrom(a);
        }
        else {
            this.a = Number(a);
            this.b = b;
            this.c = c;
            this.d = d;
            this.tx = tx;
            this.ty = ty;
        }
    }
    Object.defineProperty(Matrix.prototype, "a", {
        /**
         * The value that affects the positioning of pixels along the <i>x</i> axis
         * when scaling or rotating an image.
         */
        get: function () {
            return this.rawData[0];
        },
        set: function (value) {
            this.rawData[0] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "b", {
        /**
         * The value that affects the positioning of pixels along the <i>y</i> axis
         * when rotating or skewing an image.
         */
        get: function () {
            return this.rawData[2];
        },
        set: function (value) {
            this.rawData[2] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "c", {
        /**
         * The value that affects the positioning of pixels along the <i>x</i> axis
         * when rotating or skewing an image.
         */
        get: function () {
            return this.rawData[1];
        },
        set: function (value) {
            this.rawData[1] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "d", {
        /**
         * The value that affects the positioning of pixels along the <i>y</i> axis
         * when scaling or rotating an image.
         */
        get: function () {
            return this.rawData[3];
        },
        set: function (value) {
            this.rawData[3] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "tx", {
        /**
         * The distance by which to translate each point along the <i>x</i> axis.
         */
        get: function () {
            return this.rawData[4];
        },
        set: function (value) {
            this.rawData[4] = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Matrix.prototype, "ty", {
        /**
         * The distance by which to translate each point along the <i>y</i> axis.
         */
        get: function () {
            return this.rawData[5];
        },
        set: function (value) {
            this.rawData[5] = value;
        },
        enumerable: true,
        configurable: true
    });
    Matrix.prototype.copyRawDataFrom = function (vector, index) {
        if (index === void 0) { index = 0; }
        for (var c = 0; c < 6; c++)
            this.rawData[c] = vector[c + index];
    };
    /**
     * Returns a new Matrix object that is a clone of this matrix, with an exact
     * copy of the contained object.
     *
     * @return A Matrix object.
     */
    Matrix.prototype.clone = function () {
        return new Matrix(this.a, this.b, this.c, this.d, this.tx, this.ty);
    };
    /**
     * Concatenates a matrix with the current matrix, effectively combining the
     * geometric effects of the two. In mathematical terms, concatenating two
     * matrixes is the same as combining them using matrix multiplication.
     *
     * <p>For example, if matrix <code>m1</code> scales an object by a factor of
     * four, and matrix <code>m2</code> rotates an object by 1.5707963267949
     * radians(<code>Math.PI/2</code>), then <code>m1.concat(m2)</code>
     * transforms <code>m1</code> into a matrix that scales an object by a factor
     * of four and rotates the object by <code>Math.PI/2</code> radians. </p>
     *
     * <p>This method replaces the source matrix with the concatenated matrix. If
     * you want to concatenate two matrixes without altering either of the two
     * source matrixes, first copy the source matrix by using the
     * <code>clone()</code> method, as shown in the Class Examples section.</p>
     *
     * @param matrix The matrix to be concatenated to the source matrix.
     */
    Matrix.prototype.concat = function (matrix) {
        var a1 = this.a * matrix.a + this.b * matrix.c;
        this.b = this.a * matrix.b + this.b * matrix.d;
        this.a = a1;
        var c1 = this.c * matrix.a + this.d * matrix.c;
        this.d = this.c * matrix.b + this.d * matrix.d;
        this.c = c1;
        var tx1 = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
        this.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
        this.tx = tx1;
    };
    /**
     * Copies a Vector3D object into specific column of the calling Matrix3D
     * object.
     *
     * @param column   The column from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyColumnFrom = function (column, vector3D) {
        if (column > 2) {
            throw "Column " + column + " out of bounds (2)";
        }
        else if (column == 0) {
            this.a = vector3D.x;
            this.c = vector3D.y;
        }
        else if (column == 1) {
            this.b = vector3D.x;
            this.d = vector3D.y;
        }
        else {
            this.tx = vector3D.x;
            this.ty = vector3D.y;
        }
    };
    /**
     * Copies specific column of the calling Matrix object into the Vector3D
     * object. The w element of the Vector3D object will not be changed.
     *
     * @param column   The column from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyColumnTo = function (column, vector3D) {
        if (column > 2) {
            throw new ArgumentError("ArgumentError, Column " + column + " out of bounds [0, ..., 2]");
        }
        else if (column == 0) {
            vector3D.x = this.a;
            vector3D.y = this.c;
            vector3D.z = 0;
        }
        else if (column == 1) {
            vector3D.x = this.b;
            vector3D.y = this.d;
            vector3D.z = 0;
        }
        else {
            vector3D.x = this.tx;
            vector3D.y = this.ty;
            vector3D.z = 1;
        }
    };
    /**
     * Copies all of the matrix data from the source Point object into the
     * calling Matrix object.
     *
     * @param sourceMatrix The Matrix object from which to copy the data.
     */
    Matrix.prototype.copyFrom = function (sourceMatrix) {
        this.a = sourceMatrix.a;
        this.b = sourceMatrix.b;
        this.c = sourceMatrix.c;
        this.d = sourceMatrix.d;
        this.tx = sourceMatrix.tx;
        this.ty = sourceMatrix.ty;
    };
    /**
     * Copies a Vector3D object into specific row of the calling Matrix object.
     *
     * @param row      The row from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyRowFrom = function (row, vector3D) {
        if (row > 2) {
            throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
        }
        else if (row == 0) {
            this.a = vector3D.x;
            this.c = vector3D.y;
        }
        else if (row == 1) {
            this.b = vector3D.x;
            this.d = vector3D.y;
        }
        else {
            this.tx = vector3D.x;
            this.ty = vector3D.y;
        }
    };
    /**
     * Copies specific row of the calling Matrix object into the Vector3D object.
     * The w element of the Vector3D object will not be changed.
     *
     * @param row      The row from which to copy the data from.
     * @param vector3D The Vector3D object from which to copy the data.
     */
    Matrix.prototype.copyRowTo = function (row, vector3D) {
        if (row > 2) {
            throw new ArgumentError("ArgumentError, Row " + row + " out of bounds [0, ..., 2]");
        }
        else if (row == 0) {
            vector3D.x = this.a;
            vector3D.y = this.b;
            vector3D.z = this.tx;
        }
        else if (row == 1) {
            vector3D.x = this.c;
            vector3D.y = this.d;
            vector3D.z = this.ty;
        }
        else {
            vector3D.setTo(0, 0, 1);
        }
    };
    /**
     * Includes parameters for scaling, rotation, and translation. When applied
     * to a matrix it sets the matrix's values based on those parameters.
     *
     * <p>Using the <code>createBox()</code> method lets you obtain the same
     * matrix as you would if you applied the <code>identity()</code>,
     * <code>rotate()</code>, <code>scale()</code>, and <code>translate()</code>
     * methods in succession. For example, <code>mat1.createBox(2,2,Math.PI/4,
     * 100, 100)</code> has the same effect as the following:</p>
     *
     * @param scaleX   The factor by which to scale horizontally.
     * @param scaleY   The factor by which scale vertically.
     * @param rotation The amount to rotate, in radians.
     * @param tx       The number of pixels to translate(move) to the right
     *                 along the <i>x</i> axis.
     * @param ty       The number of pixels to translate(move) down along the
     *                 <i>y</i> axis.
     */
    Matrix.prototype.createBox = function (scaleX, scaleY, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = scaleX;
        this.d = scaleY;
        this.b = rotation;
        this.tx = tx;
        this.ty = ty;
    };
    /**
     * Creates the specific style of matrix expected by the
     * <code>beginGradientFill()</code> and <code>lineGradientStyle()</code>
     * methods of the Graphics class. Width and height are scaled to a
     * <code>scaleX</code>/<code>scaleY</code> pair and the
     * <code>tx</code>/<code>ty</code> values are offset by half the width and
     * height.
     *
     * <p>For example, consider a gradient with the following
     * characteristics:</p>
     *
     * <ul>
     *   <li><code>GradientType.LINEAR</code></li>
     *   <li>Two colors, green and blue, with the ratios array set to <code>[0,
     * 255]</code></li>
     *   <li><code>SpreadMethod.PAD</code></li>
     *   <li><code>InterpolationMethod.LINEAR_RGB</code></li>
     * </ul>
     *
     * <p>The following illustrations show gradients in which the matrix was
     * defined using the <code>createGradientBox()</code> method with different
     * parameter settings:</p>
     *
     * @param width    The width of the gradient box.
     * @param height   The height of the gradient box.
     * @param rotation The amount to rotate, in radians.
     * @param tx       The distance, in pixels, to translate to the right along
     *                 the <i>x</i> axis. This value is offset by half of the
     *                 <code>width</code> parameter.
     * @param ty       The distance, in pixels, to translate down along the
     *                 <i>y</i> axis. This value is offset by half of the
     *                 <code>height</code> parameter.
     */
    Matrix.prototype.createGradientBox = function (width, height, rotation, tx, ty) {
        if (rotation === void 0) { rotation = 0; }
        if (tx === void 0) { tx = 0; }
        if (ty === void 0) { ty = 0; }
        this.a = width / 1638.4;
        this.d = height / 1638.4;
        if (rotation != 0.0) {
            var cos = Math.cos(rotation);
            var sin = Math.sin(rotation);
            this.b = sin * this.d;
            this.c = -sin * this.a;
            this.a *= cos;
            this.d *= cos;
        }
        else {
            this.b = this.c = 0;
        }
        this.tx = tx + width / 2;
        this.ty = ty + height / 2;
    };
    /**
     * Given a point in the pretransform coordinate space, returns the
     * coordinates of that point after the transformation occurs. Unlike the
     * standard transformation applied using the <code>transformPoint()</code>
     * method, the <code>deltaTransformPoint()</code> method's transformation
     * does not consider the translation parameters <code>tx</code> and
     * <code>ty</code>.
     *
     * @param point The point for which you want to get the result of the matrix
     *              transformation.
     * @return The point resulting from applying the matrix transformation.
     */
    Matrix.prototype.deltaTransformPoint = function (point) {
        return new Point(point.x * this.a + point.y * this.c, point.x * this.b + point.y * this.d);
    };
    /**
     * Sets each matrix property to a value that causes a null transformation. An
     * object transformed by applying an identity matrix will be identical to the
     * original.
     *
     * <p>After calling the <code>identity()</code> method, the resulting matrix
     * has the following properties: <code>a</code>=1, <code>b</code>=0,
     * <code>c</code>=0, <code>d</code>=1, <code>tx</code>=0,
     * <code>ty</code>=0.</p>
     *
     * <p>In matrix notation, the identity matrix looks like this:</p>
     *
     */
    Matrix.prototype.identity = function () {
        this.a = 1;
        this.b = 0;
        this.c = 0;
        this.d = 1;
        this.tx = 0;
        this.ty = 0;
    };
    /**
     * Performs the opposite transformation of the original matrix. You can apply
     * an inverted matrix to an object to undo the transformation performed when
     * applying the original matrix.
     */
    Matrix.prototype.invert = function () {
        var norm = this.a * this.d - this.b * this.c;
        if (norm == 0) {
            this.a = this.b = this.c = this.d = 0;
            this.tx = -this.tx;
            this.ty = -this.ty;
        }
        else {
            norm = 1.0 / norm;
            var a1 = this.d * norm;
            this.d = this.a * norm;
            this.a = a1;
            this.b *= -norm;
            this.c *= -norm;
            var tx1 = -this.a * this.tx - this.c * this.ty;
            this.ty = -this.b * this.tx - this.d * this.ty;
            this.tx = tx1;
        }
    };
    /**
     * Returns a new Matrix object that is a clone of this matrix, with an exact
     * copy of the contained object.
     *
     * @param matrix The matrix for which you want to get the result of the matrix
     *               transformation.
     * @return A Matrix object.
     */
    Matrix.prototype.multiply = function (matrix) {
        var result = new Matrix();
        result.a = this.a * matrix.a + this.b * matrix.c;
        result.b = this.a * matrix.b + this.b * matrix.d;
        result.c = this.c * matrix.a + this.d * matrix.c;
        result.d = this.c * matrix.b + this.d * matrix.d;
        result.tx = this.tx * matrix.a + this.ty * matrix.c + matrix.tx;
        result.ty = this.tx * matrix.b + this.ty * matrix.d + matrix.ty;
        return result;
    };
    /**
     * Applies a rotation transformation to the Matrix object.
     *
     * <p>The <code>rotate()</code> method alters the <code>a</code>,
     * <code>b</code>, <code>c</code>, and <code>d</code> properties of the
     * Matrix object. In matrix notation, this is the same as concatenating the
     * current matrix with the following:</p>
     *
     * @param angle The rotation angle in radians.
     */
    Matrix.prototype.rotate = function (angle) {
        var cos = Math.cos(angle);
        var sin = Math.sin(angle);
        var a1 = this.a * cos - this.b * sin;
        this.b = this.a * sin + this.b * cos;
        this.a = a1;
        var c1 = this.c * cos - this.d * sin;
        this.d = this.c * sin + this.d * cos;
        this.c = c1;
        var tx1 = this.tx * cos - this.ty * sin;
        this.ty = this.tx * sin + this.ty * cos;
        this.tx = tx1;
    };
    /**
     * Applies a scaling transformation to the matrix. The <i>x</i> axis is
     * multiplied by <code>sx</code>, and the <i>y</i> axis it is multiplied by
     * <code>sy</code>.
     *
     * <p>The <code>scale()</code> method alters the <code>a</code> and
     * <code>d</code> properties of the Matrix object. In matrix notation, this
     * is the same as concatenating the current matrix with the following
     * matrix:</p>
     *
     * @param sx A multiplier used to scale the object along the <i>x</i> axis.
     * @param sy A multiplier used to scale the object along the <i>y</i> axis.
     */
    Matrix.prototype.scale = function (sx, sy) {
        this.a *= sx;
        this.b *= sy;
        this.c *= sx;
        this.d *= sy;
        this.tx *= sx;
        this.ty *= sy;
    };
    /**
     * Sets the members of Matrix to the specified values.
     *
     * @param a  The value that affects the positioning of pixels along the
     *           <i>x</i> axis when scaling or rotating an image.
     * @param b  The value that affects the positioning of pixels along the
     *           <i>y</i> axis when rotating or skewing an image.
     * @param c  The value that affects the positioning of pixels along the
     *           <i>x</i> axis when rotating or skewing an image.
     * @param d  The value that affects the positioning of pixels along the
     *           <i>y</i> axis when scaling or rotating an image..
     * @param tx The distance by which to translate each point along the <i>x</i>
     *           axis.
     * @param ty The distance by which to translate each point along the <i>y</i>
     *           axis.
     */
    Matrix.prototype.setTo = function (a, b, c, d, tx, ty) {
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        this.tx = tx;
        this.ty = ty;
    };
    /**
     * Returns a text value listing the properties of the Matrix object.
     *
     * @return A string containing the values of the properties of the Matrix
     *         object: <code>a</code>, <code>b</code>, <code>c</code>,
     *         <code>d</code>, <code>tx</code>, and <code>ty</code>.
     */
    Matrix.prototype.toString = function () {
        return "[Matrix] (a=" + this.a + ", b=" + this.b + ", c=" + this.c + ", d=" + this.d + ", tx=" + this.tx + ", ty=" + this.ty + ")";
    };
    /**
     * Returns the result of applying the geometric transformation represented by
     * the Matrix object to the specified point.
     *
     * @param point The point for which you want to get the result of the Matrix
     *              transformation.
     * @return The point resulting from applying the Matrix transformation.
     */
    Matrix.prototype.transformPoint = function (point) {
        return new Point(point.x * this.a + point.y * this.c + this.tx, point.x * this.b + point.y * this.d + this.ty);
    };
    /**
     * Translates the matrix along the <i>x</i> and <i>y</i> axes, as specified
     * by the <code>dx</code> and <code>dy</code> parameters.
     *
     * @param dx The amount of movement along the <i>x</i> axis to the right, in
     *           pixels.
     * @param dy The amount of movement down along the <i>y</i> axis, in pixels.
     */
    Matrix.prototype.translate = function (dx, dy) {
        this.tx += dx;
        this.ty += dy;
    };
    return Matrix;
}());

var PlaneClassification = (function () {
    function PlaneClassification() {
    }
    return PlaneClassification;
}());
// "back" is synonymous with "in", but used for planes (back of plane is "inside" a solid volume walled by a plane)
PlaneClassification.BACK = 0;
PlaneClassification.FRONT = 1;
PlaneClassification.IN = 0;
PlaneClassification.OUT = 1;
PlaneClassification.INTERSECT = 2;

var Plane3D = (function () {
    /**
     * Create a Plane3D with ABCD coefficients
     */
    function Plane3D(a, b, c, d) {
        if (a === void 0) { a = 0; }
        if (b === void 0) { b = 0; }
        if (c === void 0) { c = 0; }
        if (d === void 0) { d = 0; }
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;
        if (a == 0 && b == 0) {
            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
        }
        else if (b == 0 && c == 0) {
            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
        }
        else if (a == 0 && c == 0) {
            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
        }
        else {
            this._iAlignment = Plane3D.ALIGN_ANY;
        }
    }
    /**
     * Fills this Plane3D with the coefficients from 3 points in 3d space.
     * @param p0 Vector3D
     * @param p1 Vector3D
     * @param p2 Vector3D
     */
    Plane3D.prototype.fromPoints = function (p0, p1, p2) {
        var d1x = p1.x - p0.x;
        var d1y = p1.y - p0.y;
        var d1z = p1.z - p0.z;
        var d2x = p2.x - p0.x;
        var d2y = p2.y - p0.y;
        var d2z = p2.z - p0.z;
        this.a = d1y * d2z - d1z * d2y;
        this.b = d1z * d2x - d1x * d2z;
        this.c = d1x * d2y - d1y * d2x;
        this.d = this.a * p0.x + this.b * p0.y + this.c * p0.z;
        // not using epsilon, since a plane is infinite and a small incorrection can grow very large
        if (this.a == 0 && this.b == 0) {
            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
        }
        else if (this.b == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
        }
        else if (this.a == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
        }
        else {
            this._iAlignment = Plane3D.ALIGN_ANY;
        }
    };
    /**
     * Fills this Plane3D with the coefficients from the plane's normal and a point in 3d space.
     * @param normal Vector3D
     * @param point  Vector3D
     */
    Plane3D.prototype.fromNormalAndPoint = function (normal, point) {
        this.a = normal.x;
        this.b = normal.y;
        this.c = normal.z;
        this.d = this.a * point.x + this.b * point.y + this.c * point.z;
        if (this.a == 0 && this.b == 0) {
            this._iAlignment = Plane3D.ALIGN_XY_AXIS;
        }
        else if (this.b == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_YZ_AXIS;
        }
        else if (this.a == 0 && this.c == 0) {
            this._iAlignment = Plane3D.ALIGN_XZ_AXIS;
        }
        else {
            this._iAlignment = Plane3D.ALIGN_ANY;
        }
    };
    /**
     * Normalize this Plane3D
     * @return Plane3D This Plane3D.
     */
    Plane3D.prototype.normalize = function () {
        var len = 1 / Math.sqrt(this.a * this.a + this.b * this.b + this.c * this.c);
        this.a *= len;
        this.b *= len;
        this.c *= len;
        this.d *= len;
        return this;
    };
    /**
     * Returns the signed distance between this Plane3D and the point p.
     * @param p Vector3D
     * @returns Number
     */
    Plane3D.prototype.distance = function (p) {
        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS) {
            return this.a * p.x - this.d;
        }
        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS) {
            return this.b * p.y - this.d;
        }
        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS) {
            return this.c * p.z - this.d;
        }
        else {
            return this.a * p.x + this.b * p.y + this.c * p.z - this.d;
        }
    };
    /**
     * Classify a point against this Plane3D. (in front, back or intersecting)
     * @param p Vector3D
     * @return int Plane3.FRONT or Plane3D.BACK or Plane3D.INTERSECT
     */
    Plane3D.prototype.classifyPoint = function (p, epsilon) {
        if (epsilon === void 0) { epsilon = 0.01; }
        // check NaN
        if (this.d != this.d)
            return PlaneClassification.FRONT;
        var len;
        if (this._iAlignment == Plane3D.ALIGN_YZ_AXIS)
            len = this.a * p.x - this.d;
        else if (this._iAlignment == Plane3D.ALIGN_XZ_AXIS)
            len = this.b * p.y - this.d;
        else if (this._iAlignment == Plane3D.ALIGN_XY_AXIS)
            len = this.c * p.z - this.d;
        else
            len = this.a * p.x + this.b * p.y + this.c * p.z - this.d;
        if (len < -epsilon)
            return PlaneClassification.BACK;
        else if (len > epsilon)
            return PlaneClassification.FRONT;
        else
            return PlaneClassification.INTERSECT;
    };
    Plane3D.prototype.toString = function () {
        return "Plane3D [a:" + this.a + ", b:" + this.b + ", c:" + this.c + ", d:" + this.d + "]";
    };
    return Plane3D;
}());
// indicates the alignment of the plane
Plane3D.ALIGN_ANY = 0;
Plane3D.ALIGN_XY_AXIS = 1;
Plane3D.ALIGN_YZ_AXIS = 2;
Plane3D.ALIGN_XZ_AXIS = 3;

var PoissonLookup = (function () {
    function PoissonLookup() {
    }
    PoissonLookup.initDistributions = function () {
        // precalculated for best control
        this._distributions = new Array();
        this._distributions[0] = new Array(0.3082841, 0.4320919);
        this._distributions[1] = new Array(0.3082841, 0.4320919, -0.2274942, -0.6640266);
        this._distributions[2] = new Array(0.8742689, 0.0009265686, -0.6864116, -0.5536607, -0.2325206, 0.7678371);
        this._distributions[3] = new Array(0.3913446, -0.7084417, -0.7511101, -0.5935929, -0.2323436, 0.5320091, 0.8435315, 0.5035911);
        this._distributions[4] = new Array(0.2122471, -0.5771395, -0.8543506, -0.1763534, 0.5189021, 0.8323698, -0.3616908, 0.5865368, 0.9523004, -0.04948437);
        this._distributions[5] = new Array(0.5791035, 0.3496495, 0.2959551, -0.6006749, -0.2419119, -0.06879545, -0.7403072, 0.6110353, -0.04555973, 0.8059174, -0.5275017, -0.737129);
        this._distributions[6] = new Array(0.06941478, 0.8519508, -0.7441907, 0.2426432, 0.6439992, -0.2405252, -0.1007523, -0.2327587, -0.6427067, -0.7248485, 0.8050759, 0.5492936, 0.3573822, -0.8824506);
        this._distributions[7] = new Array(0.8509863, 0.4452587, -0.09507271, 0.2073005, 0.1706571, -0.6434793, 0.8029777, -0.2718274, -0.4401725, 0.8196304, 0.2715359, 0.8598521, -0.8121575, -0.006447683, -0.6486837, -0.7237598);
        this._distributions[8] = new Array(0.6951686, -0.2680728, -0.04933243, 0.3710589, 0.6592212, 0.3661054, -0.01579228, -0.6909603, -0.3275101, -0.1756866, 0.3811549, 0.9218544, -0.216032, 0.9755028, -0.7065172, 0.3355389, -0.6579109, -0.6798355);
        this._distributions[9] = new Array(0.6181276, -0.09790418, -0.2537868, -0.5570995, -0.1964931, 0.3459414, 0.3474613, -0.8885581, 0.5135743, 0.5753114, -0.9549091, 0.1480672, -0.8711916, -0.4293123, -0.6928071, 0.6190156, -0.13369, 0.8892705, 0.0548224, -0.1246777);
        this._distributions[10] = new Array(0.4853027, -0.5080479, -0.1331675, -0.506597, 0.139575, 0.01316885, 0.803486, -0.07568797, 0.5240274, 0.4883182, -0.4334005, 0.1207938, -0.7794577, -0.3985141, 0.1576432, -0.9861221, -0.3712867, 0.6959021, 0.1517378, 0.9847429, -0.9762396, 0.1661073);
        this._distributions[11] = new Array(-0.2790166, -0.01252619, 0.3389016, 0.3921154, 0.2408341, -0.313211, -0.8151779, -0.3898362, -0.6347761, 0.3486495, 0.09471484, -0.7722448, -0.1385674, 0.6364574, 0.2456331, 0.9295807, -0.3864306, -0.8247881, 0.6111673, -0.7164014, 0.8287669, 0.05466961, 0.837706, 0.5415626);
        this._distributions[12] = new Array(0.056417, 0.3185693, -0.8245888, 0.1882799, 0.8575996, 0.1136829, 0.1070375, 0.875332, 0.4076743, -0.06000621, -0.4311306, 0.7239349, 0.2677574, -0.538472, -0.08486642, -0.2083647, -0.888989, -0.3906443, -0.4768958, -0.6664082, 0.09334993, -0.9861541, 0.808736, -0.455949, 0.5889823, 0.7660807);
        this._distributions[13] = new Array(-0.2681346, -0.3955857, -0.1315102, -0.8852947, -0.5143692, 0.09551838, 0.4344836, -0.546945, -0.8620899, -0.3813288, 0.1650431, 0.02034803, -0.1543657, 0.3842218, -0.828457, 0.5376903, -0.6145, -0.7818927, -0.2639062, 0.8784655, 0.1912684, 0.9720125, 0.3135219, 0.5224229, 0.7850655, 0.4592297, 0.7465045, -0.1368916);
        this._distributions[14] = new Array(0.4241029, 0.695281, 0.150511, -0.02304107, -0.2482675, 0.9120338, 0.8057325, 0.2622084, -0.2445909, 0.2765962, 0.8588713, -0.1772072, 0.3117845, -0.4385471, -0.3923851, -0.3298936, -0.1751254, -0.7405846, 0.6926506, -0.684163, -0.9304563, -0.3254691, -0.8533293, 0.1523024, 0.2510415, -0.917345, -0.6239773, -0.7105472, -0.6104624, 0.6041355);
        this._distributions[15] = new Array(0.5844554, 0.06651045, 0.1343258, 0.6756578, 0.3799674, -0.6301104, 0.5590436, 0.7940555, 0.09574714, 0.02262517, 0.8697868, 0.393301, 0.003945862, -0.421735, 0.9043913, -0.2432393, -0.4844007, 0.7190998, -0.3201078, 0.2972371, -0.3852352, -0.6341155, -0.5413069, -0.09223081, -0.8468984, -0.5126905, 0.004156174, -0.8633173, -0.9681889, -0.03305046, -0.846509, 0.4414353);
        this._distributions[16] = new Array(0.4506488, 0.657668, 0.4621297, 0.07441051, -0.2782125, 0.6201044, 0.9750003, 0.09110117, 0.1019436, 0.2986514, 0.03457398, 0.9631706, 0.542098, -0.5505635, 0.8675668, 0.4938077, -0.5414361, 0.2655292, -0.7941836, 0.6003053, -0.09847672, -0.1001604, -0.9316511, -0.08572888, 0.07286467, -0.611899, -0.5232627, -0.4082253, -0.5481608, -0.827938, -0.1551939, -0.9621193, 0.9220031, -0.3315949);
        this._distributions[17] = new Array(0.197908, -0.4697656, -0.4474689, -0.3428435, 0.8529873, -0.2228634, 0.6022478, -0.5469642, 0.2545276, -0.931133, -0.1507547, -0.7855865, -0.07606658, 0.1011628, 0.3046715, 0.2785755, 0.4698432, -0.1064076, 0.6831254, 0.4152522, 0.1374381, 0.8363233, -0.2166121, 0.6682042, 0.5511393, 0.7996449, -0.4278994, 0.28836, -0.8875198, 0.2181732, -0.8772842, -0.2818254, -0.7000262, 0.5762185, -0.6062385, -0.7439126);
        this._distributions[18] = new Array(0.6645703, -0.05678739, 0.5720971, 0.4533803, -0.07660709, 0.08802763, 0.5163431, -0.4426552, 0.1163455, -0.3404382, -0.4004807, -0.5046007, 0.2932099, -0.8201418, -0.5322125, 0.03834766, -0.1490209, -0.8817304, -0.8000439, -0.3509448, 0.5260983, 0.8421043, 0.1197811, 0.6963812, 0.9498612, 0.3122156, -0.9285746, 0.02120355, -0.6670724, 0.7217396, 0.9155889, -0.3510147, -0.271941, 0.4727852, 0.318879, 0.1634057, -0.2686755, 0.9253026);
        this._distributions[19] = new Array(0.5064292, 0.422527, 0.8935515, -0.06610427, 0.1199719, 0.175568, 0.403388, -0.2003276, 0.1657927, 0.8154403, 0.9301245, 0.2929218, -0.1644068, 0.6201534, 0.7113559, -0.6589743, -0.3364046, -0.1799502, 0.02109996, -0.392765, -0.382213, 0.3219992, -0.9201946, 0.1207967, -0.726185, 0.4291916, -0.7443482, -0.2480059, -0.5147594, 0.7418784, 0.1935272, -0.7406143, -0.3643523, -0.5559214, -0.7147766, -0.6326278, -0.2524151, -0.9096627, 0.5161405, 0.7908453);
        this._distributions[20] = new Array(0.7921003, -0.3032096, 0.5992879, -0.009052323, 0.2538549, -0.1872749, 0.7053444, 0.3677175, 0.5417761, -0.8170255, 0.9749611, 0.1210478, 0.1969143, -0.6117041, -0.1824499, -0.4634196, -0.1181338, -0.8668742, -0.3050112, -0.1352596, -0.4409327, -0.7082354, -0.03225285, 0.1171548, 0.3113096, 0.3250439, -0.8166144, -0.463995, -0.01014475, 0.4715334, -0.6868284, 0.05091889, -0.4011163, 0.2717285, -0.06756835, 0.8307694, -0.7938535, 0.4352129, -0.4663842, 0.7165329, 0.559729, 0.8093995);
        this._distributions[21] = new Array(0.07832243, 0.426151, -0.3856795, 0.5799953, 0.01970797, 0.06706189, 0.4822682, 0.3014512, -0.1532982, 0.87485, -0.4959527, 0.07888043, 0.260601, -0.2304784, 0.4996209, 0.7167382, 0.585986, -0.04265174, -0.7679967, 0.5509416, -0.9041753, 0.1802134, -0.8407655, -0.4442826, -0.2058258, -0.2636995, -0.4984115, -0.5928579, 0.2926032, -0.7886473, -0.06933882, -0.621177, 0.578115, -0.4813387, 0.8981777, -0.3291056, 0.1942733, 0.9255584, 0.8084362, 0.5066984, 0.9920095, 0.03103104, -0.2403206, -0.9389018);
        this._distributions[22] = new Array(-0.5691095, 0.1014316, -0.7788262, 0.384012, -0.8253665, -0.1645582, -0.1830993, 0.002997211, -0.2555013, -0.4177977, -0.6640869, -0.4794711, -0.2351242, 0.5850121, 0.02436554, 0.2825883, 0.006061143, -0.8200245, 0.1618791, -0.3063331, -0.3765897, -0.7249815, 0.6092919, -0.6769328, -0.5956934, 0.6957655, 0.5383642, 0.4522677, -0.1489165, 0.9125596, 0.4167473, 0.1335986, 0.1898309, 0.5874342, 0.2288171, 0.9624356, 0.7540846, -0.07672304, 0.8986252, 0.2788797, 0.3555991, -0.9262139, 0.8454325, -0.4027667, 0.4945236, -0.2935512);
        this._distributions[23] = new Array(-0.4481403, -0.3758374, -0.8877251, 0.08739938, 0.05015831, -0.1339983, -0.4070427, -0.8534173, 0.1019274, -0.5503222, -0.445998, 0.1997541, -0.8686263, -0.2788867, -0.7695944, -0.6033704, -0.05515742, -0.885711, -0.7714347, 0.5790485, 0.3466263, -0.8799297, 0.4487582, -0.5321087, -0.2461368, 0.6053771, -0.05568117, 0.2457351, -0.4668669, 0.8523816, 0.8103387, -0.4255538, 0.4054182, -0.175663, -0.2802011, -0.08920153, 0.2665959, 0.382935, 0.555679, 0.1621837, 0.105246, 0.8420411, 0.6921161, 0.6902903, 0.880946, 0.2483067, 0.9699264, -0.1021767);
        this._distributions[24] = new Array(-0.1703323, -0.3119385, 0.2916039, -0.2988263, -0.008472982, -0.9277695, -0.7730271, -0.3277904, 0.3440474, -0.6815342, -0.2910278, 0.03461745, -0.6764899, -0.657078, -0.3505501, -0.7311988, -0.03478927, 0.3258755, -0.6048835, 0.159423, 0.2035525, 0.02212214, 0.5116573, 0.2226856, 0.6664805, -0.2500189, 0.7147882, -0.6609634, 0.03030632, -0.5763278, -0.2516585, 0.6116219, -0.9434413, -0.0116792, 0.9061816, 0.2491155, 0.182867, 0.6076167, 0.286593, 0.9485695, -0.5992439, 0.6970096, -0.2082874, 0.9416641, 0.9880044, -0.1541709, -0.9122881, 0.331555, 0.7324886, 0.6725098);
        this._distributions[25] = new Array(0.3869598, -0.04974834, 0.7168844, -0.0693711, -0.07166742, 0.1725325, 0.4599592, 0.3232779, 0.5872094, -0.4198674, 0.2442266, -0.625667, 0.1254557, 0.4500048, -0.2290154, -0.1803567, 0.890583, 0.3373493, 0.1256081, 0.7853789, -0.2676466, 0.5305805, -0.7063224, 0.252168, -0.3989835, 0.1189921, 0.09617215, -0.2451447, 0.6302541, 0.6085876, 0.9380925, -0.3234899, 0.5086241, -0.8573482, 0.03576187, -0.9876697, -0.0876712, -0.6365195, -0.5276513, 0.823456, -0.6935764, -0.2240411, -0.5212318, -0.5383121, -0.2116208, 0.9639363, -0.9840096, 0.02743555, -0.3991577, -0.8994547, -0.7830126, 0.614068);
        this._distributions[26] = new Array(-0.8366601, 0.4464895, -0.5917366, -0.02073906, -0.9845258, 0.1635625, -0.3097973, 0.4379579, -0.5478154, 0.7173221, -0.1685888, 0.9261969, 0.01503595, 0.6046097, 0.4452421, 0.5449086, 0.0315687, 0.1944619, 0.3753404, 0.8688548, 0.4143643, 0.1396648, 0.8711032, 0.4304703, 0.7328773, 0.1461501, 0.6374492, -0.3521495, 0.145613, -0.1341466, 0.9040975, -0.135123, -0.7839059, -0.5450199, -0.516019, -0.3320859, -0.206158, -0.4431106, -0.9703014, -0.2368356, -0.2473119, -0.0864351, 0.2130725, -0.4604077, -0.003726701, -0.7122303, -0.4072131, -0.6833169, 0.1632999, -0.9776646, 0.4686888, -0.680495, -0.2293511, -0.9509777);
        this._distributions[27] = new Array(0.107311, -0.1311369, -0.4194764, -0.3148777, 0.6171439, -0.2745973, 0.2796618, 0.1937153, -0.09106886, 0.4180236, 0.6044006, 0.05577846, 0.02927299, -0.6738263, -0.2580845, 0.1179939, -0.09023564, -0.3830024, 0.3570953, -0.5000587, 0.81591, -0.5518309, 0.9300217, -0.1257987, 0.4904627, -0.8381903, -0.3163182, -0.8632009, 0.1137595, -0.9875998, 0.8390043, 0.3538185, 0.2149114, 0.4993694, 0.5191584, 0.3833552, 0.5002763, 0.7061465, -0.2567276, 0.9068756, -0.5197366, 0.3467845, 0.03668867, 0.9734009, -0.5347553, 0.66747, -0.9028882, 0.1023768, -0.8967977, 0.412834, -0.5821944, 0.0426479, -0.8032165, -0.2397038, -0.5597343, -0.6358021);
        this._distributions[28] = new Array(-0.6562496, -0.1781036, -0.9301494, 0.1185208, -0.3861143, -0.4153562, -0.1560799, -0.1099607, -0.5587025, 0.395218, -0.5322112, -0.699701, -0.5008639, 0.08726846, -0.970524, -0.1963461, -0.813577, -0.5185111, -0.1644458, 0.298, -0.3216791, 0.639982, 0.3315373, 0.3339162, 0.2383235, -0.00105722, 0.1137828, 0.5450742, -0.01899921, 0.8798413, 0.2849685, 0.8255596, 0.6974412, 0.2123175, 0.7588523, 0.5470437, 0.5102502, -0.1687844, 0.5853448, 0.8033476, 0.2590716, -0.5262504, 0.5607718, -0.6342825, 0.8666443, -0.1491841, 0.8341052, -0.4935003, -0.1568441, -0.6634066, 0.2512113, -0.8769391, -0.2559827, -0.9572457, -0.01928852, -0.3966542, -0.750667, 0.6409678);
        this._distributions[29] = new Array(0.3454786, -0.04837726, 0.2649553, 0.2406852, 0.5599093, -0.3839145, -0.1111814, -0.05502108, 0.7586042, -0.05818377, 0.2519488, -0.4665135, -0.1264972, 0.2602723, -0.08766216, -0.3671907, 0.6428129, 0.3999204, -0.6105871, -0.1246869, -0.4589451, -0.7646643, -0.03021116, -0.7899352, -0.6036922, -0.4293956, -0.2481938, 0.6534185, 0.102798, 0.6784465, -0.6392644, 0.4821358, -0.6789002, 0.1779133, -0.9140783, -0.1989647, -0.9262617, 0.3381507, 0.4794891, -0.8093274, 0.3959447, 0.668478, 0.9602883, 0.2272305, -0.123672, 0.9210883, 0.2375148, 0.9523395, -0.52898, 0.7973378, -0.382433, 0.1228794, 0.695015, 0.6948439, 0.7530277, -0.6458191, 0.8777987, -0.3272956, 0.2318525, -0.962768);
        this._distributions[30] = new Array(0.4518921, -0.1146195, 0.4720805, -0.4238748, 0.3655423, 0.1806341, 0.1589939, -0.23568, 0.7673324, -0.5149941, 0.01163658, 0.09045836, 0.7010971, 0.1245747, 0.7518286, -0.1855433, 0.4960719, 0.4601022, 0.2566979, -0.6308268, -0.0654714, -0.5126389, -0.1823319, -0.1343282, -0.1464312, 0.4883236, -0.3858738, 0.203523, 0.1484799, 0.4432284, -0.477109, -0.116241, 0.2719092, 0.7208626, 0.9104174, 0.3578536, -0.5956199, 0.7662588, -0.6996251, 0.3678654, -0.2514512, 0.9251933, 0.1275825, -0.9478135, -0.204608, -0.8611552, 0.4264838, -0.877443, 0.9854161, 0.05521112, 0.5912951, 0.7997434, 0.1140349, 0.982093, -0.9324368, -0.2094094, -0.42436, -0.6441524, -0.6722705, -0.3554261, -0.7844236, 0.08587621);
        this._distributions[31] = new Array(-0.4206714, -0.5613642, -0.8733016, -0.3373051, -0.1046226, -0.2902999, -0.1318562, -0.8434365, 0.1145093, -0.5962623, -0.4965627, -0.1873259, -0.5011808, -0.8546229, -0.7165636, -0.5743566, 0.1090901, 0.2017643, 0.3404809, -0.220455, -0.1989015, 0.2372122, -0.4538706, 0.0979171, 0.4514146, -0.572846, 0.2314168, -0.8514503, -0.4247236, 0.5650803, -0.943347, 0.04514639, -0.1309718, 0.5221877, -0.7004157, 0.4561877, 0.6306441, 0.04448673, 0.4301621, 0.5766876, 0.1078042, 0.7245752, 0.3875354, 0.2794483, 0.702876, -0.2924213, 0.7360667, -0.6210318, 0.7486517, 0.6531103, 0.4898235, 0.8591025, 0.6549174, 0.3854057, -0.2596106, 0.7916998, 0.9251194, -0.05296265, -0.5620695, 0.820877, -0.01228026, 0.9937211, 0.9612103, 0.2628758);
    };
    PoissonLookup.getDistribution = function (n /*int*/) {
        if (!this._distributions)
            this.initDistributions();
        if (n < 2 || n > 32)
            return null;
        return this._distributions[n - 1];
    };
    return PoissonLookup;
}());

/**
 * A Quaternion object which can be used to represent rotations.
 */
var Quaternion = (function () {
    /**
     * Creates a new Quaternion object.
     * @param x The x value of the quaternion.
     * @param y The y value of the quaternion.
     * @param z The z value of the quaternion.
     * @param w The w value of the quaternion.
     */
    function Quaternion(x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 1; }
        /**
         * The x value of the quaternion.
         */
        this.x = 0;
        /**
         * The y value of the quaternion.
         */
        this.y = 0;
        /**
         * The z value of the quaternion.
         */
        this.z = 0;
        /**
         * The w value of the quaternion.
         */
        this.w = 1;
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
    }
    Object.defineProperty(Quaternion.prototype, "magnitude", {
        /**
         * Returns the magnitude of the quaternion object.
         */
        get: function () {
            return Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Fills the quaternion object with the result from a multiplication of two quaternion objects.
     *
     * @param    qa    The first quaternion in the multiplication.
     * @param    qb    The second quaternion in the multiplication.
     */
    Quaternion.prototype.multiply = function (qa, qb) {
        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
        this.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
        this.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
        this.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
        this.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
    };
    Quaternion.prototype.multiplyVector = function (vector, target) {
        if (target === void 0) { target = null; }
        //target ||= new Quaternion();
        if (target === null) {
            target = new Quaternion();
        }
        var x2 = vector.x;
        var y2 = vector.y;
        var z2 = vector.z;
        target.w = -this.x * x2 - this.y * y2 - this.z * z2;
        target.x = this.w * x2 + this.y * z2 - this.z * y2;
        target.y = this.w * y2 - this.x * z2 + this.z * x2;
        target.z = this.w * z2 + this.x * y2 - this.y * x2;
        return target;
    };
    /**
     * Fills the quaternion object with values representing the given rotation around a vector.
     *
     * @param    axis    The axis around which to rotate
     * @param    angle    The angle in radians of the rotation.
     */
    Quaternion.prototype.fromAxisAngle = function (axis, angle) {
        var sin_a = Math.sin(angle / 2);
        var cos_a = Math.cos(angle / 2);
        this.x = axis.x * sin_a;
        this.y = axis.y * sin_a;
        this.z = axis.z * sin_a;
        this.w = cos_a;
        this.normalize();
    };
    /**
     * Spherically interpolates between two quaternions, providing an interpolation between rotations with constant angle change rate.
     * @param qa The first quaternion to interpolate.
     * @param qb The second quaternion to interpolate.
     * @param t The interpolation weight, a value between 0 and 1.
     */
    Quaternion.prototype.slerp = function (qa, qb, t) {
        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
        var dot = w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2;
        // shortest direction
        if (dot < 0) {
            dot = -dot;
            w2 = -w2;
            x2 = -x2;
            y2 = -y2;
            z2 = -z2;
        }
        if (dot < 0.95) {
            // interpolate angle linearly
            var angle = Math.acos(dot);
            var s = 1 / Math.sin(angle);
            var s1 = Math.sin(angle * (1 - t)) * s;
            var s2 = Math.sin(angle * t) * s;
            this.w = w1 * s1 + w2 * s2;
            this.x = x1 * s1 + x2 * s2;
            this.y = y1 * s1 + y2 * s2;
            this.z = z1 * s1 + z2 * s2;
        }
        else {
            // nearly identical angle, interpolate linearly
            this.w = w1 + t * (w2 - w1);
            this.x = x1 + t * (x2 - x1);
            this.y = y1 + t * (y2 - y1);
            this.z = z1 + t * (z2 - z1);
            var len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
            this.w *= len;
            this.x *= len;
            this.y *= len;
            this.z *= len;
        }
    };
    /**
     * Linearly interpolates between two quaternions.
     * @param qa The first quaternion to interpolate.
     * @param qb The second quaternion to interpolate.
     * @param t The interpolation weight, a value between 0 and 1.
     */
    Quaternion.prototype.lerp = function (qa, qb, t) {
        var w1 = qa.w, x1 = qa.x, y1 = qa.y, z1 = qa.z;
        var w2 = qb.w, x2 = qb.x, y2 = qb.y, z2 = qb.z;
        var len;
        // shortest direction
        if (w1 * w2 + x1 * x2 + y1 * y2 + z1 * z2 < 0) {
            w2 = -w2;
            x2 = -x2;
            y2 = -y2;
            z2 = -z2;
        }
        this.w = w1 + t * (w2 - w1);
        this.x = x1 + t * (x2 - x1);
        this.y = y1 + t * (y2 - y1);
        this.z = z1 + t * (z2 - z1);
        len = 1.0 / Math.sqrt(this.w * this.w + this.x * this.x + this.y * this.y + this.z * this.z);
        this.w *= len;
        this.x *= len;
        this.y *= len;
        this.z *= len;
    };
    /**
     * Fills the quaternion object with values representing the given euler rotation.
     *
     * @param    ax        The angle in radians of the rotation around the ax axis.
     * @param    ay        The angle in radians of the rotation around the ay axis.
     * @param    az        The angle in radians of the rotation around the az axis.
     */
    Quaternion.prototype.fromEulerAngles = function (ax, ay, az) {
        var halfX = ax * .5, halfY = ay * .5, halfZ = az * .5;
        var cosX = Math.cos(halfX), sinX = Math.sin(halfX);
        var cosY = Math.cos(halfY), sinY = Math.sin(halfY);
        var cosZ = Math.cos(halfZ), sinZ = Math.sin(halfZ);
        this.w = cosX * cosY * cosZ + sinX * sinY * sinZ;
        this.x = sinX * cosY * cosZ - cosX * sinY * sinZ;
        this.y = cosX * sinY * cosZ + sinX * cosY * sinZ;
        this.z = cosX * cosY * sinZ - sinX * sinY * cosZ;
    };
    /**
     * Fills a target Vector3D object with the Euler angles that form the rotation represented by this quaternion.
     * @param target An optional Vector3D object to contain the Euler angles. If not provided, a new object is created.
     * @return The Vector3D containing the Euler angles.
     */
    Quaternion.prototype.toEulerAngles = function (target) {
        if (target === void 0) { target = null; }
        //target ||= new Vector3D();
        if (target === null) {
            target = new Vector3D();
        }
        target.x = Math.atan2(2 * (this.w * this.x + this.y * this.z), 1 - 2 * (this.x * this.x + this.y * this.y));
        target.y = Math.asin(2 * (this.w * this.y - this.z * this.x));
        target.z = Math.atan2(2 * (this.w * this.z + this.x * this.y), 1 - 2 * (this.y * this.y + this.z * this.z));
        return target;
    };
    /**
     * Normalises the quaternion object.
     */
    Quaternion.prototype.normalize = function (val) {
        if (val === void 0) { val = 1; }
        var mag = val / Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
        this.x *= mag;
        this.y *= mag;
        this.z *= mag;
        this.w *= mag;
    };
    /**
     * Used to trace the values of a quaternion.
     *
     * @return A string representation of the quaternion object.
     */
    Quaternion.prototype.toString = function () {
        return "{x:" + this.x + " y:" + this.y + " z:" + this.z + " w:" + this.w + "}";
    };
    /**
     * Converts the quaternion to a Matrix3D object representing an equivalent rotation.
     * @param target An optional Matrix3D container to store the transformation in. If not provided, a new object is created.
     * @return A Matrix3D object representing an equivalent rotation.
     */
    Quaternion.prototype.toMatrix3D = function (target) {
        if (target === void 0) { target = null; }
        var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
        var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
        var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
        if (!target)
            target = new Matrix3D();
        var rawData = target._rawData;
        rawData[0] = xx - yy - zz + ww;
        rawData[4] = xy2 - zw2;
        rawData[8] = xz2 + yw2;
        rawData[12] = 0;
        rawData[1] = xy2 + zw2;
        rawData[5] = -xx + yy - zz + ww;
        rawData[9] = yz2 - xw2;
        rawData[13] = 0;
        rawData[2] = xz2 - yw2;
        rawData[6] = yz2 + xw2;
        rawData[10] = -xx - yy + zz + ww;
        rawData[14] = 0;
        rawData[3] = 0.0;
        rawData[7] = 0.0;
        rawData[11] = 0;
        rawData[15] = 1;
        return target;
    };
    /**
     * Extracts a quaternion rotation matrix out of a given Matrix3D object.
     * @param matrix The Matrix3D out of which the rotation will be extracted.
     */
    Quaternion.prototype.fromMatrix = function (matrix) {
        var v = matrix.decompose(Orientation3D.QUATERNION)[1];
        this.x = v.x;
        this.y = v.y;
        this.z = v.z;
        this.w = v.w;
    };
    /**
     * Converts the quaternion to a Vector.&lt;Number&gt; matrix representation of a rotation equivalent to this quaternion.
     * @param target The Vector.&lt;Number&gt; to contain the raw matrix data.
     * @param exclude4thRow If true, the last row will be omitted, and a 4x3 matrix will be generated instead of a 4x4.
     */
    Quaternion.prototype.toRawData = function (target, exclude4thRow) {
        if (exclude4thRow === void 0) { exclude4thRow = false; }
        var xy2 = 2.0 * this.x * this.y, xz2 = 2.0 * this.x * this.z, xw2 = 2.0 * this.x * this.w;
        var yz2 = 2.0 * this.y * this.z, yw2 = 2.0 * this.y * this.w, zw2 = 2.0 * this.z * this.w;
        var xx = this.x * this.x, yy = this.y * this.y, zz = this.z * this.z, ww = this.w * this.w;
        target[0] = xx - yy - zz + ww;
        target[1] = xy2 - zw2;
        target[2] = xz2 + yw2;
        target[4] = xy2 + zw2;
        target[5] = -xx + yy - zz + ww;
        target[6] = yz2 - xw2;
        target[8] = xz2 - yw2;
        target[9] = yz2 + xw2;
        target[10] = -xx - yy + zz + ww;
        target[3] = target[7] = target[11] = 0;
        if (!exclude4thRow) {
            target[12] = target[13] = target[14] = 0;
            target[15] = 1;
        }
    };
    /**
     * Clones the quaternion.
     * @return An exact duplicate of the current Quaternion.
     */
    Quaternion.prototype.clone = function () {
        return new Quaternion(this.x, this.y, this.z, this.w);
    };
    /**
     * Rotates a point.
     * @param vector The Vector3D object to be rotated.
     * @param target An optional Vector3D object that will contain the rotated coordinates. If not provided, a new object will be created.
     * @return A Vector3D object containing the rotated point.
     */
    Quaternion.prototype.rotatePoint = function (vector, target) {
        if (target === void 0) { target = null; }
        var x1, y1, z1, w1;
        var x2 = vector.x, y2 = vector.y, z2 = vector.z;
        //target ||= new Vector3D();
        if (target === null) {
            target = new Vector3D();
        }
        // p*q'
        w1 = -this.x * x2 - this.y * y2 - this.z * z2;
        x1 = this.w * x2 + this.y * z2 - this.z * y2;
        y1 = this.w * y2 - this.x * z2 + this.z * x2;
        z1 = this.w * z2 + this.x * y2 - this.y * x2;
        target.x = -w1 * this.x + x1 * this.w - y1 * this.z + z1 * this.y;
        target.y = -w1 * this.y + x1 * this.z + y1 * this.w - z1 * this.x;
        target.z = -w1 * this.z - x1 * this.y + y1 * this.x + z1 * this.w;
        return target;
    };
    /**
     * Copies the data from a quaternion into this instance.
     * @param q The quaternion to copy from.
     */
    Quaternion.prototype.copyFrom = function (q) {
        this.x = q.x;
        this.y = q.y;
        this.z = q.z;
        this.w = q.w;
    };
    return Quaternion;
}());

/**
 * A Rectangle object is an area defined by its position, as indicated by its
 * top-left corner point(<i>x</i>, <i>y</i>) and by its width and its height.
 *
 *
 * <p>The <code>x</code>, <code>y</code>, <code>width</code>, and
 * <code>height</code> properties of the Rectangle export class are independent of
 * each other; changing the value of one property has no effect on the others.
 * However, the <code>right</code> and <code>bottom</code> properties are
 * integrally related to those four properties. For example, if you change the
 * value of the <code>right</code> property, the value of the
 * <code>width</code> property changes; if you change the <code>bottom</code>
 * property, the value of the <code>height</code> property changes. </p>
 *
 * <p>The following methods and properties use Rectangle objects:</p>
 *
 * <ul>
 *   <li>The <code>applyFilter()</code>, <code>colorTransform()</code>,
 * <code>copyChannel()</code>, <code>copyPixels()</code>, <code>draw()</code>,
 * <code>fillRect()</code>, <code>generateFilterRect()</code>,
 * <code>getColorBoundsRect()</code>, <code>getPixels()</code>,
 * <code>merge()</code>, <code>paletteMap()</code>,
 * <code>pixelDisolve()</code>, <code>setPixels()</code>, and
 * <code>threshold()</code> methods, and the <code>rect</code> property of the
 * BitmapData class</li>
 *   <li>The <code>getBounds()</code> and <code>getRect()</code> methods, and
 * the <code>scrollRect</code> and <code>scale9Grid</code> properties of the
 * DisplayObject class</li>
 *   <li>The <code>getCharBoundaries()</code> method of the TextField
 * class</li>
 *   <li>The <code>pixelBounds</code> property of the Transform class</li>
 *   <li>The <code>bounds</code> parameter for the <code>startDrag()</code>
 * method of the Sprite class</li>
 *   <li>The <code>printArea</code> parameter of the <code>addPage()</code>
 * method of the PrintJob class</li>
 * </ul>
 *
 * <p>You can use the <code>new Rectangle()</code> constructor to create a
 * Rectangle object.</p>
 *
 * <p><b>Note:</b> The Rectangle export class does not define a rectangular Shape
 * display object. To draw a rectangular Shape object onscreen, use the
 * <code>drawRect()</code> method of the Graphics class.</p>
 */
var Rectangle = (function () {
    /**
     * Creates a new Rectangle object with the top-left corner specified by the
     * <code>x</code> and <code>y</code> parameters and with the specified
     * <code>width</code> and <code>height</code> parameters. If you call this
     * public without parameters, a rectangle with <code>x</code>,
     * <code>y</code>, <code>width</code>, and <code>height</code> properties set
     * to 0 is created.
     *
     * @param x      The <i>x</i> coordinate of the top-left corner of the
     *               rectangle.
     * @param y      The <i>y</i> coordinate of the top-left corner of the
     *               rectangle.
     * @param width  The width of the rectangle, in pixels.
     * @param height The height of the rectangle, in pixels.
     */
    function Rectangle(x, y, width, height) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (width === void 0) { width = 0; }
        if (height === void 0) { height = 0; }
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
    }
    Object.defineProperty(Rectangle.prototype, "bottom", {
        /**
         * The sum of the <code>y</code> and <code>height</code> properties.
         */
        get: function () {
            return this.y + this.height;
        },
        set: function (val) {
            this.height = val - this.y;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "bottomRight", {
        /**
         * The location of the Rectangle object's bottom-right corner, determined by
         * the values of the <code>right</code> and <code>bottom</code> properties.
         */
        get: function () {
            if (this._bottomRight == null)
                this._bottomRight = new Point();
            this._bottomRight.x = this.x + this.width;
            this._bottomRight.y = this.y + this.height;
            return this._bottomRight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "left", {
        /**
         * The <i>x</i> coordinate of the top-left corner of the rectangle. Changing
         * the <code>left</code> property of a Rectangle object has no effect on the
         * <code>y</code> and <code>height</code> properties. However it does affect
         * the <code>width</code> property, whereas changing the <code>x</code> value
         * does <i>not</i> affect the <code>width</code> property.
         *
         * <p>The value of the <code>left</code> property is equal to the value of
         * the <code>x</code> property.</p>
         */
        get: function () {
            return this.x;
        },
        set: function (val) {
            this.width += this.x - val;
            this.x = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "right", {
        /**
         * The sum of the <code>x</code> and <code>width</code> properties.
         */
        get: function () {
            return this.x + this.width;
        },
        set: function (val) {
            this.width = val - this.x;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "size", {
        /**
         * The size of the Rectangle object, expressed as a Point object with the
         * values of the <code>width</code> and <code>height</code> properties.
         */
        get: function () {
            if (this._size == null)
                this._size = new Point();
            this._size.x = this.width;
            this._size.y = this.height;
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "top", {
        /**
         * The <i>y</i> coordinate of the top-left corner of the rectangle. Changing
         * the <code>top</code> property of a Rectangle object has no effect on the
         * <code>x</code> and <code>width</code> properties. However it does affect
         * the <code>height</code> property, whereas changing the <code>y</code>
         * value does <i>not</i> affect the <code>height</code> property.
         *
         * <p>The value of the <code>top</code> property is equal to the value of the
         * <code>y</code> property.</p>
         */
        get: function () {
            return this.y;
        },
        set: function (val) {
            this.height += (this.y - val);
            this.y = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "topLeft", {
        /**
         * The location of the Rectangle object's top-left corner, determined by the
         * <i>x</i> and <i>y</i> coordinates of the point.
         */
        get: function () {
            if (this._topLeft == null)
                this._topLeft = new Point();
            this._topLeft.x = this.x;
            this._topLeft.y = this.y;
            return this._topLeft;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new Rectangle object with the same values for the
     * <code>x</code>, <code>y</code>, <code>width</code>, and
     * <code>height</code> properties as the original Rectangle object.
     *
     * @return A new Rectangle object with the same values for the
     *         <code>x</code>, <code>y</code>, <code>width</code>, and
     *         <code>height</code> properties as the original Rectangle object.
     */
    Rectangle.prototype.clone = function () {
        return new Rectangle(this.x, this.y, this.width, this.height);
    };
    /**
     * Determines whether the specified point is contained within the rectangular
     * region defined by this Rectangle object.
     *
     * @param x The <i>x</i> coordinate(horizontal position) of the point.
     * @param y The <i>y</i> coordinate(vertical position) of the point.
     * @return A value of <code>true</code> if the Rectangle object contains the
     *         specified point; otherwise <code>false</code>.
     */
    Rectangle.prototype.contains = function (x, y) {
        return (this.x <= x && this.x + this.width >= x && this.y <= y && this.y + this.height >= y);
    };
    /**
     * Determines whether the specified point is contained within the rectangular
     * region defined by this Rectangle object. This method is similar to the
     * <code>Rectangle.contains()</code> method, except that it takes a Point
     * object as a parameter.
     *
     * @param point The point, as represented by its <i>x</i> and <i>y</i>
     *              coordinates.
     * @return A value of <code>true</code> if the Rectangle object contains the
     *         specified point; otherwise <code>false</code>.
     */
    Rectangle.prototype.containsPoint = function (point) {
        return (this.x <= point.x && this.x + this.width >= point.x && this.y <= point.y && this.y + this.height >= point.y);
    };
    /**
     * Determines whether the Rectangle object specified by the <code>rect</code>
     * parameter is contained within this Rectangle object. A Rectangle object is
     * said to contain another if the second Rectangle object falls entirely
     * within the boundaries of the first.
     *
     * @param rect The Rectangle object being checked.
     * @return A value of <code>true</code> if the Rectangle object that you
     *         specify is contained by this Rectangle object; otherwise
     *         <code>false</code>.
     */
    Rectangle.prototype.containsRect = function (rect) {
        return (this.x <= rect.x && this.x + this.width >= rect.x + rect.width && this.y <= rect.y && this.y + this.height >= rect.y + rect.height);
    };
    /**
     * Copies all of rectangle data from the source Rectangle object into the
     * calling Rectangle object.
     *
     * @param sourceRect The Rectangle object from which to copy the data.
     */
    Rectangle.prototype.copyFrom = function (sourceRect) {
        this.x = sourceRect.x;
        this.y = sourceRect.y;
        this.width = sourceRect.width;
        this.height = sourceRect.height;
    };
    /**
     * Determines whether the object specified in the <code>toCompare</code>
     * parameter is equal to this Rectangle object. This method compares the
     * <code>x</code>, <code>y</code>, <code>width</code>, and
     * <code>height</code> properties of an object against the same properties of
     * this Rectangle object.
     *
     * @param toCompare The rectangle to compare to this Rectangle object.
     * @return A value of <code>true</code> if the object has exactly the same
     *         values for the <code>x</code>, <code>y</code>, <code>width</code>,
     *         and <code>height</code> properties as this Rectangle object;
     *         otherwise <code>false</code>.
     */
    Rectangle.prototype.equals = function (toCompare) {
        return (this.x == toCompare.x && this.y == toCompare.y && this.width == toCompare.width && this.height == toCompare.height);
    };
    /**
     * Increases the size of the Rectangle object by the specified amounts, in
     * pixels. The center point of the Rectangle object stays the same, and its
     * size increases to the left and right by the <code>dx</code> value, and to
     * the top and the bottom by the <code>dy</code> value.
     *
     * @param dx The value to be added to the left and the right of the Rectangle
     *           object. The following equation is used to calculate the new
     *           width and position of the rectangle:
     * @param dy The value to be added to the top and the bottom of the
     *           Rectangle. The following equation is used to calculate the new
     *           height and position of the rectangle:
     */
    Rectangle.prototype.inflate = function (dx, dy) {
        this.x -= dx / 2;
        this.y -= dy / 2;
        this.width += dx / 2;
        this.height += dy / 2;
    };
    /**
     * Increases the size of the Rectangle object. This method is similar to the
     * <code>Rectangle.inflate()</code> method except it takes a Point object as
     * a parameter.
     *
     * <p>The following two code examples give the same result:</p>
     *
     * @param point The <code>x</code> property of this Point object is used to
     *              increase the horizontal dimension of the Rectangle object.
     *              The <code>y</code> property is used to increase the vertical
     *              dimension of the Rectangle object.
     */
    Rectangle.prototype.inflatePoint = function (point) {
        this.x -= point.x / 2;
        this.y -= point.y / 2;
        this.width += point.x / 2;
        this.height += point.y / 2;
    };
    /**
     * If the Rectangle object specified in the <code>toIntersect</code>
     * parameter intersects with this Rectangle object, returns the area of
     * intersection as a Rectangle object. If the rectangles do not intersect,
     * this method returns an empty Rectangle object with its properties set to
     * 0.
     *
     * @param toIntersect The Rectangle object to compare against to see if it
     *                    intersects with this Rectangle object.
     * @return A Rectangle object that equals the area of intersection. If the
     *         rectangles do not intersect, this method returns an empty
     *         Rectangle object; that is, a rectangle with its <code>x</code>,
     *         <code>y</code>, <code>width</code>, and <code>height</code>
     *         properties set to 0.
     */
    Rectangle.prototype.intersection = function (toIntersect) {
        if (this.intersects(toIntersect)) {
            var i = new Rectangle();
            if (this.x > toIntersect.x) {
                i.x = this.x;
                i.width = toIntersect.x - this.x + toIntersect.width;
                if (i.width > this.width)
                    i.width = this.width;
            }
            else {
                i.x = toIntersect.x;
                i.width = this.x - toIntersect.x + this.width;
                if (i.width > toIntersect.width)
                    i.width = toIntersect.width;
            }
            if (this.y > toIntersect.y) {
                i.y = this.y;
                i.height = toIntersect.y - this.y + toIntersect.height;
                if (i.height > this.height)
                    i.height = this.height;
            }
            else {
                i.y = toIntersect.y;
                i.height = this.y - toIntersect.y + this.height;
                if (i.height > toIntersect.height)
                    i.height = toIntersect.height;
            }
            return i;
        }
        return new Rectangle();
    };
    /**
     * Determines whether the object specified in the <code>toIntersect</code>
     * parameter intersects with this Rectangle object. This method checks the
     * <code>x</code>, <code>y</code>, <code>width</code>, and
     * <code>height</code> properties of the specified Rectangle object to see if
     * it intersects with this Rectangle object.
     *
     * @param toIntersect The Rectangle object to compare against this Rectangle
     *                    object.
     * @return A value of <code>true</code> if the specified object intersects
     *         with this Rectangle object; otherwise <code>false</code>.
     */
    Rectangle.prototype.intersects = function (toIntersect) {
        return (this.x + this.width > toIntersect.x && this.x < toIntersect.x + toIntersect.width && this.y + this.height > toIntersect.y && this.y < toIntersect.y + toIntersect.height);
    };
    /**
     * Determines whether or not this Rectangle object is empty.
     *
     * @return A value of <code>true</code> if the Rectangle object's width or
     *         height is less than or equal to 0; otherwise <code>false</code>.
     */
    Rectangle.prototype.isEmpty = function () {
        return (this.x == 0 && this.y == 0 && this.width == 0 && this.height == 0);
    };
    /**
     * Adjusts the location of the Rectangle object, as determined by its
     * top-left corner, by the specified amounts.
     *
     * @param dx Moves the <i>x</i> value of the Rectangle object by this amount.
     * @param dy Moves the <i>y</i> value of the Rectangle object by this amount.
     */
    Rectangle.prototype.offset = function (dx, dy) {
        this.x += dx;
        this.y += dy;
    };
    /**
     * Adjusts the location of the Rectangle object using a Point object as a
     * parameter. This method is similar to the <code>Rectangle.offset()</code>
     * method, except that it takes a Point object as a parameter.
     *
     * @param point A Point object to use to offset this Rectangle object.
     */
    Rectangle.prototype.offsetPoint = function (point) {
        this.x += point.x;
        this.y += point.y;
    };
    /**
     * Sets all of the Rectangle object's properties to 0. A Rectangle object is
     * empty if its width or height is less than or equal to 0.
     *
     * <p> This method sets the values of the <code>x</code>, <code>y</code>,
     * <code>width</code>, and <code>height</code> properties to 0.</p>
     *
     */
    Rectangle.prototype.setEmpty = function () {
        this.x = 0;
        this.y = 0;
        this.width = 0;
        this.height = 0;
    };
    /**
     * Sets the members of Rectangle to the specified values
     *
     * @param xa      The <i>x</i> coordinate of the top-left corner of the
     *                rectangle.
     * @param ya      The <i>y</i> coordinate of the top-left corner of the
     *                rectangle.
     * @param widtha  The width of the rectangle, in pixels.
     * @param heighta The height of the rectangle, in pixels.
     */
    Rectangle.prototype.setTo = function (xa, ya, widtha, heighta) {
        this.x = xa;
        this.y = ya;
        this.width = widtha;
        this.height = heighta;
    };
    /**
     * Builds and returns a string that lists the horizontal and vertical
     * positions and the width and height of the Rectangle object.
     *
     * @return A string listing the value of each of the following properties of
     *         the Rectangle object: <code>x</code>, <code>y</code>,
     *         <code>width</code>, and <code>height</code>.
     */
    Rectangle.prototype.toString = function () {
        return "[Rectangle] (x=" + this.x + ", y=" + this.y + ", width=" + this.width + ", height=" + this.height + ")";
    };
    /**
     * Adds two rectangles together to create a new Rectangle object, by filling
     * in the horizontal and vertical space between the two rectangles.
     *
     * <p><b>Note:</b> The <code>union()</code> method ignores rectangles with
     * <code>0</code> as the height or width value, such as: <code>var
     * rect2:Rectangle = new Rectangle(300,300,50,0);</code></p>
     *
     * @param toUnion A Rectangle object to add to this Rectangle object.
     * @return A new Rectangle object that is the union of the two rectangles.
     */
    Rectangle.prototype.union = function (toUnion) {
        var u = new Rectangle();
        if (this.x < toUnion.x) {
            u.x = this.x;
            u.width = toUnion.x - this.x + toUnion.width;
            if (u.width < this.width)
                u.width = this.width;
        }
        else {
            u.x = toUnion.x;
            u.width = this.x - toUnion.x + this.width;
            if (u.width < toUnion.width)
                u.width = toUnion.width;
        }
        if (this.y < toUnion.y) {
            u.y = this.y;
            u.height = toUnion.y - this.y + toUnion.height;
            if (u.height < this.height)
                u.height = this.height;
        }
        else {
            u.y = toUnion.y;
            u.height = this.y - toUnion.y + this.height;
            if (u.height < toUnion.height)
                u.height = toUnion.height;
        }
        return u;
    };
    return Rectangle;
}());

var Sphere = (function () {
    /**
     * Create a Sphere with ABCD coefficients
     */
    function Sphere(x, y, z, radius) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (radius === void 0) { radius = 0; }
        this.x = x;
        this.y = y;
        this.z = z;
        this.radius = radius;
    }
    Sphere.prototype.rayIntersection = function (position, direction, targetNormal) {
        if (this.containsPoint(position))
            return 0;
        var px = position.x - this.x, py = position.y - this.y, pz = position.z - this.z;
        var vx = direction.x, vy = direction.y, vz = direction.z;
        var rayEntryDistance;
        var a = vx * vx + vy * vy + vz * vz;
        var b = 2 * (px * vx + py * vy + pz * vz);
        var c = px * px + py * py + pz * pz - this.radius * this.radius;
        var det = b * b - 4 * a * c;
        if (det >= 0) {
            var sqrtDet = Math.sqrt(det);
            rayEntryDistance = (-b - sqrtDet) / (2 * a);
            if (rayEntryDistance >= 0) {
                targetNormal.x = px + rayEntryDistance * vx;
                targetNormal.y = py + rayEntryDistance * vy;
                targetNormal.z = pz + rayEntryDistance * vz;
                targetNormal.normalize();
                return rayEntryDistance;
            }
        }
        // ray misses sphere
        return -1;
    };
    Sphere.prototype.containsPoint = function (position) {
        var px = position.x - this.x;
        var py = position.y - this.y;
        var pz = position.z - this.z;
        var distance = Math.sqrt(px * px + py * py + pz * pz);
        return distance <= this.radius;
    };
    Sphere.prototype.toString = function () {
        return "Sphere [x:" + this.x + ", y:" + this.y + ", z:" + this.z + ", radius:" + this.radius + "]";
    };
    return Sphere;
}());

/**
 *
 * @export class away.pool.AbstractionBase
 */
var AbstractionBase = (function (_super) {
    __extends(AbstractionBase, _super);
    function AbstractionBase(asset, pool) {
        var _this = _super.call(this) || this;
        _this._invalid = true;
        _this._asset = asset;
        _this._pool = pool;
        _this._onClearDelegate = function (event) { return _this.onClear(event); };
        _this._onInvalidateDelegate = function (event) { return _this.onInvalidate(event); };
        _this._asset.addEventListener(AssetEvent.CLEAR, _this._onClearDelegate);
        _this._asset.addEventListener(AssetEvent.INVALIDATE, _this._onInvalidateDelegate);
        return _this;
    }
    /**
     *
     */
    AbstractionBase.prototype.onClear = function (event) {
        this._asset.removeEventListener(AssetEvent.CLEAR, this._onClearDelegate);
        this._asset.removeEventListener(AssetEvent.INVALIDATE, this._onInvalidateDelegate);
        this._pool.clearAbstraction(this._asset);
        this._pool = null;
        this._asset = null;
    };
    /**
     *
     */
    AbstractionBase.prototype.onInvalidate = function (event) {
        this._invalid = true;
    };
    return AbstractionBase;
}(EventDispatcher));

var AssetLibraryIterator = (function () {
    function AssetLibraryIterator(assets, assetTypeFilter, namespaceFilter, filterFunc) {
        this._assets = assets;
        this.filter(assetTypeFilter, namespaceFilter, filterFunc);
    }
    Object.defineProperty(AssetLibraryIterator.prototype, "currentAsset", {
        get: function () {
            // Return current, or null if no current
            return (this._idx < this._filtered.length) ? this._filtered[this._idx] : null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetLibraryIterator.prototype, "numAssets", {
        get: function () {
            return this._filtered.length;
        },
        enumerable: true,
        configurable: true
    });
    AssetLibraryIterator.prototype.next = function () {
        var next = null;
        if (this._idx < this._filtered.length)
            next = this._filtered[this._idx];
        this._idx++;
        return next;
    };
    AssetLibraryIterator.prototype.reset = function () {
        this._idx = 0;
    };
    AssetLibraryIterator.prototype.setIndex = function (index) {
        this._idx = index;
    };
    AssetLibraryIterator.prototype.filter = function (assetTypeFilter, namespaceFilter, filterFunc) {
        if (assetTypeFilter || namespaceFilter) {
            var idx;
            var asset;
            idx = 0;
            this._filtered = new Array(); //new Vector.<IAsset>;
            var l = this._assets.length;
            for (var c = 0; c < l; c++) {
                asset = this._assets[c];
                // Skip this assets if filtering on type and this is wrong type
                if (assetTypeFilter && asset.adaptee.assetType != assetTypeFilter)
                    continue;
                // Skip this asset if filtering on namespace and this is wrong namespace
                if (namespaceFilter && asset.adaptee.assetNamespace != namespaceFilter)
                    continue;
                // Skip this asset if a filter func has been provided and it returns false
                if (filterFunc != null && !filterFunc(asset))
                    continue;
                this._filtered[idx++] = asset;
            }
        }
        else {
            this._filtered = this._assets;
        }
    };
    return AssetLibraryIterator;
}());

var LoaderContext = (function () {
    /**
     * LoaderContext provides configuration for the Loader load() and parse() operations.
     * Use it to configure how (and if) dependencies are loaded, or to map dependency URLs to
     * embedded data.
     *
     * @see away.loading.Loader
     */
    function LoaderContext(includeDependencies, dependencyBaseUrl) {
        if (includeDependencies === void 0) { includeDependencies = true; }
        if (dependencyBaseUrl === void 0) { dependencyBaseUrl = null; }
        this._includeDependencies = includeDependencies;
        this._dependencyBaseUrl = dependencyBaseUrl || '';
        this._embeddedDataByUrl = {};
        this._remappedUrls = {};
        this._materialMode = LoaderContext.UNDEFINED;
        this._externalAssetMode = LoaderContext.PRELOADED;
    }
    Object.defineProperty(LoaderContext.prototype, "includeDependencies", {
        /**
         * Defines whether dependencies (all files except the one at the URL given to the load() or
         * parseData() operations) should be automatically loaded. Defaults to true.
         */
        get: function () {
            return this._includeDependencies;
        },
        set: function (val) {
            this._includeDependencies = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderContext.prototype, "materialMode", {
        /**
         * MaterialMode defines, if the Parser should create SinglePass or MultiPass Materials
         * Options:
         * 0 (Default / undefined) - All Parsers will create SinglePassMaterials, but the AWD2.1parser will create Materials as they are defined in the file
         * 1 (Force SinglePass) - All Parsers create SinglePassMaterials
         * 2 (Force MultiPass) - All Parsers will create MultiPassMaterials
         *
         */
        get: function () {
            return this._materialMode;
        },
        set: function (value) {
            this._materialMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderContext.prototype, "externalAssetMode", {
        get: function () {
            return this._externalAssetMode;
        },
        set: function (value) {
            this._externalAssetMode = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderContext.prototype, "dependencyBaseUrl", {
        /**
         * A base URL that will be prepended to all relative dependency URLs found in a loaded resource.
         * Absolute paths will not be affected by the value of this property.
         */
        get: function () {
            return this._dependencyBaseUrl;
        },
        set: function (val) {
            this._dependencyBaseUrl = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderContext.prototype, "overrideAbsolutePaths", {
        /**
         * Defines whether absolute paths (defined as paths that begin with a "/") should be overridden
         * with the dependencyBaseUrl defined in this context. If this is true, and the base path is
         * "base", /path/to/asset.jpg will be resolved as base/path/to/asset.jpg.
         */
        get: function () {
            return this._overrideAbsPath;
        },
        set: function (val) {
            this._overrideAbsPath = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderContext.prototype, "overrideFullURLs", {
        /**
         * Defines whether "full" URLs (defined as a URL that includes a scheme, e.g. http://) should be
         * overridden with the dependencyBaseUrl defined in this context. If this is true, and the base
         * path is "base", http://example.com/path/to/asset.jpg will be resolved as base/path/to/asset.jpg.
         */
        get: function () {
            return this._overrideFullUrls;
        },
        set: function (val) {
            this._overrideFullUrls = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Map a URL to another URL, so that files that are referred to by the original URL will instead
     * be loaded from the new URL. Use this when your file structure does not match the one that is
     * expected by the loaded file.
     *
     * @param originalUrl The original URL which is referenced in the loaded resource.
     * @param newUrl The URL from which away.should load the resource instead.
     *
     * @see mapUrlToData()
     */
    LoaderContext.prototype.mapUrl = function (originalUrl, newUrl) {
        this._remappedUrls[originalUrl] = newUrl;
    };
    /**
     * Map a URL to embedded data, so that instead of trying to load a dependency from the URL at
     * which it's referenced, the dependency data will be retrieved straight from the memory instead.
     *
     * @param originalUrl The original URL which is referenced in the loaded resource.
     * @param data The embedded data. Can be ByteArray or a export class which can be used to create a bytearray.
     */
    LoaderContext.prototype.mapUrlToData = function (originalUrl, data) {
        this._embeddedDataByUrl[originalUrl] = data;
    };
    /**
     * @private
     * Defines whether embedded data has been mapped to a particular URL.
     */
    LoaderContext.prototype._iHasDataForUrl = function (url) {
        return this._embeddedDataByUrl.hasOwnProperty(url);
    };
    /**
     * @private
     * Returns embedded data for a particular URL.
     */
    LoaderContext.prototype._iGetDataForUrl = function (url) {
        return this._embeddedDataByUrl[url];
    };
    /**
     * @private
     * Defines whether a replacement URL has been mapped to a particular URL.
     */
    LoaderContext.prototype._iHasMappingForUrl = function (url) {
        return this._remappedUrls.hasOwnProperty(url);
    };
    /**
     * @private
     * Returns new (replacement) URL for a particular original URL.
     */
    LoaderContext.prototype._iGetRemappedUrl = function (originalUrl) {
        return this._remappedUrls[originalUrl];
    };
    return LoaderContext;
}());
LoaderContext.UNDEFINED = 0;
LoaderContext.SINGLEPASS_MATERIALS = 1;
LoaderContext.MULTIPASS_MATERIALS = 2;
LoaderContext.ON_DEMAND = "onDemand";
LoaderContext.PRELOADED = "preloaded";

var URLLoaderDataFormat = (function () {
    function URLLoaderDataFormat() {
    }
    return URLLoaderDataFormat;
}());
/**
 * TEXT
 * @type {string}
 */
URLLoaderDataFormat.TEXT = "text";
/**
 * Variables / Value Pairs
 * @type {string}
 */
URLLoaderDataFormat.VARIABLES = "variables";
/**
 *
 * @type {string}
 */
URLLoaderDataFormat.BLOB = "blob";
/**
 *
 * @type {string}
 */
URLLoaderDataFormat.ARRAY_BUFFER = "arraybuffer";
/**
 *
 * @type {string}
 */
URLLoaderDataFormat.BINARY = "binary";

var URLRequestMethod = (function () {
    function URLRequestMethod() {
    }
    return URLRequestMethod;
}());
/**
 *
 * @type {string}
 */
URLRequestMethod.POST = 'POST';
/**
 *
 * @type {string}
 */
URLRequestMethod.GET = 'GET';

var URLVariables = (function () {
    /**
     *
     * @param source
     */
    function URLVariables(source) {
        if (source === void 0) { source = null; }
        this._variables = new Object();
        if (source !== null)
            this.decode(source);
    }
    /**
     *
     * @param source
     */
    URLVariables.prototype.decode = function (source) {
        source = source.split("+").join(" ");
        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
        while (tokens = re.exec(source))
            this._variables[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
    };
    /**
     *
     * @returns {string}
     */
    URLVariables.prototype.toString = function () {
        return '';
    };
    Object.defineProperty(URLVariables.prototype, "variables", {
        /**
         *
         * @returns {Object}
         */
        get: function () {
            return this._variables;
        },
        /**
         *
         * @returns {Object}
         */
        set: function (obj) {
            this._variables = obj;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLVariables.prototype, "formData", {
        /**
         *
         * @returns {Object}
         */
        get: function () {
            var fd = new FormData();
            for (var s in this._variables)
                fd.append(s, this._variables[s]);
            return fd;
        },
        enumerable: true,
        configurable: true
    });
    return URLVariables;
}());

/**
 * The URLLoader is used to load a single file, as part of a resource.
 *
 * While URLLoader can be used directly, e.g. to create a third-party asset
 * management system, it's recommended to use any of the classes Loader3D, Loader
 * and AssetLibrary instead in most cases.
 *
 * @see Loader
 * @see away.library.AssetLibrary
 */
var URLLoader = (function (_super) {
    __extends(URLLoader, _super);
    /**
     * Creates a new URLLoader object.
     */
    function URLLoader() {
        var _this = _super.call(this) || this;
        _this._bytesLoaded = 0;
        _this._bytesTotal = 0;
        _this._dataFormat = URLLoaderDataFormat.TEXT;
        _this._loadError = false;
        return _this;
    }
    Object.defineProperty(URLLoader.prototype, "url", {
        /**
         *
         */
        get: function () {
            return this._request ? this._request.url : '';
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "data", {
        /**
         *
         */
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "dataFormat", {
        get: function () {
            return this._dataFormat;
        },
        /**
         *
         * URLLoaderDataFormat.BINARY
         * URLLoaderDataFormat.TEXT
         * URLLoaderDataFormat.VARIABLES
         *
         * @param format
         */
        set: function (format) {
            this._dataFormat = format;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "bytesLoaded", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._bytesLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(URLLoader.prototype, "bytesTotal", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._bytesTotal;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Load a resource from a file.
     *
     * @param request The URLRequest object containing the URL of the object to be loaded.
     */
    URLLoader.prototype.load = function (request) {
        this._request = request;
        this.initXHR();
        if (request.method === URLRequestMethod.POST)
            this.postRequest(request);
        else
            this.getRequest(request);
    };
    URLLoader.prototype.isSupported = function () {
        return window != null;
    };
    /**
     *
     */
    URLLoader.prototype.close = function () {
        this._XHR.abort();
        this.disposeXHR();
    };
    /**
     *
     */
    URLLoader.prototype.dispose = function () {
        if (this._XHR)
            this._XHR.abort();
        this.disposeXHR();
    };
    /**
     *
     * @param xhr
     * @param responseType
     */
    URLLoader.prototype.setResponseType = function (xhr, responseType) {
        switch (responseType) {
            case URLLoaderDataFormat.ARRAY_BUFFER:
            case URLLoaderDataFormat.BLOB:
            case URLLoaderDataFormat.TEXT:
                xhr.responseType = responseType;
                break;
            case URLLoaderDataFormat.VARIABLES:
                xhr.responseType = URLLoaderDataFormat.TEXT;
                break;
            case URLLoaderDataFormat.BINARY:
                xhr.responseType = '';
                break;
            default:
        }
    };
    /**
     *
     * @param request {URLRequest}
     */
    URLLoader.prototype.getRequest = function (request) {
        try {
            this._XHR.open(request.method, request.url, request.async);
            this.setResponseType(this._XHR, this._dataFormat);
            this._XHR.send(); // No data to send
        }
        catch (e /* <XMLHttpRequestException> */) {
            this.handleXmlHttpRequestException(e);
        }
    };
    /**
     *
     * @param request {URLRequest}
     */
    URLLoader.prototype.postRequest = function (request) {
        this._loadError = false;
        this._XHR.open(request.method, request.url, request.async);
        if (request.data != null) {
            if (request.data instanceof URLVariables) {
                var urlVars = request.data;
                try {
                    this._XHR.responseType = 'text';
                    this._XHR.send(urlVars.formData);
                }
                catch (e /* <XMLHttpRequestException> */) {
                    this.handleXmlHttpRequestException(e);
                }
            }
            else {
                this.setResponseType(this._XHR, this._dataFormat);
                if (request.data)
                    this._XHR.send(request.data); // TODO: Test
                else
                    this._XHR.send(); // no data to send
            }
        }
        else {
            this._XHR.send(); // No data to send
        }
    };
    /**
     *
     * @param error {XMLHttpRequestException}
     */
    URLLoader.prototype.handleXmlHttpRequestException = function (error /* <XMLHttpRequestException> */) {
        switch (error.code) {
            /******************************************************************************************************************************************************************************************************
             *
             *  XMLHttpRequestException { message: "NETWORK_ERR: XMLHttpRequest Exception 101", name: "NETWORK_ERR", code: 101, stack: "Error: A network error occurred in synchronous req…",NETWORK_ERR: 101… }
             *  code: 101 , message: "NETWORK_ERR: XMLHttpRequest Exception 101" ,  name: "NETWORK_ERR"
             *
             ******************************************************************************************************************************************************************************************************/
            case 101:
                // Note: onLoadError event throws IO_ERROR event - this case is already Covered
                break;
        }
    };
    /**
     *
     */
    URLLoader.prototype.initXHR = function () {
        var _this = this;
        if (!this._XHR) {
            this._XHR = new XMLHttpRequest();
            this._XHR.onloadstart = function (event) { return _this.onLoadStart(event); }; // loadstart	        - When the request starts.
            this._XHR.onprogress = function (event) { return _this.onProgress(event); }; // progress	            - While loading and sending data.
            this._XHR.onabort = function (event) { return _this.onAbort(event); }; // abort	            - When the request has been aborted, either by invoking the abort() method or navigating away from the page.
            this._XHR.onerror = function (event) { return _this.onLoadError(event); }; // error	            - When the request has failed.
            this._XHR.onload = function (event) { return _this.onLoadComplete(event); }; // load	                - When the request has successfully completed.
            this._XHR.ontimeout = function (event) { return _this.onTimeOut(event); }; // timeout	            - When the author specified timeout has passed before the request could complete.
            this._XHR.onloadend = function (event) { return _this.onLoadEnd(event); }; // loadend	            - When the request has completed, regardless of whether or not it was successful.
            this._XHR.onreadystatechange = function (event) { return _this.onReadyStateChange(event); }; // onreadystatechange   - When XHR state changes
        }
    };
    /**
     *
     */
    URLLoader.prototype.disposeXHR = function () {
        if (this._XHR !== null) {
            this._XHR.onloadstart = null;
            this._XHR.onprogress = null;
            this._XHR.onabort = null;
            this._XHR.onerror = null;
            this._XHR.onload = null;
            this._XHR.ontimeout = null;
            this._XHR.onloadend = null;
            this._XHR = null;
        }
    };
    /**
     *
     * @param source
     */
    URLLoader.prototype.decodeURLVariables = function (source) {
        var result = new Object();
        source = source.split("+").join(" ");
        var tokens, re = /[?&]?([^=]+)=([^&]*)/g;
        while (tokens = re.exec(source))
            result[decodeURIComponent(tokens[1])] = decodeURIComponent(tokens[2]);
        return result;
    };
    // XMLHttpRequest - Event Handlers
    /**
     * When XHR state changes
     * @param event
     */
    URLLoader.prototype.onReadyStateChange = function (event) {
        if (this._XHR.readyState == 4) {
            this._status = this._XHR.status;
            if (this._status == 404) {
                this._loadError = true;
                this.dispatchEvent(this._loadErrorEvent || (this._loadErrorEvent = new URLLoaderEvent(URLLoaderEvent.LOAD_ERROR, this)));
            }
            this.dispatchEvent(this._statusEvent || (this._statusEvent = new URLLoaderEvent(URLLoaderEvent.HTTP_STATUS, this)));
        }
    };
    /**
     * When the request has completed, regardless of whether or not it was successful.
     * @param event
     */
    URLLoader.prototype.onLoadEnd = function (event) {
        if (this._loadError === true)
            return;
    };
    /**
     * When the author specified timeout has passed before the request could complete.
     * @param event
     */
    URLLoader.prototype.onTimeOut = function (event) {
        //TODO: Timeout not currently implemented ( also not part of AS3 API )
    };
    /**
     * When the request has been aborted, either by invoking the abort() method or navigating away from the page.
     * @param event
     */
    URLLoader.prototype.onAbort = function (event) {
        // TODO: investigate whether this needs to be an IOError
    };
    /**
     * While loading and sending data.
     * @param event
     */
    URLLoader.prototype.onProgress = function (event) {
        this._bytesTotal = event.total;
        this._bytesLoaded = event.loaded;
        this.dispatchEvent(this._progressEvent || (this._progressEvent = new URLLoaderEvent(URLLoaderEvent.LOAD_PROGRESS, this)));
    };
    /**
     * When the request starts.
     * @param event
     */
    URLLoader.prototype.onLoadStart = function (event) {
        this.dispatchEvent(this._loadStartEvent || (this._loadStartEvent = new URLLoaderEvent(URLLoaderEvent.LOAD_START, this)));
    };
    /**
     * When the request has successfully completed.
     * @param event
     */
    URLLoader.prototype.onLoadComplete = function (event) {
        if (this._loadError === true)
            return;
        switch (this._dataFormat) {
            case URLLoaderDataFormat.TEXT:
                this._data = this._XHR.responseText;
                break;
            case URLLoaderDataFormat.VARIABLES:
                this._data = this.decodeURLVariables(this._XHR.responseText);
                break;
            case URLLoaderDataFormat.BLOB:
            case URLLoaderDataFormat.ARRAY_BUFFER:
            case URLLoaderDataFormat.BINARY:
                this._data = this._XHR.response;
                break;
            default:
                this._data = this._XHR.responseText;
                break;
        }
        this.dispatchEvent(this._loadCompleteEvent || (this._loadCompleteEvent = new URLLoaderEvent(URLLoaderEvent.LOAD_COMPLETE, this)));
    };
    /**
     * When the request has failed. ( due to network issues ).
     * @param event
     */
    URLLoader.prototype.onLoadError = function (event) {
        this._loadError = true;
        this.dispatchEvent(this._loadErrorEvent || (this._loadErrorEvent = new URLLoaderEvent(URLLoaderEvent.LOAD_ERROR, this)));
    };
    return URLLoader;
}(EventDispatcher));

/**
 * ResourceDependency represents the data required to load, parse and resolve additional files ("dependencies")
 * required by a parser, used by ResourceLoadSession.
 *
 */
var ResourceDependency = (function () {
    function ResourceDependency(id, request, data, parser, parentParser, retrieveAsRawData, suppressAssetEvents, sub_id) {
        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
        if (suppressAssetEvents === void 0) { suppressAssetEvents = false; }
        if (sub_id === void 0) { sub_id = 0; }
        this._id = id;
        this._sub_id = sub_id;
        this._request = request;
        this._data = data;
        this._parser = parser;
        this._parentParser = parentParser;
        this._retrieveAsRawData = retrieveAsRawData;
        this._suppressAssetEvents = suppressAssetEvents;
        this._assets = new Array();
        this._dependencies = new Array();
    }
    Object.defineProperty(ResourceDependency.prototype, "id", {
        /**
         *
         */
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "sub_id", {
        get: function () {
            return this._sub_id;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "request", {
        /**
         *
         */
        get: function () {
            return this._request;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "data", {
        /**
         * The data containing the dependency to be parsed, if the resource was already loaded.
         */
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "parser", {
        /**
         *
         */
        get: function () {
            return this._parser;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "parentParser", {
        /**
         * The parser which is dependent on this ResourceDependency object.
         */
        get: function () {
            return this._parentParser;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "retrieveAsRawData", {
        /**
         *
         */
        get: function () {
            return this._retrieveAsRawData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "suppresAssetEvents", {
        /**
         *
         */
        get: function () {
            return this._suppressAssetEvents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "assets", {
        /**
         *
         */
        get: function () {
            return this._assets;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResourceDependency.prototype, "dependencies", {
        /**
         *
         */
        get: function () {
            return this._dependencies;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @private
     * Method to set data after having already created the dependency object, e.g. after load.
     */
    ResourceDependency.prototype._iSetData = function (data) {
        this._data = data;
    };
    /**
     * @private
     *
     */
    ResourceDependency.prototype._iSetParser = function (parser) {
        this._parser = parser;
    };
    /**
     * Resolve the dependency when it's loaded with the parent parser. For example, a dependency containing an
     * ImageResource would be assigned to a Mesh instance as a BitmapMaterial, a scene graph object would be added
     * to its intended parent. The dependency should be a member of the dependencies property.
     */
    ResourceDependency.prototype.resolve = function () {
        if (this._parentParser)
            this._parentParser._iResolveDependency(this);
    };
    /**
     * Resolve a dependency failure. For example, map loading failure from a 3d file
     */
    ResourceDependency.prototype.resolveFailure = function () {
        if (this._parentParser)
            this._parentParser._iResolveDependencyFailure(this);
    };
    /**
     * Resolve the dependencies name
     */
    ResourceDependency.prototype.resolveName = function (asset) {
        if (this._parentParser)
            return this._parentParser._iResolveDependencyName(this, asset);
        return asset.name;
    };
    return ResourceDependency;
}());

/**
 * Dispatched when any asset finishes parsing. Also see specific events for each
 * individual asset type (meshes, materials et c.)
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="assetComplete", type="away3d.events.AssetEvent")]
/**
 * Dispatched when a full resource (including dependencies) finishes loading.
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="resourceComplete", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when a single dependency (which may be the main file of a resource)
 * finishes loading.
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="dependencyComplete", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when an error occurs during loading. I
 *
 * @eventType away.events.LoaderEvent
 */
//[Event(name="loadError", type="away3d.events.LoaderEvent")]
/**
 * Dispatched when an error occurs during parsing.
 *
 * @eventType away.events.ParserEvent
 */
//[Event(name="parseError", type="away3d.events.ParserEvent")]
/**
 * Dispatched when an image asset dimensions are not a power of 2
 *
 * @eventType away.events.AssetEvent
 */
//[Event(name="textureSizeError", type="away3d.events.AssetEvent")]
/**
 * Loader can load any file format that away.supports (or for which a third-party parser
 * has been plugged in) and it's dependencies. Events are dispatched when assets are encountered
 * and for when the resource (or it's dependencies) have been loaded.
 *
 * The Loader will not make assets available in any other way than through the dispatched
 * events. To store assets and make them available at any point from any module in an application,
 * use the AssetLibrary to load and manage assets.
 *
 * @see away.library.AssetLibrary
 */
var Loader = (function (_super) {
    __extends(Loader, _super);
    /**
     * Create a new ResourceLoadSession object.
     */
    function Loader(materialMode) {
        if (materialMode === void 0) { materialMode = 0; }
        var _this = _super.call(this) || this;
        _this._materialMode = materialMode;
        _this._stack = new Array();
        _this._errorHandlers = new Array();
        _this._parseErrorHandlers = new Array();
        _this._onReadyForDependenciesDelegate = function (event) { return _this.onReadyForDependencies(event); };
        _this._onParseCompleteDelegate = function (event) { return _this.onParseComplete(event); };
        _this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
        _this._onLoadProgressDelegate = function (event) { return _this.onLoadProgress(event); };
        _this._onLoadCompleteDelegate = function (event) { return _this.onLoadComplete(event); };
        _this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
        _this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
        _this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
        return _this;
    }
    /**
     * Enables a specific parser.
     * When no specific parser is set for a loading/parsing opperation,
     * loader3d can autoselect the correct parser to use.
     * A parser must have been enabled, to be considered when autoselecting the parser.
     *
     * @param parser The parser export class to enable.
     *
     * @see away.parsers.Parsers
     */
    Loader.enableParser = function (parser) {
        if (Loader._parsers.indexOf(parser) < 0)
            Loader._parsers.push(parser);
    };
    /**
     * Enables a list of parsers.
     * When no specific parser is set for a loading/parsing opperation,
     * Loader can autoselect the correct parser to use.
     * A parser must have been enabled, to be considered when autoselecting the parser.
     *
     * @param parsers A Vector of parser classes to enable.
     * @see away.parsers.Parsers
     */
    Loader.enableParsers = function (parsers) {
        for (var c = 0; c < parsers.length; c++)
            Loader.enableParser(parsers[c]);
    };
    Object.defineProperty(Loader.prototype, "baseDependency", {
        /**
         * Returns the base dependency of the loader
         */
        get: function () {
            return this._baseDependency;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Loader.prototype, "loaderInfo", {
        /**
         * Returns a LoaderInfo object corresponding to the object being loaded.
         * LoaderInfo objects are shared between the Loader object and the loaded
         * content object. The LoaderInfo object supplies loading progress
         * information and statistics about the loaded file.
         *
         * <p>Events related to the load are dispatched by the LoaderInfo object
         * referenced by the <code>contentLoaderInfo</code> property of the Loader
         * object. The <code>contentLoaderInfo</code> property is set to a valid
         * LoaderInfo object, even before the content is loaded, so that you can add
         * event listeners to the object prior to the load.</p>
         *
         * <p>To detect uncaught errors that happen in a loaded SWF, use the
         * <code>Loader.uncaughtErrorEvents</code> property, not the
         * <code>Loader.contentLoaderInfo.uncaughtErrorEvents</code> property.</p>
         */
        get: function () {
            return this._loaderInfo;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Loads a file and (optionally) all of its dependencies.
     *
     * @param req The URLRequest object containing the URL of the file to be loaded.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
     */
    Loader.prototype.load = function (req, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        this._uri = req.url = req.url.replace(/\\/g, "/");
        this._context = context;
        this._namespace = ns;
        this._baseDependency = new ResourceDependency('', req, null, parser, null);
        this.retrieveDependency(this._baseDependency);
    };
    /**
     * Loads a resource from already loaded data.
     *
     * @param data The data object containing all resource information.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
     */
    Loader.prototype.loadData = function (data, id, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        this._uri = id;
        this._context = context;
        this._namespace = ns;
        this._baseDependency = new ResourceDependency(id, null, data, parser, null);
        this.retrieveDependency(this._baseDependency);
    };
    /**
     * Recursively retrieves the next to-be-loaded and parsed dependency on the stack, or pops the list off the
     * stack when complete and continues on the top set.
     * @param parser The parser that will translate the data into a usable resource.
     */
    Loader.prototype.retrieveNext = function (parser) {
        if (parser === void 0) { parser = null; }
        if (this._currentDependency.dependencies.length) {
            var next = this._currentDependency.dependencies.pop();
            this._stack.push(this._currentDependency);
            this.retrieveDependency(next);
        }
        else if (this._currentDependency.parser && this._currentDependency.parser.parsingPaused) {
            this._currentDependency.parser._iResumeParsing();
        }
        else if (this._stack.length) {
            var prev = this._currentDependency;
            this._currentDependency = this._stack.pop();
            if (prev._iSuccess)
                prev.resolve();
            this.retrieveNext(parser);
        }
        else {
            this.dispatchEvent(new LoaderEvent(LoaderEvent.LOAD_COMPLETE, this._uri, this._baseDependency.parser.content, this._baseDependency.assets));
        }
    };
    /**
     * Retrieves a single dependency.
     * @param parser The parser that will translate the data into a usable resource.
     */
    Loader.prototype.retrieveDependency = function (dependency) {
        var data;
        if (this._context && this._context.materialMode != 0)
            this._materialMode = this._context.materialMode;
        this._currentDependency = dependency;
        dependency._iLoader = new URLLoader();
        this.addEventListeners(dependency._iLoader);
        // Get already loaded (or mapped) data if available
        data = dependency.data;
        if (this._context && dependency.request) {
            if (this._context._iHasDataForUrl(dependency.request.url)) {
                data = this._context._iGetDataForUrl(dependency.request.url);
            }
            else if (this._context.externalAssetMode == LoaderContext.ON_DEMAND && (this.getSuffix(dependency.request.url) == "jpg" || this.getSuffix(dependency.request.url) == "png")) {
                data = dependency.request;
                if (!dependency.parser)
                    dependency._iSetParser(this.getParserFromSuffix(dependency.request.url));
            }
        }
        if (data) {
            if (data.constructor === Function)
                data = new data();
            dependency._iSetData(data);
            if (dependency.retrieveAsRawData) {
                // No need to parse. The parent parser is expecting this
                // to be raw data so it can be passed directly.
                dependency.resolve();
                // Move on to next dependency
                this.retrieveNext();
            }
            else {
                this.parseDependency(dependency);
            }
        }
        else {
            // Resolve URL and start loading
            dependency.request.url = this.resolveDependencyUrl(dependency);
            if (dependency.retrieveAsRawData) {
                // Always use binary for raw data loading
                dependency._iLoader.dataFormat = URLLoaderDataFormat.BINARY;
            }
            else {
                if (!dependency.parser)
                    dependency._iSetParser(this.getParserFromSuffix(dependency.request.url));
                if (dependency.parser) {
                    dependency._iLoader.dataFormat = dependency.parser.dataFormat;
                }
                else {
                    // Always use BINARY for unknown file formats. The thorough
                    // file type check will determine format after load, and if
                    // binary, a text load will have broken the file data.
                    dependency._iLoader.dataFormat = URLLoaderDataFormat.BINARY;
                }
            }
            dependency._iLoader.load(dependency.request);
        }
    };
    Loader.prototype.joinUrl = function (base, end) {
        if (end.charAt(0) == '/' || end.charAt(0) == '\\')
            end = end.substr(1);
        if (end.charAt(0) == '.')
            end = end.substr(2);
        if (base.length == 0)
            return end;
        if (base.charAt(base.length - 1) == '/' || base.charAt(base.length - 1) == '\\')
            base = base.substr(0, base.length - 1);
        return base.concat('/', end);
    };
    Loader.prototype.resolveDependencyUrl = function (dependency) {
        var scheme_re;
        var base;
        var url = dependency.request.url;
        // Has the user re-mapped this URL?
        if (this._context && this._context._iHasMappingForUrl(url))
            return this._context._iGetRemappedUrl(url);
        // This is the "base" dependency, i.e. the actual requested asset.
        // We will not try to resolve this since the user can probably be
        // thrusted to know this URL better than our automatic resolver. :)
        if (url == this._uri)
            return url;
        // Absolute URL? Check if starts with slash or a URL
        // scheme definition (e.g. ftp://, http://, file://)
        scheme_re = new RegExp('/^[a-zA-Z]{3,4}:\/\//');
        if (url.charAt(0) == '/') {
            if (this._context && this._context.overrideAbsolutePaths)
                return this.joinUrl(this._context.dependencyBaseUrl, url);
            else
                return url;
        }
        else if (scheme_re.test(url)) {
            // If overriding full URLs, get rid of scheme (e.g. "http://")
            // and replace with the dependencyBaseUrl defined by user.
            if (this._context && this._context.overrideFullURLs) {
                var noscheme_url = url.replace(scheme_re, ''); //url['replace'](scheme_re);
                return this.joinUrl(this._context.dependencyBaseUrl, noscheme_url);
            }
        }
        // Since not absolute, just get rid of base file name to find it's
        // folder and then concatenate dynamic URL
        if (this._context && this._context.dependencyBaseUrl) {
            base = this._context.dependencyBaseUrl;
            return this.joinUrl(base, url);
        }
        else {
            base = this._uri.substring(0, this._uri.lastIndexOf('/') + 1);
            return this.joinUrl(base, url);
        }
    };
    Loader.prototype.retrieveParserDependencies = function () {
        if (!this._currentDependency)
            return;
        var parserDependancies = this._currentDependency.parser.dependencies;
        var i, len = parserDependancies.length;
        for (i = 0; i < len; i++)
            this._currentDependency.dependencies[i] = parserDependancies[i];
        // Since more dependencies might be added eventually, empty this
        // list so that the same dependency isn't retrieved more than once.
        parserDependancies.length = 0;
        this._stack.push(this._currentDependency);
        this.retrieveNext();
    };
    Loader.prototype.resolveParserDependencies = function () {
        this._currentDependency._iSuccess = true;
        // Retrieve any last dependencies remaining on this parser, or
        // if none exists, just move on.
        if (this._currentDependency.parser && this._currentDependency.parser.dependencies.length && (!this._context || this._context.includeDependencies))
            this.retrieveParserDependencies();
        else
            this.retrieveNext();
    };
    /**
     * Called when a single dependency loading failed, and pushes further dependencies onto the stack.
     * @param event
     */
    Loader.prototype.onLoadError = function (event) {
        var handled;
        var isDependency = (this._currentDependency != this._baseDependency);
        var loader = event.urlLoader;
        this.removeEventListeners(loader);
        if (this.hasEventListener(URLLoaderEvent.LOAD_ERROR)) {
            this.dispatchEvent(event);
            handled = true;
        }
        else {
            // TODO: Consider not doing this even when Loader does have it's own LOAD_ERROR listener
            var i, len = this._errorHandlers.length;
            for (i = 0; i < len; i++)
                if (!handled)
                    handled = this._errorHandlers[i](event);
        }
        if (handled) {
            //if (isDependency && ! event.isDefaultPrevented()) {
            if (isDependency) {
                this._currentDependency.resolveFailure();
                this.retrieveNext();
            }
            else {
                // Either this was the base file (last left in the stack) or
                // default behavior was prevented by the handlers, and hence
                // there is nothing more to do than clean up and bail.
                this.dispose();
                return;
            }
        }
        else {
            // Error event was not handled by listeners directly on Loader or
            // on any of the subscribed loaders (in the list of error handlers.)
            throw new Error();
        }
    };
    /**
     * Called when a dependency parsing failed, and dispatches a <code>ParserEvent.PARSE_ERROR</code>
     * @param event
     */
    Loader.prototype.onParseError = function (event) {
        var handled;
        var isDependency = (this._currentDependency != this._baseDependency);
        var loader = event.target;
        this.removeEventListeners(loader);
        if (this.hasEventListener(ParserEvent.PARSE_ERROR)) {
            this.dispatchEvent(event);
            handled = true;
        }
        else {
            // TODO: Consider not doing this even when Loader does
            // have it's own LOAD_ERROR listener
            var i, len = this._parseErrorHandlers.length;
            for (i = 0; i < len; i++)
                if (!handled)
                    handled = this._parseErrorHandlers[i](event);
        }
        if (handled) {
            this.retrieveNext();
        }
        else {
            // Error event was not handled by listeners directly on Loader or
            // on any of the subscribed loaders (in the list of error handlers.)
            throw new Error(event.message);
        }
    };
    Loader.prototype.onAssetComplete = function (event) {
        // Add loaded asset to list of assets retrieved as part
        // of the current dependency. This list will be inspected
        // by the parent parser when dependency is resolved
        if (this._currentDependency)
            this._currentDependency.assets.push(event.asset);
        event.asset.resetAssetPath(event.asset.name, this._namespace);
        if (!this._currentDependency.suppresAssetEvents)
            this.dispatchEvent(event);
    };
    Loader.prototype.onReadyForDependencies = function (event) {
        var parser = event.target;
        if (this._context && !this._context.includeDependencies)
            parser._iResumeParsing();
        else
            this.retrieveParserDependencies();
    };
    Loader.prototype.onLoadProgress = function (event) {
        this.dispatchEvent(event);
    };
    /**
     * Called when a single dependency was parsed, and pushes further dependencies onto the stack.
     * @param event
     */
    Loader.prototype.onLoadComplete = function (event) {
        var loader = event.urlLoader;
        this.removeEventListeners(loader);
        // Resolve this dependency
        this._currentDependency._iSetData(loader.data);
        if (this._currentDependency.retrieveAsRawData) {
            // No need to parse this data, which should be returned as is
            this.resolveParserDependencies();
        }
        else {
            this.parseDependency(this._currentDependency);
        }
    };
    /**
     * Called when parsing is complete.
     */
    Loader.prototype.onParseComplete = function (event) {
        var parser = event.target;
        parser.removeEventListener(ParserEvent.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
        parser.removeEventListener(ParserEvent.PARSE_COMPLETE, this._onParseCompleteDelegate);
        parser.removeEventListener(ParserEvent.PARSE_ERROR, this._onParseErrorDelegate);
        parser.removeEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        parser.removeEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        this.resolveParserDependencies();
    };
    /**
     * Called when an image is too large or it's dimensions are not a power of 2
     * @param event
     */
    Loader.prototype.onTextureSizeError = function (event) {
        event.asset.name = this._currentDependency.resolveName(event.asset);
        this.dispatchEvent(event);
    };
    Loader.prototype.addEventListeners = function (loader) {
        loader.addEventListener(URLLoaderEvent.LOAD_PROGRESS, this._onLoadProgressDelegate);
        loader.addEventListener(URLLoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
        loader.addEventListener(URLLoaderEvent.LOAD_ERROR, this._onLoadErrorDelegate);
    };
    Loader.prototype.removeEventListeners = function (loader) {
        loader.removeEventListener(URLLoaderEvent.LOAD_PROGRESS, this._onLoadProgressDelegate);
        loader.removeEventListener(URLLoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
        loader.removeEventListener(URLLoaderEvent.LOAD_ERROR, this._onLoadErrorDelegate);
    };
    Loader.prototype.stop = function () {
        this.dispose();
    };
    Loader.prototype.dispose = function () {
        this._errorHandlers = null;
        this._parseErrorHandlers = null;
        this._context = null;
        this._stack = null;
        if (this._currentDependency && this._currentDependency._iLoader)
            this.removeEventListeners(this._currentDependency._iLoader);
        this._currentDependency = null;
    };
    /**
     * @private
     * This method is used by other loader classes (e.g. Loader3D and AssetLibraryBundle) to
     * add error event listeners to the Loader instance. This system is used instead of
     * the regular EventDispatcher system so that the AssetLibrary error handler can be sure
     * that if hasEventListener() returns true, it's client code that's listening for the
     * event. Secondly, functions added as error handler through this custom method are
     * expected to return a boolean value indicating whether the event was handled (i.e.
     * whether they in turn had any client code listening for the event.) If no handlers
     * return true, the Loader knows that the event wasn't handled and will throw an RTE.
     */
    Loader.prototype._iAddParseErrorHandler = function (handler) {
        if (this._parseErrorHandlers.indexOf(handler) < 0)
            this._parseErrorHandlers.push(handler);
    };
    Loader.prototype._iAddErrorHandler = function (handler) {
        if (this._errorHandlers.indexOf(handler) < 0)
            this._errorHandlers.push(handler);
    };
    /**
     * Guesses the parser to be used based on the file contents.
     * @param data The data to be parsed.
     * @param uri The url or id of the object to be parsed.
     * @return An instance of the guessed parser.
     */
    Loader.prototype.getParserFromData = function (data) {
        var len = Loader._parsers.length;
        // go in reverse order to allow application override of default parser added in away.proper
        for (var i = len - 1; i >= 0; i--)
            if (Loader._parsers[i].supportsData(data))
                return new Loader._parsers[i]();
        return null;
    };
    /**
     * Initiates parsing of the loaded dependency.
     *
     * @param The dependency to be parsed.
     */
    Loader.prototype.parseDependency = function (dependency) {
        var parser = dependency.parser;
        // If no parser has been defined, try to find one by letting
        // all plugged in parsers inspect the actual data.
        if (!parser)
            dependency._iSetParser(parser = this.getParserFromData(dependency.data));
        if (parser) {
            parser.addEventListener(ParserEvent.READY_FOR_DEPENDENCIES, this._onReadyForDependenciesDelegate);
            parser.addEventListener(ParserEvent.PARSE_COMPLETE, this._onParseCompleteDelegate);
            parser.addEventListener(ParserEvent.PARSE_ERROR, this._onParseErrorDelegate);
            parser.addEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
            parser.addEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
            if (dependency.request && dependency.request.url)
                parser._iFileName = dependency.request.url;
            parser.materialMode = this._materialMode;
            parser.parseAsync(dependency.data);
        }
        else {
            var handled;
            var message = "No parser defined. To enable all parsers for auto-detection, use Parsers.enableAllBundled()";
            var event = new ParserEvent(ParserEvent.PARSE_ERROR, message);
            if (this.hasEventListener(ParserEvent.PARSE_ERROR)) {
                this.dispatchEvent(event);
                handled = true;
            }
            else {
                // TODO: Consider not doing this even when Loader does
                // have it's own LOAD_ERROR listener
                var i, len = this._parseErrorHandlers.length;
                for (i = 0; i < len; i++)
                    if (!handled)
                        handled = this._parseErrorHandlers[i](event);
            }
            if (handled) {
                this.retrieveNext();
            }
            else {
                // Error event was not handled by listeners directly on Loader or
                // on any of the subscribed loaders (in the list of error handlers.)
                throw new Error(message);
            }
        }
    };
    /**
     * Guesses the parser to be used based on the file extension.
     * @return An instance of the guessed parser.
     */
    Loader.prototype.getParserFromSuffix = function (url) {
        var fileExtension = this.getSuffix(url);
        var len = Loader._parsers.length;
        // go in reverse order to allow application override of default parser added in away.proper
        for (var i = len - 1; i >= 0; i--) {
            var parserClass = Loader._parsers[i];
            if (parserClass.supportsType(fileExtension))
                return new parserClass();
        }
        return null;
    };
    Loader.prototype.getSuffix = function (url) {
        // Get rid of query string if any and extract extension
        var base = (url.indexOf('?') > 0) ? url.split('?')[0] : url;
        return base.substr(base.lastIndexOf('.') + 1).toLowerCase();
    };
    return Loader;
}(EventDispatcher));
// Image parser only parser that is added by default, to save file size.
Loader._parsers = new Array();

/**
 * Enumaration export class for precedence when resolving naming conflicts in the library.
 *
 * @see away.library.AssetLibrary.conflictPrecedence
 * @see away.library.AssetLibrary.conflictStrategy
 * @see away.library.naming.ConflictStrategy
 */
var ConflictPrecedence = (function () {
    function ConflictPrecedence() {
    }
    return ConflictPrecedence;
}());
/**
 * Signals that in a conflict, the previous owner of the conflicting name
 * should be favored (and keep it's name) and that the newly renamed asset
 * is reverted to a non-conflicting name.
 */
ConflictPrecedence.FAVOR_OLD = 'favorOld';
/**
 * Signales that in a conflict, the newly renamed asset is favored (and keeps
 * it's newly defined name) and that the previous owner of that name gets
 * renamed to a non-conflicting name.
 */
ConflictPrecedence.FAVOR_NEW = 'favorNew';

/**
 * Abstract base export class for naming conflict resolution classes. Extend this to create a
 * strategy export class which the asset library can use to resolve asset naming conflicts, or
 * use one of the bundled concrete strategy classes:
 *
 * <ul>
 *   <li>IgnoreConflictStrategy (ConflictStrategy.IGNORE)</li>
 *   <li>ErrorConflictStrategy (ConflictStrategy.THROW_ERROR)</li>
 *   <li>NumSuffixConflictStrategy (ConflictStrategy.APPEND_NUM_SUFFIX)</li>
 * </ul>
 *
 * @see away.library.AssetLibrary.conflictStrategy
 * @see away.library.ConflictStrategy
 * @see away.library.IgnoreConflictStrategy
 * @see away.library.ErrorConflictStrategy
 * @see away.library.NumSuffixConflictStrategy
 */
var ConflictStrategyBase = (function () {
    function ConflictStrategyBase() {
    }
    /**
     * Resolve a naming conflict between two assets. Must be implemented by concrete strategy
     * classes.
     */
    ConflictStrategyBase.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        throw new AbstractMethodError();
    };
    /**
     * Create instance of this conflict strategy. Used internally by the AssetLibrary to
     * make sure the same strategy instance is not used in all AssetLibrary instances, which
     * would break any state caching that happens inside the strategy class.
     */
    ConflictStrategyBase.prototype.create = function () {
        throw new AbstractMethodError();
    };
    /**
     * Provided as a convenience method for all conflict strategy classes, as a way to finalize
     * the conflict resolution by applying the new names and dispatching the correct events.
     */
    ConflictStrategyBase.prototype._pUpdateNames = function (ns, nonConflictingName, oldAsset, newAsset, assetsDictionary, precedence) {
        var loser_prev_name;
        var winner;
        var loser;
        winner = (precedence === ConflictPrecedence.FAVOR_NEW) ? newAsset : oldAsset;
        loser = (precedence === ConflictPrecedence.FAVOR_NEW) ? oldAsset : newAsset;
        loser_prev_name = loser.adaptee.name;
        assetsDictionary[winner.adaptee.name] = winner;
        assetsDictionary[nonConflictingName] = loser;
        loser.adaptee.resetAssetPath(nonConflictingName, ns, false);
        loser.adaptee.dispatchEvent(new AssetEvent(AssetEvent.ASSET_CONFLICT_RESOLVED, loser.adaptee, loser_prev_name));
    };
    return ConflictStrategyBase;
}());

var ErrorConflictStrategy = (function (_super) {
    __extends(ErrorConflictStrategy, _super);
    function ErrorConflictStrategy() {
        return _super.call(this) || this;
    }
    ErrorConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        throw new ErrorBase('Asset name collision while AssetLibrary.namingStrategy set to AssetLibrary.THROW_ERROR. Asset path: ' + changedAsset.adaptee.assetFullPath);
    };
    ErrorConflictStrategy.prototype.create = function () {
        return new ErrorConflictStrategy();
    };
    return ErrorConflictStrategy;
}(ConflictStrategyBase));

var IgnoreConflictStrategy = (function (_super) {
    __extends(IgnoreConflictStrategy, _super);
    function IgnoreConflictStrategy() {
        return _super.call(this) || this;
    }
    IgnoreConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        // Do nothing, ignore the fact that there is a conflict.
        return;
    };
    IgnoreConflictStrategy.prototype.create = function () {
        return new IgnoreConflictStrategy();
    };
    return IgnoreConflictStrategy;
}(ConflictStrategyBase));

var NumSuffixConflictStrategy = (function (_super) {
    __extends(NumSuffixConflictStrategy, _super);
    function NumSuffixConflictStrategy(separator) {
        if (separator === void 0) { separator = '.'; }
        var _this = _super.call(this) || this;
        _this._separator = separator;
        _this._next_suffix = {};
        return _this;
    }
    NumSuffixConflictStrategy.prototype.resolveConflict = function (changedAsset, oldAsset, assetsDictionary, precedence) {
        var orig;
        var new_name;
        var base;
        var suffix;
        orig = changedAsset.adaptee.name;
        if (orig.indexOf(this._separator) >= 0) {
            // Name has an ocurrence of the separator, so get base name and suffix,
            // unless suffix is non-numerical, in which case revert to zero and
            // use entire name as base
            base = orig.substring(0, orig.lastIndexOf(this._separator));
            suffix = parseInt(orig.substring(base.length - 1));
            if (isNaN(suffix)) {
                base = orig;
                suffix = 0;
            }
        }
        else {
            base = orig;
            suffix = 0;
        }
        if (suffix == 0 && this._next_suffix.hasOwnProperty(base)) {
            suffix = this._next_suffix[base];
        }
        // Find the first suffixed name that does
        // not collide with other names.
        do {
            suffix++;
            new_name = base.concat(this._separator, suffix.toString());
        } while (assetsDictionary.hasOwnProperty(new_name));
        this._next_suffix[base] = suffix;
        this._pUpdateNames(oldAsset.adaptee.assetNamespace, new_name, oldAsset, changedAsset, assetsDictionary, precedence);
    };
    NumSuffixConflictStrategy.prototype.create = function () {
        return new NumSuffixConflictStrategy(this._separator);
    };
    return NumSuffixConflictStrategy;
}(ConflictStrategyBase));

/**
 * Enumeration export class for bundled conflict strategies. Set one of these values (or an
 * instance of a self-defined sub-export class of ConflictStrategyBase) to the conflictStrategy
 * property on an AssetLibrary to define how that library resolves naming conflicts.
 *
 * The value of the <code>AssetLibrary.conflictPrecedence</code> property defines which
 * of the conflicting assets will get to keep it's name, and which is renamed (if any.)
 *
 * @see away.library.AssetLibrary.conflictStrategy
 * @see away.library.naming.ConflictStrategyBase
 */
var ConflictStrategy = (function () {
    function ConflictStrategy(include) {
        //TODO: find out why typescript d.ts files do not include this class
    }
    return ConflictStrategy;
}());
/**
 * Specifies that in case of a naming conflict, one of the assets will be renamed and
 * a numeric suffix appended to the base name.
 */
ConflictStrategy.APPEND_NUM_SUFFIX = new NumSuffixConflictStrategy();
/**
 * Specifies that naming conflicts should be ignored. This is not recommended in most
 * cases, unless it can be 100% guaranteed that the application does not cause naming
 * conflicts in the library (i.e. when an app-level system is in place to prevent this.)
 */
ConflictStrategy.IGNORE = new IgnoreConflictStrategy();
/**
 * Specifies that an error should be thrown if a naming conflict is discovered. Use this
 * to be 100% sure that naming conflicts never occur unnoticed, and when it's undesirable
 * to have the library automatically rename assets to avoid such conflicts.
 */
ConflictStrategy.THROW_ERROR = new ErrorConflictStrategy();

/**
 * AssetLibraryBundle enforces a multiton pattern and is not intended to be instanced directly.
 * Its purpose is to create a container for 3D data management, both before and after parsing.
 * If you are interested in creating multiple library bundles, please use the <code>getInstance()</code> method.
 */
var AssetLibraryBundle = (function (_super) {
    __extends(AssetLibraryBundle, _super);
    /**
     * Creates a new <code>AssetLibraryBundle</code> object.
     *
     * @param me A multiton enforcer for the AssetLibraryBundle ensuring it cannnot be instanced.
     */
    function AssetLibraryBundle() {
        var _this = _super.call(this) || this;
        _this._loaderSessionsGarbage = new Array();
        _this._assets = new Array(); //new Vector.<IAsset>;
        _this._assetDictionary = new Object();
        _this._loaderSessions = new Array();
        _this.conflictStrategy = ConflictStrategy.IGNORE.create();
        _this.conflictPrecedence = ConflictPrecedence.FAVOR_NEW;
        _this._onAssetRenameDelegate = function (event) { return _this.onAssetRename(event); };
        _this._onAssetConflictResolvedDelegate = function (event) { return _this.onAssetConflictResolved(event); };
        _this._onLoadCompleteDelegate = function (event) { return _this.onLoadComplete(event); };
        _this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
        _this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
        _this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
        _this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
        return _this;
    }
    /**
     * Returns an AssetLibraryBundle instance. If no key is given, returns the default bundle instance (which is
     * similar to using the AssetLibraryBundle as a singleton.) To keep several separated library bundles,
     * pass a string key to this method to define which bundle should be returned. This is
     * referred to as using the AssetLibrary as a multiton.
     *
     * @param key Defines which multiton instance should be returned.
     * @return An instance of the asset library
     */
    AssetLibraryBundle.getInstance = function (key) {
        if (key === void 0) { key = 'default'; }
        if (!key)
            key = 'default';
        if (!AssetLibraryBundle._iInstances.hasOwnProperty(key))
            AssetLibraryBundle._iInstances[key] = new AssetLibraryBundle();
        return AssetLibraryBundle._iInstances[key];
    };
    /**
     *
     */
    AssetLibraryBundle.prototype.enableParser = function (parserClass) {
        Loader.enableParser(parserClass);
    };
    /**
     *
     */
    AssetLibraryBundle.prototype.enableParsers = function (parserClasses) {
        Loader.enableParsers(parserClasses);
    };
    Object.defineProperty(AssetLibraryBundle.prototype, "conflictStrategy", {
        /**
         * Defines which strategy should be used for resolving naming conflicts, when two library
         * assets are given the same name. By default, <code>ConflictStrategy.APPEND_NUM_SUFFIX</code>
         * is used which means that a numeric suffix is appended to one of the assets. The
         * <code>conflictPrecedence</code> property defines which of the two conflicting assets will
         * be renamed.
         *
         * @see naming.ConflictStrategy
         * @see AssetLibrary.conflictPrecedence
         */
        get: function () {
            return this._strategy;
        },
        set: function (val) {
            if (!val)
                throw new ErrorBase('namingStrategy must not be null. To ignore naming, use AssetLibrary.IGNORE');
            this._strategy = val.create();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetLibraryBundle.prototype, "conflictPrecedence", {
        /**
         * Defines which asset should have precedence when resolving a naming conflict between
         * two assets of which one has just been renamed by the user or by a parser. By default
         * <code>ConflictPrecedence.FAVOR_NEW</code> is used, meaning that the newly renamed
         * asset will keep it's new name while the older asset gets renamed to not conflict.
         *
         * This property is ignored for conflict strategies that do not actually rename an
         * asset automatically, such as ConflictStrategy.IGNORE and ConflictStrategy.THROW_ERROR.
         *
         * @see away.library.ConflictPrecedence
         * @see away.library.ConflictStrategy
         */
        get: function () {
            return this._strategyPreference;
        },
        set: function (val) {
            this._strategyPreference = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Create an AssetLibraryIterator instance that can be used to iterate over the assets
     * in this asset library instance. The iterator can filter assets on asset type and/or
     * namespace. A "null" filter value means no filter of that type is used.
     *
     * @param assetTypeFilter Asset type to filter on (from the AssetType enum class.) Use
     * null to not filter on asset type.
     * @param namespaceFilter Namespace to filter on. Use null to not filter on namespace.
     * @param filterFunc Callback function to use when deciding whether an asset should be
     * included in the iteration or not. This needs to be a function that takes a single
     * parameter of type IAsset and returns a boolean where true means it should be included.
     *
     * @see away.library.AssetType
     */
    AssetLibraryBundle.prototype.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
        if (namespaceFilter === void 0) { namespaceFilter = null; }
        if (filterFunc === void 0) { filterFunc = null; }
        return new AssetLibraryIterator(this._assets, assetTypeFilter, namespaceFilter, filterFunc);
    };
    /**
     * Loads a file and (optionally) all of its dependencies.
     *
     * @param req The URLRequest object containing the URL of the file to be loaded.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
     * @return A handle to the retrieved resource.
     */
    AssetLibraryBundle.prototype.load = function (req, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        this.getLoader().load(req, context, ns, parser);
    };
    /**
     * Loads a resource from existing data in memory.
     *
     * @param data The data object containing all resource information.
     * @param context An optional context object providing additional parameters for loading
     * @param ns An optional namespace string under which the file is to be loaded, allowing the differentiation of two resources with identical assets
     * @param parser An optional parser object for translating the loaded data into a usable resource. If not provided, Loader will attempt to auto-detect the file type.
     * @return A handle to the retrieved resource.
     */
    AssetLibraryBundle.prototype.loadData = function (data, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        this.getLoader().loadData(data, '', context, ns, parser);
    };
    AssetLibraryBundle.prototype.getLoader = function () {
        var loader = new Loader();
        this._loaderSessions.push(loader);
        loader.addEventListener(LoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
        loader.addEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        loader.addEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        // Error are handled separately (see documentation for addErrorHandler)
        loader._iAddErrorHandler(this._onLoadErrorDelegate);
        loader._iAddParseErrorHandler(this._onParseErrorDelegate);
        return loader;
    };
    AssetLibraryBundle.prototype.disposeLoader = function (loader) {
        var index = this._loaderSessions.indexOf(loader);
        this._loaderSessions.splice(index, 1);
        this.killloaderSession(loader);
    };
    /**
     *
     */
    AssetLibraryBundle.prototype.getAsset = function (name, ns) {
        if (ns === void 0) { ns = null; }
        if (this._assetDictDirty)
            this.rehashAssetDict();
        if (ns == null)
            ns = AssetBase.DEFAULT_NAMESPACE;
        if (!this._assetDictionary.hasOwnProperty(ns))
            return null;
        return this._assetDictionary[ns][name];
    };
    AssetLibraryBundle.prototype.getAllAssets = function () {
        return this._assets;
    };
    /**
     * Adds an asset to the asset library, first making sure that it's name is unique
     * using the method defined by the <code>conflictStrategy</code> and
     * <code>conflictPrecedence</code> properties.
     */
    AssetLibraryBundle.prototype.addAsset = function (asset) {
        var ns;
        var old;
        // Bail if asset has already been added.
        if (this._assets.indexOf(asset) >= 0)
            return;
        old = this.getAsset(asset.adaptee.name, asset.adaptee.assetNamespace);
        ns = asset.adaptee.assetNamespace || AssetBase.DEFAULT_NAMESPACE;
        if (old != null)
            this._strategy.resolveConflict(asset, old, this._assetDictionary[ns], this._strategyPreference);
        //create unique-id (for now this is used in AwayBuilder only
        //asset.id = IDUtil.createUID();
        // Add it
        this._assets.push(asset);
        if (!this._assetDictionary.hasOwnProperty(ns))
            this._assetDictionary[ns] = new Object();
        this._assetDictionary[ns][asset.adaptee.name] = asset;
        asset.adaptee.addEventListener(AssetEvent.RENAME, this._onAssetRenameDelegate);
        asset.adaptee.addEventListener(AssetEvent.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
    };
    /**
     * Removes an asset from the library, and optionally disposes that asset by calling
     * it's disposeAsset() method (which for most assets is implemented as a default
     * version of that type's dispose() method.
     *
     * @param asset The asset which should be removed from this library.
     * @param dispose Defines whether the assets should also be disposed.
     */
    AssetLibraryBundle.prototype.removeAsset = function (asset, dispose) {
        if (dispose === void 0) { dispose = true; }
        var idx;
        this.removeAssetFromDict(asset);
        asset.adaptee.removeEventListener(AssetEvent.RENAME, this._onAssetRenameDelegate);
        asset.adaptee.removeEventListener(AssetEvent.ASSET_CONFLICT_RESOLVED, this._onAssetConflictResolvedDelegate);
        idx = this._assets.indexOf(asset);
        if (idx >= 0)
            this._assets.splice(idx, 1);
        if (dispose)
            asset.dispose();
    };
    /**
     * Removes an asset which is specified using name and namespace.
     *
     * @param name The name of the asset to be removed.
     * @param ns The namespace to which the desired asset belongs.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see away.library.AssetLibrary.removeAsset()
     */
    AssetLibraryBundle.prototype.removeAssetByName = function (name, ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        var asset = this.getAsset(name, ns);
        if (asset)
            this.removeAsset(asset, dispose);
        return asset;
    };
    /**
     * Removes all assets from the asset library, optionally disposing them as they
     * are removed.
     *
     * @param dispose Defines whether the assets should also be disposed.
     */
    AssetLibraryBundle.prototype.removeAllAssets = function (dispose) {
        if (dispose === void 0) { dispose = true; }
        if (dispose) {
            var asset;
            var len = this._assets.length;
            for (var c = 0; c < len; c++) {
                asset = this._assets[c];
                asset.dispose();
            }
        }
        this._assets.length = 0;
        this.rehashAssetDict();
    };
    /**
     * Removes all assets belonging to a particular namespace (null for default)
     * from the asset library, and optionall disposes them by calling their
     * disposeAsset() method.
     *
     * @param ns The namespace from which all assets should be removed.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see away.library.AssetLibrary.removeAsset()
     */
    AssetLibraryBundle.prototype.removeNamespaceAssets = function (ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        var idx = 0;
        var asset;
        var old_assets;
        // Empty the assets vector after having stored a copy of it.
        // The copy will be filled with all assets which weren't removed.
        old_assets = this._assets.concat();
        this._assets.length = 0;
        if (ns == null)
            ns = AssetBase.DEFAULT_NAMESPACE;
        var len = old_assets.length;
        for (var d = 0; d < len; d++) {
            asset = old_assets[d];
            // Remove from dict if in the supplied namespace. If not,
            // transfer over to the new vector.
            if (asset.adaptee.assetNamespace == ns) {
                if (dispose)
                    asset.dispose();
                // Remove asset from dictionary, but don't try to auto-remove
                // the namespace, which will trigger an unnecessarily expensive
                // test that is not needed since we know that the namespace
                // will be empty when loop finishes.
                this.removeAssetFromDict(asset, false);
            }
            else {
                this._assets[idx++] = asset;
            }
        }
        /*
         for each (asset in old_assets) {
         // Remove from dict if in the supplied namespace. If not,
         // transfer over to the new vector.
         if (asset.assetNamespace == ns) {
         if (dispose)
         asset.dispose();

         // Remove asset from dictionary, but don't try to auto-remove
         // the namespace, which will trigger an unnecessarily expensive
         // test that is not needed since we know that the namespace
         // will be empty when loop finishes.
         removeAssetFromDict(asset, false);
         } else
         _assets[idx++] = asset;

         }
         */
        // Remove empty namespace
        if (this._assetDictionary.hasOwnProperty(ns))
            delete this._assetDictionary[ns];
    };
    AssetLibraryBundle.prototype.removeAssetFromDict = function (asset, autoRemoveEmptyNamespace) {
        if (autoRemoveEmptyNamespace === void 0) { autoRemoveEmptyNamespace = true; }
        if (this._assetDictDirty)
            this.rehashAssetDict();
        if (this._assetDictionary.hasOwnProperty(asset.adaptee.assetNamespace)) {
            if (this._assetDictionary[asset.adaptee.assetNamespace].hasOwnProperty(asset.adaptee.name))
                delete this._assetDictionary[asset.adaptee.assetNamespace][asset.adaptee.name];
            if (autoRemoveEmptyNamespace) {
                var key;
                var empty = true;
                for (key in this._assetDictionary[asset.adaptee.assetNamespace]) {
                    empty = false;
                    break;
                }
                if (empty)
                    delete this._assetDictionary[asset.adaptee.assetNamespace];
            }
        }
    };
    AssetLibraryBundle.prototype.stopAllLoaders = function () {
        var len = this._loaderSessions.length;
        for (var i = 0; i < len; i++)
            this.killloaderSession(this._loaderSessions[i]);
        this._loaderSessions = new Array();
    };
    AssetLibraryBundle.prototype.rehashAssetDict = function () {
        var asset;
        this._assetDictionary = {};
        var len = this._assets.length;
        for (var c = 0; c < len; c++) {
            asset = this._assets[c];
            if (!this._assetDictionary.hasOwnProperty(asset.adaptee.assetNamespace))
                this._assetDictionary[asset.adaptee.assetNamespace] = {};
            this._assetDictionary[asset.adaptee.assetNamespace][asset.adaptee.name] = asset;
        }
        this._assetDictDirty = false;
    };
    /**
     * Called when a an error occurs during loading.
     */
    AssetLibraryBundle.prototype.onLoadError = function (event) {
        if (this.hasEventListener(URLLoaderEvent.LOAD_ERROR)) {
            this.dispatchEvent(event);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Called when a an error occurs during parsing.
     */
    AssetLibraryBundle.prototype.onParseError = function (event) {
        if (this.hasEventListener(ParserEvent.PARSE_ERROR)) {
            this.dispatchEvent(event);
            return true;
        }
        else {
            return false;
        }
    };
    AssetLibraryBundle.prototype.onAssetComplete = function (event) {
        // Only add asset to library the first time.
        if (event.type == AssetEvent.ASSET_COMPLETE)
            this.addAsset(event.asset.adapter);
        this.dispatchEvent(event);
    };
    AssetLibraryBundle.prototype.onTextureSizeError = function (event) {
        this.dispatchEvent(event);
    };
    /**
     * Called when the resource and all of its dependencies was retrieved.
     */
    AssetLibraryBundle.prototype.onLoadComplete = function (event) {
        var loader = event.target;
        this.dispatchEvent(event);
        this.disposeLoader(loader);
    };
    AssetLibraryBundle.prototype.killloaderSession = function (loader) {
        loader.removeEventListener(LoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
        loader.removeEventListener(AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        loader.removeEventListener(AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        loader.stop();
    };
    AssetLibraryBundle.prototype.onAssetRename = function (event) {
        var asset = event.target.adapter; // TODO: was ev.currentTarget - watch this var
        var old = this.getAsset(asset.adaptee.assetNamespace, asset.adaptee.name);
        if (old != null) {
            this._strategy.resolveConflict(asset, old, this._assetDictionary[asset.adaptee.assetNamespace], this._strategyPreference);
        }
        else {
            var dict = this._assetDictionary[event.asset.assetNamespace];
            if (dict == null)
                return;
            dict[event.prevName] = null;
            dict[event.asset.name] = event.asset;
        }
    };
    AssetLibraryBundle.prototype.onAssetConflictResolved = function (event) {
        this.dispatchEvent(event.clone());
    };
    return AssetLibraryBundle;
}(EventDispatcher));
AssetLibraryBundle._iInstances = new Object();

/**
 * AssetLibrary enforces a singleton pattern and is not intended to be instanced.
 * It's purpose is to allow access to the default library bundle through a set of static shortcut methods.
 * If you are interested in creating multiple library bundles, please use the <code>getBundle()</code> method.
 */
var AssetLibrary = (function () {
    /**
     * Creates a new <code>AssetLibrary</code> object.
     *
     */
    function AssetLibrary() {
    }
    //*/
    /**
     * Returns an AssetLibrary bundle instance. If no key is given, returns the default bundle (which is
     * similar to using the AssetLibraryBundle as a singleton). To keep several separated library bundles,
     * pass a string key to this method to define which bundle should be returned. This is
     * referred to as using the AssetLibraryBundle as a multiton.
     *
     * @param key Defines which multiton instance should be returned.
     * @return An instance of the asset library
     */
    AssetLibrary.getBundle = function (key) {
        if (key === void 0) { key = 'default'; }
        return AssetLibraryBundle.getInstance(key);
    };
    /**
     *
     */
    AssetLibrary.enableParser = function (parserClass) {
        Loader.enableParser(parserClass);
    };
    /**
     *
     */
    AssetLibrary.enableParsers = function (parserClasses) {
        Loader.enableParsers(parserClasses);
    };
    Object.defineProperty(AssetLibrary, "conflictStrategy", {
        /**
         * Short-hand for conflictStrategy property on default asset library bundle.
         *
         * @see AssetLibraryBundle.conflictStrategy
         */
        get: function () {
            return AssetLibrary.getBundle().conflictStrategy;
        },
        set: function (val) {
            AssetLibrary.getBundle().conflictStrategy = val;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AssetLibrary, "conflictPrecedence", {
        /**
         * Short-hand for conflictPrecedence property on default asset library bundle.
         *
         * @see AssetLibraryBundle.conflictPrecedence
         */
        get: function () {
            return AssetLibrary.getBundle().conflictPrecedence;
        },
        set: function (val) {
            AssetLibrary.getBundle().conflictPrecedence = val;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Short-hand for createIterator() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.createIterator()
     */
    AssetLibrary.createIterator = function (assetTypeFilter, namespaceFilter, filterFunc) {
        if (assetTypeFilter === void 0) { assetTypeFilter = null; }
        if (namespaceFilter === void 0) { namespaceFilter = null; }
        if (filterFunc === void 0) { filterFunc = null; }
        return AssetLibrary.getBundle().createIterator(assetTypeFilter, namespaceFilter, filterFunc);
    };
    /**
     * Short-hand for load() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.load()
     */
    AssetLibrary.load = function (req, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        AssetLibrary.getBundle().load(req, context, ns, parser);
    };
    /**
     * Short-hand for loadData() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.loadData()
     */
    AssetLibrary.loadData = function (data, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        AssetLibrary.getBundle().loadData(data, context, ns, parser);
    };
    AssetLibrary.stopLoad = function () {
        AssetLibrary.getBundle().stopAllLoaders();
    };
    AssetLibrary.getLoader = function () {
        return AssetLibrary.getBundle().getLoader();
    };
    /**
     * Short-hand for getAsset() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.getAsset()
     */
    AssetLibrary.getAsset = function (name, ns) {
        if (ns === void 0) { ns = null; }
        return AssetLibrary.getBundle().getAsset(name, ns);
    };
    /**
     * Short-hand for getAsset() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.getAsset()
     */
    AssetLibrary.getAllAssets = function () {
        return AssetLibrary.getBundle().getAllAssets();
    };
    /**
     * Short-hand for addEventListener() method on default asset library bundle.
     */
    AssetLibrary.addEventListener = function (type, listener) {
        AssetLibrary.getBundle().addEventListener(type, listener);
    };
    /**
     * Short-hand for removeEventListener() method on default asset library bundle.
     */
    AssetLibrary.removeEventListener = function (type, listener) {
        AssetLibrary.getBundle().removeEventListener(type, listener);
    };
    /**
     * Short-hand for hasEventListener() method on default asset library bundle.

     public static hasEventListener(type:string):boolean
     {
        return AssetLibrary.getBundle().hasEventListener(type);
    }

     public static willTrigger(type:string):boolean
     {
        return getBundle().willTrigger(type);
    }
     */
    /**
     * Short-hand for addAsset() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.addAsset()
     */
    AssetLibrary.addAsset = function (asset) {
        AssetLibrary.getBundle().addAsset(asset);
    };
    /**
     * Short-hand for removeAsset() method on default asset library bundle.
     *
     * @param asset The asset which should be removed from the library.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see AssetLibraryBundle.removeAsset()
     */
    AssetLibrary.removeAsset = function (asset, dispose) {
        if (dispose === void 0) { dispose = true; }
        AssetLibrary.getBundle().removeAsset(asset, dispose);
    };
    /**
     * Short-hand for removeAssetByName() method on default asset library bundle.
     *
     * @param name The name of the asset to be removed.
     * @param ns The namespace to which the desired asset belongs.
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see AssetLibraryBundle.removeAssetByName()
     */
    AssetLibrary.removeAssetByName = function (name, ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        return AssetLibrary.getBundle().removeAssetByName(name, ns, dispose);
    };
    /**
     * Short-hand for removeAllAssets() method on default asset library bundle.
     *
     * @param dispose Defines whether the assets should also be disposed.
     *
     * @see AssetLibraryBundle.removeAllAssets()
     */
    AssetLibrary.removeAllAssets = function (dispose) {
        if (dispose === void 0) { dispose = true; }
        AssetLibrary.getBundle().removeAllAssets(dispose);
    };
    /**
     * Short-hand for removeNamespaceAssets() method on default asset library bundle.
     *
     * @see AssetLibraryBundle.removeNamespaceAssets()
     */
    AssetLibrary.removeNamespaceAssets = function (ns, dispose) {
        if (ns === void 0) { ns = null; }
        if (dispose === void 0) { dispose = true; }
        AssetLibrary.getBundle().removeNamespaceAssets(ns, dispose);
    };
    return AssetLibrary;
}());

var IDUtil = (function () {
    function IDUtil() {
    }
    /**
     *  Generates a UID (unique identifier) based on ActionScript's
     *  pseudo-random number generator and the current time.
     *
     *  <p>The UID has the form
     *  <code>"XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX"</code>
     *  where X is a hexadecimal digit (0-9, A-F).</p>
     *
     *  <p>This UID will not be truly globally unique; but it is the best
     *  we can do without player support for UID generation.</p>
     *
     *  @return The newly-generated UID.
     *
     *  @langversion 3.0
     *  @playerversion Flash 9
     *  @playerversion AIR 1.1
     *  @productversion Flex 3
     */
    IDUtil.createUID = function () {
        var uid = new Array(36);
        var index = 0;
        var i;
        var j;
        for (i = 0; i < 8; i++)
            uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];
        for (i = 0; i < 3; i++) {
            uid[index++] = 45; // charCode for "-"
            for (j = 0; j < 4; j++)
                uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];
        }
        uid[index++] = 45; // charCode for "-"
        var time = new Date().getTime();
        // Note: time is the number of milliseconds since 1970,
        // which is currently more than one trillion.
        // We use the low 8 hex digits of this number in the UID.
        // Just in case the system clock has been reset to
        // Jan 1-4, 1970 (in which case this number could have only
        // 1-7 hex digits), we pad on the left with 7 zeros
        // before taking the low digits.
        var timeString = ("0000000" + time.toString(16).toUpperCase()).substr(-8);
        for (i = 0; i < 8; i++)
            uid[index++] = timeString.charCodeAt(i);
        for (i = 0; i < 4; i++)
            uid[index++] = IDUtil.ALPHA_CHAR_CODES[Math.floor(Math.random() * 16)];
        return String.fromCharCode.apply(null, uid);
    };
    return IDUtil;
}());
/**
 *  @private
 *  Char codes for 0123456789ABCDEF
 */
IDUtil.ALPHA_CHAR_CODES = [48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 65, 66, 67, 68, 69, 70];

/**
 * The LoaderInfo export class provides information about a loaded SWF file or a
 * loaded image file(JPEG, GIF, or PNG). LoaderInfo objects are available for
 * any display object. The information provided includes load progress, the
 * URLs of the loader and loaded content, the number of bytes total for the
 * media, and the nominal height and width of the media.
 *
 * <p>You can access LoaderInfo objects in two ways: </p>
 *
 * <ul>
 *   <li>The <code>contentLoaderInfo</code> property of a flash.display.Loader
 * object -  The <code>contentLoaderInfo</code> property is always available
 * for any Loader object. For a Loader object that has not called the
 * <code>load()</code> or <code>loadBytes()</code> method, or that has not
 * sufficiently loaded, attempting to access many of the properties of the
 * <code>contentLoaderInfo</code> property throws an error.</li>
 *   <li>The <code>loaderInfo</code> property of a display object. </li>
 * </ul>
 *
 * <p>The <code>contentLoaderInfo</code> property of a Loader object provides
 * information about the content that the Loader object is loading, whereas
 * the <code>loaderInfo</code> property of a DisplayObject provides
 * information about the root SWF file for that display object. </p>
 *
 * <p>When you use a Loader object to load a display object(such as a SWF
 * file or a bitmap), the <code>loaderInfo</code> property of the display
 * object is the same as the <code>contentLoaderInfo</code> property of the
 * Loader object(<code>DisplayObject.loaderInfo =
 * Loader.contentLoaderInfo</code>). Because the instance of the main export class of
 * the SWF file has no Loader object, the <code>loaderInfo</code> property is
 * the only way to access the LoaderInfo for the instance of the main export class of
 * the SWF file.</p>
 *
 * <p>The following diagram shows the different uses of the LoaderInfo
 * object - for the instance of the main export class of the SWF file, for the
 * <code>contentLoaderInfo</code> property of a Loader object, and for the
 * <code>loaderInfo</code> property of a loaded object:</p>
 *
 * <p>When a loading operation is not complete, some properties of the
 * <code>contentLoaderInfo</code> property of a Loader object are not
 * available. You can obtain some properties, such as
 * <code>bytesLoaded</code>, <code>bytesTotal</code>, <code>url</code>,
 * <code>loaderURL</code>, and <code>applicationDomain</code>. When the
 * <code>loaderInfo</code> object dispatches the <code>init</code> event, you
 * can access all properties of the <code>loaderInfo</code> object and the
 * loaded image or SWF file.</p>
 *
 * <p><b>Note:</b> All properties of LoaderInfo objects are read-only.</p>
 *
 * <p>The <code>EventDispatcher.dispatchEvent()</code> method is not
 * applicable to LoaderInfo objects. If you call <code>dispatchEvent()</code>
 * on a LoaderInfo object, an IllegalOperationError exception is thrown.</p>
 *
 * @event complete   Dispatched when data has loaded successfully. In other
 *                   words, it is dispatched when all the content has been
 *                   downloaded and the loading has finished. The
 *                   <code>complete</code> event is always dispatched after
 *                   the <code>init</code> event. The <code>init</code> event
 *                   is dispatched when the object is ready to access, though
 *                   the content may still be downloading.
 * @event httpStatus Dispatched when a network request is made over HTTP and
 *                   an HTTP status code can be detected.
 * @event init       Dispatched when the properties and methods of a loaded
 *                   SWF file are accessible and ready for use. The content,
 *                   however, can still be downloading. A LoaderInfo object
 *                   dispatches the <code>init</code> event when the following
 *                   conditions exist:
 *                   <ul>
 *                     <li>All properties and methods associated with the
 *                   loaded object and those associated with the LoaderInfo
 *                   object are accessible.</li>
 *                     <li>The constructors for all child objects have
 *                   completed.</li>
 *                     <li>All ActionScript code in the first frame of the
 *                   loaded SWF's main timeline has been executed.</li>
 *                   </ul>
 *
 *                   <p>For example, an <code>Event.INIT</code> is dispatched
 *                   when the first frame of a movie or animation is loaded.
 *                   The movie is then accessible and can be added to the
 *                   display list. The complete movie, however, can take
 *                   longer to download. The <code>Event.COMPLETE</code> is
 *                   only dispatched once the full movie is loaded.</p>
 *
 *                   <p>The <code>init</code> event always precedes the
 *                   <code>complete</code> event.</p>
 * @event ioError    Dispatched when an input or output error occurs that
 *                   causes a load operation to fail.
 * @event open       Dispatched when a load operation starts.
 * @event progress   Dispatched when data is received as the download
 *                   operation progresses.
 * @event unload     Dispatched by a LoaderInfo object whenever a loaded
 *                   object is removed by using the <code>unload()</code>
 *                   method of the Loader object, or when a second load is
 *                   performed by the same Loader object and the original
 *                   content is removed prior to the load beginning.
 */
var LoaderInfo = (function (_super) {
    __extends(LoaderInfo, _super);
    function LoaderInfo() {
        return _super.apply(this, arguments) || this;
    }
    Object.defineProperty(LoaderInfo.prototype, "bytes", {
        /**
         * The bytes associated with a LoaderInfo object.
         *
         * @throws SecurityError If the object accessing this API is prevented from
         *                       accessing the loaded object due to security
         *                       restrictions. This situation can occur, for
         *                       instance, when a Loader object attempts to access
         *                       the <code>contentLoaderInfo.content</code> property
         *                       and it is not granted security permission to access
         *                       the loaded content.
         *
         *                       <p>For more information related to security, see the
         *                       Flash Player Developer Center Topic: <a
         *                       href="http://www.adobe.com/go/devnet_security_en"
         *                       scope="external">Security</a>.</p>
         */
        get: function () {
            return this._bytes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderInfo.prototype, "bytesLoaded", {
        /**
         * The number of bytes that are loaded for the media. When this number equals
         * the value of <code>bytesTotal</code>, all of the bytes are loaded.
         */
        get: function () {
            return this._bytesLoaded;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderInfo.prototype, "bytesTotal", {
        /**
         * The number of compressed bytes in the entire media file.
         *
         * <p>Before the first <code>progress</code> event is dispatched by this
         * LoaderInfo object's corresponding Loader object, <code>bytesTotal</code>
         * is 0. After the first <code>progress</code> event from the Loader object,
         * <code>bytesTotal</code> reflects the actual number of bytes to be
         * downloaded.</p>
         */
        get: function () {
            return this._bytesTotal;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderInfo.prototype, "content", {
        /**
         * The loaded object associated with this LoaderInfo object.
         *
         * @throws SecurityError If the object accessing this API is prevented from
         *                       accessing the loaded object due to security
         *                       restrictions. This situation can occur, for
         *                       instance, when a Loader object attempts to access
         *                       the <code>contentLoaderInfo.content</code> property
         *                       and it is not granted security permission to access
         *                       the loaded content.
         *
         *                       <p>For more information related to security, see the
         *                       Flash Player Developer Center Topic: <a
         *                       href="http://www.adobe.com/go/devnet_security_en"
         *                       scope="external">Security</a>.</p>
         */
        get: function () {
            return this._content;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderInfo.prototype, "contentType", {
        /**
         * The MIME type of the loaded file. The value is <code>null</code> if not
         * enough of the file has loaded in order to determine the type. The
         * following list gives the possible values:
         * <ul>
         *   <li><code>"application/x-shockwave-flash"</code></li>
         *   <li><code>"image/jpeg"</code></li>
         *   <li><code>"image/gif"</code></li>
         *   <li><code>"image/png"</code></li>
         * </ul>
         */
        get: function () {
            return this._contentType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderInfo.prototype, "loader", {
        /**
         * The Loader object associated with this LoaderInfo object. If this
         * LoaderInfo object is the <code>loaderInfo</code> property of the instance
         * of the main export class of the SWF file, no Loader object is associated.
         *
         * @throws SecurityError If the object accessing this API is prevented from
         *                       accessing the Loader object because of security
         *                       restrictions. This can occur, for instance, when a
         *                       loaded SWF file attempts to access its
         *                       <code>loaderInfo.loader</code> property and it is
         *                       not granted security permission to access the
         *                       loading SWF file.
         *
         *                       <p>For more information related to security, see the
         *                       Flash Player Developer Center Topic: <a
         *                       href="http://www.adobe.com/go/devnet_security_en"
         *                       scope="external">Security</a>.</p>
         */
        get: function () {
            return this._loader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LoaderInfo.prototype, "url", {
        /**
         * The URL of the media being loaded.
         *
         * <p>Before the first <code>progress</code> event is dispatched by this
         * LoaderInfo object's corresponding Loader object, the value of the
         * <code>url</code> property might reflect only the initial URL specified in
         * the call to the <code>load()</code> method of the Loader object. After the
         * first <code>progress</code> event, the <code>url</code> property reflects
         * the media's final URL, after any redirects and relative URLs are
         * resolved.</p>
         *
         * <p>In some cases, the value of the <code>url</code> property is truncated;
         * see the <code>isURLInaccessible</code> property for details.</p>
         */
        get: function () {
            return this._url;
        },
        enumerable: true,
        configurable: true
    });
    return LoaderInfo;
}(EventDispatcher));

var CrossDomainPolicy = (function () {
    function CrossDomainPolicy() {
    }
    return CrossDomainPolicy;
}());
CrossDomainPolicy.ANONYMOUS = 'anonymous';
CrossDomainPolicy.USE_CREDENTIALS = 'use-credentials';

var URLRequest = (function () {
    /**

     * @param url
     */
    function URLRequest(url) {
        if (url === void 0) { url = null; }
        /**
         *
         * away.net.URLRequestMethod.GET
         * away.net.URLRequestMethod.POST
         *
         * @type {string}
         */
        this.method = URLRequestMethod.GET;
        /**
         * Use asynchronous XMLHttpRequest
         * @type {boolean}
         */
        this.async = true;
        this._url = url;
    }
    Object.defineProperty(URLRequest.prototype, "url", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._url;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            this._url = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * dispose
     */
    URLRequest.prototype.dispose = function () {
        this.data = null;
        this._url = null;
    };
    return URLRequest;
}());

var Timer = (function (_super) {
    __extends(Timer, _super);
    function Timer(delay, repeatCount) {
        if (repeatCount === void 0) { repeatCount = 0; }
        var _this = _super.call(this) || this;
        _this._repeatCount = 0;
        _this._currentCount = 0;
        _this._running = false;
        _this._delay = delay;
        _this._repeatCount = repeatCount;
        if (isNaN(delay) || delay < 0)
            throw new ErrorBase("Delay is negative or not a number");
        return _this;
    }
    Object.defineProperty(Timer.prototype, "currentCount", {
        get: function () {
            return this._currentCount;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Timer.prototype, "delay", {
        get: function () {
            return this._delay;
        },
        set: function (value) {
            this._delay = value;
            if (this._running) {
                this.stop();
                this.start();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Timer.prototype, "repeatCount", {
        get: function () {
            return this._repeatCount;
        },
        set: function (value) {
            this._repeatCount = value;
        },
        enumerable: true,
        configurable: true
    });
    Timer.prototype.reset = function () {
        if (this._running)
            this.stop();
        this._currentCount = 0;
    };
    Object.defineProperty(Timer.prototype, "running", {
        get: function () {
            return this._running;
        },
        enumerable: true,
        configurable: true
    });
    Timer.prototype.start = function () {
        var _this = this;
        this._running = true;
        clearInterval(this._iid);
        this._iid = setInterval(function () { return _this.tick(); }, this._delay);
    };
    Timer.prototype.stop = function () {
        this._running = false;
        clearInterval(this._iid);
    };
    Timer.prototype.tick = function () {
        this._currentCount++;
        if ((this._repeatCount > 0) && this._currentCount >= this._repeatCount) {
            this.stop();
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER));
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER_COMPLETE));
        }
        else {
            this.dispatchEvent(new TimerEvent(TimerEvent.TIMER));
        }
    };
    return Timer;
}(EventDispatcher));

/**
 *
 *
 * @returns {number}
 */
/**
 *
 *
 * @returns {number}
 */ function getTimer() {
    // number milliseconds of 1970/01/01
    // this different to AS3 implementation which gets the number of milliseconds
    // since instance of Flash player was initialised
    return Date.now();
}

/**
 * <code>ParserBase</code> provides an abstract base export class for objects that convert blocks of data to data structures
 * supported by away.
 *
 * If used by <code>Loader</code> to automatically determine the parser type, two public static methods should
 * be implemented, with the following signatures:
 *
 * <code>public static supportsType(extension : string) : boolean</code>
 * Indicates whether or not a given file extension is supported by the parser.
 *
 * <code>public static supportsData(data : *) : boolean</code>
 * Tests whether a data block can be parsed by the parser.
 *
 * Furthermore, for any concrete subtype, the method <code>initHandle</code> should be overridden to immediately
 * create the object that will contain the parsed data. This allows <code>ResourceManager</code> to return an object
 * handle regardless of whether the object was loaded or not.
 *
 * @see Loader
 */
var ParserBase = (function (_super) {
    __extends(ParserBase, _super);
    /**
     * Creates a new ParserBase object
     * @param format The data format of the file data to be parsed. Can be either <code>ParserDataFormat.BINARY</code> or <code>ParserDataFormat.PLAIN_TEXT</code>, and should be provided by the concrete subtype.
     *
     * @see away.loading.parsers.ParserDataFormat
     */
    function ParserBase(format) {
        var _this = _super.call(this) || this;
        _this._materialMode = 0;
        _this._dataFormat = format;
        _this._dependencies = new Array();
        _this._pOnIntervalDelegate = function (event) { return _this._pOnInterval(event); };
        return _this;
    }
    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
    // TODO: add error checking for the following ( could cause a problem if this function is not implemented )
    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
    // Needs to be implemented in all Parsers (
    //<code>public static supportsType(extension : string) : boolean</code>
    //* Indicates whether or not a given file extension is supported by the parser.
    //----------------------------------------------------------------------------------------------------------------------------------------------------------------
    ParserBase.supportsType = function (extension) {
        throw new AbstractMethodError();
    };
    Object.defineProperty(ParserBase.prototype, "content", {
        /* Protected */
        get: function () {
            return this._pContent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "parsingFailure", {
        get: function () {
            return this._parsingFailure;
        },
        set: function (b) {
            this._parsingFailure = b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "parsingPaused", {
        get: function () {
            return this._parsingPaused;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "parsingComplete", {
        get: function () {
            return this._parsingComplete;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "materialMode", {
        get: function () {
            return this._materialMode;
        },
        set: function (newMaterialMode) {
            this._materialMode = newMaterialMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParserBase.prototype, "dataFormat", {
        /**
         * The data format of the file data to be parsed. Options are <code>URLLoaderDataFormat.BINARY</code>, <code>URLLoaderDataFormat.ARRAY_BUFFER</code>, <code>URLLoaderDataFormat.BLOB</code>, <code>URLLoaderDataFormat.VARIABLES</code> or <code>URLLoaderDataFormat.TEXT</code>.
         */
        get: function () {
            return this._dataFormat;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Parse data (possibly containing bytearry, plain text or BitmapAsset) asynchronously, meaning that
     * the parser will periodically stop parsing so that the AVM may proceed to the
     * next frame.
     *
     * @param data The untyped data object in which the loaded data resides.
     * @param frameLimit number of milliseconds of parsing allowed per frame. The
     * actual time spent on a frame can exceed this number since time-checks can
     * only be performed between logical sections of the parsing procedure.
     */
    ParserBase.prototype.parseAsync = function (data, frameLimit) {
        if (frameLimit === void 0) { frameLimit = 30; }
        this._data = data;
        this._pStartParsing(frameLimit);
    };
    Object.defineProperty(ParserBase.prototype, "dependencies", {
        /**
         * A list of dependencies that need to be loaded and resolved for the object being parsed.
         */
        get: function () {
            return this._dependencies;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resolve a dependency when it's loaded. For example, a dependency containing an ImageResource would be assigned
     * to a Mesh instance as a BitmapMaterial, a scene graph object would be added to its intended parent. The
     * dependency should be a member of the dependencies property.
     *
     * @param resourceDependency The dependency to be resolved.
     */
    ParserBase.prototype._iResolveDependency = function (resourceDependency) {
        throw new AbstractMethodError();
    };
    /**
     * Resolve a dependency loading failure. Used by parser to eventually provide a default map
     *
     * @param resourceDependency The dependency to be resolved.
     */
    ParserBase.prototype._iResolveDependencyFailure = function (resourceDependency) {
        throw new AbstractMethodError();
    };
    /**
     * Resolve a dependency name
     *
     * @param resourceDependency The dependency to be resolved.
     */
    ParserBase.prototype._iResolveDependencyName = function (resourceDependency, asset) {
        return asset.name;
    };
    ParserBase.prototype._iResumeParsing = function () {
        this._parsingPaused = false;
        if (this._timer)
            this._timer.start();
        //get started!
        if (!this._isParsing)
            this._pOnInterval();
    };
    ParserBase.prototype._pFinalizeAsset = function (asset, name) {
        if (name === void 0) { name = null; }
        var type_event;
        var type_name;
        if (name != null)
            asset.name = name;
        // If the asset has no name, give it
        // a per-type default name.
        if (!asset.name)
            asset.name = asset.assetType;
        this.dispatchEvent(new AssetEvent(AssetEvent.ASSET_COMPLETE, asset));
    };
    /**
     * Parse the next block of data.
     * @return Whether or not more data needs to be parsed. Can be <code>ParserBase.ParserBase.PARSING_DONE</code> or
     * <code>ParserBase.ParserBase.MORE_TO_PARSE</code>.
     */
    ParserBase.prototype._pProceedParsing = function () {
        throw new AbstractMethodError();
    };
    ParserBase.prototype._pDieWithError = function (message) {
        if (message === void 0) { message = 'Unknown parsing error'; }
        if (this._timer) {
            this._timer.removeEventListener(TimerEvent.TIMER, this._pOnIntervalDelegate);
            this._timer.stop();
            this._timer = null;
        }
        this.dispatchEvent(new ParserEvent(ParserEvent.PARSE_ERROR, message));
    };
    ParserBase.prototype._pAddDependency = function (id, req, parser, data, retrieveAsRawData, suppressErrorEvents, sub_id) {
        if (parser === void 0) { parser = null; }
        if (data === void 0) { data = null; }
        if (retrieveAsRawData === void 0) { retrieveAsRawData = false; }
        if (suppressErrorEvents === void 0) { suppressErrorEvents = false; }
        if (sub_id === void 0) { sub_id = 0; }
        var dependency = new ResourceDependency(id, req, data, parser, this, retrieveAsRawData, suppressErrorEvents, sub_id);
        this._dependencies.push(dependency);
        return dependency;
    };
    ParserBase.prototype._pPauseAndRetrieveDependencies = function () {
        this._pPauseParsing();
        this.dispatchEvent(new ParserEvent(ParserEvent.READY_FOR_DEPENDENCIES));
    };
    ParserBase.prototype._pPauseParsing = function () {
        if (this._timer)
            this._timer.stop();
        this._parsingPaused = true;
    };
    /**
     * Tests whether or not there is still time left for parsing within the maximum allowed time frame per session.
     * @return True if there is still time left, false if the maximum allotted time was exceeded and parsing should be interrupted.
     */
    ParserBase.prototype._pHasTime = function () {
        return ((getTimer() - this._lastFrameTime) < this._frameLimit);
    };
    /**
     * Called when the parsing pause interval has passed and parsing can proceed.
     */
    ParserBase.prototype._pOnInterval = function (event) {
        if (event === void 0) { event = null; }
        this._lastFrameTime = getTimer();
        this._isParsing = true;
        if (this._pProceedParsing() && !this._parsingFailure)
            this._pFinishParsing();
        this._isParsing = false;
    };
    /**
     * Initializes the parsing of data.
     * @param frameLimit The maximum duration of a parsing session.
     */
    ParserBase.prototype._pStartParsing = function (frameLimit) {
        this._frameLimit = frameLimit;
        this._timer = new Timer(this._frameLimit, 0);
        this._timer.addEventListener(TimerEvent.TIMER, this._pOnIntervalDelegate);
        this._timer.start();
        //get started!
        this._pOnInterval();
    };
    /**
     * Finish parsing the data.
     */
    ParserBase.prototype._pFinishParsing = function () {
        if (this._timer) {
            this._timer.removeEventListener(TimerEvent.TIMER, this._pOnIntervalDelegate);
            this._timer.stop();
        }
        this._timer = null;
        this._parsingComplete = true;
        this._isParsing = false;
        this.dispatchEvent(new ParserEvent(ParserEvent.PARSE_COMPLETE));
    };
    /**
     *
     * @returns {string}
     * @private
     */
    ParserBase.prototype._pGetTextData = function () {
        return ParserUtils.toString(this._data);
    };
    /**
     *
     * @returns {ByteArray}
     * @private
     */
    ParserBase.prototype._pGetByteData = function () {
        return ParserUtils.toByteArray(this._data);
    };
    /**
     *
     * @returns {any}
     * @private
     */
    ParserBase.prototype._pGetData = function () {
        return this._data;
    };
    return ParserBase;
}(EventDispatcher));
/**
 * Returned by <code>proceedParsing</code> to indicate no more parsing is needed.
 */
ParserBase.PARSING_DONE = true;
/* Protected */
/**
 * Returned by <code>proceedParsing</code> to indicate more parsing is needed, allowing asynchronous parsing.
 */
ParserBase.MORE_TO_PARSE = false;

/**
 * An enumeration providing values to describe the data format of parsed data.
 */
var ParserDataFormat = (function () {
    function ParserDataFormat() {
    }
    return ParserDataFormat;
}());
/**
 * Describes the format of a binary file.
 */
ParserDataFormat.BINARY = "binary";
/**
 * Describes the format of a plain text file.
 */
ParserDataFormat.PLAIN_TEXT = "plainText";
/**
 * Describes the format of an image file
 */
ParserDataFormat.IMAGE = "image";

var WaveAudioParser = (function (_super) {
    __extends(WaveAudioParser, _super);
    function WaveAudioParser() {
        var _this = _super.call(this, URLLoaderDataFormat.BLOB) || this;
        _this._convertingBlobState = 0;
        return _this;
    }
    WaveAudioParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "wav" || extension == "mp3" || extension == "ogg";
    };
    WaveAudioParser.supportsData = function (data) {
        if (!(data instanceof ByteArray))
            return false;
        var ba = data;
        var filetype = WaveAudioParser.parseFileType(ba);
        return filetype ? true : false;
    };
    WaveAudioParser.prototype._pStartParsing = function (frameLimit) {
        //clear content
        delete this._pContent;
        this._pContent = null;
        _super.prototype._pStartParsing.call(this, frameLimit);
    };
    WaveAudioParser.prototype._pProceedParsing = function () {
        var _this = this;
        if (this._convertingBlobState == 1) {
            return ParserBase.MORE_TO_PARSE;
        }
        else if (this._convertingBlobState == 2) {
            return ParserBase.PARSING_DONE;
        }
        else if (this._convertingBlobState == 3) {
            return ParserBase.PARSING_DONE; //todo
        }
        if (this.data instanceof ByteArray) {
            this._pContent = new WaveAudio(this.data.arraybytes);
            this._pFinalizeAsset(this._pContent, this._iFileName);
        }
        else if (this.data instanceof ArrayBuffer) {
            this._pContent = new WaveAudio(this.data);
            this._pFinalizeAsset(this._pContent, this._iFileName);
        }
        else if (this.data instanceof Blob) {
            this._convertingBlobState = 1;
            var fileReader = new FileReader();
            fileReader.onload = function (event) { return _this.blobConverted(event); };
            fileReader.readAsArrayBuffer(this.data);
            return ParserBase.MORE_TO_PARSE;
        }
        return ParserBase.PARSING_DONE;
    };
    WaveAudioParser.prototype.blobConverted = function (event) {
        this._pContent = new WaveAudio(event.target.result);
        this._pFinalizeAsset(this._pContent, WaveAudioParser.processFilename(this._iFileName));
        this._convertingBlobState = 2;
    };
    WaveAudioParser.parseFileType = function (ba) {
        //old mp3 detections
        // This does not seem to work for all my mp3 files (i tested different mp3 encoders)
        // I leave it in, because it might work for mp3 data that i do not have here to test
        ba.position = 0;
        if ((ba.readUnsignedShort() & 0xFFE0) == 0xFFE0) {
            return 'mp3'; // test for MP3 syncword
        }
        // new mp3 detection
        // this from is-mp3 npm module,
        // but still i have mp3 files that are not detected by this
        // i added the hack: (byte_1 === 255 && byte_2 === 243 && byte_3 === 130) 	to catch those mp3s
        // todo: find a more foolproof way to detect al mp3 (my hack might collide with detection for other filetypes)
        ba.position = 0;
        var byte_1 = ba.readUnsignedByte();
        var byte_2 = ba.readUnsignedByte();
        var byte_3 = ba.readUnsignedByte();
        if ((byte_1 === 73 && byte_2 === 68 && byte_3 === 51)
            || (byte_1 === 255 && byte_2 === 251)
            || (byte_1 === 255 && byte_2 === 243 && byte_3 === 130)) {
            return 'mp3';
        }
        ba.position = 0;
        if (ba.readUTFBytes(4) == 'RIFF')
            return 'wav';
        ba.position = 0;
        if (ba.readUTFBytes(4) == 'OggS')
            return 'ogg';
        ba.position = 0;
        return null;
    };
    return WaveAudioParser;
}(ParserBase));
/*
    this static property can be set with a function that that will be called on each filename before adding it to the library
*/
WaveAudioParser.processFilename = function (filename) {
    return filename;
};

/**
 * Provides constant values for camera lens projection options use the the <code>coordinateSystem</code> property
 *
 * @see away.projections.PerspectiveLens#coordinateSystem
 */
/**
 * Provides constant values for camera lens projection options use the the <code>coordinateSystem</code> property
 *
 * @see away.projections.PerspectiveLens#coordinateSystem
 */ 
(function (CoordinateSystem) {
    /**
     * Default option, projects to a left-handed coordinate system
     */
    CoordinateSystem[CoordinateSystem["LEFT_HANDED"] = 0] = "LEFT_HANDED";
    /**
     * Projects to a right-handed coordinate system
     */
    CoordinateSystem[CoordinateSystem["RIGHT_HANDED"] = 1] = "RIGHT_HANDED";
})(exports.CoordinateSystem || (exports.CoordinateSystem = {}));

var ProjectionBase = (function (_super) {
    __extends(ProjectionBase, _super);
    function ProjectionBase(coordinateSystem) {
        if (coordinateSystem === void 0) { coordinateSystem = exports.CoordinateSystem.LEFT_HANDED; }
        var _this = _super.call(this) || this;
        _this._viewMatrix3D = new Matrix3D();
        _this._inverseViewMatrix3D = new Matrix3D();
        _this._frustumMatrix3D = new Matrix3D();
        _this._viewRect = new Rectangle();
        _this._stageRect = new Rectangle();
        _this._near = 20;
        _this._far = 3000;
        _this._frustumCorners = [];
        _this._originX = 0.5;
        _this._originY = 0.5;
        _this._viewMatrix3DDirty = true;
        _this._inverseViewMatrix3DDirty = true;
        _this._frustumMatrix3DDirty = true;
        _this._frustumPlanesDirty = true;
        _this._coordinateSystem = coordinateSystem;
        _this._onInvalidateConcatenatedMatrix3DDelegate = function (event) { return _this._onInvalidateConcatenatedMatrix3D(event); };
        return _this;
    }
    Object.defineProperty(ProjectionBase.prototype, "transform", {
        get: function () {
            return this._transform;
        },
        set: function (value) {
            if (this._transform == value)
                return;
            if (this._transform)
                this._transform.removeEventListener(TransformEvent.INVALIDATE_CONCATENATED_MATRIX3D, this._onInvalidateConcatenatedMatrix3DDelegate);
            this._transform = value;
            if (this._transform)
                this._transform.addEventListener(TransformEvent.INVALIDATE_CONCATENATED_MATRIX3D, this._onInvalidateConcatenatedMatrix3DDelegate);
            this._invalidateViewMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "coordinateSystem", {
        /**
         * The handedness of the coordinate system projection. The default is LEFT_HANDED.
         */
        get: function () {
            return this._coordinateSystem;
        },
        set: function (value) {
            if (this._coordinateSystem == value)
                return;
            this._coordinateSystem = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "frustumCorners", {
        /**
         *
         * @returns {number[]}
         */
        get: function () {
            return this._frustumCorners;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "frustumMatrix3D", {
        /**
         *
         * @returns {Matrix3D}
         */
        get: function () {
            if (this._frustumMatrix3DDirty)
                this._updateFrustumMatrix3D();
            return this._frustumMatrix3D;
        },
        set: function (value) {
            this._frustumMatrix3D = value;
            this._invalidateViewMatrix3D();
            this._invalidateProperties();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "near", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            if (this._propertiesDirty)
                this._updateProperties();
            return this._near;
        },
        set: function (value) {
            if (value == this._near)
                return;
            this._near = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "originX", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            if (this._propertiesDirty)
                this._updateProperties();
            return this._originX;
        },
        set: function (value) {
            if (this._originX == value)
                return;
            this._originX = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "originY", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            if (this._propertiesDirty)
                this._updateProperties();
            return this._originY;
        },
        set: function (value) {
            if (this._originY == value)
                return;
            this._originY = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "far", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            if (this._propertiesDirty)
                this._updateProperties();
            return this._far;
        },
        set: function (value) {
            if (value == this._far)
                return;
            this._far = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    /*
    
     */
    ProjectionBase.prototype.project = function (vector3D) {
        var v = this.viewMatrix3D.transformVector(vector3D);
        v.x = v.x / v.w;
        v.y = -v.y / v.w;
        //z is remapped to w
        v.z = v.w;
        v.w = 1;
        return v;
    };
    Object.defineProperty(ProjectionBase.prototype, "viewMatrix3D", {
        get: function () {
            if (this._viewMatrix3DDirty) {
                this._viewMatrix3DDirty = false;
                if (this._transform) {
                    this._viewMatrix3D.copyFrom(this._transform.inverseConcatenatedMatrix3D);
                    this._viewMatrix3D.append(this.frustumMatrix3D);
                }
                else {
                    this._viewMatrix3D.copyFrom(this.frustumMatrix3D);
                }
            }
            return this._viewMatrix3D;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ProjectionBase.prototype, "inverseViewMatrix3D", {
        get: function () {
            if (this._inverseViewMatrix3DDirty) {
                this._inverseViewMatrix3DDirty = false;
                this._inverseViewMatrix3D.copyFrom(this.viewMatrix3D);
                this._inverseViewMatrix3D.invert();
            }
            return this._inverseViewMatrix3D;
        },
        enumerable: true,
        configurable: true
    });
    ProjectionBase.prototype.unproject = function (nX, nY, sZ, target) {
        if (target === void 0) { target = null; }
        throw new AbstractMethodError();
    };
    ProjectionBase.prototype.clone = function () {
        throw new AbstractMethodError();
    };
    ProjectionBase.prototype._invalidateProperties = function () {
        this._propertiesDirty = true;
    };
    ProjectionBase.prototype._invalidateViewMatrix3D = function () {
        this._viewMatrix3DDirty = true;
        this._inverseViewMatrix3DDirty = true;
        this._frustumPlanesDirty = true;
        this.dispatchEvent(new ProjectionEvent(ProjectionEvent.MATRIX_CHANGED, this));
    };
    ProjectionBase.prototype._invalidateFrustumMatrix3D = function () {
        if (this._propertiesDirty)
            this._updateProperties();
        this._frustumMatrix3DDirty = true;
        this._invalidateViewMatrix3D();
    };
    ProjectionBase.prototype.setViewRect = function (x, y, width, height) {
        this._viewRect.x = x;
        this._viewRect.y = y;
        this._viewRect.width = width;
        this._viewRect.height = height;
        this._invalidateFrustumMatrix3D();
    };
    ProjectionBase.prototype.setStageRect = function (x, y, width, height) {
        this._stageRect.x = x;
        this._stageRect.y = y;
        this._stageRect.width = width;
        this._stageRect.height = height;
        this._invalidateFrustumMatrix3D();
    };
    ProjectionBase.prototype._updateFrustumMatrix3D = function () {
        this._frustumMatrix3DDirty = false;
    };
    ProjectionBase.prototype._updateProperties = function () {
        this._propertiesDirty = false;
    };
    Object.defineProperty(ProjectionBase.prototype, "frustumPlanes", {
        get: function () {
            if (this._frustumPlanesDirty)
                this._updateFrustumPlanes();
            return this._frustumPlanes;
        },
        enumerable: true,
        configurable: true
    });
    ProjectionBase.prototype._updateFrustumPlanes = function () {
        this._frustumPlanesDirty = false;
        if (!this._frustumPlanes) {
            this._frustumPlanes = [];
            for (var i = 0; i < 6; ++i)
                this._frustumPlanes[i] = new Plane3D();
        }
        var a, b, c;
        //var d : Number;
        var c11, c12, c13, c14;
        var c21, c22, c23, c24;
        var c31, c32, c33, c34;
        var c41, c42, c43, c44;
        var p;
        var raw = this.viewMatrix3D._rawData;
        var invLen;
        c11 = raw[0];
        c12 = raw[4];
        c13 = raw[8];
        c14 = raw[12];
        c21 = raw[1];
        c22 = raw[5];
        c23 = raw[9];
        c24 = raw[13];
        c31 = raw[2];
        c32 = raw[6];
        c33 = raw[10];
        c34 = raw[14];
        c41 = raw[3];
        c42 = raw[7];
        c43 = raw[11];
        c44 = raw[15];
        // left plane
        p = this._frustumPlanes[0];
        a = c41 + c11;
        b = c42 + c12;
        c = c43 + c13;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = -(c44 + c14) * invLen;
        // right plane
        p = this._frustumPlanes[1];
        a = c41 - c11;
        b = c42 - c12;
        c = c43 - c13;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = (c14 - c44) * invLen;
        // bottom
        p = this._frustumPlanes[2];
        a = c41 + c21;
        b = c42 + c22;
        c = c43 + c23;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = -(c44 + c24) * invLen;
        // top
        p = this._frustumPlanes[3];
        a = c41 - c21;
        b = c42 - c22;
        c = c43 - c23;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = (c24 - c44) * invLen;
        // near
        p = this._frustumPlanes[4];
        a = c31;
        b = c32;
        c = c33;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = -c34 * invLen;
        // far
        p = this._frustumPlanes[5];
        a = c41 - c31;
        b = c42 - c32;
        c = c43 - c33;
        invLen = 1 / Math.sqrt(a * a + b * b + c * c);
        p.a = a * invLen;
        p.b = b * invLen;
        p.c = c * invLen;
        p.d = (c34 - c44) * invLen;
    };
    ProjectionBase.prototype._onInvalidateConcatenatedMatrix3D = function (event) {
        this._invalidateViewMatrix3D();
    };
    return ProjectionBase;
}(EventDispatcher));

var ObliqueNearPlaneProjection = (function (_super) {
    __extends(ObliqueNearPlaneProjection, _super);
    function ObliqueNearPlaneProjection(baseProjection, plane) {
        var _this = _super.call(this) || this;
        _this.baseProjection = baseProjection;
        _this.plane = plane;
        _this._onProjectionMatrixChangedDelegate = function (event) { return _this.onProjectionMatrixChanged(event); };
        return _this;
    }
    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "frustumCorners", {
        //@override
        get: function () {
            return this._baseProjection.frustumCorners;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "near", {
        //@override
        get: function () {
            return this._baseProjection.near;
        },
        //@override
        set: function (value) {
            this._baseProjection.near = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "far", {
        //@override
        get: function () {
            return this._baseProjection.far;
        },
        //@override
        set: function (value) {
            this._baseProjection.far = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "plane", {
        get: function () {
            return this._plane;
        },
        set: function (value) {
            this._plane = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ObliqueNearPlaneProjection.prototype, "baseProjection", {
        set: function (value) {
            if (this._baseProjection)
                this._baseProjection.removeEventListener(ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
            this._baseProjection = value;
            if (this._baseProjection)
                this._baseProjection.addEventListener(ProjectionEvent.MATRIX_CHANGED, this._onProjectionMatrixChangedDelegate);
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    ObliqueNearPlaneProjection.prototype.onProjectionMatrixChanged = function (event) {
        this._invalidateFrustumMatrix3D();
    };
    //@override
    ObliqueNearPlaneProjection.prototype._updateFrustumMatrix3D = function () {
        _super.prototype._updateFrustumMatrix3D.call(this);
        this._frustumMatrix3D.copyFrom(this._baseProjection.frustumMatrix3D);
        var cx = this._plane.a;
        var cy = this._plane.b;
        var cz = this._plane.c;
        var cw = -this._plane.d + .05;
        var signX = cx >= 0 ? 1 : -1;
        var signY = cy >= 0 ? 1 : -1;
        var p = new Vector3D(signX, signY, 1, 1);
        var inverse = this._frustumMatrix3D.clone();
        inverse.invert();
        var q = inverse.transformVector(p);
        this._frustumMatrix3D.copyRowTo(3, p);
        var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);
        this._frustumMatrix3D.copyRowFrom(2, new Vector3D(cx * a, cy * a, cz * a, cw * a));
    };
    return ObliqueNearPlaneProjection;
}(ProjectionBase));

var OrthographicOffCenterProjection = (function (_super) {
    __extends(OrthographicOffCenterProjection, _super);
    function OrthographicOffCenterProjection(minX, maxX, minY, maxY) {
        var _this = _super.call(this) || this;
        _this._minX = minX;
        _this._maxX = maxX;
        _this._minY = minY;
        _this._maxY = maxY;
        return _this;
    }
    Object.defineProperty(OrthographicOffCenterProjection.prototype, "minX", {
        get: function () {
            return this._minX;
        },
        set: function (value) {
            this._minX = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OrthographicOffCenterProjection.prototype, "maxX", {
        get: function () {
            return this._maxX;
        },
        set: function (value) {
            this._maxX = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OrthographicOffCenterProjection.prototype, "minY", {
        get: function () {
            return this._minY;
        },
        set: function (value) {
            this._minY = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(OrthographicOffCenterProjection.prototype, "maxY", {
        get: function () {
            return this._maxY;
        },
        set: function (value) {
            this._maxY = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    //@override
    OrthographicOffCenterProjection.prototype.unproject = function (nX, nY, sZ) {
        var v = new Vector3D(nX, -nY, sZ, 1.0);
        v = this.inverseViewMatrix3D.transformVector(v);
        //z is unaffected by transform
        v.z = sZ;
        return v;
    };
    //@override
    OrthographicOffCenterProjection.prototype.clone = function () {
        var clone = new OrthographicOffCenterProjection(this._minX, this._maxX, this._minY, this._maxY);
        clone._near = this._near;
        clone._far = this._far;
        return clone;
    };
    //@override
    OrthographicOffCenterProjection.prototype._updateFrustumMatrix3D = function () {
        _super.prototype._updateFrustumMatrix3D.call(this);
        var raw = Matrix3D.CALCULATION_MATRIX._rawData;
        var w = 1 / (this._maxX - this._minX);
        var h = 1 / (this._maxY - this._minY);
        var d = 1 / (this._far - this._near);
        raw[0] = 2 * w;
        raw[5] = 2 * h;
        raw[10] = d;
        raw[12] = -(this._maxX + this._minX) * w;
        raw[13] = -(this._maxY + this._minY) * h;
        raw[14] = -this._near * d;
        raw[15] = 1;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
        this._frustumMatrix3D.copyRawDataFrom(raw);
        this._frustumCorners[0] = this._frustumCorners[9] = this._frustumCorners[12] = this._frustumCorners[21] = this._minX;
        this._frustumCorners[3] = this._frustumCorners[6] = this._frustumCorners[15] = this._frustumCorners[18] = this._maxX;
        this._frustumCorners[1] = this._frustumCorners[4] = this._frustumCorners[13] = this._frustumCorners[16] = this._minY;
        this._frustumCorners[7] = this._frustumCorners[10] = this._frustumCorners[19] = this._frustumCorners[22] = this._maxY;
        this._frustumCorners[2] = this._frustumCorners[5] = this._frustumCorners[8] = this._frustumCorners[11] = this._near;
        this._frustumCorners[14] = this._frustumCorners[17] = this._frustumCorners[20] = this._frustumCorners[23] = this._far;
    };
    return OrthographicOffCenterProjection;
}(ProjectionBase));

var OrthographicProjection = (function (_super) {
    __extends(OrthographicProjection, _super);
    function OrthographicProjection(projectionHeight) {
        if (projectionHeight === void 0) { projectionHeight = 500; }
        var _this = _super.call(this) || this;
        _this._projectionHeight = projectionHeight;
        return _this;
    }
    Object.defineProperty(OrthographicProjection.prototype, "projectionHeight", {
        get: function () {
            return this._projectionHeight;
        },
        set: function (value) {
            if (value == this._projectionHeight)
                return;
            this._projectionHeight = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    //@override
    OrthographicProjection.prototype.unproject = function (nX, nY, sZ, target) {
        if (target === void 0) { target = null; }
        if (target == null)
            target = new Vector3D();
        target.x = nX + this.viewMatrix3D._rawData[12];
        target.y = -nY + this.viewMatrix3D._rawData[13];
        target.z = sZ;
        target.w = 1.0;
        this.inverseViewMatrix3D.transformVector(target, target);
        //z is unaffected by transform
        target.z = sZ;
        return target;
    };
    //@override
    OrthographicProjection.prototype.clone = function () {
        var clone = new OrthographicProjection();
        clone._near = this._near;
        clone._far = this._far;
        clone.projectionHeight = this._projectionHeight;
        return clone;
    };
    //@override
    OrthographicProjection.prototype._updateFrustumMatrix3D = function () {
        _super.prototype._updateFrustumMatrix3D.call(this);
        var raw = Matrix3D.CALCULATION_MATRIX._rawData;
        this._yMax = this._projectionHeight * .5;
        this._xMax = this._yMax * this._viewRect.width / this._viewRect.height;
        var left;
        var right;
        var top;
        var bottom;
        if (this._viewRect.x == 0 && this._viewRect.y == 0 && this._viewRect.width == this._stageRect.width && this._viewRect.height == this._stageRect.height) {
            // assume symmetric frustum
            left = -this._xMax;
            right = this._xMax;
            top = -this._yMax;
            bottom = this._yMax;
            raw[0] = 2 / (this._projectionHeight * this._viewRect.width / this._viewRect.height);
            raw[5] = 2 / this._projectionHeight;
            raw[10] = 1 / (this._far - this._near);
            raw[14] = this._near / (this._near - this._far);
            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = raw[12] = raw[13] = 0;
            raw[15] = 1;
        }
        else {
            var xWidth = this._xMax * (this._stageRect.width / this._viewRect.width);
            var yHgt = this._yMax * (this._stageRect.height / this._viewRect.height);
            var center = this._xMax * (this._viewRect.x * 2 - this._stageRect.width) / this._viewRect.width + this._xMax;
            var middle = -this._yMax * (this._viewRect.y * 2 - this._stageRect.height) / this._viewRect.height - this._yMax;
            left = center - xWidth;
            right = center + xWidth;
            top = middle - yHgt;
            bottom = middle + yHgt;
            raw[0] = 2 * 1 / (right - left);
            raw[5] = -2 * 1 / (top - bottom);
            raw[10] = 1 / (this._far - this._near);
            raw[12] = (right + left) / (right - left);
            raw[13] = (bottom + top) / (bottom - top);
            raw[14] = this._near / (this.near - this.far);
            raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
            raw[15] = 1;
        }
        this._frustumCorners[0] = this._frustumCorners[9] = this._frustumCorners[12] = this._frustumCorners[21] = left;
        this._frustumCorners[3] = this._frustumCorners[6] = this._frustumCorners[15] = this._frustumCorners[18] = right;
        this._frustumCorners[1] = this._frustumCorners[4] = this._frustumCorners[13] = this._frustumCorners[16] = top;
        this._frustumCorners[7] = this._frustumCorners[10] = this._frustumCorners[19] = this._frustumCorners[22] = bottom;
        this._frustumCorners[2] = this._frustumCorners[5] = this._frustumCorners[8] = this._frustumCorners[11] = this._near;
        this._frustumCorners[14] = this._frustumCorners[17] = this._frustumCorners[20] = this._frustumCorners[23] = this._far;
        this._frustumMatrix3D.copyRawDataFrom(raw);
    };
    return OrthographicProjection;
}(ProjectionBase));

var PerspectiveProjection = (function (_super) {
    __extends(PerspectiveProjection, _super);
    function PerspectiveProjection(fieldOfView, coordinateSystem) {
        if (fieldOfView === void 0) { fieldOfView = 60; }
        if (coordinateSystem === void 0) { coordinateSystem = exports.CoordinateSystem.LEFT_HANDED; }
        var _this = _super.call(this, coordinateSystem) || this;
        _this._fieldOfView = 60;
        _this._focalLength = 1000;
        _this._hFieldOfView = 60;
        _this._hFocalLength = 1000;
        _this._preserveAspectRatio = true;
        _this._preserveFocalLength = false;
        _this.fieldOfView = fieldOfView;
        return _this;
    }
    Object.defineProperty(PerspectiveProjection.prototype, "preserveAspectRatio", {
        /**
         *
         */
        get: function () {
            return this._preserveAspectRatio;
        },
        set: function (value) {
            if (this._preserveAspectRatio == value)
                return;
            this._preserveAspectRatio = value;
            if (this._preserveAspectRatio)
                this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "preserveFocalLength", {
        /**
         *
         */
        get: function () {
            return this._preserveFocalLength;
        },
        set: function (value) {
            if (this._preserveFocalLength == value)
                return;
            this._preserveFocalLength = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "fieldOfView", {
        /**
         *
         */
        get: function () {
            if (this._frustumMatrix3DDirty && this._preserveFocalLength)
                this._updateFrustumMatrix3D();
            return this._fieldOfView;
        },
        set: function (value) {
            if (this._fieldOfView == value)
                return;
            this._fieldOfView = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "focalLength", {
        /**
         *
         */
        get: function () {
            if (this._frustumMatrix3DDirty && !this._preserveFocalLength)
                this._updateFrustumMatrix3D();
            return this._focalLength;
        },
        set: function (value) {
            if (this._focalLength == value)
                return;
            this._focalLength = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "hFieldOfView", {
        /**
         *
         */
        get: function () {
            if (this._frustumMatrix3DDirty && this._preserveFocalLength)
                this._updateFrustumMatrix3D();
            return this._hFieldOfView;
        },
        set: function (value) {
            if (this._hFieldOfView == value)
                return;
            this._hFieldOfView = value;
            this._hFocalLength = 1 / Math.tan(this._hFieldOfView * Math.PI / 360);
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PerspectiveProjection.prototype, "hFocalLength", {
        /**
         *
         */
        get: function () {
            if (this._frustumMatrix3DDirty && !this._preserveFocalLength)
                this._updateFrustumMatrix3D();
            return this._hFocalLength;
        },
        set: function (value) {
            if (this._hFocalLength == value)
                return;
            this._hFocalLength = value;
            this._invalidateFrustumMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    //@override
    PerspectiveProjection.prototype.unproject = function (nX, nY, sZ, target) {
        if (target === void 0) { target = null; }
        if (target == null)
            target = new Vector3D();
        target.x = nX * sZ;
        target.y = -nY * sZ;
        target.z = (this._far + this._near) / (this._far - this._near) * sZ - 2 * this._far * this._near / (this._far - this._near);
        target.w = sZ;
        this.inverseViewMatrix3D.transformVector(target, target);
        target.w = 1;
        return target;
    };
    /**
     *
     * @returns {PerspectiveProjection}
     */
    PerspectiveProjection.prototype.clone = function () {
        var clone = new PerspectiveProjection(this._fieldOfView, this._coordinateSystem);
        clone._hFieldOfView = this.hFieldOfView;
        clone._preserveAspectRatio = this._preserveAspectRatio;
        clone._preserveFocalLength = this._preserveFocalLength;
        clone._near = this._near;
        clone._far = this._far;
        clone._coordinateSystem = this._coordinateSystem;
        return clone;
    };
    /**
     *
     * @private
     */
    PerspectiveProjection.prototype._updateFrustumMatrix3D = function () {
        _super.prototype._updateFrustumMatrix3D.call(this);
        var raw = Matrix3D.CALCULATION_MATRIX._rawData;
        if (this._preserveFocalLength) {
            if (this._preserveAspectRatio)
                this._hFocalLength = this._focalLength;
            this._fieldOfView = Math.atan(0.5 * this._viewRect.height / this._focalLength) * 360 / Math.PI;
            this._hFieldOfView = Math.atan(0.5 * this._viewRect.width / this._hFocalLength) * 360 / Math.PI;
        }
        else {
            this._focalLength = 0.5 * this._viewRect.height / Math.tan(this._fieldOfView * Math.PI / 360);
            if (this._preserveAspectRatio)
                this._hFocalLength = this._focalLength;
            else
                this._hFocalLength = 0.5 * this._viewRect.width / Math.tan(this._hFieldOfView * Math.PI / 360);
        }
        // assume scissored frustum
        var right = (this._viewRect.x + this._originX * this._viewRect.width) / this._hFocalLength;
        var top = -(this._viewRect.y + this._originY * this._viewRect.height) / this._focalLength;
        var left = right - this._stageRect.width / this._hFocalLength;
        var bottom = top + this._stageRect.height / this._focalLength;
        raw[0] = 2 / (right - left);
        raw[5] = 2 / (bottom - top);
        raw[8] = (right + left) / (right - left);
        raw[9] = (bottom + top) / (bottom - top);
        raw[10] = (this._far + this._near) / (this._far - this._near);
        raw[11] = 1;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[12] = raw[13] = raw[15] = 0;
        raw[14] = -2 * this._far * this._near / (this._far - this._near);
        if (this._coordinateSystem == exports.CoordinateSystem.RIGHT_HANDED)
            raw[5] = -raw[5];
        this._frustumMatrix3D.copyRawDataFrom(raw);
        this._frustumCorners[0] = this._frustumCorners[9] = this._near * left;
        this._frustumCorners[3] = this._frustumCorners[6] = this._near * right;
        this._frustumCorners[1] = this._frustumCorners[4] = this._near * top;
        this._frustumCorners[7] = this._frustumCorners[10] = this._near * bottom;
        this._frustumCorners[12] = this._frustumCorners[21] = this._far * left;
        this._frustumCorners[15] = this._frustumCorners[18] = this._far * right;
        this._frustumCorners[13] = this._frustumCorners[16] = this._far * top;
        this._frustumCorners[19] = this._frustumCorners[22] = this._far * bottom;
        this._frustumCorners[2] = this._frustumCorners[5] = this._frustumCorners[8] = this._frustumCorners[11] = this._near;
        this._frustumCorners[14] = this._frustumCorners[17] = this._frustumCorners[20] = this._frustumCorners[23] = this._far;
    };
    PerspectiveProjection.prototype._updateProperties = function () {
        _super.prototype._updateProperties.call(this);
        var rawData = this._frustumMatrix3D._rawData;
        this._near = rawData[14] / (-1 - rawData[10]);
        this._far = rawData[14] / (1 - rawData[10]);
        //rawData[8] = 2*(this._viewRect.x + this._originX*this._viewRect.width)/this._stageRect.width - 1;
        this._originX = ((rawData[8] + 1) * this._stageRect.width / 2 - this._viewRect.x) / this._viewRect.width;
        //rawData[9] = 1 - 2*(this._viewRect.y + this._originY*this._viewRect.height)/this._stageRect.height;
        this._originY = ((1 - rawData[9]) * this._stageRect.height / 2 - this._viewRect.y) / this._viewRect.height;
    };
    return PerspectiveProjection;
}(ProjectionBase));

var Keyboard = (function () {
    function Keyboard() {
    }
    return Keyboard;
}());
/**
 * Constant associated with the key code value for the A key (65).
 */
Keyboard.A = 65;
/**
 * Constant associated with the key code value for the Alternate (Option) key  (18).
 */
Keyboard.ALTERNATE = 18;
/**
 * Select the audio mode
 */
Keyboard.AUDIO = 0x01000017;
/**
 * Constant associated with the key code value for the B key (66).
 */
Keyboard.B = 66;
/**
 * Return to previous page in application
 */
Keyboard.BACK = 0x01000016;
/**
 * Constant associated with the key code value for the ` key (192).
 */
Keyboard.BACKQUOTE = 192;
/**
 * Constant associated with the key code value for the \ key (220).
 */
Keyboard.BACKSLASH = 220;
/**
 * Constant associated with the key code value for the Backspace key (8).
 */
Keyboard.BACKSPACE = 8;
/**
 * Blue function key button
 */
Keyboard.BLUE = 0x01000003;
/**
 * Constant associated with the key code value for the C key (67).
 */
Keyboard.C = 67;
/**
 * Constant associated with the key code value for the Caps Lock key (20).
 */
Keyboard.CAPS_LOCK = 20;
/**
 * Channel down
 */
Keyboard.CHANNEL_DOWN = 0x01000005;
/**
 * Channel up
 */
Keyboard.CHANNEL_UP = 0x01000005;
/**
 * Constant associated with the key code value for the , key (188).
 */
Keyboard.COMMA = 188;
/**
 * Constant associated with the Mac command key (15). This constant is
 * currently only used for setting menu key equivalents.
 */
Keyboard.COMMAND = 15;
/**
 * Constant associated with the key code value for the Control key (17).
 */
Keyboard.CONTROL = 17;
/**
 * Constant associated with the key code value for the D key (68).
 */
Keyboard.D = 68;
/**
 * Constant associated with the key code value for the Delete key (46).
 */
Keyboard.DELETE = 46;
/**
 * Constant associated with the key code value for the Down Arrow key (40).
 */
Keyboard.DOWN = 40;
/**
 * Engage DVR application mode
 */
Keyboard.DVR = 0x01000019;
/**
 * Constant associated with the key code value for the E key (69).
 */
Keyboard.E = 69;
/**
 * Constant associated with the key code value for the End key (35).
 */
Keyboard.END = 35;
/**
 * Constant associated with the key code value for the Enter key (13).
 */
Keyboard.ENTER = 13;
/**
 * Constant associated with the key code value for the = key (187).
 */
Keyboard.EQUAL = 187;
/**
 * Constant associated with the key code value for the Escape key (27).
 */
Keyboard.ESCAPE = 27;
/**
 * Exits current application mode
 */
Keyboard.EXIT = 0x01000015;
/**
 * Constant associated with the key code value for the F key (70).
 */
Keyboard.F = 70;
/**
 * Constant associated with the key code value for the F1 key (112).
 */
Keyboard.F1 = 112;
/**
 * Constant associated with the key code value for the F10 key (121).
 */
Keyboard.F10 = 121;
/**
 * Constant associated with the key code value for the F11 key (122).
 */
Keyboard.F11 = 122;
/**
 * Constant associated with the key code value for the F12 key (123).
 */
Keyboard.F12 = 123;
/**
 * Constant associated with the key code value for the F13 key (124).
 */
Keyboard.F13 = 124;
/**
 * Constant associated with the key code value for the F14 key (125).
 */
Keyboard.F14 = 125;
/**
 * Constant associated with the key code value for the F15 key (126).
 */
Keyboard.F15 = 126;
/**
 * Constant associated with the key code value for the F2 key (113).
 */
Keyboard.F2 = 113;
/**
 * Constant associated with the key code value for the F3 key (114).
 */
Keyboard.F3 = 114;
/**
 * Constant associated with the key code value for the F4 key (115).
 */
Keyboard.F4 = 115;
/**
 * Constant associated with the key code value for the F5 key (116).
 */
Keyboard.F5 = 116;
/**
 * Constant associated with the key code value for the F6 key (117).
 */
Keyboard.F6 = 117;
/**
 * Constant associated with the key code value for the F7 key (118).
 */
Keyboard.F7 = 118;
/**
 * Constant associated with the key code value for the F8 key (119).
 */
Keyboard.F8 = 119;
/**
 * Constant associated with the key code value for the F9 key (120).
 */
Keyboard.F9 = 120;
/**
 * Engage fast-forward transport mode
 */
Keyboard.FAST_FORWARD = 0x0100000A;
/**
 * Constant associated with the key code value for the G key (71).
 */
Keyboard.G = 71;
/**
 * Green function key button
 */
Keyboard.GREEN = 0x01000001;
/**
 * Engage program guide
 */
Keyboard.GUIDE = 0x01000014;
/**
 * Constant associated with the key code value for the H key (72).
 */
Keyboard.H = 72;
/**
 * Engage help application or context-sensitive help
 */
Keyboard.HELP = 0x0100001D;
/**
 * Constant associated with the key code value for the Home key (36).
 */
Keyboard.HOME = 36;
/**
 * Constant associated with the key code value for the I key (73).
 */
Keyboard.I = 73;
/**
 * Info button
 */
Keyboard.INFO = 0x01000013;
/**
 * Cycle input
 */
Keyboard.INPUT = 0x0100001B;
/**
 * Constant associated with the key code value for the Insert key (45).
 */
Keyboard.INSERT = 45;
/**
 * Constant associated with the key code value for the J key (74).
 */
Keyboard.J = 74;
/**
 * Constant associated with the key code value for the K key (75).
 */
Keyboard.K = 75;
/**
 * The Begin key
 */
Keyboard.KEYNAME_BEGIN = "Begin";
/**
 * The Break key
 */
Keyboard.KEYNAME_BREAK = "Break";
/**
 * The Clear Display key
 */
Keyboard.KEYNAME_CLEARDISPLAY = "ClrDsp";
/**
 * The Clear Line key
 */
Keyboard.KEYNAME_CLEARLINE = "ClrLn";
/**
 * The Delete key
 */
Keyboard.KEYNAME_DELETE = "Delete";
/**
 * The Delete Character key
 */
Keyboard.KEYNAME_DELETECHAR = "DelChr";
/**
 * The Delete Line key
 */
Keyboard.KEYNAME_DELETELINE = "DelLn";
/**
 * The down arrow
 */
Keyboard.KEYNAME_DOWNARROW = "Down";
/**
 * The End key
 */
Keyboard.KEYNAME_END = "End";
/**
 * The Execute key
 */
Keyboard.KEYNAME_EXECUTE = "Exec";
/**
 * The F1 key
 */
Keyboard.KEYNAME_F1 = "F1";
/**
 * The F10 key
 */
Keyboard.KEYNAME_F10 = "F10";
/**
 * The F11 key
 */
Keyboard.KEYNAME_F11 = "F11";
/**
 * The F12 key
 */
Keyboard.KEYNAME_F12 = "F12";
/**
 * The F13 key
 */
Keyboard.KEYNAME_F13 = "F13";
/**
 * The F14 key
 */
Keyboard.KEYNAME_F14 = "F14";
/**
 * The F15 key
 */
Keyboard.KEYNAME_F15 = "F15";
/**
 * The F16 key
 */
Keyboard.KEYNAME_F16 = "F16";
/**
 * The F17 key
 */
Keyboard.KEYNAME_F17 = "F17";
/**
 * The F18 key
 */
Keyboard.KEYNAME_F18 = "F18";
/**
 * The F19 key
 */
Keyboard.KEYNAME_F19 = "F19";
/**
 * The F2 key
 */
Keyboard.KEYNAME_F2 = "F2";
/**
 * The F20 key
 */
Keyboard.KEYNAME_F20 = "F20";
/**
 * The F21 key
 */
Keyboard.KEYNAME_F21 = "F21";
/**
 * The F22 key
 */
Keyboard.KEYNAME_F22 = "F22";
/**
 * The F23 key
 */
Keyboard.KEYNAME_F23 = "F23";
/**
 * The F24 key
 */
Keyboard.KEYNAME_F24 = "F24";
/**
 * The F25 key
 */
Keyboard.KEYNAME_F25 = "F25";
/**
 * The F26 key
 */
Keyboard.KEYNAME_F26 = "F26";
/**
 * The F27 key
 */
Keyboard.KEYNAME_F27 = "F27";
/**
 * The F28 key
 */
Keyboard.KEYNAME_F28 = "F28";
/**
 * The F29 key
 */
Keyboard.KEYNAME_F29 = "F29";
/**
 * The F3 key
 */
Keyboard.KEYNAME_F3 = "F3";
/**
 * The F30 key
 */
Keyboard.KEYNAME_F30 = "F30";
/**
 * The F31 key
 */
Keyboard.KEYNAME_F31 = "F31";
/**
 * The F32 key
 */
Keyboard.KEYNAME_F32 = "F32";
/**
 * The F33 key
 */
Keyboard.KEYNAME_F33 = "F33";
/**
 * The F34 key
 */
Keyboard.KEYNAME_F34 = "F34";
/**
 * The F35 key
 */
Keyboard.KEYNAME_F35 = "F35";
/**
 * The F4 key
 */
Keyboard.KEYNAME_F4 = "F4";
/**
 * The F5 key
 */
Keyboard.KEYNAME_F5 = "F5";
/**
 * The F6 key
 */
Keyboard.KEYNAME_F6 = "F6";
/**
 * The F7 key
 */
Keyboard.KEYNAME_F7 = "F7";
/**
 * The F8 key
 */
Keyboard.KEYNAME_F8 = "F8";
/**
 * The F9 key
 */
Keyboard.KEYNAME_F9 = "F9";
/**
 * The Find key
 */
Keyboard.KEYNAME_FIND = "Find";
/**
 * The Help key
 */
Keyboard.KEYNAME_HELP = "Help";
/**
 * The Home key
 */
Keyboard.KEYNAME_HOME = "Home";
/**
 * The Insert key
 */
Keyboard.KEYNAME_INSERT = "Insert";
/**
 * The Insert Character key
 */
Keyboard.KEYNAME_INSERTCHAR = "InsChr";
/**
 * The Insert Line key
 */
Keyboard.KEYNAME_INSERTLINE = "LnsLn";
/**
 * The left arrow
 */
Keyboard.KEYNAME_LEFTARROW = "Left";
/**
 * The Menu key
 */
Keyboard.KEYNAME_MENU = "Menu";
/**
 * The Mode Switch key
 */
Keyboard.KEYNAME_MODESWITCH = "ModeSw";
/**
 * The Next key
 */
Keyboard.KEYNAME_NEXT = "Next";
/**
 * The Page Down key
 */
Keyboard.KEYNAME_PAGEDOWN = "PgDn";
/**
 * The Page Up key
 */
Keyboard.KEYNAME_PAGEUP = "PgUp";
/**
 * The Pause key
 */
Keyboard.KEYNAME_PAUSE = "Pause";
/**
 * The Previous key
 */
Keyboard.KEYNAME_PREV = "Prev";
/**
 * The PRINT key
 */
Keyboard.KEYNAME_PRINT = "Print";
/**
 * The PRINT Screen
 */
Keyboard.KEYNAME_PRINTSCREEN = "PrntScrn";
/**
 * The Redo key
 */
Keyboard.KEYNAME_REDO = "Redo";
/**
 * The Reset key
 */
Keyboard.KEYNAME_RESET = "Reset";
/**
 * The right arrow
 */
Keyboard.KEYNAME_RIGHTARROW = "Right";
/**
 * The Scroll Lock key
 */
Keyboard.KEYNAME_SCROLLLOCK = "ScrlLck";
/**
 * The Select key
 */
Keyboard.KEYNAME_SELECT = "Select";
/**
 * The Stop key
 */
Keyboard.KEYNAME_STOP = "Stop";
/**
 * The System Request key
 */
Keyboard.KEYNAME_SYSREQ = "SysReq";
/**
 * The System key
 */
Keyboard.KEYNAME_SYSTEM = "Sys";
/**
 * The Undo key
 */
Keyboard.KEYNAME_UNDO = "Undo";
/**
 * The up arrow
 */
Keyboard.KEYNAME_UPARROW = "Up";
/**
 * The User key
 */
Keyboard.KEYNAME_USER = "User";
/**
 * Constant associated with the key code value for the L key (76).
 */
Keyboard.L = 76;
/**
 * Watch last channel or show watched
 */
Keyboard.LAST = 0x01000011;
/**
 * Constant associated with the key code value for the Left Arrow key (37).
 */
Keyboard.LEFT = 37;
/**
 * Constant associated with the key code value for the [ key (219).
 */
Keyboard.LEFTBRACKET = 219;
/**
 * Return to live [position in broadcast]
 */
Keyboard.LIVE = 0x01000010;
/**
 * Constant associated with the key code value for the M key (77).
 */
Keyboard.M = 77;
/**
 * Engage "Master Shell" e.g. TiVo or other vendor button
 */
Keyboard.MASTER_SHELL = 0x0100001E;
/**
 * Engage menu
 */
Keyboard.MENU = 0x01000012;
/**
 * Constant associated with the key code value for the - key (189).
 */
Keyboard.MINUS = 189;
/**
 * Constant associated with the key code value for the N key (78).
 */
Keyboard.N = 78;
/**
 * Skip to next track or chapter
 */
Keyboard.NEXT = 0x0100000E;
/**
 * Constant associated with the key code value for the 0 key (48).
 */
Keyboard.NUMBER_0 = 48;
/**
 * Constant associated with the key code value for the 1 key (49).
 */
Keyboard.NUMBER_1 = 49;
/**
 * Constant associated with the key code value for the 2 key (50).
 */
Keyboard.NUMBER_2 = 50;
/**
 * Constant associated with the key code value for the 3 key (51).
 */
Keyboard.NUMBER_3 = 51;
/**
 * Constant associated with the key code value for the 4 key (52).
 */
Keyboard.NUMBER_4 = 52;
/**
 * Constant associated with the key code value for the 5 key (53).
 */
Keyboard.NUMBER_5 = 53;
/**
 * Constant associated with the key code value for the 6 key (54).
 */
Keyboard.NUMBER_6 = 54;
/**
 * Constant associated with the key code value for the 7 key (55).
 */
Keyboard.NUMBER_7 = 55;
/**
 * Constant associated with the key code value for the 8 key (56).
 */
Keyboard.NUMBER_8 = 56;
/**
 * Constant associated with the key code value for the 9 key (57).
 */
Keyboard.NUMBER_9 = 57;
/**
 * Constant associated with the pseudo-key code for the the number pad (21). Use to set numpad modifier on key equivalents
 */
Keyboard.NUMPAD = 21;
/**
 * Constant associated with the key code value for the number 0 key on the number pad (96).
 */
Keyboard.NUMPAD_0 = 96;
/**
 * Constant associated with the key code value for the number 1 key on the number pad (97).
 */
Keyboard.NUMPAD_1 = 97;
/**
 * Constant associated with the key code value for the number 2 key on the number pad (98).
 */
Keyboard.NUMPAD_2 = 98;
/**
 * Constant associated with the key code value for the number 3 key on the number pad (99).
 */
Keyboard.NUMPAD_3 = 99;
/**
 * Constant associated with the key code value for the number 4 key on the number pad (100).
 */
Keyboard.NUMPAD_4 = 100;
/**
 * Constant associated with the key code value for the number 5 key on the number pad (101).
 */
Keyboard.NUMPAD_5 = 101;
/**
 * Constant associated with the key code value for the number 6 key on the number pad (102).
 */
Keyboard.NUMPAD_6 = 102;
/**
 * Constant associated with the key code value for the number 7 key on the number pad (103).
 */
Keyboard.NUMPAD_7 = 103;
/**
 * Constant associated with the key code value for the number 8 key on the number pad (104).
 */
Keyboard.NUMPAD_8 = 104;
/**
 * Constant associated with the key code value for the number 9 key on the number pad (105).
 */
Keyboard.NUMPAD_9 = 105;
/**
 * Constant associated with the key code value for the addition key on the number pad (107).
 */
Keyboard.NUMPAD_ADD = 107;
/**
 * Constant associated with the key code value for the decimal key on the number pad (110).
 */
Keyboard.NUMPAD_DECIMAL = 110;
/**
 * Constant associated with the key code value for the division key on the number pad (111).
 */
Keyboard.NUMPAD_DIVIDE = 111;
/**
 * Constant associated with the key code value for the Enter key on the number pad (108).
 */
Keyboard.NUMPAD_ENTER = 108;
/**
 * Constant associated with the key code value for the multiplication key on the number pad (106).
 */
Keyboard.NUMPAD_MULTIPLY = 106;
/**
 * Constant associated with the key code value for the subtraction key on the number pad (109).
 */
Keyboard.NUMPAD_SUBTRACT = 109;
/**
 * Constant associated with the key code value for the O key (79).
 */
Keyboard.O = 79;
/**
 * Constant associated with the key code value for the P key (80).
 */
Keyboard.P = 80;
/**
 * Constant associated with the key code value for the Page Down key (34).
 */
Keyboard.PAGE_DOWN = 34;
/**
 * Constant associated with the key code value for the Page Up key (33).
 */
Keyboard.PAGE_UP = 33;
/**
 * Engage pause transport mode
 */
Keyboard.PAUSE = 0x01000008;
/**
 * Constant associated with the key code value for the . key (190).
 */
Keyboard.PERIOD = 190;
/**
 * Engage play transport mode
 */
Keyboard.PLAY = 0x01000007;
/**
 * Skip to previous track or chapter
 */
Keyboard.PREVIOUS = 0x0100000F;
/**
 * Constant associated with the key code value for the Q key (81).
 */
Keyboard.Q = 81;
/**
 * Constant associated with the key code value for the ' key (222).
 */
Keyboard.QUOTE = 222;
/**
 * Constant associated with the key code value for the R key (82).
 */
Keyboard.R = 82;
/**
 * Record item or engage record transport mode
 */
Keyboard.RECORD = 0x01000006;
/**
 * Red function key button
 */
Keyboard.RED = 0x01000000;
/**
 * Engage rewind transport mode
 */
Keyboard.REWIND = 0x0100000B;
/**
 * Constant associated with the key code value for the Right Arrow key (39).
 */
Keyboard.RIGHT = 39;
/**
 * Constant associated with the key code value for the ] key (221).
 */
Keyboard.RIGHTBRACKET = 221;
/**
 * Constant associated with the key code value for the S key (83).
 */
Keyboard.S = 83;
/**
 * Search button
 */
Keyboard.SEARCH = 0x0100001F;
/**
 * Constant associated with the key code value for the ; key (186).
 */
Keyboard.SEMICOLON = 186;
/**
 * Engage setup application or menu
 */
Keyboard.SETUP = 0x0100001C;
/**
 * Constant associated with the key code value for the Shift key (16).
 */
Keyboard.SHIFT = 16;
/**
 * Quick skip backward (usually 7-10 seconds)
 */
Keyboard.SKIP_BACKWARD = 0x0100000D;
/**
 * Quick skip ahead (usually 30 seconds)
 */
Keyboard.SKIP_FORWARD = 0x0100000C;
/**
 * Constant associated with the key code value for the / key (191).
 */
Keyboard.SLASH = 191;
/**
 * Constant associated with the key code value for the Spacebar (32).
 */
Keyboard.SPACE = 32;
/**
 * Engage stop transport mode
 */
Keyboard.STOP = 0x01000009;
/**
 * Toggle subtitles
 */
Keyboard.SUBTITLE = 0x01000018;
/**
 * Constant associated with the key code value for the T key (84).
 */
Keyboard.T = 84;
/**
 * Constant associated with the key code value for the Tab key (9).
 */
Keyboard.TAB = 9;
/**
 * Constant associated with the key code value for the U key (85).
 */
Keyboard.U = 85;
/**
 * Constant associated with the key code value for the Up Arrow key (38).
 */
Keyboard.UP = 38;
/**
 * Constant associated with the key code value for the V key (86).
 */
Keyboard.V = 86;
/**
 * Engage video-on-demand
 */
Keyboard.VOD = 0x0100001A;
/**
 * Constant associated with the key code value for the W key (87).
 */
Keyboard.W = 87;
/**
 * Constant associated with the key code value for the X key (88).
 */
Keyboard.X = 88;
/**
 * Constant associated with the key code value for the Y key (89).
 */
Keyboard.Y = 89;
/**
 * Yellow function key button
 */
Keyboard.YELLOW = 0x01000002;
/**
 * Constant associated with the key code value for the Z key (90).
 */
Keyboard.Z = 90;

var Byte32Array = (function () {
    function Byte32Array(byteLength) {
        if (byteLength === void 0) { byteLength = 0; }
        this._maxLength = -1;
        this.bytePosition = 0;
        this.byteLength = -1;
        this._ensureSpace(byteLength);
    }
    Object.defineProperty(Byte32Array.prototype, "arrayBuffer", {
        get: function () {
            return this._arrayBuffer;
        },
        set: function (value) {
            //reset position
            this.bytePosition = 0;
            //clear length
            this.byteLength = -1;
            this._maxLength = -1;
            //calc new length
            this._ensureSpace(value.byteLength);
            //write new buffer
            this._int32Array.set(new Int32Array(value));
        },
        enumerable: true,
        configurable: true
    });
    Byte32Array.prototype.readByte32Array = function (byte32Array, byteLength) {
        if (byteLength === void 0) { byteLength = -1; }
        if (byteLength == -1)
            byteLength = byte32Array.byteLength - byte32Array.bytePosition;
        byte32Array.writeInt32Array(this._int32Array.subarray(this.bytePosition / 4, (this.bytePosition + byteLength) / 4));
        this.bytePosition += byteLength;
    };
    Byte32Array.prototype.writeByte32Array = function (byte32Array) {
        byte32Array.bytePosition = 0;
        byte32Array.readByte32Array(this, byte32Array.byteLength);
    };
    Byte32Array.prototype.writeFloat32Array = function (float32Array) {
        this._ensureSpace(this.bytePosition + float32Array.length * 4);
        this._float32Array.set(float32Array, this.bytePosition / 4);
        this.bytePosition += float32Array.length * 4;
    };
    Byte32Array.prototype.writeInt32Array = function (int32Array) {
        this._ensureSpace(this.bytePosition + int32Array.length * 4);
        this._uint32Array.set(int32Array, this.bytePosition / 4);
        this.bytePosition += int32Array.length * 4;
    };
    Byte32Array.prototype.writeUint32Array = function (uint32Array) {
        this._ensureSpace(this.bytePosition + uint32Array.length * 4);
        this._uint32Array.set(uint32Array, this.bytePosition / 4);
        this.bytePosition += uint32Array.length * 4;
    };
    Byte32Array.prototype.readFloat32Array = function (float32Array) {
        float32Array.set(this._float32Array.subarray(this.bytePosition / 4, this.bytePosition / 4 + float32Array.length));
    };
    Byte32Array.prototype.readInt32Array = function (int32Array) {
        int32Array.set(this._int32Array.subarray(this.bytePosition / 4, this.bytePosition / 4 + int32Array.length));
    };
    Byte32Array.prototype.readUint32Array = function (uint32Array) {
        uint32Array.set(this._uint32Array.subarray(this.bytePosition / 4, this.bytePosition / 4 + uint32Array.length));
    };
    Byte32Array.prototype.getBytesAvailable = function () {
        return this.byteLength - this.bytePosition;
    };
    Byte32Array.prototype.readUTFBytes = function (len) {
        var value = "";
        var max = this.bytePosition + len;
        var data = new DataView(this._arrayBuffer);
        // utf8-encode
        while (this.bytePosition < max) {
            var c = data.getUint8(this.bytePosition++);
            if (c < 0x80) {
                if (c == 0)
                    break;
                value += String.fromCharCode(c);
            }
            else if (c < 0xE0) {
                value += String.fromCharCode(((c & 0x3F) << 6) | (data.getUint8(this.bytePosition++) & 0x7F));
            }
            else if (c < 0xF0) {
                var c2 = data.getUint8(this.bytePosition++);
                value += String.fromCharCode(((c & 0x1F) << 12) | ((c2 & 0x7F) << 6) | (data.getUint8(this.bytePosition++) & 0x7F));
            }
            else {
                var c2 = data.getUint8(this.bytePosition++);
                var c3 = data.getUint8(this.bytePosition++);
                value += String.fromCharCode(((c & 0x0F) << 18) | ((c2 & 0x7F) << 12) | ((c3 << 6) & 0x7F) | (data.getUint8(this.bytePosition++) & 0x7F));
            }
        }
        return value;
    };
    Byte32Array.prototype.writeUTFBytes = function (s) {
        var escstr = encodeURIComponent(s);
        var binstr = escstr.replace(/%([0-9A-F]{2})/g, function (match, p1) {
            return String.fromCharCode(parseInt('0x' + p1));
        });
        if (binstr.length % 4) {
            var padding = 4 - (binstr.length % 4);
            for (var i = 0; i < padding; i++)
                binstr += " ";
        }
        this._ensureSpace(this.bytePosition + 4 + binstr.length);
        this.writeInt(binstr.length);
        for (var i = 0; i < binstr.length; i += 4)
            this.writeUnsignedInt((binstr.charCodeAt(i + 3) << 24) | (binstr.charCodeAt(i + 2) << 16) | (binstr.charCodeAt(i + 1) << 8) | binstr.charCodeAt(i));
        return binstr.length;
    };
    Byte32Array.prototype.readInt = function () {
        if (this.bytePosition > this.byteLength + 4)
            throw "ByteArray out of bounds read. Position=" + this.bytePosition + ", Length=" + this.byteLength;
        var pa = this.bytePosition >> 2;
        this.bytePosition += 4;
        return this._int32Array[pa];
    };
    Byte32Array.prototype.writeUnsignedInt = function (b) {
        this._ensureSpace(this.bytePosition + 4);
        this._uint32Array[this.bytePosition >> 2] = (~~b) & 0xffffffff; // ~~ is cast to int in js...
        this.bytePosition += 4;
    };
    Byte32Array.prototype.writeInt = function (b) {
        this._ensureSpace(this.bytePosition + 4);
        this._int32Array[this.bytePosition >> 2] = (~~b); // ~~ is cast to int in js...
        this.bytePosition += 4;
    };
    Byte32Array.prototype.readUnsignedInt = function () {
        if (this.bytePosition > this.byteLength + 4)
            throw "ByteArray out of bounds read. Position=" + this.bytePosition + ", Length=" + this.byteLength;
        var pa = this.bytePosition >> 2;
        this.bytePosition += 4;
        return this._uint32Array[pa];
    };
    Byte32Array.prototype.writeFloat = function (b) {
        this._ensureSpace(this.bytePosition + 4);
        this._float32Array[this.bytePosition >> 2] = b;
        this.bytePosition += 4;
    };
    Byte32Array.prototype.readFloat = function () {
        if (this.bytePosition > this.byteLength + 4)
            throw "ByteArray out of bounds read. Positon=" + this.bytePosition + ", Length=" + this.byteLength;
        var pa = this.bytePosition >> 2;
        this.bytePosition += 4;
        return this._float32Array[pa];
    };
    Byte32Array.prototype._ensureSpace = function (length) {
        if (this.byteLength < length) {
            this.byteLength = length;
            if (this._maxLength < length) {
                this._maxLength = Math.max((length + 255) & (~255), 4);
                var newArrayBuffer = new ArrayBuffer(this._maxLength);
                var newInt32Array = new Int32Array(newArrayBuffer);
                if (this._int32Array)
                    newInt32Array.set(this._int32Array); // memcpy
                this._uint32Array = new Uint32Array(newArrayBuffer);
                this._float32Array = new Float32Array(newArrayBuffer);
                this._int32Array = newInt32Array;
                this._arrayBuffer = newArrayBuffer;
            }
        }
    };
    return Byte32Array;
}());

var ByteArrayBuffer = (function (_super) {
    __extends(ByteArrayBuffer, _super);
    function ByteArrayBuffer() {
        var _this = _super.call(this) || this;
        _this._bytes = [];
        _this._mode = "Array";
        return _this;
    }
    ByteArrayBuffer.prototype.writeByte = function (b) {
        var bi = ~~b;
        this._bytes[this.position++] = bi;
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArrayBuffer.prototype.readByte = function () {
        if (this.position >= this.length) {
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        }
        return this._bytes[this.position++];
    };
    ByteArrayBuffer.prototype.writeUnsignedByte = function (b) {
        var bi = ~~b;
        this._bytes[this.position++] = bi & 0xff;
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArrayBuffer.prototype.readUnsignedByte = function () {
        if (this.position >= this.length) {
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        }
        return this._bytes[this.position++];
    };
    ByteArrayBuffer.prototype.writeUnsignedShort = function (b) {
        var bi = ~~b;
        this._bytes[this.position++] = bi & 0xff;
        this._bytes[this.position++] = (bi >> 8) & 0xff;
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArrayBuffer.prototype.readUnsignedShort = function () {
        if (this.position + 2 > this.length)
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        var r = this._bytes[this.position] | (this._bytes[this.position + 1] << 8);
        this.position += 2;
        return r;
    };
    ByteArrayBuffer.prototype.writeUnsignedInt = function (b) {
        var bi = ~~b;
        this._bytes[this.position++] = bi & 0xff;
        this._bytes[this.position++] = (bi >>> 8) & 0xff;
        this._bytes[this.position++] = (bi >>> 16) & 0xff;
        this._bytes[this.position++] = (bi >>> 24) & 0xff;
        if (this.position > this.length) {
            this.length = this.position;
        }
    };
    ByteArrayBuffer.prototype.readUnsignedInt = function () {
        if (this.position + 4 > this.length) {
            throw "ByteArray out of bounds read. Position=" + this.position + ", Length=" + this.length;
        }
        var r = this._bytes[this.position] | (this._bytes[this.position + 1] << 8) | (this._bytes[this.position + 2] << 16) | (this._bytes[this.position + 3] << 24);
        this.position += 4;
        return r >>> 0;
    };
    ByteArrayBuffer.prototype.writeFloat = function (b) {
        // this is crazy slow and silly, but as a fallback...
        this.writeUnsignedInt(this.toFloatBits(Number(b)));
    };
    ByteArrayBuffer.prototype.toFloatBits = function (x) {
        // don't handle inf/nan yet
        // special case zero
        if (x == 0) {
            return 0;
        }
        // remove the sign, after this we only deal with positive numbers
        var sign = 0;
        if (x < 0) {
            x = -x;
            sign = 1;
        }
        else {
            sign = 0;
        }
        // a float value is now defined as: x = (1+(mantissa*2^-23))*(2^(exponent-127))
        var exponent = Math.log(x) / Math.log(2); // rough exponent
        exponent = Math.floor(exponent);
        x = x * Math.pow(2, 23 - exponent); // normalize to 24 bits
        var mantissa = Math.floor(x) - 0x800000;
        exponent = exponent + 127;
        return ((sign << 31) >>> 0) | (exponent << 23) | mantissa;
    };
    ByteArrayBuffer.prototype.readFloat = function (b) {
        return this.fromFloatBits(this.readUnsignedInt());
    };
    ByteArrayBuffer.prototype.fromFloatBits = function (x) {
        if (x == 0) {
            return 0;
        }
        var exponent = (x >>> 23) & 0xff;
        var mantissa = (x & 0x7fffff) | 0x800000;
        var y = Math.pow(2, (exponent - 127) - 23) * mantissa;
        if (x >>> 31 != 0) {
            y = -y;
        }
        return y;
    };
    return ByteArrayBuffer;
}(ByteArrayBase));

var CSS = (function () {
    function CSS() {
    }
    CSS.setElementSize = function (element, width, height) {
        if (!element)
            return;
        element.style.width = width + "px";
        element.style.height = height + "px";
        element["width"] = width;
        element["height"] = height;
    };
    CSS.setElementWidth = function (element, width) {
        if (!element)
            return;
        element.style.width = width + "px";
        element["width"] = width;
    };
    CSS.setElementHeight = function (element, height) {
        if (!element)
            return;
        element.style.height = height + "px";
        element["height"] = height;
    };
    CSS.setElementX = function (element, x) {
        if (!element)
            return;
        element.style.position = 'absolute';
        element.style.left = x + "px";
    };
    CSS.setElementY = function (element, y) {
        if (!element)
            return;
        element.style.position = 'absolute';
        element.style.top = y + "px";
    };
    CSS.getElementVisibility = function (element) {
        if (!element)
            return false;
        return element.style.visibility == 'visible';
    };
    CSS.setElementVisibility = function (element, visible) {
        if (!element)
            return;
        if (visible) {
            element.style.visibility = 'visible';
        }
        else {
            element.style.visibility = 'hidden';
        }
    };
    CSS.setElementAlpha = function (element, alpha) {
        if (element instanceof HTMLCanvasElement) {
            var context = element.getContext("2d");
            context.globalAlpha = alpha;
        }
    };
    CSS.setElementPosition = function (element, x, y, absolute) {
        if (absolute === void 0) { absolute = false; }
        if (!element)
            return;
        if (absolute) {
            element.style.position = "absolute";
        }
        else {
            element.style.position = "relative";
        }
        element.style.left = x + "px";
        element.style.top = y + "px";
    };
    return CSS;
}());

/**
 *
 */
var Debug = (function () {
    function Debug() {
    }
    Debug.breakpoint = function () {
        Debug['break']();
    };
    Debug.throwPIROnKeyWordOnly = function (str, enable) {
        if (enable === void 0) { enable = true; }
        if (!enable)
            Debug.keyword = null;
        else
            Debug.keyword = str;
    };
    Debug.throwPIR = function (clss, fnc, msg) {
        Debug.logPIR('PartialImplementationError ' + clss, fnc, msg);
        if (Debug.THROW_ERRORS) {
            if (Debug.keyword) {
                var e = clss + fnc + msg;
                if (e.indexOf(Debug.keyword) == -1)
                    return;
            }
            throw new PartialImplementationError(clss + '.' + fnc + ': ' + msg);
        }
    };
    Debug.logPIR = function (clss, fnc, msg) {
        if (msg === void 0) { msg = ''; }
        if (Debug.LOG_PI_ERRORS)
            console.log(clss + '.' + fnc + ': ' + msg);
    };
    Debug.log = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (Debug.ENABLE_LOG)
            console.log(args);
    };
    return Debug;
}());
Debug.THROW_ERRORS = true;
Debug.ENABLE_LOG = true;
Debug.LOG_PI_ERRORS = true;
Debug.keyword = null;

/**
 *
 */
var Extensions = (function () {
    function Extensions() {
    }
    return Extensions;
}());
Extensions.SIMD = Boolean(typeof (SIMD) !== "undefined");

var RequestAnimationFrame = (function () {
    function RequestAnimationFrame(callback, callbackContext) {
        var _this = this;
        this._active = false;
        this._argsArray = new Array();
        this._getTimer = getTimer;
        this.setCallback(callback, callbackContext);
        this._rafUpdateFunction = function () {
            if (_this._active)
                _this._tick();
        };
        this._argsArray.push(this._dt);
    }
    // Public
    /**
     *
     * @param callback
     * @param callbackContext
     */
    RequestAnimationFrame.prototype.setCallback = function (callback, callbackContext) {
        this._callback = callback;
        this._callbackContext = callbackContext;
    };
    /**
     *
     */
    RequestAnimationFrame.prototype.start = function () {
        this._prevTime = this._getTimer();
        this._active = true;
        if (window) {
            if (window.requestAnimationFrame) {
                window.requestAnimationFrame(this._rafUpdateFunction);
            }
            else {
                if (window['mozRequestAnimationFrame'])
                    window.requestAnimationFrame = window['mozRequestAnimationFrame'];
                else if (window['webkitRequestAnimationFrame'])
                    window.requestAnimationFrame = window['webkitRequestAnimationFrame'];
                else if (window['oRequestAnimationFrame'])
                    window.requestAnimationFrame = window['oRequestAnimationFrame'];
            }
        }
    };
    /**
     *
     */
    RequestAnimationFrame.prototype.stop = function () {
        this._active = false;
    };
    Object.defineProperty(RequestAnimationFrame.prototype, "active", {
        // Get / Set
        /**
         *
         * @returns {boolean}
         */
        get: function () {
            return this._active;
        },
        enumerable: true,
        configurable: true
    });
    // Private
    /**
     *
     * @private
     */
    RequestAnimationFrame.prototype._tick = function () {
        this._currentTime = this._getTimer();
        this._dt = this._currentTime - this._prevTime;
        this._argsArray[0] = this._dt;
        this._callback.apply(this._callbackContext, this._argsArray);
        window.requestAnimationFrame(this._rafUpdateFunction);
        this._prevTime = this._currentTime;
    };
    return RequestAnimationFrame;
}());

var XmlUtils = (function () {
    function XmlUtils() {
    }
    XmlUtils.getChildrenWithTag = function (node, tag) {
        var fragment = document.createDocumentFragment();
        if (node) {
            var num = node.childNodes.length;
            for (var i = 0; i < num; i++) {
                var child = node.childNodes[i];
                if (child != null) {
                    if (child.nodeName == tag) {
                        fragment.appendChild(child);
                    }
                }
            }
        }
        return fragment.childNodes;
    };
    XmlUtils.filterListByParam = function (nodes, paramName, paramValue) {
        var fragment = document.createDocumentFragment();
        if (nodes) {
            var num = nodes.length;
            for (var i = 0; i < num; i++) {
                var child = nodes[i];
                if (child != null) {
                    if (child.attributes.getNamedItem(paramName).value == paramValue) {
                        fragment.appendChild(child);
                    }
                }
            }
        }
        return fragment.childNodes;
    };
    XmlUtils.strToXml = function (str) {
        var parser = new DOMParser();
        var node = parser.parseFromString(str, "text/xml");
        return node;
    };
    XmlUtils.nodeToString = function (node) {
        if (!node)
            return "";
        var str = (new XMLSerializer()).serializeToString(node);
        return str;
    };
    XmlUtils.readAttributeValue = function (node, attrName) {
        var attrs = node.attributes;
        if (attrs == undefined) {
            return "";
        }
        var attribute = attrs.getNamedItem(attrName);
        if (!attribute) {
            //console.log("XmlUltils - readAttributeValue() - name: " + attrName + ", attribute does not exist.";
            return "";
        }
        //console.log("XmlUltils - readAttributeValue() - name: " + attrName + ", value: " + attribute.value);
        return attribute.value;
    };
    XmlUtils.writeAttributeValue = function (node, attrName, attrValue) {
        var attribute = document.createAttribute(attrName);
        attribute.value = attrValue;
        attribute = node.attributes.setNamedItem(attribute);
        console.log("XmlUltils - writeAttributeValue() - name: " + attribute.name + ", value: " + attribute.value);
    };
    XmlUtils.hasAttribute = function (node, attrName) {
        var attrs = node.attributes;
        if (attrs == undefined) {
            return false;
        }
        var attribute = attrs.getNamedItem(attrName);
        return attribute != null;
    };
    return XmlUtils;
}());

exports.AttributesView = AttributesView;
exports.AttributesBuffer = AttributesBuffer;
exports.Byte4Attributes = Byte4Attributes;
exports.Float1Attributes = Float1Attributes;
exports.Float2Attributes = Float2Attributes;
exports.Float3Attributes = Float3Attributes;
exports.Float4Attributes = Float4Attributes;
exports.Short2Attributes = Short2Attributes;
exports.Short3Attributes = Short3Attributes;
exports.WaveAudio = WaveAudio;
exports.ColorTransform = ColorTransform;
exports.Transform = Transform;
exports.AbstractMethodError = AbstractMethodError;
exports.ArgumentError = ArgumentError;
exports.DocumentError = DocumentError;
exports.ErrorBase = ErrorBase;
exports.PartialImplementationError = PartialImplementationError;
exports.RangeError = RangeError;
exports.AssetEvent = AssetEvent;
exports.EventBase = EventBase;
exports.EventDispatcher = EventDispatcher;
exports.LoaderEvent = LoaderEvent;
exports.ParserEvent = ParserEvent;
exports.ProjectionEvent = ProjectionEvent;
exports.TimerEvent = TimerEvent;
exports.TransformEvent = TransformEvent;
exports.URLLoaderEvent = URLLoaderEvent;
exports.Box = Box;
exports.MathConsts = MathConsts;
exports.Matrix = Matrix;
exports.Matrix3D = Matrix3D;
exports.Orientation3D = Orientation3D;
exports.Plane3D = Plane3D;
exports.PlaneClassification = PlaneClassification;
exports.Point = Point;
exports.PoissonLookup = PoissonLookup;
exports.Quaternion = Quaternion;
exports.Rectangle = Rectangle;
exports.Sphere = Sphere;
exports.Vector3D = Vector3D;
exports.AbstractionBase = AbstractionBase;
exports.AssetBase = AssetBase;
exports.AssetLibrary = AssetLibrary;
exports.AssetLibraryBundle = AssetLibraryBundle;
exports.AssetLibraryIterator = AssetLibraryIterator;
exports.ConflictPrecedence = ConflictPrecedence;
exports.ConflictStrategy = ConflictStrategy;
exports.ConflictStrategyBase = ConflictStrategyBase;
exports.ErrorConflictStrategy = ErrorConflictStrategy;
exports.IDUtil = IDUtil;
exports.IgnoreConflictStrategy = IgnoreConflictStrategy;
exports.Loader = Loader;
exports.LoaderContext = LoaderContext;
exports.LoaderInfo = LoaderInfo;
exports.NumSuffixConflictStrategy = NumSuffixConflictStrategy;
exports.AudioManager = AudioManager;
exports.StreamingAudioChannel = StreamingAudioChannel;
exports.WebAudioChannel = WebAudioChannel;
exports.CrossDomainPolicy = CrossDomainPolicy;
exports.URLLoader = URLLoader;
exports.URLLoaderDataFormat = URLLoaderDataFormat;
exports.URLRequest = URLRequest;
exports.URLRequestMethod = URLRequestMethod;
exports.URLVariables = URLVariables;
exports.ParserBase = ParserBase;
exports.ParserDataFormat = ParserDataFormat;
exports.ParserUtils = ParserUtils;
exports.ResourceDependency = ResourceDependency;
exports.WaveAudioParser = WaveAudioParser;
exports.ObliqueNearPlaneProjection = ObliqueNearPlaneProjection;
exports.OrthographicOffCenterProjection = OrthographicOffCenterProjection;
exports.OrthographicProjection = OrthographicProjection;
exports.PerspectiveProjection = PerspectiveProjection;
exports.ProjectionBase = ProjectionBase;
exports.Keyboard = Keyboard;
exports.ByteArray = ByteArray;
exports.Byte32Array = Byte32Array;
exports.ByteArrayBase = ByteArrayBase;
exports.ByteArrayBuffer = ByteArrayBuffer;
exports.ColorUtils = ColorUtils;
exports.CSS = CSS;
exports.Debug = Debug;
exports.Extensions = Extensions;
exports.getTimer = getTimer;
exports.RequestAnimationFrame = RequestAnimationFrame;
exports.Timer = Timer;
exports.XmlUtils = XmlUtils;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_stage__ = __webpack_require__(13);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_stage___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_stage__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_stage__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_stage__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(7)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/core'], factory) :
    (factory((global.AwayjsGraphics = global.AwayjsGraphics || {}),global.AwayjsCore));
}(this, (function (exports,_awayjs_core) { 'use strict';

var ParticleData = (function () {
    function ParticleData() {
    }
    return ParticleData;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

/**
 * Provides an abstract base class for nodes in an animation blend tree.
 */
var AnimationNodeBase = (function (_super) {
    __extends(AnimationNodeBase, _super);
    /**
     * Creates a new <code>AnimationNodeBase</code> object.
     */
    function AnimationNodeBase() {
        return _super.call(this) || this;
    }
    Object.defineProperty(AnimationNodeBase.prototype, "stateClass", {
        get: function () {
            return this._pStateClass;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    AnimationNodeBase.prototype.dispose = function () {
    };
    Object.defineProperty(AnimationNodeBase.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AnimationNodeBase.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return AnimationNodeBase;
}(_awayjs_core.AssetBase));
AnimationNodeBase.assetType = "[asset AnimationNodeBase]";

/**
 * Dispatched to notify changes in a sub geometry object's state.
 *
 * @class away.events.RenderableEvent
 * @see away.core.base.Graphics
 */
var RenderableEvent = (function (_super) {
    __extends(RenderableEvent, _super);
    /**
     * Create a new GraphicsEvent
     * @param type The event type.
     * @param dataType An optional data type of the vertex data being updated.
     */
    function RenderableEvent(type, renderable) {
        var _this = _super.call(this, type) || this;
        _this._renderable = renderable;
        return _this;
    }
    Object.defineProperty(RenderableEvent.prototype, "renderable", {
        /**
         * The renderobject owner of the renderable owner.
         */
        get: function () {
            return this._renderable;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current object.
     */
    RenderableEvent.prototype.clone = function () {
        return new RenderableEvent(this.type, this._renderable);
    };
    return RenderableEvent;
}(_awayjs_core.EventBase));
/**
 * Dispatched when a Renderable has been updated.
 */
RenderableEvent.INVALIDATE_MATERIAL = "invalidateMaterial";
/**
 *
 */
RenderableEvent.INVALIDATE_ELEMENTS = "invalidateElements";

var StyleEvent = (function (_super) {
    __extends(StyleEvent, _super);
    function StyleEvent(type, style) {
        var _this = _super.call(this, type) || this;
        _this._style = style;
        return _this;
    }
    Object.defineProperty(StyleEvent.prototype, "style", {
        get: function () {
            return this._style;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     * @return An exact duplicate of the current object.
     */
    StyleEvent.prototype.clone = function () {
        return new StyleEvent(this.type, this._style);
    };
    return StyleEvent;
}(_awayjs_core.EventBase));
/**
 *
 */
StyleEvent.INVALIDATE_PROPERTIES = "invalidateProperties";

/**
 * Dispatched to notify changes in a sub geometry object's state.
 *
 * @class away.events.ShapeEvent
 * @see away.core.base.Graphics
 */
var ShapeEvent = (function (_super) {
    __extends(ShapeEvent, _super);
    /**
     * Create a new GraphicsEvent
     * @param type The event type.
     * @param dataType An optional data type of the vertex data being updated.
     */
    function ShapeEvent(type, shape) {
        var _this = _super.call(this, type) || this;
        _this._shape = shape;
        return _this;
    }
    Object.defineProperty(ShapeEvent.prototype, "shape", {
        /**
         * The renderobject owner of the renderable owner.
         */
        get: function () {
            return this._shape;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current object.
     */
    ShapeEvent.prototype.clone = function () {
        return new ShapeEvent(this.type, this._shape);
    };
    return ShapeEvent;
}(_awayjs_core.EventBase));
/**
 * Dispatched when a Renderable has been updated.
 */
ShapeEvent.ADD_MATERIAL = "addMaterial";
/**
 * Dispatched when a Renderable has been updated.
 */
ShapeEvent.REMOVE_MATERIAL = "removeMaterial";

/**
 * Graphic wraps a Elements as a scene graph instantiation. A Graphic is owned by a Sprite object.
 *
 *
 * @see away.base.ElementsBase
 * @see away.entities.Sprite
 *
 * @class away.base.Graphic
 */
var Shape = (function (_super) {
    __extends(Shape, _super);
    /**
     * Creates a new Shape object
     */
    function Shape(elements, material, style, count, offset) {
        if (material === void 0) { material = null; }
        if (style === void 0) { style = null; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        var _this = _super.call(this) || this;
        _this._boxBoundsInvalid = true;
        _this._sphereBoundsInvalid = true;
        _this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
        _this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
        _this._elements = elements;
        _this._material = material;
        _this._style = style;
        if (_this._style)
            _this._style.addEventListener(StyleEvent.INVALIDATE_PROPERTIES, _this._onInvalidatePropertiesDelegate);
        _this.count = count;
        _this.offset = offset;
        return _this;
    }
    Shape.getShape = function (elements, material, style, count, offset) {
        if (material === void 0) { material = null; }
        if (style === void 0) { style = null; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        if (Shape._pool.length) {
            var shape = Shape._pool.pop();
            shape.elements = elements;
            shape.material = material;
            shape.style = style;
            shape.count = count;
            shape.offset = offset;
            return shape;
        }
        return new Shape(elements, material, style, count, offset);
    };
    Shape.storeShape = function (shape) {
        shape.elements = null;
        shape.material = null;
        shape.style = null;
        shape.clear();
        Shape._pool.push(shape);
    };
    Object.defineProperty(Shape.prototype, "strokePath", {
        /*
         * _strokePath provides the original stroke-path that was used to create this shape
         * when the strokepath is set, it should already be prepared so that its faster to update stroke for new thickness
         */
        get: function () {
            return this._strokePath;
        },
        set: function (value) {
            this._strokePath = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "isStroke", {
        /*
            * true if this shape was created for a stroke
         */
        get: function () {
            return this._isStroke;
        },
        set: function (value) {
            this._isStroke = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "elements", {
        /**
         * The Elements object which provides the geometry data for this Shape.
         */
        get: function () {
            return this._elements;
        },
        set: function (value) {
            if (this._elements == value)
                return;
            this._elements = value;
            this.invalidateElements();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return Shape.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "material", {
        /**
         * The material used to render the current Shape. If set to null, the containing Graphics's material will be used instead.
         */
        get: function () {
            return this._material;
        },
        set: function (value) {
            if (this._material == value)
                return;
            if (this._material)
                this.dispatchEvent(new ShapeEvent(ShapeEvent.REMOVE_MATERIAL, this));
            this._material = value;
            if (this._material)
                this.dispatchEvent(new ShapeEvent(ShapeEvent.ADD_MATERIAL, this));
            this.invalidateMaterial();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Shape.prototype, "style", {
        /**
         * The style used to render the current Shape. If set to null, its parent Sprite's style will be used instead.
         */
        get: function () {
            return this._style;
        },
        set: function (value) {
            if (this._style == value)
                return;
            if (this._style)
                this._style.removeEventListener(StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this._style = value;
            if (this._style)
                this._style.addEventListener(StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this.invalidateMaterial();
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    Shape.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
    };
    Shape.prototype.invalidate = function () {
        _super.prototype.invalidate.call(this);
        this._boxBoundsInvalid = true;
        this._sphereBoundsInvalid = true;
    };
    Shape.prototype.invalidateElements = function () {
        this.dispatchEvent(new RenderableEvent(RenderableEvent.INVALIDATE_ELEMENTS, this));
        this._boxBoundsInvalid = true;
        this._sphereBoundsInvalid = true;
    };
    Shape.prototype.invalidateMaterial = function () {
        this.dispatchEvent(new RenderableEvent(RenderableEvent.INVALIDATE_MATERIAL, this));
    };
    Shape.prototype._onInvalidateProperties = function (event) {
        this.invalidateMaterial();
    };
    Shape.prototype._onInvalidateVertices = function (event) {
        if (event.attributesView != event.target.positions)
            return;
        this.invalidate();
        this.dispatchEvent(event);
    };
    /**
     * //TODO
     *
     * @param shortestCollisionDistance
     * @param findClosest
     * @returns {boolean}
     *
     * @internal
     */
    // public _iTestCollision(pickingCollision:PickingCollision, pickingCollider:IPickingCollider):boolean
    // {
    // 	return this._elements._iTestCollision(pickingCollider, this.material, pickingCollision, this.count, this.offset)
    // }
    Shape.prototype.applyTransformation = function (transform) {
        this._elements.applyTransformation(transform, this.count, this.offset);
    };
    Shape.prototype.hitTestPoint = function (x, y, z) {
        var box;
        //early out for box test
        if (!(box = this.getBoxBounds()).contains(x, y, z))
            return false;
        return this._elements.hitTestPoint(x, y, z, box, this.count, this.offset);
    };
    Shape.prototype.scale = function (scale) {
        this._elements.scale(scale, this.count, this.offset);
    };
    Shape.prototype.scaleUV = function (scaleU, scaleV) {
        if (scaleU === void 0) { scaleU = 1; }
        if (scaleV === void 0) { scaleV = 1; }
        this._elements.scaleUV(scaleU, scaleV, this.count, this.offset);
    };
    Shape.prototype.getBoxBounds = function () {
        if (this._boxBoundsInvalid) {
            this._boxBoundsInvalid = false;
            this._boxBounds = this._elements.getBoxBounds(this._boxBounds || (this._boxBounds = new _awayjs_core.Box()), this.count, this.offset);
        }
        return this._boxBounds;
    };
    Shape.prototype.getSphereBounds = function (center, target) {
        if (target === void 0) { target = null; }
        return this._elements.getSphereBounds(center, target, this.count, this.offset);
    };
    return Shape;
}(_awayjs_core.AssetBase));
Shape._pool = new Array();
Shape.assetType = "[asset Shape]";

/**
 *
 */
var Style = (function (_super) {
    __extends(Style, _super);
    function Style() {
        var _this = _super.call(this) || this;
        _this._samplers = new Object();
        _this._images = new Object();
        _this._color = 0xFFFFFF;
        return _this;
    }
    Object.defineProperty(Style.prototype, "sampler", {
        get: function () {
            return this._sampler;
        },
        set: function (value) {
            if (this._sampler == value)
                return;
            this._sampler = value;
            this._invalidateProperties();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "image", {
        get: function () {
            return this._image;
        },
        set: function (value) {
            if (this._image == value)
                return;
            this._image = value;
            this._invalidateProperties();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "uvMatrix", {
        get: function () {
            return this._uvMatrix;
        },
        set: function (value) {
            if (this._uvMatrix == value)
                return;
            this._uvMatrix = value;
            this._invalidateProperties();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Style.prototype, "color", {
        /**
         * The diffuse reflectivity color of the surface.
         */
        get: function () {
            return this._color;
        },
        set: function (value) {
            if (this._color == value)
                return;
            this._color = value;
            this._invalidateProperties();
        },
        enumerable: true,
        configurable: true
    });
    Style.prototype.getImageAt = function (texture, index) {
        if (index === void 0) { index = 0; }
        return (this._images[texture.id] ? this._images[texture.id][index] : null) || this._image;
    };
    Style.prototype.getSamplerAt = function (texture, index) {
        if (index === void 0) { index = 0; }
        return (this._samplers[texture.id] ? this._samplers[texture.id][index] : null) || this._sampler;
    };
    Style.prototype.addImageAt = function (image, texture, index) {
        if (index === void 0) { index = 0; }
        if (!this._images[texture.id])
            this._images[texture.id] = new Array();
        this._images[texture.id][index] = image;
    };
    Style.prototype.addSamplerAt = function (sampler, texture, index) {
        if (index === void 0) { index = 0; }
        if (!this._samplers[texture.id])
            this._samplers[texture.id] = new Array();
        this._samplers[texture.id][index] = sampler;
        this._invalidateProperties();
    };
    Style.prototype.removeImageAt = function (texture, index) {
        if (index === void 0) { index = 0; }
        if (!this._images[texture.id])
            return;
        this._images[texture.id][index] = null;
        this._invalidateProperties();
    };
    Style.prototype.removeSamplerAt = function (texture, index) {
        if (index === void 0) { index = 0; }
        if (!this._samplers[texture.id])
            return;
        this._samplers[texture.id][index] = null;
        this._invalidateProperties();
    };
    Style.prototype._invalidateProperties = function () {
        this.dispatchEvent(new StyleEvent(StyleEvent.INVALIDATE_PROPERTIES, this));
    };
    return Style;
}(_awayjs_core.EventDispatcher));

/**
 * Picks a 3d object from a view or scene by 3D raycast calculations.
 * Performs an initial coarse boundary calculation to return a subset of entities whose bounding volumes intersect with the specified ray,
 * then triggers an optional picking collider on individual renderable objects to further determine the precise values of the picking ray collision.
 *
 * @class away.pick.RaycastPicker
 */
var TraverserBase = (function (_super) {
    __extends(TraverserBase, _super);
    /**
     *
     */
    function TraverserBase() {
        var _this = _super.call(this) || this;
        var i;
        //setup defaults for all entity functions
        for (i = 0; i < TraverserBase.entityNames.length; i++)
            if (!_this[TraverserBase.entityNames[i]])
                _this[TraverserBase.entityNames[i]] = _this.applyEntity;
        //setup defaults for all renderable functions
        for (i = 0; i < TraverserBase.renderableNames.length; i++)
            if (!_this[TraverserBase.renderableNames[i]])
                _this[TraverserBase.renderableNames[i]] = _this.applyRenderable;
        return _this;
    }
    TraverserBase.addEntityName = function (name) {
        TraverserBase.entityNames.push(name);
        return name;
    };
    TraverserBase.addRenderableName = function (name) {
        TraverserBase.renderableNames.push(name);
        return name;
    };
    /**
     * Returns true if the current node is at least partly in the frustum. If so, the partition node knows to pass on the traverser to its children.
     *
     * @param node The Partition3DNode object to frustum-test.
     */
    TraverserBase.prototype.enterNode = function (node) {
        return true;
    };
    TraverserBase.prototype.dispose = function () {
        //TODO
    };
    /**
     *
     * @param entity
     */
    TraverserBase.prototype.applyEntity = function (entity) {
        //do nothing
    };
    /**
     *
     * @param entity
     */
    TraverserBase.prototype.applyRenderable = function (renderable) {
        //do nothing
    };
    return TraverserBase;
}(_awayjs_core.EventDispatcher));
TraverserBase.entityNames = new Array();
TraverserBase.renderableNames = new Array();

/**
 * The CapsStyle class is an enumeration of constant values that specify the
 * caps style to use in drawing lines. The constants are provided for use as
 * values in the <code>caps</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method. You can specify the
 * following three types of caps:
 */
var CapsStyle = (function () {
    function CapsStyle() {
    }
    return CapsStyle;
}());
/**
 * Used to specify round caps in the <code>caps</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method.
 */
CapsStyle.ROUND = 1;
/**
 * Used to specify no caps in the <code>caps</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method.
 */
CapsStyle.NONE = 0;
/**
 * Used to specify square caps in the <code>caps</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method.
 */
CapsStyle.SQUARE = 2;

/**
 * DrawMode is an enumeration of constant values that specify the
 * DrawMode to use when drawing.
 */
var DrawMode = (function () {
    function DrawMode() {
    }
    return DrawMode;
}());
/**
 * Used to specify to draw both strokes and fills
 */
DrawMode.BOTH = 1;
/**
 * Used to specify to draw strokes only
 */
DrawMode.STROKE = 0;
/**
 * Used to specify to draw fills only
 */
DrawMode.FILL = 2;

/**
 * The GradientType class provides values for the <code>type</code> parameter
 * in the <code>beginGradientFill()</code> and
 * <code>lineGradientStyle()</code> methods of the flash.display.Graphics
 * class.
 */
var GradientType = (function () {
    function GradientType() {
    }
    return GradientType;
}());
/**
 * Value used to specify a linear gradient fill.
 */
GradientType.LINEAR = "linear";
/**
 * Value used to specify a radial gradient fill.
 */
GradientType.RADIAL = "radial";

var GraphicsFillStyle = (function () {
    function GraphicsFillStyle(color, alpha) {
        if (color === void 0) { color = 0xffffff; }
        if (alpha === void 0) { alpha = 1; }
        this.color = color;
        this.alpha = alpha;
    }
    Object.defineProperty(GraphicsFillStyle.prototype, "data_type", {
        get: function () {
            return GraphicsFillStyle.data_type;
        },
        enumerable: true,
        configurable: true
    });
    return GraphicsFillStyle;
}());
GraphicsFillStyle.data_type = "[graphicsdata FillStyle]";

var GradientFillStyle = (function (_super) {
    __extends(GradientFillStyle, _super);
    function GradientFillStyle(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
        var _this = _super.call(this) || this;
        if (colors.length != alphas.length || colors.length != ratios.length) {
            throw ("GradientFillStyle: Error - colors, alphas and ratios must be of same length");
        }
        _this.colors = colors;
        _this.colors_r = [];
        _this.colors_g = [];
        _this.colors_b = [];
        _this.colors_r.length = _this.colors_g.length = _this.colors_g.length = _this.colors.length;
        _this.alphas = alphas;
        _this.ratios = ratios;
        _this.matrix = matrix;
        _this.type = type;
        _this.uvRectangle = new _awayjs_core.Rectangle();
        _this.ratio_min = _this.ratios[0];
        _this.ratio_max = _this.ratios[_this.ratios.length - 1];
        var r = _this.ratios.length;
        while (r > 1) {
            r--;
            if (_this.ratios[r] < _this.ratios[r - 1]) {
                throw ("GradientFillStyle: Error - ratios are not valid");
            }
        }
        var c = colors.length;
        var argb;
        while (c > 0) {
            c--;
            argb = _awayjs_core.ColorUtils.float32ColorToARGB(colors[c]);
            _this.colors_r[c] = argb[1];
            _this.colors_g[c] = argb[2];
            _this.colors_b[c] = argb[3];
        }
        return _this;
    }
    GradientFillStyle.prototype.getUVMatrix = function () {
        if (!this.matrix) {
            this.matrix = new _awayjs_core.Matrix();
        }
        // console.log(this.uvRectangle);
        // console.log(this.matrix);
        // todo: this is ported from exporter-cpp code
        // probably a lot to optimize here
        var projection_width = 1638.4;
        var projection_height = 1638.4;
        var projection_width_half = projection_width * 0.5;
        var projection_height_half = projection_height * 0.5;
        //	Get and invert the uv transform:
        var a = this.matrix.a;
        var b = this.matrix.b;
        var c = this.matrix.c;
        var d = this.matrix.d;
        var tx = this.matrix.tx;
        var ty = this.matrix.ty;
        var a_inv = d / (a * d - b * c);
        var b_inv = -b / (a * d - b * c);
        var c_inv = -c / (a * d - b * c);
        var d_inv = a / (a * d - b * c);
        var tx_inv = (c * ty - d * tx) / (a * d - b * c);
        var ty_inv = -(a * ty - b * tx) / (a * d - b * c);
        var a_out = (a_inv / projection_width) * (1 - (1 / 256));
        var b_out = 0; //(b_inv / projection_width)*(1-(1/256));
        var c_out = (c_inv / projection_width) * (1 - (1 / 256));
        var d_out = 0; //(d_inv / projection_width)*(1-(1/256));
        var tx_out = (this.uvRectangle.x) + ((tx_inv + projection_width_half) / projection_width) * (1 - (1 / 256));
        var ty_out = (this.uvRectangle.y); //+((ty_inv + projection_height_half)/projection_width)*(1-(1/256));
        this.matrix = new _awayjs_core.Matrix(a_out, c_out, 0, 0, tx_out, ty_out);
        if (this.type == GradientType.RADIAL) {
            this.matrix = new _awayjs_core.Matrix(a_inv / projection_width_half, c_inv / projection_width_half, b_inv / projection_width_half, d_inv / projection_width_half, ((tx_inv + projection_width_half) / projection_width_half) - 1, ((ty_inv + projection_height_half) / projection_width_half) - 1);
        }
        return this.matrix;
    };
    GradientFillStyle.prototype.getColorAtPosition = function (value) {
        var r1 = -1;
        var r2 = -1;
        if (value <= this.ratio_min) {
            r1 = 0;
            r2 = 0;
        }
        else if (value >= this.ratio_max) {
            r1 = this.ratios.length - 1;
            r2 = this.ratios.length - 1;
        }
        else {
            var r = 0;
            for (var r = 0; r < this.ratios.length - 1; r++) {
                if (value == this.ratios[r]) {
                    r1 = r;
                    r2 = r;
                    break;
                }
                else if (value == this.ratios[r + 1]) {
                    r1 = r + 1;
                    r2 = r + 1;
                    break;
                }
                else if (value >= this.ratios[r] && value <= this.ratios[r + 1]) {
                    r1 = r;
                    r2 = r + 1;
                    break;
                }
            }
        }
        if (r1 == r2) {
            return [this.alphas[r1], this.colors_r[r1], this.colors_g[r1], this.colors_b[r1]];
        }
        var mix = (value - this.ratios[r1]) / (this.ratios[r2] - this.ratios[r1]);
        var mix_neg = 1 - mix;
        var color_a = this.alphas[r2] * mix + this.alphas[r1] * mix_neg;
        var color_r = this.colors_r[r2] * mix + this.colors_r[r1] * mix_neg;
        var color_g = this.colors_g[r2] * mix + this.colors_g[r1] * mix_neg;
        var color_b = this.colors_b[r2] * mix + this.colors_b[r1] * mix_neg;
        return [color_a, color_r, color_g, color_b];
    };
    GradientFillStyle.prototype.toString = function () {
        var str = "";
        var c = this.colors.length;
        var argb;
        while (c > 0) {
            c--;
            str += this.colors[c] + "#" + this.alphas[c] + "#" + this.ratios[c] + "#";
        }
        return str;
    };
    Object.defineProperty(GradientFillStyle.prototype, "data_type", {
        get: function () {
            return GradientFillStyle.data_type;
        },
        enumerable: true,
        configurable: true
    });
    return GradientFillStyle;
}(GraphicsFillStyle));
GradientFillStyle.data_type = "[graphicsdata GradientFillStyle]";

var GraphicsFactoryHelper = (function () {
    function GraphicsFactoryHelper() {
    }
    GraphicsFactoryHelper.isClockWiseXY = function (point1x, point1y, point2x, point2y, point3x, point3y) {
        var num = (point1x - point2x) * (point3y - point2y) - (point1y - point2y) * (point3x - point2x);
        if (num < 0)
            return false;
        return true;
    };
    GraphicsFactoryHelper.getSign = function (ax, ay, cx, cy, bx, by) {
        return (ax - bx) * (cy - by) - (ay - by) * (cx - bx);
    };
    GraphicsFactoryHelper.pointInTri = function (ax, ay, bx, by, cx, cy, xx, xy) {
        var b1 = GraphicsFactoryHelper.getSign(ax, ay, xx, xy, bx, by) > 0;
        var b2 = GraphicsFactoryHelper.getSign(bx, by, xx, xy, cx, cy) > 0;
        var b3 = GraphicsFactoryHelper.getSign(cx, cy, xx, xy, ax, ay) > 0;
        return ((b1 == b2) && (b2 == b3));
    };
    GraphicsFactoryHelper.getControlXForCurveX = function (a, c, b) {
        return c;
    };
    GraphicsFactoryHelper.getControlYForCurveY = function (a, c, b) {
        return c;
    };
    GraphicsFactoryHelper.drawPoint = function (startX, startY, vertices, curves) {
        GraphicsFactoryHelper.addTriangle(startX - 2, startY - 2, startX + 2, startY - 2, startX + 2, startY + 2, 0, vertices, curves);
        GraphicsFactoryHelper.addTriangle(startX - 2, startY - 2, startX - 2, startY + 2, startX + 2, startY + 2, 0, vertices, curves);
    };
    GraphicsFactoryHelper.drawElipse = function (x, y, width, height, vertices, startAngle, endAngle, stepAngle, curves) {
        // todo: validate input / check edge cases
        var degreeTotal = endAngle - startAngle;
        var steps = degreeTotal / stepAngle;
        var x_last = x + width * Math.cos(startAngle * (Math.PI / 180));
        var y_last = y + height * Math.sin(startAngle * (Math.PI / 180));
        for (var i = 1; i <= steps; i++) {
            var x_tmp = x + width * Math.cos((startAngle + i * stepAngle) * (Math.PI / 180));
            var y_tmp = y + height * Math.sin((startAngle + i * stepAngle) * (Math.PI / 180));
            GraphicsFactoryHelper.addTriangle(x, y, x_tmp, y_tmp, x_last, y_last, 0, vertices, curves);
            x_last = x_tmp;
            y_last = y_tmp;
        }
    };
    GraphicsFactoryHelper.drawElipseStrokes = function (x, y, width, height, vertices, startAngle, endAngle, stepAngle, thickness, curves) {
        // todo: validate input / check edge cases
        var degreeTotal = endAngle - startAngle;
        var steps = degreeTotal / stepAngle;
        var x_last = x + (width + thickness) * Math.cos(startAngle * (Math.PI / 180));
        var y_last = y + (height + thickness) * Math.sin(startAngle * (Math.PI / 180));
        var x_last2 = x + (width - thickness) * Math.cos(startAngle * (Math.PI / 180));
        var y_last2 = y + (height - thickness) * Math.sin(startAngle * (Math.PI / 180));
        for (var i = 1; i <= steps; i++) {
            var x_tmp = x + (width + thickness) * Math.cos((startAngle + i * stepAngle) * (Math.PI / 180));
            var y_tmp = y + (height + thickness) * Math.sin((startAngle + i * stepAngle) * (Math.PI / 180));
            var x_tmp2 = x + (width - thickness) * Math.cos((startAngle + i * stepAngle) * (Math.PI / 180));
            var y_tmp2 = y + (height - thickness) * Math.sin((startAngle + i * stepAngle) * (Math.PI / 180));
            GraphicsFactoryHelper.addTriangle(x_tmp, y_tmp, x_tmp2, y_tmp2, x_last, y_last, 0, vertices, curves);
            GraphicsFactoryHelper.addTriangle(x_last2, y_last2, x_tmp2, y_tmp2, x_last, y_last, 0, vertices, curves);
            x_last = x_tmp;
            y_last = y_tmp;
            x_last2 = x_tmp2;
            y_last2 = y_tmp2;
        }
    };
    GraphicsFactoryHelper.addTriangle = function (startX, startY, controlX, controlY, endX, endY, tri_type, vertices, curves) {
        var x1 = startX;
        var y1 = startY;
        var x2 = controlX;
        var y2 = controlY;
        var x3 = endX;
        var y3 = endY;
        if (GraphicsFactoryHelper.isClockWiseXY(x1, y1, x2, y2, x3, y3)) {
            startX = x3;
            startY = y3;
            controlX = x2;
            controlY = y2;
            endX = x1;
            endY = y1;
        }
        var final_vert_cnt = vertices.length;
        if (tri_type == 0) {
            vertices[final_vert_cnt++] = startX;
            vertices[final_vert_cnt++] = startY;
            if (curves)
                vertices[final_vert_cnt++] = 4.5736980577097704e-41; // ((127<<24)+(127<<16)+0+0)
            vertices[final_vert_cnt++] = controlX;
            vertices[final_vert_cnt++] = controlY;
            if (curves)
                vertices[final_vert_cnt++] = 4.5736980577097704e-41; // ((127<<24)+(127<<16)+0+0)
            vertices[final_vert_cnt++] = endX;
            vertices[final_vert_cnt++] = endY;
            if (curves)
                vertices[final_vert_cnt++] = 4.5736980577097704e-41; // ((127<<24)+(127<<16)+0+0)
        }
        else if (tri_type < 0) {
            vertices[final_vert_cnt++] = startX;
            vertices[final_vert_cnt++] = startY;
            if (curves)
                vertices[final_vert_cnt++] = 1.1708844992641982e-38; // ((127<<24)+(127<<16)+0+0)
            vertices[final_vert_cnt++] = controlX;
            vertices[final_vert_cnt++] = controlY;
            if (curves)
                vertices[final_vert_cnt++] = 2.2778106537599901e-41; // ((127<<24)+(63<<16)+0+0)
            vertices[final_vert_cnt++] = endX;
            vertices[final_vert_cnt++] = endY;
            if (curves)
                vertices[final_vert_cnt++] = 1.7796490496925177e-43; // ((127<<24)+0+0+0)
        }
        else if (tri_type > 0) {
            vertices[final_vert_cnt++] = startX;
            vertices[final_vert_cnt++] = startY;
            if (curves)
                vertices[final_vert_cnt++] = 1.1708846393940446e-38; // ((-128<<24)+(127<<16)+0+0)
            vertices[final_vert_cnt++] = controlX;
            vertices[final_vert_cnt++] = controlY;
            if (curves)
                vertices[final_vert_cnt++] = 2.2779507836064226e-41; // ((-128<<24)+(63<<16)+0+0)
            vertices[final_vert_cnt++] = endX;
            vertices[final_vert_cnt++] = endY;
            if (curves)
                vertices[final_vert_cnt++] = 1.793662034335766e-43; // ((-128<<24)+0+0+0)
        }
    };
    GraphicsFactoryHelper.createCap = function (startX, startY, start_le, start_ri, dir_vec, capstyle, cap_position, thickness, vertices, curves) {
        if (capstyle == CapsStyle.ROUND) {
            //console.log("add round cap");
            var tmp1_x = startX + (cap_position * (dir_vec.x * thickness));
            var tmp1_y = startY + (cap_position * (dir_vec.y * thickness));
            tmp1_x = tmp1_x * 2 - start_le.x / 2 - start_ri.x / 2;
            tmp1_y = tmp1_y * 2 - start_le.y / 2 - start_ri.y / 2;
            GraphicsFactoryHelper.addTriangle(start_le.x, start_le.y, tmp1_x, tmp1_y, start_ri.x, start_ri.y, -1, vertices, curves);
        }
        else if (capstyle == CapsStyle.SQUARE) {
            //console.log("add square cap");
            var tmp1_x = start_le.x + (cap_position * (dir_vec.x * thickness));
            var tmp1_y = start_le.y + (cap_position * (dir_vec.y * thickness));
            var tmp2_x = start_ri.x + (cap_position * (dir_vec.x * thickness));
            var tmp2_y = start_ri.y + (cap_position * (dir_vec.y * thickness));
            GraphicsFactoryHelper.addTriangle(tmp2_x, tmp2_y, tmp1_x, tmp1_y, start_le.x, start_le.y, 0, vertices, curves);
            GraphicsFactoryHelper.addTriangle(tmp2_x, tmp2_y, start_le.x, start_le.y, start_ri.x, start_ri.y, 0, vertices, curves);
        }
    };
    GraphicsFactoryHelper.getLineFormularData = function (a, b) {
        var tmp_x = b.x - a.x;
        var tmp_y = b.y - a.y;
        var return_point = new _awayjs_core.Point();
        if ((tmp_x != 0) && (tmp_y != 0))
            return_point.x = tmp_y / tmp_x;
        return_point.y = -(return_point.x * a.x - a.y);
        return return_point;
    };
    GraphicsFactoryHelper.getQuadricBezierPosition = function (t, start, control, end) {
        var xt = 1 - t;
        return xt * xt * start + 2 * xt * t * control + t * t * end;
    };
    GraphicsFactoryHelper.subdivideCurve = function (startx, starty, cx, cy, endx, endy, startx2, starty2, cx2, cy2, endx2, endy2, array_out, array2_out) {
        var angle_1 = Math.atan2(cy - starty, cx - startx) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        var angle_2 = Math.atan2(endy - cy, endx - cx) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        var angle_delta = angle_2 - angle_1;
        //console.log("angle_delta "+angle_delta);
        if (angle_delta > 180) {
            angle_delta -= 360;
        }
        if (angle_delta < -180) {
            angle_delta += 360;
        }
        if (Math.abs(angle_delta) >= 175) {
            array_out.push(startx, starty, cx, cy, endx, endy);
            array2_out.push(startx2, starty2, cx2, cy2, endx2, endy2);
            return;
        }
        var b1 = false;
        var b2 = false;
        if (angle_delta < 0) {
            // curve is curved to right side. right side is convex
            b1 = GraphicsFactoryHelper.getSign(startx, starty, cx2, cy2, endx, endy) > 0;
            b2 = GraphicsFactoryHelper.getSign(startx, starty, cx, cy, endx, endy) > 0;
            b1 = (((starty - endy) * (cx - startx) + (endx - startx) * (cy - starty)) * ((starty - endy) * (cx2 - startx) + (endx - startx) * (cy2 - starty))) < 0;
        }
        else {
            // curve is curved to left side. left side is convex
            b1 = GraphicsFactoryHelper.getSign(startx2, starty2, cx2, cy2, endx2, endy2) > 0;
            b2 = GraphicsFactoryHelper.getSign(startx2, starty2, cx, cy, endx2, endy2) > 0;
            b1 = (((starty2 - endy) * (cx - startx2) + (endx2 - startx2) * (cy - starty2)) * ((starty2 - endy2) * (cx2 - startx2) + (endx2 - startx2) * (cy2 - starty2))) < 0;
        }
        if (b1) {
            array_out.push(startx, starty, cx, cy, endx, endy);
            array2_out.push(startx2, starty2, cx2, cy2, endx2, endy2);
            return;
        }
        // triangles overlap. we must subdivide:
        var c1x = startx + (cx - startx) * 0.5; // new controlpoint 1.1
        var c1y = starty + (cy - starty) * 0.5;
        var c2x = cx + (endx - cx) * 0.5; // new controlpoint 1.2
        var c2y = cy + (endy - cy) * 0.5;
        var ax = c1x + (c2x - c1x) * 0.5; // new middlepoint 1
        var ay = c1y + (c2y - c1y) * 0.5;
        var c1x2 = startx2 + (cx2 - startx2) * 0.5; // new controlpoint 2.1
        var c1y2 = starty2 + (cy2 - starty2) * 0.5;
        var c2x2 = cx2 + (endx2 - cx2) * 0.5; // new controlpoint 2.2
        var c2y2 = cy2 + (endy2 - cy2) * 0.5;
        var ax2 = c1x2 + (c2x2 - c1x2) * 0.5; // new middlepoint 2
        var ay2 = c1y2 + (c2y2 - c1y2) * 0.5;
        GraphicsFactoryHelper.subdivideCurve(startx, starty, c1x, c1y, ax, ay, startx2, starty2, c1x2, c1y2, ax2, ay2, array_out, array2_out);
        GraphicsFactoryHelper.subdivideCurve(ax, ay, c2x, c2y, endx, endy, ax2, ay2, c2x2, c2y2, endx2, endy2, array_out, array2_out);
    };
    GraphicsFactoryHelper.tesselateCurve = function (startx, starty, cx, cy, endx, endy, array_out) {
        var angle_1 = Math.atan2(cy - starty, cx - startx) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        var angle_2 = Math.atan2(endy - cy, endx - cx) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        var angle_delta = angle_2 - angle_1;
        //console.log("angle_delta "+angle_delta);
        while (angle_delta > 180) {
            angle_delta -= 360;
        }
        while (angle_delta < -180) {
            angle_delta += 360;
        }
        var diff_x = endx - startx;
        var diff_y = endy - starty;
        var len = Math.sqrt(diff_x * diff_x + diff_y * diff_y);
        //console.log("len", len, "angle_delta", angle_delta);
        // if the curve angle is smaller than threshold_ang_2 and the len is smaller than threshold_len, we just early out. we will not use the ctr-point at all
        // todo: find best constants / checks to test if a curve need more subdividing
        /*if(Math.abs(angle_delta)>=150 && len <=3){
            array_out.push(endx, endy);
            return;
        }*/
        if (Math.abs(angle_delta) <= 2 || len <= 5) {
            array_out.push(endx, endy);
            return;
        }
        // curve needs to be subdivided:
        var c1x = startx + (cx - startx) * 0.5; // new controlpoint 1
        var c1y = starty + (cy - starty) * 0.5;
        var c2x = cx + (endx - cx) * 0.5; // new controlpoint 2
        var c2y = cy + (endy - cy) * 0.5;
        var ax = c1x + (c2x - c1x) * 0.5; // new middlepoint 1
        var ay = c1y + (c2y - c1y) * 0.5;
        GraphicsFactoryHelper.tesselateCurve(startx, starty, c1x, c1y, ax, ay, array_out);
        GraphicsFactoryHelper.tesselateCurve(ax, ay, c2x, c2y, endx, endy, array_out);
    };
    return GraphicsFactoryHelper;
}());

/**
 * @class away.base.HitTestCache
 */
var HitTestCache = (function () {
    function HitTestCache() {
        /**
         *
         */
        this.cells = new Array();
        /**
         *
         */
        this.lastCollisionIndex = -1;
    }
    return HitTestCache;
}());

var ElementsUtils = (function () {
    function ElementsUtils() {
    }
    ElementsUtils.generateFaceNormals = function (indexAttributes, positionAttributes, faceNormalAttributes, count, offset) {
        if (offset === void 0) { offset = 0; }
        var indices = indexAttributes.get(count, offset);
        var positions = positionAttributes.get(positionAttributes.count);
        if (faceNormalAttributes == null)
            faceNormalAttributes = new _awayjs_core.Float4Attributes(count + offset);
        else if (faceNormalAttributes.count < count + offset)
            faceNormalAttributes.count = count + offset;
        var indexDim = indexAttributes.stride;
        var posDim = positionAttributes.dimensions;
        var posStride = positionAttributes.stride;
        var faceNormals = faceNormalAttributes.get(count, offset);
        var len = count * indexDim;
        var i = 0;
        var j = 0;
        var index;
        var x1, x2, x3;
        var y1, y2, y3;
        var z1, z2, z3;
        var dx1, dy1, dz1;
        var dx2, dy2, dz2;
        var cx, cy, cz;
        var d;
        if (posDim == 3) {
            for (i = 0; i < len; i += indexDim) {
                index = indices[i] * posStride;
                x1 = positions[index];
                y1 = positions[index + 1];
                z1 = positions[index + 2];
                index = indices[i + 1] * posStride;
                x2 = positions[index];
                y2 = positions[index + 1];
                z2 = positions[index + 2];
                index = indices[i + 2] * posStride;
                x3 = positions[index];
                y3 = positions[index + 1];
                z3 = positions[index + 2];
                dx1 = x3 - x1;
                dy1 = y3 - y1;
                dz1 = z3 - z1;
                dx2 = x2 - x1;
                dy2 = y2 - y1;
                dz2 = z2 - z1;
                cx = dz1 * dy2 - dy1 * dz2;
                cy = dx1 * dz2 - dz1 * dx2;
                cz = dy1 * dx2 - dx1 * dy2;
                d = Math.sqrt(cx * cx + cy * cy + cz * cz);
                // length of cross product = 2*triangle area
                faceNormals[j++] = cx;
                faceNormals[j++] = cy;
                faceNormals[j++] = cz;
                faceNormals[j++] = d;
            }
        }
        else if (posDim == 2) {
            for (i = 0; i < len; i += indexDim) {
                faceNormals[j++] = 0;
                faceNormals[j++] = 0;
                faceNormals[j++] = 1;
                faceNormals[j++] = 1;
            }
        }
        return faceNormalAttributes;
    };
    ElementsUtils.generateNormals = function (indexAttributes, faceNormalAttributes, normalAttributes, concatenatedBuffer) {
        var indices = indexAttributes.get(indexAttributes.count);
        var faceNormals = faceNormalAttributes.get(faceNormalAttributes.count);
        if (normalAttributes == null)
            normalAttributes = new _awayjs_core.Float3Attributes(concatenatedBuffer);
        var indexDim = indexAttributes.dimensions;
        var normalStride = normalAttributes.stride;
        var normals = normalAttributes.get(normalAttributes.count);
        var i;
        var len = normalAttributes.count * normalStride;
        //clear normal values
        for (i = 0; i < len; i += normalStride) {
            normals[i] = 0;
            normals[i + 1] = 0;
            normals[i + 2] = 0;
        }
        len = indexAttributes.count * indexDim;
        var index;
        var f1 = 0;
        var f2 = 1;
        var f3 = 2;
        //collect face normals
        for (i = 0; i < len; i += indexDim) {
            index = indices[i] * normalStride;
            normals[index] += faceNormals[f1];
            normals[index + 1] += faceNormals[f2];
            normals[index + 2] += faceNormals[f3];
            index = indices[i + 1] * normalStride;
            normals[index] += faceNormals[f1];
            normals[index + 1] += faceNormals[f2];
            normals[index + 2] += faceNormals[f3];
            index = indices[i + 2] * normalStride;
            normals[index] += faceNormals[f1];
            normals[index + 1] += faceNormals[f2];
            normals[index + 2] += faceNormals[f3];
            f1 += 4;
            f2 += 4;
            f3 += 4;
        }
        len = normalAttributes.count * normalStride;
        var vx;
        var vy;
        var vz;
        var d;
        //normalise normals collections
        for (i = 0; i < len; i += normalStride) {
            vx = normals[i];
            vy = normals[i + 1];
            vz = normals[i + 2];
            d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
            normals[i] = vx * d;
            normals[i + 1] = vy * d;
            normals[i + 2] = vz * d;
        }
        return normalAttributes;
    };
    ElementsUtils.generateFaceTangents = function (indexAttributes, positionAttributes, uvAttributes, faceTangentAttributes, count, offset, useFaceWeights) {
        if (offset === void 0) { offset = 0; }
        if (useFaceWeights === void 0) { useFaceWeights = false; }
        var indices = indexAttributes.get(count, offset);
        var positions = positionAttributes.get(positionAttributes.count);
        var uvs = uvAttributes.get(uvAttributes.count);
        if (faceTangentAttributes == null)
            faceTangentAttributes = new _awayjs_core.Float4Attributes(count + offset);
        else if (faceTangentAttributes.count < count + offset)
            faceTangentAttributes.count = count + offset;
        var indexDim = indexAttributes.dimensions;
        var posDim = positionAttributes.dimensions;
        var posStride = positionAttributes.stride;
        var uvStride = uvAttributes.stride;
        var faceTangents = faceTangentAttributes.get(count, offset);
        var i = 0;
        var index1;
        var index2;
        var index3;
        var v0;
        var v1;
        var v2;
        var dv1;
        var dv2;
        var denom;
        var x0, y0, z0;
        var dx1, dy1, dz1;
        var dx2, dy2, dz2;
        var cx, cy, cz;
        //multiply by dimension to get index length
        var len = count * indexDim;
        for (i = 0; i < len; i += indexDim) {
            index1 = indices[i];
            index2 = indices[i + 1];
            index3 = indices[i + 2];
            v0 = uvs[index1 * uvStride + 1];
            dv1 = uvs[index2 * uvStride + 1] - v0;
            dv2 = uvs[index3 * uvStride + 1] - v0;
            v0 = index1 * posStride;
            v1 = index2 * posStride;
            v2 = index3 * posStride;
            x0 = positions[v0];
            dx1 = positions[v1] - x0;
            dx2 = positions[v2] - x0;
            cx = dv2 * dx1 - dv1 * dx2;
            y0 = positions[v0 + 1];
            dy1 = positions[v1 + 1] - y0;
            dy2 = positions[v2 + 1] - y0;
            cy = dv2 * dy1 - dv1 * dy2;
            if (posDim == 3) {
                z0 = positions[v0 + 2];
                dz1 = positions[v1 + 2] - z0;
                dz2 = positions[v2 + 2] - z0;
                cz = dv2 * dz1 - dv1 * dz2;
            }
            else {
                cz = 0;
            }
            denom = 1 / Math.sqrt(cx * cx + cy * cy + cz * cz);
            faceTangents[i] = denom * cx;
            faceTangents[i + 1] = denom * cy;
            faceTangents[i + 2] = denom * cz;
        }
        return faceTangentAttributes;
    };
    ElementsUtils.generateTangents = function (indexAttributes, faceTangentAttributes, faceNormalAttributes, tangentAttributes, concatenatedBuffer) {
        var indices = indexAttributes.get(indexAttributes.count);
        var faceTangents = faceTangentAttributes.get(faceTangentAttributes.count);
        var faceNormals = faceNormalAttributes.get(faceNormalAttributes.count);
        if (tangentAttributes == null)
            tangentAttributes = new _awayjs_core.Float3Attributes(concatenatedBuffer);
        var indexDim = indexAttributes.dimensions;
        var tangentStride = tangentAttributes.stride;
        var tangents = tangentAttributes.get(tangentAttributes.count);
        var i;
        var len = tangentAttributes.count * tangentStride;
        //clear tangent values
        for (i = 0; i < len; i += tangentStride) {
            tangents[i] = 0;
            tangents[i + 1] = 0;
            tangents[i + 2] = 0;
        }
        var weight;
        var index;
        var f1 = 0;
        var f2 = 1;
        var f3 = 2;
        var f4 = 3;
        len = indexAttributes.count * indexDim;
        //collect face tangents
        for (i = 0; i < len; i += indexDim) {
            weight = faceNormals[f4];
            index = indices[i] * tangentStride;
            tangents[index++] += faceTangents[f1] * weight;
            tangents[index++] += faceTangents[f2] * weight;
            tangents[index] += faceTangents[f3] * weight;
            index = indices[i + 1] * tangentStride;
            tangents[index++] += faceTangents[f1] * weight;
            tangents[index++] += faceTangents[f2] * weight;
            tangents[index] += faceTangents[f3] * weight;
            index = indices[i + 2] * tangentStride;
            tangents[index++] += faceTangents[f1] * weight;
            tangents[index++] += faceTangents[f2] * weight;
            tangents[index] += faceTangents[f3] * weight;
            f1 += 3;
            f2 += 3;
            f3 += 3;
            f4 += 4;
        }
        var vx;
        var vy;
        var vz;
        var d;
        //normalise tangents collections
        for (i = 0; i < len; i += tangentStride) {
            vx = tangents[i];
            vy = tangents[i + 1];
            vz = tangents[i + 2];
            d = 1.0 / Math.sqrt(vx * vx + vy * vy + vz * vz);
            tangents[i] = vx * d;
            tangents[i + 1] = vy * d;
            tangents[i + 2] = vz * d;
        }
        return tangentAttributes;
    };
    ElementsUtils.generateColors = function (indexAttributes, colorAttributes, concatenatedBuffer, count, offset) {
        if (offset === void 0) { offset = 0; }
        if (colorAttributes == null)
            colorAttributes = new _awayjs_core.Byte4Attributes(concatenatedBuffer);
        if (colorAttributes.count < count + offset)
            colorAttributes.count = count + offset;
        var colors = colorAttributes.get(count, offset);
        var colorStride = colorAttributes.stride;
        var len = colorAttributes.count * colorStride;
        for (var i = 0; i < len; i += colorStride) {
            colors[i] = 0xFF;
            colors[i + 1] = 0xFF;
            colors[i + 2] = 0xFF;
            colors[i + 3] = 0xFF;
        }
        return colorAttributes;
    };
    ElementsUtils.scale = function (scaleA, scaleB, scaleC, output, count, offset) {
        if (offset === void 0) { offset = 0; }
        if (output.count < count + offset)
            output.count = count + offset;
        var scaleArray = new Float32Array([scaleA, scaleB, scaleC]);
        var values = output.get(count, offset);
        var outputStride = output.stride;
        var outputDim = output.dimensions;
        var i;
        var j;
        var len = count * outputStride;
        for (i = 0; i < len; i += outputStride)
            for (j = 0; j < outputDim; j++)
                values[i + j] *= scaleArray[j];
        output.invalidate();
    };
    ElementsUtils.applyTransformation = function (transform, positionAttributes, normalAttributes, tangentAttributes, count, offset) {
        if (offset === void 0) { offset = 0; }
        //todo: make this compatible with 2-dimensional positions
        var positions = positionAttributes.get(count, offset);
        var positionStride = positionAttributes.stride;
        var normals;
        var normalStride;
        if (normalAttributes) {
            normals = normalAttributes.get(count, offset);
            normalStride = normalAttributes.stride;
        }
        var tangents;
        var tangentStride;
        if (tangentAttributes) {
            tangents = tangentAttributes.get(count, offset);
            tangentStride = tangentAttributes.stride;
        }
        var i;
        var i1;
        var i2;
        var vector = new _awayjs_core.Vector3D();
        var invTranspose;
        if (normalAttributes || tangentAttributes) {
            invTranspose = transform.clone();
            invTranspose.invert();
            invTranspose.transpose();
        }
        var vi0 = 0;
        var ni0 = 0;
        var ti0 = 0;
        for (i = 0; i < count; ++i) {
            // bake position
            i1 = vi0 + 1;
            i2 = vi0 + 2;
            vector.x = positions[vi0];
            vector.y = positions[i1];
            vector.z = positions[i2];
            vector = transform.transformVector(vector);
            positions[vi0] = vector.x;
            positions[i1] = vector.y;
            positions[i2] = vector.z;
            vi0 += positionStride;
            if (normals) {
                // bake normal
                i1 = ni0 + 1;
                i2 = ni0 + 2;
                vector.x = normals[ni0];
                vector.y = normals[i1];
                vector.z = normals[i2];
                vector = invTranspose.deltaTransformVector(vector);
                vector.normalize();
                normals[ni0] = vector.x;
                normals[i1] = vector.y;
                normals[i2] = vector.z;
                ni0 += normalStride;
            }
            if (tangents) {
                // bake tangent
                i1 = ti0 + 1;
                i2 = ti0 + 2;
                vector.x = tangents[ti0];
                vector.y = tangents[i1];
                vector.z = tangents[i2];
                vector = invTranspose.deltaTransformVector(vector);
                vector.normalize();
                tangents[ti0] = vector.x;
                tangents[i1] = vector.y;
                tangents[i2] = vector.z;
                ti0 += tangentStride;
            }
        }
        positionAttributes.invalidate();
        if (normalAttributes)
            normalAttributes.invalidate();
        if (tangentAttributes)
            tangentAttributes.invalidate();
    };
    ElementsUtils.getSubIndices = function (indexAttributes, numVertices, indexMappings, indexOffset) {
        if (indexOffset === void 0) { indexOffset = 0; }
        var buffer = indexAttributes.attributesBuffer;
        var numIndices = indexAttributes.length;
        //reset mappings
        indexMappings.length = 0;
        //shortcut for those buffers that fit into the maximum buffer sizes
        if (numIndices < ElementsUtils.LIMIT_INDICES && numVertices < ElementsUtils.LIMIT_VERTS)
            return buffer;
        var i;
        var indices = indexAttributes.get(indexAttributes.count, indexOffset);
        var splitIndices = new Array();
        var indexSwap = ElementsUtils._indexSwap;
        indexSwap.length = numIndices;
        for (i = 0; i < numIndices; i++)
            indexSwap[i] = -1;
        var originalIndex;
        var splitIndex;
        var index = 0;
        var offsetLength = indexOffset * indexAttributes.dimensions;
        // Loop over all triangles
        i = 0;
        while (i < numIndices + offsetLength && i + 1 < ElementsUtils.LIMIT_INDICES && index + 1 < ElementsUtils.LIMIT_VERTS) {
            originalIndex = indices[i];
            if (indexSwap[originalIndex] >= 0) {
                splitIndex = indexSwap[originalIndex];
            }
            else {
                // This vertex does not yet exist in the split list and
                // needs to be copied from the long list.
                splitIndex = index++;
                indexSwap[originalIndex] = splitIndex;
                indexMappings[splitIndex] = originalIndex;
            }
            // Store new index, which may have come from the swap look-up,
            // or from copying a new set of vertex data from the original vector
            splitIndices[i++] = splitIndex;
        }
        buffer = new _awayjs_core.AttributesBuffer(indexAttributes.size * indexAttributes.dimensions, splitIndices.length / indexAttributes.dimensions);
        indexAttributes = indexAttributes.clone(buffer);
        indexAttributes.set(splitIndices);
        return buffer;
    };
    ElementsUtils.getSubVertices = function (vertexBuffer, indexMappings) {
        if (!indexMappings.length)
            return vertexBuffer;
        var stride = vertexBuffer.stride;
        var vertices = vertexBuffer.bufferView;
        var splitVerts = new Uint8Array(indexMappings.length * stride);
        var splitIndex;
        var originalIndex;
        var i = 0;
        var j = 0;
        var len = indexMappings.length;
        for (i = 0; i < len; i++) {
            splitIndex = i * stride;
            originalIndex = indexMappings[i] * stride;
            for (j = 0; j < stride; j++)
                splitVerts[splitIndex + j] = vertices[originalIndex + j];
        }
        vertexBuffer = new _awayjs_core.AttributesBuffer(stride, len);
        vertexBuffer.bufferView = splitVerts;
        return vertexBuffer;
    };
    //TODO - generate this dyanamically based on num tris
    ElementsUtils.hitTestTriangleElements = function (x, y, z, box, triangleElements, count, offset) {
        if (offset === void 0) { offset = 0; }
        var positionAttributes = triangleElements.positions;
        var curveAttributes = triangleElements.getCustomAtributes("curves");
        var posStride = positionAttributes.stride;
        var curveStride = curveAttributes ? curveAttributes.stride : null;
        var positions = positionAttributes.get(count, offset);
        var curves = curveAttributes ? curveAttributes.get(count, offset) : null;
        var indices;
        var len;
        if (triangleElements.indices) {
            indices = triangleElements.indices.get(count, offset);
            positions = positionAttributes.get(positionAttributes.count);
            curves = curveAttributes ? curveAttributes.get(curveAttributes.count) : null;
            len = count * triangleElements.indices.dimensions;
        }
        else {
            positions = positionAttributes.get(count, offset);
            curves = curveAttributes ? curveAttributes.get(count, offset) : null;
            len = count;
        }
        var id0;
        var id1;
        var id2;
        var ax;
        var ay;
        var bx;
        var by;
        var cx;
        var cy;
        var hitTestCache = triangleElements.hitTestCache[offset] || (triangleElements.hitTestCache[offset] = new HitTestCache());
        var index = hitTestCache.lastCollisionIndex;
        if (index != -1 && index < len) {
            precheck: {
                if (indices) {
                    id0 = indices[index + 2];
                    id1 = indices[index + 1];
                    id2 = indices[index];
                }
                else {
                    id0 = index + 2;
                    id1 = index + 1;
                    id2 = index;
                }
                ax = positions[id0 * posStride];
                ay = positions[id0 * posStride + 1];
                bx = positions[id1 * posStride];
                by = positions[id1 * posStride + 1];
                cx = positions[id2 * posStride];
                cy = positions[id2 * posStride + 1];
                //from a to p
                var dx = ax - x;
                var dy = ay - y;
                //edge normal (a-b)
                var nx = by - ay;
                var ny = -(bx - ax);
                var dot = (dx * nx) + (dy * ny);
                if (dot > 0)
                    break precheck;
                dx = bx - x;
                dy = by - y;
                nx = cy - by;
                ny = -(cx - bx);
                dot = (dx * nx) + (dy * ny);
                if (dot > 0)
                    break precheck;
                dx = cx - x;
                dy = cy - y;
                nx = ay - cy;
                ny = -(ax - cx);
                dot = (dx * nx) + (dy * ny);
                if (dot > 0)
                    break precheck;
                if (curves) {
                    //check if not solid
                    if (curves[id0 * curveStride + 2] != -128) {
                        var v0x = bx - ax;
                        var v0y = by - ay;
                        var v1x = cx - ax;
                        var v1y = cy - ay;
                        var v2x = x - ax;
                        var v2y = y - ay;
                        var den = v0x * v1y - v1x * v0y;
                        var v = (v2x * v1y - v1x * v2y) / den;
                        var w = (v0x * v2y - v2x * v0y) / den;
                        //var u:number = 1 - v - w;	//commented out as inlined away
                        //here be dragons
                        var uu = 0.5 * v + w;
                        var vv = w;
                        var d = uu * uu - vv;
                        var az = curves[id0 * curveStride];
                        if (d > 0 && az == -128) {
                            break precheck;
                        }
                        else if (d < 0 && az == 127) {
                            break precheck;
                        }
                    }
                }
                return true;
            }
        }
        //hard coded min vertex count to bother using a grid for
        if (len > 150) {
            var cells = hitTestCache.cells;
            var divisions = cells.length ? hitTestCache.divisions : (hitTestCache.divisions = Math.min(Math.ceil(Math.sqrt(len)), 32));
            var conversionX = divisions / box.width;
            var conversionY = divisions / box.height;
            var minx = box.x;
            var miny = box.y;
            if (!cells.length) {
                //now we have bounds start creating grid cells and filling
                cells.length = divisions * divisions;
                for (var k = 0; k < len; k += 3) {
                    if (indices) {
                        id0 = indices[k + 2];
                        id1 = indices[k + 1];
                        id2 = indices[k];
                    }
                    else {
                        id0 = k + 2;
                        id1 = k + 1;
                        id2 = k;
                    }
                    ax = positions[id0 * posStride];
                    ay = positions[id0 * posStride + 1];
                    bx = positions[id1 * posStride];
                    by = positions[id1 * posStride + 1];
                    cx = positions[id2 * posStride];
                    cy = positions[id2 * posStride + 1];
                    //subtractions to push into positive space
                    var min_index_x = Math.floor((Math.min(ax, bx, cx) - minx) * conversionX);
                    var min_index_y = Math.floor((Math.min(ay, by, cy) - miny) * conversionY);
                    var max_index_x = Math.floor((Math.max(ax, bx, cx) - minx) * conversionX);
                    var max_index_y = Math.floor((Math.max(ay, by, cy) - miny) * conversionY);
                    for (var i = min_index_x; i <= max_index_x; i++) {
                        for (var j = min_index_y; j <= max_index_y; j++) {
                            var c = i + j * divisions;
                            var nodes = cells[c] || (cells[c] = new Array());
                            //push in the triangle ids
                            nodes.push(k);
                        }
                    }
                }
            }
            var index_x = Math.floor((x - minx) * conversionX);
            var index_y = Math.floor((y - miny) * conversionY);
            var nodes = cells[index_x + index_y * divisions];
            if (nodes == null) {
                hitTestCache.lastCollisionIndex = -1;
                return false;
            }
            var nodeCount = nodes.length;
            for (var n = 0; n < nodeCount; n++) {
                var k = nodes[n];
                if (indices) {
                    id2 = indices[k];
                }
                else {
                    id2 = k;
                }
                if (id2 == index)
                    continue;
                if (indices) {
                    id0 = indices[k + 2];
                    id1 = indices[k + 1];
                }
                else {
                    id0 = k + 2;
                    id1 = k + 1;
                }
                ax = positions[id0 * posStride];
                ay = positions[id0 * posStride + 1];
                bx = positions[id1 * posStride];
                by = positions[id1 * posStride + 1];
                cx = positions[id2 * posStride];
                cy = positions[id2 * posStride + 1];
                //from a to p
                var dx = ax - x;
                var dy = ay - y;
                //edge normal (a-b)
                var nx = by - ay;
                var ny = -(bx - ax);
                var dot = (dx * nx) + (dy * ny);
                if (dot > 0)
                    continue;
                dx = bx - x;
                dy = by - y;
                nx = cy - by;
                ny = -(cx - bx);
                dot = (dx * nx) + (dy * ny);
                if (dot > 0)
                    continue;
                dx = cx - x;
                dy = cy - y;
                nx = ay - cy;
                ny = -(ax - cx);
                dot = (dx * nx) + (dy * ny);
                if (dot > 0)
                    continue;
                if (curves) {
                    //check if not solid
                    if (curves[id0 * curveStride + 2] != -128) {
                        var v0x = bx - ax;
                        var v0y = by - ay;
                        var v1x = cx - ax;
                        var v1y = cy - ay;
                        var v2x = x - ax;
                        var v2y = y - ay;
                        var den = v0x * v1y - v1x * v0y;
                        var v = (v2x * v1y - v1x * v2y) / den;
                        var w = (v0x * v2y - v2x * v0y) / den;
                        //var u:number = 1 - v - w;	//commented out as inlined away
                        //here be dragons
                        var uu = 0.5 * v + w;
                        var vv = w;
                        var d = uu * uu - vv;
                        var az = curves[id0 * curveStride];
                        if (d > 0 && az == -128) {
                            continue;
                        }
                        else if (d < 0 && az == 127) {
                            continue;
                        }
                    }
                }
                hitTestCache.lastCollisionIndex = k;
                return true;
            }
            hitTestCache.lastCollisionIndex = -1;
            return false;
        }
        //brute force
        for (var k = 0; k < len; k += 3) {
            if (indices) {
                id2 = indices[k];
            }
            else {
                id2 = k;
            }
            if (id2 == index)
                continue;
            if (indices) {
                id0 = indices[k + 2];
                id1 = indices[k + 1];
            }
            else {
                id0 = k + 2;
                id1 = k + 1;
            }
            ax = positions[id0 * posStride];
            ay = positions[id0 * posStride + 1];
            bx = positions[id1 * posStride];
            by = positions[id1 * posStride + 1];
            cx = positions[id2 * posStride];
            cy = positions[id2 * posStride + 1];
            //from a to p
            var dx = ax - x;
            var dy = ay - y;
            //edge normal (a-b)
            var nx = by - ay;
            var ny = -(bx - ax);
            var dot = (dx * nx) + (dy * ny);
            if (dot > 0)
                continue;
            dx = bx - x;
            dy = by - y;
            nx = cy - by;
            ny = -(cx - bx);
            dot = (dx * nx) + (dy * ny);
            if (dot > 0)
                continue;
            dx = cx - x;
            dy = cy - y;
            nx = ay - cy;
            ny = -(ax - cx);
            dot = (dx * nx) + (dy * ny);
            if (dot > 0)
                continue;
            if (curves) {
                //check if not solid
                if (curves[id0 * curveStride + 2] != -128) {
                    var v0x = bx - ax;
                    var v0y = by - ay;
                    var v1x = cx - ax;
                    var v1y = cy - ay;
                    var v2x = x - ax;
                    var v2y = y - ay;
                    var den = v0x * v1y - v1x * v0y;
                    var v = (v2x * v1y - v1x * v2y) / den;
                    var w = (v0x * v2y - v2x * v0y) / den;
                    //var u:number = 1 - v - w;	//commented out as inlined away
                    //here be dragons
                    var uu = 0.5 * v + w;
                    var vv = w;
                    var d = uu * uu - vv;
                    var az = curves[id0 * curveStride];
                    if (d > 0 && az == -128) {
                        continue;
                    }
                    else if (d < 0 && az == 127) {
                        continue;
                    }
                }
            }
            hitTestCache.lastCollisionIndex = k;
            return true;
        }
        hitTestCache.lastCollisionIndex = -1;
        return false;
    };
    ElementsUtils.getTriangleGraphicsBoxBounds = function (positionAttributes, indexAttributes, output, count, offset, halfThickness) {
        if (offset === void 0) { offset = 0; }
        if (halfThickness === void 0) { halfThickness = 0; }
        var positions;
        var posDim = positionAttributes.dimensions;
        var posStride = positionAttributes.stride;
        var pos;
        var minX = 0, minY = 0, minZ = 0;
        var maxX = 0, maxY = 0, maxZ = 0;
        var indices;
        var len;
        if (indexAttributes) {
            len = count * indexAttributes.dimensions;
            indices = indexAttributes.get(count, offset);
            positions = positionAttributes.get(positionAttributes.count);
        }
        else {
            len = count;
            positions = positionAttributes.get(count, offset);
        }
        var index;
        for (var i = 0; i < len; i++) {
            index = (indices) ? indices[i] * posStride : i * posStride;
            if (i == 0) {
                maxX = minX = positions[index];
                maxY = minY = positions[index + 1];
                maxZ = minZ = (posDim == 3) ? positions[index + 2] : 0;
            }
            else {
                pos = positions[index];
                if (pos < minX)
                    minX = pos;
                else if (pos > maxX)
                    maxX = pos;
                pos = positions[index + 1];
                if (pos < minY)
                    minY = pos;
                else if (pos > maxY)
                    maxY = pos;
                if (posDim == 3) {
                    pos = positions[index + 2];
                    if (pos < minZ)
                        minZ = pos;
                    else if (pos > maxZ)
                        maxZ = pos;
                }
            }
        }
        if (output == null)
            output = new _awayjs_core.Box();
        output.x = minX + halfThickness;
        output.y = minY + halfThickness;
        output.z = minZ;
        output.right = maxX - halfThickness;
        output.bottom = maxY - halfThickness;
        output.back = maxZ;
        return output;
    };
    ElementsUtils.getTriangleGraphicsSphereBounds = function (positionAttributes, center, output, count, offset) {
        if (offset === void 0) { offset = 0; }
        var positions = positionAttributes.get(count, offset);
        var posDim = positionAttributes.dimensions;
        var posStride = positionAttributes.stride;
        var maxRadiusSquared = 0;
        var radiusSquared;
        var len = count * posStride;
        var distanceX;
        var distanceY;
        var distanceZ;
        for (var i = 0; i < len; i += posStride) {
            distanceX = positions[i] - center.x;
            distanceY = positions[i + 1] - center.y;
            distanceZ = (posDim == 3) ? positions[i + 2] - center.z : -center.z;
            radiusSquared = distanceX * distanceX + distanceY * distanceY + distanceZ * distanceZ;
            if (maxRadiusSquared < radiusSquared)
                maxRadiusSquared = radiusSquared;
        }
        if (output == null)
            output = new _awayjs_core.Sphere();
        output.x = center.x;
        output.y = center.y;
        output.z = center.z;
        output.radius = Math.sqrt(maxRadiusSquared);
        return output;
    };
    ElementsUtils.updateTriangleGraphicsSlice9 = function (triangleElements, originalRect, scaleX, scaleY, init, copy) {
        // todo: for now this only works for Float2Attributes.
        if (init === void 0) { init = false; }
        if (copy === void 0) { copy = false; }
        if (triangleElements.slice9Indices.length != 9) {
            throw ("ElementUtils: Error - triangleElement does not provide valid slice9Indices!");
        }
        var s_len = triangleElements.slice9Indices.length;
        var innerWidth = originalRect.width - (triangleElements.slice9offsets.x + triangleElements.slice9offsets.width) / scaleX;
        var innerHeight = originalRect.height - (triangleElements.slice9offsets.y + triangleElements.slice9offsets.height) / scaleY;
        if (innerWidth < 0) {
            innerWidth = 0;
            scaleX = (triangleElements.slice9offsets.x + triangleElements.slice9offsets.width) / originalRect.width;
        }
        if (innerHeight < 0) {
            innerHeight = 0;
            scaleY = (triangleElements.slice9offsets.y + triangleElements.slice9offsets.height) / originalRect.height;
        }
        var newElem;
        var positions;
        if (copy) {
            var newverts = new Uint8Array(triangleElements.positions.count * 8);
            while (v < triangleElements.positions.count * 2) {
                newverts[v] = positions[v++];
                newverts[v] = positions[v++];
            }
            var vertexBuffer = new _awayjs_core.AttributesBuffer(8, triangleElements.positions.count);
            vertexBuffer.bufferView = newverts;
            var newElem = new TriangleElements(vertexBuffer);
            newElem.setPositions(new _awayjs_core.Float2Attributes(vertexBuffer));
            newElem.slice9offsets = triangleElements.slice9offsets;
            newElem.initialSlice9Positions = triangleElements.initialSlice9Positions;
            newElem.slice9Indices = triangleElements.slice9Indices;
            positions = newElem.positions.get(newElem.positions.count);
            v = 0;
        }
        else {
            positions = triangleElements.positions.get(triangleElements.positions.count);
        }
        // todo: i had trouble when just cloning the positions 
        //	for now i just create the initialSlice9Positions by iterating the positions
        var v = 0;
        var init_positions;
        if (init) {
            init_positions = [];
            init_positions.length = triangleElements.positions.count * 2;
            while (v < triangleElements.positions.count * 2) {
                init_positions[v] = positions[v++];
                init_positions[v] = positions[v++];
            }
            triangleElements.initialSlice9Positions = init_positions;
        }
        else {
            init_positions = triangleElements.initialSlice9Positions;
        }
        var slice9Indices = triangleElements.slice9Indices;
        var s = 0;
        v = 0;
        var slice9Offsets_x = [];
        slice9Offsets_x.length = 3;
        var slice9Offsets_y = [];
        slice9Offsets_y.length = 3;
        slice9Offsets_x[0] = originalRect.x;
        slice9Offsets_x[1] = originalRect.x + triangleElements.slice9offsets.x / scaleX;
        slice9Offsets_x[2] = originalRect.x + triangleElements.slice9offsets.x / scaleX + innerWidth;
        slice9Offsets_y[0] = originalRect.y;
        slice9Offsets_y[1] = originalRect.y + triangleElements.slice9offsets.y / scaleY;
        slice9Offsets_y[2] = originalRect.y + triangleElements.slice9offsets.y / scaleY + innerHeight;
        //console.log("slice9Offsets_x",slice9Offsets_x);
        //console.log("slice9Offsets_y",slice9Offsets_x);
        var row_cnt = -1;
        var col_cnt = 0;
        var scalex = 0;
        var scaley = 0;
        var offsetx = 0;
        var offsety = 0;
        // iterating over the 9 chunks - keep in mind that we are constructing a 3x3 grid:
        for (s = 0; s < s_len; s++) {
            // keep track of column and row index
            if (row_cnt == 2) {
                col_cnt++;
                row_cnt = -1;
            }
            row_cnt++;
            // only need to x-scale if this is the middle column
            // if the innerWidth<=0 we can skip this complete column
            if (col_cnt == 1) {
                scalex = innerWidth;
            }
            else {
                scalex = 1 / scaleX;
            }
            // only need to y-scale if this is the middle row
            // if the innerHeight<=0 we can skip this complete row
            if (row_cnt == 1) {
                scaley = innerHeight;
            }
            else {
                scaley = 1 / scaleY;
            }
            // offsetx is different for each column
            offsetx = slice9Offsets_x[col_cnt];
            // offsety is different for each row
            offsety = slice9Offsets_y[row_cnt];
            // iterate the verts and apply the translation / scale
            while (v < slice9Indices[s]) {
                positions[v] = offsetx + (init_positions[v++] * scalex);
                positions[v] = offsety + (init_positions[v++] * scaley);
            }
        }
        //console.log("positions",positions);
        if (copy) {
            newElem.positions.invalidate();
            return newElem;
        }
        triangleElements.positions.invalidate();
        return triangleElements;
    };
    return ElementsUtils;
}());
ElementsUtils.tempFloat32x4 = new Float32Array(4);
ElementsUtils.LIMIT_VERTS = 0xffff;
ElementsUtils.LIMIT_INDICES = 0xffffff;
ElementsUtils._indexSwap = new Array();

/**
 * Dispatched to notify changes in a sub geometry object's state.
 *
 * @class away.events.ElementsEvent
 * @see away.core.base.Graphics
 */
var ElementsEvent = (function (_super) {
    __extends(ElementsEvent, _super);
    /**
     * Create a new GraphicsEvent
     * @param type The event type.
     * @param attributesView An optional data type of the vertex data being updated.
     */
    function ElementsEvent(type, attributesView) {
        var _this = _super.call(this, type) || this;
        _this._attributesView = attributesView;
        return _this;
    }
    Object.defineProperty(ElementsEvent.prototype, "attributesView", {
        /**
         * The attributes view of the vertex data.
         */
        get: function () {
            return this._attributesView;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current object.
     */
    ElementsEvent.prototype.clone = function () {
        return new ElementsEvent(this.type, this._attributesView);
    };
    return ElementsEvent;
}(_awayjs_core.EventBase));
/**
 * Dispatched when a Elements's index data has been updated.
 */
ElementsEvent.INVALIDATE_INDICES = "invalidateIndices";
/**
 * Dispatched when a Elements's index data has been disposed.
 */
ElementsEvent.CLEAR_INDICES = "clearIndices";
/**
 * Dispatched when a Elements's vertex data has been updated.
 */
ElementsEvent.INVALIDATE_VERTICES = "invalidateVertices";
/**
 * Dispatched when a Elements's vertex data has been disposed.
 */
ElementsEvent.CLEAR_VERTICES = "clearVertices";

/**
 * @class away.base.TriangleElements
 */
var ElementsBase = (function (_super) {
    __extends(ElementsBase, _super);
    /**
     *
     */
    function ElementsBase(concatenatedBuffer) {
        if (concatenatedBuffer === void 0) { concatenatedBuffer = null; }
        var _this = _super.call(this) || this;
        _this._customAttributesNames = new Array();
        _this._customAttributes = new Object();
        _this._numElements = 0;
        _this._numVertices = 0;
        _this._verticesDirty = new Object();
        _this._invalidateVertices = new Object();
        _this._concatenatedBuffer = concatenatedBuffer;
        return _this;
    }
    Object.defineProperty(ElementsBase.prototype, "traverseName", {
        get: function () {
            throw new _awayjs_core.AbstractMethodError();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementsBase.prototype, "concatenatedBuffer", {
        get: function () {
            return this._concatenatedBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementsBase.prototype, "indices", {
        /**
         * The raw index data that define the faces.
         */
        get: function () {
            return this._indices;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    ElementsBase.prototype.getCustomAtributesNames = function () {
        return this._customAttributesNames;
    };
    /**
     *
     */
    ElementsBase.prototype.getCustomAtributes = function (name) {
        return this._customAttributes[name];
    };
    Object.defineProperty(ElementsBase.prototype, "numElements", {
        /**
         * The total amount of triangles in the TriangleElements.
         */
        get: function () {
            return this._numElements;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ElementsBase.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    ElementsBase.prototype.copyTo = function (elements) {
        if (this.indices)
            elements.setIndices(this.indices.clone());
        for (var name in this._customAttributes)
            elements.setCustomAttributes(name, this.getCustomAtributes(name).clone());
    };
    /**
     *
     */
    ElementsBase.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._indices) {
            this._indices.dispose();
            this._indices = null;
        }
        for (var name in this._customAttributes) {
            this._customAttributes[name].dispose();
            delete this._customAttributes;
        }
    };
    ElementsBase.prototype.setIndices = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values instanceof _awayjs_core.Short3Attributes) {
            if (this._indices)
                this.clearIndices();
            this._indices = values;
        }
        else if (values) {
            if (!this._indices)
                this._indices = new _awayjs_core.Short3Attributes();
            this._indices.set(values, offset);
        }
        else if (this._indices) {
            this._indices.dispose();
            this._indices = null;
            this.clearIndices();
        }
        if (this._indices) {
            this._numElements = this._indices.count;
            this.invalidateIndices();
        }
        else {
            this._numElements = 0;
        }
    };
    ElementsBase.prototype.setCustomAttributes = function (name, values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values == this._customAttributes[name])
            return;
        if (values instanceof _awayjs_core.AttributesView) {
            this.clearVertices(this._customAttributes[name]);
            this._customAttributes[name] = values;
        }
        else if (values) {
            if (!this._customAttributes[name])
                this._customAttributes[name] = new _awayjs_core.Float3Attributes(this._concatenatedBuffer); //default custom atrributes is Float3
            this._customAttributes[name].set(values, offset);
        }
        else if (this._customAttributes[name]) {
            this.clearVertices(this._customAttributes[name]);
            this._customAttributesNames.splice(this._customAttributesNames.indexOf(name), 1);
            delete this._customAttributes[name];
            return;
        }
        this.invalidateVertices(this._customAttributes[name]);
        this._verticesDirty[this._customAttributes[name].id] = false;
        if (this._customAttributesNames.indexOf(name) == -1)
            this._customAttributesNames.push(name);
    };
    /**
     * Clones the current object
     * @return An exact duplicate of the current object.
     */
    ElementsBase.prototype.clone = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    ElementsBase.prototype.applyTransformation = function (transform, count, offset) {
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * Scales the geometry.
     * @param scale The amount by which to scale.
     */
    ElementsBase.prototype.scale = function (scale, count, offset) {
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        throw new _awayjs_core.AbstractMethodError();
    };
    ElementsBase.prototype.scaleUV = function (scaleU, scaleV, count, offset) {
        if (scaleU === void 0) { scaleU = 1; }
        if (scaleV === void 0) { scaleV = 1; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        throw new _awayjs_core.AbstractMethodError();
    };
    ElementsBase.prototype.getBoxBounds = function (target, count, offset) {
        if (target === void 0) { target = null; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        throw new _awayjs_core.AbstractMethodError();
    };
    ElementsBase.prototype.getSphereBounds = function (center, target, count, offset) {
        if (target === void 0) { target = null; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        throw new _awayjs_core.AbstractMethodError();
    };
    ElementsBase.prototype.hitTestPoint = function (x, y, z, box, count, offset) {
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        throw new _awayjs_core.AbstractMethodError();
    };
    ElementsBase.prototype.invalidateIndices = function () {
        if (!this._invalidateIndices)
            this._invalidateIndices = new ElementsEvent(ElementsEvent.INVALIDATE_INDICES, this._indices);
        this.dispatchEvent(this._invalidateIndices);
    };
    ElementsBase.prototype.clearIndices = function () {
        this.dispatchEvent(new ElementsEvent(ElementsEvent.CLEAR_INDICES, this._indices));
    };
    ElementsBase.prototype.invalidateVertices = function (attributesView) {
        if (!attributesView || this._verticesDirty[attributesView.id])
            return;
        this._verticesDirty[attributesView.id] = true;
        if (!this._invalidateVertices[attributesView.id])
            this._invalidateVertices[attributesView.id] = new ElementsEvent(ElementsEvent.INVALIDATE_VERTICES, attributesView);
        this.dispatchEvent(this._invalidateVertices[attributesView.id]);
    };
    ElementsBase.prototype.clearVertices = function (attributesView) {
        if (!attributesView)
            return;
        attributesView.dispose();
        this.dispatchEvent(new ElementsEvent(ElementsEvent.CLEAR_VERTICES, attributesView));
        this._verticesDirty[attributesView.id] = null;
        this._invalidateVertices[attributesView.id] = null;
    };
    return ElementsBase;
}(_awayjs_core.AssetBase));

/**
 * @class away.base.TriangleElements
 */
var TriangleElements = (function (_super) {
    __extends(TriangleElements, _super);
    function TriangleElements() {
        var _this = _super.apply(this, arguments) || this;
        _this._faceNormalsDirty = true;
        _this._faceTangentsDirty = true;
        _this._autoDeriveNormals = true;
        _this._autoDeriveTangents = true;
        //used for hittesting geometry
        _this.hitTestCache = new Object();
        _this.halfStrokeThickness = 0;
        return _this;
        // public _iTestCollision(pickingCollider:IPickingCollider, material:MaterialBase, pickingCollision:PickingCollision, count:number = 0, offset:number = 0):boolean
        // {
        // 	return pickingCollider.testTriangleCollision(this, material, pickingCollision, count || this._numVertices, offset);
        // }
    }
    TriangleElements.prototype.updateSlice9 = function (width, height) {
    };
    Object.defineProperty(TriangleElements.prototype, "assetType", {
        get: function () {
            return TriangleElements.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "traverseName", {
        get: function () {
            return TriangleElements.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "useCondensedIndices", {
        /**
         * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
         * by condensing the number of joint index values required per sprite. Only applicable to
         * skeleton animations that utilise more than one sprite object. Defaults to false.
         */
        get: function () {
            return this._useCondensedIndices;
        },
        set: function (value) {
            if (this._useCondensedIndices == value)
                return;
            this._useCondensedIndices = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "jointsPerVertex", {
        /**
         *
         */
        get: function () {
            return this._jointsPerVertex;
        },
        set: function (value) {
            if (this._jointsPerVertex == value)
                return;
            this._jointsPerVertex = value;
            if (this._jointIndices)
                this._jointIndices.dimensions = this._jointsPerVertex;
            if (this._jointWeights)
                this._jointWeights.dimensions = this._jointsPerVertex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "autoDeriveNormals", {
        /**
         * True if the vertex normals should be derived from the geometry, false if the vertex normals are set
         * explicitly.
         */
        get: function () {
            return this._autoDeriveNormals;
        },
        set: function (value) {
            if (this._autoDeriveNormals == value)
                return;
            this._autoDeriveNormals = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "autoDeriveTangents", {
        /**
         * True if the vertex tangents should be derived from the geometry, false if the vertex normals are set
         * explicitly.
         */
        get: function () {
            return this._autoDeriveTangents;
        },
        set: function (value) {
            if (this._autoDeriveTangents == value)
                return;
            this._autoDeriveTangents = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "positions", {
        /**
         *
         */
        get: function () {
            if (!this._positions)
                this.setPositions(new _awayjs_core.Float3Attributes(this._concatenatedBuffer));
            return this._positions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "normals", {
        /**
         *
         */
        get: function () {
            if (!this._normals || this._verticesDirty[this._normals.id])
                this.setNormals(this._normals);
            return this._normals;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "tangents", {
        /**
         *
         */
        get: function () {
            if (!this._tangents || this._verticesDirty[this._tangents.id])
                this.setTangents(this._tangents);
            return this._tangents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "faceNormals", {
        /**
         * The raw data of the face normals, in the same order as the faces are listed in the index list.
         */
        get: function () {
            if (this._faceNormalsDirty)
                this.updateFaceNormals();
            return this._faceNormals;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "faceTangents", {
        /**
         * The raw data of the face tangets, in the same order as the faces are listed in the index list.
         */
        get: function () {
            if (this._faceTangentsDirty)
                this.updateFaceTangents();
            return this._faceTangents;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "uvs", {
        /**
         *
         */
        get: function () {
            if (!this._uvs && TriangleElements.isIE) {
                var attributesView2 = new _awayjs_core.AttributesView(Float32Array, 2);
                attributesView2.set(this._positions.get(this._positions.count));
                var attributesBuffer2 = attributesView2.attributesBuffer;
                attributesView2.dispose();
                this._uvs = new _awayjs_core.Float2Attributes(attributesBuffer2);
            }
            return this._uvs;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "jointIndices", {
        /**
         *
         */
        get: function () {
            return this._jointIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "jointWeights", {
        /**
         *
         */
        get: function () {
            return this._jointWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TriangleElements.prototype, "condensedIndexLookUp", {
        get: function () {
            return this._condensedIndexLookUp;
        },
        enumerable: true,
        configurable: true
    });
    TriangleElements.prototype.getBoxBounds = function (target, count, offset) {
        if (target === void 0) { target = null; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        return ElementsUtils.getTriangleGraphicsBoxBounds(this.positions, this.indices, target, count || this._numElements || this._numVertices, offset, this.halfStrokeThickness);
    };
    TriangleElements.prototype.getSphereBounds = function (center, target, count, offset) {
        if (target === void 0) { target = null; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        return ElementsUtils.getTriangleGraphicsSphereBounds(this.positions, center, target, count || this._numVertices, offset);
    };
    TriangleElements.prototype.hitTestPoint = function (x, y, z, box, count, offset, idx_count, idx_offset) {
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        if (idx_count === void 0) { idx_count = 0; }
        if (idx_offset === void 0) { idx_offset = 0; }
        return ElementsUtils.hitTestTriangleElements(x, y, 0, box, this, count || this._numElements || this._numVertices, offset);
    };
    TriangleElements.prototype.setPositions = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values == this._positions)
            return;
        if (values instanceof _awayjs_core.AttributesView) {
            this.clearVertices(this._positions);
            this._positions = values;
        }
        else if (values) {
            if (!this._positions)
                this._positions = new _awayjs_core.Float3Attributes(this._concatenatedBuffer);
            this._positions.set(values, offset);
        }
        else {
            this.clearVertices(this._positions);
            this._positions = new _awayjs_core.Float3Attributes(this._concatenatedBuffer); //positions cannot be null
        }
        this._numVertices = this._positions.count;
        if (this._autoDeriveNormals)
            this.invalidateVertices(this._normals);
        if (this._autoDeriveTangents)
            this.invalidateVertices(this._tangents);
        this.invalidateVertices(this._positions);
        this._verticesDirty[this._positions.id] = false;
    };
    TriangleElements.prototype.setNormals = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (!this._autoDeriveNormals) {
            if (values == this._normals)
                return;
            if (values instanceof _awayjs_core.Float3Attributes) {
                this.clearVertices(this._normals);
                this._normals = values;
            }
            else if (values) {
                if (!this._normals)
                    this._normals = new _awayjs_core.Float3Attributes(this._concatenatedBuffer);
                this._normals.set(values, offset);
            }
            else if (this._normals) {
                this.clearVertices(this._normals);
                this._normals = null;
                return;
            }
        }
        else {
            this._normals = ElementsUtils.generateNormals(this.indices, this.faceNormals, this._normals, this._concatenatedBuffer);
        }
        this.invalidateVertices(this._normals);
        this._verticesDirty[this._normals.id] = false;
    };
    TriangleElements.prototype.setTangents = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (!this._autoDeriveTangents) {
            if (values == this._tangents)
                return;
            if (values instanceof _awayjs_core.Float3Attributes) {
                this.clearVertices(this._tangents);
                this._tangents = values;
            }
            else if (values) {
                if (!this._tangents)
                    this._tangents = new _awayjs_core.Float3Attributes(this._concatenatedBuffer);
                this._tangents.set(values, offset);
            }
            else if (this._tangents) {
                this.clearVertices(this._tangents);
                this._tangents = null;
                return;
            }
        }
        else {
            this._tangents = ElementsUtils.generateTangents(this.indices, this.faceTangents, this.faceNormals, this._tangents, this._concatenatedBuffer);
        }
        this.invalidateVertices(this._tangents);
        this._verticesDirty[this._tangents.id] = false;
    };
    TriangleElements.prototype.setUVs = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values == this._uvs)
            return;
        if (values instanceof _awayjs_core.AttributesView) {
            this.clearVertices(this._uvs);
            this._uvs = values;
        }
        else if (values) {
            if (!this._uvs)
                this._uvs = new _awayjs_core.Float2Attributes(this._concatenatedBuffer);
            this._uvs.set(values, offset);
        }
        else if (this._uvs) {
            this.clearVertices(this._uvs);
            this._uvs = null;
            return;
        }
        this.invalidateVertices(this._uvs);
        this._verticesDirty[this._uvs.id] = false;
    };
    TriangleElements.prototype.setJointIndices = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values == this._jointIndices)
            return;
        if (values instanceof _awayjs_core.AttributesView) {
            this.clearVertices(this._jointIndices);
            this._jointIndices = values;
        }
        else if (values) {
            if (!this._jointIndices)
                this._jointIndices = new _awayjs_core.AttributesView(Float32Array, this._jointsPerVertex, this._concatenatedBuffer);
            if (this._useCondensedIndices) {
                var i = 0;
                var oldIndex;
                var newIndex = 0;
                var dic = new Object();
                this._condensedIndexLookUp = new Array();
                while (i < values.length) {
                    oldIndex = values[i];
                    // if we encounter a new index, assign it a new condensed index
                    if (dic[oldIndex] == undefined) {
                        dic[oldIndex] = newIndex;
                        this._condensedIndexLookUp[newIndex++] = oldIndex;
                    }
                    //reset value to dictionary lookup
                    values[i++] = dic[oldIndex];
                }
            }
            this._jointIndices.set(values, offset);
        }
        else if (this._jointIndices) {
            this.clearVertices(this._jointIndices);
            this._jointIndices = null;
            return;
        }
        this.invalidateVertices(this._jointIndices);
        this._verticesDirty[this._jointIndices.id] = false;
    };
    TriangleElements.prototype.setJointWeights = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values == this._jointWeights)
            return;
        if (values instanceof _awayjs_core.AttributesView) {
            this.clearVertices(this._jointWeights);
            this._jointWeights = values;
        }
        else if (values) {
            if (!this._jointWeights)
                this._jointWeights = new _awayjs_core.AttributesView(Float32Array, this._jointsPerVertex, this._concatenatedBuffer);
            this._jointWeights.set(values, offset);
        }
        else if (this._jointWeights) {
            this.clearVertices(this._jointWeights);
            this._jointWeights = null;
            return;
        }
        this.invalidateVertices(this._jointWeights);
        this._verticesDirty[this._jointWeights.id] = false;
    };
    /**
     *
     */
    TriangleElements.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        if (this._positions) {
            this._positions.dispose();
            this._positions = null;
        }
        if (this._normals) {
            this._normals.dispose();
            this._normals = null;
        }
        if (this._tangents) {
            this._tangents.dispose();
            this._tangents = null;
        }
        if (this._uvs) {
            this._uvs.dispose();
            this._uvs = null;
        }
        if (this._jointIndices) {
            this._jointIndices.dispose();
            this._jointIndices = null;
        }
        if (this._jointWeights) {
            this._jointWeights.dispose();
            this._jointWeights = null;
        }
        if (this._faceNormals) {
            this._faceNormals.dispose();
            this._faceNormals = null;
        }
        if (this._faceTangents) {
            this._faceTangents.dispose();
            this._faceTangents = null;
        }
    };
    TriangleElements.prototype.setIndices = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        _super.prototype.setIndices.call(this, values, offset);
        this._faceNormalsDirty = true;
        this._faceTangentsDirty = true;
        if (this._autoDeriveNormals)
            this.invalidateVertices(this._normals);
        if (this._autoDeriveTangents)
            this.invalidateVertices(this._tangents);
    };
    TriangleElements.prototype.copyTo = function (elements) {
        _super.prototype.copyTo.call(this, elements);
        //temp disable auto derives
        var autoDeriveNormals = this._autoDeriveNormals;
        var autoDeriveTangents = this._autoDeriveTangents;
        elements.autoDeriveNormals = this._autoDeriveNormals = false;
        elements.autoDeriveTangents = this._autoDeriveTangents = false;
        elements.setPositions(this.positions.clone());
        if (this.normals)
            elements.setNormals(this.normals.clone());
        if (this.tangents)
            elements.setTangents(this.tangents.clone());
        if (this.uvs)
            elements.setUVs(this.uvs.clone());
        elements.jointsPerVertex = this._jointsPerVertex;
        if (this.jointIndices)
            elements.setJointIndices(this.jointIndices.clone());
        if (this.jointWeights)
            elements.setJointWeights(this.jointWeights.clone());
        //return auto derives to cloned values
        elements.autoDeriveNormals = this._autoDeriveNormals = autoDeriveNormals;
        elements.autoDeriveTangents = this._autoDeriveTangents = autoDeriveTangents;
        if (this.slice9Indices) {
            elements.originalSlice9Size = this.originalSlice9Size;
            elements.slice9offsets = this.slice9offsets;
            elements.slice9Indices = this.slice9Indices;
            elements.initialSlice9Positions = this.initialSlice9Positions;
        }
    };
    /**
     * Clones the current object
     * @return An exact duplicate of the current object.
     */
    TriangleElements.prototype.clone = function () {
        var clone = new TriangleElements(this._concatenatedBuffer ? this._concatenatedBuffer.clone() : null);
        this.copyTo(clone);
        return clone;
    };
    TriangleElements.prototype.scaleUV = function (scaleU, scaleV, count, offset) {
        if (scaleU === void 0) { scaleU = 1; }
        if (scaleV === void 0) { scaleV = 1; }
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        if (this.uvs)
            ElementsUtils.scale(scaleU, scaleV, 0, this.uvs, count || this._numVertices, offset);
    };
    /**
     * Scales the geometry.
     * @param scale The amount by which to scale.
     */
    TriangleElements.prototype.scale = function (scale, count, offset) {
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        ElementsUtils.scale(scale, scale, scale, this.positions, count || this._numVertices, offset);
    };
    TriangleElements.prototype.applyTransformation = function (transform, count, offset) {
        if (count === void 0) { count = 0; }
        if (offset === void 0) { offset = 0; }
        ElementsUtils.applyTransformation(transform, this.positions, this.normals, this.tangents, count || this._numVertices, offset);
    };
    /**
     * Updates the tangents for each face.
     */
    TriangleElements.prototype.updateFaceTangents = function () {
        this._faceTangents = ElementsUtils.generateFaceTangents(this.indices, this.positions, this.uvs || this.positions, this._faceTangents, this.numElements);
        this._faceTangentsDirty = false;
    };
    /**
     * Updates the normals for each face.
     */
    TriangleElements.prototype.updateFaceNormals = function () {
        this._faceNormals = ElementsUtils.generateFaceNormals(this.indices, this.positions, this._faceNormals, this.numElements);
        this._faceNormalsDirty = false;
    };
    return TriangleElements;
}(ElementsBase));
TriangleElements.isIE = !!navigator.userAgent.match(/Trident/g) || !!navigator.userAgent.match(/MSIE/g);
TriangleElements.traverseName = TraverserBase.addRenderableName("applyTriangleShape");
TriangleElements.assetType = "[asset TriangleElements]";

/**
 * Defines the values to use for specifying path-drawing commands.
 * The values in this class are used by the Graphics.drawPath() method,
 *or stored in the commands vector of a GraphicsPath object.
 */
var GraphicsPathCommand = (function () {
    function GraphicsPathCommand() {
    }
    return GraphicsPathCommand;
}());
/**
 * Represents the default "do nothing" command.
 */
GraphicsPathCommand.NO_OP = 0;
/**
 * Specifies a drawing command that moves the current drawing position
 * to the x- and y-coordinates specified in the data vector.
 */
GraphicsPathCommand.MOVE_TO = 1;
/**
 * Specifies a drawing command that draws a line from the current drawing position
 * to the x- and y-coordinates specified in the data vector.
 */
GraphicsPathCommand.LINE_TO = 2;
/**
 *  Specifies a drawing command that draws a curve from the current drawing position
 *  to the x- and y-coordinates specified in the data vector, using a control point.
 */
GraphicsPathCommand.CURVE_TO = 3;
/**
 *  Specifies a drawing command that draws a curve from the current drawing position
 *  to the x- and y-coordinates specified in the data vector, using a control point.
 */
GraphicsPathCommand.BUILD_JOINT = 13;
GraphicsPathCommand.BUILD_ROUND_JOINT = 14;
/**
 * Specifies a "line to" drawing command,
 * but uses two sets of coordinates (four values) instead of one set.
 */
GraphicsPathCommand.WIDE_LINE_TO = 4;
/**
 *   Specifies a "move to" drawing command,
 *   but uses two sets of coordinates (four values) instead of one set.
 */
GraphicsPathCommand.WIDE_MOVE_TO = 5;
/**
 * Specifies a drawing command that draws a curve from the current drawing position
 * to the x- and y-coordinates specified in the data vector, using 2 control points.
 */
GraphicsPathCommand.CUBIC_CURVE = 6;

/**
 *
 */
var SamplerBase = (function (_super) {
    __extends(SamplerBase, _super);
    /**
     *
     */
    function SamplerBase(smooth, mipmap) {
        if (smooth === void 0) { smooth = false; }
        if (mipmap === void 0) { mipmap = false; }
        var _this = _super.call(this) || this;
        _this._smooth = smooth;
        _this._mipmap = mipmap;
        return _this;
    }
    Object.defineProperty(SamplerBase.prototype, "smooth", {
        /**
         *
         */
        get: function () {
            return this._smooth;
        },
        set: function (value) {
            if (this._smooth == value)
                return;
            this._smooth = value;
            //TODO: update dependencies
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SamplerBase.prototype, "mipmap", {
        /**
         *
         */
        get: function () {
            return this._mipmap;
        },
        set: function (value) {
            if (this._mipmap == value)
                return;
            this._mipmap = value;
            //TODO: update dependencies
        },
        enumerable: true,
        configurable: true
    });
    return SamplerBase;
}(_awayjs_core.AssetBase));

/**
 * The Sampler2D export class represents display objects that represent bitmap images.
 * These can be images that you load with the <code>flash.Assets</code> or
 * <code>flash.display.Loader</code> classes, or they can be images that you
 * create with the <code>Sampler2D()</code> constructor.
 *
 * <p>The <code>Sampler2D()</code> constructor allows you to create a Sampler2D
 * object that contains a reference to a Image2D object. After you create a
 * Sampler2D object, use the <code>addChild()</code> or <code>addChildAt()</code>
 * method of the parent DisplayObjectContainer instance to place the bitmap on
 * the display list.</p>
 *
 * <p>A Sampler2D object can share its Image2D reference among several Sampler2D
 * objects, independent of translation or rotation properties. Because you can
 * create multiple Sampler2D objects that reference the same Image2D object,
 * multiple texture objects can use the same complex Image2D object without
 * incurring the memory overhead of a Image2D object for each texture
 * object instance.</p>

 */
var Sampler2D = (function (_super) {
    __extends(Sampler2D, _super);
    /**
     *
     * @param image2D
     * @param smoothing
     */
    function Sampler2D(repeat, smooth, mipmap) {
        if (repeat === void 0) { repeat = false; }
        if (smooth === void 0) { smooth = false; }
        if (mipmap === void 0) { mipmap = false; }
        var _this = _super.call(this, smooth, mipmap) || this;
        _this._repeat = repeat;
        _this._updateRect();
        return _this;
    }
    Object.defineProperty(Sampler2D.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Sampler2D.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sampler2D.prototype, "repeat", {
        /**
         * Controls whether or not the Sampler2D object is snapped to the nearest pixel.
         * This value is ignored in the native and HTML5 targets.
         * The PixelSnapping export class includes possible values:
         * <ul>
         *   <li><code>PixelSnapping.NEVER</code> - No pixel snapping occurs.</li>
         *   <li><code>PixelSnapping.ALWAYS</code> - The image is always snapped to
         * the nearest pixel, independent of transformation.</li>
         *   <li><code>PixelSnapping.AUTO</code> - The image is snapped to the
         * nearest pixel if it is drawn with no rotation or skew and it is drawn at a
         * scale factor of 99.9% to 100.1%. If these conditions are satisfied, the
         * bitmap image is drawn at 100% scale, snapped to the nearest pixel.
         * When targeting Flash Player, this value allows the image to be drawn as fast
         * as possible using the internal vector renderer.</li>
         * </ul>
         */
        //var pixelSnapping:PixelSnapping;
        /**
         * Controls whether or not the bitmap is smoothed when scaled. If
         * <code>true</code>, the bitmap is smoothed when scaled. If
         * <code>false</code>, the bitmap is not smoothed when scaled.
         */
        /**
         *
         */
        get: function () {
            return this._repeat;
        },
        set: function (value) {
            if (this._repeat == value)
                return;
            this._repeat = value;
            //TODO: update dependencies
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sampler2D.prototype, "imageRect", {
        /**
         *
         */
        get: function () {
            return this._imageRect;
        },
        set: function (value) {
            if (this._imageRect == value)
                return;
            this._imageRect = value;
            this._updateRect();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sampler2D.prototype, "frameRect", {
        /**
         *
         */
        get: function () {
            return this._frameRect;
        },
        set: function (value) {
            if (this._frameRect == value)
                return;
            this._frameRect = value;
            this._updateRect();
        },
        enumerable: true,
        configurable: true
    });
    Sampler2D.prototype._updateRect = function () {
    };
    return Sampler2D;
}(SamplerBase));
Sampler2D.assetType = "[asset Sampler2D]";

/**
 * The GraphicsPathWinding class provides values for the
 * <code>flash.display.GraphicsPath.winding</code> property and the
 * <code>flash.display.Graphics.drawPath()</code> method to determine the
 * direction to draw a path. A clockwise path is positively wound, and a
 * counter-clockwise path is negatively wound:
 *
 * <p> When paths intersect or overlap, the winding direction determines the
 * rules for filling the areas created by the intersection or overlap:</p>
 */
var GraphicsPathWinding = (function () {
    function GraphicsPathWinding() {
    }
    return GraphicsPathWinding;
}());
GraphicsPathWinding.EVEN_ODD = "evenOdd";
GraphicsPathWinding.NON_ZERO = "nonZero";

/**
 * The JointStyle class is an enumeration of constant values that specify the
 * joint style to use in drawing lines. These constants are provided for use
 * as values in the <code>joints</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method. The method supports
 * three types of joints: miter, round, and bevel, as the following example
 * shows:
 */
var JointStyle = (function () {
    function JointStyle() {
    }
    return JointStyle;
}());
/**
 * Specifies beveled joints in the <code>joints</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method.
 */
JointStyle.BEVEL = 2;
/**
 * Specifies mitered joints in the <code>joints</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method.
 */
JointStyle.MITER = 0;
/**
 * Specifies round joints in the <code>joints</code> parameter of the
 * <code>flash.display.Graphics.lineStyle()</code> method.
 */
JointStyle.ROUND = 1;

var GraphicsStrokeStyle = (function () {
    function GraphicsStrokeStyle(color, alpha, thickness, jointstyle, capstyle, miter_limit) {
        if (color === void 0) { color = 0xffffff; }
        if (alpha === void 0) { alpha = 1; }
        if (thickness === void 0) { thickness = 10; }
        if (jointstyle === void 0) { jointstyle = JointStyle.ROUND; }
        if (capstyle === void 0) { capstyle = CapsStyle.SQUARE; }
        if (miter_limit === void 0) { miter_limit = 10; }
        this._color = color;
        this._alpha = alpha;
        this._thickness = thickness;
        this._jointstyle = jointstyle;
        this._capstyle = capstyle;
        this._miter_limit = miter_limit;
    }
    Object.defineProperty(GraphicsStrokeStyle.prototype, "data_type", {
        get: function () {
            return GraphicsStrokeStyle.data_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsStrokeStyle.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsStrokeStyle.prototype, "alpha", {
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            this._alpha = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsStrokeStyle.prototype, "half_thickness", {
        get: function () {
            return this._thickness / 2;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsStrokeStyle.prototype, "thickness", {
        get: function () {
            return this._thickness;
        },
        set: function (value) {
            this._thickness = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsStrokeStyle.prototype, "jointstyle", {
        get: function () {
            return this._jointstyle;
        },
        set: function (value) {
            this._jointstyle = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsStrokeStyle.prototype, "miter_limit", {
        get: function () {
            return this._miter_limit;
        },
        set: function (value) {
            this._miter_limit = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsStrokeStyle.prototype, "capstyle", {
        get: function () {
            return this._capstyle;
        },
        set: function (value) {
            this._capstyle = value;
        },
        enumerable: true,
        configurable: true
    });
    return GraphicsStrokeStyle;
}());
GraphicsStrokeStyle.data_type = "[graphicsdata StrokeStyle]";

/**

 * Defines the values to use for specifying path-drawing commands.
 * The values in this class are used by the Graphics.drawPath() method,
 *or stored in the commands vector of a GraphicsPath object.
 */
var GraphicsPath = (function () {
    function GraphicsPath(commands, data, winding_rule) {
        if (commands === void 0) { commands = null; }
        if (data === void 0) { data = null; }
        if (winding_rule === void 0) { winding_rule = GraphicsPathWinding.EVEN_ODD; }
        this.forceClose = false;
        this._data = [];
        this._commands = [];
        this._style = null;
        this.verts = [];
        this._positions = [];
        this._newCommands = [];
        if (commands != null && data != null) {
            this._data[0] = data;
            this._commands[0] = commands;
        }
        else {
            this._data[0] = [];
            this._commands[0] = [];
        }
        this._startPoint = new _awayjs_core.Point();
        this._cur_point = new _awayjs_core.Point();
        this._winding_rule = winding_rule;
        this._winding_directions = [];
    }
    Object.defineProperty(GraphicsPath.prototype, "data_type", {
        get: function () {
            return GraphicsPath.data_type;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsPath.prototype, "style", {
        get: function () {
            return this._style;
        },
        set: function (value) {
            this._style = value;
        },
        enumerable: true,
        configurable: true
    });
    GraphicsPath.prototype.fill = function () {
        if (this._style == null)
            return null;
        if (this._style.data_type == GraphicsFillStyle.data_type)
            return this._style;
        return null;
    };
    GraphicsPath.prototype.stroke = function () {
        if (this._style == null)
            return null;
        if (this._style.data_type == GraphicsStrokeStyle.data_type)
            return this._style;
        return null;
    };
    Object.defineProperty(GraphicsPath.prototype, "commands", {
        get: function () {
            return this._commands;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GraphicsPath.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    GraphicsPath.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
        // if controlpoint and anchor are same, we add lineTo command
        if ((controlX == anchorX) && (controlY == anchorY)) {
            this.lineTo(controlX, controlY);
            this.moveTo(anchorX, anchorY);
            return;
        }
        // if anchor is current point, but controlpoint is different, we lineto controlpoint
        if (((this._cur_point.x == anchorX) && (this._cur_point.y == anchorY)) && ((this._cur_point.x != controlX) || (this._cur_point.y != controlY))) {
            this.lineTo(controlX, controlY);
            this.moveTo(anchorX, anchorY);
            return;
        }
        // if controlpoint is current point, but anchor is different, we lineto anchor
        if (((this._cur_point.x != anchorX) || (this._cur_point.y != anchorY)) && ((this._cur_point.x == controlX) && (this._cur_point.y == controlY))) {
            this.lineTo(anchorX, anchorY);
            return;
        }
        // if controlpoint and anchor are same as current point
        if (((this._cur_point.x == anchorX) && (this._cur_point.y == anchorY)) && ((this._cur_point.x == controlX) && (this._cur_point.y == controlY))) {
            //console.log("curveTo command not added because startpoint and endpoint are the same.");
            this.lineTo(anchorX, anchorY);
            return;
        }
        if (this._commands[this._commands.length - 1].length == 0) {
            // every contour must start with a moveTo command, so we make sure we have correct startpoint
            this._commands[this._commands.length - 1].push(GraphicsPathCommand.MOVE_TO);
            this._data[this._data.length - 1].push(this._cur_point.x);
            this._data[this._data.length - 1].push(this._cur_point.y);
        }
        this._commands[this._commands.length - 1].push(GraphicsPathCommand.CURVE_TO);
        this._data[this._data.length - 1].push(controlX);
        this._data[this._data.length - 1].push(controlY);
        this._data[this._data.length - 1].push(anchorX);
        this._data[this._data.length - 1].push(anchorY);
        this._cur_point.x = anchorX;
        this._cur_point.y = anchorY;
    };
    GraphicsPath.prototype.cubicCurveTo = function (controlX, controlY, control2X, control2Y, anchorX, anchorY) {
        console.log("cubicCurveTo not yet fully supported.");
        if ((this._cur_point.x == anchorX) && (this._cur_point.y == anchorY)) {
            //console.log("curveTo command not added because startpoint and endpoint are the same.");
            return;
        }
        if (this._commands[this._commands.length - 1].length == 0) {
            // every contour must start with a moveTo command, so we make sure we have correct startpoint
            this._commands[this._commands.length - 1].push(GraphicsPathCommand.MOVE_TO);
            this._data[this._data.length - 1].push(this._cur_point.x);
            this._data[this._data.length - 1].push(this._cur_point.y);
        }
        this._commands[this._commands.length - 1].push(GraphicsPathCommand.CURVE_TO);
        this._data[this._data.length - 1].push(controlX);
        this._data[this._data.length - 1].push(controlY);
        this._data[this._data.length - 1].push(anchorX);
        this._data[this._data.length - 1].push(anchorY);
        this._cur_point.x = anchorX;
        this._cur_point.y = anchorY;
    };
    GraphicsPath.prototype.lineTo = function (x, y) {
        if ((this._cur_point.x == x) && (this._cur_point.y == y)) {
            //console.log("lineTo command not added because startpoint and endpoint are the same.");
            return;
        }
        if (this._commands[this._commands.length - 1].length == 0) {
            // every contour must start with a moveTo command, so we make sure we have correct startpoint
            this._commands[this._commands.length - 1].push(GraphicsPathCommand.MOVE_TO);
            this._data[this._data.length - 1].push(this._cur_point.x);
            this._data[this._data.length - 1].push(this._cur_point.y);
        }
        this._commands[this._commands.length - 1].push(GraphicsPathCommand.LINE_TO);
        this._data[this._data.length - 1].push(x);
        this._data[this._data.length - 1].push(y);
        this._cur_point.x = x;
        this._cur_point.y = y;
    };
    GraphicsPath.prototype.moveTo = function (x, y) {
        if ((this._cur_point.x == x) && (this._cur_point.y == y)) {
            //console.log("moveTo command not added because startpoint and endpoint are the same.");
            return;
        }
        // whenever a moveTo command apears, we start a new contour
        if (this._commands[this._commands.length - 1].length > 0) {
            this._commands.push([GraphicsPathCommand.MOVE_TO]);
            this._data.push([x, y]);
        }
        this._startPoint.x = x;
        this._startPoint.y = y;
        this._cur_point.x = x;
        this._cur_point.y = y;
    };
    GraphicsPath.prototype.wideLineTo = function (x, y) {
        // not used
        /*
         this._commands.push(GraphicsPathCommand.WIDE_LINE_TO);
         this._data.push(0);
         this._data.push(0);
         this._data.push(x);
         this._data.push(y);
         */
    };
    GraphicsPath.prototype.wideMoveTo = function (x, y) {
        // not used
        /*
         this._commands.push(GraphicsPathCommand.WIDE_MOVE_TO);
         this._data.push(0);
         this._data.push(0);
         this._data.push(x);
         this._data.push(y);
         */
    };
    GraphicsPath.prototype.prepare = function () {
        var new_dir;
        var dir_delta;
        var last_direction;
        var closed;
        var tmp_dir_point = new _awayjs_core.Point();
        var prev_dir_vec = new _awayjs_core.Point();
        var prev_point = new _awayjs_core.Point();
        var end_point = new _awayjs_core.Point();
        var commands;
        var data;
        var c, i = 0;
        var cmd_len = this.commands.length;
        for (c = 0; c < cmd_len; c++) {
            commands = this.commands[c];
            data = this.data[c];
            new_dir = 0;
            dir_delta = 0;
            last_direction = 0;
            tmp_dir_point.x = 0;
            tmp_dir_point.y = 0;
            prev_dir_vec.x = 0;
            prev_dir_vec.y = 0;
            this._positions[c] = [];
            this._newCommands[c] = [];
            // check if the path is closed. 
            // if its not closed, we optionally close it by adding the extra lineTo-cmd
            closed = true;
            if ((data[0] != data[data.length - 2]) || (data[1] != data[data.length - 1])) {
                if (this.forceClose) {
                    commands[commands.length] = GraphicsPathCommand.LINE_TO;
                    data[data.length] = data[0];
                    data[data.length] = data[1];
                }
                else {
                    closed = false;
                }
            }
            // if the path is closed, we init the prevDirection with the last segments direction
            if (closed) {
                //console.log("path is closed");
                prev_dir_vec.x = data[data.length - 2] - data[data.length - 4];
                prev_dir_vec.y = data[data.length - 1] - data[data.length - 3];
                prev_dir_vec.normalize();
                last_direction = Math.atan2(prev_dir_vec.y, prev_dir_vec.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
            }
            else {
            }
            var data_cnt = 0;
            prev_point.x = data[data_cnt++];
            prev_point.y = data[data_cnt++];
            var prev_x = prev_point.x;
            var prev_y = prev_point.y;
            this._positions[c].push(prev_point.x);
            this._positions[c].push(prev_point.y);
            this._newCommands[c].push(GraphicsPathCommand.MOVE_TO);
            var ctr_point = new _awayjs_core.Point();
            for (i = 1; i < commands.length; i++) {
                switch (commands[i]) {
                    case GraphicsPathCommand.MOVE_TO:
                        console.log("ERROR ! ONLY THE FIRST COMMAND FOR A CONTOUR IS ALLOWED TO BE A 'MOVE_TO' COMMAND");
                        break;
                    case GraphicsPathCommand.LINE_TO:
                        end_point = new _awayjs_core.Point(data[data_cnt++], data[data_cnt++]);
                        // console.log("LINE_TO ", i, end_point.x, end_point.y);
                        this._positions[c].push(end_point.x);
                        this._positions[c].push(end_point.y);
                        this._newCommands[c].push(GraphicsPathCommand.LINE_TO);
                        prev_x = end_point.x;
                        prev_y = end_point.y;
                        break;
                    case GraphicsPathCommand.CURVE_TO:
                        end_point = new _awayjs_core.Point(data[data_cnt++], data[data_cnt++]);
                        ctr_point = new _awayjs_core.Point(data[data_cnt++], data[data_cnt++]);
                        //console.log("CURVE_TO ", i, ctr_point.x, ctr_point.y, end_point.x, end_point.y);
                        var curve_verts = [];
                        GraphicsFactoryHelper.tesselateCurve(prev_x, prev_y, ctr_point.x, ctr_point.y, end_point.x, end_point.y, curve_verts);
                        var k_len = curve_verts.length;
                        var k = 0;
                        for (k = 0; k < k_len; k += 2) {
                            var newPoint = new _awayjs_core.Point(curve_verts[k], curve_verts[k + 1]);
                            // console.log("tesselated curve to ", k, newPoint.x, newPoint.y);
                            this._newCommands[c].push(GraphicsPathCommand.LINE_TO);
                            this._positions[c].push(newPoint.x);
                            this._positions[c].push(newPoint.y);
                        }
                        prev_x = end_point.x;
                        prev_y = end_point.y;
                        break;
                }
            }
        }
    };
    return GraphicsPath;
}());
GraphicsPath.data_type = "[graphicsdata path]";

/**
 * The LineScaleMode class provides values for the <code>scaleMode</code>
 * parameter in the <code>Graphics.lineStyle()</code> method.
 */
var LineScaleMode = (function () {
    function LineScaleMode() {
    }
    return LineScaleMode;
}());
/**
 * With this setting used as the <code>scaleMode</code> parameter of the
 * <code>lineStyle()</code> method, the thickness of the line scales
 * <i>only</i> vertically. For example, consider the following circles, drawn
 * with a one-pixel line, and each with the <code>scaleMode</code> parameter
 * set to <code>LineScaleMode.VERTICAL</code>. The circle on the left is
 * scaled only vertically, and the circle on the right is scaled both
 * vertically and horizontally.
 */
LineScaleMode.HORIZONTAL = "horizontal";
/**
 * With this setting used as the <code>scaleMode</code> parameter of the
 * <code>lineStyle()</code> method, the thickness of the line never scales.
 */
LineScaleMode.NONE = "none";
/**
 * With this setting used as the <code>scaleMode</code> parameter of the
 * <code>lineStyle()</code> method, the thickness of the line always scales
 * when the object is scaled(the default).
 */
LineScaleMode.NORMAL = "normal";
/**
 * With this setting used as the <code>scaleMode</code> parameter of the
 * <code>lineStyle()</code> method, the thickness of the line scales
 * <i>only</i> horizontally. For example, consider the following circles,
 * drawn with a one-pixel line, and each with the <code>scaleMode</code>
 * parameter set to <code>LineScaleMode.HORIZONTAL</code>. The circle on the
 * left is scaled only horizontally, and the circle on the right is scaled
 * both vertically and horizontally.
 */
LineScaleMode.VERTICAL = "vertical";

/**
 * The Graphics class contains a set of methods that you can use to create a
 * vector shape. Display objects that support drawing include Sprite and Shape
 * objects. Each of these classes includes a <code>graphics</code> property
 * that is a Graphics object. The following are among those helper functions
 * provided for ease of use: <code>drawRect()</code>,
 * <code>drawRoundRect()</code>, <code>drawCircle()</code>, and
 * <code>drawEllipse()</code>.
 *
 * <p>You cannot create a Graphics object directly from ActionScript code. If
 * you call <code>new Graphics()</code>, an exception is thrown.</p>
 *
 * <p>The Graphics class is final; it cannot be subclassed.</p>
 */
var GraphicsFactoryStrokes = (function () {
    function GraphicsFactoryStrokes() {
    }
    GraphicsFactoryStrokes.draw_pathes = function (targetGraphics) {
        var len = targetGraphics.queued_stroke_pathes.length;
        var i = 0;
        for (i = 0; i < len; i++) {
            var strokePath = targetGraphics.queued_stroke_pathes[i];
            var strokeStyle = strokePath.style;
            var obj = Graphics.get_material_for_color(strokeStyle.color, strokeStyle.alpha);
            var material = obj.material;
            var final_vert_list = [];
            strokePath.prepare();
            GraphicsFactoryStrokes.draw_path([strokePath], final_vert_list, material.curves);
            final_vert_list = final_vert_list.concat(strokePath.verts);
            var attributesView = new _awayjs_core.AttributesView(Float32Array, material.curves ? 3 : 2);
            attributesView.set(final_vert_list);
            var attributesBuffer = attributesView.attributesBuffer;
            attributesView.dispose();
            var elements = new TriangleElements(attributesBuffer);
            elements.setPositions(new _awayjs_core.Float2Attributes(attributesBuffer));
            elements.halfStrokeThickness = strokeStyle.half_thickness;
            //	if(material.curves)
            //		elements.setCustomAttributes("curves", new Byte4Attributes(attributesBuffer, false));
            //	material.alpha=(<GraphicsStrokeStyle>this.queued_stroke_pathes[i].style).alpha;
            var shape = targetGraphics.addShape(Shape.getShape(elements, material));
            shape.isStroke = true;
            shape.strokePath = strokePath;
            shape.elements;
            if (obj.colorPos) {
                shape.style = new Style();
                var sampler = new Sampler2D();
                material.animateUVs = true;
                shape.style.addSamplerAt(sampler, material.getTextureAt(0));
                shape.style.uvMatrix = new _awayjs_core.Matrix(0, 0, 0, 0, obj.colorPos.x, obj.colorPos.y);
            }
        }
        targetGraphics.queued_stroke_pathes.length = 0;
        /*
                var len=graphic_pathes.length;
                var one_path:GraphicsPath;
                var cp, i=0;
                for(cp=0; cp<len; cp++) {
                    one_path = graphic_pathes[cp];
                    one_path.prepare();
                    for (i = 0; i < one_path._positions[cp].length; i+=2) {
                        GraphicsFactoryHelper.drawPoint(one_path._positions[cp][i], one_path._positions[cp][i+1], final_vert_list, false);
                    }
                }
                GraphicsFactoryStrokes.draw_pathes_old(graphic_pathes, final_vert_list, false);
                */
    };
    GraphicsFactoryStrokes.updateStrokesForShape = function (shape, scale, scaleMode) {
        var graphicsPath = shape.strokePath;
        var final_vert_list = [];
        GraphicsFactoryStrokes.draw_path([graphicsPath], final_vert_list, false, scale, scaleMode);
        var elements = shape.elements;
        elements.setPositions(final_vert_list);
        elements.invalidate();
    };
    GraphicsFactoryStrokes.draw_path = function (graphic_pathes, final_vert_list, curves, scale, scaleMode) {
        if (scale === void 0) { scale = 1; }
        if (scaleMode === void 0) { scaleMode = LineScaleMode.NORMAL; }
        var len = graphic_pathes.length;
        var contour_commands;
        var contour_data;
        var strokeStyle;
        var one_path;
        var commands;
        var data;
        var i = 0;
        var k = 0;
        var vert_cnt = 0;
        var data_cnt = 0;
        var final_vert_cnt = 0;
        var lastPoint = new _awayjs_core.Point();
        var start_point = new _awayjs_core.Point();
        var end_point = new _awayjs_core.Point();
        var start_left = new _awayjs_core.Point();
        var start_right = new _awayjs_core.Point();
        var ctr_left = new _awayjs_core.Point();
        var ctr_right = new _awayjs_core.Point();
        var ctr_left2 = new _awayjs_core.Point();
        var ctr_right2 = new _awayjs_core.Point();
        var end_left = new _awayjs_core.Point();
        var end_right = new _awayjs_core.Point();
        var tmp_point = new _awayjs_core.Point();
        var tmp_point2 = new _awayjs_core.Point();
        var tmp_point3 = new _awayjs_core.Point();
        var closed = false;
        var last_dir_vec = new _awayjs_core.Point();
        var cp = 0;
        for (cp = 0; cp < len; cp++) {
            one_path = graphic_pathes[cp];
            contour_commands = one_path._newCommands;
            contour_data = one_path._positions;
            strokeStyle = one_path.stroke();
            var half_thickness = strokeStyle.half_thickness;
            if (scaleMode == LineScaleMode.NORMAL) {
                if (half_thickness != 0.15) {
                    var minScale = 0.5;
                    if (scale < 1) {
                        minScale = 0.5;
                    }
                    if ((half_thickness * scale) < minScale) {
                        half_thickness = minScale * (1 / scale);
                    }
                }
            }
            else if (scaleMode == LineScaleMode.NONE) {
                half_thickness *= (1 / scale);
            }
            for (k = 0; k < contour_commands.length; k++) {
                commands = contour_commands[k];
                data = contour_data[k];
                vert_cnt = 0;
                data_cnt = 0;
                var new_dir = 0;
                var dir_delta = 0;
                var last_direction = 0;
                var tmp_dir_point = new _awayjs_core.Point();
                // check if the path is closed. if yes, than set the last_dir_vec from last segment
                closed = true;
                if ((data[0] != data[data.length - 2]) || (data[1] != data[data.length - 1]))
                    closed = false;
                else {
                    last_dir_vec.x = data[data.length - 2] - data[data.length - 4];
                    last_dir_vec.y = data[data.length - 1] - data[data.length - 3];
                    last_dir_vec.normalize();
                    last_direction = Math.atan2(last_dir_vec.y, last_dir_vec.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                }
                data_cnt = 0;
                lastPoint.x = data[data_cnt++];
                lastPoint.y = data[data_cnt++];
                var new_cmds = [];
                var new_pnts = [];
                var new_cmds_cnt = 0;
                var new_pnts_cnt = 0;
                var prev_normal = new _awayjs_core.Point();
                var le_point = new _awayjs_core.Point();
                var curve_end_point = new _awayjs_core.Point();
                var ri_point = new _awayjs_core.Point();
                var ctr_point = new _awayjs_core.Point();
                prev_normal.x = -1 * last_dir_vec.y;
                prev_normal.y = last_dir_vec.x;
                for (i = 1; i < commands.length; i++) {
                    if (commands[i] == GraphicsPathCommand.MOVE_TO) {
                        console.log("ERROR ! ONLY THE FIRST COMMAND FOR A CONTOUR IS ALLOWED TO BE A 'MOVE_TO' COMMAND");
                        continue;
                    }
                    //console.log("");
                    //console.log("segment "+i+"lastPoint x = "+lastPoint.x+" y = "+lastPoint.y)
                    end_point = new _awayjs_core.Point(data[data_cnt++], data[data_cnt++]);
                    //console.log("segment "+i+"end_point x = "+end_point.x+" y = "+end_point.y)
                    if (commands[i] == GraphicsPathCommand.CURVE_TO) {
                        curve_end_point = new _awayjs_core.Point(data[data_cnt++], data[data_cnt++]);
                    }
                    if ((end_point.x != lastPoint.x) || (end_point.y != lastPoint.y)) {
                        //get the directional vector and the direction for this segment
                        tmp_dir_point.x = end_point.x - lastPoint.x;
                        tmp_dir_point.y = end_point.y - lastPoint.y;
                        tmp_dir_point.normalize();
                        new_dir = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                        // get the difference in angle to the last segment
                        dir_delta = new_dir - last_direction;
                        if (dir_delta > 180) {
                            dir_delta -= 360;
                        }
                        if (dir_delta < -180) {
                            dir_delta += 360;
                        }
                        //console.log("DIRECTION DELTA: "+dir_delta);
                        last_direction = new_dir;
                        //console.log("segment "+i+" direction: "+dir_delta);
                        // rotate direction around 90 degree
                        tmp_point.x = -1 * tmp_dir_point.y;
                        tmp_point.y = tmp_dir_point.x;
                        ri_point = new _awayjs_core.Point(lastPoint.x + (tmp_point.x * half_thickness), lastPoint.y + (tmp_point.y * half_thickness));
                        le_point = new _awayjs_core.Point(lastPoint.x - (tmp_point.x * half_thickness), lastPoint.y - (tmp_point.y * half_thickness));
                        var add_segment = false;
                        // check if this is the first segment, and the path is not closed
                        // in this case, we can just set the points to the contour points
                        if ((i == 1) && (!closed)) {
                            //console.log("segment "+i+"Path is not closed, we can just add the first segment")
                            add_segment = true;
                        }
                        else {
                            // we need to figure out if we need to add a joint or not
                            if ((dir_delta == 0) || (dir_delta == 180)) {
                                // check if this and the prev segment was a line. if yes, than they can be merged
                                if ((i != 1) && (commands[i] == GraphicsPathCommand.LINE_TO) && (new_cmds[new_cmds.length - 1] == GraphicsPathCommand.LINE_TO)) {
                                    //console.log("straight line can be merged in prev straight line");
                                    add_segment = false;
                                }
                                else {
                                    add_segment = true;
                                }
                            }
                            if (Math.abs(dir_delta) >= 179.9997 && Math.abs(dir_delta) <= 180.0003) {
                                add_segment = true;
                            }
                            else if (dir_delta != 0) {
                                add_segment = true;
                                var half_angle = (180 - (dir_delta));
                                if (dir_delta < 0) {
                                    half_angle = (-180 - (dir_delta));
                                }
                                half_angle = half_angle * -0.5 * _awayjs_core.MathConsts.DEGREES_TO_RADIANS;
                                var distance = half_thickness / Math.sin(half_angle);
                                tmp_point2.x = tmp_dir_point.x * Math.cos(half_angle) + tmp_dir_point.y * Math.sin(half_angle);
                                tmp_point2.y = tmp_dir_point.y * Math.cos(half_angle) - tmp_dir_point.x * Math.sin(half_angle);
                                tmp_point2.normalize();
                                var merged_pnt_ri = new _awayjs_core.Point(lastPoint.x - (tmp_point2.x * distance), lastPoint.y - (tmp_point2.y * distance));
                                var merged_pnt_le = new _awayjs_core.Point(lastPoint.x + (tmp_point2.x * distance), lastPoint.y + (tmp_point2.y * distance));
                                if (dir_delta > 0) {
                                    ri_point = merged_pnt_ri;
                                    var contour_le = new _awayjs_core.Point(lastPoint.x - (tmp_point.x * half_thickness), lastPoint.y - (tmp_point.y * half_thickness));
                                    var contour_prev_le = new _awayjs_core.Point(lastPoint.x - (prev_normal.x * half_thickness), lastPoint.y - (prev_normal.y * half_thickness));
                                    le_point = contour_le;
                                }
                                else {
                                    le_point = merged_pnt_le;
                                    var contour_ri = new _awayjs_core.Point(lastPoint.x + (tmp_point.x * half_thickness), lastPoint.y + (tmp_point.y * half_thickness));
                                    var contour_prev_ri = new _awayjs_core.Point(lastPoint.x + (prev_normal.x * half_thickness), lastPoint.y + (prev_normal.y * half_thickness));
                                    ri_point = contour_ri;
                                }
                                var addJoints = true;
                                if (strokeStyle.jointstyle == JointStyle.MITER) {
                                    var distance_miter = (Math.sqrt((distance * distance) - (half_thickness * half_thickness)) / half_thickness);
                                    if (distance_miter <= strokeStyle.miter_limit) {
                                        addJoints = false;
                                        ri_point = merged_pnt_ri;
                                        le_point = merged_pnt_le;
                                    }
                                    else {
                                        if (dir_delta > 0) {
                                            contour_le.x = contour_le.x - (tmp_dir_point.x * (strokeStyle.miter_limit * half_thickness));
                                            contour_le.y = contour_le.y - (tmp_dir_point.y * (strokeStyle.miter_limit * half_thickness));
                                            tmp_point3.x = prev_normal.y * -1;
                                            tmp_point3.y = prev_normal.x;
                                            contour_prev_le.x = contour_prev_le.x - (tmp_point3.x * (strokeStyle.miter_limit * half_thickness));
                                            contour_prev_le.y = contour_prev_le.y - (tmp_point3.y * (strokeStyle.miter_limit * half_thickness));
                                        }
                                        else {
                                            contour_ri.x = contour_ri.x - (tmp_dir_point.x * (strokeStyle.miter_limit * half_thickness));
                                            contour_ri.y = contour_ri.y - (tmp_dir_point.y * (strokeStyle.miter_limit * half_thickness));
                                            tmp_point3.x = prev_normal.y * -1;
                                            tmp_point3.y = prev_normal.x;
                                            contour_prev_ri.x = contour_prev_ri.x - (tmp_point3.x * (strokeStyle.miter_limit * half_thickness));
                                            contour_prev_ri.y = contour_prev_ri.y - (tmp_point3.y * (strokeStyle.miter_limit * half_thickness));
                                        }
                                    }
                                }
                                if (addJoints) {
                                    new_cmds[new_cmds_cnt++] = (strokeStyle.jointstyle != JointStyle.ROUND) ? GraphicsPathCommand.BUILD_JOINT : GraphicsPathCommand.BUILD_ROUND_JOINT;
                                    if (dir_delta > 0) {
                                        new_pnts[new_pnts_cnt++] = merged_pnt_ri;
                                        new_pnts[new_pnts_cnt++] = contour_prev_le;
                                        new_pnts[new_pnts_cnt++] = contour_le;
                                    }
                                    else {
                                        new_pnts[new_pnts_cnt++] = contour_prev_ri;
                                        new_pnts[new_pnts_cnt++] = merged_pnt_le;
                                        new_pnts[new_pnts_cnt++] = contour_ri;
                                    }
                                    if (strokeStyle.jointstyle == JointStyle.ROUND) {
                                        new_pnts[new_pnts_cnt++] = new _awayjs_core.Point(lastPoint.x - (tmp_point2.x * Math.abs(distance)), lastPoint.y - (tmp_point2.y * Math.abs(distance)));
                                        if (dir_delta > 0) {
                                            new_pnts[new_pnts_cnt++] = contour_prev_le;
                                            new_pnts[new_pnts_cnt++] = contour_le;
                                        }
                                        else {
                                            new_pnts[new_pnts_cnt++] = contour_prev_ri;
                                            new_pnts[new_pnts_cnt++] = contour_ri;
                                        }
                                    }
                                }
                            }
                        }
                        prev_normal.x = tmp_point.x;
                        prev_normal.y = tmp_point.y;
                        if (add_segment) {
                            if (commands[i] == GraphicsPathCommand.LINE_TO) {
                                new_cmds[new_cmds_cnt++] = GraphicsPathCommand.LINE_TO;
                                new_pnts[new_pnts_cnt++] = ri_point;
                                new_pnts[new_pnts_cnt++] = le_point;
                            }
                            else if (commands[i] == GraphicsPathCommand.CURVE_TO) {
                                tmp_dir_point.x = curve_end_point.x - end_point.x;
                                tmp_dir_point.y = curve_end_point.y - end_point.y;
                                tmp_dir_point.normalize();
                                new_dir = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                                dir_delta = new_dir - last_direction;
                                last_direction = new_dir;
                                tmp_point.x = -1 * tmp_dir_point.y;
                                tmp_point.y = tmp_dir_point.x;
                                if ((dir_delta != 0) && (dir_delta != 180)) {
                                    new_cmds[new_cmds_cnt++] = GraphicsPathCommand.CURVE_TO;
                                    new_pnts[new_pnts_cnt++] = ri_point;
                                    new_pnts[new_pnts_cnt++] = le_point;
                                    new_pnts[new_pnts_cnt++] = new _awayjs_core.Point(lastPoint.x, lastPoint.y);
                                    new_pnts[new_pnts_cnt++] = new _awayjs_core.Point(end_point.x, end_point.y);
                                    new_pnts[new_pnts_cnt++] = curve_end_point;
                                }
                                else {
                                    new_cmds[new_cmds_cnt++] = GraphicsPathCommand.LINE_TO;
                                    new_pnts[new_pnts_cnt++] = ri_point;
                                    new_pnts[new_pnts_cnt++] = le_point;
                                }
                                prev_normal.x = tmp_point.x;
                                prev_normal.y = tmp_point.y;
                                lastPoint = curve_end_point;
                            }
                        }
                        if (commands[i] == GraphicsPathCommand.LINE_TO) {
                            lastPoint = end_point;
                        }
                        if (i == commands.length - 1) {
                            if (!closed) {
                                new_cmds[new_cmds_cnt++] = GraphicsPathCommand.NO_OP;
                                new_pnts[new_pnts_cnt++] = new _awayjs_core.Point(lastPoint.x + (tmp_point.x * half_thickness), lastPoint.y + (tmp_point.y * half_thickness));
                                new_pnts[new_pnts_cnt++] = new _awayjs_core.Point(lastPoint.x - (tmp_point.x * half_thickness), lastPoint.y - (tmp_point.y * half_thickness));
                            }
                            else {
                                new_cmds[new_cmds_cnt++] = GraphicsPathCommand.NO_OP;
                                new_pnts[new_pnts_cnt++] = new_pnts[0];
                                new_pnts[new_pnts_cnt++] = new_pnts[1];
                            }
                        }
                    }
                }
                // first we draw all the curves:
                new_cmds_cnt = 0;
                new_pnts_cnt = 0;
                for (i = 0; i < new_cmds.length; i++) {
                    if (new_cmds[i] == GraphicsPathCommand.LINE_TO) {
                        new_pnts_cnt += 2;
                    }
                    else if (new_cmds[i] == GraphicsPathCommand.CURVE_TO) {
                        if (curves) {
                            start_right = new_pnts[new_pnts_cnt++];
                            start_left = new_pnts[new_pnts_cnt++];
                            start_point = new_pnts[new_pnts_cnt++];
                            ctr_point = new_pnts[new_pnts_cnt++];
                            end_point = new_pnts[new_pnts_cnt++];
                            end_right = new_pnts[new_pnts_cnt];
                            end_left = new_pnts[new_pnts_cnt + 1];
                            // get the directional vector for the first part of the curve
                            tmp_dir_point.x = ctr_point.x - start_point.x;
                            tmp_dir_point.y = ctr_point.y - start_point.y;
                            tmp_point3.x = ctr_point.x - start_point.x;
                            tmp_point3.y = ctr_point.y - start_point.y;
                            var length1 = tmp_point3.length;
                            tmp_dir_point.normalize();
                            // get the directional vector for the second part of the curve
                            tmp_point2.x = end_point.x - ctr_point.x;
                            tmp_point2.y = end_point.y - ctr_point.y;
                            var length2 = tmp_point2.length;
                            tmp_point2.normalize();
                            var length_calc = 0.5 - ((length2 - length1) / length1) * 0.5;
                            if (length1 > length2) {
                                length_calc = 0.5 + ((length1 - length2) / length2) * 0.5;
                            }
                            // get angle to positive x-axis for both dir-vectors, than get the difference between those
                            var angle_1 = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                            var angle_2 = Math.atan2(tmp_point2.y, tmp_point2.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                            dir_delta = angle_2 - angle_1;
                            if (dir_delta > 180)
                                dir_delta -= 360;
                            if (dir_delta < -180)
                                dir_delta += 360;
                            //var half_angle:number=dir_delta*0.5*MathConsts.DEGREES_TO_RADIANS;
                            //var distance:number=half_thickness / Math.sin(half_angle);
                            //tmp_point3.x = tmp_point2.x * Math.cos(half_angle) + tmp_point2.y * Math.sin(half_angle);
                            //tmp_point3.y = tmp_point2.y * Math.cos(half_angle) - tmp_point2.x * Math.sin(half_angle);
                            //tmp_point3.normalize();
                            //var merged_pnt_ri:Point = new Point(ctr_point.x - (tmp_point3.x * distance), ctr_point.y - (tmp_point3.y * distance));
                            //var merged_pnt_le:Point = new Point(ctr_point.x + (tmp_point3.x * distance), ctr_point.y + (tmp_point3.y * distance));
                            var curve_x = GraphicsFactoryHelper.getQuadricBezierPosition(0.5, start_point.x, ctr_point.x, end_point.x);
                            var curve_y = GraphicsFactoryHelper.getQuadricBezierPosition(0.5, start_point.y, ctr_point.y, end_point.y);
                            var curve_2x = GraphicsFactoryHelper.getQuadricBezierPosition(0.501, start_point.x, ctr_point.x, end_point.x);
                            var curve_2y = GraphicsFactoryHelper.getQuadricBezierPosition(0.501, start_point.y, ctr_point.y, end_point.y);
                            tmp_point3.x = -1 * (curve_y - curve_2y);
                            tmp_point3.y = curve_x - curve_2x;
                            tmp_point3.normalize();
                            //GraphicsFactoryHelper.drawPoint(curve_x,curve_y, final_vert_list);
                            // move the point on the curve to use correct thickness
                            ctr_right.x = curve_x - (tmp_point3.x * half_thickness);
                            ctr_right.y = curve_y - (tmp_point3.y * half_thickness);
                            ctr_left.x = curve_x + (tmp_point3.x * half_thickness);
                            ctr_left.y = curve_y + (tmp_point3.y * half_thickness);
                            //GraphicsFactoryHelper.drawPoint(ctr_right.x, ctr_right.y , final_vert_list);
                            //GraphicsFactoryHelper.drawPoint(ctr_left.x, ctr_left.y , final_vert_list);
                            // calculate the actual controlpoints
                            ctr_right.x = ctr_right.x * 2 - start_right.x / 2 - end_right.x / 2;
                            ctr_right.y = ctr_right.y * 2 - start_right.y / 2 - end_right.y / 2;
                            ctr_left.x = ctr_left.x * 2 - start_left.x / 2 - end_left.x / 2;
                            ctr_left.y = ctr_left.y * 2 - start_left.y / 2 - end_left.y / 2;
                            //ctr_right=merged_pnt_ri;
                            //ctr_left=merged_pnt_le;
                            /*
                             // controlpoints version2:
                             tmp_dir_point.x = start_left.x-start_right.x;
                             tmp_dir_point.y = start_left.y-start_right.y;
                             tmp_point2.x = end_left.x-end_right.x;
                             tmp_point2.y = end_left.y-end_right.y;

                             ctr_right.x = ctr_point.x-(tmp_dir_point.x/2);
                             ctr_right.y = ctr_point.y-(tmp_dir_point.y/2);
                             var new_end_ri:Point = new Point(end_point.x+(tmp_dir_point.x/2), end_point.y+(tmp_dir_point.y/2));

                             ctr_left.x = ctr_point.x+(tmp_dir_point.x/2);
                             ctr_left.y = ctr_point.y+(tmp_dir_point.y/2);
                             var new_end_le:Point = new Point(end_point.x-(tmp_dir_point.x/2), end_point.y-(tmp_dir_point.y/2));

                             */
                            /*
                             tmp_point2.x=ctr_point.x-start_point.x;
                             tmp_point2.y=ctr_point.y-start_point.y;
                             var m1:number=tmp_point2.y/tmp_point2.x;
                             tmp_point2.x=end_point.x-ctr_point.x;
                             tmp_point2.y=end_point.y-ctr_point.y;
                             var m2:number=tmp_point2.y/tmp_point2.x;

                             if(m1==m2){
                             console.log("lines for curve are parallel - this should not be possible!")
                             }
                             if((!isFinite(m1))&&(!isFinite(m2))){
                             console.log("both lines are vertical - this should not be possible!")
                             }
                             else if((isFinite(m1))&&(isFinite(m2))) {
                             var b_r1:number = start_right.y - (m1 * start_right.x);
                             var b_l1:number = start_left.y - (m1 * start_left.x);
                             var b_r2:number = end_right.y - (m2 * end_right.x);
                             var b_l2:number = end_left.y - (m2 * end_left.x);
                             ctr_right.x = (b_r2 - b_r1) / (m1 - m2);
                             ctr_right.y = m1 * ctr_right.x + b_r1;
                             ctr_left.x = (b_l2 - b_l1) / (m1 - m2);
                             ctr_left.y = m1 * ctr_left.x + b_l1;
                             }
                             else if((!isFinite(m1))&&(isFinite(m2))) {
                             console.log("second part of curve is vertical line");
                             var b_r2:number = end_right.y - (m2 * end_right.x);
                             var b_l2:number = end_left.y - (m2 * end_left.x);
                             ctr_right.x =  start_right.x;
                             ctr_right.y = m2 * ctr_right.x + b_r2;
                             ctr_left.x =  start_left.x;
                             ctr_left.y = m2 * ctr_left.x + b_l2;
                             }
                             else if((isFinite(m1))&&(!isFinite(m2))) {
                             console.log("first part of curve is vertical line");
                             var b_r1:number = start_right.y - (m1 * start_right.x);
                             var b_l1:number = start_left.y - (m1 * start_left.x);
                             ctr_right.x =  end_right.x;
                             ctr_right.y = m1 * ctr_right.x + b_r1;
                             ctr_left.x =  end_left.x;
                             ctr_left.y = m1 * ctr_left.x + b_l1;
                             }
                             */
                            /*
                             tmp_point2.x=ctr_right.x-ctr_left.x;
                             tmp_point2.y=ctr_right.y-ctr_left.y;
                             if(tmp_point2.length!=strokeStyle.thickness){

                             tmp_point.x=ctr_left.x+tmp_point2.x*0.5;
                             tmp_point.y=ctr_left.y+tmp_point2.y*0.5;
                             tmp_point2.normalize();
                             ctr_left.x=tmp_point.x-tmp_point2.x*half_thickness;
                             ctr_left.y=tmp_point.y-tmp_point2.y*half_thickness;
                             ctr_right.x=tmp_point.x+tmp_point2.x*half_thickness;
                             ctr_right.y=tmp_point.y+tmp_point2.y*half_thickness;
                             }
                             */
                            //ctr_right=ctr_point;
                            //ctr_left=ctr_point;
                            //console.log(start_point.x);
                            //console.log(start_point.y);
                            //console.log(ctr_point.x);
                            //console.log(ctr_point.y);
                            //console.log(end_point.x);
                            //console.log(end_point.y);
                            var subdivided = [];
                            var subdivided2 = [];
                            GraphicsFactoryHelper.subdivideCurve(start_right.x, start_right.y, ctr_right.x, ctr_right.y, end_right.x, end_right.y, start_left.x, start_left.y, ctr_left.x, ctr_left.y, end_left.x, end_left.y, subdivided, subdivided2);
                            if (dir_delta > 0) {
                                for (var sc = 0; sc < subdivided.length / 6; sc++) {
                                    // right curved
                                    // concave curves:
                                    GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], -128, final_vert_list, curves);
                                    // fills
                                    GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], 0, final_vert_list, curves);
                                    GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], 0, final_vert_list, curves);
                                    GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], 0, final_vert_list, curves);
                                    // convex curves:
                                    GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], 127, final_vert_list, curves);
                                }
                            }
                            else {
                                for (var sc = 0; sc < subdivided.length / 6; sc++) {
                                    // left curved
                                    // convex curves:
                                    GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 2], subdivided[sc * 6 + 3], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], 127, final_vert_list, curves);
                                    // fills
                                    GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], 0, final_vert_list, curves);
                                    GraphicsFactoryHelper.addTriangle(subdivided[sc * 6], subdivided[sc * 6 + 1], subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], 0, final_vert_list, curves);
                                    GraphicsFactoryHelper.addTriangle(subdivided[sc * 6 + 4], subdivided[sc * 6 + 5], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], 0, final_vert_list, curves);
                                    // concave curves:
                                    GraphicsFactoryHelper.addTriangle(subdivided2[sc * 6], subdivided2[sc * 6 + 1], subdivided2[sc * 6 + 2], subdivided2[sc * 6 + 3], subdivided2[sc * 6 + 4], subdivided2[sc * 6 + 5], -128, final_vert_list, curves);
                                }
                            }
                        }
                        else {
                            start_right = new_pnts[new_pnts_cnt++];
                            start_left = new_pnts[new_pnts_cnt++];
                            start_point = new_pnts[new_pnts_cnt++];
                            ctr_point = new_pnts[new_pnts_cnt++];
                            end_point = new_pnts[new_pnts_cnt++];
                            end_right = new_pnts[new_pnts_cnt];
                            end_left = new_pnts[new_pnts_cnt + 1];
                            var curve_verts = [];
                            GraphicsFactoryHelper.tesselateCurve(start_point.x, start_point.y, ctr_point.x, ctr_point.y, end_right.x, end_right.y, curve_verts);
                            var c_cnt = curve_verts.length;
                            while (c_cnt > 0) {
                                c_cnt -= 2;
                            }
                        }
                    }
                    else if (new_cmds[i] >= GraphicsPathCommand.BUILD_JOINT) {
                        new_pnts_cnt += 3;
                        if (new_cmds[i] == GraphicsPathCommand.BUILD_ROUND_JOINT) {
                            end_left = new_pnts[new_pnts_cnt++]; // concave curves:
                            start_right = new_pnts[new_pnts_cnt++];
                            start_left = new_pnts[new_pnts_cnt++];
                            GraphicsFactoryHelper.addTriangle(start_right.x, start_right.y, end_left.x, end_left.y, start_left.x, start_left.y, -1, final_vert_list, curves);
                        }
                    }
                }
                // now we draw all the normal triangles.
                // we do it in 2 steps, to prevent curves cut anything out of underlying normal tris
                new_cmds_cnt = 0;
                new_pnts_cnt = 0;
                for (i = 0; i < new_cmds.length; i++) {
                    if (new_cmds[i] == GraphicsPathCommand.LINE_TO) {
                        start_right = new_pnts[new_pnts_cnt++];
                        start_left = new_pnts[new_pnts_cnt++];
                        end_right = new_pnts[new_pnts_cnt];
                        end_left = new_pnts[new_pnts_cnt + 1];
                        //0GraphicsFactoryHelper.drawPoint(start_right.x,start_right.y, final_vert_list, false);
                        //GraphicsFactoryHelper.drawPoint(start_left.x,start_left.y, final_vert_list, false);
                        //GraphicsFactoryHelper.drawPoint(end_right.x,end_right.y, final_vert_list, false);
                        //GraphicsFactoryHelper.drawPoint(end_left.x,end_left.y, final_vert_list, false);
                        GraphicsFactoryHelper.addTriangle(start_right.x, start_right.y, end_right.x, end_right.y, start_left.x, start_left.y, 0, final_vert_list, curves);
                        GraphicsFactoryHelper.addTriangle(start_left.x, start_left.y, end_right.x, end_right.y, end_left.x, end_left.y, 0, final_vert_list, curves);
                    }
                    else if (new_cmds[i] == GraphicsPathCommand.CURVE_TO) {
                        new_pnts_cnt += 5;
                    }
                    else if (new_cmds[i] >= GraphicsPathCommand.BUILD_JOINT) {
                        end_right = new_pnts[new_pnts_cnt++];
                        start_right = new_pnts[new_pnts_cnt++];
                        start_left = new_pnts[new_pnts_cnt++];
                        GraphicsFactoryHelper.addTriangle(start_right.x, start_right.y, start_left.x, start_left.y, end_right.x, end_right.y, 0, final_vert_list, curves);
                        if (new_cmds[i] == GraphicsPathCommand.BUILD_ROUND_JOINT) {
                            new_pnts_cnt += 3;
                        }
                    }
                }
                if (!closed) {
                    last_dir_vec.x = data[2] - data[0];
                    last_dir_vec.y = data[3] - data[1];
                    last_dir_vec.normalize();
                    GraphicsFactoryHelper.createCap(data[0], data[1], new_pnts[0], new_pnts[1], last_dir_vec, strokeStyle.capstyle, -128, half_thickness, final_vert_list, curves);
                    last_dir_vec.x = data[data.length - 2] - data[data.length - 4];
                    last_dir_vec.y = data[data.length - 1] - data[data.length - 3];
                    last_dir_vec.normalize();
                    GraphicsFactoryHelper.createCap(data[data.length - 2], data[data.length - 1], new_pnts[new_pnts.length - 2], new_pnts[new_pnts.length - 1], last_dir_vec, strokeStyle.capstyle, 127, half_thickness, final_vert_list, curves);
                }
            }
        }
        //targetGraphic.queued_stroke_pathes.length=0;
    };
    return GraphicsFactoryStrokes;
}());

/**
 * @class LineElements
 */
var LineElements = (function (_super) {
    __extends(LineElements, _super);
    /**
     *
     */
    function LineElements(concatenatedBuffer) {
        if (concatenatedBuffer === void 0) { concatenatedBuffer = null; }
        var _this = _super.call(this, concatenatedBuffer) || this;
        _this._positions = new _awayjs_core.AttributesView(Float32Array, 6, concatenatedBuffer);
        return _this;
    }
    Object.defineProperty(LineElements.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return LineElements.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineElements.prototype, "traverseName", {
        get: function () {
            return LineElements.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineElements.prototype, "positions", {
        /**
         *
         */
        get: function () {
            return this._positions;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineElements.prototype, "thickness", {
        /**
         *
         */
        get: function () {
            return this._thickness;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineElements.prototype, "colors", {
        /**
         *
         */
        get: function () {
            if (!this._colors)
                this.setColors(this._colors);
            return this._colors;
        },
        enumerable: true,
        configurable: true
    });
    LineElements.prototype.getBoxBounds = function (target) {
        if (target === void 0) { target = null; }
        //TODO bounding calculations for lines
        return target;
    };
    LineElements.prototype.getSphereBounds = function (center, target) {
        if (target === void 0) { target = null; }
        //TODO bounding calculations for lines
        return target;
    };
    LineElements.prototype.setPositions = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values instanceof _awayjs_core.AttributesView) {
            this.clearVertices(this._positions);
            this._positions = values;
        }
        else if (values) {
            var i = 0;
            var j = 0;
            var index = 0;
            var positions = new Float32Array(values.length * 4);
            var indices = new Uint16Array(values.length);
            while (i < values.length) {
                if (index / 6 & 1) {
                    positions[index] = values[i + 3];
                    positions[index + 1] = values[i + 4];
                    positions[index + 2] = values[i + 5];
                    positions[index + 3] = values[i];
                    positions[index + 4] = values[i + 1];
                    positions[index + 5] = values[i + 2];
                }
                else {
                    positions[index] = values[i];
                    positions[index + 1] = values[i + 1];
                    positions[index + 2] = values[i + 2];
                    positions[index + 3] = values[i + 3];
                    positions[index + 4] = values[i + 4];
                    positions[index + 5] = values[i + 5];
                }
                index += 6;
                if (++j == 4) {
                    var o = index / 6 - 4;
                    indices.set([o, o + 1, o + 2, o + 3, o + 2, o + 1], i);
                    j = 0;
                    i += 6;
                }
            }
            this._positions.set(positions, offset * 4);
            this.setIndices(indices, offset);
        }
        else {
            this.clearVertices(this._positions);
            this._positions = new _awayjs_core.AttributesView(Float32Array, 6, this._concatenatedBuffer);
        }
        this._numVertices = this._positions.count;
        this.invalidateVertices(this._positions);
        this._verticesDirty[this._positions.id] = false;
    };
    LineElements.prototype.setThickness = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values instanceof _awayjs_core.Float1Attributes) {
            this._thickness = values;
        }
        else if (values) {
            if (!this._thickness)
                this._thickness = new _awayjs_core.Float1Attributes(this._concatenatedBuffer);
            var i = 0;
            var j = 0;
            var index = 0;
            var thickness = new Float32Array(values.length * 4);
            while (i < values.length) {
                thickness[index] = (Math.floor(0.5 * index + 0.5) & 1) ? -values[i] : values[i];
                if (++j == 4) {
                    j = 0;
                    i++;
                }
                index++;
            }
            this._thickness.set(thickness, offset * 4);
        }
        else if (this._thickness) {
            this._thickness.dispose();
            this._thickness = null;
        }
        this.invalidateVertices(this._thickness);
        this._verticesDirty[this._thickness.id] = false;
    };
    LineElements.prototype.setColors = function (values, offset) {
        if (offset === void 0) { offset = 0; }
        if (values) {
            if (values == this._colors)
                return;
            if (values instanceof _awayjs_core.Byte4Attributes) {
                this.clearVertices(this._colors);
                this._colors = values;
            }
            else {
                if (!this._colors)
                    this._colors = new _awayjs_core.Byte4Attributes(this._concatenatedBuffer);
                var i = 0;
                var j = 0;
                var index = 0;
                var colors = new Uint8Array(values.length * 4);
                while (i < values.length) {
                    if (index / 4 & 1) {
                        colors[index] = values[i + 4];
                        colors[index + 1] = values[i + 5];
                        colors[index + 2] = values[i + 6];
                        colors[index + 3] = values[i + 7];
                    }
                    else {
                        colors[index] = values[i];
                        colors[index + 1] = values[i + 1];
                        colors[index + 2] = values[i + 2];
                        colors[index + 3] = values[i + 3];
                    }
                    if (++j == 4) {
                        j = 0;
                        i += 8;
                    }
                    index += 4;
                }
                this._colors.set(colors, offset * 4);
            }
        }
        else {
            //auto-derive colors
            this._colors = ElementsUtils.generateColors(this.indices, this._colors, this._concatenatedBuffer, this._numVertices);
        }
        this.invalidateVertices(this._colors);
        this._verticesDirty[this._colors.id] = false;
    };
    /**
     *
     */
    LineElements.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._positions.dispose();
        this._positions = null;
        this._thickness.dispose();
        this._thickness = null;
        this._colors.dispose();
        this._colors = null;
    };
    /**
     * Clones the current object
     * @return An exact duplicate of the current object.
     */
    LineElements.prototype.clone = function () {
        var clone = new LineElements(this._concatenatedBuffer ? this._concatenatedBuffer.clone() : null);
        clone.setIndices(this.indices.clone());
        clone.setPositions(this._positions.clone());
        clone.setThickness(this._thickness.clone());
        clone.setColors(this._colors.clone());
        return clone;
    };
    return LineElements;
}(ElementsBase));
LineElements.traverseName = TraverserBase.addRenderableName("applyLineShape");
LineElements.assetType = "[asset LineElements]";

var ImageEvent = (function (_super) {
    __extends(ImageEvent, _super);
    /**
     * Create a new ImageEvent
     * @param type The event type.
     * @param image The instance of the image being updated.
     */
    function ImageEvent(type, image) {
        var _this = _super.call(this, type) || this;
        _this._image = image;
        return _this;
    }
    Object.defineProperty(ImageEvent.prototype, "image", {
        /**
         * The image of the material.
         */
        get: function () {
            return this._image;
        },
        enumerable: true,
        configurable: true
    });
    return ImageEvent;
}(_awayjs_core.EventBase));
/**
 *
 */
ImageEvent.INVALIDATE_MIPMAPS = "invalidateMipmaps";

var ImageBase = (function (_super) {
    __extends(ImageBase, _super);
    /**
     *
     */
    function ImageBase() {
        var _this = _super.call(this) || this;
        _this._pFormat = "bgra";
        return _this;
    }
    Object.defineProperty(ImageBase.prototype, "format", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return this._pFormat;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    ImageBase.prototype.invalidateMipmaps = function () {
        this.dispatchEvent(new ImageEvent(ImageEvent.INVALIDATE_MIPMAPS, this));
    };
    return ImageBase;
}(_awayjs_core.AssetBase));

var DefaultGraphicsFactory = (function () {
    function DefaultGraphicsFactory() {
    }
    DefaultGraphicsFactory.prototype.createImage2D = function (width, height, transparent, fillColor, powerOfTwo) {
        if (transparent === void 0) { transparent = true; }
        if (fillColor === void 0) { fillColor = null; }
        if (powerOfTwo === void 0) { powerOfTwo = true; }
        return new BitmapImage2D(width, height, transparent, fillColor, powerOfTwo);
    };
    return DefaultGraphicsFactory;
}());

var ImageUtils = (function () {
    function ImageUtils() {
    }
    /**
     *
     */
    ImageUtils.imageToBitmapImage2D = function (img, powerOfTwo, factory) {
        if (powerOfTwo === void 0) { powerOfTwo = true; }
        if (factory === void 0) { factory = null; }
        if (!factory)
            factory = new DefaultGraphicsFactory();
        var image2D = factory.createImage2D(img.naturalWidth, img.naturalHeight, true, null, powerOfTwo);
        image2D.draw(img);
        return image2D;
    };
    ImageUtils.isImage2DValid = function (image2D) {
        if (image2D == null)
            return true;
        return ImageUtils.isDimensionValid(image2D.width, image2D.powerOfTwo) && ImageUtils.isDimensionValid(image2D.height, image2D.powerOfTwo);
    };
    ImageUtils.isHTMLImageElementValid = function (image) {
        if (image == null)
            return true;
        return ImageUtils.isDimensionValid(image.width) && ImageUtils.isDimensionValid(image.height);
    };
    ImageUtils.isDimensionValid = function (d, powerOfTwo) {
        if (powerOfTwo === void 0) { powerOfTwo = true; }
        return d >= 1 && d <= ImageUtils.MAX_SIZE && (!powerOfTwo || ImageUtils.isPowerOfTwo(d));
    };
    ImageUtils.isPowerOfTwo = function (value) {
        return value ? ((value & -value) == value) : false;
    };
    ImageUtils.getBestPowerOf2 = function (value) {
        var p = 1;
        while (p < value)
            p <<= 1;
        if (p > ImageUtils.MAX_SIZE)
            p = ImageUtils.MAX_SIZE;
        return p;
    };
    return ImageUtils;
}());
ImageUtils.MAX_SIZE = 8192;

var Image2D = (function (_super) {
    __extends(Image2D, _super);
    /**
     *
     */
    function Image2D(width, height, powerOfTwo) {
        if (powerOfTwo === void 0) { powerOfTwo = true; }
        var _this = _super.call(this) || this;
        _this._powerOfTwo = true;
        _this._rect = new _awayjs_core.Rectangle(0, 0, Math.round(width), Math.round(height));
        _this._powerOfTwo = powerOfTwo;
        _this._testDimensions();
        return _this;
    }
    Object.defineProperty(Image2D.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Image2D.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Image2D.prototype, "height", {
        /**
         * The height of the image in pixels.
         */
        get: function () {
            return this._rect.height;
        },
        set: function (value) {
            this._setSize(this._rect.width, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Image2D.prototype, "rect", {
        /**
         * The rectangle that defines the size and location of the bitmap image. The
         * top and left of the rectangle are 0; the width and height are equal to the
         * width and height in pixels of the BitmapData object.
         */
        get: function () {
            return this._rect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Image2D.prototype, "width", {
        /**
         * The width of the bitmap image in pixels.
         */
        get: function () {
            return this._rect.width;
        },
        set: function (value) {
            this._setSize(value, this._rect.height);
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param width
     * @param height
     * @private
     */
    Image2D.prototype._setSize = function (width, height) {
        width = Math.round(width);
        height = Math.round(height);
        if (this._rect.width == width && this._rect.height == height)
            return;
        this.clear();
        this._rect.width = width;
        this._rect.height = height;
        this._testDimensions();
    };
    /**
     *
     * @private
     */
    Image2D.prototype._testDimensions = function () {
        if (this._powerOfTwo && (!ImageUtils.isDimensionValid(this._rect.width) || !ImageUtils.isDimensionValid(this._rect.height)))
            throw new Error("Invalid dimension: Width and height must be power of 2 and cannot exceed 2048");
    };
    Object.defineProperty(Image2D.prototype, "powerOfTwo", {
        /**
         * Enable POT texture size validation
         * @returns {boolean}
         */
        get: function () {
            return this._powerOfTwo;
        },
        set: function (value) {
            if (this._powerOfTwo == value)
                return;
            this._powerOfTwo = value;
            this._testDimensions();
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @returns {ImageData}
     */
    Image2D.prototype.getImageData = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    return Image2D;
}(ImageBase));
Image2D.assetType = "[image Image2D]";

var BitmapImageUtils = (function () {
    function BitmapImageUtils() {
    }
    BitmapImageUtils._fillRect = function (context, rect, color, transparent) {
        if ((color & 0xff000000) >>> 24 != 0xFF && transparent)
            context.clearRect(rect.x, rect.y, rect.width, rect.height);
        var argb = _awayjs_core.ColorUtils.float32ColorToARGB(color);
        if (transparent)
            context.fillStyle = 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',' + argb[0] / 255 + ')';
        else
            context.fillStyle = 'rgba(' + argb[1] + ',' + argb[2] + ',' + argb[3] + ',1)';
        context.fillRect(rect.x, rect.y, rect.width, rect.height);
    };
    BitmapImageUtils._copyPixels = function (context, bmpd, sourceRect, destPoint) {
        if (sourceRect.width > 0 && sourceRect.height > 0)
            context.drawImage(bmpd, sourceRect.x, sourceRect.y, sourceRect.width, sourceRect.height, destPoint.x, destPoint.y, sourceRect.width, sourceRect.height);
    };
    BitmapImageUtils._draw = function (context, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
        context.save();
        if (matrix != null)
            context.setTransform(matrix.a, matrix.b, matrix.c, matrix.d, matrix.tx, matrix.ty);
        if (source instanceof Uint8Array) {
            if (clipRect != null) {
                var imageData = context.getImageData(0, 0, clipRect.width, clipRect.height);
                imageData.data = source;
                context.putImageData(imageData, 0, 0);
            }
            else {
                console.log("  no rect");
            }
        }
        else {
            if (clipRect != null)
                context.drawImage(source, clipRect.x, clipRect.y, clipRect.width, clipRect.height);
            else
                context.drawImage(source, 0, 0);
        }
        context.restore();
    };
    return BitmapImageUtils;
}());

//TODO: implement all methods
var CPURenderingContext2D = (function () {
    function CPURenderingContext2D(cpuCanvas) {
        this.point = new _awayjs_core.Point();
        this.point2 = new _awayjs_core.Point();
        this.cpuCanvas = cpuCanvas;
    }
    CPURenderingContext2D.prototype.restore = function () {
        this.matrix = null;
    };
    CPURenderingContext2D.prototype.setTransform = function (m11, m12, m21, m22, dx, dy) {
        this.matrix = new _awayjs_core.Matrix(m11, m12, m21, m22, dx, dy);
    };
    CPURenderingContext2D.prototype.save = function () {
    };
    CPURenderingContext2D.prototype.arc = function (x, y, radius, startAngle, endAngle, anticlockwise) {
    };
    CPURenderingContext2D.prototype.measureText = function (text) {
        return undefined;
    };
    CPURenderingContext2D.prototype.isPointInPath = function (x, y, fillRule) {
        return undefined;
    };
    CPURenderingContext2D.prototype.quadraticCurveTo = function (cpx, cpy, x, y) {
    };
    CPURenderingContext2D.prototype.putImageData = function (imagedata, dx, dy, dirtyX, dirtyY, dirtyWidth, dirtyHeight) {
    };
    CPURenderingContext2D.prototype.rotate = function (angle) {
    };
    CPURenderingContext2D.prototype.fillText = function (text, x, y, maxWidth) {
    };
    CPURenderingContext2D.prototype.translate = function (x, y) {
    };
    CPURenderingContext2D.prototype.scale = function (x, y) {
    };
    CPURenderingContext2D.prototype.createRadialGradient = function (x0, y0, r0, x1, y1, r1) {
        return undefined;
    };
    CPURenderingContext2D.prototype.ellipse = function (x, y, radiusX, radiusY, rotation, startAngle, endAngle, anticlockwise) {
    };
    CPURenderingContext2D.prototype.lineTo = function (x, y) {
    };
    CPURenderingContext2D.prototype.getLineDash = function () {
        return undefined;
    };
    CPURenderingContext2D.prototype.fill = function (fillRule) {
    };
    CPURenderingContext2D.prototype.createImageData = function (imageDataOrSw, sh) {
        return undefined;
    };
    CPURenderingContext2D.prototype.createPattern = function (image, repetition) {
        return undefined;
    };
    CPURenderingContext2D.prototype.closePath = function () {
    };
    CPURenderingContext2D.prototype.rect = function (x, y, w, h) {
    };
    CPURenderingContext2D.prototype.clip = function (fillRule) {
    };
    CPURenderingContext2D.prototype.clearRect = function (x, y, w, h) {
        var imageData = this.cpuCanvas.getImageData();
        for (var i = x; i < x + w; i++) {
            for (var j = y; j < y + h; j++) {
                var index = (i + j * imageData.width) * 4;
                imageData.data[index] = 0;
                imageData.data[index + 1] = 0;
                imageData.data[index + 2] = 0;
                imageData.data[index + 3] = 0;
            }
        }
    };
    CPURenderingContext2D.prototype.moveTo = function (x, y) {
    };
    CPURenderingContext2D.prototype.getImageData = function (sx, sy, sw, sh) {
        //var result:ImageData = new ImageData(sw, sh);
        //var i:number = 0;
        //
        //for (i = 0; i < sw * sh * 4; i += 4) {
        //    result.data[i] = 255;
        //    result.data[i + 1] = 255;
        //    result.data[i + 2] = 255;
        //    result.data[i + 3] = 255;
        //}
        //
        //var imageData:ImageData = this.cpuCanvas.getImageData();
        //for (i = sx; i < sx + sw; i++) {
        //    for (var j:number = sy; j < sy + sh; j++) {
        //        this.copyPixel32(result, i - sx, i - sy, imageData, i, j);
        //    }
        //}
        return this.cpuCanvas.getImageData();
    };
    CPURenderingContext2D.prototype.applyPixel32 = function (target, x, y, color) {
        //todo: blending support
        x = Math.floor(x);
        y = Math.floor(y);
        if (x < 0 || x >= target.width || y >= target.height || y < 0)
            return;
        var index = (x + y * target.width) * 4;
        //var alpha:number = color[3] / 255;
        // target.data[index] += color[0];
        // target.data[index + 1] += color[1];
        // target.data[index + 2] += color[2];
        // target.data[index + 3] += color[3];
        target.data[index] = color[0];
        target.data[index + 1] = color[1];
        target.data[index + 2] = color[2];
        target.data[index + 3] = color[3];
        target.data[index] = target.data[index] & 0xFF;
        target.data[index + 1] = target.data[index + 1] & 0xFF;
        target.data[index + 2] = target.data[index + 2] & 0xFF;
        target.data[index + 3] = target.data[index + 3] & 0xFF;
    };
    CPURenderingContext2D.prototype.copyPixel32 = function (target, x, y, source, fromX, fromY) {
        x = Math.floor(x);
        y = Math.floor(y);
        fromX = Math.floor(fromX);
        fromY = Math.floor(fromY);
        if (x < 0 || x >= target.width || y >= target.height || y < 0)
            return;
        if (fromX < 0 || fromX >= source.width || fromY >= source.height || fromY < 0)
            return;
        var index = (x + y * target.width) * 4;
        var fromIndex = (fromX + fromY * source.width) * 4;
        target.data[index] = source.data[fromIndex];
        target.data[index + 1] = source.data[fromIndex + 1];
        target.data[index + 2] = source.data[fromIndex + 2];
        target.data[index + 3] = source.data[fromIndex + 3];
    };
    CPURenderingContext2D.prototype.fillRect = function (x, y, w, h) {
        if (this.fillStyle) {
            if (this.parsedFillStyle != this.fillStyle) {
                var colorStrings = this.fillStyle.substring(5, this.fillStyle.lastIndexOf(")")).split(",");
                this.parsedA = parseFloat(colorStrings[3]) * 255;
                this.parsedR = parseInt(colorStrings[0]);
                this.parsedG = parseInt(colorStrings[1]);
                this.parsedB = parseInt(colorStrings[2]);
                this.parsedFillStyle = this.fillStyle;
            }
            var imageData = this.cpuCanvas.getImageData();
            for (var i = x; i < x + w; i++) {
                for (var j = y; j < y + h; j++) {
                    var index = (i + j * imageData.width) * 4;
                    imageData.data[index] = this.parsedR;
                    imageData.data[index + 1] = this.parsedG;
                    imageData.data[index + 2] = this.parsedB;
                    imageData.data[index + 3] = this.parsedA;
                }
            }
        }
    };
    CPURenderingContext2D.prototype.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {
    };
    CPURenderingContext2D.prototype.drawImage = function (image, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
        var b = image;
        if (image.constructor.toString().indexOf("BitmapImage2D") > -1) {
            var bitmap = b;
            bitmap.lock();
            this.drawBitmap(bitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
            bitmap.unlock();
        }
        else if (image.constructor.toString().indexOf("HTMLImage") > -1) {
            var htmlImage = image;
            var htmlCanvas = document.createElement("canvas");
            htmlCanvas.width = htmlImage.width;
            htmlCanvas.height = htmlImage.height;
            var htmlContext = htmlCanvas.getContext("2d");
            htmlContext.drawImage(htmlImage, 0, 0);
            var htmlImageData = htmlContext.getImageData(0, 0, htmlImage.width, htmlImage.height);
            var resultBitmap = new BitmapImage2D(htmlImage.width, htmlImage.height, true, 0, false);
            resultBitmap.getImageData().data = htmlImageData.data;
            var passBitmap = resultBitmap;
            this.drawImage(passBitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
        }
        else if (image.constructor.toString().indexOf("CPUCanvas") > -1) {
            //
            var canvas = b;
            this.drawBitmap(canvas, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight);
        }
    };
    CPURenderingContext2D.prototype.drawBitmap = function (bitmap, offsetX, offsetY, width, height, canvasOffsetX, canvasOffsetY, canvasImageWidth, canvasImageHeight) {
        if (!width || width == 0) {
            width = bitmap.width;
            height = bitmap.height;
        }
        if (!canvasOffsetX || canvasOffsetX == 0) {
            canvasOffsetX = 0;
            canvasOffsetY = 0;
        }
        if (!canvasImageWidth || canvasImageWidth == 0 || this.matrix) {
            canvasImageWidth = width;
            canvasImageHeight = height;
        }
        //console.log("CPURenderingContext2D:drawBitmap(width: " + width + " height: " + height + " canvasImageWidth: " + canvasImageWidth + " canvasImageHeight: " + canvasImageHeight);
        var sourceData = bitmap.getImageData();
        var canvasImageData = this.cpuCanvas.getImageData();
        if (this.matrix || (canvasImageWidth != width || canvasImageHeight != height)) {
            var matrix = this.matrix;
            if (!matrix) {
                matrix = new _awayjs_core.Matrix();
                matrix.scale(canvasImageWidth / width, canvasImageHeight / height);
            }
            var scaleX = Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b);
            var scaleY = Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d);
            canvasImageWidth = width * scaleX;
            canvasImageHeight = height * scaleY;
            matrix.tx += canvasOffsetX;
            matrix.ty += canvasOffsetY;
            canvasOffsetX = Math.floor(matrix.tx);
            canvasOffsetY = Math.floor(matrix.ty);
            matrix.invert();
            if (scaleX >= 1 || scaleY >= 1) {
                var p = new _awayjs_core.Point();
                for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
                    for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
                        p.x = i;
                        p.y = j;
                        p = matrix.transformPoint(p);
                        var color = CPURenderingContext2D.sampleBilinear(p.x, p.y, sourceData);
                        this.applyPixel32(canvasImageData, i, j, color);
                    }
                }
            }
            else {
                //decimate
                var p1 = this.point;
                var p2 = this.point2;
                for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
                    for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
                        p1.x = i;
                        p1.y = j;
                        p1 = matrix.transformPoint(p1);
                        p2.x = i + 1;
                        p2.y = j + 1;
                        p2 = matrix.transformPoint(p2);
                        var color = CPURenderingContext2D.sampleBox(p1.x + offsetX, p1.y + offsetY, p2.x + offsetX, p2.y + offsetY, sourceData);
                        this.applyPixel32(canvasImageData, i, j, color);
                    }
                }
            }
            matrix.invert();
        }
        else {
            for (var i = canvasOffsetX; i < canvasOffsetX + canvasImageWidth; i++) {
                for (var j = canvasOffsetY; j < canvasOffsetY + canvasImageHeight; j++) {
                    var color = CPURenderingContext2D.sample(i - canvasOffsetX + offsetX, j - canvasOffsetY + offsetY, sourceData);
                    this.applyPixel32(canvasImageData, i, j, color);
                }
            }
        }
    };
    CPURenderingContext2D.prototype.transform = function (m11, m12, m21, m22, dx, dy) {
    };
    CPURenderingContext2D.prototype.stroke = function () {
    };
    CPURenderingContext2D.prototype.strokeRect = function (x, y, w, h) {
    };
    CPURenderingContext2D.prototype.setLineDash = function (segments) {
    };
    CPURenderingContext2D.prototype.strokeText = function (text, x, y, maxWidth) {
    };
    CPURenderingContext2D.prototype.beginPath = function () {
    };
    CPURenderingContext2D.prototype.arcTo = function (x1, y1, x2, y2, radius) {
    };
    CPURenderingContext2D.prototype.createLinearGradient = function (x0, y0, x1, y1) {
        return undefined;
    };
    CPURenderingContext2D.sampleBilinear = function (u, v, texture, texelSizeX, texelSizeY) {
        if (texelSizeX === void 0) { texelSizeX = 1; }
        if (texelSizeY === void 0) { texelSizeY = 1; }
        var color00 = CPURenderingContext2D.sample(u, v, texture);
        var color10 = CPURenderingContext2D.sample(u + texelSizeX, v, texture);
        var color01 = CPURenderingContext2D.sample(u, v + texelSizeY, texture);
        var color11 = CPURenderingContext2D.sample(u + texelSizeX, v + texelSizeY, texture);
        var a = u;
        a = a - Math.floor(a);
        var interColor0 = CPURenderingContext2D.interpolateColor(color00, color10, a);
        var interColor1 = CPURenderingContext2D.interpolateColor(color01, color11, a);
        var b = v;
        b = b - Math.floor(b);
        return CPURenderingContext2D.interpolateColor(interColor0, interColor1, b);
    };
    CPURenderingContext2D.sample = function (u, v, imageData) {
        u = Math.floor(u);
        v = Math.floor(v);
        var result = [0, 0, 0, 0];
        if (u < 0 || u >= imageData.width || v < 0 || v >= imageData.height) {
            return result;
        }
        var index = (u + v * imageData.width) * 4;
        result[0] = imageData.data[index];
        result[1] = imageData.data[index + 1];
        result[2] = imageData.data[index + 2];
        result[3] = imageData.data[index + 3];
        return result;
    };
    CPURenderingContext2D.sampleBox = function (x0, y0, x1, y1, texture) {
        var area = 0; // -- total area accumulated in pixels
        var result = [0, 0, 0, 0];
        var x;
        var y;
        var xsize;
        var ysize;
        var fromY = Math.floor(y0);
        var toY = Math.ceil(y1);
        fromY = Math.max(Math.min(fromY, texture.height - 1), 0);
        toY = Math.max(Math.min(toY, texture.height - 1), 0);
        for (y = fromY; y < toY; y++) {
            ysize = 1;
            if (y < y0) {
                ysize = ysize * (1.0 - (y0 - y));
            }
            if (y > y1) {
                ysize = ysize * (1.0 - (y - y1));
            }
            var fromX = Math.floor(x0);
            var toX = Math.ceil(x1);
            fromX = Math.max(Math.min(fromX, texture.width - 1), 0);
            toX = Math.max(Math.min(toX, texture.width - 1), 0);
            for (x = fromX; x < toX; x++) {
                xsize = ysize;
                var color = CPURenderingContext2D.sample(x, y, texture);
                if (x < x0) {
                    xsize = xsize * (1.0 - (x0 - x));
                }
                if (x > x1) {
                    xsize = xsize * (1.0 - (x - x1));
                }
                result[0] += color[0] * xsize;
                result[1] += color[1] * xsize;
                result[2] += color[2] * xsize;
                result[3] += color[3] * xsize;
                area = area + xsize;
            }
        }
        result[0] /= area;
        result[1] /= area;
        result[2] /= area;
        result[3] /= area;
        result[0] = result[0] & 0xFF;
        result[1] = result[1] & 0xFF;
        result[2] = result[2] & 0xFF;
        result[3] = result[3] & 0xFF;
        return result;
    };
    CPURenderingContext2D.interpolateColor = function (source, target, a) {
        var result = [];
        result[0] = source[0] + (target[0] - source[0]) * a;
        result[1] = source[1] + (target[1] - source[1]) * a;
        result[2] = source[2] + (target[2] - source[2]) * a;
        result[3] = source[3] + (target[3] - source[3]) * a;
        return result;
    };
    return CPURenderingContext2D;
}());

var ImageData = (function () {
    function ImageData(width, height) {
        this.width = width;
        this.height = height;
        this.data = new Uint8Array(width * height * 4);
    }
    return ImageData;
}());

var CPUCanvas = (function () {
    function CPUCanvas() {
        this.width = 1;
        this.height = 1;
        this.reset();
    }
    CPUCanvas.prototype.getContext = function (contextId) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        return new CPURenderingContext2D(this);
    };
    CPUCanvas.prototype.reset = function () {
        if (!this.imageData) {
            this.imageData = new ImageData(this.width, this.height);
        }
        else {
            this.imageData.width = this.width;
            this.imageData.height = this.height;
            if (this.imageData.data) {
                //this.imageData.data.length = 0;
                this.imageData.data = null;
            }
            this.imageData.data = new Uint8Array(this.width * this.height * 4);
        }
        for (var i = 0; i < this.width * this.height * 4; i += 4) {
            this.imageData.data[i] = 255;
            this.imageData.data[i + 1] = 255;
            this.imageData.data[i + 2] = 255;
            this.imageData.data[i + 3] = 255;
        }
    };
    CPUCanvas.prototype.getImageData = function () {
        if (this.imageData.width != this.width || this.imageData.height != this.height) {
            this.reset();
        }
        return this.imageData;
    };
    return CPUCanvas;
}());

/**
 * The BitmapImage2D export class lets you work with the data(pixels) of a Bitmap
 * object. You can use the methods of the BitmapImage2D export class to create
 * arbitrarily sized transparent or opaque bitmap images and manipulate them
 * in various ways at runtime. You can also access the BitmapImage2D for a bitmap
 * image that you load with the <code>flash.Assets</code> or
 * <code>flash.display.Loader</code> classes.
 *
 * <p>This export class lets you separate bitmap rendering operations from the
 * internal display updating routines of flash. By manipulating a
 * BitmapImage2D object directly, you can create complex images without incurring
 * the per-frame overhead of constantly redrawing the content from vector
 * data.</p>
 *
 * <p>The methods of the BitmapImage2D export class support effects that are not
 * available through the filters available to non-bitmap display objects.</p>
 *
 * <p>A BitmapImage2D object contains an array of pixel data. This data can
 * represent either a fully opaque bitmap or a transparent bitmap that
 * contains alpha channel data. Either type of BitmapImage2D object is stored as
 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
 * of a single pixel in the bitmap.</p>
 *
 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
 * 0 to 255) that describe the alpha transparency and the red, green, and blue
 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
 * represents the alpha channel value, followed by red, green, and blue.)</p>
 *
 * <p>The four channels(alpha, red, green, and blue) are represented as
 * numbers when you use them with the <code>BitmapImage2D.copyChannel()</code>
 * method or the <code>DisplacementMapFilter.componentX</code> and
 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
 * are represented by the following constants in the BitmapImage2DChannel
 * class:</p>
 *
 * <ul>
 *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
 *   <li><code>BitmapImage2DChannel.RED</code></li>
 *   <li><code>BitmapImage2DChannel.GREEN</code></li>
 *   <li><code>BitmapImage2DChannel.BLUE</code></li>
 * </ul>
 *
 * <p>You can attach BitmapImage2D objects to a Bitmap object by using the
 * <code>bitmapData</code> property of the Bitmap object.</p>
 *
 * <p>You can use a BitmapImage2D object to fill a Graphics object by using the
 * <code>Graphics.beginBitmapFill()</code> method.</p>
 *
 * <p>You can also use a BitmapImage2D object to perform batch tile rendering
 * using the <code>flash.display.Tilesheet</code> class.</p>
 *
 * <p>In Flash Player 10, the maximum size for a BitmapImage2D object
 * is 8,191 pixels in width or height, and the total number of pixels cannot
 * exceed 16,777,215 pixels.(So, if a BitmapImage2D object is 8,191 pixels wide,
 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation
 * is 2,880 pixels in height and 2,880 in width.</p>
 */
var BitmapImage2D = (function (_super) {
    __extends(BitmapImage2D, _super);
    /**
     * Creates a BitmapImage2D object with a specified width and height. If you
     * specify a value for the <code>fillColor</code> parameter, every pixel in
     * the bitmap is set to that color.
     *
     * <p>By default, the bitmap is created as transparent, unless you pass
     * the value <code>false</code> for the transparent parameter. After you
     * create an opaque bitmap, you cannot change it to a transparent bitmap.
     * Every pixel in an opaque bitmap uses only 24 bits of color channel
     * information. If you define the bitmap as transparent, every pixel uses 32
     * bits of color channel information, including an alpha transparency
     * channel.</p>
     *
     * @param width       The width of the bitmap image in pixels.
     * @param height      The height of the bitmap image in pixels.
     * @param transparent Specifies whether the bitmap image supports per-pixel
     *                    transparency. The default value is <code>true</code>
     *                    (transparent). To create a fully transparent bitmap,
     *                    set the value of the <code>transparent</code>
     *                    parameter to <code>true</code> and the value of the
     *                    <code>fillColor</code> parameter to 0x00000000(or to
     *                    0). Setting the <code>transparent</code> property to
     *                    <code>false</code> can result in minor improvements
     *                    in rendering performance.
     * @param fillColor   A 32-bit ARGB color value that you use to fill the
     *                    bitmap image area. The default value is
     *                    0xFFFFFFFF(solid white).
     */
    function BitmapImage2D(width, height, transparent, fillColor, powerOfTwo) {
        if (transparent === void 0) { transparent = true; }
        if (fillColor === void 0) { fillColor = null; }
        if (powerOfTwo === void 0) { powerOfTwo = true; }
        var _this = _super.call(this, width, height, powerOfTwo) || this;
        _this._locked = false;
        _this._transparent = transparent;
        if (typeof document !== "undefined") {
            _this._imageCanvas = document.createElement("canvas");
        }
        else {
            _this._imageCanvas = new CPUCanvas();
        }
        _this._imageCanvas.width = _this._rect.width;
        _this._imageCanvas.height = _this._rect.height;
        _this._context = _this._imageCanvas.getContext("2d");
        if (fillColor != null)
            _this.fillRect(_this._rect, fillColor);
        return _this;
    }
    Object.defineProperty(BitmapImage2D.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return BitmapImage2D.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapImage2D.prototype, "transparent", {
        /**
         * Defines whether the bitmap image supports per-pixel transparency. You can
         * set this value only when you construct a BitmapImage2D object by passing in
         * <code>true</code> for the <code>transparent</code> parameter of the
         * constructor. Then, after you create a BitmapImage2D object, you can check
         * whether it supports per-pixel transparency by determining if the value of
         * the <code>transparent</code> property is <code>true</code>.
         */
        get: function () {
            return this._transparent;
        },
        set: function (value) {
            this._transparent = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new BitmapImage2D object that is a clone of the original instance
     * with an exact copy of the contained bitmap.
     *
     * @return A new BitmapImage2D object that is identical to the original.
     */
    BitmapImage2D.prototype.clone = function () {
        var t = new BitmapImage2D(this.width, this.height, this.transparent, null, this.powerOfTwo);
        t.copyPixels(this, this.rect, new _awayjs_core.Point());
        return t;
    };
    /**
     * Adjusts the color values in a specified area of a bitmap image by using a
     * <code>ColorTransform</code> object. If the rectangle matches the
     * boundaries of the bitmap image, this method transforms the color values of
     * the entire image.
     *
     * @param rect           A Rectangle object that defines the area of the
     *                       image in which the ColorTransform object is applied.
     * @param colorTransform A ColorTransform object that describes the color
     *                       transformation values to apply.
     */
    BitmapImage2D.prototype.colorTransform = function (rect, colorTransform) {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var data = this._imageData.data;
        var i, j, index;
        for (i = 0; i < rect.width; ++i) {
            for (j = 0; j < rect.height; ++j) {
                index = (i + rect.x + (j + rect.y) * this.width) * 4;
                data[index] = data[index] * colorTransform.redMultiplier + colorTransform.redOffset;
                data[index + 1] = data[index + 1] * colorTransform.greenMultiplier + colorTransform.greenOffset;
                data[index + 2] = data[index + 2] * colorTransform.blueMultiplier + colorTransform.blueOffset;
                data[index + 3] = data[index + 3] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
            }
        }
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Transfers data from one channel of another BitmapImage2D object or the
     * current BitmapImage2D object into a channel of the current BitmapImage2D object.
     * All of the data in the other channels in the destination BitmapImage2D object
     * are preserved.
     *
     * <p>The source channel value and destination channel value can be one of
     * following values: </p>
     *
     * <ul>
     *   <li><code>BitmapImage2DChannel.RED</code></li>
     *   <li><code>BitmapImage2DChannel.GREEN</code></li>
     *   <li><code>BitmapImage2DChannel.BLUE</code></li>
     *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
     * </ul>
     *
     * @param sourceBitmapImage2D The input bitmap image to use. The source image
     *                         can be a different BitmapImage2D object or it can
     *                         refer to the current BitmapImage2D object.
     * @param sourceRect       The source Rectangle object. To copy only channel
     *                         data from a smaller area within the bitmap,
     *                         specify a source rectangle that is smaller than
     *                         the overall size of the BitmapImage2D object.
     * @param destPoint        The destination Point object that represents the
     *                         upper-left corner of the rectangular area where
     *                         the new channel data is placed. To copy only
     *                         channel data from one area to a different area in
     *                         the destination image, specify a point other than
     *                        (0,0).
     * @param sourceChannel    The source channel. Use a value from the
     *                         BitmapImage2DChannel class
     *                        (<code>BitmapImage2DChannel.RED</code>,
     *                         <code>BitmapImage2DChannel.BLUE</code>,
     *                         <code>BitmapImage2DChannel.GREEN</code>,
     *                         <code>BitmapImage2DChannel.ALPHA</code>).
     * @param destChannel      The destination channel. Use a value from the
     *                         BitmapImage2DChannel class
     *                        (<code>BitmapImage2DChannel.RED</code>,
     *                         <code>BitmapImage2DChannel.BLUE</code>,
     *                         <code>BitmapImage2DChannel.GREEN</code>,
     *                         <code>BitmapImage2DChannel.ALPHA</code>).
     * @throws TypeError The sourceBitmapImage2D, sourceRect or destPoint are null.
     */
    BitmapImage2D.prototype.copyChannel = function (sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
        var imageData = sourceBitmap.getImageData();
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var sourceData = imageData.data;
        var destData = this._imageData.data;
        var sourceOffset = Math.round(Math.log(sourceChannel) / Math.log(2));
        var destOffset = Math.round(Math.log(destChannel) / Math.log(2));
        var sourceX = Math.round(sourceRect.x);
        var sourceY = Math.round(sourceRect.y);
        var destX = Math.round(destPoint.x);
        var destY = Math.round(destPoint.y);
        var i, j, sourceIndex, destIndex;
        for (i = 0; i < sourceRect.width; ++i) {
            for (j = 0; j < sourceRect.height; ++j) {
                sourceIndex = (i + sourceX + (j + sourceY) * imageData.width) * 4;
                destIndex = (i + destX + (j + destY) * this._rect.width) * 4;
                destData[destIndex + destOffset] = sourceData[sourceIndex + sourceOffset];
            }
        }
        if (!this._locked)
            this.invalidate();
    };
    BitmapImage2D.prototype.copyPixels = function (source, sourceRect, destPoint) {
        if (source instanceof BitmapImage2D)
            source = source.getCanvas();
        if (this._imageData)
            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
        BitmapImageUtils._copyPixels(this._context, source, sourceRect, destPoint);
        this._imageData = null;
        if (!this._locked)
            this.invalidate();
    };
    BitmapImage2D.prototype.merge = function (source, sourceRect, destPoint, redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier) {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var dest = this._imageData.data;
        var src = source.getImageData().data;
        redMultiplier = ~~redMultiplier;
        greenMultiplier = ~~greenMultiplier;
        blueMultiplier = ~~blueMultiplier;
        alphaMultiplier = ~~alphaMultiplier;
        var i, j, index;
        for (i = 0; i < sourceRect.width; ++i) {
            for (j = 0; j < sourceRect.height; ++j) {
                index = (i + sourceRect.x + (j + sourceRect.y) * this.width) * 4;
                dest[index] = ~~((src[index] * redMultiplier + dest[index] * (0x100 - redMultiplier)) / 0x100);
                dest[index + 1] = ~~((src[index + 1] * greenMultiplier + dest[index + 1] * (0x100 - greenMultiplier)) / 0x100);
                dest[index + 2] = ~~((src[index + 2] * blueMultiplier + dest[index + 2] * (0x100 - blueMultiplier)) / 0x100);
                dest[index + 3] = ~~((src[index + 3] * alphaMultiplier + dest[index + 3] * (0x100 - alphaMultiplier)) / 0x100);
            }
        }
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Frees memory that is used to store the BitmapImage2D object.
     *
     * <p>When the <code>dispose()</code> method is called on an image, the width
     * and height of the image are set to 0. All subsequent calls to methods or
     * properties of this BitmapImage2D instance fail, and an exception is thrown.
     * </p>
     *
     * <p><code>BitmapImage2D.dispose()</code> releases the memory occupied by the
     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
     * memory). After using <code>BitmapImage2D.dispose()</code>, the BitmapImage2D
     * object is no longer usable and an exception may be thrown if
     * you call functions on the BitmapImage2D object. However,
     * <code>BitmapImage2D.dispose()</code> does not garbage collect the BitmapImage2D
     * object(approximately 128 bytes); the memory occupied by the actual
     * BitmapImage2D object is released at the time the BitmapImage2D object is
     * collected by the garbage collector.</p>
     *
     */
    BitmapImage2D.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._context = null;
        this._imageCanvas = null;
        this._imageData = null;
        this._rect = null;
        this._transparent = null;
        this._locked = null;
    };
    BitmapImage2D.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smoothing) {
        if (source instanceof BitmapImage2D && source.getCanvas())
            source = source.getCanvas();
        if (this._imageData)
            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
        BitmapImageUtils._draw(this._context, source, matrix, colorTransform, blendMode, clipRect, smoothing);
        this._imageData = null;
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Fills a rectangular area of pixels with a specified ARGB color.
     *
     * @param rect  The rectangular area to fill.
     * @param color The ARGB color value that fills the area. ARGB colors are
     *              often specified in hexadecimal format; for example,
     *              0xFF336699.
     * @throws TypeError The rect is null.
     */
    BitmapImage2D.prototype.fillRect = function (rect, color) {
        if (this._imageData)
            this._context.putImageData(this._imageData, 0, 0); // at coords 0,0
        rect.x = Math.ceil(rect.x);
        rect.y = Math.ceil(rect.y);
        rect.width = Math.ceil(rect.width);
        rect.height = Math.ceil(rect.height);
        BitmapImageUtils._fillRect(this._context, rect, color, this._transparent);
        this._imageData = null;
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Returns an integer that represents an RGB pixel value from a BitmapImage2D
     * object at a specific point(<i>x</i>, <i>y</i>). The
     * <code>getPixel()</code> method returns an unmultiplied pixel value. No
     * alpha information is returned.
     *
     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
     * values. A premultiplied image pixel has the red, green, and blue color
     * channel values already multiplied by the alpha data. For example, if the
     * alpha value is 0, the values for the RGB channels are also 0, independent
     * of their unmultiplied values. This loss of data can cause some problems
     * when you perform operations. All BitmapImage2D methods take and return
     * unmultiplied values. The internal pixel representation is converted from
     * premultiplied to unmultiplied before it is returned as a value. During a
     * set operation, the pixel value is premultiplied before the raw image pixel
     * is set.</p>
     *
     * @param x The <i>x</i> position of the pixel.
     * @param y The <i>y</i> position of the pixel.
     * @return A number that represents an RGB pixel value. If the(<i>x</i>,
     *         <i>y</i>) coordinates are outside the bounds of the image, the
     *         method returns 0.
     */
    BitmapImage2D.prototype.getPixel = function (x, y) {
        var r;
        var g;
        var b;
        var a;
        if (!this._imageData) {
            var pixelData = this._context.getImageData(x, y, 1, 1);
            r = pixelData.data[0];
            g = pixelData.data[1];
            b = pixelData.data[2];
            a = pixelData.data[3];
        }
        else {
            var index = (x + y * this._imageData.width) * 4;
            r = this._imageData.data[index + 0];
            g = this._imageData.data[index + 1];
            b = this._imageData.data[index + 2];
            a = this._imageData.data[index + 3];
        }
        //returns black if fully transparent
        if (!a)
            return 0x0;
        return (r << 16) | (g << 8) | b;
    };
    /**
     * Returns an ARGB color value that contains alpha channel data and RGB data.
     * This method is similar to the <code>getPixel()</code> method, which
     * returns an RGB color without alpha channel data.
     *
     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
     * values. A premultiplied image pixel has the red, green, and blue color
     * channel values already multiplied by the alpha data. For example, if the
     * alpha value is 0, the values for the RGB channels are also 0, independent
     * of their unmultiplied values. This loss of data can cause some problems
     * when you perform operations. All BitmapImage2D methods take and return
     * unmultiplied values. The internal pixel representation is converted from
     * premultiplied to unmultiplied before it is returned as a value. During a
     * set operation, the pixel value is premultiplied before the raw image pixel
     * is set.</p>
     *
     * @param x The <i>x</i> position of the pixel.
     * @param y The <i>y</i> position of the pixel.
     * @return A number representing an ARGB pixel value. If the(<i>x</i>,
     *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
     *         returned.
     */
    BitmapImage2D.prototype.getPixel32 = function (x, y) {
        var r;
        var g;
        var b;
        var a;
        if (!this._imageData) {
            var pixelData = this._context.getImageData(~~x, ~~y, 1, 1);
            r = pixelData.data[0];
            g = pixelData.data[1];
            b = pixelData.data[2];
            a = pixelData.data[3];
        }
        else {
            var index = (~~x + ~~y * this._imageData.width) * 4;
            r = this._imageData.data[index + 0];
            g = this._imageData.data[index + 1];
            b = this._imageData.data[index + 2];
            a = this._imageData.data[index + 3];
        }
        return (a << 24) | (r << 16) | (g << 8) | b;
    };
    BitmapImage2D.prototype.getPixelData = function (x, y, imagePixel) {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var index = (x + y * this._imageData.width) * 4;
        imagePixel[0] = this._imageData.data[index + 0];
        imagePixel[1] = this._imageData.data[index + 1];
        imagePixel[2] = this._imageData.data[index + 2];
        imagePixel[3] = this._imageData.data[index + 3];
    };
    BitmapImage2D.prototype.setPixelData = function (x, y, imagePixel) {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var index = (x + y * this._imageData.width) * 4;
        this._imageData.data[index + 0] = imagePixel[0];
        this._imageData.data[index + 1] = imagePixel[1];
        this._imageData.data[index + 2] = imagePixel[2];
        this._imageData.data[index + 3] = this._transparent ? imagePixel[3] : 0xFF;
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Locks an image so that any objects that reference the BitmapImage2D object,
     * such as Bitmap objects, are not updated when this BitmapImage2D object
     * changes. To improve performance, use this method along with the
     * <code>unlock()</code> method before and after numerous calls to the
     * <code>setPixel()</code> or <code>setPixel32()</code> method.
     *
     */
    BitmapImage2D.prototype.lock = function () {
        if (this._locked)
            return;
        this._locked = true;
    };
    /**
     * Converts an Array into a rectangular region of pixel data. For each pixel,
     * an Array element is read and written into the BitmapImage2D pixel. The data
     * in the Array is expected to be 32-bit ARGB pixel values.
     *
     * @param rect        Specifies the rectangular region of the BitmapImage2D
     *                    object.
     * @param inputArray  An Array that consists of 32-bit unmultiplied pixel
     *                    values to be used in the rectangular region.
     * @throws RangeError The vector array is not large enough to read all the
     *                    pixel data.
     */
    BitmapImage2D.prototype.setArray = function (rect, inputArray) {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var i, j, index, argb;
        for (i = 0; i < rect.width; ++i) {
            for (j = 0; j < rect.height; ++j) {
                argb = _awayjs_core.ColorUtils.float32ColorToARGB(inputArray[i + j * rect.width]);
                index = (i + rect.x + (j + rect.y) * this._imageData.width) * 4;
                this._imageData.data[index + 0] = argb[1];
                this._imageData.data[index + 1] = argb[2];
                this._imageData.data[index + 2] = argb[3];
                this._imageData.data[index + 3] = this._transparent ? argb[0] : 0xFF;
            }
        }
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Sets a single pixel of a BitmapImage2D object. The current alpha channel
     * value of the image pixel is preserved during this operation. The value of
     * the RGB color parameter is treated as an unmultiplied color value.
     *
     * <p><b>Note:</b> To increase performance, when you use the
     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
     * call the <code>lock()</code> method before you call the
     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
     * the <code>unlock()</code> method when you have made all pixel changes.
     * This process prevents objects that reference this BitmapImage2D instance from
     * updating until you finish making the pixel changes.</p>
     *
     * @param x     The <i>x</i> position of the pixel whose value changes.
     * @param y     The <i>y</i> position of the pixel whose value changes.
     * @param color The resulting RGB color for the pixel.
     */
    BitmapImage2D.prototype.setPixel = function (x, y, color) {
        var argb = _awayjs_core.ColorUtils.float32ColorToARGB(color);
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var index = (~~x + ~~y * this._imageData.width) * 4;
        this._imageData.data[index + 0] = argb[1];
        this._imageData.data[index + 1] = argb[2];
        this._imageData.data[index + 2] = argb[3];
        this._imageData.data[index + 3] = 0xff;
        if (!this._locked)
            this.invalidate();
    };
    BitmapImage2D.prototype.setPixelFromArray = function (x, y, colors) {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var index = (x + y * this._imageData.width) * 4;
        this._imageData.data[index + 0] = colors[1];
        this._imageData.data[index + 1] = colors[2];
        this._imageData.data[index + 2] = colors[3];
        this._imageData.data[index + 3] = colors[0] * 0xff;
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Sets the color and alpha transparency values of a single pixel of a
     * BitmapImage2D object. This method is similar to the <code>setPixel()</code>
     * method; the main difference is that the <code>setPixel32()</code> method
     * takes an ARGB color value that contains alpha channel information.
     *
     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
     * values. A premultiplied image pixel has the red, green, and blue color
     * channel values already multiplied by the alpha data. For example, if the
     * alpha value is 0, the values for the RGB channels are also 0, independent
     * of their unmultiplied values. This loss of data can cause some problems
     * when you perform operations. All BitmapImage2D methods take and return
     * unmultiplied values. The internal pixel representation is converted from
     * premultiplied to unmultiplied before it is returned as a value. During a
     * set operation, the pixel value is premultiplied before the raw image pixel
     * is set.</p>
     *
     * <p><b>Note:</b> To increase performance, when you use the
     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
     * call the <code>lock()</code> method before you call the
     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
     * the <code>unlock()</code> method when you have made all pixel changes.
     * This process prevents objects that reference this BitmapImage2D instance from
     * updating until you finish making the pixel changes.</p>
     *
     * @param x     The <i>x</i> position of the pixel whose value changes.
     * @param y     The <i>y</i> position of the pixel whose value changes.
     * @param color The resulting ARGB color for the pixel. If the bitmap is
     *              opaque(not transparent), the alpha transparency portion of
     *              this color value is ignored.
     */
    BitmapImage2D.prototype.setPixel32 = function (x, y, color) {
        var argb = _awayjs_core.ColorUtils.float32ColorToARGB(color);
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        var index = (~~x + ~~y * this._imageData.width) * 4;
        this._imageData.data[index + 0] = argb[1];
        this._imageData.data[index + 1] = argb[2];
        this._imageData.data[index + 2] = argb[3];
        this._imageData.data[index + 3] = this._transparent ? argb[0] : 0xFF;
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Converts a byte array into a rectangular region of pixel data. For each
     * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
     * the return value is written into the pixel. If the byte array ends before
     * the full rectangle is written, the function returns. The data in the byte
     * array is expected to be 32-bit ARGB pixel values. No seeking is performed
     * on the byte array before or after the pixels are read.
     *
     * @param rect           Specifies the rectangular region of the BitmapImage2D
     *                       object.
     * @param inputByteArray A ByteArray object that consists of 32-bit
     *                       unmultiplied pixel values to be used in the
     *                       rectangular region.
     * @throws EOFError  The <code>inputByteArray</code> object does not include
     *                   enough data to fill the area of the <code>rect</code>
     *                   rectangle. The method fills as many pixels as possible
     *                   before throwing the exception.
     * @throws TypeError The rect or inputByteArray are null.
     */
    BitmapImage2D.prototype.setPixels = function (rect, input) {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        //fast path for full imageData
        if (rect.equals(this._rect)) {
            this._imageData.data.set(input);
        }
        else {
            var i;
            var imageWidth = this._rect.width;
            var inputWidth = rect.width;
            for (i = 0; i < rect.height; ++i)
                this._imageData.data.set(input.subarray(i * inputWidth * 4, (i + 1) * inputWidth * 4), (rect.x + (i + rect.y) * imageWidth) * 4);
        }
        if (!this._locked)
            this.invalidate();
    };
    /**
     * Unlocks an image so that any objects that reference the BitmapImage2D object,
     * such as Bitmap objects, are updated when this BitmapImage2D object changes.
     * To improve performance, use this method along with the <code>lock()</code>
     * method before and after numerous calls to the <code>setPixel()</code> or
     * <code>setPixel32()</code> method.
     *
     * @param changeRect The area of the BitmapImage2D object that has changed. If
     *                   you do not specify a value for this parameter, the
     *                   entire area of the BitmapImage2D object is considered
     *                   changed.
     */
    BitmapImage2D.prototype.unlock = function () {
        if (!this._locked)
            return;
        this._locked = false;
        this.invalidate();
    };
    /**
     *
     * @returns {ImageData}
     */
    BitmapImage2D.prototype.getImageData = function () {
        if (!this._imageData)
            this._imageData = this._context.getImageData(0, 0, this._rect.width, this._rect.height);
        return this._imageData;
    };
    /**
     *
     * @returns {HTMLCanvasElement}
     */
    BitmapImage2D.prototype.getCanvas = function () {
        if (this._imageData)
            this._context.putImageData(this._imageData, 0, 0);
        this._imageData = null;
        return this._imageCanvas;
    };
    /**
     *
     * @param width
     * @param height
     * @private
     */
    BitmapImage2D.prototype._setSize = function (width, height) {
        if (this._imageData)
            this._context.putImageData(this._imageData, 0, 0);
        if (this._imageCanvas) {
            this._imageCanvas.width = width;
            this._imageCanvas.height = height;
        }
        _super.prototype._setSize.call(this, width, height);
        this._imageData = null;
    };
    return BitmapImage2D;
}(Image2D));
BitmapImage2D.assetType = "[image BitmapImage2D]";

var ImageCube = (function (_super) {
    __extends(ImageCube, _super);
    /**
     *
     */
    function ImageCube(size) {
        var _this = _super.call(this) || this;
        _this._size = size;
        _this._testDimensions();
        return _this;
    }
    Object.defineProperty(ImageCube.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return ImageCube.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ImageCube.prototype, "size", {
        /**
         * The size of the cube bitmap in pixels.
         */
        get: function () {
            return this._size;
        },
        set: function (value) {
            if (this._size == value)
                return;
            this._setSize(this._size);
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @returns {ImageData}
     */
    ImageCube.prototype.getImageData = function (side) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     *
     * @param width
     * @param height
     * @private
     */
    ImageCube.prototype._setSize = function (size) {
        if (this._size != size)
            this.clear();
        this._size = size;
        this._testDimensions();
    };
    /**
     *
     * @private
     */
    ImageCube.prototype._testDimensions = function () {
        if (!ImageUtils.isDimensionValid(this._size))
            throw new Error("Invalid dimension: Width and height must be power of 2 and cannot exceed 2048");
    };
    return ImageCube;
}(ImageBase));
ImageCube.assetType = "[image ImageCube]";

/**
 * The BitmapImage2D export class lets you work with the data(pixels) of a Bitmap
 * object. You can use the methods of the BitmapImage2D export class to create
 * arbitrarily sized transparent or opaque bitmap images and manipulate them
 * in various ways at runtime. You can also access the BitmapImage2D for a bitmap
 * image that you load with the <code>flash.Assets</code> or
 * <code>flash.display.Loader</code> classes.
 *
 * <p>This export class lets you separate bitmap rendering operations from the
 * internal display updating routines of flash. By manipulating a
 * BitmapImage2D object directly, you can create complex images without incurring
 * the per-frame overhead of constantly redrawing the content from vector
 * data.</p>
 *
 * <p>The methods of the BitmapImage2D export class support effects that are not
 * available through the filters available to non-bitmap display objects.</p>
 *
 * <p>A BitmapImage2D object contains an array of pixel data. This data can
 * represent either a fully opaque bitmap or a transparent bitmap that
 * contains alpha channel data. Either type of BitmapImage2D object is stored as
 * a buffer of 32-bit integers. Each 32-bit integer determines the properties
 * of a single pixel in the bitmap.</p>
 *
 * <p>Each 32-bit integer is a combination of four 8-bit channel values(from
 * 0 to 255) that describe the alpha transparency and the red, green, and blue
 * (ARGB) values of the pixel.(For ARGB values, the most significant byte
 * represents the alpha channel value, followed by red, green, and blue.)</p>
 *
 * <p>The four channels(alpha, red, green, and blue) are represented as
 * numbers when you use them with the <code>BitmapImage2D.copyChannel()</code>
 * method or the <code>DisplacementMapFilter.componentX</code> and
 * <code>DisplacementMapFilter.componentY</code> properties, and these numbers
 * are represented by the following constants in the BitmapImage2DChannel
 * class:</p>
 *
 * <ul>
 *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
 *   <li><code>BitmapImage2DChannel.RED</code></li>
 *   <li><code>BitmapImage2DChannel.GREEN</code></li>
 *   <li><code>BitmapImage2DChannel.BLUE</code></li>
 * </ul>
 *
 * <p>You can attach BitmapImage2D objects to a Bitmap object by using the
 * <code>bitmapData</code> property of the Bitmap object.</p>
 *
 * <p>You can use a BitmapImage2D object to fill a Graphics object by using the
 * <code>Graphics.beginBitmapFill()</code> method.</p>
 *
 * <p>You can also use a BitmapImage2D object to perform batch tile rendering
 * using the <code>flash.display.Tilesheet</code> class.</p>
 *
 * <p>In Flash Player 10, the maximum size for a BitmapImage2D object
 * is 8,191 pixels in width or height, and the total number of pixels cannot
 * exceed 16,777,215 pixels.(So, if a BitmapImage2D object is 8,191 pixels wide,
 * it can only be 2,048 pixels high.) In Flash Player 9 and earlier, the limitation
 * is 2,880 pixels in height and 2,880 in width.</p>
 */
var BitmapImageCube = (function (_super) {
    __extends(BitmapImageCube, _super);
    /**
     * Creates a BitmapImage2D object with a specified width and height. If you
     * specify a value for the <code>fillColor</code> parameter, every pixel in
     * the bitmap is set to that color.
     *
     * <p>By default, the bitmap is created as transparent, unless you pass
     * the value <code>false</code> for the transparent parameter. After you
     * create an opaque bitmap, you cannot change it to a transparent bitmap.
     * Every pixel in an opaque bitmap uses only 24 bits of color channel
     * information. If you define the bitmap as transparent, every pixel uses 32
     * bits of color channel information, including an alpha transparency
     * channel.</p>
     *
     * @param width       The width of the bitmap image in pixels.
     * @param height      The height of the bitmap image in pixels.
     * @param transparent Specifies whether the bitmap image supports per-pixel
     *                    transparency. The default value is <code>true</code>
     *                    (transparent). To create a fully transparent bitmap,
     *                    set the value of the <code>transparent</code>
     *                    parameter to <code>true</code> and the value of the
     *                    <code>fillColor</code> parameter to 0x00000000(or to
     *                    0). Setting the <code>transparent</code> property to
     *                    <code>false</code> can result in minor improvements
     *                    in rendering performance.
     * @param fillColor   A 32-bit ARGB color value that you use to fill the
     *                    bitmap image area. The default value is
     *                    0xFFFFFFFF(solid white).
     */
    function BitmapImageCube(size, transparent, fillColor) {
        if (transparent === void 0) { transparent = true; }
        if (fillColor === void 0) { fillColor = null; }
        var _this = _super.call(this, size) || this;
        _this._imageCanvas = new Array(6);
        _this._context = new Array(6);
        _this._imageData = new Array(6);
        _this._locked = false;
        _this._transparent = transparent;
        for (var i = 0; i < 6; i++) {
            if (typeof document !== "undefined") {
                _this._imageCanvas[i] = document.createElement("canvas");
            }
            else {
                _this._imageCanvas[i] = new CPUCanvas();
            }
            _this._imageCanvas[i].width = size;
            _this._imageCanvas[i].height = size;
            _this._context[i] = _this._imageCanvas[i].getContext("2d");
            if (fillColor != null)
                _this.fillRect(i, new _awayjs_core.Rectangle(0, 0, size, size), fillColor);
        }
        return _this;
    }
    Object.defineProperty(BitmapImageCube.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return BitmapImageCube.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapImageCube.prototype, "transparent", {
        /**
         * Defines whether the bitmap image supports per-pixel transparency. You can
         * set this value only when you construct a BitmapImage2D object by passing in
         * <code>true</code> for the <code>transparent</code> parameter of the
         * constructor. Then, after you create a BitmapImage2D object, you can check
         * whether it supports per-pixel transparency by determining if the value of
         * the <code>transparent</code> property is <code>true</code>.
         */
        get: function () {
            return this._transparent;
        },
        set: function (value) {
            this._transparent = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new BitmapImage2D object that is a clone of the original instance
     * with an exact copy of the contained bitmap.
     *
     * @return A new BitmapImage2D object that is identical to the original.
     */
    BitmapImageCube.prototype.clone = function () {
        var t = new BitmapImageCube(this._size, this.transparent);
        for (var i = 0; i < 6; i++) {
            t.draw(i, this.getCanvas(i));
        }
        return t;
    };
    /**
     * Adjusts the color values in a specified area of a bitmap image by using a
     * <code>ColorTransform</code> object. If the rectangle matches the
     * boundaries of the bitmap image, this method transforms the color values of
     * the entire image.
     *
     * @param rect           A Rectangle object that defines the area of the
     *                       image in which the ColorTransform object is applied.
     * @param colorTransform A ColorTransform object that describes the color
     *                       transformation values to apply.
     */
    BitmapImageCube.prototype.colorTransform = function (side, rect, colorTransform) {
        if (!this._locked)
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        var data = this._imageData[side].data;
        var i, j, index;
        for (i = 0; i < rect.width; ++i) {
            for (j = 0; j < rect.height; ++j) {
                index = (i + rect.x + (j + rect.y) * this._size) * 4;
                data[index] = data[index] * colorTransform.redMultiplier + colorTransform.redOffset;
                data[index + 1] = data[index + 1] * colorTransform.greenMultiplier + colorTransform.greenOffset;
                data[index + 2] = data[index + 2] * colorTransform.blueMultiplier + colorTransform.blueOffset;
                data[index + 3] = data[index + 3] * colorTransform.alphaMultiplier + colorTransform.alphaOffset;
            }
        }
        if (!this._locked) {
            this._context[side].putImageData(this._imageData[side], 0, 0);
            this._imageData[side] = null;
        }
        this.invalidate();
    };
    /**
     * Transfers data from one channel of another BitmapImage2D object or the
     * current BitmapImage2D object into a channel of the current BitmapImage2D object.
     * All of the data in the other channels in the destination BitmapImage2D object
     * are preserved.
     *
     * <p>The source channel value and destination channel value can be one of
     * following values: </p>
     *
     * <ul>
     *   <li><code>BitmapImage2DChannel.RED</code></li>
     *   <li><code>BitmapImage2DChannel.GREEN</code></li>
     *   <li><code>BitmapImage2DChannel.BLUE</code></li>
     *   <li><code>BitmapImage2DChannel.ALPHA</code></li>
     * </ul>
     *
     * @param sourceBitmapImage2D The input bitmap image to use. The source image
     *                         can be a different BitmapImage2D object or it can
     *                         refer to the current BitmapImage2D object.
     * @param sourceRect       The source Rectangle object. To copy only channel
     *                         data from a smaller area within the bitmap,
     *                         specify a source rectangle that is smaller than
     *                         the overall size of the BitmapImage2D object.
     * @param destPoint        The destination Point object that represents the
     *                         upper-left corner of the rectangular area where
     *                         the new channel data is placed. To copy only
     *                         channel data from one area to a different area in
     *                         the destination image, specify a point other than
     *                        (0,0).
     * @param sourceChannel    The source channel. Use a value from the
     *                         BitmapImage2DChannel class
     *                        (<code>BitmapImage2DChannel.RED</code>,
     *                         <code>BitmapImage2DChannel.BLUE</code>,
     *                         <code>BitmapImage2DChannel.GREEN</code>,
     *                         <code>BitmapImage2DChannel.ALPHA</code>).
     * @param destChannel      The destination channel. Use a value from the
     *                         BitmapImage2DChannel class
     *                        (<code>BitmapImage2DChannel.RED</code>,
     *                         <code>BitmapImage2DChannel.BLUE</code>,
     *                         <code>BitmapImage2DChannel.GREEN</code>,
     *                         <code>BitmapImage2DChannel.ALPHA</code>).
     * @throws TypeError The sourceBitmapImage2D, sourceRect or destPoint are null.
     */
    BitmapImageCube.prototype.copyChannel = function (side, sourceBitmap, sourceRect, destPoint, sourceChannel, destChannel) {
        var imageData = sourceBitmap.getImageData();
        if (!this._locked)
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        var sourceData = sourceBitmap.getImageData().data;
        var destData = this._imageData[side].data;
        var sourceOffset = Math.round(Math.log(sourceChannel) / Math.log(2));
        var destOffset = Math.round(Math.log(destChannel) / Math.log(2));
        var i, j, sourceIndex, destIndex;
        for (i = 0; i < sourceRect.width; ++i) {
            for (j = 0; j < sourceRect.height; ++j) {
                sourceIndex = (i + sourceRect.x + (j + sourceRect.y) * sourceBitmap.width) * 4;
                destIndex = (i + destPoint.x + (j + destPoint.y) * this._size) * 4;
                destData[destIndex + destOffset] = sourceData[sourceIndex + sourceOffset];
            }
        }
        if (!this._locked) {
            this._context[side].putImageData(this._imageData[side], 0, 0);
            this._imageData[side] = null;
        }
        this.invalidate();
    };
    BitmapImageCube.prototype.copyPixels = function (side, source, sourceRect, destPoint) {
        if (source instanceof BitmapImage2D)
            source = source.getCanvas();
        if (this._locked) {
            // If canvas is locked:
            //
            //      1) copy image data back to canvas
            //      2) draw object
            //      3) read _imageData back out
            this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
            BitmapImageUtils._copyPixels(this._context[side], source, sourceRect, destPoint);
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        }
        else {
            BitmapImageUtils._copyPixels(this._context[side], source, sourceRect, destPoint);
        }
        this.invalidate();
    };
    /**
     * Frees memory that is used to store the BitmapImage2D object.
     *
     * <p>When the <code>dispose()</code> method is called on an image, the width
     * and height of the image are set to 0. All subsequent calls to methods or
     * properties of this BitmapImage2D instance fail, and an exception is thrown.
     * </p>
     *
     * <p><code>BitmapImage2D.dispose()</code> releases the memory occupied by the
     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
     * memory). After using <code>BitmapImage2D.dispose()</code>, the BitmapImage2D
     * object is no longer usable and an exception may be thrown if
     * you call functions on the BitmapImage2D object. However,
     * <code>BitmapImage2D.dispose()</code> does not garbage collect the BitmapImage2D
     * object(approximately 128 bytes); the memory occupied by the actual
     * BitmapImage2D object is released at the time the BitmapImage2D object is
     * collected by the garbage collector.</p>
     *
     */
    BitmapImageCube.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        for (var i = 0; i < 6; i++) {
            this._context[i] = null;
            this._imageCanvas[i] = null;
            this._imageData[i] = null;
        }
        this._transparent = null;
        this._locked = null;
    };
    BitmapImageCube.prototype.draw = function (side, source, matrix, colorTransform, blendMode, clipRect, smoothing) {
        if (source instanceof BitmapImage2D)
            source = source.getCanvas();
        if (this._locked) {
            // If canvas is locked:
            //
            //      1) copy image data back to canvas
            //      2) draw object
            //      3) read _imageData back out
            this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
            BitmapImageUtils._draw(this._context[side], source, matrix, colorTransform, blendMode, clipRect, smoothing);
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        }
        else {
            BitmapImageUtils._draw(this._context[side], source, matrix, colorTransform, blendMode, clipRect, smoothing);
        }
        this.invalidate();
    };
    /**
     * Fills a rectangular area of pixels with a specified ARGB color.
     *
     * @param rect  The rectangular area to fill.
     * @param color The ARGB color value that fills the area. ARGB colors are
     *              often specified in hexadecimal format; for example,
     *              0xFF336699.
     * @throws TypeError The rect is null.
     */
    BitmapImageCube.prototype.fillRect = function (side, rect, color) {
        if (this._locked) {
            // If canvas is locked:
            //
            //      1) copy image data back to canvas
            //      2) apply fill
            //      3) read _imageData back out
            if (this._imageData[side])
                this._context[side].putImageData(this._imageData[side], 0, 0); // at coords 0,0
            BitmapImageUtils._fillRect(this._context[side], rect, color, this._transparent);
            if (this._imageData[side])
                this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        }
        else {
            BitmapImageUtils._fillRect(this._context[side], rect, color, this._transparent);
        }
        this.invalidate();
    };
    /**
     * Returns an integer that represents an RGB pixel value from a BitmapImage2D
     * object at a specific point(<i>x</i>, <i>y</i>). The
     * <code>getPixel()</code> method returns an unmultiplied pixel value. No
     * alpha information is returned.
     *
     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
     * values. A premultiplied image pixel has the red, green, and blue color
     * channel values already multiplied by the alpha data. For example, if the
     * alpha value is 0, the values for the RGB channels are also 0, independent
     * of their unmultiplied values. This loss of data can cause some problems
     * when you perform operations. All BitmapImage2D methods take and return
     * unmultiplied values. The internal pixel representation is converted from
     * premultiplied to unmultiplied before it is returned as a value. During a
     * set operation, the pixel value is premultiplied before the raw image pixel
     * is set.</p>
     *
     * @param x The <i>x</i> position of the pixel.
     * @param y The <i>y</i> position of the pixel.
     * @return A number that represents an RGB pixel value. If the(<i>x</i>,
     *         <i>y</i>) coordinates are outside the bounds of the image, the
     *         method returns 0.
     */
    BitmapImageCube.prototype.getPixel = function (side, x, y) {
        var r;
        var g;
        var b;
        var a;
        if (!this._locked) {
            var pixelData = this._context[side].getImageData(x, y, 1, 1);
            r = pixelData.data[0];
            g = pixelData.data[1];
            b = pixelData.data[2];
            a = pixelData.data[3];
        }
        else {
            var index = (x + y * this._size) * 4;
            r = this._imageData[side].data[index + 0];
            g = this._imageData[side].data[index + 1];
            b = this._imageData[side].data[index + 2];
            a = this._imageData[side].data[index + 3];
        }
        //returns black if fully transparent
        if (!a)
            return 0x0;
        return (r << 16) | (g << 8) | b;
    };
    /**
     * Returns an ARGB color value that contains alpha channel data and RGB data.
     * This method is similar to the <code>getPixel()</code> method, which
     * returns an RGB color without alpha channel data.
     *
     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
     * values. A premultiplied image pixel has the red, green, and blue color
     * channel values already multiplied by the alpha data. For example, if the
     * alpha value is 0, the values for the RGB channels are also 0, independent
     * of their unmultiplied values. This loss of data can cause some problems
     * when you perform operations. All BitmapImage2D methods take and return
     * unmultiplied values. The internal pixel representation is converted from
     * premultiplied to unmultiplied before it is returned as a value. During a
     * set operation, the pixel value is premultiplied before the raw image pixel
     * is set.</p>
     *
     * @param x The <i>x</i> position of the pixel.
     * @param y The <i>y</i> position of the pixel.
     * @return A number representing an ARGB pixel value. If the(<i>x</i>,
     *         <i>y</i>) coordinates are outside the bounds of the image, 0 is
     *         returned.
     */
    BitmapImageCube.prototype.getPixel32 = function (side, x, y) {
        var r;
        var g;
        var b;
        var a;
        if (!this._locked) {
            var pixelData = this._context[side].getImageData(x, y, 1, 1);
            r = pixelData.data[0];
            g = pixelData.data[1];
            b = pixelData.data[2];
            a = pixelData.data[3];
        }
        else {
            var index = (x + y * this._size) * 4;
            r = this._imageData[side].data[index + 0];
            g = this._imageData[side].data[index + 1];
            b = this._imageData[side].data[index + 2];
            a = this._imageData[side].data[index + 3];
        }
        return (a << 24) | (r << 16) | (g << 8) | b;
    };
    /**
     * Locks an image so that any objects that reference the BitmapImage2D object,
     * such as Bitmap objects, are not updated when this BitmapImage2D object
     * changes. To improve performance, use this method along with the
     * <code>unlock()</code> method before and after numerous calls to the
     * <code>setPixel()</code> or <code>setPixel32()</code> method.
     *
     */
    BitmapImageCube.prototype.lock = function () {
        if (this._locked)
            return;
        this._locked = true;
        for (var i = 0; i < 6; i++)
            this._imageData[i] = this._context[i].getImageData(0, 0, this._size, this._size);
    };
    /**
     * Converts an Array into a rectangular region of pixel data. For each pixel,
     * an Array element is read and written into the BitmapImage2D pixel. The data
     * in the Array is expected to be 32-bit ARGB pixel values.
     *
     * @param rect        Specifies the rectangular region of the BitmapImage2D
     *                    object.
     * @param inputArray  An Array that consists of 32-bit unmultiplied pixel
     *                    values to be used in the rectangular region.
     * @throws RangeError The vector array is not large enough to read all the
     *                    pixel data.
     */
    BitmapImageCube.prototype.setArray = function (side, rect, inputArray) {
        if (!this._locked)
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        var i, j, index, argb;
        for (i = 0; i < rect.width; ++i) {
            for (j = 0; j < rect.height; ++j) {
                argb = _awayjs_core.ColorUtils.float32ColorToARGB(inputArray[i + j * rect.width]);
                index = (i + rect.x + (j + rect.y) * this._size) * 4;
                this._imageData[side].data[index + 0] = argb[1];
                this._imageData[side].data[index + 1] = argb[2];
                this._imageData[side].data[index + 2] = argb[3];
                this._imageData[side].data[index + 3] = argb[0];
            }
        }
        if (!this._locked) {
            this._context[side].putImageData(this._imageData[side], 0, 0);
            this._imageData[side] = null;
        }
        this.invalidate();
    };
    /**
     * Sets a single pixel of a BitmapImage2D object. The current alpha channel
     * value of the image pixel is preserved during this operation. The value of
     * the RGB color parameter is treated as an unmultiplied color value.
     *
     * <p><b>Note:</b> To increase performance, when you use the
     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
     * call the <code>lock()</code> method before you call the
     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
     * the <code>unlock()</code> method when you have made all pixel changes.
     * This process prevents objects that reference this BitmapImage2D instance from
     * updating until you finish making the pixel changes.</p>
     *
     * @param x     The <i>x</i> position of the pixel whose value changes.
     * @param y     The <i>y</i> position of the pixel whose value changes.
     * @param color The resulting RGB color for the pixel.
     */
    BitmapImageCube.prototype.setPixel = function (side, x, y, color) {
        var argb = _awayjs_core.ColorUtils.float32ColorToARGB(color);
        if (!this._locked)
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        var index = (x + y * this._size) * 4;
        this._imageData[side].data[index + 0] = argb[1];
        this._imageData[side].data[index + 1] = argb[2];
        this._imageData[side].data[index + 2] = argb[3];
        this._imageData[side].data[index + 3] = 255;
        if (!this._locked) {
            this._context[side].putImageData(this._imageData[side], 0, 0);
            this._imageData = null;
        }
        this.invalidate();
    };
    /**
     * Sets the color and alpha transparency values of a single pixel of a
     * BitmapImage2D object. This method is similar to the <code>setPixel()</code>
     * method; the main difference is that the <code>setPixel32()</code> method
     * takes an ARGB color value that contains alpha channel information.
     *
     * <p>All pixels in a BitmapImage2D object are stored as premultiplied color
     * values. A premultiplied image pixel has the red, green, and blue color
     * channel values already multiplied by the alpha data. For example, if the
     * alpha value is 0, the values for the RGB channels are also 0, independent
     * of their unmultiplied values. This loss of data can cause some problems
     * when you perform operations. All BitmapImage2D methods take and return
     * unmultiplied values. The internal pixel representation is converted from
     * premultiplied to unmultiplied before it is returned as a value. During a
     * set operation, the pixel value is premultiplied before the raw image pixel
     * is set.</p>
     *
     * <p><b>Note:</b> To increase performance, when you use the
     * <code>setPixel()</code> or <code>setPixel32()</code> method repeatedly,
     * call the <code>lock()</code> method before you call the
     * <code>setPixel()</code> or <code>setPixel32()</code> method, and then call
     * the <code>unlock()</code> method when you have made all pixel changes.
     * This process prevents objects that reference this BitmapImage2D instance from
     * updating until you finish making the pixel changes.</p>
     *
     * @param x     The <i>x</i> position of the pixel whose value changes.
     * @param y     The <i>y</i> position of the pixel whose value changes.
     * @param color The resulting ARGB color for the pixel. If the bitmap is
     *              opaque(not transparent), the alpha transparency portion of
     *              this color value is ignored.
     */
    BitmapImageCube.prototype.setPixel32 = function (side, x, y, color) {
        var argb = _awayjs_core.ColorUtils.float32ColorToARGB(color);
        if (!this._locked)
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        var index = (x + y * this._size) * 4;
        this._imageData[side].data[index + 0] = argb[1];
        this._imageData[side].data[index + 1] = argb[2];
        this._imageData[side].data[index + 2] = argb[3];
        this._imageData[side].data[index + 3] = argb[0];
        if (!this._locked) {
            this._context[side].putImageData(this._imageData[side], 0, 0);
            this._imageData[side] = null;
        }
        this.invalidate();
    };
    /**
     * Converts a byte array into a rectangular region of pixel data. For each
     * pixel, the <code>ByteArray.readUnsignedInt()</code> method is called and
     * the return value is written into the pixel. If the byte array ends before
     * the full rectangle is written, the function returns. The data in the byte
     * array is expected to be 32-bit ARGB pixel values. No seeking is performed
     * on the byte array before or after the pixels are read.
     *
     * @param rect           Specifies the rectangular region of the BitmapImage2D
     *                       object.
     * @param inputByteArray A ByteArray object that consists of 32-bit
     *                       unmultiplied pixel values to be used in the
     *                       rectangular region.
     * @throws EOFError  The <code>inputByteArray</code> object does not include
     *                   enough data to fill the area of the <code>rect</code>
     *                   rectangle. The method fills as many pixels as possible
     *                   before throwing the exception.
     * @throws TypeError The rect or inputByteArray are null.
     */
    BitmapImageCube.prototype.setPixels = function (side, rect, inputByteArray) {
        if (!this._locked)
            this._imageData[side] = this._context[side].getImageData(0, 0, this._size, this._size);
        inputByteArray.position = 0;
        var i, j, index;
        for (i = 0; i < rect.width; ++i) {
            for (j = 0; j < rect.height; ++j) {
                index = (i + rect.x + (j + rect.y) * this._size) * 4;
                this._imageData[side].data[index + 0] = inputByteArray.readUnsignedInt();
                this._imageData[side].data[index + 1] = inputByteArray.readUnsignedInt();
                this._imageData[side].data[index + 2] = inputByteArray.readUnsignedInt();
                this._imageData[side].data[index + 3] = inputByteArray.readUnsignedInt();
            }
        }
        if (!this._locked) {
            this._context[side].putImageData(this._imageData[side], 0, 0);
            this._imageData[side] = null;
        }
        this.invalidate();
    };
    /**
     * Unlocks an image so that any objects that reference the BitmapImage2D object,
     * such as Bitmap objects, are updated when this BitmapImage2D object changes.
     * To improve performance, use this method along with the <code>lock()</code>
     * method before and after numerous calls to the <code>setPixel()</code> or
     * <code>setPixel32()</code> method.
     *
     * @param changeRect The area of the BitmapImage2D object that has changed. If
     *                   you do not specify a value for this parameter, the
     *                   entire area of the BitmapImage2D object is considered
     *                   changed.
     */
    BitmapImageCube.prototype.unlock = function () {
        if (!this._locked)
            return;
        this._locked = false;
        for (var i = 0; i < 6; i++) {
            this._context[i].putImageData(this._imageData[i], 0, 0); // at coords 0,0
            this._imageData[i] = null;
        }
    };
    /**
     *
     * @returns {ImageData}
     */
    BitmapImageCube.prototype.getImageData = function (side) {
        if (!this._locked)
            return this._context[side].getImageData(0, 0, this._size, this._size);
        return this._imageData[side];
    };
    /**
     *
     * @returns {HTMLCanvasElement}
     */
    BitmapImageCube.prototype.getCanvas = function (side) {
        return this._imageCanvas[side];
    };
    /**
     *
     * @param width
     * @param height
     * @private
     */
    BitmapImageCube.prototype._setSize = function (size) {
        _super.prototype._setSize.call(this, size);
        for (var i = 0; i < 6; i++) {
            if (this._locked)
                this._context[i].putImageData(this._imageData[i], 0, 0);
            this._imageCanvas[i].width = size;
            this._imageCanvas[i].height = size;
            if (this._locked)
                this._imageData[i] = this._context[i].getImageData(0, 0, this._size, this._size);
        }
    };
    return BitmapImageCube;
}(ImageCube));
BitmapImageCube.assetType = "[image BitmapImageCube]";
BitmapImageCube.posX = 0;
BitmapImageCube.negX = 1;
BitmapImageCube.posY = 2;
BitmapImageCube.negY = 3;
BitmapImageCube.posZ = 4;
BitmapImageCube.negZ = 5;

/**
 * A export class that provides constant values for visual blend mode effects. These
 * constants are used in the following:
 * <ul>
 *   <li> The <code>blendMode</code> property of the
 * flash.display.DisplayObject class.</li>
 *   <li> The <code>blendMode</code> parameter of the <code>draw()</code>
 * method of the flash.display.BitmapData class</li>
 * </ul>
 */
var BlendMode = (function () {
    function BlendMode() {
    }
    return BlendMode;
}());
/**
 * Adds the values of the constituent colors of the display object to the
 * colors of its background, applying a ceiling of 0xFF. This setting is
 * commonly used for animating a lightening dissolve between two objects.
 *
 * <p>For example, if the display object has a pixel with an RGB value of
 * 0xAAA633, and the background pixel has an RGB value of 0xDD2200, the
 * resulting RGB value for the displayed pixel is 0xFFC833(because 0xAA +
 * 0xDD > 0xFF, 0xA6 + 0x22 = 0xC8, and 0x33 + 0x00 = 0x33).</p>
 */
BlendMode.ADD = "add";
/**
 * Applies the alpha value of each pixel of the display object to the
 * background. This requires the <code>blendMode</code> property of the
 * parent display object be set to
 * <code>away.base.BlendMode.LAYER</code>.
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.ALPHA = "alpha";
/**
 * Selects the darker of the constituent colors of the display object and the
 * colors of the background(the colors with the smaller values). This
 * setting is commonly used for superimposing type.
 *
 * <p>For example, if the display object has a pixel with an RGB value of
 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
 * resulting RGB value for the displayed pixel is 0xDDCC00(because 0xFF >
 * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.DARKEN = "darken";
/**
 * Compares the constituent colors of the display object with the colors of
 * its background, and subtracts the darker of the values of the two
 * constituent colors from the lighter value. This setting is commonly used
 * for more vibrant colors.
 *
 * <p>For example, if the display object has a pixel with an RGB value of
 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
 * resulting RGB value for the displayed pixel is 0x222C33(because 0xFF -
 * 0xDD = 0x22, 0xF8 - 0xCC = 0x2C, and 0x33 - 0x00 = 0x33).</p>
 */
BlendMode.DIFFERENCE = "difference";
/**
 * Erases the background based on the alpha value of the display object. This
 * process requires that the <code>blendMode</code> property of the parent
 * display object be set to <code>flash.display.BlendMode.LAYER</code>.
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.ERASE = "erase";
/**
 * Adjusts the color of each pixel based on the darkness of the display
 * object. If the display object is lighter than 50% gray, the display object
 * and background colors are screened, which results in a lighter color. If
 * the display object is darker than 50% gray, the colors are multiplied,
 * which results in a darker color. This setting is commonly used for shading
 * effects.
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.HARDLIGHT = "hardlight";
/**
 * Inverts the background.
 */
BlendMode.INVERT = "invert";
/**
 * Forces the creation of a transparency group for the display object. This
 * means that the display object is precomposed in a temporary buffer before
 * it is processed further. The precomposition is done automatically if the
 * display object is precached by means of bitmap caching or if the display
 * object is a display object container that has at least one child object
 * with a <code>blendMode</code> setting other than <code>"normal"</code>.
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.LAYER = "layer";
/**
 * Selects the lighter of the constituent colors of the display object and
 * the colors of the background(the colors with the larger values). This
 * setting is commonly used for superimposing type.
 *
 * <p>For example, if the display object has a pixel with an RGB value of
 * 0xFFCC33, and the background pixel has an RGB value of 0xDDF800, the
 * resulting RGB value for the displayed pixel is 0xFFF833(because 0xFF >
 * 0xDD, 0xCC < 0xF8, and 0x33 > 0x00 = 33).</p>
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.LIGHTEN = "lighten";
/**
 * Multiplies the values of the display object constituent colors by the
 * constituent colors of the background color, and normalizes by dividing by
 * 0xFF, resulting in darker colors. This setting is commonly used for
 * shadows and depth effects.
 *
 * <p>For example, if a constituent color(such as red) of one pixel in the
 * display object and the corresponding color of the pixel in the background
 * both have the value 0x88, the multiplied result is 0x4840. Dividing by
 * 0xFF yields a value of 0x48 for that constituent color, which is a darker
 * shade than the color of the display object or the color of the
 * background.</p>
 */
BlendMode.MULTIPLY = "multiply";
/**
 * The display object appears in front of the background. Pixel values of the
 * display object override the pixel values of the background. Where the
 * display object is transparent, the background is visible.
 */
BlendMode.NORMAL = "normal";
/**
 * Adjusts the color of each pixel based on the darkness of the background.
 * If the background is lighter than 50% gray, the display object and
 * background colors are screened, which results in a lighter color. If the
 * background is darker than 50% gray, the colors are multiplied, which
 * results in a darker color. This setting is commonly used for shading
 * effects.
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.OVERLAY = "overlay";
/**
 * Multiplies the complement(inverse) of the display object color by the
 * complement of the background color, resulting in a bleaching effect. This
 * setting is commonly used for highlights or to remove black areas of the
 * display object.
 */
BlendMode.SCREEN = "screen";
/**
 * Uses a shader to define the blend between objects.
 *
 * <p>Setting the <code>blendShader</code> property to a Shader instance
 * automatically sets the display object's <code>blendMode</code> property to
 * <code>BlendMode.SHADER</code>. If the <code>blendMode</code> property is
 * set to <code>BlendMode.SHADER</code> without first setting the
 * <code>blendShader</code> property, the <code>blendMode</code> property is
 * set to <code>BlendMode.NORMAL</code> instead. If the
 * <code>blendShader</code> property is set(which sets the
 * <code>blendMode</code> property to <code>BlendMode.SHADER</code>), then
 * later the value of the <code>blendMode</code> property is changed, the
 * blend mode can be reset to use the blend shader simply by setting the
 * <code>blendMode</code> property to <code>BlendMode.SHADER</code>. The
 * <code>blendShader</code> property does not need to be set again except to
 * change the shader that's used to define the blend mode.</p>
 *
 * <p>Not supported under GPU rendering.</p>
 */
BlendMode.SHADER = "shader";
/**
 * Subtracts the values of the constituent colors in the display object from
 * the values of the background color, applying a floor of 0. This setting is
 * commonly used for animating a darkening dissolve between two objects.
 *
 * <p>For example, if the display object has a pixel with an RGB value of
 * 0xAA2233, and the background pixel has an RGB value of 0xDDA600, the
 * resulting RGB value for the displayed pixel is 0x338400(because 0xDD -
 * 0xAA = 0x33, 0xA6 - 0x22 = 0x84, and 0x00 - 0x33 < 0x00).</p>
 */
BlendMode.SUBTRACT = "subtract";

var MaterialEvent = (function (_super) {
    __extends(MaterialEvent, _super);
    /**
     * Create a new GraphicsEvent
     * @param type The event type.
     * @param dataType An optional data type of the vertex data being updated.
     */
    function MaterialEvent(type, material) {
        var _this = _super.call(this, type) || this;
        _this._material = material;
        return _this;
    }
    Object.defineProperty(MaterialEvent.prototype, "material", {
        /**
         * The material of the renderable.
         */
        get: function () {
            return this._material;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current object.
     */
    MaterialEvent.prototype.clone = function () {
        return new MaterialEvent(this.type, this._material);
    };
    return MaterialEvent;
}(_awayjs_core.EventBase));
MaterialEvent.INVALIDATE_TEXTURE = "invalidateTexture";
MaterialEvent.INVALIDATE_ANIMATION = "invalidateAnimation";
MaterialEvent.INVALIDATE_PASSES = "invalidatePasses";

/**
 * MaterialBase forms an abstract base class for any material.
 * A material consists of several passes, each of which constitutes at least one render call. Several passes could
 * be used for special effects (render lighting for many lights in several passes, render an outline in a separate
 * pass) or to provide additional render-to-texture passes (rendering diffuse light to texture for texture-space
 * subsurface scattering, or rendering a depth map for specialized self-shadowing).
 *
 * Away3D provides default materials trough SinglePassMaterialBase and TriangleMaterial, which use modular
 * methods to build the shader code. MaterialBase can be extended to build specific and high-performant custom
 * shaders, or entire new material frameworks.
 */
var MaterialBase = (function (_super) {
    __extends(MaterialBase, _super);
    function MaterialBase(imageColor, alpha) {
        if (imageColor === void 0) { imageColor = 0xFFFFFF; }
        if (alpha === void 0) { alpha = 1; }
        var _this = _super.call(this) || this;
        _this._textures = new Array();
        _this._pUseColorTransform = false;
        _this._alphaBlending = false;
        _this._alpha = 1;
        _this._pAlphaThreshold = 0;
        _this._pAnimateUVs = false;
        _this._style = new Style();
        _this._iBaseScreenPassIndex = 0;
        _this._bothSides = false; // update
        /**
         * A list of material owners, renderables or custom Entities.
         */
        _this._owners = new Array();
        _this._pBlendMode = BlendMode.NORMAL;
        _this._imageRect = false;
        _this._curves = false;
        _this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
        _this._style.addEventListener(StyleEvent.INVALIDATE_PROPERTIES, _this._onInvalidatePropertiesDelegate);
        if (imageColor instanceof ImageBase)
            _this._style.image = imageColor;
        else
            _this._style.color = Number(imageColor);
        _this.alpha = alpha;
        _this._onTextureInvalidateDelegate = function (event) { return _this.onTextureInvalidate(event); };
        _this.alphaPremultiplied = false; //TODO: work out why this is different for WebGL
        return _this;
    }
    Object.defineProperty(MaterialBase.prototype, "alpha", {
        /**
         * The alpha of the surface.
         */
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            if (this._alpha == value)
                return;
            this._alpha = value;
            if (this._colorTransform == null)
                this._colorTransform = new _awayjs_core.ColorTransform();
            this._colorTransform.alphaMultiplier = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "colorTransform", {
        /**
         * The ColorTransform object to transform the colour of the material with. Defaults to null.
         */
        get: function () {
            return this._colorTransform;
        },
        set: function (value) {
            this._colorTransform = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "alphaBlending", {
        /**
         * Indicates whether or not the material has transparency. If binary transparency is sufficient, for
         * example when using textures of foliage, consider using alphaThreshold instead.
         */
        get: function () {
            return this._alphaBlending;
        },
        set: function (value) {
            if (this._alphaBlending == value)
                return;
            this._alphaBlending = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "animationSet", {
        /**
         *
         */
        get: function () {
            return this._animationSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "curves", {
        /**
         * Indicates whether material should use curves. Defaults to false.
         */
        get: function () {
            return this._curves;
        },
        set: function (value) {
            if (this._curves == value)
                return;
            this._curves = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "imageRect", {
        /**
         * Indicates whether or not any used textures should use an atlas. Defaults to false.
         */
        get: function () {
            return this._imageRect;
        },
        set: function (value) {
            if (this._imageRect == value)
                return;
            this._imageRect = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "style", {
        /**
         * The style used to render the current TriangleGraphic. If set to null, its parent Sprite's style will be used instead.
         */
        get: function () {
            return this._style;
        },
        set: function (value) {
            if (this._style == value)
                return;
            if (this._style)
                this._style.removeEventListener(StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this._style = value;
            if (this._style)
                this._style.addEventListener(StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "animateUVs", {
        /**
         * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
         */
        get: function () {
            return this._pAnimateUVs;
        },
        set: function (value) {
            if (this._pAnimateUVs == value)
                return;
            this._pAnimateUVs = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "useColorTransform", {
        /**
         * Specifies whether or not the UV coordinates should be animated using a transformation matrix.
         */
        get: function () {
            return this._pUseColorTransform;
        },
        set: function (value) {
            if (this._pUseColorTransform == value)
                return;
            this._pUseColorTransform = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "bothSides", {
        /**
         * Defines whether or not the material should cull triangles facing away from the camera.
         */
        get: function () {
            return this._bothSides;
        },
        set: function (value) {
            if (this._bothSides = value)
                return;
            this._bothSides = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "blendMode", {
        /**
         * The blend mode to use when drawing this renderable. The following blend modes are supported:
         * <ul>
         * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
         * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
         * <li>BlendMode.MULTIPLY</li>
         * <li>BlendMode.ADD</li>
         * <li>BlendMode.ALPHA</li>
         * </ul>
         */
        get: function () {
            return this._pBlendMode;
        },
        set: function (value) {
            if (this._pBlendMode == value)
                return;
            this._pBlendMode = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "alphaPremultiplied", {
        /**
         * Indicates whether visible textures (or other pixels) used by this material have
         * already been premultiplied. Toggle this if you are seeing black halos around your
         * blended alpha edges.
         */
        get: function () {
            return this._alphaPremultiplied;
        },
        set: function (value) {
            if (this._alphaPremultiplied == value)
                return;
            this._alphaPremultiplied = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialBase.prototype, "alphaThreshold", {
        /**
         * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
         * invisible or entirely opaque, often used with textures for foliage, etc.
         * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
         */
        get: function () {
            return this._pAlphaThreshold;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            if (this._pAlphaThreshold == value)
                return;
            this._pAlphaThreshold = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    //
    // MATERIAL MANAGEMENT
    //
    /**
     * Mark an IEntity as owner of this material.
     * Assures we're not using the same material across renderables with different animations, since the
     * Programs depend on animation. This method needs to be called when a material is assigned.
     *
     * @param owner The IEntity that had this material assigned
     *
     * @internal
     */
    MaterialBase.prototype.iAddOwner = function (owner) {
        this._owners.push(owner);
        var animationSet;
        var animator = owner.animator;
        if (animator)
            animationSet = animator.animationSet;
        if (owner.animator) {
            if (this._animationSet && animationSet != this._animationSet) {
                throw new Error("A Material instance cannot be shared across material owners with different animation sets");
            }
            else {
                if (this._animationSet != animationSet) {
                    this._animationSet = animationSet;
                    this.invalidateAnimation();
                }
            }
        }
    };
    /**
     * Removes an IEntity as owner.
     * @param owner
     *
     * @internal
     */
    MaterialBase.prototype.iRemoveOwner = function (owner) {
        this._owners.splice(this._owners.indexOf(owner), 1);
        if (this._owners.length == 0) {
            this._animationSet = null;
            this.invalidateAnimation();
        }
    };
    Object.defineProperty(MaterialBase.prototype, "iOwners", {
        /**
         * A list of the IEntities that use this material
         *
         * @private
         */
        get: function () {
            return this._owners;
        },
        enumerable: true,
        configurable: true
    });
    MaterialBase.prototype.getNumTextures = function () {
        return this._textures.length;
    };
    MaterialBase.prototype.getTextureAt = function (index) {
        return this._textures[index];
    };
    /**
     * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
     *
     * @private
     */
    MaterialBase.prototype.invalidatePasses = function () {
        this.dispatchEvent(new MaterialEvent(MaterialEvent.INVALIDATE_PASSES, this));
    };
    MaterialBase.prototype.invalidateAnimation = function () {
        this.dispatchEvent(new MaterialEvent(MaterialEvent.INVALIDATE_ANIMATION, this));
    };
    MaterialBase.prototype.invalidateMaterials = function () {
        var len = this._owners.length;
        for (var i = 0; i < len; i++)
            this._owners[i].invalidateMaterial();
    };
    MaterialBase.prototype.invalidateTexture = function () {
        this.dispatchEvent(new MaterialEvent(MaterialEvent.INVALIDATE_TEXTURE, this));
    };
    MaterialBase.prototype.addTextureAt = function (texture, index) {
        var i = this._textures.indexOf(texture);
        if (i == index)
            return;
        else if (i != -1)
            this._textures.splice(i, 1);
        this._textures.splice(index, 0, texture);
        texture.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
        this.onTextureInvalidate();
    };
    MaterialBase.prototype.addTexture = function (texture) {
        if (this._textures.indexOf(texture) != -1)
            return;
        this._textures.push(texture);
        texture.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
        this.onTextureInvalidate();
    };
    MaterialBase.prototype.removeTexture = function (texture) {
        this._textures.splice(this._textures.indexOf(texture), 1);
        texture.removeEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
        this.onTextureInvalidate();
    };
    MaterialBase.prototype.onTextureInvalidate = function (event) {
        if (event === void 0) { event = null; }
        this.invalidatePasses();
        //invalidate renderables for number of images getter (in case it has changed)
        this.invalidateMaterials();
    };
    MaterialBase.prototype._onInvalidateProperties = function (event) {
        this.invalidatePasses();
    };
    return MaterialBase;
}(_awayjs_core.AssetBase));

/**
 *
 */
/**
 *
 */ 
(function (MappingMode) {
    /**
     *
     */
    MappingMode[MappingMode["CUBE"] = 0] = "CUBE";
    /**
     *
     */
    MappingMode[MappingMode["LINEAR"] = 1] = "LINEAR";
    /**
     *
     */
    MappingMode[MappingMode["RADIAL"] = 2] = "RADIAL";
})(exports.MappingMode || (exports.MappingMode = {}));

/**
 *
 */
var TextureBase = (function (_super) {
    __extends(TextureBase, _super);
    /**
     *
     */
    function TextureBase() {
        var _this = _super.call(this) || this;
        _this._numImages = 0;
        _this._images = new Array();
        _this._samplers = new Array();
        return _this;
    }
    Object.defineProperty(TextureBase.prototype, "mappingMode", {
        get: function () {
            return this._mappingMode;
        },
        set: function (value) {
            if (this._mappingMode == value)
                return;
            this._mappingMode = value;
        },
        enumerable: true,
        configurable: true
    });
    TextureBase.prototype.getNumImages = function () {
        return this._numImages;
    };
    TextureBase.prototype.setNumImages = function (value) {
        if (this._numImages == value)
            return;
        this._numImages = value;
        this._images.length = value;
        this._samplers.length = value;
        this.invalidate();
    };
    TextureBase.prototype.getImageAt = function (index) {
        return this._images[index];
    };
    TextureBase.prototype.setImageAt = function (image, index) {
        this._images[index] = image;
        this.invalidate();
    };
    TextureBase.prototype.getSamplerAt = function (index) {
        return this._samplers[index];
    };
    TextureBase.prototype.setSamplerAt = function (sampler, index) {
        this._samplers[index] = sampler;
        this.invalidate();
    };
    return TextureBase;
}(_awayjs_core.AssetBase));

var Single2DTexture = (function (_super) {
    __extends(Single2DTexture, _super);
    function Single2DTexture(image2D) {
        if (image2D === void 0) { image2D = null; }
        var _this = _super.call(this) || this;
        _this._mappingMode = exports.MappingMode.LINEAR;
        _this.setNumImages(1);
        _this.image2D = image2D;
        return _this;
    }
    Object.defineProperty(Single2DTexture.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return Single2DTexture.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Single2DTexture.prototype, "sampler2D", {
        /**
         *
         * @returns {Image2D}
         */
        get: function () {
            return this._samplers[0];
        },
        set: function (value) {
            if (this._samplers[0] == value)
                return;
            this.setSamplerAt(value, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Single2DTexture.prototype, "image2D", {
        /**
         *
         * @returns {Image2D}
         */
        get: function () {
            return this._images[0];
        },
        set: function (value) {
            if (this._images[0] == value)
                return;
            if (!ImageUtils.isImage2DValid(value))
                throw new _awayjs_core.ErrorBase("Invalid image2DData: Width and height must be power of 2 and cannot exceed 2048");
            this.setImageAt(value, 0);
        },
        enumerable: true,
        configurable: true
    });
    return Single2DTexture;
}(TextureBase));
Single2DTexture.assetType = "[texture Single2DTexture]";

/**
 * BasicMaterial forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var BasicMaterial = (function (_super) {
    __extends(BasicMaterial, _super);
    function BasicMaterial(imageColor, alpha) {
        if (imageColor === void 0) { imageColor = null; }
        if (alpha === void 0) { alpha = 1; }
        var _this = _super.call(this, imageColor, alpha) || this;
        _this._preserveAlpha = false;
        //set a texture if an image is present
        if (imageColor instanceof Image2D)
            _this.texture = new Single2DTexture();
        return _this;
    }
    Object.defineProperty(BasicMaterial.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return BasicMaterial.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasicMaterial.prototype, "preserveAlpha", {
        /**
         * Indicates whether alpha should be preserved - defaults to false
         */
        get: function () {
            return this._preserveAlpha;
        },
        set: function (value) {
            if (this._preserveAlpha == value)
                return;
            this._preserveAlpha = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BasicMaterial.prototype, "texture", {
        /**
         * The texture object to use for the albedo colour.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture == value)
                return;
            if (this._texture)
                this.removeTexture(this._texture);
            this._texture = value;
            if (this._texture)
                this.addTexture(this._texture);
            this.invalidateTexture();
        },
        enumerable: true,
        configurable: true
    });
    return BasicMaterial;
}(MaterialBase));
BasicMaterial.assetType = "[materials BasicMaterial]";

var SingleCubeTexture = (function (_super) {
    __extends(SingleCubeTexture, _super);
    function SingleCubeTexture(imageCube) {
        if (imageCube === void 0) { imageCube = null; }
        var _this = _super.call(this) || this;
        _this._mappingMode = exports.MappingMode.CUBE;
        _this.setNumImages(1);
        _this.imageCube = imageCube;
        return _this;
    }
    Object.defineProperty(SingleCubeTexture.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return SingleCubeTexture.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SingleCubeTexture.prototype, "samplerCube", {
        /**
         *
         * @returns {Image2D}
         */
        get: function () {
            return this._samplers[0];
        },
        set: function (value) {
            if (this._samplers[0] == value)
                return;
            this.setSamplerAt(value, 0);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SingleCubeTexture.prototype, "imageCube", {
        /**
         *
         * @returns {ImageCube}
         */
        get: function () {
            return this._images[0];
        },
        set: function (value) {
            if (this._images[0] == value)
                return;
            this.setImageAt(value, 0);
        },
        enumerable: true,
        configurable: true
    });
    return SingleCubeTexture;
}(TextureBase));
SingleCubeTexture.assetType = "[texture SingleCubeTexture]";

var DefaultMaterialManager = (function () {
    function DefaultMaterialManager() {
    }
    DefaultMaterialManager.getDefaultMaterial = function (renderable) {
        if (renderable === void 0) { renderable = null; }
        if (renderable != null && renderable.isAsset(Shape) && renderable.elements.isAsset(LineElements)) {
            if (!DefaultMaterialManager._defaultColorMaterial)
                DefaultMaterialManager.createDefaultColorMaterial();
            return DefaultMaterialManager._defaultColorMaterial;
        }
        if (renderable != null && renderable.assetType == "[asset Skybox]") {
            if (!DefaultMaterialManager._defaultCubeTextureMaterial)
                DefaultMaterialManager.createDefaultCubeTextureMaterial();
            return DefaultMaterialManager._defaultCubeTextureMaterial;
        }
        if (!DefaultMaterialManager._defaultTextureMaterial)
            DefaultMaterialManager.createDefaultTextureMaterial();
        return DefaultMaterialManager._defaultTextureMaterial;
    };
    DefaultMaterialManager.getDefaultTexture = function (renderable) {
        if (renderable === void 0) { renderable = null; }
        if (renderable != null && renderable.assetType == "[asset Skybox]") {
            if (!DefaultMaterialManager._defaultCubeTexture)
                DefaultMaterialManager.createDefaultCubeTexture();
            return DefaultMaterialManager._defaultCubeTexture;
        }
        if (!DefaultMaterialManager._defaultTexture)
            DefaultMaterialManager.createDefaultTexture();
        return DefaultMaterialManager._defaultTexture;
    };
    DefaultMaterialManager.getDefaultImage2D = function () {
        if (!DefaultMaterialManager._defaultBitmapImage2D)
            DefaultMaterialManager.createDefaultImage2D();
        return DefaultMaterialManager._defaultBitmapImage2D;
    };
    DefaultMaterialManager.getDefaultImageCube = function () {
        if (!DefaultMaterialManager._defaultBitmapImageCube)
            DefaultMaterialManager.createDefaultImageCube();
        return DefaultMaterialManager._defaultBitmapImageCube;
    };
    DefaultMaterialManager.getDefaultSampler = function () {
        if (!DefaultMaterialManager._defaultSampler2D)
            DefaultMaterialManager.createDefaultSampler2D();
        return DefaultMaterialManager._defaultSampler2D;
    };
    DefaultMaterialManager.createDefaultTexture = function () {
        DefaultMaterialManager._defaultTexture = new Single2DTexture();
        DefaultMaterialManager._defaultTexture.name = "defaultTexture";
    };
    DefaultMaterialManager.createDefaultCubeTexture = function () {
        DefaultMaterialManager._defaultCubeTexture = new SingleCubeTexture();
        DefaultMaterialManager._defaultCubeTexture.name = "defaultCubeTexture";
    };
    DefaultMaterialManager.createDefaultImageCube = function () {
        if (!DefaultMaterialManager._defaultBitmapImage2D)
            DefaultMaterialManager.createDefaultImage2D();
        var b = new BitmapImageCube(DefaultMaterialManager._defaultBitmapImage2D.width);
        for (var i = 0; i < 6; i++)
            b.draw(i, DefaultMaterialManager._defaultBitmapImage2D);
        DefaultMaterialManager._defaultBitmapImageCube = b;
    };
    DefaultMaterialManager.createDefaultImage2D = function () {
        var b = new BitmapImage2D(8, 8, false, 0x000000);
        //create chekerboard
        var i, j;
        for (i = 0; i < 8; i++)
            for (j = 0; j < 8; j++)
                if ((j & 1) ^ (i & 1))
                    b.setPixel(i, j, 0XFFFFFF);
        DefaultMaterialManager._defaultBitmapImage2D = b;
    };
    DefaultMaterialManager.createDefaultTextureMaterial = function () {
        if (!DefaultMaterialManager._defaultTexture)
            DefaultMaterialManager.createDefaultTexture();
        DefaultMaterialManager._defaultTextureMaterial = new BasicMaterial();
        DefaultMaterialManager._defaultTextureMaterial.texture = DefaultMaterialManager._defaultTexture;
        DefaultMaterialManager._defaultTextureMaterial.name = "defaultTextureMaterial";
    };
    DefaultMaterialManager.createDefaultCubeTextureMaterial = function () {
        if (!DefaultMaterialManager._defaultCubeTexture)
            DefaultMaterialManager.createDefaultCubeTexture();
        DefaultMaterialManager._defaultCubeTextureMaterial = new BasicMaterial();
        DefaultMaterialManager._defaultCubeTextureMaterial.texture = DefaultMaterialManager._defaultCubeTexture;
        DefaultMaterialManager._defaultCubeTextureMaterial.name = "defaultCubeTextureMaterial";
    };
    DefaultMaterialManager.createDefaultColorMaterial = function () {
        DefaultMaterialManager._defaultColorMaterial = new BasicMaterial(0xFFFFFF);
        DefaultMaterialManager._defaultColorMaterial.name = "defaultColorMaterial";
    };
    DefaultMaterialManager.createDefaultSampler2D = function () {
        DefaultMaterialManager._defaultSampler2D = new Sampler2D();
    };
    return DefaultMaterialManager;
}());

/**
 *
 * Graphics is a collection of Shapes, each of which contain the actual geometrical data such as vertices,
 * normals, uvs, etc. It also contains a reference to an animation class, which defines how the geometry moves.
 * A Graphics object is assigned to a Sprite, a scene graph occurence of the geometry, which in turn assigns
 * the SubGeometries to its respective TriangleGraphic objects.
 *
 *
 *
 *
 * @class Graphics
 */
var Graphics = (function (_super) {
    __extends(Graphics, _super);
    /**
     * Creates a new Graphics object.
     */
    function Graphics(entity) {
        if (entity === void 0) { entity = null; }
        var _this = _super.call(this) || this;
        _this._boxBoundsInvalid = true;
        _this._sphereBoundsInvalid = true;
        _this._shapes = [];
        _this._current_position = new _awayjs_core.Point();
        _this._scaleX = 1;
        _this._scaleY = 1;
        // todo: this is a temp workarpound to prevent strokes from getting scaled, if they are not coming from awd
        _this.scaleStrokes = LineScaleMode.NONE;
        _this._drawingDirty = false;
        //store associated entity object, otherwise assign itself as entity
        _this._entity = entity;
        _this._drawingDirty = false;
        _this._current_position = new _awayjs_core.Point();
        _this._queued_fill_pathes = [];
        _this._queued_stroke_pathes = [];
        _this._active_fill_path = null;
        _this._active_stroke_path = null;
        _this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
        _this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
        _this._onAddMaterialDelegate = function (event) { return _this._onAddMaterial(event); };
        _this._onRemoveMaterialDelegate = function (event) { return _this._onRemoveMaterial(event); };
        return _this;
    }
    Graphics.getGraphics = function (entity) {
        if (Graphics._pool.length) {
            var graphics = Graphics._pool.pop();
            graphics._entity = entity;
            return graphics;
        }
        return new Graphics(entity);
    };
    Graphics.storeGraphics = function (graphics) {
        graphics.clear();
        Graphics._pool.push(graphics);
    };
    Graphics.prototype.updateScale = function (scaleX, scaleY) {
        if (this._scaleX == scaleX && this._scaleY == scaleY)
            return;
        this._scaleX = scaleX;
        this._scaleY = scaleY;
        var len = this._shapes.length;
        var doInvalid = false;
        for (var i = 0; i < len; i++) {
            if (this._shapes[i].isStroke) {
                doInvalid = true;
                GraphicsFactoryStrokes.updateStrokesForShape(this._shapes[i], this._scaleX, this.scaleStrokes);
            }
        }
        if (doInvalid) {
            this.invalidate();
        }
    };
    Graphics.prototype.updateSlice9 = function (scaleX, scaleY) {
        if (this._scaleX == scaleX && this._scaleY == scaleY)
            return;
        this._scaleX = scaleX;
        this._scaleY = scaleY;
        var len = this._shapes.length;
        for (var i = 0; i < len; i++) {
            ElementsUtils.updateTriangleGraphicsSlice9(this._shapes[i].elements, this.originalSlice9Size, scaleX, scaleY);
        }
        this.invalidate();
    };
    Object.defineProperty(Graphics.prototype, "assetType", {
        get: function () {
            return Graphics.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graphics.prototype, "count", {
        get: function () {
            return (this._shapes.length + this._queued_stroke_pathes.length + this._queued_fill_pathes.length);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graphics.prototype, "animator", {
        /**
         * Defines the animator of the graphics object.  Default value is <code>null</code>.
         */
        get: function () {
            return this._animator;
        },
        set: function (value) {
            if (this._animator)
                this._animator.removeOwner(this._entity);
            this._animator = value;
            if (this._animator)
                this._animator.addOwner(this._entity);
            if (this._material) {
                this._material.iRemoveOwner(this._entity);
                this._material.iAddOwner(this._entity);
            }
            var shape;
            var len = this._shapes.length;
            for (var i = 0; i < len; ++i) {
                shape = this._shapes[i];
                // cause material to be unregistered and registered again to work with the new animation type (if possible)
                if (shape.material && shape.material != this._material) {
                    shape.material.iRemoveOwner(this._entity);
                    shape.material.iAddOwner(this._entity);
                }
                //invalidate any existing shape objects in case they need to pull new elements
                shape.invalidateElements();
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graphics.prototype, "style", {
        /**
         *
         */
        get: function () {
            return this._style;
        },
        set: function (value) {
            if (this._style == value)
                return;
            if (this._style)
                this._style.removeEventListener(StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this._style = value;
            if (this._style)
                this._style.addEventListener(StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this.invalidateMaterials();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graphics.prototype, "queued_stroke_pathes", {
        get: function () {
            return this._queued_stroke_pathes;
        },
        set: function (value) {
            this._queued_stroke_pathes = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graphics.prototype, "queued_fill_pathes", {
        get: function () {
            return this._queued_fill_pathes;
        },
        set: function (value) {
            this._queued_fill_pathes = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Graphics.prototype, "material", {
        /**
         * The material with which to render the Graphics.
         */
        get: function () {
            return this._material;
        },
        set: function (value) {
            if (value == this._material)
                return;
            if (this._material && !this._isShapeMaterial(this._material))
                this._material.iRemoveOwner(this._entity);
            this._material = value;
            if (this._material && !this._isShapeMaterial(this._material))
                this._material.iAddOwner(this._entity);
            this.invalidateMaterials();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a GraphicBase wrapping a Elements.
     *
     * @param elements
     */
    Graphics.prototype.addShape = function (shape) {
        var shapeIndex = this.getShapeIndex(shape);
        if (shapeIndex != -1)
            this.removeShapeAt(shapeIndex);
        this._shapes.push(shape);
        shape.addEventListener(ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
        //shape.addEventListener(ShapeEvent.ADD_MATERIAL, this._onAddMaterialDelegate);
        //shape.addEventListener(ShapeEvent.REMOVE_MATERIAL, this._onRemoveMaterialDelegate);
        this.invalidate();
        return shape;
    };
    Graphics.prototype.removeShape = function (shape) {
        var shapeIndex = this.getShapeIndex(shape);
        if (shapeIndex == -1)
            throw new _awayjs_core.ArgumentError("Shape parameter is not a shape of the caller");
        this.removeShapeAt(shapeIndex);
    };
    Graphics.prototype.removeShapeAt = function (index) {
        if (index < 0 || index >= this._shapes.length)
            throw new _awayjs_core.RangeError("Index is out of range");
        var shape = this._shapes.splice(index, 1)[0];
        shape.removeEventListener(ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
        //shape.removeEventListener(ShapeEvent.ADD_MATERIAL, this._onAddMaterialDelegate);
        //shape.removeEventListener(ShapeEvent.REMOVE_MATERIAL, this._onRemoveMaterialDelegate);
        this.invalidate();
    };
    Graphics.prototype.getShapeAt = function (index) {
        return this._shapes[index];
    };
    Graphics.prototype.getShapeIndex = function (shape) {
        return this._shapes.indexOf(shape);
    };
    Graphics.prototype.applyTransformation = function (transform) {
        var len = this._shapes.length;
        for (var i = 0; i < len; ++i) {
            this._shapes[i].applyTransformation(transform);
        }
    };
    Graphics.prototype.copyTo = function (graphics, cloneShapes) {
        if (cloneShapes === void 0) { cloneShapes = false; }
        graphics.material = this._material;
        graphics.style = this._style;
        graphics.particles = this.particles;
        graphics.numParticles = this.numParticles;
        graphics.scaleStrokes = this.scaleStrokes;
        if (this.slice9Rectangle) {
            graphics.slice9Rectangle = new _awayjs_core.Rectangle();
            graphics.slice9Rectangle.copyFrom(this.slice9Rectangle);
            graphics.originalSlice9Size = new _awayjs_core.Rectangle();
            graphics.originalSlice9Size.copyFrom(this.originalSlice9Size);
            graphics.minSlice9Width = this.minSlice9Width;
            graphics.minSlice9Height = this.minSlice9Height;
        }
        graphics._addShapes(this._shapes, cloneShapes);
        if (this._animator)
            graphics.animator = this._animator.clone();
    };
    /**
     * Scales the geometry.
     * @param scale The amount by which to scale.
     */
    Graphics.prototype.scale = function (scale) {
        var len = this._shapes.length;
        for (var i = 0; i < len; ++i)
            this._shapes[i].scale(scale);
    };
    Graphics.prototype.clearInternal = function () {
        for (var i = this._shapes.length - 1; i >= 0; i--)
            this._shapes[i].clear();
        //this.invalidateElements();
    };
    Graphics.prototype.clear = function () {
        var shape;
        var len = this._shapes.length;
        for (var i = 0; i < len; i++) {
            shape = this._shapes[i];
            shape.clear();
            shape.removeEventListener(ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
            shape.removeEventListener(ShapeEvent.ADD_MATERIAL, this._onAddMaterialDelegate);
            shape.removeEventListener(ShapeEvent.REMOVE_MATERIAL, this._onRemoveMaterialDelegate);
        }
        this._shapes.length = 0;
        this.invalidate();
        this._active_fill_path = null;
        this._active_stroke_path = null;
        this._queued_fill_pathes.length = 0;
        this._queued_stroke_pathes.length = 0;
        this._drawingDirty = false;
        //this.invalidateElements();
    };
    /**
     * Clears all resources used by the Graphics object, including SubGeometries.
     */
    Graphics.prototype.dispose = function () {
        this.material = null;
        this.clear();
        if (this._animator)
            this._animator.dispose();
    };
    /**
     * Scales the uv coordinates (tiling)
     * @param scaleU The amount by which to scale on the u axis. Default is 1;
     * @param scaleV The amount by which to scale on the v axis. Default is 1;
     */
    Graphics.prototype.scaleUV = function (scaleU, scaleV) {
        if (scaleU === void 0) { scaleU = 1; }
        if (scaleV === void 0) { scaleV = 1; }
        var len = this._shapes.length;
        for (var i = 0; i < len; ++i)
            this._shapes[i].scaleUV(scaleU, scaleV);
    };
    Graphics.prototype.getBoxBounds = function () {
        if (this._drawingDirty) {
            this.endFill();
        }
        if (this._boxBoundsInvalid) {
            this._boxBoundsInvalid = false;
            if (!this._boxBounds)
                this._boxBounds = new _awayjs_core.Box();
            this._boxBounds.setEmpty();
            var numShapes = this._shapes.length;
            if (numShapes) {
                var shapeBox;
                var first = true;
                for (var i = 0; i < numShapes; i++) {
                    shapeBox = this._shapes[i].getBoxBounds();
                    if (shapeBox.isEmpty())
                        continue;
                    if (first) {
                        first = false;
                        this._boxBounds.copyFrom(shapeBox);
                    }
                    else {
                        this._boxBounds = this._boxBounds.union(shapeBox, this._boxBounds);
                    }
                }
            }
        }
        return this._boxBounds;
    };
    Graphics.prototype.getSphereBounds = function (center, target) {
        if (target === void 0) { target = null; }
        var len = this._shapes.length;
        for (var i = 0; i < len; i++) {
            target = this._shapes[i].getSphereBounds(center, target);
        }
        return target;
    };
    Graphics.prototype.invalidate = function () {
        _super.prototype.invalidate.call(this);
        this._boxBoundsInvalid = true;
        this._sphereBoundsInvalid = true;
    };
    Graphics.prototype.invalidateMaterials = function () {
        var len = this._shapes.length;
        for (var i = 0; i < len; ++i)
            this._shapes[i].invalidateMaterial();
    };
    Graphics.prototype.invalidateElements = function () {
        var len = this._shapes.length;
        for (var i = 0; i < len; ++i)
            this._shapes[i].invalidateElements();
    };
    Graphics.prototype._hitTestPointInternal = function (x, y) {
        //TODO: handle lines as well
        var len = this._shapes.length;
        for (var i = 0; i < len; i++)
            if (this._shapes[i].hitTestPoint(x, y, 0))
                return true;
        return false;
    };
    Graphics.prototype.acceptTraverser = function (traverser) {
        if (this._drawingDirty) {
            this.endFill();
        }
        var len = this._shapes.length;
        for (var i = len - 1; i >= 0; i--)
            traverser[this._shapes[i].elements.traverseName](this._shapes[i]);
    };
    Graphics.prototype._onInvalidateProperties = function (event) {
        this.invalidateMaterials();
    };
    Graphics.prototype._onInvalidateVertices = function (event) {
        //callback for bounds update
        if (event.attributesView != event.target.positions)
            return;
        this.invalidate();
    };
    Graphics.prototype._onAddMaterial = function (event) {
        var material = event.shape.material;
        if (material != this._material)
            material.iAddOwner(this._entity);
    };
    Graphics.prototype._onRemoveMaterial = function (event) {
        var material = event.shape.material;
        if (material != this._material)
            material.iRemoveOwner(this._entity);
    };
    Graphics.prototype.draw_fills = function () {
        GraphicsFactoryFills.draw_pathes(this);
    };
    Graphics.prototype.draw_strokes = function () {
        GraphicsFactoryStrokes.draw_pathes(this);
    };
    /**
     * Fills a drawing area with a bitmap image. The bitmap can be repeated or
     * tiled to fill the area. The fill remains in effect until you call the
     * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
     * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
     * method. Calling the <code>clear()</code> method clears the fill.
     *
     * <p>The application renders the fill whenever three or more points are
     * drawn, or when the <code>endFill()</code> method is called. </p>
     *
     * @param bitmap A transparent or opaque bitmap image that contains the bits
     *               to be displayed.
     * @param matrix A matrix object(of the flash.geom.Matrix class), which you
     *               can use to define transformations on the bitmap. For
     *               example, you can use the following matrix to rotate a bitmap
     *               by 45 degrees(pi/4 radians):
     * @param repeat If <code>true</code>, the bitmap image repeats in a tiled
     *               pattern. If <code>false</code>, the bitmap image does not
     *               repeat, and the edges of the bitmap are used for any fill
     *               area that extends beyond the bitmap.
     *
     *               <p>For example, consider the following bitmap(a 20 x
     *               20-pixel checkerboard pattern):</p>
     *
     *               <p>When <code>repeat</code> is set to <code>true</code>(as
     *               in the following example), the bitmap fill repeats the
     *               bitmap:</p>
     *
     *               <p>When <code>repeat</code> is set to <code>false</code>,
     *               the bitmap fill uses the edge pixels for the fill area
     *               outside the bitmap:</p>
     * @param smooth If <code>false</code>, upscaled bitmap images are rendered
     *               by using a nearest-neighbor algorithm and look pixelated. If
     *               <code>true</code>, upscaled bitmap images are rendered by
     *               using a bilinear algorithm. Rendering by using the nearest
     *               neighbor algorithm is faster.
     */
    Graphics.prototype.beginBitmapFill = function (bitmap, matrix, repeat, smooth) {
        if (matrix === void 0) { matrix = null; }
        if (repeat === void 0) { repeat = true; }
        if (smooth === void 0) { smooth = false; }
        this.draw_fills();
        this._drawingDirty = true;
        // start a new fill path
        this._active_fill_path = new GraphicsPath();
        // todo: create bitmap fill style
        this._active_fill_path.style = new GraphicsFillStyle(0xffffff, 1);
        if (this._current_position.x != 0 || this._current_position.y != 0)
            this._active_fill_path.moveTo(this._current_position.x, this._current_position.y);
        this._queued_fill_pathes.push(this._active_fill_path);
        this.invalidate();
    };
    /**
     * Specifies a simple one-color fill that subsequent calls to other Graphics
     * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) use
     * when drawing. The fill remains in effect until you call the
     * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
     * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
     * method. Calling the <code>clear()</code> method clears the fill.
     *
     * <p>The application renders the fill whenever three or more points are
     * drawn, or when the <code>endFill()</code> method is called.</p>
     *
     * @param color The color of the fill(0xRRGGBB).
     * @param alpha The alpha value of the fill(0.0 to 1.0).
     */
    Graphics.prototype.beginFill = function (color /*int*/, alpha) {
        if (alpha === void 0) { alpha = 1; }
        if (color == 0) {
            color = 0x010101;
        }
        this.draw_fills();
        this._drawingDirty = true;
        // start a new fill path
        this._active_fill_path = new GraphicsPath();
        this._active_fill_path.style = new GraphicsFillStyle(color, alpha);
        if (this._current_position.x != 0 || this._current_position.y != 0)
            this._active_fill_path.moveTo(this._current_position.x, this._current_position.y);
        this._queued_fill_pathes.push(this._active_fill_path);
        this.invalidate();
    };
    /**
     * Specifies a gradient fill used by subsequent calls to other Graphics
     * methods(such as <code>lineTo()</code> or <code>drawCircle()</code>) for
     * the object. The fill remains in effect until you call the
     * <code>beginFill()</code>, <code>beginBitmapFill()</code>,
     * <code>beginGradientFill()</code>, or <code>beginShaderFill()</code>
     * method. Calling the <code>clear()</code> method clears the fill.
     *
     * <p>The application renders the fill whenever three or more points are
     * drawn, or when the <code>endFill()</code> method is called. </p>
     *
     * @param type                A value from the GradientType class that
     *                            specifies which gradient type to use:
     *                            <code>GradientType.LINEAR</code> or
     *                            <code>GradientType.RADIAL</code>.
     * @param colors              An array of RGB hexadecimal color values used
     *                            in the gradient; for example, red is 0xFF0000,
     *                            blue is 0x0000FF, and so on. You can specify
     *                            up to 15 colors. For each color, specify a
     *                            corresponding value in the alphas and ratios
     *                            parameters.
     * @param alphas              An array of alpha values for the corresponding
     *                            colors in the colors array; valid values are 0
     *                            to 1. If the value is less than 0, the default
     *                            is 0. If the value is greater than 1, the
     *                            default is 1.
     * @param ratios              An array of color distribution ratios; valid
     *                            values are 0-255. This value defines the
     *                            percentage of the width where the color is
     *                            sampled at 100%. The value 0 represents the
     *                            left position in the gradient box, and 255
     *                            represents the right position in the gradient
     *                            box.
     * @param matrix              A transformation matrix as defined by the
     *                            flash.geom.Matrix class. The flash.geom.Matrix
     *                            class includes a
     *                            <code>createGradientBox()</code> method, which
     *                            lets you conveniently set up the matrix for use
     *                            with the <code>beginGradientFill()</code>
     *                            method.
     * @param spreadMethod        A value from the SpreadMethod class that
     *                            specifies which spread method to use, either:
     *                            <code>SpreadMethod.PAD</code>,
     *                            <code>SpreadMethod.REFLECT</code>, or
     *                            <code>SpreadMethod.REPEAT</code>.
     *
     *                            <p>For example, consider a simple linear
     *                            gradient between two colors:</p>
     *
     *                            <p>This example uses
     *                            <code>SpreadMethod.PAD</code> for the spread
     *                            method, and the gradient fill looks like the
     *                            following:</p>
     *
     *                            <p>If you use <code>SpreadMethod.REFLECT</code>
     *                            for the spread method, the gradient fill looks
     *                            like the following:</p>
     *
     *                            <p>If you use <code>SpreadMethod.REPEAT</code>
     *                            for the spread method, the gradient fill looks
     *                            like the following:</p>
     * @param interpolationMethod A value from the InterpolationMethod class that
     *                            specifies which value to use:
     *                            <code>InterpolationMethod.LINEAR_RGB</code> or
     *                            <code>InterpolationMethod.RGB</code>
     *
     *                            <p>For example, consider a simple linear
     *                            gradient between two colors(with the
     *                            <code>spreadMethod</code> parameter set to
     *                            <code>SpreadMethod.REFLECT</code>). The
     *                            different interpolation methods affect the
     *                            appearance as follows: </p>
     * @param focalPointRatio     A number that controls the location of the
     *                            focal point of the gradient. 0 means that the
     *                            focal point is in the center. 1 means that the
     *                            focal point is at one border of the gradient
     *                            circle. -1 means that the focal point is at the
     *                            other border of the gradient circle. A value
     *                            less than -1 or greater than 1 is rounded to -1
     *                            or 1. For example, the following example shows
     *                            a <code>focalPointRatio</code> set to 0.75:
     * @throws ArgumentError If the <code>type</code> parameter is not valid.
     */
    Graphics.prototype.beginGradientFill = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
        if (matrix === void 0) { matrix = null; }
        if (spreadMethod === void 0) { spreadMethod = "pad"; }
        if (interpolationMethod === void 0) { interpolationMethod = "rgb"; }
        if (focalPointRatio === void 0) { focalPointRatio = 0; }
        this.draw_fills();
        // start a new fill path
        this._drawingDirty = true;
        this._active_fill_path = new GraphicsPath();
        // todo: create gradient fill style
        //this._active_fill_path.style=new GraphicsFillStyle(colors[0], alphas[0]);//, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio);
        this._active_fill_path.style = new GradientFillStyle(type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio);
        if (this._current_position.x != 0 || this._current_position.y != 0)
            this._active_fill_path.moveTo(this._current_position.x, this._current_position.y);
        this._queued_fill_pathes.push(this._active_fill_path);
        this.invalidate();
    };
    /**
     * Copies all of drawing commands from the source Graphics object into the
     * calling Graphics object.
     *
     * @param sourceGraphics The Graphics object from which to copy the drawing
     *                       commands.
     */
    Graphics.prototype.copyFrom = function (sourceGraphics) {
        sourceGraphics.copyTo(this);
    };
    /**
     * Draws a cubic Bezier curve from the current drawing position to the
     * specified anchor point. Cubic Bezier curves consist of two anchor points
     * and two control points. The curve interpolates the two anchor points and
     * curves toward the two control points.
     *
     * The four points you use to draw a cubic Bezier curve with the
     * <code>cubicCurveTo()</code> method are as follows:
     *
     * <ul>
     *   <li>The current drawing position is the first anchor point. </li>
     *   <li>The anchorX and anchorY parameters specify the second anchor point.
     *   </li>
     *   <li>The <code>controlX1</code> and <code>controlY1</code> parameters
     *   specify the first control point.</li>
     *   <li>The <code>controlX2</code> and <code>controlY2</code> parameters
     *   specify the second control point.</li>
     * </ul>
     *
     * If you call the <code>cubicCurveTo()</code> method before calling the
     * <code>moveTo()</code> method, your curve starts at position (0, 0).
     *
     * If the <code>cubicCurveTo()</code> method succeeds, the Flash runtime sets
     * the current drawing position to (<code>anchorX</code>,
     * <code>anchorY</code>). If the <code>cubicCurveTo()</code> method fails,
     * the current drawing position remains unchanged.
     *
     * If your movie clip contains content created with the Flash drawing tools,
     * the results of calls to the <code>cubicCurveTo()</code> method are drawn
     * underneath that content.
     *
     * @param controlX1 Specifies the horizontal position of the first control
     *                  point relative to the registration point of the parent
     *                  display object.
     * @param controlY1 Specifies the vertical position of the first control
     *                  point relative to the registration point of the parent
     *                  display object.
     * @param controlX2 Specifies the horizontal position of the second control
     *                  point relative to the registration point of the parent
     *                  display object.
     * @param controlY2 Specifies the vertical position of the second control
     *                  point relative to the registration point of the parent
     *                  display object.
     * @param anchorX   Specifies the horizontal position of the anchor point
     *                  relative to the registration point of the parent display
     *                  object.
     * @param anchorY   Specifies the vertical position of the anchor point
     *                  relative to the registration point of the parent display
     *                  object.
     */
    Graphics.prototype.cubicCurveTo = function (controlX1, controlY1, controlX2, controlY2, anchorX, anchorY) {
        throw new _awayjs_core.PartialImplementationError("cubicCurveTo");
        /*
         t = 0.5; // given example value
         x = (1 - t) * (1 - t) * p[0].x + 2 * (1 - t) * t * p[1].x + t * t * p[2].x;
         y = (1 - t) * (1 - t) * p[0].y + 2 * (1 - t) * t * p[1].y + t * t * p[2].y;

         this.queued_command_types.push(Graphics.CMD_BEZIER);
         this.queued_command_data.push(controlX1);
         this.queued_command_data.push(controlY1);
         this.queued_command_data.push(controlX2);
         this.queued_command_data.push(controlY2);
         this.queued_command_data.push(anchorX);
         this.queued_command_data.push(anchorY);

         // todo: somehow convert cubic bezier curve into 2 quadric curves...

         this.draw_direction+=0;
         */
    };
    /**
     * Draws a curve using the current line style from the current drawing
     * position to(anchorX, anchorY) and using the control point that
     * (<code>controlX</code>, <code>controlY</code>) specifies. The current
     * drawing position is then set to(<code>anchorX</code>,
     * <code>anchorY</code>). If the movie clip in which you are drawing contains
     * content created with the Flash drawing tools, calls to the
     * <code>curveTo()</code> method are drawn underneath this content. If you
     * call the <code>curveTo()</code> method before any calls to the
     * <code>moveTo()</code> method, the default of the current drawing position
     * is(0, 0). If any of the parameters are missing, this method fails and the
     * current drawing position is not changed.
     *
     * <p>The curve drawn is a quadratic Bezier curve. Quadratic Bezier curves
     * consist of two anchor points and one control point. The curve interpolates
     * the two anchor points and curves toward the control point. </p>
     *
     * @param controlX A number that specifies the horizontal position of the
     *                 control point relative to the registration point of the
     *                 parent display object.
     * @param controlY A number that specifies the vertical position of the
     *                 control point relative to the registration point of the
     *                 parent display object.
     * @param anchorX  A number that specifies the horizontal position of the
     *                 next anchor point relative to the registration point of
     *                 the parent display object.
     * @param anchorY  A number that specifies the vertical position of the next
     *                 anchor point relative to the registration point of the
     *                 parent display object.
     */
    Graphics.prototype.curveTo = function (controlX, controlY, anchorX, anchorY) {
        this._drawingDirty = true;
        if (this._active_fill_path != null) {
            this._active_fill_path.curveTo(controlX, controlY, anchorX, anchorY);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.curveTo(controlX, controlY, anchorX, anchorY);
        }
        this._current_position.x = anchorX;
        this._current_position.y = anchorY;
    };
    /**
     * Draws a circle. Set the line style, fill, or both before you call the
     * <code>drawCircle()</code> method, by calling the <code>linestyle()</code>,
     * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
     * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
     * method.
     *
     * @param x      The <i>x</i> location of the center of the circle relative
     *               to the registration point of the parent display object(in
     *               pixels).
     * @param y      The <i>y</i> location of the center of the circle relative
     *               to the registration point of the parent display object(in
     *               pixels).
     * @param radius The radius of the circle(in pixels).
     */
    Graphics.prototype.drawCircle = function (x, y, radius) {
        this._drawingDirty = true;
        //var radius2=radius*1.065;
        if (this._active_fill_path != null) {
            this._active_fill_path.moveTo(x, y);
            /*
            for(var i=8; i>=0;i--){

                var degree = (i) *(360/8)*Math.PI/180;
                var degree2 = degree + ((360/16)*Math.PI/180);
                this._active_fill_path.curveTo(x-(Math.cos(degree2)*radius2), y+(Math.sin(degree2)*radius2),x-(Math.cos(degree)*radius), y+(Math.sin(degree)*radius));
            }*/
            var r = radius;
            if (this._active_stroke_path != null) {
                r -= this._active_stroke_path.style.thickness / 2;
            }
            GraphicsFactoryHelper.drawElipse(x, y, r, r, this._active_fill_path.verts, 0, 360, 5, false);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.moveTo(x, y);
            /*
                        var radius2=radius*0.93;
                        this._active_stroke_path.curveTo(x-(radius2), y+(radius2), x-radius, y);
                        this._active_stroke_path.curveTo(x-(radius2), y-(radius2), x, y-radius);
                        this._active_stroke_path.curveTo(x+(radius2), y-(radius2), x+radius, y);
                        this._active_stroke_path.curveTo(x+(radius2), y+(radius2), x, y+radius);
                        */
            GraphicsFactoryHelper.drawElipseStrokes(x, y, radius, radius, this._active_stroke_path.verts, 0, 360, 5, this._active_stroke_path.style.thickness / 2, false);
        }
    };
    /**
     * Draws an ellipse. Set the line style, fill, or both before you call the
     * <code>drawEllipse()</code> method, by calling the
     * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
     * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
     * <code>beginBitmapFill()</code> method.
     *
     * @param x      The <i>x</i> location of the top-left of the bounding-box of
     *               the ellipse relative to the registration point of the parent
     *               display object(in pixels).
     * @param y      The <i>y</i> location of the top left of the bounding-box of
     *               the ellipse relative to the registration point of the parent
     *               display object(in pixels).
     * @param width  The width of the ellipse(in pixels).
     * @param height The height of the ellipse(in pixels).
     */
    Graphics.prototype.drawEllipse = function (x, y, width, height) {
        this._drawingDirty = true;
        //var radius2=radius*1.065;
        if (this._active_fill_path != null) {
            this._active_fill_path.moveTo(x, y);
            /*
             for(var i=8; i>=0;i--){

             var degree = (i) *(360/8)*Math.PI/180;
             var degree2 = degree + ((360/16)*Math.PI/180);
             this._active_fill_path.curveTo(x-(Math.cos(degree2)*radius2), y+(Math.sin(degree2)*radius2),x-(Math.cos(degree)*radius), y+(Math.sin(degree)*radius));
             }*/
            var w = width;
            var h = height;
            if (this._active_stroke_path != null) {
                w -= this._active_stroke_path.style.thickness / 2;
                h -= this._active_stroke_path.style.thickness / 2;
            }
            GraphicsFactoryHelper.drawElipse(x, y, w, h, this._active_fill_path.verts, 0, 360, 5, false);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.moveTo(x, y);
            GraphicsFactoryHelper.drawElipseStrokes(x, y, width, height, this._active_stroke_path.verts, 0, 360, 5, this._active_stroke_path.style.thickness / 2, false);
        }
    };
    /**
     * Submits a series of IGraphicsData instances for drawing. This method
     * accepts a Vector containing objects including paths, fills, and strokes
     * that implement the IGraphicsData interface. A Vector of IGraphicsData
     * instances can refer to a part of a shape, or a complex fully defined set
     * of data for rendering a complete shape.
     *
     * <p> Graphics paths can contain other graphics paths. If the
     * <code>graphicsData</code> Vector includes a path, that path and all its
     * sub-paths are rendered during this operation. </p>
     *
     */
    Graphics.prototype.drawGraphicsData = function (graphicsData) {
        //this.draw_fills();
        /*
         for (var i:number=0; i<graphicsData.length; i++){
         //todo
         if(graphicsData[i].dataType=="beginFill"){

         }
         else if(graphicsData[i].dataType=="endFill"){

         }
         else if(graphicsData[i].dataType=="endFill"){

         }
         else if(graphicsData[i].dataType=="Path"){

         }

         }
         */
    };
    /**
     * Submits a series of commands for drawing. The <code>drawPath()</code>
     * method uses vector arrays to consolidate individual <code>moveTo()</code>,
     * <code>lineTo()</code>, and <code>curveTo()</code> drawing commands into a
     * single call. The <code>drawPath()</code> method parameters combine drawing
     * commands with x- and y-coordinate value pairs and a drawing direction. The
     * drawing commands are values from the GraphicsPathCommand class. The x- and
     * y-coordinate value pairs are Numbers in an array where each pair defines a
     * coordinate location. The drawing direction is a value from the
     * GraphicsPathWinding class.
     *
     * <p> Generally, drawings render faster with <code>drawPath()</code> than
     * with a series of individual <code>lineTo()</code> and
     * <code>curveTo()</code> methods. </p>
     *
     * <p> The <code>drawPath()</code> method uses a uses a floating computation
     * so rotation and scaling of shapes is more accurate and gives better
     * results. However, curves submitted using the <code>drawPath()</code>
     * method can have small sub-pixel alignment errors when used in conjunction
     * with the <code>lineTo()</code> and <code>curveTo()</code> methods. </p>
     *
     * <p> The <code>drawPath()</code> method also uses slightly different rules
     * for filling and drawing lines. They are: </p>
     *
     * <ul>
     *   <li>When a fill is applied to rendering a path:
     * <ul>
     *   <li>A sub-path of less than 3 points is not rendered.(But note that the
     * stroke rendering will still occur, consistent with the rules for strokes
     * below.)</li>
     *   <li>A sub-path that isn't closed(the end point is not equal to the
     * begin point) is implicitly closed.</li>
     * </ul>
     * </li>
     *   <li>When a stroke is applied to rendering a path:
     * <ul>
     *   <li>The sub-paths can be composed of any number of points.</li>
     *   <li>The sub-path is never implicitly closed.</li>
     * </ul>
     * </li>
     * </ul>
     *
     * @param winding Specifies the winding rule using a value defined in the
     *                GraphicsPathWinding class.
     */
    Graphics.prototype.drawPath = function (commands, data, winding) {
        //todo
        /*
         if(this._active_fill_path!=null){
         this._active_fill_path.curveTo(controlX, controlY, anchorX, anchorY);
         }
         if(this._active_stroke_path!=null){
         this._active_stroke_path.curveTo(controlX, controlY, anchorX, anchorY);
         }
         this._current_position.x=anchorX;
         this._current_position.y=anchorY;
         */
    };
    /**
     * Draws a rectangle. Set the line style, fill, or both before you call the
     * <code>drawRect()</code> method, by calling the <code>linestyle()</code>,
     * <code>lineGradientStyle()</code>, <code>beginFill()</code>,
     * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
     * method.
     *
     * @param x      A number indicating the horizontal position relative to the
     *               registration point of the parent display object(in pixels).
     * @param y      A number indicating the vertical position relative to the
     *               registration point of the parent display object(in pixels).
     * @param width  The width of the rectangle(in pixels).
     * @param height The height of the rectangle(in pixels).
     * @throws ArgumentError If the <code>width</code> or <code>height</code>
     *                       parameters are not a number
     *                      (<code>Number.NaN</code>).
     */
    Graphics.prototype.drawRect = function (x, y, width, height) {
        this._drawingDirty = true;
        if (this._active_fill_path != null) {
            this._active_fill_path.moveTo(x, y);
            /*
            this._active_fill_path.lineTo(x+width, y);
            this._active_fill_path.lineTo(x+width, y+height);
            this._active_fill_path.lineTo(x, y+height);
            this._active_fill_path.lineTo(x, y);
            */
            var w = width;
            var h = height;
            var t = 0;
            if (this._active_stroke_path != null) {
                t = this._active_stroke_path.style.thickness / 2;
                w -= this._active_stroke_path.style.thickness;
                h -= this._active_stroke_path.style.thickness;
            }
            GraphicsFactoryHelper.addTriangle(x + t, y + h + t, x + t, y + t, x + w + t, y + t, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + t, y + h + t, x + t + w, y + t, x + w + t, y + h + t, 0, this._active_fill_path.verts, false);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.moveTo(x, y);
            //var t:number=(<GraphicsStrokeStyle>this._active_stroke_path.style).thickness/2;
            // todo: respect Jointstyle here (?)
            /*
            GraphicsFactoryHelper.addTriangle(x-t, y+height+t, x-t, y-t, x+t, y+t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x-t, y+height+t, x+t, y+height-t, x+t, y+t, 0, this._active_stroke_path.verts, false);

            GraphicsFactoryHelper.addTriangle(x-t, y-t, x+width+t, y-t, x+t, y+t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x+t, y+t, x+width+t, y-t, x+width-t, y+t, 0, this._active_stroke_path.verts, false);

            GraphicsFactoryHelper.addTriangle(x+width-t, y+height-t, x+width-t, y+t, x+width+t, y+height+t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x+width+t, y+height+t, x+width+t, y-t, x+width-t, y+t, 0, this._active_stroke_path.verts, false);

            GraphicsFactoryHelper.addTriangle(x-t, y+height+t, x+width+t, y+height+t, x+t, y+height-t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x+t, y+height-t, x+width+t, y+height+t, x+width-t, y+height-t, 0, this._active_stroke_path.verts, false);
            */
            this._active_stroke_path.lineTo(x + width, y);
            this._active_stroke_path.lineTo(x + width, y + height);
            this._active_stroke_path.lineTo(x, y + height);
            this._active_stroke_path.lineTo(x, y);
        }
    };
    /**
     * Draws a rounded rectangle. Set the line style, fill, or both before you
     * call the <code>drawRoundRect()</code> method, by calling the
     * <code>linestyle()</code>, <code>lineGradientStyle()</code>,
     * <code>beginFill()</code>, <code>beginGradientFill()</code>, or
     * <code>beginBitmapFill()</code> method.
     *
     * @param x             A number indicating the horizontal position relative
     *                      to the registration point of the parent display
     *                      object(in pixels).
     * @param y             A number indicating the vertical position relative to
     *                      the registration point of the parent display object
     *                     (in pixels).
     * @param width         The width of the round rectangle(in pixels).
     * @param height        The height of the round rectangle(in pixels).
     * @param ellipseWidth  The width of the ellipse used to draw the rounded
     *                      corners(in pixels).
     * @param ellipseHeight The height of the ellipse used to draw the rounded
     *                      corners(in pixels). Optional; if no value is
     *                      specified, the default value matches that provided
     *                      for the <code>ellipseWidth</code> parameter.
     * @throws ArgumentError If the <code>width</code>, <code>height</code>,
     *                       <code>ellipseWidth</code> or
     *                       <code>ellipseHeight</code> parameters are not a
     *                       number(<code>Number.NaN</code>).
     */
    Graphics.prototype.drawRoundRect = function (x, y, width, height, ellipseWidth, ellipseHeight) {
        if (ellipseHeight === void 0) { ellipseHeight = NaN; }
        this._drawingDirty = true;
        if (isNaN(ellipseHeight)) {
            ellipseHeight = ellipseWidth;
        }
        var w = width;
        var h = height;
        var ew = ellipseWidth / 2;
        var eh = ellipseHeight / 2;
        var t = 0;
        if (this._active_fill_path != null) {
            this._active_fill_path.moveTo(x, y);
            if (this._active_stroke_path != null) {
                t = this._active_stroke_path.style.thickness / 2;
                w -= this._active_stroke_path.style.thickness;
                h -= this._active_stroke_path.style.thickness;
            }
            GraphicsFactoryHelper.addTriangle(x + t, y + h - eh, x + t, y + eh, x + w - t, y + eh, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + t, y + h - eh, x + w - t, y + eh, x + w - t, y + h - eh, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y + t, x + w - ew, y + eh, x + ew, y + eh, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y + t, x + w - ew, y + t, x + w - ew, y + eh, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y + h - eh, x + w - ew, y + h - t, x + ew, y + h - t, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y + h - eh, x + w - ew, y + h - eh, x + w - ew, y + h - t, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.drawElipse(x + ew, y + eh, ew - t, eh - t, this._active_fill_path.verts, 180, 270, 5, false);
            GraphicsFactoryHelper.drawElipse(x + w - ew, y + eh, ew - t, eh - t, this._active_fill_path.verts, 270, 360, 5, false);
            GraphicsFactoryHelper.drawElipse(x + w - ew, y + h - eh, ew - t, eh - t, this._active_fill_path.verts, 0, 90, 5, false);
            GraphicsFactoryHelper.drawElipse(x + ew, y + h - eh, ew - t, eh - t, this._active_fill_path.verts, 90, 180, 5, false);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.moveTo(x, y);
            t = this._active_stroke_path.style.thickness / 2;
            GraphicsFactoryHelper.addTriangle(x - t, y + h - eh, x - t, y + eh, x + t, y + eh, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x - t, y + h - eh, x + t, y + h - eh, x + t, y + eh, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y - t, x + w - ew, y - t, x + ew, y + t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y + t, x + w - ew, y - t, x + w - ew, y + t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + w - t, y + h - eh, x + w - t, y + eh, x + w + t, y + h - eh, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + w + t, y + h - eh, x + w + t, y + eh, x + w - t, y + eh, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y + h + t, x + w - ew, y + h + t, x + ew, y + h - t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + ew, y + h - t, x + w - ew, y + h + t, x + w - ew, y + h - t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + ew, y + eh, ew, eh, this._active_stroke_path.verts, 180, 270, 5, t, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + w - ew, y + eh, ew, eh, this._active_stroke_path.verts, 270, 360, 5, t, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + w - ew, y + h - eh, ew, eh, this._active_stroke_path.verts, 0, 90, 5, t, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + ew, y + h - eh, ew, eh, this._active_stroke_path.verts, 90, 180, 5, t, false);
        }
    };
    Graphics.prototype.drawRoundRectComplex = function (x, y, width, height, topLeftRadius, topRightRadius, bottomLeftRadius, bottomRightRadius) {
        var w = width;
        var h = height;
        var tl = topLeftRadius;
        var tr = topRightRadius;
        var bl = bottomLeftRadius;
        var br = bottomRightRadius;
        this._drawingDirty = true;
        var t = 0;
        if (this._active_fill_path != null) {
            this._active_fill_path.moveTo(x, y);
            if (this._active_stroke_path != null) {
                t = this._active_stroke_path.style.thickness / 2;
                w -= this._active_stroke_path.style.thickness;
                h -= this._active_stroke_path.style.thickness;
            }
            GraphicsFactoryHelper.addTriangle(x + tl, y + tl, x + w - tr, y + tr, x + w - br, y + h - br, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + tl, y + tl, x + w - br, y + h - br, x + bl, y + h - bl, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + t, y + tl, x + tl, y + tl, x + t, y + h - bl, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + tl, y + tl, x + t, y + h - bl, x + bl, y + h - bl, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + tl, y + t, x + tl, y + tl, x + w - tr, y + t, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + tl, y + tl, x + w - tr, y + tr, x + w - tr, y + t, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + w - t, y + tr, x + w - tr, y + tr, x + w - t, y + h - br, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + w - tr, y + tr, x + w - br, y + h - br, x + w - t, y + h - br, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + bl, y + h - t, x + w - br, y + h - t, x + bl, y + h - bl, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + bl, y + h - bl, x + w - br, y + h - t, x + w - br, y + h - br, 0, this._active_fill_path.verts, false);
            GraphicsFactoryHelper.drawElipse(x + tl, y + tl, tl - t, tl - t, this._active_fill_path.verts, 180, 270, 5, false);
            GraphicsFactoryHelper.drawElipse(x + w - tr, y + tr, tr - t, tr - t, this._active_fill_path.verts, 270, 360, 5, false);
            GraphicsFactoryHelper.drawElipse(x + w - br, y + h - br, br - t, br - t, this._active_fill_path.verts, 0, 90, 5, false);
            GraphicsFactoryHelper.drawElipse(x + bl, y + h - bl, bl - t, bl - t, this._active_fill_path.verts, 90, 180, 5, false);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.moveTo(x, y);
            t = this._active_stroke_path.style.thickness / 2;
            GraphicsFactoryHelper.addTriangle(x - t, y + h - bl, x - t, y + tl, x + t, y + tl, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x - t, y + h - bl, x + t, y + h - bl, x + t, y + tl, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + tl, y - t, x + w - tr, y - t, x + tr, y + t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + tl, y + t, x + w - tr, y - t, x + w - tr, y + t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + w - t, y + h - br, x + w - t, y + tr, x + w + t, y + h - br, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + w + t, y + h - br, x + w + t, y + tr, x + w - t, y + tr, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + bl, y + h + t, x + w - br, y + h + t, x + bl, y + h - t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.addTriangle(x + bl, y + h - t, x + w - br, y + h + t, x + w - br, y + h - t, 0, this._active_stroke_path.verts, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + tl, y + tl, tl, tl, this._active_stroke_path.verts, 180, 270, 5, t, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + w - tr, y + tr, tr, tr, this._active_stroke_path.verts, 270, 360, 5, t, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + w - br, y + h - br, br, br, this._active_stroke_path.verts, 0, 90, 5, t, false);
            GraphicsFactoryHelper.drawElipseStrokes(x + bl, y + h - bl, bl, bl, this._active_stroke_path.verts, 90, 180, 5, t, false);
        }
    };
    /**
     * Renders a set of triangles, typically to distort bitmaps and give them a
     * three-dimensional appearance. The <code>drawTriangles()</code> method maps
     * either the current fill, or a bitmap fill, to the triangle faces using a
     * set of(u,v) coordinates.
     *
     * <p> Any type of fill can be used, but if the fill has a transform matrix
     * that transform matrix is ignored. </p>
     *
     * <p> A <code>uvtData</code> parameter improves texture mapping when a
     * bitmap fill is used. </p>
     *
     * @param culling Specifies whether to render triangles that face in a
     *                specified direction. This parameter prevents the rendering
     *                of triangles that cannot be seen in the current view. This
     *                parameter can be set to any value defined by the
     *                TriangleCulling class.
     */
    Graphics.prototype.drawTriangles = function (vertices, indices, uvtData, culling) {
        if (indices === void 0) { indices = null; }
        if (uvtData === void 0) { uvtData = null; }
        if (culling === void 0) { culling = null; }
        this._drawingDirty = true;
        if (this._active_fill_path != null) {
        }
        if (this._active_stroke_path != null) {
        }
    };
    /**
     * Applies a fill to the lines and curves that were added since the last call
     * to the <code>beginFill()</code>, <code>beginGradientFill()</code>, or
     * <code>beginBitmapFill()</code> method. Flash uses the fill that was
     * specified in the previous call to the <code>beginFill()</code>,
     * <code>beginGradientFill()</code>, or <code>beginBitmapFill()</code>
     * method. If the current drawing position does not equal the previous
     * position specified in a <code>moveTo()</code> method and a fill is
     * defined, the path is closed with a line and then filled.
     *
     */
    Graphics.prototype.endFill = function () {
        this._drawingDirty = false;
        this.draw_fills();
        this.draw_strokes();
        this._active_fill_path = null;
        this._active_stroke_path = null;
        //this.invalidate();
        //this.invalidateElements();
    };
    /**
     * Specifies a bitmap to use for the line stroke when drawing lines.
     *
     * <p>The bitmap line style is used for subsequent calls to Graphics methods
     * such as the <code>lineTo()</code> method or the <code>drawCircle()</code>
     * method. The line style remains in effect until you call the
     * <code>lineStyle()</code> or <code>lineGradientStyle()</code> methods, or
     * the <code>lineBitmapStyle()</code> method again with different parameters.
     * </p>
     *
     * <p>You can call the <code>lineBitmapStyle()</code> method in the middle of
     * drawing a path to specify different styles for different line segments
     * within a path. </p>
     *
     * <p>Call the <code>lineStyle()</code> method before you call the
     * <code>lineBitmapStyle()</code> method to enable a stroke, or else the
     * value of the line style is <code>undefined</code>.</p>
     *
     * <p>Calls to the <code>clear()</code> method set the line style back to
     * <code>undefined</code>. </p>
     *
     * @param bitmap The bitmap to use for the line stroke.
     * @param matrix An optional transformation matrix as defined by the
     *               flash.geom.Matrix class. The matrix can be used to scale or
     *               otherwise manipulate the bitmap before applying it to the
     *               line style.
     * @param repeat Whether to repeat the bitmap in a tiled fashion.
     * @param smooth Whether smoothing should be applied to the bitmap.
     */
    Graphics.prototype.lineBitmapStyle = function (bitmap, matrix, repeat, smooth) {
        if (matrix === void 0) { matrix = null; }
        if (repeat === void 0) { repeat = true; }
        if (smooth === void 0) { smooth = false; }
        this._drawingDirty = true;
        // start a new stroke path
        this._active_stroke_path = new GraphicsPath();
        if (this._current_position.x != 0 || this._current_position.y != 0)
            this._active_stroke_path.moveTo(this._current_position.x, this._current_position.y);
        this._queued_stroke_pathes.push(this._active_stroke_path);
        this.invalidate();
    };
    /**
     * Specifies a gradient to use for the stroke when drawing lines.
     *
     * <p>The gradient line style is used for subsequent calls to Graphics
     * methods such as the <code>lineTo()</code> methods or the
     * <code>drawCircle()</code> method. The line style remains in effect until
     * you call the <code>lineStyle()</code> or <code>lineBitmapStyle()</code>
     * methods, or the <code>lineGradientStyle()</code> method again with
     * different parameters. </p>
     *
     * <p>You can call the <code>lineGradientStyle()</code> method in the middle
     * of drawing a path to specify different styles for different line segments
     * within a path. </p>
     *
     * <p>Call the <code>lineStyle()</code> method before you call the
     * <code>lineGradientStyle()</code> method to enable a stroke, or else the
     * value of the line style is <code>undefined</code>.</p>
     *
     * <p>Calls to the <code>clear()</code> method set the line style back to
     * <code>undefined</code>. </p>
     *
     * @param type                A value from the GradientType class that
     *                            specifies which gradient type to use, either
     *                            GradientType.LINEAR or GradientType.RADIAL.
     * @param colors              An array of RGB hexadecimal color values used
     *                            in the gradient; for example, red is 0xFF0000,
     *                            blue is 0x0000FF, and so on. You can specify
     *                            up to 15 colors. For each color, specify a
     *                            corresponding value in the alphas and ratios
     *                            parameters.
     * @param alphas              An array of alpha values for the corresponding
     *                            colors in the colors array; valid values are 0
     *                            to 1. If the value is less than 0, the default
     *                            is 0. If the value is greater than 1, the
     *                            default is 1.
     * @param ratios              An array of color distribution ratios; valid
     *                            values are 0-255. This value defines the
     *                            percentage of the width where the color is
     *                            sampled at 100%. The value 0 represents the
     *                            left position in the gradient box, and 255
     *                            represents the right position in the gradient
     *                            box.
     * @param matrix              A transformation matrix as defined by the
     *                            flash.geom.Matrix class. The flash.geom.Matrix
     *                            class includes a
     *                            <code>createGradientBox()</code> method, which
     *                            lets you conveniently set up the matrix for use
     *                            with the <code>lineGradientStyle()</code>
     *                            method.
     * @param spreadMethod        A value from the SpreadMethod class that
     *                            specifies which spread method to use:
     * @param interpolationMethod A value from the InterpolationMethod class that
     *                            specifies which value to use. For example,
     *                            consider a simple linear gradient between two
     *                            colors(with the <code>spreadMethod</code>
     *                            parameter set to
     *                            <code>SpreadMethod.REFLECT</code>). The
     *                            different interpolation methods affect the
     *                            appearance as follows:
     * @param focalPointRatio     A number that controls the location of the
     *                            focal point of the gradient. The value 0 means
     *                            the focal point is in the center. The value 1
     *                            means the focal point is at one border of the
     *                            gradient circle. The value -1 means that the
     *                            focal point is at the other border of the
     *                            gradient circle. Values less than -1 or greater
     *                            than 1 are rounded to -1 or 1. The following
     *                            image shows a gradient with a
     *                            <code>focalPointRatio</code> of -0.75:
     */
    Graphics.prototype.lineGradientStyle = function (type, colors, alphas, ratios, matrix, spreadMethod, interpolationMethod, focalPointRatio) {
        if (matrix === void 0) { matrix = null; }
        if (spreadMethod === void 0) { spreadMethod = null; }
        if (interpolationMethod === void 0) { interpolationMethod = null; }
        if (focalPointRatio === void 0) { focalPointRatio = 0; }
        this._drawingDirty = true;
        // start a new stroke path
        this._active_stroke_path = new GraphicsPath();
        this._active_stroke_path.style = new GraphicsStrokeStyle(colors[0], alphas[0], 1); //, jointstyle, capstyle, miterLimit);
        if (this._current_position.x != 0 || this._current_position.y != 0)
            this._active_stroke_path.moveTo(this._current_position.x, this._current_position.y);
        this._queued_stroke_pathes.push(this._active_stroke_path);
        this.invalidate();
    };
    /**
     * Specifies a shader to use for the line stroke when drawing lines.
     *
     * <p>The shader line style is used for subsequent calls to Graphics methods
     * such as the <code>lineTo()</code> method or the <code>drawCircle()</code>
     * method. The line style remains in effect until you call the
     * <code>lineStyle()</code> or <code>lineGradientStyle()</code> methods, or
     * the <code>lineBitmapStyle()</code> method again with different parameters.
     * </p>
     *
     * <p>You can call the <code>lineShaderStyle()</code> method in the middle of
     * drawing a path to specify different styles for different line segments
     * within a path. </p>
     *
     * <p>Call the <code>lineStyle()</code> method before you call the
     * <code>lineShaderStyle()</code> method to enable a stroke, or else the
     * value of the line style is <code>undefined</code>.</p>
     *
     * <p>Calls to the <code>clear()</code> method set the line style back to
     * <code>undefined</code>. </p>
     *
     * @param shader The shader to use for the line stroke.
     * @param matrix An optional transformation matrix as defined by the
     *               flash.geom.Matrix class. The matrix can be used to scale or
     *               otherwise manipulate the bitmap before applying it to the
     *               line style.
     */
    //		public lineShaderStyle(shader:Shader, matrix:Matrix = null)
    //		{
    //
    //		}
    /**
     * Specifies a line style used for subsequent calls to Graphics methods such
     * as the <code>lineTo()</code> method or the <code>drawCircle()</code>
     * method. The line style remains in effect until you call the
     * <code>lineGradientStyle()</code> method, the
     * <code>lineBitmapStyle()</code> method, or the <code>lineStyle()</code>
     * method with different parameters.
     *
     * <p>You can call the <code>lineStyle()</code> method in the middle of
     * drawing a path to specify different styles for different line segments
     * within the path.</p>
     *
     * <p><b>Note: </b>Calls to the <code>clear()</code> method set the line
     * style back to <code>undefined</code>.</p>
     *
     * <p><b>Note: </b>Flash Lite 4 supports only the first three parameters
     * (<code>thickness</code>, <code>color</code>, and <code>alpha</code>).</p>
     *
     * @param thickness    An integer that indicates the thickness of the line in
     *                     points; valid values are 0-255. If a number is not
     *                     specified, or if the parameter is undefined, a line is
     *                     not drawn. If a value of less than 0 is passed, the
     *                     default is 0. The value 0 indicates hairline
     *                     thickness; the maximum thickness is 255. If a value
     *                     greater than 255 is passed, the default is 255.
     * @param color        A hexadecimal color value of the line; for example,
     *                     red is 0xFF0000, blue is 0x0000FF, and so on. If a
     *                     value is not indicated, the default is 0x000000
     *                    (black). Optional.
     * @param alpha        A number that indicates the alpha value of the color
     *                     of the line; valid values are 0 to 1. If a value is
     *                     not indicated, the default is 1(solid). If the value
     *                     is less than 0, the default is 0. If the value is
     *                     greater than 1, the default is 1.
     * @param pixelHinting(Not supported in Flash Lite 4) A Boolean value that
     *                     specifies whether to hint strokes to full pixels. This
     *                     affects both the position of anchors of a curve and
     *                     the line stroke size itself. With
     *                     <code>pixelHinting</code> set to <code>true</code>,
     *                     line widths are adjusted to full pixel widths. With
     *                     <code>pixelHinting</code> set to <code>false</code>,
     *                     disjoints can appear for curves and straight lines.
     *                     For example, the following illustrations show how
     *                     Flash Player or Adobe AIR renders two rounded
     *                     rectangles that are identical, except that the
     *                     <code>pixelHinting</code> parameter used in the
     *                     <code>lineStyle()</code> method is set differently
     *                    (the images are scaled by 200%, to emphasize the
     *                     difference):
     *
     *                     <p>If a value is not supplied, the line does not use
     *                     pixel hinting.</p>
     * @param scaleMode   (Not supported in Flash Lite 4) A value from the
     *                     LineScaleMode class that specifies which scale mode to
     *                     use:
     *                     <ul>
     *                       <li> <code>LineScaleMode.NORMAL</code> - Always
     *                     scale the line thickness when the object is scaled
     *                    (the default). </li>
     *                       <li> <code>LineScaleMode.NONE</code> - Never scale
     *                     the line thickness. </li>
     *                       <li> <code>LineScaleMode.VERTICAL</code> - Do not
     *                     scale the line thickness if the object is scaled
     *                     vertically <i>only</i>. For example, consider the
     *                     following circles, drawn with a one-pixel line, and
     *                     each with the <code>scaleMode</code> parameter set to
     *                     <code>LineScaleMode.VERTICAL</code>. The circle on the
     *                     left is scaled vertically only, and the circle on the
     *                     right is scaled both vertically and horizontally:
     *                     </li>
     *                       <li> <code>LineScaleMode.HORIZONTAL</code> - Do not
     *                     scale the line thickness if the object is scaled
     *                     horizontally <i>only</i>. For example, consider the
     *                     following circles, drawn with a one-pixel line, and
     *                     each with the <code>scaleMode</code> parameter set to
     *                     <code>LineScaleMode.HORIZONTAL</code>. The circle on
     *                     the left is scaled horizontally only, and the circle
     *                     on the right is scaled both vertically and
     *                     horizontally:   </li>
     *                     </ul>
     * @param caps        (Not supported in Flash Lite 4) A value from the
     *                     CapsStyle class that specifies the type of caps at the
     *                     end of lines. Valid values are:
     *                     <code>CapsStyle.NONE</code>,
     *                     <code>CapsStyle.ROUND</code>, and
     *                     <code>CapsStyle.SQUARE</code>. If a value is not
     *                     indicated, Flash uses round caps.
     *
     *                     <p>For example, the following illustrations show the
     *                     different <code>capsStyle</code> settings. For each
     *                     setting, the illustration shows a blue line with a
     *                     thickness of 30(for which the <code>capsStyle</code>
     *                     applies), and a superimposed black line with a
     *                     thickness of 1(for which no <code>capsStyle</code>
     *                     applies): </p>
     * @param joints      (Not supported in Flash Lite 4) A value from the
     *                     JointStyle class that specifies the type of joint
     *                     appearance used at angles. Valid values are:
     *                     <code>JointStyle.BEVEL</code>,
     *                     <code>JointStyle.MITER</code>, and
     *                     <code>JointStyle.ROUND</code>. If a value is not
     *                     indicated, Flash uses round joints.
     *
     *                     <p>For example, the following illustrations show the
     *                     different <code>joints</code> settings. For each
     *                     setting, the illustration shows an angled blue line
     *                     with a thickness of 30(for which the
     *                     <code>jointStyle</code> applies), and a superimposed
     *                     angled black line with a thickness of 1(for which no
     *                     <code>jointStyle</code> applies): </p>
     *
     *                     <p><b>Note:</b> For <code>joints</code> set to
     *                     <code>JointStyle.MITER</code>, you can use the
     *                     <code>miterLimit</code> parameter to limit the length
     *                     of the miter.</p>
     * @param miterLimit  (Not supported in Flash Lite 4) A number that
     *                     indicates the limit at which a miter is cut off. Valid
     *                     values range from 1 to 255(and values outside that
     *                     range are rounded to 1 or 255). This value is only
     *                     used if the <code>jointStyle</code> is set to
     *                     <code>"miter"</code>. The <code>miterLimit</code>
     *                     value represents the length that a miter can extend
     *                     beyond the point at which the lines meet to form a
     *                     joint. The value expresses a factor of the line
     *                     <code>thickness</code>. For example, with a
     *                     <code>miterLimit</code> factor of 2.5 and a
     *                     <code>thickness</code> of 10 pixels, the miter is cut
     *                     off at 25 pixels.
     *
     *                     <p>For example, consider the following angled lines,
     *                     each drawn with a <code>thickness</code> of 20, but
     *                     with <code>miterLimit</code> set to 1, 2, and 4.
     *                     Superimposed are black reference lines showing the
     *                     meeting points of the joints:</p>
     *
     *                     <p>Notice that a given <code>miterLimit</code> value
     *                     has a specific maximum angle for which the miter is
     *                     cut off. The following table lists some examples:</p>
     */
    Graphics.prototype.lineStyle = function (thickness, color, alpha, pixelHinting, scaleMode, capstyle, jointstyle, miterLimit) {
        if (thickness === void 0) { thickness = 0; }
        if (color === void 0) { color = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (pixelHinting === void 0) { pixelHinting = false; }
        if (scaleMode === void 0) { scaleMode = null; }
        if (capstyle === void 0) { capstyle = CapsStyle.NONE; }
        if (jointstyle === void 0) { jointstyle = JointStyle.MITER; }
        if (miterLimit === void 0) { miterLimit = 100; }
        this._drawingDirty = true;
        if (thickness == 0) {
            thickness = 0.3;
        }
        // start a new stroke path
        this._active_stroke_path = new GraphicsPath();
        this._active_stroke_path.style = new GraphicsStrokeStyle(color, alpha, thickness, jointstyle, capstyle, miterLimit);
        if (this._current_position.x != 0 || this._current_position.y != 0)
            this._active_stroke_path.moveTo(this._current_position.x, this._current_position.y);
        this._queued_stroke_pathes.push(this._active_stroke_path);
        this.invalidate();
    };
    /**
     * Draws a line using the current line style from the current drawing
     * position to(<code>x</code>, <code>y</code>); the current drawing position
     * is then set to(<code>x</code>, <code>y</code>). If the display object in
     * which you are drawing contains content that was created with the Flash
     * drawing tools, calls to the <code>lineTo()</code> method are drawn
     * underneath the content. If you call <code>lineTo()</code> before any calls
     * to the <code>moveTo()</code> method, the default position for the current
     * drawing is(<i>0, 0</i>). If any of the parameters are missing, this
     * method fails and the current drawing position is not changed.
     *
     * @param x A number that indicates the horizontal position relative to the
     *          registration point of the parent display object(in pixels).
     * @param y A number that indicates the vertical position relative to the
     *          registration point of the parent display object(in pixels).
     */
    Graphics.prototype.lineTo = function (x, y) {
        this._drawingDirty = true;
        if (this._active_fill_path != null) {
            this._active_fill_path.lineTo(x, y);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.lineTo(x, y);
        }
        this._current_position.x = x;
        this._current_position.y = y;
    };
    /**
     * Moves the current drawing position to(<code>x</code>, <code>y</code>). If
     * any of the parameters are missing, this method fails and the current
     * drawing position is not changed.
     *
     * @param x A number that indicates the horizontal position relative to the
     *          registration point of the parent display object(in pixels).
     * @param y A number that indicates the vertical position relative to the
     *          registration point of the parent display object(in pixels).
     */
    Graphics.prototype.moveTo = function (x, y) {
        this._drawingDirty = true;
        if (this._active_fill_path != null) {
            this._active_fill_path.moveTo(x, y);
        }
        if (this._active_stroke_path != null) {
            this._active_stroke_path.moveTo(x, y);
        }
        this._current_position.x = x;
        this._current_position.y = y;
    };
    Graphics.prototype._addShapes = function (shapes, cloneShapes) {
        if (cloneShapes === void 0) { cloneShapes = false; }
        var shape;
        var len = shapes.length;
        for (var i = 0; i < len; i++) {
            shape = shapes[i];
            if (this.slice9Rectangle)
                shape = Shape.getShape(ElementsUtils.updateTriangleGraphicsSlice9(shape.elements, this.originalSlice9Size, 1, 1, false, true), shape.material, shape.style);
            else if (cloneShapes)
                shape = Shape.getShape(shape.elements, shape.material, shape.style, shape.count, shape.offset);
            shape.addEventListener(ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
            shape.addEventListener(ShapeEvent.ADD_MATERIAL, this._onAddMaterialDelegate);
            shape.addEventListener(ShapeEvent.REMOVE_MATERIAL, this._onRemoveMaterialDelegate);
            this._shapes.push(shape);
        }
        this.invalidate();
    };
    Graphics.prototype._isShapeMaterial = function (material) {
        var len = this._shapes.length;
        for (var i = 0; i < len; i++)
            if (material == this._shapes[i].material)
                return true;
        return false;
    };
    return Graphics;
}(_awayjs_core.AssetBase));
Graphics._pool = new Array();
Graphics.get_material_for_color = function (color, alpha) {
    return { material: DefaultMaterialManager.getDefaultMaterial() };
};
Graphics.get_material_for_gradient = function (gradient) {
    return { material: DefaultMaterialManager.getDefaultMaterial() };
};
Graphics.assetType = "[asset Graphics]";

var Tess2 = __webpack_require__(18);
/**
 * The Graphics class contains a set of methods that you can use to create a
 * vector shape. Display objects that support drawing include Sprite and Shape
 * objects. Each of these classes includes a <code>graphics</code> property
 * that is a Graphics object. The following are among those helper functions
 * provided for ease of use: <code>drawRect()</code>,
 * <code>drawRoundRect()</code>, <code>drawCircle()</code>, and
 * <code>drawEllipse()</code>.
 *
 * <p>You cannot create a Graphics object directly from ActionScript code. If
 * you call <code>new Graphics()</code>, an exception is thrown.</p>
 *
 * <p>The Graphics class is final; it cannot be subclassed.</p>
 */
var GraphicsFactoryFills = (function () {
    function GraphicsFactoryFills() {
    }
    GraphicsFactoryFills.draw_pathes = function (targetGraphics) {
        var len = targetGraphics.queued_fill_pathes.length;
        var cp = 0;
        for (cp = 0; cp < len; cp++) {
            var one_path = targetGraphics.queued_fill_pathes[cp];
            //one_path.finalizeContour();
            var contour_commands = one_path.commands;
            var contour_data = one_path.data;
            var commands;
            var data;
            var i = 0;
            var k = 0;
            var vert_cnt = 0;
            var data_cnt = 0;
            var draw_direction = 0;
            var contours_vertices = [[]];
            var final_vert_list = [];
            var final_vert_cnt = 0;
            var lastPoint = new _awayjs_core.Point();
            var last_dir_vec = new _awayjs_core.Point();
            var end_point = new _awayjs_core.Point();
            if (contour_commands.length > 0 && contour_commands[0].length > 0) {
                for (k = 0; k < contour_commands.length; k++) {
                    contours_vertices.push([]);
                    vert_cnt = 0;
                    data_cnt = 0;
                    commands = contour_commands[k];
                    data = contour_data[k];
                    draw_direction = 0;
                    var new_dir = 0;
                    var new_dir_1 = 0;
                    var new_dir_2 = 0;
                    var dir_delta = 0;
                    var last_direction = 0;
                    var tmp_dir_point = new _awayjs_core.Point();
                    if ((data[0] != data[data.length - 2]) || (data[1] != data[data.length - 1])) {
                        data[data.length] = data[0];
                        data[data.length] = data[1];
                    }
                    lastPoint.x = data[0];
                    lastPoint.y = data[1];
                    if (commands[1] == GraphicsPathCommand.LINE_TO) {
                        last_dir_vec.x = data[2] - lastPoint.x;
                        last_dir_vec.y = data[3] - lastPoint.y;
                    }
                    else if (commands[1] == GraphicsPathCommand.CURVE_TO) {
                        last_dir_vec.x = data[4] - lastPoint.x;
                        last_dir_vec.y = data[5] - lastPoint.y;
                    }
                    data_cnt = 2;
                    last_dir_vec.normalize();
                    last_direction = Math.atan2(last_dir_vec.y, last_dir_vec.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                    for (i = 1; i < commands.length; i++) {
                        end_point = new _awayjs_core.Point(data[data_cnt++], data[data_cnt++]);
                        if (commands[i] == GraphicsPathCommand.MOVE_TO) {
                            console.log("ERROR ! ONLY THE FIRST COMMAND FOR A CONTOUR IS ALLOWED TO BE A 'MOVE_TO' COMMAND");
                        }
                        else if (commands[i] == GraphicsPathCommand.CURVE_TO) {
                            end_point = new _awayjs_core.Point(data[data_cnt++], data[data_cnt++]);
                        }
                        //get the directional vector and the direction for this segment
                        tmp_dir_point.x = end_point.x - lastPoint.x;
                        tmp_dir_point.y = end_point.y - lastPoint.y;
                        tmp_dir_point.normalize();
                        new_dir = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                        // get the difference in angle to the last segment
                        dir_delta = new_dir - last_direction;
                        if (dir_delta > 180) {
                            dir_delta -= 360;
                        }
                        if (dir_delta < -180) {
                            dir_delta += 360;
                        }
                        draw_direction += dir_delta;
                        last_direction = new_dir;
                        lastPoint.x = end_point.x;
                        lastPoint.y = end_point.y;
                    }
                    lastPoint.x = data[0];
                    lastPoint.y = data[1];
                    data_cnt = 2;
                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.x;
                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.y;
                    //console.log("Draw directions complete: "+draw_direction);
                    for (i = 1; i < commands.length; i++) {
                        switch (commands[i]) {
                            case GraphicsPathCommand.MOVE_TO:
                                console.log("ERROR ! ONLY THE FIRST COMMAND FOR A CONTOUR IS ALLOWED TO BE A 'MOVE_TO' COMMAND");
                                break;
                            case GraphicsPathCommand.LINE_TO:
                                lastPoint.x = data[data_cnt++];
                                lastPoint.y = data[data_cnt++];
                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.x;
                                contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.y;
                                break;
                            case GraphicsPathCommand.CURVE_TO:
                                var control_x = data[data_cnt++];
                                var control_y = data[data_cnt++];
                                var end_x = data[data_cnt++];
                                var end_y = data[data_cnt++];
                                tmp_dir_point.x = control_x - lastPoint.x;
                                tmp_dir_point.y = control_y - lastPoint.y;
                                tmp_dir_point.normalize();
                                new_dir_1 = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                                tmp_dir_point.x = end_x - lastPoint.x;
                                tmp_dir_point.y = end_y - lastPoint.y;
                                tmp_dir_point.normalize();
                                new_dir_2 = Math.atan2(tmp_dir_point.y, tmp_dir_point.x) * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
                                // get the difference in angle to the last segment
                                var curve_direction = new_dir_2 - new_dir_1;
                                if (curve_direction > 180) {
                                    curve_direction -= 360;
                                }
                                if (curve_direction < -180) {
                                    curve_direction += 360;
                                }
                                if ((curve_direction == 0) && (curve_direction == 180) && (curve_direction == -180)) {
                                    lastPoint.x = end_x;
                                    lastPoint.y = end_y;
                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.x;
                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = lastPoint.y;
                                    break;
                                }
                                var curve_attr_1 = -1;
                                if (draw_direction < 0) {
                                    if (curve_direction > 0) {
                                        //convex
                                        //console.log("convex");
                                        curve_attr_1 = 1;
                                        contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_x;
                                        contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_y;
                                    }
                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_x;
                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_y;
                                }
                                else {
                                    if (curve_direction < 0) {
                                        //convex
                                        //console.log("convex");
                                        curve_attr_1 = 1;
                                        contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_x;
                                        contours_vertices[contours_vertices.length - 1][vert_cnt++] = control_y;
                                    }
                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_x;
                                    contours_vertices[contours_vertices.length - 1][vert_cnt++] = end_y;
                                }
                                if (GraphicsFactoryHelper.isClockWiseXY(end_x, end_y, control_x, control_y, lastPoint.x, lastPoint.y)) {
                                    final_vert_list[final_vert_cnt++] = end_x;
                                    final_vert_list[final_vert_cnt++] = end_y;
                                    /*
                                     final_vert_list[final_vert_cnt++] = curve_attr_1;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 0.0;
                                     */
                                    final_vert_list[final_vert_cnt++] = control_x;
                                    final_vert_list[final_vert_cnt++] = control_y;
                                    /*
                                     final_vert_list[final_vert_cnt++] = curve_attr_1;
                                     final_vert_list[final_vert_cnt++] = 0.5;
                                     final_vert_list[final_vert_cnt++] = 0.0;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 0.0;
                                     */
                                    final_vert_list[final_vert_cnt++] = lastPoint.x;
                                    final_vert_list[final_vert_cnt++] = lastPoint.y;
                                }
                                else {
                                    final_vert_list[final_vert_cnt++] = lastPoint.x;
                                    final_vert_list[final_vert_cnt++] = lastPoint.y;
                                    /*
                                     final_vert_list[final_vert_cnt++] = curve_attr_1;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 0.0;
                                     */
                                    final_vert_list[final_vert_cnt++] = control_x;
                                    final_vert_list[final_vert_cnt++] = control_y;
                                    /*
                                     final_vert_list[final_vert_cnt++] = curve_attr_1;
                                     final_vert_list[final_vert_cnt++] = 0.5;
                                     final_vert_list[final_vert_cnt++] = 0.0;
                                     final_vert_list[final_vert_cnt++] = 1.0;
                                     final_vert_list[final_vert_cnt++] = 0.0;
                                     */
                                    final_vert_list[final_vert_cnt++] = end_x;
                                    final_vert_list[final_vert_cnt++] = end_y;
                                }
                                lastPoint.x = end_x;
                                lastPoint.y = end_y;
                                break;
                            case GraphicsPathCommand.CUBIC_CURVE:
                                //todo
                                break;
                        }
                    }
                }
                var verts = [];
                var all_verts = [];
                var elems = [];
                var res = Tess2.tesselate({
                    contours: contours_vertices,
                    windingRule: Tess2.WINDING_ODD,
                    elementType: Tess2.POLYGONS,
                    polySize: 3,
                    vertexSize: 2
                });
                var numElems = res.elements.length / 3;
                var p1 = 0;
                var p2 = 0;
                var p3 = 0;
                for (i = 0; i < numElems; ++i) {
                    p1 = res.elements[i * 3];
                    p2 = res.elements[i * 3 + 1];
                    p3 = res.elements[i * 3 + 2];
                    final_vert_list[final_vert_cnt++] = res.vertices[p3 * 2];
                    final_vert_list[final_vert_cnt++] = res.vertices[p3 * 2 + 1];
                    /*
                     final_vert_list[final_vert_cnt++] = 1;
                     final_vert_list[final_vert_cnt++] = 2.0;
                     final_vert_list[final_vert_cnt++] = 0.0;
                     final_vert_list[final_vert_cnt++] = 1.0;
                     final_vert_list[final_vert_cnt++] = 0.0;
                     */
                    final_vert_list[final_vert_cnt++] = res.vertices[p2 * 2];
                    final_vert_list[final_vert_cnt++] = res.vertices[p2 * 2 + 1];
                    /*
                     final_vert_list[final_vert_cnt++] = 1;
                     final_vert_list[final_vert_cnt++] = 2.0;
                     final_vert_list[final_vert_cnt++] = 0.0;
                     final_vert_list[final_vert_cnt++] = 1.0;
                     final_vert_list[final_vert_cnt++] = 0.0;
                     */
                    final_vert_list[final_vert_cnt++] = res.vertices[p1 * 2];
                    final_vert_list[final_vert_cnt++] = res.vertices[p1 * 2 + 1];
                }
            }
            final_vert_list = final_vert_list.concat(targetGraphics.queued_fill_pathes[cp].verts);
            if (final_vert_list.length > 0) {
                //for (i = 0; i < final_vert_list.length/7; ++i)
                //	console.log("final verts "+i+" = "+final_vert_list[i*7]+" / "+final_vert_list[i*7+1]);
                var attributesView = new _awayjs_core.AttributesView(Float32Array, 2);
                attributesView.set(final_vert_list);
                var attributesBuffer = attributesView.attributesBuffer;
                attributesView.dispose();
                var elements = new TriangleElements(attributesBuffer);
                elements.setPositions(new _awayjs_core.Float2Attributes(attributesBuffer));
                //elements.setCustomAttributes("curves", new Float3Attributes(attributesBuffer));
                //elements.setUVs(new Float2Attributes(attributesBuffer));
                var sampler;
                var style;
                var material;
                if (targetGraphics.queued_fill_pathes[cp].style.data_type == GraphicsFillStyle.data_type) {
                    var obj = Graphics.get_material_for_color(targetGraphics.queued_fill_pathes[cp].style.color, targetGraphics.queued_fill_pathes[cp].style.alpha);
                    material = obj.material;
                    var shape = targetGraphics.addShape(Shape.getShape(elements, material));
                    if (obj.colorPos) {
                        shape.style = new Style();
                        sampler = new Sampler2D();
                        material.animateUVs = true;
                        shape.style.addSamplerAt(sampler, material.getTextureAt(0));
                        shape.style.uvMatrix = new _awayjs_core.Matrix(0, 0, 0, 0, obj.colorPos.x, obj.colorPos.y);
                    }
                }
                else if (targetGraphics.queued_fill_pathes[cp].style.data_type == GradientFillStyle.data_type) {
                    var gradientStyle = targetGraphics.queued_fill_pathes[cp].style;
                    var obj = Graphics.get_material_for_gradient(gradientStyle);
                    material = obj.material;
                    var shape = targetGraphics.addShape(Shape.getShape(elements, material));
                    shape.style = new Style();
                    sampler = new Sampler2D();
                    shape.style.addSamplerAt(sampler, material.getTextureAt(0));
                    material.animateUVs = true;
                    shape.style.uvMatrix = gradientStyle.getUVMatrix();
                    // todo: always use mappingmode = Radial ?
                    sampler.imageRect = gradientStyle.uvRectangle;
                    material.imageRect = true;
                    material.getTextureAt(0).mappingMode = exports.MappingMode.RADIAL;
                }
            }
        }
        targetGraphics.queued_fill_pathes.length = 0;
    };
    return GraphicsFactoryFills;
}());

/**
 * The InterpolationMethod class provides values for the
 * <code>interpolationMethod</code> parameter in the
 * <code>Graphics.beginGradientFill()</code> and
 * <code>Graphics.lineGradientStyle()</code> methods. This parameter
 * determines the RGB space to use when rendering the gradient.
 */
var InterpolationMethod = (function () {
    function InterpolationMethod() {
    }
    return InterpolationMethod;
}());
/**
 * Specifies that the RGB interpolation method should be used. This means
 * that the gradient is rendered with exponential sRGB(standard RGB) space.
 * The sRGB space is a W3C-endorsed standard that defines a non-linear
 * conversion between red, green, and blue component values and the actual
 * intensity of the visible component color.
 *
 * <p>For example, consider a simple linear gradient between two colors(with
 * the <code>spreadMethod</code> parameter set to
 * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
 * affect the appearance as follows: </p>
 */
InterpolationMethod.LINEAR_RGB = "linearRGB";
/**
 * Specifies that the RGB interpolation method should be used. This means
 * that the gradient is rendered with exponential sRGB(standard RGB) space.
 * The sRGB space is a W3C-endorsed standard that defines a non-linear
 * conversion between red, green, and blue component values and the actual
 * intensity of the visible component color.
 *
 * <p>For example, consider a simple linear gradient between two colors(with
 * the <code>spreadMethod</code> parameter set to
 * <code>SpreadMethod.REFLECT</code>). The different interpolation methods
 * affect the appearance as follows: </p>
 */
InterpolationMethod.RGB = "rgb";

/**
 * The PixelSnapping class is an enumeration of constant values for setting
 * the pixel snapping options by using the <code>pixelSnapping</code> property
 * of a Bitmap object.
 */
var PixelSnapping = (function () {
    function PixelSnapping() {
    }
    return PixelSnapping;
}());
/**
 * A constant value used in the <code>pixelSnapping</code> property of a
 * Bitmap object to specify that the bitmap image is always snapped to the
 * nearest pixel, independent of any transformation.
 */
PixelSnapping.ALWAYS = "always";
/**
 * A constant value used in the <code>pixelSnapping</code> property of a
 * Bitmap object to specify that the bitmap image is snapped to the nearest
 * pixel if it is drawn with no rotation or skew and it is drawn at a scale
 * factor of 99.9% to 100.1%. If these conditions are satisfied, the image is
 * drawn at 100% scale, snapped to the nearest pixel. Internally, this
 * setting allows the image to be drawn as fast as possible by using the
 * vector renderer.
 */
PixelSnapping.AUTO = "auto";
/**
 * A constant value used in the <code>pixelSnapping</code> property of a
 * Bitmap object to specify that no pixel snapping occurs.
 */
PixelSnapping.NEVER = "never";

/**
 * The SpreadMethod class provides values for the <code>spreadMethod</code>
 * parameter in the <code>beginGradientFill()</code> and
 * <code>lineGradientStyle()</code> methods of the Graphics class.
 *
 * <p>The following example shows the same gradient fill using various spread
 * methods:</p>
 */
var SpreadMethod = (function () {
    function SpreadMethod() {
    }
    return SpreadMethod;
}());
/**
 * Specifies that the gradient use the <i>pad</i> spread method.
 */
SpreadMethod.PAD = "pad";
/**
 * Specifies that the gradient use the <i>reflect</i> spread method.
 */
SpreadMethod.REFLECT = "reflect";
/**
 * Specifies that the gradient use the <i>repeat</i> spread method.
 */
SpreadMethod.REPEAT = "repeat";

/**
 * Defines codes for culling algorithms that determine which triangles not to
 * render when drawing triangle paths.
 *
 * <p> The terms <code>POSITIVE</code> and <code>NEGATIVE</code> refer to the
 * sign of a triangle's normal along the z-axis. The normal is a 3D vector
 * that is perpendicular to the surface of the triangle. </p>
 *
 * <p> A triangle whose vertices 0, 1, and 2 are arranged in a clockwise order
 * has a positive normal value. That is, its normal points in a positive
 * z-axis direction, away from the current view point. When the
 * <code>TriangleCulling.POSITIVE</code> algorithm is used, triangles with
 * positive normals are not rendered. Another term for this is backface
 * culling. </p>
 *
 * <p> A triangle whose vertices are arranged in a counter-clockwise order has
 * a negative normal value. That is, its normal points in a negative z-axis
 * direction, toward the current view point. When the
 * <code>TriangleCulling.NEGATIVE</code> algorithm is used, triangles with
 * negative normals will not be rendered. </p>
 */
var TriangleCulling = (function () {
    function TriangleCulling() {
    }
    return TriangleCulling;
}());
/**
 * Specifies culling of all triangles facing toward the current view point.
 */
TriangleCulling.NEGATIVE = "negative";
/**
 * Specifies no culling. All triangles in the path are rendered.
 */
TriangleCulling.NONE = "none";
/**
 * Specifies culling of all triangles facing away from the current view
 * point. This is also known as backface culling.
 */
TriangleCulling.POSITIVE = "positive";

var ElementsType = (function () {
    function ElementsType() {
    }
    return ElementsType;
}());
/**
 *
 */
ElementsType.TRIANGLE = "triangle";
/**
 *
 */
ElementsType.LINE = "line";

var BitmapImageChannel = (function () {
    function BitmapImageChannel() {
    }
    return BitmapImageChannel;
}());
BitmapImageChannel.ALPHA = 8;
BitmapImageChannel.BLUE = 4;
BitmapImageChannel.GREEN = 2;
BitmapImageChannel.RED = 1;

/**

 */
var ExternalImage2D = (function (_super) {
    __extends(ExternalImage2D, _super);
    /**
     *
     */
    function ExternalImage2D(urlRequest) {
        var _this = _super.call(this, 8, 8, true) || this;
        _this._urlRequest = urlRequest;
        return _this;
    }
    Object.defineProperty(ExternalImage2D.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return ExternalImage2D.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ExternalImage2D.prototype, "urlRequest", {
        get: function () {
            return this._urlRequest;
        },
        set: function (value) {
            this._urlRequest = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new ExternalImage2D object that is a clone of the original instance
     * with an exact copy of the contained bitmap.
     *
     * @return A new ExternalImage2D object that is identical to the original.
     */
    ExternalImage2D.prototype.clone = function () {
        var t = new ExternalImage2D(this._urlRequest);
        return t;
    };
    return ExternalImage2D;
}(Image2D));
ExternalImage2D.assetType = "[image ExternalImage2D]";

/**
 * The Bitmap export class represents display objects that represent bitmap images.
 * These can be images that you load with the <code>flash.Assets</code> or
 * <code>flash.display.Loader</code> classes, or they can be images that you
 * create with the <code>Bitmap()</code> constructor.
 *
 * <p>The <code>Bitmap()</code> constructor allows you to create a Bitmap
 * object that contains a reference to a BitmapData object. After you create a
 * Bitmap object, use the <code>addChild()</code> or <code>addChildAt()</code>
 * method of the parent DisplayObjectContainer instance to place the bitmap on
 * the display list.</p>
 *
 * <p>A Bitmap object can share its BitmapData reference among several Bitmap
 * objects, independent of translation or rotation properties. Because you can
 * create multiple Bitmap objects that reference the same BitmapData object,
 * multiple texture objects can use the same complex BitmapData object without
 * incurring the memory overhead of a BitmapData object for each texture
 * object instance.</p>

 */
var SamplerCube = (function (_super) {
    __extends(SamplerCube, _super);
    /**
     *
     * @param bitmapData
     * @param smoothing
     */
    function SamplerCube(smooth, mipmap) {
        if (smooth === void 0) { smooth = false; }
        if (mipmap === void 0) { mipmap = false; }
        return _super.call(this, smooth, mipmap) || this;
    }
    Object.defineProperty(SamplerCube.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return SamplerCube.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return SamplerCube;
}(SamplerBase));
SamplerCube.assetType = "[asset SamplerCube]";

/**
 *
 */
var SpecularImage2D = (function (_super) {
    __extends(SpecularImage2D, _super);
    /**
     *
     */
    function SpecularImage2D(specularSource, glossSource) {
        if (specularSource === void 0) { specularSource = null; }
        if (glossSource === void 0) { glossSource = null; }
        var _this = _super.call(this, 1, 1) || this;
        _this._specularSource = specularSource;
        _this._glossSource = glossSource;
        _this._output = new BitmapImage2D(1, 1, false, 0xffffff);
        _this._testSize();
        return _this;
    }
    Object.defineProperty(SpecularImage2D.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return SpecularImage2D.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularImage2D.prototype, "specularSource", {
        get: function () {
            return this._specularSource;
        },
        set: function (value) {
            if (this._specularSource == value)
                return;
            this._specularSource = value;
            this.invalidate();
            this._testSize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularImage2D.prototype, "glossSource", {
        get: function () {
            return this._glossSource;
        },
        set: function (value) {
            if (this._glossSource == value)
                return;
            this._glossSource = value;
            this.invalidate();
            this._testSize();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a new SpecularImage2D object that is a clone of the original instance
     * with an exact copy of the contained bitmap.
     *
     * @return A new SpecularImage2D object that is identical to the original.
     */
    SpecularImage2D.prototype.clone = function () {
        return new SpecularImage2D(this._specularSource, this._glossSource);
    };
    /**
     * Frees memory that is used to store the SpecularImage2D object.
     *
     * <p>When the <code>dispose()</code> method is called on an image, the width
     * and height of the image are set to 0. All subsequent calls to methods or
     * properties of this SpecularImage2D instance fail, and an exception is thrown.
     * </p>
     *
     * <p><code>SpecularImage2D.dispose()</code> releases the memory occupied by the
     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
     * memory). After using <code>SpecularImage2D.dispose()</code>, the SpecularImage2D
     * object is no longer usable and an exception may be thrown if
     * you call functions on the SpecularImage2D object. However,
     * <code>SpecularImage2D.dispose()</code> does not garbage collect the SpecularImage2D
     * object(approximately 128 bytes); the memory occupied by the actual
     * SpecularImage2D object is released at the time the SpecularImage2D object is
     * collected by the garbage collector.</p>
     *
     */
    SpecularImage2D.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._rect = null;
        this._output.dispose();
    };
    /**
     *
     * @returns {ImageData}
     */
    SpecularImage2D.prototype.getImageData = function () {
        var origin = new _awayjs_core.Point();
        this._output.fillRect(this._rect, 0xffffff);
        if (this._glossSource)
            this._output.copyChannel(this._glossSource, this._rect, origin, BitmapImageChannel.GREEN, BitmapImageChannel.GREEN);
        if (this._specularSource)
            this._output.copyChannel(this._specularSource, this._rect, origin, BitmapImageChannel.RED, BitmapImageChannel.RED);
        return this._output.getImageData();
    };
    /**
     *
     * @returns {HTMLCanvasElement}
     */
    SpecularImage2D.prototype.getCanvas = function () {
        return this._output.getCanvas();
    };
    /**
     *
     * @param width
     * @param height
     * @private
     */
    SpecularImage2D.prototype._setSize = function (width, height) {
        _super.prototype._setSize.call(this, width, height);
        this._output._setSize(width, height);
    };
    SpecularImage2D.prototype._testSize = function () {
        var w, h;
        if (this._specularSource) {
            w = this._specularSource.width;
            h = this._specularSource.height;
        }
        else if (this._glossSource) {
            w = this._glossSource.width;
            h = this._glossSource.height;
        }
        else {
            w = 1;
            h = 1;
        }
        if (w != this._output.width && h != this._output.height) {
            this._output.dispose();
            this._output = new BitmapImage2D(w, h, false, 0xffffff);
        }
        this._setSize(w, h);
    };
    return SpecularImage2D;
}(Image2D));
SpecularImage2D.assetType = "[asset SpecularImage2D]";

/*import {IRenderable} from "../base/IRenderable";
import {LineElements} from "../elements/LineElements";
import {Sampler2D} from "../image/Sampler2D";
import {BitmapImageCube} from "../image/BitmapImageCube";
import {MaterialBase} from "../materials/MaterialBase";
import {BasicMaterial} from "../materials/BasicMaterial";
import {Single2DTexture} from "../textures/Single2DTexture";
import {SingleCubeTexture} from "../textures/SingleCubeTexture";
import {Shape} from "../base/Shape";
*/
var TextureAtlas = (function () {
    function TextureAtlas() {
        this.availableRows = 256;
        this.gradient_row = -1;
        this.color_row = 255;
        this.color_position = 256;
        this.availableGradients = 256;
        this.availableColors = 0;
        this.bitmap = new BitmapImage2D(256, 256, false, 0xff0000);
        this.availableRows = 256;
        this.availableColors = 0;
    }
    TextureAtlas.getTextureForColor = function (color, alpha) {
        var colorString = color.toString() + "#" + alpha.toString();
        if (TextureAtlas._allColors.hasOwnProperty(colorString)) {
            return TextureAtlas._allColors[colorString];
        }
        // find textureAtlas that has empty space:
        var t_len = TextureAtlas._allTextureAtlas.length;
        var t = 0;
        var textureAtlas;
        for (t = 0; t < t_len; t++) {
            if (TextureAtlas._allTextureAtlas[t].fit_color()) {
                textureAtlas = TextureAtlas._allTextureAtlas[t];
                break;
            }
        }
        if (!textureAtlas) {
            textureAtlas = new TextureAtlas();
            TextureAtlas._allTextureAtlas.push(textureAtlas);
        }
        var newColorObj = {};
        newColorObj.colorPos = textureAtlas.draw_color(color, alpha);
        newColorObj.bitmap = textureAtlas.bitmap;
        TextureAtlas._allColors[colorString] = newColorObj;
        return newColorObj;
    };
    TextureAtlas.getTextureForGradient = function (gradient) {
        var gradientStr = gradient.toString();
        if (TextureAtlas._allGradients.hasOwnProperty(gradientStr)) {
            gradient.uvRectangle = TextureAtlas._allGradients[gradientStr].uvRectangle;
            return TextureAtlas._allGradients[gradientStr];
        }
        var t_len = TextureAtlas._allTextureAtlas.length;
        var t = 0;
        var textureAtlas;
        for (t = 0; t < t_len; t++) {
            if (TextureAtlas._allTextureAtlas[t].fit_gradient()) {
                textureAtlas = TextureAtlas._allTextureAtlas[t];
                break;
            }
        }
        if (!textureAtlas) {
            textureAtlas = new TextureAtlas();
            TextureAtlas._allTextureAtlas.push(textureAtlas);
        }
        var newColorObj = {};
        textureAtlas.draw_gradient(gradient);
        newColorObj.uvRectangle = new _awayjs_core.Rectangle();
        newColorObj.uvRectangle.copyFrom(gradient.uvRectangle);
        newColorObj.bitmap = textureAtlas.bitmap;
        TextureAtlas._allGradients[gradientStr] = newColorObj;
        return newColorObj;
    };
    TextureAtlas.prototype.fit_gradient = function () {
        return (this.availableRows > 0);
    };
    TextureAtlas.prototype.fit_color = function () {
        if (this.availableColors > 0)
            return true;
        return (this.availableRows > 0);
    };
    TextureAtlas.prototype.draw_gradient = function (gradient) {
        if (this.availableRows < 0) {
            console.log("error in TextureAtlasManager.draw_color");
            return;
        }
        this.gradient_row++;
        this.availableRows--;
        var px;
        for (px = 0; px < 256; px++) {
            this.bitmap.setPixelFromArray(px, this.gradient_row, gradient.getColorAtPosition(px));
        }
        this.bitmap.invalidate();
        gradient.uvRectangle.x = 1 / 512;
        gradient.uvRectangle.y = 1 / 512 + (this.gradient_row / 256); //+1/512;
        gradient.uvRectangle.width = 1 - 1 / 512;
        gradient.uvRectangle.height = gradient.uvRectangle.y;
        return this.availableRows;
    };
    TextureAtlas.prototype.draw_color = function (color, alpha) {
        if (alpha === void 0) { alpha = 1; }
        this.color_position--;
        if (this.color_position < 0) {
            if (this.availableRows > 0) {
                this.color_row--;
                this.availableRows--;
                this.color_position = 255;
            }
            else {
                console.log("error in TextureAtlasManager.draw_color");
            }
        }
        var argb = _awayjs_core.ColorUtils.float32ColorToARGB(color);
        argb[0] = alpha;
        this.bitmap.setPixelFromArray(this.color_position, this.color_row, argb);
        this.bitmap.invalidate();
        return new _awayjs_core.Point(1 / 512 + this.color_position / 256, 1 / 512 + this.color_row / 256);
    };
    return TextureAtlas;
}());
TextureAtlas._allTextureAtlas = [];
TextureAtlas._allGradients = {};
TextureAtlas._allColors = {};

/**
 * Image2DParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
 * a loader object, it wraps it in a BitmapDataResource so resource management can happen consistently without
 * exception cases.
 */
var Image2DParser = (function (_super) {
    __extends(Image2DParser, _super);
    /**
     * Creates a new Image2DParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function Image2DParser(factory) {
        if (factory === void 0) { factory = null; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.BLOB) || this;
        _this._factory = factory || new DefaultGraphicsFactory();
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    Image2DParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "jpg" || extension == "jpeg" || extension == "png" || extension == "gif"; //|| extension == "bmp";//|| extension == "atf";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    Image2DParser.supportsData = function (data) {
        if (data instanceof HTMLImageElement)
            return true;
        if (!(data instanceof _awayjs_core.ByteArray))
            return false;
        var ba = data;
        ba.position = 0;
        if (ba.readUnsignedShort() == 0xd8ff)
            return true; // JPEG, maybe check for "JFIF" as well?
        ba.position = 0;
        if (ba.readShort() == 0x424D)
            return true; // BMP
        ba.position = 1;
        if (ba.readUTFBytes(3) == 'PNG')
            return true;
        ba.position = 0;
        if (ba.readUTFBytes(3) == 'GIF' && ba.readShort() == 0x3839 && ba.readByte() == 0x61)
            return true;
        ba.position = 0;
        if (ba.readUTFBytes(3) == 'ATF')
            return true;
        return false;
    };
    /**
     * @inheritDoc
     */
    Image2DParser.prototype._pProceedParsing = function () {
        var _this = this;
        var asset;
        var sizeError = false;
        if (this._loadingImage) {
            return _awayjs_core.ParserBase.MORE_TO_PARSE;
        }
        else if (this._htmlImageElement) {
            //if (ImageUtils.isHTMLImageElementValid(this._htmlImageElement)) {
            asset = ImageUtils.imageToBitmapImage2D(this._htmlImageElement, false, this._factory);
            this._pFinalizeAsset(asset, this._iFileName);
        }
        else if (this.data instanceof HTMLImageElement) {
            var htmlImageElement = this.data;
            //if (ImageUtils.isHTMLImageElementValid(htmlImageElement)) {
            asset = ImageUtils.imageToBitmapImage2D(htmlImageElement, false, this._factory);
            this._pFinalizeAsset(asset, this._iFileName);
        }
        else if (this.data instanceof _awayjs_core.ByteArray) {
            var ba = this.data;
            ba.position = 0;
            this._htmlImageElement = _awayjs_core.ParserUtils.byteArrayToImage(this.data);
            if (!this._htmlImageElement.naturalWidth) {
                this._htmlImageElement.onload = function (event) { return _this.onLoadComplete(event); };
                this._loadingImage = true;
                return _awayjs_core.ParserBase.MORE_TO_PARSE;
            }
            //if (ImageUtils.isHTMLImageElementValid(this._htmlImageElement)) {
            asset = ImageUtils.imageToBitmapImage2D(this._htmlImageElement, false, this._factory);
            this._pFinalizeAsset(asset, this._iFileName);
        }
        else if (this.data instanceof ArrayBuffer) {
            this._htmlImageElement = _awayjs_core.ParserUtils.arrayBufferToImage(this.data);
            asset = ImageUtils.imageToBitmapImage2D(this._htmlImageElement, false, this._factory);
            this._pFinalizeAsset(asset, this._iFileName);
        }
        else if (this.data instanceof Blob) {
            this._htmlImageElement = _awayjs_core.ParserUtils.blobToImage(this.data);
            this._htmlImageElement.onload = function (event) { return _this.onLoadComplete(event); };
            this._loadingImage = true;
            return _awayjs_core.ParserBase.MORE_TO_PARSE;
        }
        else if (this.data instanceof _awayjs_core.URLRequest) {
            asset = new ExternalImage2D(this.data);
            this._pFinalizeAsset(asset, this._iFileName);
        }
        if (sizeError) {
        }
        this._pContent = asset;
        return _awayjs_core.ParserBase.PARSING_DONE;
    };
    Image2DParser.prototype.onLoadComplete = function (event) {
        this._loadingImage = false;
    };
    return Image2DParser;
}(_awayjs_core.ParserBase));

/**
 * ImageCubeParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
 * a loader object, it wraps it in a BitmapImage2DResource so resource management can happen consistently without
 * exception cases.
 */
var ImageCubeParser = (function (_super) {
    __extends(ImageCubeParser, _super);
    /**
     * Creates a new ImageCubeParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function ImageCubeParser() {
        return _super.call(this, _awayjs_core.URLLoaderDataFormat.TEXT) || this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    ImageCubeParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "cube";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    ImageCubeParser.supportsData = function (data) {
        try {
            var obj = JSON.parse(data);
            if (obj)
                return true;
            return false;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * @inheritDoc
     */
    ImageCubeParser.prototype._iResolveDependency = function (resourceDependency) {
    };
    /**
     * @inheritDoc
     */
    ImageCubeParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
    };
    /**
     * @inheritDoc
     */
    ImageCubeParser.prototype._pProceedParsing = function () {
        if (this._imgDependencyDictionary != null) {
            var asset = new BitmapImageCube(this._getBitmapImage2D(ImageCubeParser.posX).width);
            asset.draw(BitmapImageCube.posX, this._getBitmapImage2D(ImageCubeParser.posX));
            asset.draw(BitmapImageCube.negX, this._getBitmapImage2D(ImageCubeParser.negX));
            asset.draw(BitmapImageCube.posY, this._getBitmapImage2D(ImageCubeParser.posY));
            asset.draw(BitmapImageCube.negY, this._getBitmapImage2D(ImageCubeParser.negY));
            asset.draw(BitmapImageCube.posZ, this._getBitmapImage2D(ImageCubeParser.posZ));
            asset.draw(BitmapImageCube.negZ, this._getBitmapImage2D(ImageCubeParser.negZ));
            //clear dictionary
            this._imgDependencyDictionary = null;
            asset.name = this._iFileName;
            this._pFinalizeAsset(asset, this._iFileName);
            return _awayjs_core.ParserBase.PARSING_DONE;
        }
        try {
            var json = JSON.parse(this.data);
            var data = json.data;
            var rec;
            if (data.length != 6)
                this._pDieWithError('ImageCubeParser: Error - cube texture should have exactly 6 images');
            if (json) {
                this._imgDependencyDictionary = new Object();
                for (var c = 0; c < data.length; c++) {
                    rec = data[c];
                    this._imgDependencyDictionary[rec.id] = this._pAddDependency(rec.id, new _awayjs_core.URLRequest(rec.image.toString()));
                }
                if (!this._validateCubeData()) {
                    this._pDieWithError("ImageCubeParser: JSON data error - cubes require id of:   \n" + ImageCubeParser.posX + ', ' + ImageCubeParser.negX + ',  \n' + ImageCubeParser.posY + ', ' + ImageCubeParser.negY + ',  \n' + ImageCubeParser.posZ + ', ' + ImageCubeParser.negZ);
                    return _awayjs_core.ParserBase.PARSING_DONE;
                }
                this._pPauseAndRetrieveDependencies();
                return _awayjs_core.ParserBase.MORE_TO_PARSE;
            }
        }
        catch (e) {
            this._pDieWithError('CubeTexturePaser Error parsing JSON');
        }
        return _awayjs_core.ParserBase.PARSING_DONE;
    };
    ImageCubeParser.prototype._validateCubeData = function () {
        return (this._imgDependencyDictionary[ImageCubeParser.posX] != null && this._imgDependencyDictionary[ImageCubeParser.negX] != null && this._imgDependencyDictionary[ImageCubeParser.posY] != null && this._imgDependencyDictionary[ImageCubeParser.negY] != null && this._imgDependencyDictionary[ImageCubeParser.posZ] != null && this._imgDependencyDictionary[ImageCubeParser.negZ] != null);
    };
    ImageCubeParser.prototype._getBitmapImage2D = function (name) {
        var dependency = this._imgDependencyDictionary[name];
        if (dependency)
            return dependency.assets[0];
        return null;
    };
    return ImageCubeParser;
}(_awayjs_core.ParserBase));
ImageCubeParser.posX = 'posX';
ImageCubeParser.negX = 'negX';
ImageCubeParser.posY = 'posY';
ImageCubeParser.negY = 'negY';
ImageCubeParser.posZ = 'posZ';
ImageCubeParser.negZ = 'negZ';

/**
 * TextureAtlasParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
 * a loader object, it wraps it in a BitmapImage2DResource so resource management can happen consistently without
 * exception cases.
 */
var TextureAtlasParser = (function (_super) {
    __extends(TextureAtlasParser, _super);
    /**
     * Creates a new TextureAtlasParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function TextureAtlasParser() {
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.TEXT) || this;
        _this._parseState = 0;
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    TextureAtlasParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "xml";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    TextureAtlasParser.supportsData = function (data) {
        try {
            var content = _awayjs_core.ParserUtils.toString(data);
            if (content.indexOf("TextureAtlas") != -1 || content.indexOf("textureatlas") != -1)
                return true;
            return false;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * @inheritDoc
     */
    TextureAtlasParser.prototype._iResolveDependency = function (resourceDependency) {
        if (resourceDependency.assets.length) {
            this._imageData = resourceDependency.assets[0];
            this._pFinalizeAsset(this._imageData);
            this._parseState = TextureAtlasParserState.PARSE_SUBTEXTURES;
        }
        else {
            this._parseState = TextureAtlasParserState.PARSE_COMPLETE;
        }
    };
    /**
     * @inheritDoc
     */
    TextureAtlasParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
        this._parseState = TextureAtlasParserState.PARSE_COMPLETE;
    };
    /**
     * @inheritDoc
     */
    TextureAtlasParser.prototype._pProceedParsing = function () {
        var nodes;
        switch (this._parseState) {
            case TextureAtlasParserState.PARSE_XML:
                try {
                    this._doc = _awayjs_core.XmlUtils.getChildrenWithTag(_awayjs_core.XmlUtils.strToXml(this._pGetTextData()), "TextureAtlas")[0];
                    this._imagePath = _awayjs_core.XmlUtils.readAttributeValue(this._doc, "imagePath");
                    this._subTextureNodes = _awayjs_core.XmlUtils.getChildrenWithTag(this._doc, "SubTexture");
                    this._parseState = TextureAtlasParserState.PARSE_IMAGE;
                }
                catch (Error) {
                    return _awayjs_core.ParserBase.PARSING_DONE;
                }
                break;
            case TextureAtlasParserState.PARSE_IMAGE:
                if (this._imagePath) {
                    this._pAddDependency(this._imagePath, new _awayjs_core.URLRequest(this._imagePath));
                    this._pPauseAndRetrieveDependencies();
                }
                else {
                    return _awayjs_core.ParserBase.PARSING_DONE;
                }
                break;
            case TextureAtlasParserState.PARSE_SUBTEXTURES:
                var sampler;
                var element;
                var x;
                var y;
                var width;
                var height;
                var len = this._subTextureNodes.length;
                for (var i = 0; i < len; i++) {
                    element = this._subTextureNodes[i];
                    sampler = new Sampler2D();
                    //setup subtexture rect
                    x = _awayjs_core.XmlUtils.readAttributeValue(element, "x");
                    y = _awayjs_core.XmlUtils.readAttributeValue(element, "y");
                    width = _awayjs_core.XmlUtils.readAttributeValue(element, "width");
                    height = _awayjs_core.XmlUtils.readAttributeValue(element, "height");
                    if (x || y || width || height)
                        sampler.imageRect = new _awayjs_core.Rectangle(parseInt(x) / this._imageData.width, parseInt(y) / this._imageData.height, parseInt(width) / this._imageData.width, parseInt(height) / this._imageData.height);
                    //setup frame rect
                    x = _awayjs_core.XmlUtils.readAttributeValue(element, "frameX");
                    y = _awayjs_core.XmlUtils.readAttributeValue(element, "frameY");
                    width = _awayjs_core.XmlUtils.readAttributeValue(element, "frameWidth");
                    height = _awayjs_core.XmlUtils.readAttributeValue(element, "frameHeight");
                    if (x || y || width || height)
                        sampler.frameRect = new _awayjs_core.Rectangle(parseInt(x), parseInt(y), parseInt(width), parseInt(height));
                    this._pFinalizeAsset(sampler, _awayjs_core.XmlUtils.readAttributeValue(element, "name"));
                }
                this._parseState = TextureAtlasParserState.PARSE_COMPLETE;
                break;
            case TextureAtlasParserState.PARSE_COMPLETE:
                return _awayjs_core.ParserBase.PARSING_DONE;
        }
        return _awayjs_core.ParserBase.MORE_TO_PARSE;
    };
    return TextureAtlasParser;
}(_awayjs_core.ParserBase));
var TextureAtlasParserState = (function () {
    function TextureAtlasParserState() {
    }
    return TextureAtlasParserState;
}());
TextureAtlasParserState.PARSE_XML = 0;
TextureAtlasParserState.PARSE_IMAGE = 1;
TextureAtlasParserState.PARSE_SUBTEXTURES = 2;
TextureAtlasParserState.PARSE_COMPLETE = 3;

/**
 * Value object ___ for a picking collision returned by a picking collider. Created as unique objects on display objects
 *
 * @see away.base.DisplayObject#pickingCollision
 * @see away.core.pick.IPickingCollider
 *
 * @class away.pick.PickingCollision
 */
var PickingCollision = (function () {
    /**
     * Creates a new <code>PickingCollision</code> object.
     *
     * @param entity The entity to which this collision object belongs.
     */
    function PickingCollision(entity) {
        this.entity = entity;
    }
    return PickingCollision;
}());

var MipmapGenerator = (function () {
    function MipmapGenerator() {
    }
    MipmapGenerator._generateMipMaps = function (source, output, alpha) {
        if (alpha === void 0) { alpha = false; }
        var w = source.width;
        var h = source.height;
        var i = 0;
        var mipmap;
        MipmapGenerator._rect.width = w;
        MipmapGenerator._rect.height = h;
        //use (OR) to create non-square texture mipmaps
        while (w >= 1 || h >= 1) {
            mipmap = output[i] = MipmapGenerator._getMipmapHolder(output[i], MipmapGenerator._rect.width, MipmapGenerator._rect.height);
            if (alpha)
                mipmap.fillRect(MipmapGenerator._rect, 0);
            MipmapGenerator._matrix.a = MipmapGenerator._rect.width / source.width;
            MipmapGenerator._matrix.d = MipmapGenerator._rect.height / source.height;
            //todo: add support for NPOT textures
            if (typeof document !== "undefined") {
                mipmap.draw(source, MipmapGenerator._matrix); //TODO: smoothing?
            }
            else {
                if (source.constructor.toString().indexOf("BitmapImage2D") > -1) {
                    //for BitmapImage2D
                    var bitmapImage = source;
                    bitmapImage.lock();
                    mipmap.lock();
                    this.downsampleImage(bitmapImage.getImageData(), mipmap.getImageData());
                    mipmap.unlock();
                    bitmapImage.unlock();
                }
                else if (source.constructor.toString().indexOf("CPUCanvas") > -1) {
                    this.downsampleImage(source.getImageData(), mipmap.getImageData());
                }
                else {
                    //for imageData
                    this.downsampleImage(source, mipmap.getImageData());
                }
            }
            w >>= 1;
            h >>= 1;
            MipmapGenerator._rect.width = w > 1 ? w : 1;
            MipmapGenerator._rect.height = h > 1 ? h : 1;
            i++;
        }
    };
    MipmapGenerator._getMipmapHolder = function (mipMapHolder, newW, newH) {
        if (mipMapHolder) {
            if (mipMapHolder.width == newW && mipMapHolder.height == newH)
                return mipMapHolder;
            MipmapGenerator._freeMipMapHolder(mipMapHolder);
        }
        if (!MipmapGenerator._mipMaps[newW]) {
            MipmapGenerator._mipMaps[newW] = [];
            MipmapGenerator._mipMapUses[newW] = [];
        }
        if (!MipmapGenerator._mipMaps[newW][newH]) {
            mipMapHolder = MipmapGenerator._mipMaps[newW][newH] = new BitmapImage2D(newW, newH, true);
            MipmapGenerator._mipMapUses[newW][newH] = 1;
        }
        else {
            MipmapGenerator._mipMapUses[newW][newH] = MipmapGenerator._mipMapUses[newW][newH] + 1;
            mipMapHolder = MipmapGenerator._mipMaps[newW][newH];
        }
        return mipMapHolder;
    };
    MipmapGenerator._freeMipMapHolder = function (mipMapHolder) {
        var holderWidth = mipMapHolder.width;
        var holderHeight = mipMapHolder.height;
        if (--MipmapGenerator._mipMapUses[holderWidth][holderHeight] == 0) {
            MipmapGenerator._mipMaps[holderWidth][holderHeight].dispose();
            MipmapGenerator._mipMaps[holderWidth][holderHeight] = null;
        }
    };
    MipmapGenerator.downsampleImage = function (bitmap, destBitmap) {
        var box = new BoxFilter();
        var xkernel = new PolyphaseKernel(box, bitmap.width, destBitmap.width, 4);
        var ykernel = new PolyphaseKernel(box, bitmap.height, destBitmap.height, 4);
        var tempBitmap = []; //destBitmap.width, bitmap.height
        var scale = 0;
        var iscale = 0;
        var kernelLength = 0;
        var kernelWidth = 0;
        var kernelWindowSize = 0;
        var sumR = 0;
        var sumG = 0;
        var sumB = 0;
        var sumA = 0;
        var center;
        var left;
        var i = 0;
        var j = 0;
        var index = 0;
        for (var y = 0; y < bitmap.height; y++) {
            kernelLength = xkernel.len;
            scale = kernelLength / bitmap.width;
            iscale = 1.0 / scale;
            kernelWidth = xkernel.width;
            kernelWindowSize = xkernel.windowSize;
            for (i = 0; i < kernelLength; i++) {
                center = (0.5 + i) * iscale;
                left = Math.floor(center - kernelWidth);
                sumR = 0;
                sumG = 0;
                sumB = 0;
                sumA = 0;
                for (var j = 0; j < kernelWindowSize; ++j) {
                    index = (y * bitmap.width + (left + j)) * 4;
                    var colorR = bitmap.data[index];
                    var colorG = bitmap.data[index + 1];
                    var colorB = bitmap.data[index + 2];
                    var colorA = bitmap.data[index + 3];
                    var value = xkernel.valueAt(i, j);
                    sumR += value * colorR;
                    sumG += value * colorG;
                    sumB += value * colorB;
                    sumA += value * colorA;
                }
                index = (y * destBitmap.width + i) * 4;
                tempBitmap[index] = sumR;
                tempBitmap[index + 1] = sumG;
                tempBitmap[index + 2] = sumB;
                tempBitmap[index + 3] = sumA;
            }
        }
        for (var x = 0; x < destBitmap.width; x++) {
            kernelLength = ykernel.len;
            scale = kernelLength / bitmap.height;
            iscale = 1.0 / scale;
            kernelWidth = ykernel.width;
            kernelWindowSize = ykernel.windowSize;
            for (i = 0; i < kernelLength; i++) {
                center = (0.5 + i) * iscale;
                left = Math.floor(center - kernelWidth);
                sumR = 0;
                sumG = 0;
                sumB = 0;
                sumA = 0;
                for (j = 0; j < kernelWindowSize; ++j) {
                    index = ((j + left) * destBitmap.width + x) * 4;
                    var colorR = tempBitmap[index];
                    var colorG = tempBitmap[index + 1];
                    var colorB = tempBitmap[index + 2];
                    var colorA = tempBitmap[index + 3];
                    var value = ykernel.valueAt(i, j);
                    sumR += value * colorR;
                    sumG += value * colorG;
                    sumB += value * colorB;
                    sumA += value * colorA;
                }
                index = (i * destBitmap.width + x) * 4;
                destBitmap.data[index] = sumR;
                destBitmap.data[index + 1] = sumG;
                destBitmap.data[index + 2] = sumB;
                destBitmap.data[index + 3] = sumA;
            }
        }
        return destBitmap;
    };
    return MipmapGenerator;
}());
MipmapGenerator._mipMaps = [];
MipmapGenerator._mipMapUses = [];
MipmapGenerator._matrix = new _awayjs_core.Matrix();
MipmapGenerator._rect = new _awayjs_core.Rectangle();
var PolyphaseKernel = (function () {
    function PolyphaseKernel(f, srcLength, dstLength, samples) {
        var scale = dstLength / srcLength;
        var iscale = 1.0 / scale;
        if (scale > 1) {
            // Upsampling.
            samples = 1;
            scale = 1;
        }
        this.len = dstLength;
        this.width = f.width * iscale;
        this.windowSize = Math.ceil(this.width * 2);
        this.data = [];
        for (var i = 0; i < this.len; i++) {
            var center = (0.5 + i) * iscale;
            var left = Math.floor(center - this.width);
            var total = 0.0;
            for (var j = 0; j < this.windowSize; j++) {
                var sample = f.sampleBox(left + j - center, scale, samples);
                //printf("%f %X\n", sample, *(uint32 *)&sample);
                this.data[i * this.windowSize + j] = sample;
                total += sample;
            }
            // normalize weights.
            for (var j = 0; j < this.windowSize; j++) {
                this.data[i * this.windowSize + j] /= total;
            }
        }
    }
    PolyphaseKernel.prototype.valueAt = function (column, x) {
        return this.data[column * this.windowSize + x];
    };
    return PolyphaseKernel;
}());
var BoxFilter = (function () {
    function BoxFilter() {
    }
    Object.defineProperty(BoxFilter.prototype, "width", {
        get: function () {
            return 0.5;
        },
        enumerable: true,
        configurable: true
    });
    BoxFilter.prototype.sampleBox = function (x, scale, samples) {
        var sum = 0;
        var isamples = 1.0 / samples;
        for (var s = 0; s < samples; s++) {
            var p = (x + (s + 0.5) * isamples) * scale;
            var value = this.evaluate(p);
            sum += value;
        }
        return sum * isamples;
    };
    BoxFilter.prototype.evaluate = function (x) {
        if (Math.abs(x) <= this.width)
            return 1.0;
        else
            return 0.0;
    };
    return BoxFilter;
}());

exports.ParticleData = ParticleData;
exports.AnimationNodeBase = AnimationNodeBase;
exports.Shape = Shape;
exports.Style = Style;
exports.TraverserBase = TraverserBase;
exports.CapsStyle = CapsStyle;
exports.DrawMode = DrawMode;
exports.GradientType = GradientType;
exports.GraphicsFactoryFills = GraphicsFactoryFills;
exports.GraphicsFactoryHelper = GraphicsFactoryHelper;
exports.GraphicsFactoryStrokes = GraphicsFactoryStrokes;
exports.GraphicsFillStyle = GraphicsFillStyle;
exports.GradientFillStyle = GradientFillStyle;
exports.GraphicsStrokeStyle = GraphicsStrokeStyle;
exports.GraphicsPath = GraphicsPath;
exports.GraphicsPathCommand = GraphicsPathCommand;
exports.GraphicsPathWinding = GraphicsPathWinding;
exports.InterpolationMethod = InterpolationMethod;
exports.JointStyle = JointStyle;
exports.LineScaleMode = LineScaleMode;
exports.PixelSnapping = PixelSnapping;
exports.SpreadMethod = SpreadMethod;
exports.TriangleCulling = TriangleCulling;
exports.ElementsEvent = ElementsEvent;
exports.ImageEvent = ImageEvent;
exports.MaterialEvent = MaterialEvent;
exports.RenderableEvent = RenderableEvent;
exports.ShapeEvent = ShapeEvent;
exports.StyleEvent = StyleEvent;
exports.ElementsBase = ElementsBase;
exports.ElementsType = ElementsType;
exports.LineElements = LineElements;
exports.TriangleElements = TriangleElements;
exports.DefaultGraphicsFactory = DefaultGraphicsFactory;
exports.BitmapImage2D = BitmapImage2D;
exports.BitmapImageChannel = BitmapImageChannel;
exports.BitmapImageCube = BitmapImageCube;
exports.BlendMode = BlendMode;
exports.CPUCanvas = CPUCanvas;
exports.CPURenderingContext2D = CPURenderingContext2D;
exports.ExternalImage2D = ExternalImage2D;
exports.Image2D = Image2D;
exports.ImageBase = ImageBase;
exports.ImageCube = ImageCube;
exports.ImageData = ImageData;
exports.Sampler2D = Sampler2D;
exports.SamplerBase = SamplerBase;
exports.SamplerCube = SamplerCube;
exports.SpecularImage2D = SpecularImage2D;
exports.DefaultMaterialManager = DefaultMaterialManager;
exports.TextureAtlas = TextureAtlas;
exports.BasicMaterial = BasicMaterial;
exports.MaterialBase = MaterialBase;
exports.Image2DParser = Image2DParser;
exports.ImageCubeParser = ImageCubeParser;
exports.TextureAtlasParser = TextureAtlasParser;
exports.PickingCollision = PickingCollision;
exports.Single2DTexture = Single2DTexture;
exports.SingleCubeTexture = SingleCubeTexture;
exports.TextureBase = TextureBase;
exports.BitmapImageUtils = BitmapImageUtils;
exports.ElementsUtils = ElementsUtils;
exports.HitTestCache = HitTestCache;
exports.ImageUtils = ImageUtils;
exports.MipmapGenerator = MipmapGenerator;
exports.Graphics = Graphics;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(7), __webpack_require__(9)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/core', '@awayjs/graphics'], factory) :
    (factory((global.AwayjsScene = global.AwayjsScene || {}),global.AwayjsCore,global.AwayjsGraphics));
}(this, (function (exports,_awayjs_core,_awayjs_graphics) { 'use strict';

/**
 *
 */
var AlignmentMode = (function () {
    function AlignmentMode() {
    }
    return AlignmentMode;
}());
/**
 *
 */
AlignmentMode.REGISTRATION_POINT = "registrationPoint";
/**
 *
 */
AlignmentMode.TRANSFORM_POINT = "transformPoint";

/**
 *
 */
var HierarchicalProperties = (function () {
    function HierarchicalProperties() {
    }
    return HierarchicalProperties;
}());
/**
 *
 */
HierarchicalProperties.MOUSE_ENABLED = 1;
/**
 *
 */
HierarchicalProperties.VISIBLE = 2;
/**
 *
 */
HierarchicalProperties.MASK_ID = 4;
/**
 *
 */
HierarchicalProperties.MASKS = 8;
/**
 *
 */
HierarchicalProperties.COLOR_TRANSFORM = 16;
/**
 *
 */
HierarchicalProperties.SCENE_TRANSFORM = 32;
/**
 *
 */
HierarchicalProperties.ALL = 63;

var OrientationMode = (function () {
    function OrientationMode() {
    }
    return OrientationMode;
}());
/**
 *
 */
OrientationMode.DEFAULT = "default";
/**
 *
 */
OrientationMode.CAMERA_PLANE = "cameraPlane";
/**
 *
 */
OrientationMode.CAMERA_POSITION = "cameraPosition";

var FrameScriptManager = (function () {
    function FrameScriptManager() {
    }
    FrameScriptManager.setInterval = function (func) {
        this._intervalID++;
        this._active_intervals[this._intervalID] = func;
        return this._intervalID;
    };
    FrameScriptManager.clearInterval = function (id) {
        delete this._active_intervals[id];
    };
    FrameScriptManager.execute_intervals = function () {
        for (var key in this._active_intervals) {
            this._active_intervals[key].call();
        }
    };
    FrameScriptManager.add_child_to_dispose = function (child) {
        this._queued_dispose.push(child);
    };
    FrameScriptManager.add_script_to_queue = function (mc, script) {
        // whenever we queue scripts of new objects, we first inject the lists of pass2
        var i = this._queued_mcs_pass2.length;
        while (i--) {
            this._queued_mcs.push(this._queued_mcs_pass2[i]);
            this._queued_scripts.push(this._queued_scripts_pass2[i]);
        }
        this._queued_mcs_pass2.length = 0;
        this._queued_scripts_pass2.length = 0;
        this._queued_mcs.push(mc);
        this._queued_scripts.push(script);
    };
    FrameScriptManager.add_script_to_queue_pass2 = function (mc, script) {
        this._queued_mcs_pass2.push(mc);
        this._queued_scripts_pass2.push(script);
    };
    FrameScriptManager.execute_queue = function () {
        if (this._queued_mcs.length == 0 && this._queued_mcs_pass2.length == 0)
            return;
        var i = this._queued_mcs_pass2.length;
        while (i--) {
            this._queued_mcs.push(this._queued_mcs_pass2[i]);
            this._queued_scripts.push(this._queued_scripts_pass2[i]);
        }
        this._queued_mcs_pass2.length = 0;
        this._queued_scripts_pass2.length = 0;
        var mc;
        for (i = 0; i < this._queued_mcs.length; i++) {
            // during the loop we might add more scripts to the queue
            mc = this._queued_mcs[i];
            if (mc.scene != null) {
                //	try {
                this._queued_scripts[i].call(mc.adapter);
            }
        }
        // all scripts executed. clear all
        this._queued_mcs.length = 0;
        this._queued_scripts.length = 0;
    };
    FrameScriptManager.execute_dispose = function () {
        /*
        var len:number = this._queued_dispose.length;
        for (var i:number = 0; i < len; i++)
            this._queued_dispose[i].dispose();

        this._queued_dispose.length = 0;
        */
    };
    return FrameScriptManager;
}());
// FrameScript debugging:
// the first line of a FrameScript should be a comment that represents the functions unique name
// the exporter creates a js file, containing a object that has the framescripts functions set as properties according to the unique names
// this object can be set as "frameScriptDebug" in order to enable debug mode
FrameScriptManager.frameScriptDebug = undefined;
//queue of objects for disposal
FrameScriptManager._queued_dispose = new Array();
// queues pass1 of scripts.
FrameScriptManager._queued_mcs = [];
FrameScriptManager._queued_scripts = [];
// queues pass2 of scripts. this will be inserted in reversed order into pass1 queue right before something should be added to pass1
FrameScriptManager._queued_mcs_pass2 = [];
FrameScriptManager._queued_scripts_pass2 = [];
FrameScriptManager._active_intervals = new Object(); // maps id to function
FrameScriptManager._intervalID = 0;

var Timeline = (function () {
    function Timeline() {
        this._functions = [];
        this._update_indices = [];
        this.numKeyFrames = 0;
        this.keyframe_indices = [];
        this._potentialPrototypes = [];
        this._labels = {};
        this._framescripts = {};
        this._framescripts_translated = {};
        //cache functions
        this._functions[1] = this.update_mtx_all;
        this._functions[2] = this.update_colortransform;
        this._functions[3] = this.update_masks;
        this._functions[4] = this.update_name;
        this._functions[5] = this.update_button_name;
        this._functions[6] = this.update_visibility;
        this._functions[7] = this.update_blendmode;
        this._functions[8] = this.update_rendermode;
        this._functions[11] = this.update_mtx_scale_rot;
        this._functions[12] = this.update_mtx_pos;
        this._functions[200] = this.enable_maskmode;
        this._functions[201] = this.remove_masks;
    }
    Timeline.prototype.init = function () {
        if ((this.frame_command_indices == null) || (this.frame_recipe == null) || (this.keyframe_durations == null))
            return;
        this.keyframe_firstframes = [];
        this.keyframe_constructframes = [];
        var frame_cnt = 0;
        var ic = 0;
        var ic2 = 0;
        var keyframe_cnt = 0;
        var last_construct_frame = 0;
        for (ic = 0; ic < this.numKeyFrames; ic++) {
            var duration = this.keyframe_durations[(ic)];
            if (this.frame_recipe[ic] & 1)
                last_construct_frame = keyframe_cnt;
            this.keyframe_firstframes[keyframe_cnt] = frame_cnt;
            this.keyframe_constructframes[keyframe_cnt++] = last_construct_frame;
            for (ic2 = 0; ic2 < duration; ic2++)
                this.keyframe_indices[frame_cnt++] = ic;
        }
    };
    Timeline.prototype.get_framescript = function (keyframe_index) {
        if (this._framescripts[keyframe_index] == null)
            return "";
        if (typeof this._framescripts[keyframe_index] == "string")
            return this._framescripts[keyframe_index];
        else {
            throw new Error("Framescript is already translated to Function!!!");
        }
    };
    Timeline.prototype.add_framescript = function (value, keyframe_index) {
        if (FrameScriptManager.frameScriptDebug) {
            // if we are in debug mode, we try to extract the function name from the first line of framescript code,
            // and check if this function is available on the object that is set as frameScriptDebug
            // try to get the functions name (it should be the first line as comment)
            var functionname = value.split(/[\r\n]+/g)[0].split("//")[1];
            if (FrameScriptManager.frameScriptDebug[functionname]) {
                this._framescripts[keyframe_index] = FrameScriptManager.frameScriptDebug[functionname];
                this._framescripts_translated[keyframe_index] = true;
                return;
            }
            else {
                throw new Error("Framescript could not be found on FrameScriptManager.frameScriptDebug.\n the Object set as FrameScriptmanager.frameScriptDebug should contain a function with the name '" + functionname + "' !!!");
            }
        }
        this._framescripts[keyframe_index] = value;
    };
    Timeline.prototype.regexIndexOf = function (str, regex, startpos) {
        var indexOf = str.substring(startpos || 0).search(regex);
        return (indexOf >= 0) ? (indexOf + (startpos || 0)) : indexOf;
    };
    Timeline.prototype.add_script_for_postcontruct = function (target_mc, keyframe_idx, scriptPass1) {
        if (scriptPass1 === void 0) { scriptPass1 = false; }
        if (this._framescripts[keyframe_idx] != null) {
            if (this._framescripts_translated[keyframe_idx] == null) {
                this._framescripts[keyframe_idx] = target_mc.adapter.evalScript(this._framescripts[keyframe_idx]);
                this._framescripts_translated[keyframe_idx] = true;
            }
            if (scriptPass1)
                FrameScriptManager.add_script_to_queue(target_mc, this._framescripts[keyframe_idx]);
            else
                FrameScriptManager.add_script_to_queue_pass2(target_mc, this._framescripts[keyframe_idx]);
        }
    };
    Object.defineProperty(Timeline.prototype, "numFrames", {
        get: function () {
            return this.keyframe_indices.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Timeline.prototype, "potentialPrototypes", {
        get: function () {
            return this._potentialPrototypes;
        },
        enumerable: true,
        configurable: true
    });
    Timeline.prototype.getPotentialChildPrototype = function (id) {
        return this._potentialPrototypes[id];
    };
    Timeline.prototype.getKeyframeIndexForFrameIndex = function (frame_index) {
        return this.keyframe_indices[frame_index];
    };
    Timeline.prototype.getPotentialChildInstance = function (id) {
        var this_clone = this._potentialPrototypes[id].adapter.clone().adaptee;
        //this_clone.name = "";
        //if (this_clone.isAsset(Billboard)){
        //var billboard:Billboard=(<Billboard>this_clone);
        //billboard.style=new Style();
        //billboard.style.uvMatrix=new Matrix(1,0,0,-1,0,0);
        //billboard.style.uvMatrix.scale(1,1);
        //billboard.material.animateUVs=true;
        //}
        return this_clone;
    };
    Timeline.prototype.registerPotentialChild = function (prototype) {
        var id = this._potentialPrototypes.length;
        this._potentialPrototypes[id] = prototype;
    };
    Timeline.prototype.jumpToLabel = function (target_mc, label) {
        var key_frame_index = this._labels[label];
        if (key_frame_index >= 0)
            target_mc.currentFrameIndex = this.keyframe_firstframes[key_frame_index];
    };
    Timeline.prototype.gotoFrame = function (target_mc, value, skip_script) {
        if (skip_script === void 0) { skip_script = false; }
        var current_keyframe_idx = target_mc.constructedKeyFrameIndex;
        var target_keyframe_idx = this.keyframe_indices[value];
        if (current_keyframe_idx == target_keyframe_idx)
            return;
        if (current_keyframe_idx + 1 == target_keyframe_idx) {
            this.constructNextFrame(target_mc, !skip_script, true);
            return;
        }
        var break_frame_idx = this.keyframe_constructframes[target_keyframe_idx];
        //we now have 3 index to keyframes: current_keyframe_idx / target_keyframe_idx / break_frame_idx
        var jump_forward = (target_keyframe_idx > current_keyframe_idx);
        var jump_gap = (break_frame_idx > current_keyframe_idx);
        // in case we jump forward, but not jump a gap, we start at current_keyframe_idx + 1
        // in case we jump back or we jump a gap, we want to start constructing at BreakFrame
        var start_construct_idx = (jump_forward && !jump_gap) ? current_keyframe_idx + 1 : break_frame_idx;
        var i;
        var k;
        if (jump_gap)
            for (i = target_mc.numChildren - 1; i >= 0; i--)
                if (target_mc._children[i]._depthID < 0)
                    target_mc.removeChildAt(i);
        //if we jump back, we want to reset all objects (but not the timelines of the mcs)
        if (!jump_forward)
            target_mc.resetSessionIDs();
        // in other cases, we want to collect the current objects to compare state of targetframe with state of currentframe
        var depth_sessionIDs = target_mc.getSessionIDDepths();
        //pass1: only apply add/remove commands into depth_sessionIDs.
        this.pass1(start_construct_idx, target_keyframe_idx, depth_sessionIDs);
        // check what childs are alive on both frames.
        // childs that are not alive anymore get removed and unregistered
        // childs that are alive on both frames have their properties reset if we are jumping back
        var child;
        for (i = target_mc.numChildren - 1; i >= 0; i--) {
            child = target_mc._children[i];
            if (child._depthID < 0) {
                if (depth_sessionIDs[child._depthID] != child._sessionID) {
                    target_mc.removeChildAt(i);
                }
                else if (!jump_forward) {
                    if (child._adapter) {
                        if (!child.adapter.isBlockedByScript()) {
                            child.transform.clearMatrix3D();
                            child.transform.clearColorTransform();
                            //this.name="";
                            child.masks = null;
                            child.maskMode = false;
                        }
                        if (!child.adapter.isVisibilityByScript()) {
                            child.visible = true;
                        }
                    }
                }
            }
        }
        // now we need to addchild the objects that were added before targetframe first
        // than we can add the script of the targetframe
        // than we can addchild objects added on targetframe
        for (var key in depth_sessionIDs) {
            child = target_mc.getPotentialChildInstance(this.add_child_stream[depth_sessionIDs[key] * 2]);
            if (child._sessionID == -1)
                target_mc._addTimelineChildAt(child, Number(key), depth_sessionIDs[key]);
        }
        if (!skip_script && this.keyframe_firstframes[target_keyframe_idx] == value)
            this.add_script_for_postcontruct(target_mc, target_keyframe_idx, true);
        //pass2: apply update commands for objects on stage (only if they are not blocked by script)
        this.pass2(target_mc);
        target_mc.constructedKeyFrameIndex = target_keyframe_idx;
    };
    Timeline.prototype.pass1 = function (start_construct_idx, target_keyframe_idx, depth_sessionIDs) {
        var i;
        var k;
        this._update_indices.length = 0; // store a list of updatecommand_indices, so we dont have to read frame_recipe again
        var update_cnt = 0;
        var start_index;
        var end_index;
        for (k = start_construct_idx; k <= target_keyframe_idx; k++) {
            var frame_command_idx = this.frame_command_indices[k];
            var frame_recipe = this.frame_recipe[k];
            if (frame_recipe & 2) {
                // remove childs
                start_index = this.command_index_stream[frame_command_idx];
                end_index = start_index + this.command_length_stream[frame_command_idx++];
                for (i = start_index; i < end_index; i++)
                    delete depth_sessionIDs[this.remove_child_stream[i] - 16383];
            }
            if (frame_recipe & 4) {
                start_index = this.command_index_stream[frame_command_idx];
                end_index = start_index + this.command_length_stream[frame_command_idx++];
                // apply add commands in reversed order to have script exeucted in correct order.
                // this could be changed in exporter
                for (i = end_index - 1; i >= start_index; i--)
                    depth_sessionIDs[this.add_child_stream[i * 2 + 1] - 16383] = i;
            }
            if (frame_recipe & 8)
                this._update_indices[update_cnt++] = frame_command_idx; // execute update command later
        }
    };
    Timeline.prototype.pass2 = function (target_mc) {
        var k;
        var len = this._update_indices.length;
        for (k = 0; k < len; k++)
            this.update_childs(target_mc, this._update_indices[k]);
    };
    Timeline.prototype.constructNextFrame = function (target_mc, queueScript, scriptPass1) {
        if (queueScript === void 0) { queueScript = true; }
        if (scriptPass1 === void 0) { scriptPass1 = false; }
        var frameIndex = target_mc.currentFrameIndex;
        var new_keyFrameIndex = this.keyframe_indices[frameIndex];
        if (queueScript && this.keyframe_firstframes[new_keyFrameIndex] == frameIndex)
            this.add_script_for_postcontruct(target_mc, new_keyFrameIndex, scriptPass1);
        if (target_mc.constructedKeyFrameIndex != new_keyFrameIndex) {
            target_mc.constructedKeyFrameIndex = new_keyFrameIndex;
            var frame_command_idx = this.frame_command_indices[new_keyFrameIndex];
            var frame_recipe = this.frame_recipe[new_keyFrameIndex];
            if (frame_recipe & 1) {
                for (var i = target_mc.numChildren - 1; i >= 0; i--)
                    if (target_mc._children[i]._depthID < 0)
                        target_mc.removeChildAt(i);
            }
            else if (frame_recipe & 2) {
                this.remove_childs_continous(target_mc, frame_command_idx++);
            }
            if (frame_recipe & 4)
                this.add_childs_continous(target_mc, frame_command_idx++);
            if (frame_recipe & 8)
                this.update_childs(target_mc, frame_command_idx++);
        }
    };
    Timeline.prototype.remove_childs_continous = function (sourceMovieClip, frame_command_idx) {
        var start_index = this.command_index_stream[frame_command_idx];
        var end_index = start_index + this.command_length_stream[frame_command_idx];
        for (var i = start_index; i < end_index; i++)
            sourceMovieClip.removeChildAt(sourceMovieClip.getDepthIndexInternal(this.remove_child_stream[i] - 16383));
    };
    // used to add childs when jumping between frames
    Timeline.prototype.add_childs_continous = function (sourceMovieClip, frame_command_idx) {
        // apply add commands in reversed order to have script exeucted in correct order.
        // this could be changed in exporter
        var idx;
        var start_index = this.command_index_stream[frame_command_idx];
        var end_index = start_index + this.command_length_stream[frame_command_idx];
        for (var i = end_index - 1; i >= start_index; i--) {
            idx = i * 2;
            sourceMovieClip._addTimelineChildAt(sourceMovieClip.getPotentialChildInstance(this.add_child_stream[idx]), this.add_child_stream[idx + 1] - 16383, i);
        }
    };
    Timeline.prototype.update_childs = function (target_mc, frame_command_idx) {
        var p;
        var props_start_idx;
        var props_end_index;
        var start_index = this.command_index_stream[frame_command_idx];
        var end_index = start_index + this.command_length_stream[frame_command_idx];
        var child;
        for (var i = start_index; i < end_index; i++) {
            child = target_mc.getChildAtSessionID(this.update_child_stream[i]);
            if (child) {
                // check if the child is active + not blocked by script
                this._blocked = Boolean(child._adapter && child.adapter.isBlockedByScript());
                props_start_idx = this.update_child_props_indices_stream[i];
                props_end_index = props_start_idx + this.update_child_props_length_stream[i];
                for (p = props_start_idx; p < props_end_index; p++)
                    this._functions[this.property_type_stream[p]].call(this, child, target_mc, this.property_index_stream[p]);
            }
        }
    };
    Timeline.prototype.update_mtx_all = function (child, target_mc, i) {
        if (this._blocked)
            return;
        i *= 6;
        var new_matrix = child.transform.matrix3D;
        new_matrix._rawData[0] = this.properties_stream_f32_mtx_all[i++];
        new_matrix._rawData[1] = this.properties_stream_f32_mtx_all[i++];
        new_matrix._rawData[4] = this.properties_stream_f32_mtx_all[i++];
        new_matrix._rawData[5] = this.properties_stream_f32_mtx_all[i++];
        new_matrix._rawData[12] = this.properties_stream_f32_mtx_all[i++];
        new_matrix._rawData[13] = this.properties_stream_f32_mtx_all[i];
        child.transform.invalidateComponents();
    };
    Timeline.prototype.update_colortransform = function (child, target_mc, i) {
        if (this._blocked)
            return;
        i *= 8;
        var new_ct = child.transform.colorTransform || (child.transform.colorTransform = new _awayjs_core.ColorTransform());
        new_ct._rawData[0] = this.properties_stream_f32_ct[i++];
        new_ct._rawData[1] = this.properties_stream_f32_ct[i++];
        new_ct._rawData[2] = this.properties_stream_f32_ct[i++];
        new_ct._rawData[3] = this.properties_stream_f32_ct[i++];
        new_ct._rawData[4] = this.properties_stream_f32_ct[i++];
        new_ct._rawData[5] = this.properties_stream_f32_ct[i++];
        new_ct._rawData[6] = this.properties_stream_f32_ct[i++];
        new_ct._rawData[7] = this.properties_stream_f32_ct[i];
        child.transform.invalidateColorTransform();
    };
    Timeline.prototype.update_masks = function (child, target_mc, i) {
        // an object could have multiple groups of masks, in case a graphic clip was merged into the timeline
        // this is not implmeented in the runtime yet
        // for now, a second mask-groupd would overwrite the first one
        var mask;
        var masks = new Array();
        var numMasks = this.properties_stream_int[i++];
        //mask may not exist if a goto command moves the playhead to a point in the timeline after
        //one of the masks in a mask array has already been removed. Therefore a check is needed.
        for (var m = 0; m < numMasks; m++)
            if ((mask = target_mc.getChildAtSessionID(this.properties_stream_int[i++])))
                masks.push(mask);
        child.masks = masks;
    };
    Timeline.prototype.update_name = function (child, target_mc, i) {
        child.name = this.properties_stream_strings[i];
        target_mc.adapter.registerScriptObject(child);
    };
    Timeline.prototype.update_button_name = function (target, sourceMovieClip, i) {
        target.name = this.properties_stream_strings[i];
        // todo: creating the buttonlistenrs later should also be done, but for icycle i dont think this will cause problems
        target.addButtonListeners();
        sourceMovieClip.adapter.registerScriptObject(target);
    };
    Timeline.prototype.update_visibility = function (child, target_mc, i) {
        if (!child._adapter || !child.adapter.isVisibilityByScript())
            child.visible = Boolean(i);
    };
    Timeline.prototype.update_mtx_scale_rot = function (child, target_mc, i) {
        if (this._blocked)
            return;
        i *= 4;
        var new_matrix = child.transform.matrix3D;
        new_matrix._rawData[0] = this.properties_stream_f32_mtx_scale_rot[i++];
        new_matrix._rawData[1] = this.properties_stream_f32_mtx_scale_rot[i++];
        new_matrix._rawData[4] = this.properties_stream_f32_mtx_scale_rot[i++];
        new_matrix._rawData[5] = this.properties_stream_f32_mtx_scale_rot[i];
        child.transform.invalidateComponents();
        child.pInvalidateHierarchicalProperties(HierarchicalProperties.SCENE_TRANSFORM);
    };
    Timeline.prototype.update_mtx_pos = function (child, target_mc, i) {
        if (this._blocked)
            return;
        i *= 2;
        var new_matrix = child.transform.matrix3D;
        new_matrix._rawData[12] = this.properties_stream_f32_mtx_pos[i++];
        new_matrix._rawData[13] = this.properties_stream_f32_mtx_pos[i];
        child.transform.invalidatePosition();
    };
    Timeline.prototype.enable_maskmode = function (child, target_mc, i) {
        child.maskMode = true;
    };
    Timeline.prototype.remove_masks = function (child, target_mc, i) {
        child.masks = null;
    };
    Timeline.prototype.update_blendmode = function (child, target_mc, i) {
        console.log("update blendmode " + i);
    };
    Timeline.prototype.update_rendermode = function (child, target_mc, i) {
        console.log("update rendermode " + i);
    };
    return Timeline;
}());

/**
 *
 */
var TouchPoint = (function () {
    function TouchPoint(x, y, id) {
        this.x = x;
        this.y = y;
        this.id = id;
    }
    return TouchPoint;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

/**
 *
 */
var BoundsType = (function () {
    function BoundsType() {
    }
    return BoundsType;
}());
/**
 *
 */
BoundsType.SPHERE = "sphere";
/**
 *
 */
BoundsType.AXIS_ALIGNED_BOX = "axisAlignedBox";
/**
 *
 */
BoundsType.NULL = "null";

var DisplayObjectEvent = (function (_super) {
    __extends(DisplayObjectEvent, _super);
    function DisplayObjectEvent(type, object) {
        var _this = _super.call(this, type) || this;
        _this._object = object;
        return _this;
    }
    Object.defineProperty(DisplayObjectEvent.prototype, "object", {
        get: function () {
            return this._object;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     * @return An exact duplicate of the current object.
     */
    DisplayObjectEvent.prototype.clone = function () {
        return new DisplayObjectEvent(this.type, this._object);
    };
    return DisplayObjectEvent;
}(_awayjs_core.EventBase));
/**
 *
 */
DisplayObjectEvent.VISIBLITY_UPDATED = "visiblityUpdated";
/**
 *
 */
DisplayObjectEvent.SCENETRANSFORM_CHANGED = "scenetransformChanged";
/**
 *
 */
DisplayObjectEvent.SCENE_CHANGED = "sceneChanged";
/**
 *
 */
DisplayObjectEvent.PARTITION_CHANGED = "partitionChanged";
/**
 *
 */
DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS = "invalidatePartitionBounds";

/**
 * The DisplayObject class is the base class for all objects that can be
 * placed on the display list. The display list manages all objects displayed
 * in flash. Use the DisplayObjectContainer class to arrange the
 * display objects in the display list. DisplayObjectContainer objects can
 * have child display objects, while other display objects, such as Shape and
 * TextField objects, are "leaf" nodes that have only parents and siblings, no
 * children.
 *
 * <p>The DisplayObject class supports basic functionality like the <i>x</i>
 * and <i>y</i> position of an object, as well as more advanced properties of
 * the object such as its transformation matrix. </p>
 *
 * <p>DisplayObject is an abstract base class; therefore, you cannot call
 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
 * <code>ArgumentError</code> exception. </p>
 *
 * <p>All display objects inherit from the DisplayObject class.</p>
 *
 * <p>The DisplayObject class itself does not include any APIs for rendering
 * content onscreen. For that reason, if you want create a custom subclass of
 * the DisplayObject class, you will want to extend one of its subclasses that
 * do have APIs for rendering content onscreen, such as the Shape, Sprite,
 * Bitmap, SimpleButton, TextField, or MovieClip class.</p>
 *
 * <p>The DisplayObject class contains several broadcast events. Normally, the
 * target of any particular event is a specific DisplayObject instance. For
 * example, the target of an <code>added</code> event is the specific
 * DisplayObject instance that was added to the display list. Having a single
 * target restricts the placement of event listeners to that target and in
 * some cases the target's ancestors on the display list. With broadcast
 * events, however, the target is not a specific DisplayObject instance, but
 * rather all DisplayObject instances, including those that are not on the
 * display list. This means that you can add a listener to any DisplayObject
 * instance to listen for broadcast events. In addition to the broadcast
 * events listed in the DisplayObject class's Events table, the DisplayObject
 * class also inherits two broadcast events from the EventDispatcher class:
 * <code>activate</code> and <code>deactivate</code>.</p>
 *
 * <p>Some properties previously used in the ActionScript 1.0 and 2.0
 * MovieClip, TextField, and Button classes(such as <code>_alpha</code>,
 * <code>_height</code>, <code>_name</code>, <code>_width</code>,
 * <code>_x</code>, <code>_y</code>, and others) have equivalents in the
 * ActionScript 3.0 DisplayObject class that are renamed so that they no
 * longer begin with the underscore(_) character.</p>
 *
 * <p>For more information, see the "Display Programming" chapter of the
 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
 *
 * @event added            Dispatched when a display object is added to the
 *                         display list. The following methods trigger this
 *                         event:
 *                         <code>DisplayObjectContainer.addChild()</code>,
 *                         <code>DisplayObjectContainer.addChildAt()</code>.
 * @event addedToScene     Dispatched when a display object is added to the on
 *                         scene display list, either directly or through the
 *                         addition of a sub tree in which the display object
 *                         is contained. The following methods trigger this
 *                         event:
 *                         <code>DisplayObjectContainer.addChild()</code>,
 *                         <code>DisplayObjectContainer.addChildAt()</code>.
 * @event enterFrame       [broadcast event] Dispatched when the playhead is
 *                         entering a new frame. If the playhead is not
 *                         moving, or if there is only one frame, this event
 *                         is dispatched continuously in conjunction with the
 *                         frame rate. This event is a broadcast event, which
 *                         means that it is dispatched by all display objects
 *                         with a listener registered for this event.
 * @event exitFrame        [broadcast event] Dispatched when the playhead is
 *                         exiting the current frame. All frame scripts have
 *                         been run. If the playhead is not moving, or if
 *                         there is only one frame, this event is dispatched
 *                         continuously in conjunction with the frame rate.
 *                         This event is a broadcast event, which means that
 *                         it is dispatched by all display objects with a
 *                         listener registered for this event.
 * @event frameConstructed [broadcast event] Dispatched after the constructors
 *                         of frame display objects have run but before frame
 *                         scripts have run. If the playhead is not moving, or
 *                         if there is only one frame, this event is
 *                         dispatched continuously in conjunction with the
 *                         frame rate. This event is a broadcast event, which
 *                         means that it is dispatched by all display objects
 *                         with a listener registered for this event.
 * @event removed          Dispatched when a display object is about to be
 *                         removed from the display list. Two methods of the
 *                         DisplayObjectContainer class generate this event:
 *                         <code>removeChild()</code> and
 *                         <code>removeChildAt()</code>.
 *
 *                         <p>The following methods of a
 *                         DisplayObjectContainer object also generate this
 *                         event if an object must be removed to make room for
 *                         the new object: <code>addChild()</code>,
 *                         <code>addChildAt()</code>, and
 *                         <code>setChildIndex()</code>. </p>
 * @event removedFromScene Dispatched when a display object is about to be
 *                         removed from the display list, either directly or
 *                         through the removal of a sub tree in which the
 *                         display object is contained. Two methods of the
 *                         DisplayObjectContainer class generate this event:
 *                         <code>removeChild()</code> and
 *                         <code>removeChildAt()</code>.
 *
 *                         <p>The following methods of a
 *                         DisplayObjectContainer object also generate this
 *                         event if an object must be removed to make room for
 *                         the new object: <code>addChild()</code>,
 *                         <code>addChildAt()</code>, and
 *                         <code>setChildIndex()</code>. </p>
 * @event render           [broadcast event] Dispatched when the display list
 *                         is about to be updated and rendered. This event
 *                         provides the last opportunity for objects listening
 *                         for this event to make changes before the display
 *                         list is rendered. You must call the
 *                         <code>invalidate()</code> method of the Scene
 *                         object each time you want a <code>render</code>
 *                         event to be dispatched. <code>Render</code> events
 *                         are dispatched to an object only if there is mutual
 *                         trust between it and the object that called
 *                         <code>Scene.invalidate()</code>. This event is a
 *                         broadcast event, which means that it is dispatched
 *                         by all display objects with a listener registered
 *                         for this event.
 *
 *                         <p><b>Note: </b>This event is not dispatched if the
 *                         display is not rendering. This is the case when the
 *                         content is either minimized or obscured. </p>
 */
var DisplayObject = (function (_super) {
    __extends(DisplayObject, _super);
    /**
     * Creates a new <code>DisplayObject</code> instance.
     */
    function DisplayObject() {
        var _this = _super.call(this) || this;
        //temp point used in hit testing
        _this._tempPoint = new _awayjs_core.Point();
        _this._queuedEvents = new Array();
        _this._boxBoundsInvalid = true;
        _this._sphereBoundsInvalid = true;
        _this._concatenatedMatrix3D = new _awayjs_core.Matrix3D();
        _this._pIsEntity = false;
        _this._pIsContainer = false;
        _this._sessionID = -1;
        _this._depthID = -16384;
        _this._scenePosition = new _awayjs_core.Vector3D();
        _this._explicitVisibility = true;
        _this._explicitMaskId = -1;
        _this._pImplicitVisibility = true;
        _this._pImplicitMaskId = -1;
        _this._pImplicitMaskIds = new Array();
        _this._explicitMouseEnabled = true;
        _this._pImplicitMouseEnabled = true;
        _this._orientationMatrix = new _awayjs_core.Matrix3D();
        _this._inheritColorTransform = true;
        _this._maskMode = false;
        //temp vector used in global to local
        _this._tempVector3D = new _awayjs_core.Vector3D();
        _this.isSlice9ScaledMC = false;
        _this.isSlice9ScaledSprite = false;
        /**
         *
         */
        _this.alignmentMode = AlignmentMode.REGISTRATION_POINT;
        /**
         *
         */
        _this.castsShadows = true;
        /**
         *
         */
        _this.orientationMode = OrientationMode.DEFAULT;
        /**
         *
         */
        _this.zOffset = 0;
        //global debug bounding boxes:
        //this._debugVisible=true;
        _this._onInvalidatePropertiesDelegate = function (event) { return _this._onInvalidateProperties(event); };
        //creation of associated transform object
        _this._transform = new _awayjs_core.Transform(null, _this._concatenatedMatrix3D);
        //setup transform listeners
        _this._transform.addEventListener(_awayjs_core.TransformEvent.INVALIDATE_MATRIX3D, function (event) { return _this._onInvalidateMatrix3D(event); });
        _this._transform.addEventListener(_awayjs_core.TransformEvent.UPDATE_CONCATENATED_MATRIX3D, function (event) { return _this._onUpdateConcatenatedMatrix3D(event); });
        _this._transform.addEventListener(_awayjs_core.TransformEvent.INVALIDATE_COLOR_TRANSFORM, function (event) { return _this._onInvalidateColorTransform(event); });
        //default bounds type
        _this._boundsType = BoundsType.AXIS_ALIGNED_BOX;
        return _this;
    }
    Object.defineProperty(DisplayObject.prototype, "traverseName", {
        get: function () {
            return DisplayObject.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "inheritColorTransform", {
        get: function () {
            return this._inheritColorTransform;
        },
        set: function (value) {
            if (this._inheritColorTransform == value)
                return;
            this._inheritColorTransform = value;
            this.pInvalidateHierarchicalProperties(HierarchicalProperties.COLOR_TRANSFORM);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "alpha", {
        /**
         * Indicates the alpha transparency value of the object specified. Valid
         * values are 0(fully transparent) to 1(fully opaque). The default value is
         * 1. Display objects with <code>alpha</code> set to 0 <i>are</i> active,
         * even though they are invisible.
         */
        get: function () {
            return this._transform.colorTransform.alphaMultiplier;
        },
        set: function (value) {
            this._transform.colorTransform.alphaMultiplier = value;
            this._transform.invalidateColorTransform();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "boundsType", {
        /**
         *
         */
        get: function () {
            return this._boundsType;
        },
        set: function (value) {
            if (this._boundsType == value)
                return;
            this._boundsType = value;
            this.invalidate();
            this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "depth", {
        /**
         * Indicates the depth of the display object, in pixels. The depth is
         * calculated based on the bounds of the content of the display object. When
         * you set the <code>depth</code> property, the <code>scaleZ</code> property
         * is adjusted accordingly, as shown in the following code:
         *
         * <p>Except for TextField and Video objects, a display object with no
         * content (such as an empty sprite) has a depth of 0, even if you try to
         * set <code>depth</code> to a different value.</p>
         */
        get: function () {
            if (this._registrationMatrix3D)
                return this.getBox().depth * this.scaleZ * this._registrationMatrix3D._rawData[10];
            return this.getBox().depth * this.scaleZ;
        },
        set: function (val) {
            if (this._depth == val)
                return;
            this._depth = val;
            this._setScaleZ(val / this.getBox().depth);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "eulers", {
        /**
         * Defines the rotation of the 3d object as a <code>Vector3D</code> object containing euler angles for rotation around x, y and z axis.
         */
        get: function () {
            if (!this._eulers)
                this._eulers = new _awayjs_core.Vector3D();
            this._eulers.x = this.rotationX;
            this._eulers.y = this.rotationY;
            this._eulers.z = this.rotationZ;
            return this._eulers;
        },
        set: function (value) {
            // previously this was using the setters for rotationX etc
            // but because this will convert from radians to degree, i changed it to update directly
            this._transform.rotation.x = value.x;
            this._transform.rotation.y = value.y;
            this._transform.rotation.z = value.z;
            this._transform.invalidateMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "height", {
        /**
         * An indexed array that contains each filter object currently associated
         * with the display object. The flash.filters package contains several
         * classes that define specific filters you can use.
         *
         * <p>Filters can be applied in Flash Professional at design time, or at run
         * time by using ActionScript code. To apply a filter by using ActionScript,
         * you must make a temporary copy of the entire <code>filters</code> array,
         * modify the temporary array, then assign the value of the temporary array
         * back to the <code>filters</code> array. You cannot directly add a new
         * filter object to the <code>filters</code> array.</p>
         *
         * <p>To add a filter by using ActionScript, perform the following steps
         * (assume that the target display object is named
         * <code>myDisplayObject</code>):</p>
         *
         * <ol>
         *   <li>Create a new filter object by using the constructor method of your
         * chosen filter class.</li>
         *   <li>Assign the value of the <code>myDisplayObject.filters</code> array
         * to a temporary array, such as one named <code>myFilters</code>.</li>
         *   <li>Add the new filter object to the <code>myFilters</code> temporary
         * array.</li>
         *   <li>Assign the value of the temporary array to the
         * <code>myDisplayObject.filters</code> array.</li>
         * </ol>
         *
         * <p>If the <code>filters</code> array is undefined, you do not need to use
         * a temporary array. Instead, you can directly assign an array literal that
         * contains one or more filter objects that you create. The first example in
         * the Examples section adds a drop shadow filter by using code that handles
         * both defined and undefined <code>filters</code> arrays.</p>
         *
         * <p>To modify an existing filter object, you must use the technique of
         * modifying a copy of the <code>filters</code> array:</p>
         *
         * <ol>
         *   <li>Assign the value of the <code>filters</code> array to a temporary
         * array, such as one named <code>myFilters</code>.</li>
         *   <li>Modify the property by using the temporary array,
         * <code>myFilters</code>. For example, to set the quality property of the
         * first filter in the array, you could use the following code:
         * <code>myFilters[0].quality = 1;</code></li>
         *   <li>Assign the value of the temporary array to the <code>filters</code>
         * array.</li>
         * </ol>
         *
         * <p>At load time, if a display object has an associated filter, it is
         * marked to cache itself as a transparent bitmap. From this point forward,
         * as long as the display object has a valid filter list, the player caches
         * the display object as a bitmap. This source bitmap is used as a source
         * image for the filter effects. Each display object usually has two bitmaps:
         * one with the original unfiltered source display object and another for the
         * final image after filtering. The final image is used when rendering. As
         * long as the display object does not change, the final image does not need
         * updating.</p>
         *
         * <p>The flash.filters package includes classes for filters. For example, to
         * create a DropShadow filter, you would write:</p>
         *
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
         *                       and the shader output type is not compatible with
         *                       this operation(the shader must specify a
         *                       <code>pixel4</code> output).
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
         *                       and the shader doesn't specify any image input or
         *                       the first input is not an <code>image4</code> input.
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter
         *                       and the shader specifies an image input that isn't
         *                       provided.
         * @throws ArgumentError When <code>filters</code> includes a ShaderFilter, a
         *                       ByteArray or Vector.<Number> instance as a shader
         *                       input, and the <code>width</code> and
         *                       <code>height</code> properties aren't specified for
         *                       the ShaderInput object, or the specified values
         *                       don't match the amount of data in the input data.
         *                       See the <code>ShaderInput.input</code> property for
         *                       more information.
         */
        //		public filters:Array<Dynamic>;
        /**
         * Indicates the height of the display object, in pixels. The height is
         * calculated based on the bounds of the content of the display object. When
         * you set the <code>height</code> property, the <code>scaleY</code> property
         * is adjusted accordingly, as shown in the following code:
         *
         * <p>Except for TextField and Video objects, a display object with no
         * content (such as an empty sprite) has a height of 0, even if you try to
         * set <code>height</code> to a different value.</p>
         */
        get: function () {
            if (this._registrationMatrix3D)
                return this.getBox().height * this.scaleY * this._registrationMatrix3D._rawData[5];
            return this.getBox().height * this.scaleY;
        },
        set: function (val) {
            if (this._height == val)
                return;
            var boxHeight = this.getBox().height;
            //return if box is empty ie setting height for no content is impossible
            if (!boxHeight)
                return;
            this._height = val;
            this._setScaleY(val / boxHeight);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "index", {
        /**
         * Indicates the instance container index of the DisplayObject. The object can be
         * identified in the child list of its parent display object container by
         * calling the <code>getChildByIndex()</code> method of the display object
         * container.
         *
         * <p>If the DisplayObject has no parent container, index defaults to 0.</p>
         */
        get: function () {
            if (this._pParent)
                return this._pParent.getChildIndex(this);
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "isEntity", {
        /**
         *
         */
        get: function () {
            return this._pIsEntity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "isContainer", {
        /**
         *
         */
        get: function () {
            return this._pIsContainer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "loaderInfo", {
        /**
         * Returns a LoaderInfo object containing information about loading the file
         * to which this display object belongs. The <code>loaderInfo</code> property
         * is defined only for the root display object of a SWF file or for a loaded
         * Bitmap(not for a Bitmap that is drawn with ActionScript). To find the
         * <code>loaderInfo</code> object associated with the SWF file that contains
         * a display object named <code>myDisplayObject</code>, use
         * <code>myDisplayObject.root.loaderInfo</code>.
         *
         * <p>A large SWF file can monitor its download by calling
         * <code>this.root.loaderInfo.addEventListener(Event.COMPLETE,
         * func)</code>.</p>
         */
        get: function () {
            return this._loaderInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "maskMode", {
        get: function () {
            return this._maskMode;
        },
        set: function (value) {
            if (this._maskMode == value)
                return;
            this._maskMode = value;
            this._explicitMaskId = value ? this.id : -1;
            this._updateMaskMode();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "mouseEnabled", {
        /**
         * Specifies whether this object receives mouse, or other user input,
         * messages. The default value is <code>true</code>, which means that by
         * default any InteractiveObject instance that is on the display list
         * receives mouse events or other user input events. If
         * <code>mouseEnabled</code> is set to <code>false</code>, the instance does
         * not receive any mouse events(or other user input events like keyboard
         * events). Any children of this instance on the display list are not
         * affected. To change the <code>mouseEnabled</code> behavior for all
         * children of an object on the display list, use
         * <code>flash.display.DisplayObjectContainer.mouseChildren</code>.
         *
         * <p> No event is dispatched by setting this property. You must use the
         * <code>addEventListener()</code> method to create interactive
         * functionality.</p>
         */
        get: function () {
            return this._explicitMouseEnabled;
        },
        set: function (value) {
            if (this._explicitMouseEnabled == value)
                return;
            this._explicitMouseEnabled = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "mouseX", {
        /**
         * Indicates the x coordinate of the mouse or user input device position, in
         * pixels.
         *
         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned x
         * coordinate will reflect the non-rotated object.</p>
         */
        get: function () {
            return this._mouseX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "mouseY", {
        /**
         * Indicates the y coordinate of the mouse or user input device position, in
         * pixels.
         *
         * <p><b>Note</b>: For a DisplayObject that has been rotated, the returned y
         * coordinate will reflect the non-rotated object.</p>
         */
        get: function () {
            return this._mouseY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "name", {
        /**
         * Indicates the instance name of the DisplayObject. The object can be
         * identified in the child list of its parent display object container by
         * calling the <code>getChildByName()</code> method of the display object
         * container.
         *
         * @throws IllegalOperationError If you are attempting to set this property
         *                               on an object that was placed on the timeline
         *                               in the Flash authoring tool.
         */
        get: function () {
            return this._pName;
        },
        set: function (value) {
            this._pName = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "parent", {
        /**
         * Indicates the DisplayObjectContainer object that contains this display
         * object. Use the <code>parent</code> property to specify a relative path to
         * display objects that are above the current display object in the display
         * list hierarchy.
         *
         * <p>You can use <code>parent</code> to move up multiple levels in the
         * display list as in the following:</p>
         *
         * @throws SecurityError The parent display object belongs to a security
         *                       sandbox to which you do not have access. You can
         *                       avoid this situation by having the parent movie call
         *                       the <code>Security.allowDomain()</code> method.
         */
        get: function () {
            return this._pParent;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "isPartition", {
        /**
         *
         */
        get: function () {
            return this._iIsPartition;
        },
        set: function (value) {
            if (this._iIsPartition == value)
                return;
            this._iIsPartition = value;
            this._iSetScene(this._pScene, this._pParent ? this._pParent._pPartition : null);
            this.dispatchEvent(new DisplayObjectEvent(DisplayObjectEvent.PARTITION_CHANGED, this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "registrationPoint", {
        /**
         * Defines the local point around which the object rotates.
         */
        get: function () {
            if (this._registrationMatrix3D)
                return new _awayjs_core.Vector3D(-this._registrationMatrix3D._rawData[12] * this.scaleX, -this._registrationMatrix3D._rawData[13] * this.scaleY, -this._registrationMatrix3D._rawData[14] * this.scaleZ);
            return null;
        },
        set: function (value) {
            if (!value) {
                if (!this._registrationMatrix3D)
                    return;
                this._registrationMatrix3D._rawData[12] = 0;
                this._registrationMatrix3D._rawData[13] = 0;
                this._registrationMatrix3D._rawData[14] = 0;
                if (this._registrationMatrix3D.isIdentity())
                    this._registrationMatrix3D = null;
            }
            else {
                if (!this._registrationMatrix3D)
                    this._registrationMatrix3D = new _awayjs_core.Matrix3D();
                this._registrationMatrix3D._rawData[12] = -value.x / this._transform.scale.x;
                this._registrationMatrix3D._rawData[13] = -value.y / this._transform.scale.y;
                this._registrationMatrix3D._rawData[14] = -value.z / this._transform.scale.z;
            }
            this._registrationMatrix3D.invalidatePosition();
            this.pInvalidateHierarchicalProperties(HierarchicalProperties.SCENE_TRANSFORM);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "registrationScale", {
        /**
         * Defines the local scale.
         */
        get: function () {
            if (this._registrationMatrix3D)
                return new _awayjs_core.Vector3D(this._registrationMatrix3D._rawData[0], this._registrationMatrix3D._rawData[5], this._registrationMatrix3D._rawData[10]);
            return null;
        },
        set: function (value) {
            if (!value) {
                if (!this._registrationMatrix3D)
                    return;
                this._registrationMatrix3D._rawData[0] = 1;
                this._registrationMatrix3D._rawData[5] = 1;
                this._registrationMatrix3D._rawData[10] = 1;
                if (this._registrationMatrix3D.isIdentity())
                    this._registrationMatrix3D = null;
            }
            else {
                if (!this._registrationMatrix3D)
                    this._registrationMatrix3D = new _awayjs_core.Matrix3D();
                this._registrationMatrix3D._rawData[0] = value.x;
                this._registrationMatrix3D._rawData[5] = value.y;
                this._registrationMatrix3D._rawData[10] = value.z;
            }
            this.pInvalidateHierarchicalProperties(HierarchicalProperties.SCENE_TRANSFORM);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "root", {
        /**
         * For a display object in a loaded SWF file, the <code>root</code> property
         * is the top-most display object in the portion of the display list's tree
         * structure represented by that SWF file. For a Bitmap object representing a
         * loaded image file, the <code>root</code> property is the Bitmap object
         * itself. For the instance of the main class of the first SWF file loaded,
         * the <code>root</code> property is the display object itself. The
         * <code>root</code> property of the Scene object is the Scene object itself.
         * The <code>root</code> property is set to <code>null</code> for any display
         * object that has not been added to the display list, unless it has been
         * added to a display object container that is off the display list but that
         * is a child of the top-most display object in a loaded SWF file.
         *
         * <p>For example, if you create a new Sprite object by calling the
         * <code>Sprite()</code> constructor method, its <code>root</code> property
         * is <code>null</code> until you add it to the display list(or to a display
         * object container that is off the display list but that is a child of the
         * top-most display object in a SWF file).</p>
         *
         * <p>For a loaded SWF file, even though the Loader object used to load the
         * file may not be on the display list, the top-most display object in the
         * SWF file has its <code>root</code> property set to itself. The Loader
         * object does not have its <code>root</code> property set until it is added
         * as a child of a display object for which the <code>root</code> property is
         * set.</p>
         */
        get: function () {
            return this._root;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "rotationX", {
        /**
         * Indicates the x-axis rotation of the DisplayObject instance, in degrees,
         * from its original orientation relative to the 3D parent container. Values
         * from 0 to 180 represent clockwise rotation; values from 0 to -180
         * represent counterclockwise rotation. Values outside this range are added
         * to or subtracted from 360 to obtain a value within the range.
         */
        get: function () {
            return this._transform.rotation.x * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        },
        set: function (val) {
            if (this.rotationX == val)
                return;
            this._transform.rotation.x = val * _awayjs_core.MathConsts.DEGREES_TO_RADIANS;
            this._transform.invalidateMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "rotationY", {
        /**
         * Indicates the y-axis rotation of the DisplayObject instance, in degrees,
         * from its original orientation relative to the 3D parent container. Values
         * from 0 to 180 represent clockwise rotation; values from 0 to -180
         * represent counterclockwise rotation. Values outside this range are added
         * to or subtracted from 360 to obtain a value within the range.
         */
        get: function () {
            return this._transform.rotation.y * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        },
        set: function (val) {
            if (this.rotationY == val)
                return;
            this._transform.rotation.y = val * _awayjs_core.MathConsts.DEGREES_TO_RADIANS;
            this._transform.invalidateMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "rotationZ", {
        /**
         * Indicates the z-axis rotation of the DisplayObject instance, in degrees,
         * from its original orientation relative to the 3D parent container. Values
         * from 0 to 180 represent clockwise rotation; values from 0 to -180
         * represent counterclockwise rotation. Values outside this range are added
         * to or subtracted from 360 to obtain a value within the range.
         */
        get: function () {
            return this._transform.rotation.z * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        },
        set: function (val) {
            if (this.rotationZ == val)
                return;
            this._transform.rotation.z = val * _awayjs_core.MathConsts.DEGREES_TO_RADIANS;
            this._transform.invalidateMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scaleX", {
        /**
         * Indicates the horizontal scale(percentage) of the object as applied from
         * the registration point. The default registration point is(0,0). 1.0
         * equals 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code> and
         * <code>y</code> property values, which are defined in whole pixels. </p>
         */
        get: function () {
            return this._transform.scale.x;
        },
        set: function (val) {
            //remove absolute width
            this._width = null;
            this._setScaleX(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scaleY", {
        /**
         * Indicates the vertical scale(percentage) of an object as applied from the
         * registration point of the object. The default registration point is(0,0).
         * 1.0 is 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code> and
         * <code>y</code> property values, which are defined in whole pixels. </p>
         */
        get: function () {
            return this._transform.scale.y;
        },
        set: function (val) {
            //remove absolute height
            this._height = null;
            this._setScaleY(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scaleZ", {
        /**
         * Indicates the depth scale(percentage) of an object as applied from the
         * registration point of the object. The default registration point is(0,0).
         * 1.0 is 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code>,
         * <code>y</code> and <code>z</code> property values, which are defined in
         * whole pixels. </p>
         */
        get: function () {
            return this._transform.scale.z;
        },
        set: function (val) {
            //remove absolute depth
            this._depth = null;
            this._setScaleZ(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "skewX", {
        /**
         * Indicates the horizontal skew(angle) of the object as applied from
         * the registration point. The default registration point is(0,0).
         */
        get: function () {
            return this._transform.skew.x;
        },
        set: function (val) {
            if (this.skewX == val)
                return;
            this._transform.skew.x = val;
            this._transform.invalidateMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "skewY", {
        /**
         * Indicates the vertical skew(angle) of an object as applied from the
         * registration point of the object. The default registration point is(0,0).
         */
        get: function () {
            return this._transform.skew.y;
        },
        set: function (val) {
            if (this.skewY == val)
                return;
            this._transform.skew.y = val;
            this._transform.invalidateMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "skewZ", {
        /**
         * Indicates the depth skew(angle) of an object as applied from the
         * registration point of the object. The default registration point is(0,0).
         */
        get: function () {
            return this._transform.skew.z;
        },
        set: function (val) {
            if (this.skewZ == val)
                return;
            this._transform.skew.z = val;
            this._transform.invalidateMatrix3D();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "partition", {
        /**
         *
         */
        get: function () {
            return this._pPartition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scene", {
        /**
         *
         */
        get: function () {
            return this._pScene;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "scenePosition", {
        /**
         *
         */
        get: function () {
            if (this._scenePositionDirty) {
                if (this._registrationMatrix3D && this.alignmentMode == AlignmentMode.REGISTRATION_POINT) {
                    this._scenePosition.x = -this._registrationMatrix3D._rawData[12];
                    this._scenePosition.y = -this._registrationMatrix3D._rawData[13];
                    this._scenePosition.z = -this._registrationMatrix3D._rawData[14];
                    this._scenePosition = this._transform.concatenatedMatrix3D.transformVector(this._scenePosition, this._scenePosition);
                }
                else {
                    this._transform.concatenatedMatrix3D.copyColumnTo(3, this._scenePosition);
                }
                this._scenePositionDirty = false;
            }
            return this._scenePosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "animator", {
        /**
         * Defines the animator of the display object.  Default value is <code>null</code>.
         */
        get: function () {
            return this._animator;
        },
        set: function (value) {
            if (this._animator)
                this._animator.removeOwner(this);
            this._animator = value;
            if (this._animator)
                this._animator.addOwner(this);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "material", {
        /**
         *
         */
        get: function () {
            return this._material;
        },
        set: function (value) {
            if (this._material == value)
                return;
            if (this._material)
                this._material.iRemoveOwner(this);
            this._material = value;
            if (this._material)
                this._material.iAddOwner(this);
            this.invalidateMaterial();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "style", {
        /**
         *
         */
        get: function () {
            return this._style;
        },
        set: function (value) {
            if (this._style == value)
                return;
            if (this._style)
                this._style.removeEventListener(_awayjs_graphics.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this._style = value;
            if (this._style)
                this._style.addEventListener(_awayjs_graphics.StyleEvent.INVALIDATE_PROPERTIES, this._onInvalidatePropertiesDelegate);
            this._onInvalidateProperties();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "shaderPickingDetails", {
        /**
         *
         */
        get: function () {
            return this._shaderPickingDetails;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "debugVisible", {
        /**
         *
         */
        get: function () {
            return this._debugVisible;
        },
        set: function (value) {
            if (value == this._debugVisible)
                return;
            this._debugVisible = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "transform", {
        /**
         * An object with properties pertaining to a display object's matrix, color
         * transform, and pixel bounds. The specific properties  -  matrix,
         * colorTransform, and three read-only properties
         * (<code>concatenatedMatrix</code>, <code>concatenatedColorTransform</code>,
         * and <code>pixelBounds</code>)  -  are described in the entry for the
         * Transform class.
         *
         * <p>Each of the transform object's properties is itself an object. This
         * concept is important because the only way to set new values for the matrix
         * or colorTransform objects is to create a new object and copy that object
         * into the transform.matrix or transform.colorTransform property.</p>
         *
         * <p>For example, to increase the <code>tx</code> value of a display
         * object's matrix, you must make a copy of the entire matrix object, then
         * copy the new object into the matrix property of the transform object:</p>
         * <pre xml:space="preserve"><code> public myMatrix:Matrix =
         * myDisplayObject.transform.matrix; myMatrix.tx += 10;
         * myDisplayObject.transform.matrix = myMatrix; </code></pre>
         *
         * <p>You cannot directly set the <code>tx</code> property. The following
         * code has no effect on <code>myDisplayObject</code>: </p>
         * <pre xml:space="preserve"><code> myDisplayObject.transform.matrix.tx +=
         * 10; </code></pre>
         *
         * <p>You can also copy an entire transform object and assign it to another
         * display object's transform property. For example, the following code
         * copies the entire transform object from <code>myOldDisplayObj</code> to
         * <code>myNewDisplayObj</code>:</p>
         * <code>myNewDisplayObj.transform = myOldDisplayObj.transform;</code>
         *
         * <p>The resulting display object, <code>myNewDisplayObj</code>, now has the
         * same values for its matrix, color transform, and pixel bounds as the old
         * display object, <code>myOldDisplayObj</code>.</p>
         *
         * <p>Note that AIR for TV devices use hardware acceleration, if it is
         * available, for color transforms.</p>
         */
        get: function () {
            return this._transform;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "visible", {
        /**
         * Whether or not the display object is visible. Display objects that are not
         * visible are disabled. For example, if <code>visible=false</code> for an
         * InteractiveObject instance, it cannot be clicked.
         */
        get: function () {
            return this._explicitVisibility;
        },
        set: function (value) {
            if (this._explicitVisibility == value)
                return;
            this._explicitVisibility = value;
            this.pInvalidateHierarchicalProperties(HierarchicalProperties.VISIBLE);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "masks", {
        get: function () {
            return this._explicitMasks;
        },
        set: function (value) {
            if (this._explicitMasks == value)
                return;
            this._explicitMasks = value;
            //make sure maskMode is set to true for all masks
            if (value != null && value.length) {
                var len = value.length;
                for (var i = 0; i < len; i++)
                    value[i].maskMode = true;
            }
            this.pInvalidateHierarchicalProperties(HierarchicalProperties.MASKS);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "width", {
        /**
         * Indicates the width of the display object, in pixels. The width is
         * calculated based on the bounds of the content of the display object. When
         * you set the <code>width</code> property, the <code>scaleX</code> property
         * is adjusted accordingly, as shown in the following code:
         *
         * <p>Except for TextField and Video objects, a display object with no
         * content(such as an empty sprite) has a width of 0, even if you try to set
         * <code>width</code> to a different value.</p>
         */
        get: function () {
            if (this._registrationMatrix3D)
                return this.getBox().width * this.scaleX * this._registrationMatrix3D._rawData[0];
            return this.getBox().width * this.scaleX;
        },
        set: function (val) {
            if (this._width == val)
                return;
            var boxWidth = this.getBox().width;
            //return if box is empty ie setting width for no content is impossible
            if (!boxWidth)
                return;
            this._width = val;
            this._setScaleX(val / boxWidth);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "x", {
        /**
         * Indicates the <i>x</i> coordinate of the DisplayObject instance relative
         * to the local coordinates of the parent DisplayObjectContainer. If the
         * object is inside a DisplayObjectContainer that has transformations, it is
         * in the local coordinate system of the enclosing DisplayObjectContainer.
         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
         * DisplayObjectContainer's children inherit a coordinate system that is
         * rotated 90° counterclockwise. The object's coordinates refer to the
         * registration point position.
         */
        get: function () {
            return this._transform.position.x;
        },
        set: function (val) {
            if (this._transform.position.x == val)
                return;
            this._transform.matrix3D._rawData[12] = val;
            this._transform.invalidatePosition();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "y", {
        /**
         * Indicates the <i>y</i> coordinate of the DisplayObject instance relative
         * to the local coordinates of the parent DisplayObjectContainer. If the
         * object is inside a DisplayObjectContainer that has transformations, it is
         * in the local coordinate system of the enclosing DisplayObjectContainer.
         * Thus, for a DisplayObjectContainer rotated 90° counterclockwise, the
         * DisplayObjectContainer's children inherit a coordinate system that is
         * rotated 90° counterclockwise. The object's coordinates refer to the
         * registration point position.
         */
        get: function () {
            return this._transform.position.y;
        },
        set: function (val) {
            if (this._transform.position.y == val)
                return;
            this._transform.matrix3D._rawData[13] = val;
            this._transform.invalidatePosition();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObject.prototype, "z", {
        /**
         * Indicates the z coordinate position along the z-axis of the DisplayObject
         * instance relative to the 3D parent container. The z property is used for
         * 3D coordinates, not screen or pixel coordinates.
         *
         * <p>When you set a <code>z</code> property for a display object to
         * something other than the default value of <code>0</code>, a corresponding
         * Matrix3D object is automatically created. for adjusting a display object's
         * position and orientation in three dimensions. When working with the
         * z-axis, the existing behavior of x and y properties changes from screen or
         * pixel coordinates to positions relative to the 3D parent container.</p>
         *
         * <p>For example, a child of the <code>_root</code> at position x = 100, y =
         * 100, z = 200 is not drawn at pixel location(100,100). The child is drawn
         * wherever the 3D projection calculation puts it. The calculation is:</p>
         *
         * <p><code>(x~~cameraFocalLength/cameraRelativeZPosition,
         * y~~cameraFocalLength/cameraRelativeZPosition)</code></p>
         */
        get: function () {
            return this._transform.position.z;
        },
        set: function (val) {
            if (this._transform.position.z == val)
                return;
            this._transform.matrix3D._rawData[14] = val;
            this._transform.invalidatePosition();
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    DisplayObject.prototype.addEventListener = function (type, listener) {
        _super.prototype.addEventListener.call(this, type, listener);
        switch (type) {
            case DisplayObjectEvent.SCENE_CHANGED:
                this._listenToSceneChanged = true;
                break;
            case DisplayObjectEvent.SCENETRANSFORM_CHANGED:
                this._listenToSceneTransformChanged = true;
                break;
        }
    };
    /**
     *
     */
    DisplayObject.prototype.clone = function () {
        var newInstance = new DisplayObject();
        this.copyTo(newInstance);
        return newInstance;
    };
    DisplayObject.prototype.copyTo = function (displayObject) {
        displayObject.isPartition = this._iIsPartition;
        displayObject.boundsType = this._boundsType;
        if (this._registrationMatrix3D)
            displayObject._registrationMatrix3D = this._registrationMatrix3D.clone();
        displayObject._iSourcePrefab = this._iSourcePrefab;
        displayObject.debugVisible = this._debugVisible;
        displayObject.name = this._pName;
        displayObject.mouseEnabled = this._explicitMouseEnabled;
        displayObject.extra = this.extra;
        displayObject.maskMode = this._maskMode;
        displayObject.castsShadows = this.castsShadows;
        displayObject.isSlice9ScaledMC = this.isSlice9ScaledMC;
        if (this._explicitMasks)
            displayObject.masks = this._explicitMasks;
        this._transform.copyRawDataTo(displayObject._transform);
    };
    /**
     *
     */
    DisplayObject.prototype.dispose = function () {
        this.disposeValues();
    };
    DisplayObject.prototype.disposeValues = function () {
        if (this._pParent)
            this._pParent.removeChild(this);
        //if (this._adapter) {
        //	this._adapter.dispose();
        //	this._adapter = null;
        //}
        //this._pos = null;
        //this._rot = null;
        //this._sca = null;
        //this._ske = null;
        //this._transformComponents = null;
        //this._transform.dispose();
        //this._transform = null;
        //
        //this._matrix3D = null;
        //this._concatenatedMatrix3D = null;
        //this._inverseSceneTransform = null;
        this._explicitMasks = null;
    };
    /**
     * Returns a rectangle that defines the area of the display object relative
     * to the coordinate system of the <code>targetCoordinateSpace</code> object.
     * Consider the following code, which shows how the rectangle returned can
     * vary depending on the <code>targetCoordinateSpace</code> parameter that
     * you pass to the method:
     *
     * <p><b>Note:</b> Use the <code>localToGlobal()</code> and
     * <code>globalToLocal()</code> methods to convert the display object's local
     * coordinates to display coordinates, or display coordinates to local
     * coordinates, respectively.</p>
     *
     * <p>The <code>getBounds()</code> method is similar to the
     * <code>getRect()</code> method; however, the Rectangle returned by the
     * <code>getBounds()</code> method includes any strokes on shapes, whereas
     * the Rectangle returned by the <code>getRect()</code> method does not. For
     * an example, see the description of the <code>getRect()</code> method.</p>
     *
     * @param targetCoordinateSpace The display object that defines the
     *                              coordinate system to use.
     * @return The rectangle that defines the area of the display object relative
     *         to the <code>targetCoordinateSpace</code> object's coordinate
     *         system.
     */
    DisplayObject.prototype.getBounds = function (targetCoordinateSpace) {
        return this._bounds; //TODO
    };
    /**
     * Returns a rectangle that defines the boundary of the display object, based
     * on the coordinate system defined by the <code>targetCoordinateSpace</code>
     * parameter, excluding any strokes on shapes. The values that the
     * <code>getRect()</code> method returns are the same or smaller than those
     * returned by the <code>getBounds()</code> method.
     *
     * <p><b>Note:</b> Use <code>localToGlobal()</code> and
     * <code>globalToLocal()</code> methods to convert the display object's local
     * coordinates to Scene coordinates, or Scene coordinates to local
     * coordinates, respectively.</p>
     *
     * @param targetCoordinateSpace The display object that defines the
     *                              coordinate system to use.
     * @return The rectangle that defines the area of the display object relative
     *         to the <code>targetCoordinateSpace</code> object's coordinate
     *         system.
     */
    DisplayObject.prototype.getRect = function (targetCoordinateSpace) {
        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
        return this._bounds; //TODO
    };
    DisplayObject.prototype.getBox = function (targetCoordinateSpace) {
        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
        if (this._iSourcePrefab)
            this._iSourcePrefab._iValidate();
        //TODO targetCoordinateSpace
        if (this._boxBoundsInvalid) {
            this._pUpdateBoxBounds();
            //scale updates if absolute dimensions are detected
            if (this._width != null)
                this._setScaleX(this._width / this._pBoxBounds.width);
            if (this._height != null)
                this._setScaleY(this._height / this._pBoxBounds.height);
            if (this._depth != null)
                this._setScaleZ(this._depth / this._pBoxBounds.depth);
        }
        if (targetCoordinateSpace == null || targetCoordinateSpace == this)
            return this._pBoxBounds;
        if (targetCoordinateSpace == this._pParent) {
            if (this._registrationMatrix3D) {
                if (this._tempTransform == null)
                    this._tempTransform = new _awayjs_core.Matrix3D();
                this._tempTransform.copyFrom(this._transform.matrix3D);
                this._tempTransform.prepend(this._registrationMatrix3D);
                if (this.alignmentMode != AlignmentMode.REGISTRATION_POINT)
                    this._tempTransform.appendTranslation(-this._registrationMatrix3D._rawData[12] * this._transform.scale.x, -this._registrationMatrix3D._rawData[13] * this._transform.scale.y, -this._registrationMatrix3D._rawData[14] * this._transform.scale.z);
                return this._tempTransform.transformBox(this._pBoxBounds);
            }
            return this._transform.matrix3D.transformBox(this._pBoxBounds);
        }
        else
            return targetCoordinateSpace.transform.inverseConcatenatedMatrix3D.transformBox(this.transform.concatenatedMatrix3D.transformBox(this._pBoxBounds));
    };
    DisplayObject.prototype.getSphere = function (targetCoordinateSpace) {
        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
        if (this._iSourcePrefab)
            this._iSourcePrefab._iValidate();
        if (this._sphereBoundsInvalid)
            this._pUpdateSphereBounds();
        return this._pSphereBounds;
    };
    /**
     * Converts the <code>point</code> object from the Scene(global) coordinates
     * to the display object's(local) coordinates.
     *
     * <p>To use this method, first create an instance of the Point class. The
     * <i>x</i> and <i>y</i> values that you assign represent global coordinates
     * because they relate to the origin(0,0) of the main display area. Then
     * pass the Point instance as the parameter to the
     * <code>globalToLocal()</code> method. The method returns a new Point object
     * with <i>x</i> and <i>y</i> values that relate to the origin of the display
     * object instead of the origin of the Scene.</p>
     *
     * @param point An object created with the Point class. The Point object
     *              specifies the <i>x</i> and <i>y</i> coordinates as
     *              properties.
     * @return A Point object with coordinates relative to the display object.
     */
    DisplayObject.prototype.globalToLocal = function (point, target) {
        if (target === void 0) { target = null; }
        this._tempVector3D.setTo(point.x, point.y, 0);
        var pos = this._transform.inverseConcatenatedMatrix3D.transformVector(this._tempVector3D, this._tempVector3D);
        if (!target)
            target = new _awayjs_core.Point();
        target.x = pos.x;
        target.y = pos.y;
        return target;
    };
    /**
     * Converts a two-dimensional point from the Scene(global) coordinates to a
     * three-dimensional display object's(local) coordinates.
     *
     * <p>To use this method, first create an instance of the Vector3D class. The x,
     * y and z values that you assign to the Vector3D object represent global
     * coordinates because they are relative to the origin(0,0,0) of the scene. Then
     * pass the Vector3D object to the <code>globalToLocal3D()</code> method as the
     * <code>position</code> parameter.
     * The method returns three-dimensional coordinates as a Vector3D object
     * containing <code>x</code>, <code>y</code>, and <code>z</code> values that
     * are relative to the origin of the three-dimensional display object.</p>
     *
     * @param point A Vector3D object representing global x, y and z coordinates in
     *              the scene.
     * @return A Vector3D object with coordinates relative to the three-dimensional
     *         display object.
     */
    DisplayObject.prototype.globalToLocal3D = function (position) {
        return this._transform.inverseConcatenatedMatrix3D.transformVector(position);
    };
    /**
     * Evaluates the bounding box of the display object to see if it overlaps or
     * intersects with the bounding box of the <code>obj</code> display object.
     *
     * @param obj The display object to test against.
     * @return <code>true</code> if the bounding boxes of the display objects
     *         intersect; <code>false</code> if not.
     */
    DisplayObject.prototype.hitTestObject = function (obj) {
        var objBox = obj.getBox(this.scene);
        if (!objBox)
            return false;
        var box = this.getBox(this.scene);
        if (!box)
            return false;
        if (objBox.x > (box.x + box.width)) {
            return false;
        }
        if (box.x > (objBox.x + objBox.width)) {
            return false;
        }
        if ((objBox.y + objBox.height) < box.y) {
            return false;
        }
        if ((box.y + box.height) < objBox.y) {
            return false;
        }
        return true; //TODO
    };
    /**
     * Evaluates the display object to see if it overlaps or intersects with the
     * point specified by the <code>x</code> and <code>y</code> parameters. The
     * <code>x</code> and <code>y</code> parameters specify a point in the
     * coordinate space of the Scene, not the display object container that
     * contains the display object(unless that display object container is the
     * Scene).
     *
     * @param x         The <i>x</i> coordinate to test against this object.
     * @param y         The <i>y</i> coordinate to test against this object.
     * @param shapeFlag Whether to check against the actual pixels of the object
     *                 (<code>true</code>) or the bounding box
     *                 (<code>false</code>).
     * @param maskFlag Whether to check against the object when it is used as mask
     *                 (<code>false</code>).
     * @return <code>true</code> if the display object overlaps or intersects
     *         with the specified point; <code>false</code> otherwise.
     */
    DisplayObject.prototype.hitTestPoint = function (x, y, shapeFlag, masksFlag) {
        if (shapeFlag === void 0) { shapeFlag = false; }
        if (masksFlag === void 0) { masksFlag = false; }
        if (!this._pImplicitVisibility)
            return false;
        if (this._pImplicitMaskId != -1 && !masksFlag)
            return false;
        //set local tempPoint for later reference
        this._tempPoint.setTo(x, y);
        this.globalToLocal(this._tempPoint, this._tempPoint);
        //early out for box test
        if (!this.getBox().contains(this._tempPoint.x, this._tempPoint.y, 0))
            return false;
        if (this._explicitMasks) {
            var numMasks = this._explicitMasks.length;
            var maskHit = false;
            for (var i = 0; i < numMasks; i++) {
                if (this._explicitMasks[i].hitTestPoint(x, y, shapeFlag, true)) {
                    maskHit = true;
                    break;
                }
            }
            if (!maskHit)
                return false;
        }
        //early out for non-shape tests
        if (!shapeFlag || this.assetType == "[asset TextField]" || this.assetType == "[asset Billboard]")
            return true;
        return this._hitTestPointInternal(x, y, shapeFlag, masksFlag);
    };
    /**
     * Rotates the 3d object around to face a point defined relative to the local coordinates of the parent <code>ObjectContainer3D</code>.
     *
     * @param    target        The vector defining the point to be looked at
     * @param    upAxis        An optional vector used to define the desired up orientation of the 3d object after rotation has occurred
     */
    DisplayObject.prototype.lookAt = function (scenePosition, upAxis) {
        if (upAxis === void 0) { upAxis = null; }
        if (upAxis == null)
            upAxis = _awayjs_core.Vector3D.Y_AXIS;
        var m = _awayjs_core.Matrix3D.getPointAtMatrix(new _awayjs_core.Vector3D(), scenePosition.subtract(this._transform.position), upAxis, _awayjs_core.Matrix3D.CALCULATION_MATRIX);
        var vec = m.decompose()[1];
        this.rotationX = vec.x * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        this.rotationY = vec.y * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
        this.rotationZ = vec.z * _awayjs_core.MathConsts.RADIANS_TO_DEGREES;
    };
    /**
     * Converts the <code>point</code> object from the display object's(local)
     * coordinates to the Scene(global) coordinates.
     *
     * <p>This method allows you to convert any given <i>x</i> and <i>y</i>
     * coordinates from values that are relative to the origin(0,0) of a
     * specific display object(local coordinates) to values that are relative to
     * the origin of the Scene(global coordinates).</p>
     *
     * <p>To use this method, first create an instance of the Point class. The
     * <i>x</i> and <i>y</i> values that you assign represent local coordinates
     * because they relate to the origin of the display object.</p>
     *
     * <p>You then pass the Point instance that you created as the parameter to
     * the <code>localToGlobal()</code> method. The method returns a new Point
     * object with <i>x</i> and <i>y</i> values that relate to the origin of the
     * Scene instead of the origin of the display object.</p>
     *
     * @param point The name or identifier of a point created with the Point
     *              class, specifying the <i>x</i> and <i>y</i> coordinates as
     *              properties.
     * @return A Point object with coordinates relative to the Scene.
     */
    DisplayObject.prototype.localToGlobal = function (point, target) {
        if (target === void 0) { target = null; }
        this._tempVector3D.setTo(point.x, point.y, 0);
        var pos = this._transform.concatenatedMatrix3D.transformVector(this._tempVector3D, this._tempVector3D);
        if (!target)
            target = new _awayjs_core.Point();
        target.x = pos.x;
        target.y = pos.y;
        return target;
    };
    /**
     * Converts a three-dimensional point of the three-dimensional display
     * object's(local) coordinates to a three-dimensional point in the Scene
     * (global) coordinates.
     *
     * <p>This method allows you to convert any given <i>x</i>, <i>y</i> and
     * <i>z</i> coordinates from values that are relative to the origin(0,0,0) of
     * a specific display object(local coordinates) to values that are relative to
     * the origin of the Scene(global coordinates).</p>
     *
     * <p>To use this method, first create an instance of the Point class. The
     * <i>x</i> and <i>y</i> values that you assign represent local coordinates
     * because they relate to the origin of the display object.</p>
     *
     * <p>You then pass the Vector3D instance that you created as the parameter to
     * the <code>localToGlobal3D()</code> method. The method returns a new
     * Vector3D object with <i>x</i>, <i>y</i> and <i>z</i> values that relate to
     * the origin of the Scene instead of the origin of the display object.</p>
     *
     * @param position A Vector3D object containing either a three-dimensional
     *                position or the coordinates of the three-dimensional
     *                display object.
     * @return A Vector3D object representing a three-dimensional position in
     *         the Scene.
     */
    DisplayObject.prototype.localToGlobal3D = function (position) {
        return this._transform.concatenatedMatrix3D.transformVector(position);
    };
    /**
     * Moves the local point around which the object rotates.
     *
     * @param    dx        The amount of movement along the local x axis.
     * @param    dy        The amount of movement along the local y axis.
     * @param    dz        The amount of movement along the local z axis.
     */
    DisplayObject.prototype.movePivot = function (dx, dy, dz) {
        if (dx == 0 && dy == 0 && dz == 0)
            return;
        if (!this._registrationMatrix3D)
            this._registrationMatrix3D = new _awayjs_core.Matrix3D();
        this._registrationMatrix3D._rawData[12] -= dx / this._transform.scale.x;
        this._registrationMatrix3D._rawData[13] -= dy / this._transform.scale.y;
        this._registrationMatrix3D._rawData[14] -= dz / this._transform.scale.z;
        this.pInvalidateHierarchicalProperties(HierarchicalProperties.SCENE_TRANSFORM);
    };
    DisplayObject.prototype.reset = function () {
        this.visible = true;
        this._transform.clearMatrix3D();
        this._transform.clearColorTransform();
        //this.name="";
        this.masks = null;
        this.maskMode = false;
    };
    /**
     *
     */
    DisplayObject.prototype.getRenderSceneTransform = function (cameraTransform) {
        if (this.orientationMode == OrientationMode.CAMERA_PLANE) {
            var comps = cameraTransform.decompose();
            comps[0].copyFrom(this.scenePosition);
            comps[3].copyFrom(this._transform.scale);
            this._orientationMatrix.recompose(comps);
            //add in case of registration point
            if (this._registrationMatrix3D) {
                this._orientationMatrix.prepend(this._registrationMatrix3D);
                if (this.alignmentMode != AlignmentMode.REGISTRATION_POINT)
                    this._orientationMatrix.appendTranslation(-this._registrationMatrix3D._rawData[12] * this._transform.scale.x, -this._registrationMatrix3D._rawData[13] * this._transform.scale.y, -this._registrationMatrix3D._rawData[14] * this._transform.scale.z);
            }
            return this._orientationMatrix;
        }
        return this._transform.concatenatedMatrix3D;
    };
    /**
     *
     */
    DisplayObject.prototype.removeEventListener = function (type, listener) {
        _super.prototype.removeEventListener.call(this, type, listener);
        if (this.hasEventListener(type))
            return;
        switch (type) {
            case DisplayObjectEvent.SCENE_CHANGED:
                this._listenToSceneChanged = false;
                break;
            case DisplayObjectEvent.SCENETRANSFORM_CHANGED:
                this._listenToSceneTransformChanged = true;
                break;
        }
    };
    Object.defineProperty(DisplayObject.prototype, "_iPickingCollision", {
        /**
         * @internal
         */
        get: function () {
            if (!this._pickingCollision)
                this._pickingCollision = new _awayjs_graphics.PickingCollision(this);
            return this._pickingCollision;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    DisplayObject.prototype.iSetParent = function (value) {
        this._pParent = value;
        if (value)
            this._iSetScene(value._pScene, value._pPartition);
        else
            this._iSetScene(null, null);
        this.pInvalidateHierarchicalProperties(HierarchicalProperties.ALL);
    };
    DisplayObject.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
        var newPropDirty = (this._hierarchicalPropsDirty ^ propDirty) & propDirty;
        if (!newPropDirty)
            return true;
        this._hierarchicalPropsDirty |= propDirty;
        if (newPropDirty & HierarchicalProperties.SCENE_TRANSFORM) {
            this.transform.invalidateConcatenatedMatrix3D();
            this._scenePositionDirty = true;
            if (this.isEntity)
                this.invalidatePartitionBounds();
            if (this._pParent)
                this._pParent._pInvalidateBounds();
            if (this._listenToSceneTransformChanged)
                this.queueDispatch(this._sceneTransformChanged || (this._sceneTransformChanged = new DisplayObjectEvent(DisplayObjectEvent.SCENETRANSFORM_CHANGED, this)));
        }
        return false;
    };
    /**
     * @protected
     */
    DisplayObject.prototype._iSetScene = function (scene, partition) {
        var sceneChanged = this._pScene != scene;
        if (this._pScene) {
            //unregister object from current scene
            this._pScene._iUnregisterObject(this);
            //gc abstraction objects
            this.clear();
        }
        // assign parent partition if _iIsPartition is false
        this._pPartition = this._iIsPartition ? this : partition;
        //assign scene
        if (sceneChanged)
            this._pScene = scene;
        if (this._pScene) {
            //register object with scene
            this._pScene._iRegisterObject(this);
        }
        if (sceneChanged && this._listenToSceneChanged)
            this.queueDispatch(this._sceneChanged || (this._sceneChanged = new DisplayObjectEvent(DisplayObjectEvent.SCENE_CHANGED, this)));
    };
    /**
     * @protected
     */
    DisplayObject.prototype._onUpdateConcatenatedMatrix3D = function (event) {
        if (this._iController)
            this._iController.updateController();
        this._concatenatedMatrix3D.copyFrom(this._transform.matrix3D);
        if (this._registrationMatrix3D) {
            this._concatenatedMatrix3D.prepend(this._registrationMatrix3D);
            if (this.alignmentMode != AlignmentMode.REGISTRATION_POINT)
                this._concatenatedMatrix3D.appendTranslation(-this._registrationMatrix3D._rawData[12] * this._transform.scale.x, -this._registrationMatrix3D._rawData[13] * this._transform.scale.y, -this._registrationMatrix3D._rawData[14] * this._transform.scale.z);
        }
        if (this._pParent && !this._pParent._iIsRoot)
            this._concatenatedMatrix3D.append(this._pParent._transform.concatenatedMatrix3D);
        this._matrix3DDirty = false;
        this._hierarchicalPropsDirty ^= HierarchicalProperties.SCENE_TRANSFORM;
    };
    /**
     *
     */
    DisplayObject.prototype._iInternalUpdate = function () {
        if (this._iController)
            this._iController.update();
        // Dispatch all queued events.
        var len = this._queuedEvents.length;
        for (var i = 0; i < len; ++i)
            this.dispatchEvent(this._queuedEvents[i]);
        this._queuedEvents.length = 0;
    };
    /**
     * @internal
     */
    DisplayObject.prototype._iIsVisible = function () {
        if (this._hierarchicalPropsDirty & HierarchicalProperties.VISIBLE)
            this._updateVisible();
        return this._pImplicitVisibility;
    };
    /**
     * @internal
     */
    DisplayObject.prototype._iAssignedMaskId = function () {
        if (this._hierarchicalPropsDirty & HierarchicalProperties.MASK_ID)
            this._updateMaskId();
        return this._pImplicitMaskId;
    };
    /**
     * @internal
     */
    DisplayObject.prototype._iAssignedMasks = function () {
        if (this._hierarchicalPropsDirty & HierarchicalProperties.MASKS)
            this._updateMasks();
        return this._pImplicitMasks;
    };
    DisplayObject.prototype._iMasksConfig = function () {
        if (this._hierarchicalPropsDirty & HierarchicalProperties.MASKS)
            this._updateMasks();
        return this._pImplicitMaskIds;
    };
    DisplayObject.prototype._iAssignedColorTransform = function () {
        if (this._hierarchicalPropsDirty & HierarchicalProperties.COLOR_TRANSFORM)
            this._updateColorTransform();
        return this._pImplicitColorTransform || (this._pImplicitColorTransform = new _awayjs_core.ColorTransform());
    };
    /**
     * @internal
     */
    DisplayObject.prototype._iIsMouseEnabled = function () {
        if (this._hierarchicalPropsDirty & HierarchicalProperties.MOUSE_ENABLED)
            this._updateMouseEnabled();
        return this._pImplicitMouseEnabled && this._explicitMouseEnabled;
    };
    DisplayObject.prototype._acceptTraverser = function (traverser) {
        //nothing to do here
    };
    /**
     * Invalidates the 3D transformation matrix, causing it to be updated upon the next request
     *
     * @private
     */
    DisplayObject.prototype._onInvalidateMatrix3D = function (event) {
        if (this._matrix3DDirty)
            return;
        this._matrix3DDirty = true;
        this.pInvalidateHierarchicalProperties(HierarchicalProperties.SCENE_TRANSFORM);
    };
    /**
     * @private
     */
    DisplayObject.prototype._onInvalidateColorTransform = function (event) {
        this.pInvalidateHierarchicalProperties(HierarchicalProperties.COLOR_TRANSFORM);
    };
    DisplayObject.prototype._pInvalidateBounds = function () {
        if (this._boxBoundsInvalid && this._sphereBoundsInvalid)
            return;
        this._boxBoundsInvalid = true;
        this._sphereBoundsInvalid = true;
        if (this.isEntity)
            this.invalidatePartitionBounds();
        if (this._pParent)
            this._pParent._pInvalidateBounds();
    };
    DisplayObject.prototype._pUpdateBoxBounds = function () {
        this._boxBoundsInvalid = false;
        if (this._pBoxBounds == null)
            this._pBoxBounds = new _awayjs_core.Box();
        this._pBoxBounds.setEmpty();
    };
    DisplayObject.prototype._pUpdateSphereBounds = function () {
        this._sphereBoundsInvalid = false;
        if (this._pSphereBounds == null)
            this._pSphereBounds = new _awayjs_core.Sphere();
    };
    DisplayObject.prototype.queueDispatch = function (event) {
        // Store event to be dispatched later.
        this._queuedEvents.push(event);
    };
    DisplayObject.prototype._setScaleX = function (val) {
        if (this.scaleX == val)
            return;
        this._transform.scale.x = val;
        this._transform.invalidateMatrix3D();
    };
    DisplayObject.prototype._setScaleY = function (val) {
        if (this.scaleY == val)
            return;
        this._transform.scale.y = val;
        this._transform.invalidateMatrix3D();
    };
    DisplayObject.prototype._setScaleZ = function (val) {
        if (this.scaleZ == val)
            return;
        this._transform.scale.z = val;
        this._transform.invalidateMatrix3D();
    };
    DisplayObject.prototype._updateMouseEnabled = function () {
        this._pImplicitMouseEnabled = (this._pParent) ? this._pParent.mouseChildren && this._pParent._pImplicitMouseEnabled : true;
        this._hierarchicalPropsDirty ^= HierarchicalProperties.MOUSE_ENABLED;
    };
    DisplayObject.prototype._updateVisible = function () {
        this._pImplicitVisibility = (this._pParent) ? this._explicitVisibility && this._pParent._iIsVisible() : this._explicitVisibility;
        this._hierarchicalPropsDirty ^= HierarchicalProperties.VISIBLE;
    };
    DisplayObject.prototype._updateMaskId = function () {
        this._pImplicitMaskId = (this._pParent && this._pParent._iAssignedMaskId() != -1) ? this._pParent._iAssignedMaskId() : this._explicitMaskId;
        this._hierarchicalPropsDirty ^= HierarchicalProperties.MASK_ID;
    };
    DisplayObject.prototype._updateMasks = function () {
        this._pImplicitMasks = (this._pParent && this._pParent._iAssignedMasks()) ? (this._explicitMasks != null) ? this._pParent._iAssignedMasks().concat([this._explicitMasks]) : this._pParent._iAssignedMasks().concat() : (this._explicitMasks != null) ? [this._explicitMasks] : null;
        this._pImplicitMaskIds.length = 0;
        if (this._pImplicitMasks && this._pImplicitMasks.length) {
            var numLayers = this._pImplicitMasks.length;
            var numChildren;
            var implicitChildren;
            var implicitChildIds;
            for (var i = 0; i < numLayers; i++) {
                implicitChildren = this._pImplicitMasks[i];
                numChildren = implicitChildren.length;
                implicitChildIds = new Array();
                for (var j = 0; j < numChildren; j++)
                    implicitChildIds.push(implicitChildren[j].id);
                this._pImplicitMaskIds.push(implicitChildIds);
            }
        }
        this._hierarchicalPropsDirty ^= HierarchicalProperties.MASKS;
    };
    DisplayObject.prototype._updateColorTransform = function () {
        if (!this._pImplicitColorTransform)
            this._pImplicitColorTransform = new _awayjs_core.ColorTransform();
        if (this._inheritColorTransform && this._pParent && this._pParent._iAssignedColorTransform()) {
            this._pImplicitColorTransform.copyFrom(this._pParent._iAssignedColorTransform());
            this._pImplicitColorTransform.prepend(this._transform.colorTransform);
        }
        else {
            this._pImplicitColorTransform.copyFrom(this._transform.colorTransform);
        }
        this._hierarchicalPropsDirty ^= HierarchicalProperties.COLOR_TRANSFORM;
    };
    DisplayObject.prototype._updateMaskMode = function () {
        if (this.maskMode)
            this.mouseEnabled = false;
        this.pInvalidateHierarchicalProperties(HierarchicalProperties.MASK_ID);
    };
    DisplayObject.prototype.clear = function () {
        _super.prototype.clear.call(this);
        var i;
        this._pImplicitColorTransform = null;
        this._pImplicitMasks = null;
    };
    DisplayObject.prototype.invalidatePartitionBounds = function () {
        this.dispatchEvent(new DisplayObjectEvent(DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS, this));
    };
    DisplayObject.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
        return false;
    };
    DisplayObject.prototype.invalidateMaterial = function () {
        //TODO: herarchical materials and/or Styles?
    };
    DisplayObject.prototype.invalidateElements = function () {
        //TODO: herarchical elements?
    };
    DisplayObject.prototype._onInvalidateProperties = function (event) {
        if (event === void 0) { event = null; }
        this.invalidateMaterial();
    };
    return DisplayObject;
}(_awayjs_core.AssetBase));
DisplayObject.traverseName = "applyEntity";

//import {Sprite} from "./Sprite";
/**
 * The DisplayObjectContainer class is the base class for all objects that can
 * serve as display object containers on the display list. The display list
 * manages all objects displayed in the Flash runtimes. Use the
 * DisplayObjectContainer class to arrange the display objects in the display
 * list. Each DisplayObjectContainer object has its own child list for
 * organizing the z-order of the objects. The z-order is the front-to-back
 * order that determines which object is drawn in front, which is behind, and
 * so on.
 *
 * <p>DisplayObject is an abstract base class; therefore, you cannot call
 * DisplayObject directly. Invoking <code>new DisplayObject()</code> throws an
 * <code>ArgumentError</code> exception.</p>
 * The DisplayObjectContainer class is an abstract base class for all objects
 * that can contain child objects. It cannot be instantiated directly; calling
 * the <code>new DisplayObjectContainer()</code> constructor throws an
 * <code>ArgumentError</code> exception.
 *
 * <p>For more information, see the "Display Programming" chapter of the
 * <i>ActionScript 3.0 Developer's Guide</i>.</p>
 */
var DisplayObjectContainer = (function (_super) {
    __extends(DisplayObjectContainer, _super);
    /**
     * Calling the <code>new DisplayObjectContainer()</code> constructor throws
     * an <code>ArgumentError</code> exception. You <i>can</i>, however, call
     * constructors for the following subclasses of DisplayObjectContainer:
     * <ul>
     *   <li><code>new Loader()</code></li>
     *   <li><code>new Sprite()</code></li>
     *   <li><code>new MovieClip()</code></li>
     * </ul>
     */
    function DisplayObjectContainer() {
        var _this = _super.call(this) || this;
        _this._mouseChildren = true;
        _this._depth_childs = {};
        _this._nextHighestDepth = 0;
        _this._children = new Array();
        return _this;
    }
    Object.defineProperty(DisplayObjectContainer.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return DisplayObjectContainer.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObjectContainer.prototype, "mouseChildren", {
        /**
         * Determines whether or not the children of the object are mouse, or user
         * input device, enabled. If an object is enabled, a user can interact with
         * it by using a mouse or user input device. The default is
         * <code>true</code>.
         *
         * <p>This property is useful when you create a button with an instance of
         * the Sprite class(instead of using the SimpleButton class). When you use a
         * Sprite instance to create a button, you can choose to decorate the button
         * by using the <code>addChild()</code> method to add additional Sprite
         * instances. This process can cause unexpected behavior with mouse events
         * because the Sprite instances you add as children can become the target
         * object of a mouse event when you expect the parent instance to be the
         * target object. To ensure that the parent instance serves as the target
         * objects for mouse events, you can set the <code>mouseChildren</code>
         * property of the parent instance to <code>false</code>.</p>
         *
         * <p> No event is dispatched by setting this property. You must use the
         * <code>addEventListener()</code> method to create interactive
         * functionality.</p>
         */
        get: function () {
            if (this._hierarchicalPropsDirty & HierarchicalProperties.MOUSE_ENABLED)
                this._updateMouseEnabled();
            return this._mouseChildren;
        },
        set: function (value) {
            if (this._mouseChildren == value)
                return;
            this._mouseChildren = value;
            this.pInvalidateHierarchicalProperties(HierarchicalProperties.MOUSE_ENABLED);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObjectContainer.prototype, "numChildren", {
        /**
         * Returns the number of children of this object.
         */
        get: function () {
            return this._children.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a child DisplayObject instance to this DisplayObjectContainer
     * instance. The child is added to the front(top) of all other children in
     * this DisplayObjectContainer instance.(To add a child to a specific index
     * position, use the <code>addChildAt()</code> method.)
     *
     * <p>If you add a child object that already has a different display object
     * container as a parent, the object is removed from the child list of the
     * other display object container. </p>
     *
     * <p><b>Note:</b> The command <code>stage.addChild()</code> can cause
     * problems with a published SWF file, including security problems and
     * conflicts with other loaded SWF files. There is only one Stage within a
     * Flash runtime instance, no matter how many SWF files you load into the
     * runtime. So, generally, objects should not be added to the Stage,
     * directly, at all. The only object the Stage should contain is the root
     * object. Create a DisplayObjectContainer to contain all of the items on the
     * display list. Then, if necessary, add that DisplayObjectContainer instance
     * to the Stage.</p>
     *
     * @param child The DisplayObject instance to add as a child of this
     *              DisplayObjectContainer instance.
     * @return The DisplayObject instance that you pass in the <code>child</code>
     *         parameter.
     * @throws ArgumentError Throws if the child is the same as the parent. Also
     *                       throws if the caller is a child(or grandchild etc.)
     *                       of the child being added.
     * @event added Dispatched when a display object is added to the display
     *              list.
     */
    DisplayObjectContainer.prototype.addChild = function (child) {
        return this.addChildAt(child, this._children.length);
    };
    DisplayObjectContainer.prototype.addChildAtDepth = function (child, depth, replace) {
        if (replace === void 0) { replace = true; }
        if (child == null)
            throw new _awayjs_core.ArgumentError("Parameter child cannot be null.");
        //if child already has a parent, remove it.
        if (child._pParent)
            child._pParent.removeChildAtInternal(child._pParent.getChildIndex(child));
        if (this.isSlice9ScaledMC && child.assetType == "[asset Sprite]") {
            child.isSlice9ScaledSprite = true;
        }
        var index = this.getDepthIndexInternal(depth);
        if (index != -1) {
            if (replace) {
                this.removeChildAt(index);
            }
            else {
                //move depth of existing child up by 1
                this.addChildAtDepth(this._children[index], depth + 1, false);
            }
        }
        if (this._nextHighestDepth < depth + 1)
            this._nextHighestDepth = depth + 1;
        this._depth_childs[depth] = child;
        this._children.push(child);
        child._depthID = depth;
        child.iSetParent(this);
        this._invalidateChildren();
        return child;
    };
    /**
     * Adds a child DisplayObject instance to this DisplayObjectContainer
     * instance. The child is added at the index position specified. An index of
     * 0 represents the back(bottom) of the display list for this
     * DisplayObjectContainer object.
     *
     * <p>For example, the following example shows three display objects, labeled
     * a, b, and c, at index positions 0, 2, and 1, respectively:</p>
     *
     * <p>If you add a child object that already has a different display object
     * container as a parent, the object is removed from the child list of the
     * other display object container. </p>
     *
     * @param child The DisplayObject instance to add as a child of this
     *              DisplayObjectContainer instance.
     * @param index The index position to which the child is added. If you
     *              specify a currently occupied index position, the child object
     *              that exists at that position and all higher positions are
     *              moved up one position in the child list.
     * @return The DisplayObject instance that you pass in the <code>child</code>
     *         parameter.
     * @throws ArgumentError Throws if the child is the same as the parent. Also
     *                       throws if the caller is a child(or grandchild etc.)
     *                       of the child being added.
     * @throws RangeError    Throws if the index position does not exist in the
     *                       child list.
     * @event added Dispatched when a display object is added to the display
     *              list.
     */
    DisplayObjectContainer.prototype.addChildAt = function (child, index) {
        return this.addChildAtDepth(child, (index < this._children.length) ? this._children[index]._depthID : this.getNextHighestDepth(), false);
    };
    DisplayObjectContainer.prototype.addChildren = function () {
        var childarray = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            childarray[_i] = arguments[_i];
        }
        var len = childarray.length;
        for (var i = 0; i < len; i++)
            this.addChild(childarray[i]);
    };
    /**
     *
     */
    DisplayObjectContainer.prototype.clone = function () {
        var newInstance = new DisplayObjectContainer();
        this.copyTo(newInstance);
        return newInstance;
    };
    DisplayObjectContainer.prototype.copyTo = function (newInstance) {
        _super.prototype.copyTo.call(this, newInstance);
        newInstance.mouseChildren = this._mouseChildren;
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            newInstance.addChild(this._children[i].clone());
    };
    /**
     * Determines whether the specified display object is a child of the
     * DisplayObjectContainer instance or the instance itself. The search
     * includes the entire display list including this DisplayObjectContainer
     * instance. Grandchildren, great-grandchildren, and so on each return
     * <code>true</code>.
     *
     * @param child The child object to test.
     * @return <code>true</code> if the <code>child</code> object is a child of
     *         the DisplayObjectContainer or the container itself; otherwise
     *         <code>false</code>.
     */
    DisplayObjectContainer.prototype.contains = function (child) {
        return this._children.indexOf(child) >= 0;
    };
    /**
     *
     */
    DisplayObjectContainer.prototype.disposeValues = function () {
        for (var i = this._children.length - 1; i >= 0; i--)
            this.removeChild(this._children[i]);
        _super.prototype.disposeValues.call(this);
    };
    DisplayObjectContainer.prototype.getChildAtDepth = function (depth) {
        return this._depth_childs[depth];
    };
    /**
     * Returns the child display object instance that exists at the specified
     * index.
     *
     * @param index The index position of the child object.
     * @return The child display object at the specified index position.
     * @throws RangeError    Throws if the index does not exist in the child
     *                       list.
     */
    DisplayObjectContainer.prototype.getChildAt = function (index) {
        var child = this._children[index];
        if (child == null)
            throw new _awayjs_core.RangeError("Index does not exist in the child list of the caller");
        return child;
    };
    /**
     * Returns the child display object that exists with the specified name. If
     * more that one child display object has the specified name, the method
     * returns the first object in the child list.
     *
     * <p>The <code>getChildAt()</code> method is faster than the
     * <code>getChildByName()</code> method. The <code>getChildAt()</code> method
     * accesses a child from a cached array, whereas the
     * <code>getChildByName()</code> method has to traverse a linked list to
     * access a child.</p>
     *
     * @param name The name of the child to return.
     * @return The child display object with the specified name.
     */
    DisplayObjectContainer.prototype.getChildByName = function (name) {
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            if (this._children[i].name == name)
                return this._children[i];
        return null;
    };
    /**
     * Returns the index position of a <code>child</code> DisplayObject instance.
     *
     * @param child The DisplayObject instance to identify.
     * @return The index position of the child display object to identify.
     * @throws ArgumentError Throws if the child parameter is not a child of this
     *                       object.
     */
    DisplayObjectContainer.prototype.getChildIndex = function (child) {
        var childIndex = this._children.indexOf(child);
        if (childIndex == -1)
            throw new _awayjs_core.ArgumentError("Child parameter is not a child of the caller");
        return childIndex;
    };
    DisplayObjectContainer.prototype.getNextHighestDepth = function () {
        if (this._nextHighestDepthDirty)
            this._updateNextHighestDepth();
        return this._nextHighestDepth;
    };
    /**
     * Returns an array of objects that lie under the specified point and are
     * children(or grandchildren, and so on) of this DisplayObjectContainer
     * instance. Any child objects that are inaccessible for security reasons are
     * omitted from the returned array. To determine whether this security
     * restriction affects the returned array, call the
     * <code>areInaccessibleObjectsUnderPoint()</code> method.
     *
     * <p>The <code>point</code> parameter is in the coordinate space of the
     * Stage, which may differ from the coordinate space of the display object
     * container(unless the display object container is the Stage). You can use
     * the <code>globalToLocal()</code> and the <code>localToGlobal()</code>
     * methods to convert points between these coordinate spaces.</p>
     *
     * @param point The point under which to look.
     * @return An array of objects that lie under the specified point and are
     *         children(or grandchildren, and so on) of this
     *         DisplayObjectContainer instance.
     */
    DisplayObjectContainer.prototype.getObjectsUnderPoint = function (point) {
        return new Array();
    };
    /**
     * Removes the specified <code>child</code> DisplayObject instance from the
     * child list of the DisplayObjectContainer instance. The <code>parent</code>
     * property of the removed child is set to <code>null</code> , and the object
     * is garbage collected if no other references to the child exist. The index
     * positions of any display objects above the child in the
     * DisplayObjectContainer are decreased by 1.
     *
     * <p>The garbage collector reallocates unused memory space. When a variable
     * or object is no longer actively referenced or stored somewhere, the
     * garbage collector sweeps through and wipes out the memory space it used to
     * occupy if no other references to it exist.</p>
     *
     * @param child The DisplayObject instance to remove.
     * @return The DisplayObject instance that you pass in the <code>child</code>
     *         parameter.
     * @throws ArgumentError Throws if the child parameter is not a child of this
     *                       object.
     */
    DisplayObjectContainer.prototype.removeChild = function (child) {
        if (child == null)
            throw new _awayjs_core.ArgumentError("Parameter child cannot be null");
        this.removeChildAt(this.getChildIndex(child));
        return child;
    };
    DisplayObjectContainer.prototype.removeChildAtDepth = function (depth) {
        return this.removeChildAt(this.getDepthIndexInternal(depth));
    };
    /**
     * Removes a child DisplayObject from the specified <code>index</code>
     * position in the child list of the DisplayObjectContainer. The
     * <code>parent</code> property of the removed child is set to
     * <code>null</code>, and the object is garbage collected if no other
     * references to the child exist. The index positions of any display objects
     * above the child in the DisplayObjectContainer are decreased by 1.
     *
     * <p>The garbage collector reallocates unused memory space. When a variable
     * or object is no longer actively referenced or stored somewhere, the
     * garbage collector sweeps through and wipes out the memory space it used to
     * occupy if no other references to it exist.</p>
     *
     * @param index The child index of the DisplayObject to remove.
     * @return The DisplayObject instance that was removed.
     * @throws RangeError    Throws if the index does not exist in the child
     *                       list.
     * @throws SecurityError This child display object belongs to a sandbox to
     *                       which the calling object does not have access. You
     *                       can avoid this situation by having the child movie
     *                       call the <code>Security.allowDomain()</code> method.
     */
    DisplayObjectContainer.prototype.removeChildAt = function (index) {
        var child = this.removeChildAtInternal(index);
        child.iSetParent(null);
        this._invalidateChildren();
        return child;
    };
    /**
     * Removes all <code>child</code> DisplayObject instances from the child list
     * of the DisplayObjectContainer instance. The <code>parent</code> property
     * of the removed children is set to <code>null</code>, and the objects are
     * garbage collected if no other references to the children exist.
     *
     * The garbage collector reallocates unused memory space. When a variable or
     * object is no longer actively referenced or stored somewhere, the garbage
     * collector sweeps through and wipes out the memory space it used to occupy
     * if no other references to it exist.
     *
     * @param beginIndex The beginning position. A value smaller than 0 throws a RangeError.
     * @param endIndex The ending position. A value smaller than 0 throws a RangeError.
     * @throws RangeError    Throws if the beginIndex or endIndex positions do
     *                       not exist in the child list.
     */
    DisplayObjectContainer.prototype.removeChildren = function (beginIndex, endIndex) {
        if (beginIndex === void 0) { beginIndex = 0; }
        if (endIndex === void 0) { endIndex = 2147483647; }
        if (beginIndex < 0)
            throw new _awayjs_core.RangeError("beginIndex is out of range of the child list");
        if (endIndex > this._children.length)
            throw new _awayjs_core.RangeError("endIndex is out of range of the child list");
        //var oldChilds:DisplayObject[]=this._children.slice();
        for (var i = endIndex - 1; i >= beginIndex; i--)
            this.removeChildAtInternal(i).iSetParent(null);
        this._invalidateChildren();
    };
    /**
     * Changes the position of an existing child in the display object container.
     * This affects the layering of child objects. For example, the following
     * example shows three display objects, labeled a, b, and c, at index
     * positions 0, 1, and 2, respectively:
     *
     * <p>When you use the <code>setChildIndex()</code> method and specify an
     * index position that is already occupied, the only positions that change
     * are those in between the display object's former and new position. All
     * others will stay the same. If a child is moved to an index LOWER than its
     * current index, all children in between will INCREASE by 1 for their index
     * reference. If a child is moved to an index HIGHER than its current index,
     * all children in between will DECREASE by 1 for their index reference. For
     * example, if the display object container in the previous example is named
     * <code>container</code>, you can swap the position of the display objects
     * labeled a and b by calling the following code:</p>
     *
     * <p>This code results in the following arrangement of objects:</p>
     *
     * @param child The child DisplayObject instance for which you want to change
     *              the index number.
     * @param index The resulting index number for the <code>child</code> display
     *              object.
     * @throws ArgumentError Throws if the child parameter is not a child of this
     *                       object.
     * @throws RangeError    Throws if the index does not exist in the child
     *                       list.
     */
    DisplayObjectContainer.prototype.setChildIndex = function (child, index) {
        //TODO
    };
    /**
     * Swaps the z-order (front-to-back order) of the two specified child
     * objects. All other child objects in the display object container remain in
     * the same index positions.
     *
     * @param child1 The first child object.
     * @param child2 The second child object.
     * @throws ArgumentError Throws if either child parameter is not a child of
     *                       this object.
     */
    DisplayObjectContainer.prototype.swapChildren = function (child1, child2) {
        this.swapChildrenAt(this.getChildIndex(child1), this.getChildIndex(child2));
    };
    /**
     * Swaps the z-order(front-to-back order) of the child objects at the two
     * specified index positions in the child list. All other child objects in
     * the display object container remain in the same index positions.
     *
     * @param index1 The index position of the first child object.
     * @param index2 The index position of the second child object.
     * @throws RangeError If either index does not exist in the child list.
     */
    DisplayObjectContainer.prototype.swapChildrenAt = function (index1, index2) {
        var depth = this._children[index2]._depthID;
        var child = this._children[index1];
        this.addChildAtDepth(this._children[index2], this._children[index1]._depthID);
        this.addChildAtDepth(child, depth);
    };
    /**
     * //TODO
     *
     * @protected
     */
    DisplayObjectContainer.prototype._pUpdateBoxBounds = function () {
        _super.prototype._pUpdateBoxBounds.call(this);
        var numChildren = this._children.length;
        if (numChildren > 0) {
            var childBox;
            var first = true;
            for (var i = 0; i < numChildren; ++i) {
                // ignore bounds of childs that are masked
                // todo: this check is only needed for icycle, to get mouseclicks work correct in shop
                //if(this._children[i].masks==null){
                childBox = this._children[i].getBox();
                if (childBox.isEmpty())
                    continue;
                childBox = this._children[i].getBox(this);
                if (first) {
                    first = false;
                    this._pBoxBounds.copyFrom(childBox);
                }
                else {
                    this._pBoxBounds = this._pBoxBounds.union(childBox, this._pBoxBounds);
                }
            }
        }
    };
    /**
     * @protected
     */
    DisplayObjectContainer.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
        if (_super.prototype.pInvalidateHierarchicalProperties.call(this, propDirty))
            return true;
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            this._children[i].pInvalidateHierarchicalProperties(propDirty);
        return false;
    };
    /**
     * @internal
     */
    DisplayObjectContainer.prototype._iSetScene = function (value, partition) {
        _super.prototype._iSetScene.call(this, value, partition);
        var len = this._children.length;
        for (var i = 0; i < len; ++i)
            this._children[i]._iSetScene(value, this._pPartition);
    };
    /**
     * @private
     *
     * @param child
     */
    DisplayObjectContainer.prototype.removeChildAtInternal = function (index) {
        var child = this._children.splice(index, 1)[0];
        //update next highest depth
        if (this._nextHighestDepth == child._depthID + 1)
            this._nextHighestDepthDirty = true;
        delete this._depth_childs[child._depthID];
        child._depthID = -16384;
        return child;
    };
    DisplayObjectContainer.prototype.getDepthIndexInternal = function (depth) {
        if (!this._depth_childs[depth])
            return -1;
        return this._children.indexOf(this._depth_childs[depth]);
    };
    DisplayObjectContainer.prototype._updateNextHighestDepth = function () {
        this._nextHighestDepthDirty = false;
        this._nextHighestDepth = 0;
        var len = this._children.length;
        for (var i = 0; i < len; i++)
            if (this._nextHighestDepth < this._children[i]._depthID)
                this._nextHighestDepth = this._children[i]._depthID;
        this._nextHighestDepth += 1;
    };
    DisplayObjectContainer.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
        var numChildren = this._children.length;
        for (var i = 0; i < numChildren; i++)
            if (this._children[i].hitTestPoint(x, y, shapeFlag, masksFlag))
                return true;
        return false;
    };
    DisplayObjectContainer.prototype._updateMaskMode = function () {
        if (this.maskMode)
            this.mouseChildren = false;
        _super.prototype._updateMaskMode.call(this);
    };
    DisplayObjectContainer.prototype._isEntityInternal = function () {
        return Boolean(this._children.length);
    };
    DisplayObjectContainer.prototype._invalidateChildren = function () {
        var isContainer = Boolean(this._children.length);
        var isEntity = this._isEntityInternal();
        if (this._pIsContainer != isContainer || this._pIsEntity != isEntity) {
            if (this._pScene)
                this._pScene._iUnregisterObject(this);
            this._pIsContainer = isContainer;
            this._pIsEntity = isEntity;
            if (this._pScene)
                this._pScene._iRegisterObject(this);
        }
        this._pInvalidateBounds();
    };
    return DisplayObjectContainer;
}(DisplayObject));
DisplayObjectContainer.assetType = "[asset DisplayObjectContainer]";

/**
 * Sprite is an instance of a Graphics, augmenting it with a presence in the scene graph, a material, and an animation
 * state. It consists out of Graphices, which in turn correspond to SubGeometries. Graphices allow different parts
 * of the graphics to be assigned different materials.
 */
var Sprite = (function (_super) {
    __extends(Sprite, _super);
    /**
     * Create a new Sprite object.
     *
     * @param material    [optional]        The material with which to render the Sprite.
     */
    function Sprite(material) {
        if (material === void 0) { material = null; }
        var _this = _super.call(this) || this;
        _this._onGraphicsInvalidateDelegate = function (event) { return _this._onGraphicsInvalidate(event); };
        _this._graphics = _awayjs_graphics.Graphics.getGraphics(_this); //unique graphics object for each Sprite
        _this._graphics.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, _this._onGraphicsInvalidateDelegate);
        _this.material = material;
        return _this;
    }
    Sprite.getNewSprite = function (material) {
        if (material === void 0) { material = null; }
        if (Sprite._sprites.length) {
            var sprite = Sprite._sprites.pop();
            sprite.material = material;
            return sprite;
        }
        return new Sprite(material);
    };
    Object.defineProperty(Sprite.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return Sprite.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "graphics", {
        /**
         * Specifies the Graphics object belonging to this Sprite object, where
         * drawing commands can occur.
         */
        get: function () {
            if (this._iSourcePrefab)
                this._iSourcePrefab._iValidate();
            if (this.isSlice9ScaledSprite) {
                //var comps:Array<Vector3D> = this.transform.concatenatedMatrix3D.decompose();
                this._graphics.updateSlice9(this.parent.scaleX, this.parent.scaleY);
            }
            if (this.parent) {
                var scaleX = this.scaleX;
                var parent = this.parent;
                while (parent) {
                    scaleX *= parent.scaleX;
                    parent = parent.parent;
                }
                this._graphics.updateScale(scaleX, this.parent.scaleY * this.scaleY);
            }
            return this._graphics;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "animator", {
        /**
         * Defines the animator of the graphics object.  Default value is <code>null</code>.
         */
        get: function () {
            return this._graphics.animator;
        },
        set: function (value) {
            this._graphics.animator = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "material", {
        /**
         * The material with which to render the Sprite.
         */
        get: function () {
            return this._graphics.material;
        },
        set: function (value) {
            this._graphics.material = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Sprite.prototype, "style", {
        /**
         *
         */
        get: function () {
            return this._graphics.style;
        },
        set: function (value) {
            this._graphics.style = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    Sprite.prototype.dispose = function () {
        this.disposeValues();
        Sprite._sprites.push(this);
    };
    /**
     * @inheritDoc
     */
    Sprite.prototype.disposeValues = function () {
        _super.prototype.disposeValues.call(this);
        this._graphics.dispose();
    };
    /**
     * Clones this Sprite instance along with all it's children, while re-using the same
     * material, graphics and animation set. The returned result will be a copy of this sprite,
     * containing copies of all of it's children.
     *
     * Properties that are re-used (i.e. not cloned) by the new copy include name,
     * graphics, and material. Properties that are cloned or created anew for the copy
     * include subSpritees, children of the sprite, and the animator.
     *
     * If you want to copy just the sprite, reusing it's graphics and material while not
     * cloning it's children, the simplest way is to create a new sprite manually:
     *
     * <code>
     * var clone : Sprite = new Sprite(original.graphics, original.material);
     * </code>
     */
    Sprite.prototype.clone = function () {
        var newInstance = (Sprite._sprites.length) ? Sprite._sprites.pop() : new Sprite();
        this.copyTo(newInstance);
        return newInstance;
    };
    Sprite.prototype.copyTo = function (sprite, cloneShapes) {
        if (cloneShapes === void 0) { cloneShapes = false; }
        _super.prototype.copyTo.call(this, sprite);
        this._graphics.copyTo(sprite.graphics, cloneShapes);
    };
    /**
     * //TODO
     *
     * @protected
     */
    Sprite.prototype._pUpdateBoxBounds = function () {
        _super.prototype._pUpdateBoxBounds.call(this);
        var graphicsBox = this._graphics.getBoxBounds();
        if (!graphicsBox.isEmpty())
            this._pBoxBounds.union(this._graphics.getBoxBounds(), this._pBoxBounds);
    };
    Sprite.prototype._pUpdateSphereBounds = function () {
        _super.prototype._pUpdateSphereBounds.call(this);
        var box = this.getBox();
        if (!this._center)
            this._center = new _awayjs_core.Vector3D();
        this._center.x = box.x + box.width / 2;
        this._center.y = box.y + box.height / 2;
        this._center.z = box.z + box.depth / 2;
        this._pSphereBounds = this._graphics.getSphereBounds(this._center, this._pSphereBounds);
    };
    Sprite.prototype._isEntityInternal = function () {
        return Boolean(this._graphics.count) || Boolean(this._children.length);
    };
    /**
     * //TODO
     *
     * @private
     */
    Sprite.prototype._onGraphicsInvalidate = function (event) {
        this._invalidateChildren();
    };
    /**
     *
     * @param renderer
     *
     * @internal
     */
    Sprite.prototype._acceptTraverser = function (traverser) {
        this.graphics.acceptTraverser(traverser);
    };
    Sprite.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
        if (this._graphics.count) {
            //early out for non-shape tests
            if (!shapeFlag)
                return true;
            //ok do the graphics thing
            if (this._graphics._hitTestPointInternal(this._tempPoint.x, this._tempPoint.y))
                return true;
        }
        return _super.prototype._hitTestPointInternal.call(this, x, y, shapeFlag, masksFlag);
    };
    Sprite.prototype.clear = function () {
        _super.prototype.clear.call(this);
        this._graphics.clearInternal();
    };
    /**
     *
     */
    Sprite.prototype.bakeTransformations = function () {
        this._graphics.applyTransformation(this.transform.matrix3D);
        this.transform.clearMatrix3D();
    };
    Sprite.prototype.invalidateElements = function () {
        this.graphics.invalidateElements();
    };
    Sprite.prototype.invalidateMaterial = function () {
        this.graphics.invalidateMaterials();
    };
    return Sprite;
}(DisplayObjectContainer));
Sprite._sprites = new Array();
Sprite.assetType = "[asset Sprite]";

/**
 * PrefabBase is an abstract base class for prefabs, which are prebuilt display objects that allow easy cloning and updating
 */
var PrefabBase = (function (_super) {
    __extends(PrefabBase, _super);
    //		public _pBatchObjects:Array<BatchObject> = new Array<BatchObject>();
    /**
     * Creates a new PrefabBase object.
     */
    function PrefabBase() {
        var _this = _super.call(this) || this;
        _this._pObjects = new Array();
        return _this;
    }
    /**
     * Returns a display object generated from this prefab
     */
    PrefabBase.prototype.getNewObject = function () {
        var object = this._pCreateObject();
        this._pObjects.push(object);
        return object;
    };
    //		public getNewBatchObject():BatchObject
    //		{
    //			var object:BatchObject = this._pCreateBatchObject();
    //
    //			this._pBatchObjects.push(object);
    //
    //			return object;
    //		}
    PrefabBase.prototype._pCreateObject = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    PrefabBase.prototype._iValidate = function () {
        // To be overridden when necessary
    };
    return PrefabBase;
}(_awayjs_core.AssetBase));

/**
 * PrimitivePrefabBase is an abstract base class for polytope prefabs, which are simple pre-built geometric shapes
 */
var PrimitivePrefabBase = (function (_super) {
    __extends(PrimitivePrefabBase, _super);
    /**
     * Creates a new PrimitivePrefabBase object.
     *
     * @param material The material with which to render the object
     */
    function PrimitivePrefabBase(material, elementsType) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        var _this = _super.call(this) || this;
        _this._primitiveDirty = true;
        _this._uvDirty = true;
        _this._scaleU = 1;
        _this._scaleV = 1;
        _this._material = material;
        _this._elementsType = elementsType;
        if (_this._elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleElements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
            triangleElements.autoDeriveNormals = false;
            triangleElements.autoDeriveTangents = false;
            _this._elements = triangleElements;
        }
        else if (_this._elementsType == _awayjs_graphics.ElementsType.LINE) {
            _this._elements = new _awayjs_graphics.LineElements(new _awayjs_core.AttributesBuffer());
        }
        return _this;
    }
    Object.defineProperty(PrimitivePrefabBase.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return PrimitivePrefabBase.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePrefabBase.prototype, "elementsType", {
        /**
         *
         */
        get: function () {
            return this._elementsType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePrefabBase.prototype, "material", {
        /**
         * The material with which to render the primitive.
         */
        get: function () {
            return this._material;
        },
        set: function (value) {
            if (value == this._material)
                return;
            this._material = value;
            var len = this._pObjects.length;
            for (var i = 0; i < len; i++)
                this._pObjects[i].material = this._material;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePrefabBase.prototype, "scaleU", {
        get: function () {
            return this._scaleU;
        },
        set: function (value) {
            if (this._scaleU == value)
                return;
            this._scaleU = value;
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePrefabBase.prototype, "scaleV", {
        get: function () {
            return this._scaleV;
        },
        set: function (value) {
            if (this._scaleV == value)
                return;
            this._scaleV = value;
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Builds the primitive's geometry when invalid. This method should not be called directly. The calling should
     * be triggered by the invalidateGraphics method (and in turn by updateGraphics).
     */
    PrimitivePrefabBase.prototype._pBuildGraphics = function (target, elementsType) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * Builds the primitive's uv coordinates when invalid. This method should not be called directly. The calling
     * should be triggered by the invalidateUVs method (and in turn by updateUVs).
     */
    PrimitivePrefabBase.prototype._pBuildUVs = function (target, elementsType) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * Invalidates the primitive, causing it to be updated when requested.
     */
    PrimitivePrefabBase.prototype._pInvalidatePrimitive = function () {
        this._primitiveDirty = true;
    };
    /**
     * Invalidates the primitive's uv coordinates, causing them to be updated when requested.
     */
    PrimitivePrefabBase.prototype._pInvalidateUVs = function () {
        this._uvDirty = true;
    };
    /**
     * Updates the geometry when invalid.
     */
    PrimitivePrefabBase.prototype.updateGraphics = function () {
        this._pBuildGraphics(this._elements, this._elementsType);
        this._primitiveDirty = false;
    };
    /**
     * Updates the uv coordinates when invalid.
     */
    PrimitivePrefabBase.prototype.updateUVs = function () {
        this._pBuildUVs(this._elements, this._elementsType);
        this._uvDirty = false;
    };
    PrimitivePrefabBase.prototype._iValidate = function () {
        if (this._primitiveDirty)
            this.updateGraphics();
        if (this._uvDirty)
            this.updateUVs();
    };
    PrimitivePrefabBase.prototype._pCreateObject = function () {
        var sprite = new Sprite(this._material);
        sprite.graphics.addShape(_awayjs_graphics.Shape.getShape(this._elements));
        sprite._iSourcePrefab = this;
        return sprite;
    };
    return PrimitivePrefabBase;
}(PrefabBase));
PrimitivePrefabBase.assetType = "[asset PrimitivePrefab]";

/**
 * A Cube primitive prefab.
 */
var PrimitiveCubePrefab = (function (_super) {
    __extends(PrimitiveCubePrefab, _super);
    /**
     * Creates a new Cube object.
     * @param width The size of the cube along its X-axis.
     * @param height The size of the cube along its Y-axis.
     * @param depth The size of the cube along its Z-axis.
     * @param segmentsW The number of segments that make up the cube along the X-axis.
     * @param segmentsH The number of segments that make up the cube along the Y-axis.
     * @param segmentsD The number of segments that make up the cube along the Z-axis.
     * @param tile6 The type of uv mapping to use. When true, a texture will be subdivided in a 2x3 grid, each used for a single face. When false, the entire image is mapped on each face.
     */
    function PrimitiveCubePrefab(material, elementsType, width, height, depth, segmentsW, segmentsH, segmentsD, tile6) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (width === void 0) { width = 100; }
        if (height === void 0) { height = 100; }
        if (depth === void 0) { depth = 100; }
        if (segmentsW === void 0) { segmentsW = 1; }
        if (segmentsH === void 0) { segmentsH = 1; }
        if (segmentsD === void 0) { segmentsD = 1; }
        if (tile6 === void 0) { tile6 = true; }
        var _this = _super.call(this, material, elementsType) || this;
        _this._width = width;
        _this._height = height;
        _this._depth = depth;
        _this._segmentsW = segmentsW;
        _this._segmentsH = segmentsH;
        _this._segmentsD = segmentsD;
        _this._tile6 = tile6;
        return _this;
    }
    Object.defineProperty(PrimitiveCubePrefab.prototype, "width", {
        /**
         * The size of the cube along its X-axis.
         */
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCubePrefab.prototype, "height", {
        /**
         * The size of the cube along its Y-axis.
         */
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCubePrefab.prototype, "depth", {
        /**
         * The size of the cube along its Z-axis.
         */
        get: function () {
            return this._depth;
        },
        set: function (value) {
            this._depth = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCubePrefab.prototype, "tile6", {
        /**
         * The type of uv mapping to use. When false, the entire image is mapped on each face.
         * When true, a texture will be subdivided in a 3x2 grid, each used for a single face.
         * Reading the tiles from left to right, top to bottom they represent the faces of the
         * cube in the following order: bottom, top, back, left, front, right. This creates
         * several shared edges (between the top, front, left and right faces) which simplifies
         * texture painting.
         */
        get: function () {
            return this._tile6;
        },
        set: function (value) {
            this._tile6 = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsW", {
        /**
         * The number of segments that make up the cube along the X-axis. Defaults to 1.
         */
        get: function () {
            return this._segmentsW;
        },
        set: function (value) {
            this._segmentsW = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsH", {
        /**
         * The number of segments that make up the cube along the Y-axis. Defaults to 1.
         */
        get: function () {
            return this._segmentsH;
        },
        set: function (value) {
            this._segmentsH = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCubePrefab.prototype, "segmentsD", {
        /**
         * The number of segments that make up the cube along the Z-axis. Defaults to 1.
         */
        get: function () {
            return this._segmentsD;
        },
        set: function (value) {
            this._segmentsD = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    PrimitiveCubePrefab.prototype._pBuildGraphics = function (target, elementsType) {
        var indices;
        var positions;
        var normals;
        var tangents;
        var stride;
        var tl, tr, bl, br;
        var i, j, inc = 0;
        var vidx, fidx; // indices
        var hw, hh, hd; // halves
        var dw, dh, dd; // deltas
        var outer_pos;
        // half cube dimensions
        hw = this._width / 2;
        hh = this._height / 2;
        hd = this._depth / 2;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            var numVertices = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
            var numIndices = ((this._segmentsW * this._segmentsH + this._segmentsW * this._segmentsD + this._segmentsH * this._segmentsD) * 12);
            if (numVertices == triangleGraphics.numVertices && triangleGraphics.indices != null) {
                triangleGraphics.invalidateIndices();
                triangleGraphics.invalidateVertices(triangleGraphics.positions);
                triangleGraphics.invalidateVertices(triangleGraphics.normals);
                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
            }
            else {
                triangleGraphics.setIndices(new Uint16Array(numIndices));
                triangleGraphics.setPositions(new Float32Array(numVertices * 3));
                triangleGraphics.setNormals(new Float32Array(numVertices * 3));
                triangleGraphics.setTangents(new Float32Array(numVertices * 3));
                this._pInvalidateUVs();
            }
            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
            positions = triangleGraphics.positions.get(numVertices);
            normals = triangleGraphics.normals.get(numVertices);
            tangents = triangleGraphics.tangents.get(numVertices);
            stride = triangleGraphics.concatenatedBuffer.stride / 4;
            vidx = 0;
            fidx = 0;
            // Segment dimensions
            dw = this._width / this._segmentsW;
            dh = this._height / this._segmentsH;
            dd = this._depth / this._segmentsD;
            for (i = 0; i <= this._segmentsW; i++) {
                outer_pos = -hw + i * dw;
                for (j = 0; j <= this._segmentsH; j++) {
                    // front
                    positions[vidx] = outer_pos;
                    positions[vidx + 1] = -hh + j * dh;
                    positions[vidx + 2] = -hd;
                    normals[vidx] = 0;
                    normals[vidx + 1] = 0;
                    normals[vidx + 2] = -1;
                    tangents[vidx] = 1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                    // back
                    positions[vidx] = outer_pos;
                    positions[vidx + 1] = -hh + j * dh;
                    positions[vidx + 2] = hd;
                    normals[vidx] = 0;
                    normals[vidx + 1] = 0;
                    normals[vidx + 2] = 1;
                    tangents[vidx] = -1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                    if (i && j) {
                        tl = 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                        tr = 2 * (i * (this._segmentsH + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            inc += 2 * (this._segmentsW + 1) * (this._segmentsH + 1);
            for (i = 0; i <= this._segmentsW; i++) {
                outer_pos = -hw + i * dw;
                for (j = 0; j <= this._segmentsD; j++) {
                    // top
                    positions[vidx] = outer_pos;
                    positions[vidx + 1] = hh;
                    positions[vidx + 2] = -hd + j * dd;
                    normals[vidx] = 0;
                    normals[vidx + 1] = 1;
                    normals[vidx + 2] = 0;
                    tangents[vidx] = 1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                    // bottom
                    positions[vidx] = outer_pos;
                    positions[vidx + 1] = -hh;
                    positions[vidx + 2] = -hd + j * dd;
                    normals[vidx] = 0;
                    normals[vidx + 1] = -1;
                    normals[vidx + 2] = 0;
                    tangents[vidx] = 1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                    if (i && j) {
                        tl = inc + 2 * ((i - 1) * (this._segmentsD + 1) + (j - 1));
                        tr = inc + 2 * (i * (this._segmentsD + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
            inc += 2 * (this._segmentsW + 1) * (this._segmentsD + 1);
            for (i = 0; i <= this._segmentsD; i++) {
                outer_pos = hd - i * dd;
                for (j = 0; j <= this._segmentsH; j++) {
                    // left
                    positions[vidx] = -hw;
                    positions[vidx + 1] = -hh + j * dh;
                    positions[vidx + 2] = outer_pos;
                    normals[vidx] = -1;
                    normals[vidx + 1] = 0;
                    normals[vidx + 2] = 0;
                    tangents[vidx] = 0;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = -1;
                    vidx += stride;
                    // right
                    positions[vidx] = hw;
                    positions[vidx + 1] = -hh + j * dh;
                    positions[vidx + 2] = outer_pos;
                    normals[vidx] = 1;
                    normals[vidx + 1] = 0;
                    normals[vidx + 2] = 0;
                    tangents[vidx] = 0;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 1;
                    vidx += stride;
                    if (i && j) {
                        tl = inc + 2 * ((i - 1) * (this._segmentsH + 1) + (j - 1));
                        tr = inc + 2 * (i * (this._segmentsH + 1) + (j - 1));
                        bl = tl + 2;
                        br = tr + 2;
                        indices[fidx++] = tl;
                        indices[fidx++] = bl;
                        indices[fidx++] = br;
                        indices[fidx++] = tl;
                        indices[fidx++] = br;
                        indices[fidx++] = tr;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = br + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tr + 1;
                        indices[fidx++] = bl + 1;
                        indices[fidx++] = tl + 1;
                    }
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
            var lineGraphics = target;
            var numSegments = this._segmentsH * 4 + this._segmentsW * 4 + this._segmentsD * 4;
            var thickness;
            positions = new Float32Array(numSegments * 6);
            thickness = new Float32Array(numSegments);
            vidx = 0;
            fidx = 0;
            //front/back face
            for (i = 0; i < this._segmentsH; ++i) {
                positions[vidx++] = -hw;
                positions[vidx++] = i * this._height / this._segmentsH - hh;
                positions[vidx++] = -hd;
                positions[vidx++] = hw;
                positions[vidx++] = i * this._height / this._segmentsH - hh;
                positions[vidx++] = -hd;
                thickness[fidx++] = 1;
                positions[vidx++] = -hw;
                positions[vidx++] = hh - i * this._height / this._segmentsH;
                positions[vidx++] = hd;
                positions[vidx++] = hw;
                positions[vidx++] = hh - i * this._height / this._segmentsH;
                positions[vidx++] = hd;
                thickness[fidx++] = 1;
            }
            for (i = 0; i < this._segmentsW; ++i) {
                positions[vidx++] = i * this._width / this._segmentsW - hw;
                positions[vidx++] = -hh;
                positions[vidx++] = -hd;
                positions[vidx++] = i * this._width / this._segmentsW - hw;
                positions[vidx++] = hh;
                positions[vidx++] = -hd;
                thickness[fidx++] = 1;
                positions[vidx++] = hw - i * this._width / this._segmentsW;
                positions[vidx++] = -hh;
                positions[vidx++] = hd;
                positions[vidx++] = hw - i * this._width / this._segmentsW;
                positions[vidx++] = hh;
                positions[vidx++] = hd;
                thickness[fidx++] = 1;
            }
            //left/right face
            for (i = 0; i < this._segmentsH; ++i) {
                positions[vidx++] = -hw;
                positions[vidx++] = i * this._height / this._segmentsH - hh;
                positions[vidx++] = -hd;
                positions[vidx++] = -hw;
                positions[vidx++] = i * this._height / this._segmentsH - hh;
                positions[vidx++] = hd;
                thickness[fidx++] = 1;
                positions[vidx++] = hw;
                positions[vidx++] = hh - i * this._height / this._segmentsH;
                positions[vidx++] = -hd;
                positions[vidx++] = hw;
                positions[vidx++] = hh - i * this._height / this._segmentsH;
                positions[vidx++] = hd;
                thickness[fidx++] = 1;
            }
            for (i = 0; i < this._segmentsD; ++i) {
                positions[vidx++] = hw;
                positions[vidx++] = -hh;
                positions[vidx++] = i * this._depth / this._segmentsD - hd;
                positions[vidx++] = hw;
                positions[vidx++] = hh;
                positions[vidx++] = i * this._depth / this._segmentsD - hd;
                thickness[fidx++] = 1;
                positions[vidx++] = -hw;
                positions[vidx++] = -hh;
                positions[vidx++] = hd - i * this._depth / this._segmentsD;
                positions[vidx++] = -hw;
                positions[vidx++] = hh;
                positions[vidx++] = hd - i * this._depth / this._segmentsD;
                thickness[fidx++] = 1;
            }
            //top/bottom face
            for (i = 0; i < this._segmentsD; ++i) {
                positions[vidx++] = -hw;
                positions[vidx++] = -hh;
                positions[vidx++] = hd - i * this._depth / this._segmentsD;
                positions[vidx++] = hw;
                positions[vidx++] = -hh;
                positions[vidx++] = hd - i * this._depth / this._segmentsD;
                thickness[fidx++] = 1;
                positions[vidx++] = -hw;
                positions[vidx++] = hh;
                positions[vidx++] = i * this._depth / this._segmentsD - hd;
                positions[vidx++] = hw;
                positions[vidx++] = hh;
                positions[vidx++] = i * this._depth / this._segmentsD - hd;
                thickness[fidx++] = 1;
            }
            for (i = 0; i < this._segmentsW; ++i) {
                positions[vidx++] = hw - i * this._width / this._segmentsW;
                positions[vidx++] = -hh;
                positions[vidx++] = -hd;
                positions[vidx++] = hw - i * this._width / this._segmentsW;
                positions[vidx++] = -hh;
                positions[vidx++] = hd;
                thickness[fidx++] = 1;
                positions[vidx++] = i * this._width / this._segmentsW - hw;
                positions[vidx++] = hh;
                positions[vidx++] = -hd;
                positions[vidx++] = i * this._width / this._segmentsW - hw;
                positions[vidx++] = hh;
                positions[vidx++] = hd;
                thickness[fidx++] = 1;
            }
            // build real data from raw data
            lineGraphics.setPositions(positions);
            lineGraphics.setThickness(thickness);
        }
    };
    /**
     * @inheritDoc
     */
    PrimitiveCubePrefab.prototype._pBuildUVs = function (target, elementsType) {
        var i, j, index;
        var uvs;
        var stride;
        var u_tile_dim, v_tile_dim;
        var u_tile_step, v_tile_step;
        var tl0u, tl0v;
        var tl1u, tl1v;
        var du, dv;
        var numVertices;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            numVertices = ((this._segmentsW + 1) * (this._segmentsH + 1) + (this._segmentsW + 1) * (this._segmentsD + 1) + (this._segmentsH + 1) * (this._segmentsD + 1)) * 2;
            var triangleGraphics = target;
            if (triangleGraphics.uvs && numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
            }
            else {
                triangleGraphics.setUVs(new Float32Array(numVertices * 2));
            }
            uvs = triangleGraphics.uvs.get(numVertices);
            stride = triangleGraphics.uvs.stride;
            if (this._tile6) {
                u_tile_dim = u_tile_step = 1 / 3;
                v_tile_dim = v_tile_step = 1 / 2;
            }
            else {
                u_tile_dim = v_tile_dim = 1;
                u_tile_step = v_tile_step = 0;
            }
            // Create planes two and two, the same way that they were
            // constructed in the buildGraphics() function. First calculate
            // the top-left UV coordinate for both planes, and then loop
            // over the points, calculating the UVs from these numbers.
            // When tile6 is true, the layout is as follows:
            //       .-----.-----.-----. (1,1)
            //       | Bot |  T  | Bak |
            //       |-----+-----+-----|
            //       |  L  |  F  |  R  |
            // (0,0)'-----'-----'-----'
            index = 0;
            // FRONT / BACK
            tl0u = 1 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this._segmentsW;
            dv = v_tile_dim / this._segmentsH;
            for (i = 0; i <= this._segmentsW; i++) {
                for (j = 0; j <= this._segmentsH; j++) {
                    uvs[index] = (tl0u + i * du) * this._scaleU;
                    uvs[index + 1] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
                    index += stride;
                    uvs[index] = (tl1u + (u_tile_dim - i * du)) * this._scaleU;
                    uvs[index + 1] = (tl1v + (v_tile_dim - j * dv)) * this._scaleV;
                    index += stride;
                }
            }
            // TOP / BOTTOM
            tl0u = 1 * u_tile_step;
            tl0v = 0 * v_tile_step;
            tl1u = 0 * u_tile_step;
            tl1v = 0 * v_tile_step;
            du = u_tile_dim / this._segmentsW;
            dv = v_tile_dim / this._segmentsD;
            for (i = 0; i <= this._segmentsW; i++) {
                for (j = 0; j <= this._segmentsD; j++) {
                    uvs[index] = (tl0u + i * du) * this._scaleU;
                    uvs[index + 1] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
                    index += stride;
                    uvs[index] = (tl1u + i * du) * this._scaleU;
                    uvs[index + 1] = (tl1v + j * dv) * this._scaleV;
                    index += stride;
                }
            }
            // LEFT / RIGHT
            tl0u = 0 * u_tile_step;
            tl0v = 1 * v_tile_step;
            tl1u = 2 * u_tile_step;
            tl1v = 1 * v_tile_step;
            du = u_tile_dim / this._segmentsD;
            dv = v_tile_dim / this._segmentsH;
            for (i = 0; i <= this._segmentsD; i++) {
                for (j = 0; j <= this._segmentsH; j++) {
                    uvs[index] = (tl0u + i * du) * this._scaleU;
                    uvs[index + 1] = (tl0v + (v_tile_dim - j * dv)) * this._scaleV;
                    index += stride;
                    uvs[index] = (tl1u + (u_tile_dim - i * du)) * this._scaleU;
                    uvs[index + 1] = (tl1v + (v_tile_dim - j * dv)) * this._scaleV;
                    index += stride;
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    return PrimitiveCubePrefab;
}(PrimitivePrefabBase));

var BoundingVolumeBase = (function () {
    function BoundingVolumeBase(entity) {
        this._pInvalidated = true;
        this._entity = entity;
    }
    BoundingVolumeBase.prototype.dispose = function () {
        this._entity = null;
        this._pBoundsPrimitive = null;
    };
    Object.defineProperty(BoundingVolumeBase.prototype, "boundsPrimitive", {
        get: function () {
            if (this._pBoundsPrimitive == null) {
                this._pBoundsPrimitive = this._pCreateBoundsPrimitive();
                this._pInvalidated = true;
            }
            if (this._pInvalidated)
                this._pUpdate();
            return this._pBoundsPrimitive;
        },
        enumerable: true,
        configurable: true
    });
    BoundingVolumeBase.prototype.nullify = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    BoundingVolumeBase.prototype.isInFrustum = function (planes, numPlanes) {
        throw new _awayjs_core.AbstractMethodError();
    };
    BoundingVolumeBase.prototype.clone = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    BoundingVolumeBase.prototype.rayIntersection = function (position, direction, targetNormal) {
        return -1;
    };
    BoundingVolumeBase.prototype.classifyToPlane = function (plane) {
        throw new _awayjs_core.AbstractMethodError();
    };
    BoundingVolumeBase.prototype._pUpdate = function () {
        this._pInvalidated = false;
    };
    BoundingVolumeBase.prototype.invalidate = function () {
        this._pInvalidated = true;
    };
    BoundingVolumeBase.prototype._pCreateBoundsPrimitive = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    return BoundingVolumeBase;
}());

/**
 * AxisAlignedBoundingBox represents a bounding box volume that has its planes aligned to the local coordinate axes of the bounded object.
 * This is useful for most sprites.
 */
var AxisAlignedBoundingBox = (function (_super) {
    __extends(AxisAlignedBoundingBox, _super);
    /**
     * Creates a new <code>AxisAlignedBoundingBox</code> object.
     */
    function AxisAlignedBoundingBox(entity) {
        var _this = _super.call(this, entity) || this;
        _this._x = 0;
        _this._y = 0;
        _this._z = 0;
        _this._width = 0;
        _this._height = 0;
        _this._depth = 0;
        _this._centerX = 0;
        _this._centerY = 0;
        _this._centerZ = 0;
        _this._halfExtentsX = 0;
        _this._halfExtentsY = 0;
        _this._halfExtentsZ = 0;
        return _this;
    }
    /**
     * @inheritDoc
     */
    AxisAlignedBoundingBox.prototype.nullify = function () {
        this._x = this._y = this._z = 0;
        this._width = this._height = this._depth = 0;
        this._centerX = this._centerY = this._centerZ = 0;
        this._halfExtentsX = this._halfExtentsY = this._halfExtentsZ = 0;
    };
    /**
     * @inheritDoc
     */
    AxisAlignedBoundingBox.prototype.isInFrustum = function (planes, numPlanes) {
        if (this._pInvalidated)
            this._pUpdate();
        for (var i = 0; i < numPlanes; ++i) {
            var plane = planes[i];
            var a = plane.a;
            var b = plane.b;
            var c = plane.c;
            var flippedExtentX = a < 0 ? -this._halfExtentsX : this._halfExtentsX;
            var flippedExtentY = b < 0 ? -this._halfExtentsY : this._halfExtentsY;
            var flippedExtentZ = c < 0 ? -this._halfExtentsZ : this._halfExtentsZ;
            var projDist = a * (this._centerX + flippedExtentX) + b * (this._centerY + flippedExtentY) + c * (this._centerZ + flippedExtentZ) - plane.d;
            if (projDist < 0)
                return false;
        }
        return true;
    };
    AxisAlignedBoundingBox.prototype.rayIntersection = function (position, direction, targetNormal) {
        if (this._pInvalidated)
            this._pUpdate();
        return this._box.rayIntersection(position, direction, targetNormal);
    };
    AxisAlignedBoundingBox.prototype.classifyToPlane = function (plane) {
        var a = plane.a;
        var b = plane.b;
        var c = plane.c;
        var centerDistance = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;
        if (a < 0)
            a = -a;
        if (b < 0)
            b = -b;
        if (c < 0)
            c = -c;
        var boundOffset = a * this._halfExtentsX + b * this._halfExtentsY + c * this._halfExtentsZ;
        return centerDistance > boundOffset ? _awayjs_core.PlaneClassification.FRONT : centerDistance < -boundOffset ? _awayjs_core.PlaneClassification.BACK : _awayjs_core.PlaneClassification.INTERSECT;
    };
    AxisAlignedBoundingBox.prototype._pUpdate = function () {
        _super.prototype._pUpdate.call(this);
        this._box = this._entity.getBox();
        var matrix = this._entity.transform.concatenatedMatrix3D;
        var hx = this._box.width / 2;
        var hy = this._box.height / 2;
        var hz = this._box.depth / 2;
        var cx = this._box.x + hx;
        var cy = this._box.y + hy;
        var cz = this._box.z + hz;
        var raw = matrix._rawData;
        var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
        var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
        var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
        this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
        this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
        this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
        this._halfExtentsX = Math.abs(hx * m11 + hy * m12 + hz * m13);
        this._halfExtentsY = Math.abs(hx * m21 + hy * m22 + hz * m23);
        this._halfExtentsZ = Math.abs(hx * m31 + hy * m32 + hz * m33);
        if (this._prefab) {
            this._prefab.width = this._box.width;
            this._prefab.height = this._box.height;
            this._prefab.depth = this._box.depth;
            this._pBoundsPrimitive.transform.matrix3D = matrix;
            this._pBoundsPrimitive.registrationPoint = new _awayjs_core.Vector3D(-cx * this._pBoundsPrimitive.transform.scale.x, -cy * this._pBoundsPrimitive.transform.scale.y, -cz * this._pBoundsPrimitive.transform.scale.z);
        }
        this._width = this._halfExtentsX * 2;
        this._height = this._halfExtentsY * 2;
        this._depth = this._halfExtentsZ * 2;
        this._x = this._centerX - this._halfExtentsX;
        this._y = this._centerY - this._halfExtentsY;
        this._z = this._centerZ - this._halfExtentsZ;
    };
    AxisAlignedBoundingBox.prototype._pCreateBoundsPrimitive = function () {
        this._prefab = new PrimitiveCubePrefab(null, _awayjs_graphics.ElementsType.LINE);
        return this._prefab.getNewObject();
    };
    return AxisAlignedBoundingBox;
}(BoundingVolumeBase));

/**
 * AxisAlignedBoundingBox represents a bounding box volume that has its planes aligned to the local coordinate axes of the bounded object.
 * This is useful for most meshes.
 */
var AxisAlignedBoundingBox2D = (function (_super) {
    __extends(AxisAlignedBoundingBox2D, _super);
    /**
     * Creates a new <code>AxisAlignedBoundingBox</code> object.
     */
    function AxisAlignedBoundingBox2D(entity) {
        return _super.call(this, entity) || this;
    }
    AxisAlignedBoundingBox2D.prototype.rayIntersection = function (position, direction, targetNormal) {
        if (this._pInvalidated)
            this._pUpdate();
        var halfExtentsX = this._box.width / 2;
        var halfExtentsY = this._box.height / 2;
        var centerX = this._box.x + halfExtentsX;
        var centerY = this._box.y + halfExtentsY;
        var px = position.x - centerX;
        var py = position.y - centerY;
        var pz = position.z;
        var vx = direction.x;
        var vy = direction.y;
        var vz = direction.z;
        var ix;
        var iy;
        var intersects;
        var rayEntryDistance;
        if (!intersects && vz < 0) {
            rayEntryDistance = -pz / vz;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iy = py + rayEntryDistance * vy;
                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
                    targetNormal.x = 0;
                    targetNormal.y = 0;
                    targetNormal.z = 1;
                    intersects = true;
                }
            }
        }
        if (!intersects && vz > 0) {
            rayEntryDistance = -pz / vz;
            if (rayEntryDistance > 0) {
                ix = px + rayEntryDistance * vx;
                iy = py + rayEntryDistance * vy;
                if (iy > -halfExtentsY && iy < halfExtentsY && ix > -halfExtentsX && ix < halfExtentsX) {
                    targetNormal.x = 0;
                    targetNormal.y = 0;
                    targetNormal.z = -1;
                    intersects = true;
                }
            }
        }
        return intersects ? rayEntryDistance : -1;
    };
    return AxisAlignedBoundingBox2D;
}(AxisAlignedBoundingBox));

/**
 * A UV Sphere primitive sprite.
 */
var PrimitiveSpherePrefab = (function (_super) {
    __extends(PrimitiveSpherePrefab, _super);
    /**
     * Creates a new Sphere object.
     *
     * @param radius The radius of the sphere.
     * @param segmentsW Defines the number of horizontal segments that make up the sphere.
     * @param segmentsH Defines the number of vertical segments that make up the sphere.
     * @param yUp Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
     */
    function PrimitiveSpherePrefab(material, elementsType, radius, segmentsW, segmentsH, yUp) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (radius === void 0) { radius = 50; }
        if (segmentsW === void 0) { segmentsW = 16; }
        if (segmentsH === void 0) { segmentsH = 12; }
        if (yUp === void 0) { yUp = true; }
        var _this = _super.call(this, material, elementsType) || this;
        _this._radius = radius;
        _this._segmentsW = segmentsW;
        _this._segmentsH = segmentsH;
        _this._yUp = yUp;
        return _this;
    }
    Object.defineProperty(PrimitiveSpherePrefab.prototype, "radius", {
        /**
         * The radius of the sphere.
         */
        get: function () {
            return this._radius;
        },
        set: function (value) {
            this._radius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveSpherePrefab.prototype, "segmentsW", {
        /**
         * Defines the number of horizontal segments that make up the sphere. Defaults to 16.
         */
        get: function () {
            return this._segmentsW;
        },
        set: function (value) {
            this._segmentsW = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveSpherePrefab.prototype, "segmentsH", {
        /**
         * Defines the number of vertical segments that make up the sphere. Defaults to 12.
         */
        get: function () {
            return this._segmentsH;
        },
        set: function (value) {
            this._segmentsH = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveSpherePrefab.prototype, "yUp", {
        /**
         * Defines whether the sphere poles should lay on the Y-axis (true) or on the Z-axis (false).
         */
        get: function () {
            return this._yUp;
        },
        set: function (value) {
            this._yUp = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    PrimitiveSpherePrefab.prototype._pBuildGraphics = function (target, elementsType) {
        var indices;
        var positions;
        var normals;
        var tangents;
        var stride;
        var i;
        var j;
        var vidx, fidx; // indices
        var comp1;
        var comp2;
        var numVertices;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
            if (numVertices == triangleGraphics.numVertices && triangleGraphics.indices != null) {
                triangleGraphics.invalidateIndices();
                triangleGraphics.invalidateVertices(triangleGraphics.positions);
                triangleGraphics.invalidateVertices(triangleGraphics.normals);
                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
            }
            else {
                triangleGraphics.setIndices(new Uint16Array((this._segmentsH - 1) * this._segmentsW * 6));
                triangleGraphics.setPositions(new Float32Array(numVertices * 3));
                triangleGraphics.setNormals(new Float32Array(numVertices * 3));
                triangleGraphics.setTangents(new Float32Array(numVertices * 3));
                this._pInvalidateUVs();
            }
            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
            positions = triangleGraphics.positions.get(numVertices);
            normals = triangleGraphics.normals.get(numVertices);
            tangents = triangleGraphics.tangents.get(numVertices);
            stride = triangleGraphics.concatenatedBuffer.stride / 4;
            vidx = 0;
            fidx = 0;
            var startIndex;
            var t1;
            var t2;
            for (j = 0; j <= this._segmentsH; ++j) {
                startIndex = vidx;
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    if (this._yUp) {
                        t1 = 0;
                        t2 = tanLen > .007 ? x / tanLen : 0;
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        t1 = tanLen > .007 ? x / tanLen : 0;
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this._segmentsW) {
                        positions[vidx] = positions[startIndex];
                        positions[vidx + 1] = positions[startIndex + 1];
                        positions[vidx + 2] = positions[startIndex + 2];
                        normals[vidx] = normals[startIndex] + (x * normLen) * .5;
                        normals[vidx + 1] = normals[startIndex + 1] + (comp1 * normLen) * .5;
                        normals[vidx + 2] = normals[startIndex + 2] + (comp2 * normLen) * .5;
                        tangents[vidx] = tanLen > .007 ? -y / tanLen : 1;
                        tangents[vidx + 1] = t1;
                        tangents[vidx + 2] = t2;
                    }
                    else {
                        positions[vidx] = x;
                        positions[vidx + 1] = comp1;
                        positions[vidx + 2] = comp2;
                        normals[vidx] = x * normLen;
                        normals[vidx + 1] = comp1 * normLen;
                        normals[vidx + 2] = comp2 * normLen;
                        tangents[vidx] = tanLen > .007 ? -y / tanLen : 1;
                        tangents[vidx + 1] = t1;
                        tangents[vidx + 2] = t2;
                    }
                    if (i > 0 && j > 0) {
                        var a = (this._segmentsW + 1) * j + i;
                        var b = (this._segmentsW + 1) * j + i - 1;
                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                        var d = (this._segmentsW + 1) * (j - 1) + i;
                        if (j == this._segmentsH) {
                            positions[vidx] = positions[startIndex];
                            positions[vidx + 1] = positions[startIndex + 1];
                            positions[vidx + 2] = positions[startIndex + 2];
                            indices[fidx++] = a;
                            indices[fidx++] = c;
                            indices[fidx++] = d;
                        }
                        else if (j == 1) {
                            indices[fidx++] = a;
                            indices[fidx++] = b;
                            indices[fidx++] = c;
                        }
                        else {
                            indices[fidx++] = a;
                            indices[fidx++] = b;
                            indices[fidx++] = c;
                            indices[fidx++] = a;
                            indices[fidx++] = c;
                            indices[fidx++] = d;
                        }
                    }
                    vidx += stride;
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
            var lineGraphics = target;
            var numSegments = this._segmentsH * this._segmentsW * 2 + this._segmentsW;
            var positions = new Float32Array(numSegments * 6);
            var thickness = new Float32Array(numSegments);
            vidx = 0;
            fidx = 0;
            for (j = 0; j <= this._segmentsH; ++j) {
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var y = ringradius * Math.sin(verangle);
                    if (this._yUp) {
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i > 0) {
                        //horizonal lines
                        positions[vidx++] = x;
                        positions[vidx++] = comp1;
                        positions[vidx++] = comp2;
                        thickness[fidx++] = 1;
                        //vertical lines
                        if (j > 0) {
                            var addx = (j == 1) ? 3 - (6 * (this._segmentsW - i) + 12 * i) : 3 - this._segmentsW * 12;
                            positions[vidx] = positions[vidx++ + addx];
                            positions[vidx] = positions[vidx++ + addx];
                            positions[vidx] = positions[vidx++ + addx];
                            positions[vidx++] = x;
                            positions[vidx++] = comp1;
                            positions[vidx++] = comp2;
                            thickness[fidx++] = 1;
                        }
                    }
                    //horizonal lines
                    if (i < this._segmentsW) {
                        positions[vidx++] = x;
                        positions[vidx++] = comp1;
                        positions[vidx++] = comp2;
                    }
                }
            }
            // build real data from raw data
            lineGraphics.setPositions(positions);
            lineGraphics.setThickness(thickness);
        }
    };
    /**
     * @inheritDoc
     */
    PrimitiveSpherePrefab.prototype._pBuildUVs = function (target, elementsType) {
        var i, j;
        var numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
        var uvs;
        var stride;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
            var triangleGraphics = target;
            if (triangleGraphics.uvs && numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
            }
            else {
                triangleGraphics.setUVs(new Float32Array(numVertices * 2));
            }
            uvs = triangleGraphics.uvs.get(numVertices);
            stride = triangleGraphics.uvs.stride;
            var index = 0;
            for (j = 0; j <= this._segmentsH; ++j) {
                for (i = 0; i <= this._segmentsW; ++i) {
                    uvs[index] = (i / this._segmentsW) * this._scaleU;
                    uvs[index + 1] = (j / this._segmentsH) * this._scaleV;
                    index += stride;
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    return PrimitiveSpherePrefab;
}(PrimitivePrefabBase));

var BoundingSphere = (function (_super) {
    __extends(BoundingSphere, _super);
    function BoundingSphere(entity) {
        var _this = _super.call(this, entity) || this;
        _this._radius = 0;
        _this._centerX = 0;
        _this._centerY = 0;
        _this._centerZ = 0;
        return _this;
    }
    BoundingSphere.prototype.nullify = function () {
        this._centerX = this._centerY = this._centerZ = 0;
        this._radius = 0;
    };
    BoundingSphere.prototype.isInFrustum = function (planes, numPlanes) {
        if (this._pInvalidated)
            this._pUpdate();
        for (var i = 0; i < numPlanes; ++i) {
            var plane = planes[i];
            var flippedExtentX = plane.a < 0 ? -this._radius : this._radius;
            var flippedExtentY = plane.b < 0 ? -this._radius : this._radius;
            var flippedExtentZ = plane.c < 0 ? -this._radius : this._radius;
            var projDist = plane.a * (this._centerX + flippedExtentX) + plane.b * (this._centerY + flippedExtentY) + plane.c * (this._centerZ + flippedExtentZ) - plane.d;
            if (projDist < 0) {
                return false;
            }
        }
        return true;
    };
    BoundingSphere.prototype.rayIntersection = function (position, direction, targetNormal) {
        if (this._pInvalidated)
            this._pUpdate();
        return this._sphere.rayIntersection(position, direction, targetNormal);
    };
    //@override
    BoundingSphere.prototype.classifyToPlane = function (plane) {
        var a = plane.a;
        var b = plane.b;
        var c = plane.c;
        var dd = a * this._centerX + b * this._centerY + c * this._centerZ - plane.d;
        if (a < 0)
            a = -a;
        if (b < 0)
            b = -b;
        if (c < 0)
            c = -c;
        var rr = (a + b + c) * this._radius;
        return dd > rr ? _awayjs_core.PlaneClassification.FRONT : dd < -rr ? _awayjs_core.PlaneClassification.BACK : _awayjs_core.PlaneClassification.INTERSECT;
    };
    BoundingSphere.prototype._pUpdate = function () {
        _super.prototype._pUpdate.call(this);
        this._sphere = this._entity.getSphere();
        var matrix = this._entity.transform.concatenatedMatrix3D;
        var cx = this._sphere.x;
        var cy = this._sphere.y;
        var cz = this._sphere.z;
        var r = this._sphere.radius;
        var raw = matrix._rawData;
        var m11 = raw[0], m12 = raw[4], m13 = raw[8], m14 = raw[12];
        var m21 = raw[1], m22 = raw[5], m23 = raw[9], m24 = raw[13];
        var m31 = raw[2], m32 = raw[6], m33 = raw[10], m34 = raw[14];
        this._centerX = cx * m11 + cy * m12 + cz * m13 + m14;
        this._centerY = cx * m21 + cy * m22 + cz * m23 + m24;
        this._centerZ = cx * m31 + cy * m32 + cz * m33 + m34;
        var rx = m11 + m12 + m13;
        var ry = m21 + m22 + m23;
        var rz = m31 + m32 + m33;
        this._radius = r * Math.sqrt((rx * rx + ry * ry + rz * rz) / 3);
        if (this._prefab) {
            this._prefab.radius = r;
            this._pBoundsPrimitive.x = cx;
            this._pBoundsPrimitive.y = cy;
            this._pBoundsPrimitive.z = cz;
            this._pBoundsPrimitive.transform.matrix3D = matrix;
        }
    };
    BoundingSphere.prototype._pCreateBoundsPrimitive = function () {
        this._prefab = new PrimitiveSpherePrefab(null, _awayjs_graphics.ElementsType.LINE);
        return this._prefab.getNewObject();
    };
    return BoundingSphere;
}(BoundingVolumeBase));

var NullBounds = (function (_super) {
    __extends(NullBounds, _super);
    function NullBounds(alwaysIn) {
        if (alwaysIn === void 0) { alwaysIn = true; }
        var _this = _super.call(this, null) || this;
        _this._alwaysIn = alwaysIn;
        return _this;
    }
    //@override
    NullBounds.prototype.clone = function () {
        return new NullBounds(this._alwaysIn);
    };
    //@override
    NullBounds.prototype.isInFrustum = function (planes, numPlanes) {
        return this._alwaysIn;
    };
    NullBounds.prototype.classifyToPlane = function (plane) {
        return _awayjs_core.PlaneClassification.INTERSECT;
    };
    return NullBounds;
}(BoundingVolumeBase));

var ControllerBase = (function () {
    function ControllerBase(targetObject) {
        if (targetObject === void 0) { targetObject = null; }
        this._pAutoUpdate = true;
        this.targetObject = targetObject;
    }
    ControllerBase.prototype.pNotifyUpdate = function () {
        if (this._pTargetObject)
            this._pTargetObject.invalidatePartitionBounds();
    };
    Object.defineProperty(ControllerBase.prototype, "targetObject", {
        get: function () {
            return this._pTargetObject;
        },
        set: function (val) {
            if (this._pTargetObject == val)
                return;
            if (this._pTargetObject && this._pAutoUpdate)
                this._pTargetObject._iController = null;
            this._pTargetObject = val;
            if (this._pTargetObject && this._pAutoUpdate)
                this._pTargetObject._iController = this;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ControllerBase.prototype, "autoUpdate", {
        get: function () {
            return this._pAutoUpdate;
        },
        set: function (val) {
            if (this._pAutoUpdate == val)
                return;
            this._pAutoUpdate = val;
            if (this._pTargetObject) {
                if (this._pAutoUpdate)
                    this._pTargetObject._iController = this;
                else
                    this._pTargetObject._iController = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    ControllerBase.prototype.update = function (interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        throw new _awayjs_core.AbstractMethodError();
    };
    ControllerBase.prototype.updateController = function () {
        if (this._pControllerDirty && this._pAutoUpdate) {
            this._pControllerDirty = false;
            this.pNotifyUpdate();
        }
    };
    return ControllerBase;
}());

/**
 * Extended camera used to hover round a specified target object.
 *
 * @see    away3d.containers.View3D
 */
var FirstPersonController = (function (_super) {
    __extends(FirstPersonController, _super);
    /**
     * Creates a new <code>HoverController</code> object.
     */
    function FirstPersonController(targetObject, panAngle, tiltAngle, minTiltAngle, maxTiltAngle, steps, wrapPanAngle) {
        if (targetObject === void 0) { targetObject = null; }
        if (panAngle === void 0) { panAngle = 0; }
        if (tiltAngle === void 0) { tiltAngle = 90; }
        if (minTiltAngle === void 0) { minTiltAngle = -90; }
        if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
        if (steps === void 0) { steps = 8; }
        if (wrapPanAngle === void 0) { wrapPanAngle = false; }
        var _this = _super.call(this, targetObject) || this;
        _this._iCurrentPanAngle = 0;
        _this._iCurrentTiltAngle = 90;
        _this._panAngle = 0;
        _this._tiltAngle = 90;
        _this._minTiltAngle = -90;
        _this._maxTiltAngle = 90;
        _this._steps = 8;
        _this._walkIncrement = 0;
        _this._strafeIncrement = 0;
        _this._wrapPanAngle = false;
        _this.fly = false;
        _this.panAngle = panAngle;
        _this.tiltAngle = tiltAngle;
        _this.minTiltAngle = minTiltAngle;
        _this.maxTiltAngle = maxTiltAngle;
        _this.steps = steps;
        _this.wrapPanAngle = wrapPanAngle;
        //values passed in contrustor are applied immediately
        _this._iCurrentPanAngle = _this._panAngle;
        _this._iCurrentTiltAngle = _this._tiltAngle;
        return _this;
    }
    Object.defineProperty(FirstPersonController.prototype, "steps", {
        /**
         * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
         *
         * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
         *
         * @see    #tiltAngle
         * @see    #panAngle
         */
        get: function () {
            return this._steps;
        },
        set: function (val) {
            val = (val < 1) ? 1 : val;
            if (this._steps == val)
                return;
            this._steps = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirstPersonController.prototype, "panAngle", {
        /**
         * Rotation of the camera in degrees around the y axis. Defaults to 0.
         */
        get: function () {
            return this._panAngle;
        },
        set: function (val) {
            if (this._panAngle == val)
                return;
            this._panAngle = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirstPersonController.prototype, "tiltAngle", {
        /**
         * Elevation angle of the camera in degrees. Defaults to 90.
         */
        get: function () {
            return this._tiltAngle;
        },
        set: function (val) {
            val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
            if (this._tiltAngle == val)
                return;
            this._tiltAngle = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirstPersonController.prototype, "minTiltAngle", {
        /**
         * Minimum bounds for the <code>tiltAngle</code>. Defaults to -90.
         *
         * @see    #tiltAngle
         */
        get: function () {
            return this._minTiltAngle;
        },
        set: function (val) {
            if (this._minTiltAngle == val)
                return;
            this._minTiltAngle = val;
            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirstPersonController.prototype, "maxTiltAngle", {
        /**
         * Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
         *
         * @see    #tiltAngle
         */
        get: function () {
            return this._maxTiltAngle;
        },
        set: function (val) {
            if (this._maxTiltAngle == val)
                return;
            this._maxTiltAngle = val;
            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FirstPersonController.prototype, "wrapPanAngle", {
        /**
         * Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
         */
        get: function () {
            return this._wrapPanAngle;
        },
        set: function (val) {
            if (this._wrapPanAngle == val)
                return;
            this._wrapPanAngle = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the current tilt angle and pan angle values.
     *
     * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.
     *
     * @param interpolate   If the update to a target pan- or tiltAngle is interpolated. Default is true.
     *
     * @see    #tiltAngle
     * @see    #panAngle
     * @see    #steps
     */
    FirstPersonController.prototype.update = function (interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        if (this._tiltAngle != this._iCurrentTiltAngle || this._panAngle != this._iCurrentPanAngle) {
            this._pControllerDirty = true;
            if (this._wrapPanAngle) {
                if (this._panAngle < 0) {
                    this._iCurrentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
                    this._panAngle = this._panAngle % 360 + 360;
                }
                else {
                    this._iCurrentPanAngle += this._panAngle % 360 - this._panAngle;
                    this._panAngle = this._panAngle % 360;
                }
                while (this._panAngle - this._iCurrentPanAngle < -180)
                    this._iCurrentPanAngle -= 360;
                while (this._panAngle - this._iCurrentPanAngle > 180)
                    this._iCurrentPanAngle += 360;
            }
            if (interpolate) {
                this._iCurrentTiltAngle += (this._tiltAngle - this._iCurrentTiltAngle) / (this.steps + 1);
                this._iCurrentPanAngle += (this._panAngle - this._iCurrentPanAngle) / (this.steps + 1);
            }
            else {
                this._iCurrentTiltAngle = this._tiltAngle;
                this._iCurrentPanAngle = this._panAngle;
            }
            //snap coords if angle differences are close
            if ((Math.abs(this.tiltAngle - this._iCurrentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._iCurrentPanAngle) < 0.01)) {
                this._iCurrentTiltAngle = this._tiltAngle;
                this._iCurrentPanAngle = this._panAngle;
            }
        }
        this.targetObject.rotationX = this._iCurrentTiltAngle;
        this.targetObject.rotationY = this._iCurrentPanAngle;
        if (this._walkIncrement) {
            if (this.fly) {
                this.targetObject.transform.moveForward(this._walkIncrement);
            }
            else {
                this.targetObject.x += this._walkIncrement * Math.sin(this._panAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS);
                this.targetObject.z += this._walkIncrement * Math.cos(this._panAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS);
            }
            this._walkIncrement = 0;
        }
        if (this._strafeIncrement) {
            this.targetObject.transform.moveRight(this._strafeIncrement);
            this._strafeIncrement = 0;
        }
    };
    FirstPersonController.prototype.incrementWalk = function (val) {
        if (val == 0)
            return;
        this._walkIncrement += val;
        this.pNotifyUpdate();
    };
    FirstPersonController.prototype.incrementStrafe = function (val) {
        if (val == 0)
            return;
        this._strafeIncrement += val;
        this.pNotifyUpdate();
    };
    return FirstPersonController;
}(ControllerBase));

var LookAtController = (function (_super) {
    __extends(LookAtController, _super);
    function LookAtController(targetObject, lookAtObject) {
        if (targetObject === void 0) { targetObject = null; }
        if (lookAtObject === void 0) { lookAtObject = null; }
        var _this = _super.call(this, targetObject) || this;
        _this._pOrigin = new _awayjs_core.Vector3D(0.0, 0.0, 0.0);
        _this._onLookAtObjectChangedDelegate = function (event) { return _this.onLookAtObjectChanged(event); };
        if (lookAtObject)
            _this.lookAtObject = lookAtObject;
        else
            _this.lookAtPosition = new _awayjs_core.Vector3D();
        return _this;
    }
    Object.defineProperty(LookAtController.prototype, "lookAtPosition", {
        get: function () {
            return this._pLookAtPosition;
        },
        set: function (val) {
            if (this._pLookAtObject) {
                this._pLookAtObject.removeEventListener(DisplayObjectEvent.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
                this._pLookAtObject = null;
            }
            this._pLookAtPosition = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LookAtController.prototype, "lookAtObject", {
        get: function () {
            return this._pLookAtObject;
        },
        set: function (val) {
            if (this._pLookAtPosition)
                this._pLookAtPosition = null;
            if (this._pLookAtObject == val)
                return;
            if (this._pLookAtObject)
                this._pLookAtObject.removeEventListener(DisplayObjectEvent.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
            this._pLookAtObject = val;
            if (this._pLookAtObject)
                this._pLookAtObject.addEventListener(DisplayObjectEvent.SCENETRANSFORM_CHANGED, this._onLookAtObjectChangedDelegate);
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    //@override
    LookAtController.prototype.update = function (interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        if (this._pTargetObject) {
            if (this._pLookAtPosition)
                this._pTargetObject.lookAt(this._pLookAtPosition);
            else if (this._pLookAtObject)
                this._pTargetObject.lookAt(this._pLookAtObject.scene ? this._pLookAtObject.scenePosition : this._pLookAtObject.transform.position);
        }
    };
    LookAtController.prototype.onLookAtObjectChanged = function (event) {
        this.pNotifyUpdate();
    };
    return LookAtController;
}(ControllerBase));

/**
 * Extended camera used to hover round a specified target object.
 *
 * @see    away.containers.View
 */
var HoverController = (function (_super) {
    __extends(HoverController, _super);
    /**
     * Creates a new <code>HoverController</code> object.
     */
    function HoverController(targetObject, lookAtObject, panAngle, tiltAngle, distance, minTiltAngle, maxTiltAngle, minPanAngle, maxPanAngle, steps, yFactor, wrapPanAngle) {
        if (targetObject === void 0) { targetObject = null; }
        if (lookAtObject === void 0) { lookAtObject = null; }
        if (panAngle === void 0) { panAngle = 0; }
        if (tiltAngle === void 0) { tiltAngle = 90; }
        if (distance === void 0) { distance = 1000; }
        if (minTiltAngle === void 0) { minTiltAngle = -90; }
        if (maxTiltAngle === void 0) { maxTiltAngle = 90; }
        if (minPanAngle === void 0) { minPanAngle = null; }
        if (maxPanAngle === void 0) { maxPanAngle = null; }
        if (steps === void 0) { steps = 8; }
        if (yFactor === void 0) { yFactor = 2; }
        if (wrapPanAngle === void 0) { wrapPanAngle = false; }
        var _this = _super.call(this, targetObject, lookAtObject) || this;
        _this._iCurrentPanAngle = 0;
        _this._iCurrentTiltAngle = 90;
        _this._panAngle = 0;
        _this._tiltAngle = 90;
        _this._distance = 1000;
        _this._minPanAngle = -Infinity;
        _this._maxPanAngle = Infinity;
        _this._minTiltAngle = -90;
        _this._maxTiltAngle = 90;
        _this._steps = 8;
        _this._yFactor = 2;
        _this._wrapPanAngle = false;
        _this._upAxis = new _awayjs_core.Vector3D();
        _this.distance = distance;
        _this.panAngle = panAngle;
        _this.tiltAngle = tiltAngle;
        _this.minPanAngle = (minPanAngle != null) ? minPanAngle : -Infinity;
        _this.maxPanAngle = (maxPanAngle != null) ? maxPanAngle : Infinity;
        _this.minTiltAngle = minTiltAngle;
        _this.maxTiltAngle = maxTiltAngle;
        _this.steps = steps;
        _this.yFactor = yFactor;
        _this.wrapPanAngle = wrapPanAngle;
        //values passed in contrustor are applied immediately
        _this._iCurrentPanAngle = _this._panAngle;
        _this._iCurrentTiltAngle = _this._tiltAngle;
        return _this;
    }
    Object.defineProperty(HoverController.prototype, "steps", {
        /**
         * Fractional step taken each time the <code>hover()</code> method is called. Defaults to 8.
         *
         * Affects the speed at which the <code>tiltAngle</code> and <code>panAngle</code> resolve to their targets.
         *
         * @see    #tiltAngle
         * @see    #panAngle
         */
        get: function () {
            return this._steps;
        },
        set: function (val) {
            val = (val < 1) ? 1 : val;
            if (this._steps == val)
                return;
            this._steps = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "panAngle", {
        /**
         * Rotation of the camera in degrees around the y axis. Defaults to 0.
         */
        get: function () {
            return this._panAngle;
        },
        set: function (val) {
            val = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, val));
            if (this._panAngle == val)
                return;
            this._panAngle = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "tiltAngle", {
        /**
         * Elevation angle of the camera in degrees. Defaults to 90.
         */
        get: function () {
            return this._tiltAngle;
        },
        set: function (val) {
            val = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, val));
            if (this._tiltAngle == val)
                return;
            this._tiltAngle = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "distance", {
        /**
         * Distance between the camera and the specified target. Defaults to 1000.
         */
        get: function () {
            return this._distance;
        },
        set: function (val) {
            if (this._distance == val)
                return;
            this._distance = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "minPanAngle", {
        /**
         * Minimum bounds for the <code>panAngle</code>. Defaults to -Infinity.
         *
         * @see    #panAngle
         */
        get: function () {
            return this._minPanAngle;
        },
        set: function (val) {
            if (this._minPanAngle == val)
                return;
            this._minPanAngle = val;
            this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "maxPanAngle", {
        /**
         * Maximum bounds for the <code>panAngle</code>. Defaults to Infinity.
         *
         * @see    #panAngle
         */
        get: function () {
            return this._maxPanAngle;
        },
        set: function (val) {
            if (this._maxPanAngle == val)
                return;
            this._maxPanAngle = val;
            this.panAngle = Math.max(this._minPanAngle, Math.min(this._maxPanAngle, this._panAngle));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "minTiltAngle", {
        /**
         * Minimum bounds for the <code>tiltAngle</code>. Defaults to -90.
         *
         * @see    #tiltAngle
         */
        get: function () {
            return this._minTiltAngle;
        },
        set: function (val) {
            if (this._minTiltAngle == val)
                return;
            this._minTiltAngle = val;
            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "maxTiltAngle", {
        /**
         * Maximum bounds for the <code>tiltAngle</code>. Defaults to 90.
         *
         * @see    #tiltAngle
         */
        get: function () {
            return this._maxTiltAngle;
        },
        set: function (val) {
            if (this._maxTiltAngle == val)
                return;
            this._maxTiltAngle = val;
            this.tiltAngle = Math.max(this._minTiltAngle, Math.min(this._maxTiltAngle, this._tiltAngle));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "yFactor", {
        /**
         * Fractional difference in distance between the horizontal camera orientation and vertical camera orientation. Defaults to 2.
         *
         * @see    #distance
         */
        get: function () {
            return this._yFactor;
        },
        set: function (val) {
            if (this._yFactor == val)
                return;
            this._yFactor = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(HoverController.prototype, "wrapPanAngle", {
        /**
         * Defines whether the value of the pan angle wraps when over 360 degrees or under 0 degrees. Defaults to false.
         */
        get: function () {
            return this._wrapPanAngle;
        },
        set: function (val) {
            if (this._wrapPanAngle == val)
                return;
            this._wrapPanAngle = val;
            this.pNotifyUpdate();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the current tilt angle and pan angle values.
     *
     * Values are calculated using the defined <code>tiltAngle</code>, <code>panAngle</code> and <code>steps</code> variables.
     *
     * @param interpolate   If the update to a target pan- or tiltAngle is interpolated. Default is true.
     *
     * @see    #tiltAngle
     * @see    #panAngle
     * @see    #steps
     */
    HoverController.prototype.update = function (interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        if (this._tiltAngle != this._iCurrentTiltAngle || this._panAngle != this._iCurrentPanAngle) {
            this._pControllerDirty = true;
            if (this._wrapPanAngle) {
                if (this._panAngle < 0) {
                    this._iCurrentPanAngle += this._panAngle % 360 + 360 - this._panAngle;
                    this._panAngle = this._panAngle % 360 + 360;
                }
                else {
                    this._iCurrentPanAngle += this._panAngle % 360 - this._panAngle;
                    this._panAngle = this._panAngle % 360;
                }
                while (this._panAngle - this._iCurrentPanAngle < -180)
                    this._iCurrentPanAngle -= 360;
                while (this._panAngle - this._iCurrentPanAngle > 180)
                    this._iCurrentPanAngle += 360;
            }
            if (interpolate) {
                this._iCurrentTiltAngle += (this._tiltAngle - this._iCurrentTiltAngle) / (this.steps + 1);
                this._iCurrentPanAngle += (this._panAngle - this._iCurrentPanAngle) / (this.steps + 1);
            }
            else {
                this._iCurrentPanAngle = this._panAngle;
                this._iCurrentTiltAngle = this._tiltAngle;
            }
            //snap coords if angle differences are close
            if ((Math.abs(this.tiltAngle - this._iCurrentTiltAngle) < 0.01) && (Math.abs(this._panAngle - this._iCurrentPanAngle) < 0.01)) {
                this._iCurrentTiltAngle = this._tiltAngle;
                this._iCurrentPanAngle = this._panAngle;
            }
        }
        var pos = (this.lookAtObject) ? this.lookAtObject.transform.position : (this.lookAtPosition) ? this.lookAtPosition : this._pOrigin;
        this.targetObject.x = pos.x + this.distance * Math.sin(this._iCurrentPanAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS);
        this.targetObject.y = pos.y + this.distance * Math.sin(this._iCurrentTiltAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS) * this.yFactor;
        this.targetObject.z = pos.z + this.distance * Math.cos(this._iCurrentPanAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS) * Math.cos(this._iCurrentTiltAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS);
        this._upAxis.x = -Math.sin(this._iCurrentPanAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS) * Math.sin(this._iCurrentTiltAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS);
        this._upAxis.y = Math.cos(this._iCurrentTiltAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS);
        this._upAxis.z = -Math.cos(this._iCurrentPanAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS) * Math.sin(this._iCurrentTiltAngle * _awayjs_core.MathConsts.DEGREES_TO_RADIANS);
        if (this._pTargetObject) {
            if (this._pLookAtPosition)
                this._pTargetObject.lookAt(this._pLookAtPosition, this._upAxis);
            else if (this._pLookAtObject)
                this._pTargetObject.lookAt(this._pLookAtObject.scene ? this._pLookAtObject.scenePosition : this._pLookAtObject.transform.position, this._upAxis);
        }
    };
    return HoverController;
}(LookAtController));

/**
 * Controller used to follow behind an object on the XZ plane, with an optional
 * elevation (tiltAngle).
 *
 * @see    away3d.containers.View3D
 */
var FollowController = (function (_super) {
    __extends(FollowController, _super);
    function FollowController(targetObject, lookAtObject, tiltAngle, distance) {
        if (targetObject === void 0) { targetObject = null; }
        if (lookAtObject === void 0) { lookAtObject = null; }
        if (tiltAngle === void 0) { tiltAngle = 45; }
        if (distance === void 0) { distance = 700; }
        return _super.call(this, targetObject, lookAtObject, 0, tiltAngle, distance) || this;
    }
    FollowController.prototype.update = function (interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        if (!this.lookAtObject)
            return;
        this.panAngle = this._pLookAtObject.rotationY - 180;
        _super.prototype.update.call(this);
    };
    return FollowController;
}(HoverController));

/**
 * Uses spring physics to animate the target object towards a position that is
 * defined as the lookAtTarget object's position plus the vector defined by the
 * positionOffset property.
 */
var SpringController = (function (_super) {
    __extends(SpringController, _super);
    function SpringController(targetObject, lookAtObject, stiffness, mass, damping) {
        if (targetObject === void 0) { targetObject = null; }
        if (lookAtObject === void 0) { lookAtObject = null; }
        if (stiffness === void 0) { stiffness = 1; }
        if (mass === void 0) { mass = 40; }
        if (damping === void 0) { damping = 4; }
        var _this = _super.call(this, targetObject, lookAtObject) || this;
        /**
         * Offset of spring center from target in target object space, ie: Where the camera should ideally be in the target object space.
         */
        _this.positionOffset = new _awayjs_core.Vector3D(0, 500, -1000);
        _this.stiffness = stiffness;
        _this.damping = damping;
        _this.mass = mass;
        _this._velocity = new _awayjs_core.Vector3D();
        _this._dv = new _awayjs_core.Vector3D();
        _this._stretch = new _awayjs_core.Vector3D();
        _this._force = new _awayjs_core.Vector3D();
        _this._acceleration = new _awayjs_core.Vector3D();
        _this._desiredPosition = new _awayjs_core.Vector3D();
        return _this;
    }
    SpringController.prototype.update = function (interpolate) {
        if (interpolate === void 0) { interpolate = true; }
        var offs;
        if (!this._pLookAtObject || !this._pTargetObject)
            return;
        this._pControllerDirty = true;
        offs = this._pLookAtObject.transform.matrix3D.deltaTransformVector(this.positionOffset);
        this._desiredPosition.x = this._pLookAtObject.x + offs.x;
        this._desiredPosition.y = this._pLookAtObject.y + offs.y;
        this._desiredPosition.z = this._pLookAtObject.z + offs.z;
        this._stretch = this._pTargetObject.transform.position.add(this._desiredPosition);
        this._stretch.scaleBy(-this.stiffness);
        this._dv.copyFrom(this._velocity);
        this._dv.scaleBy(this.damping);
        this._force.x = this._stretch.x - this._dv.x;
        this._force.y = this._stretch.y - this._dv.y;
        this._force.z = this._stretch.z - this._dv.z;
        this._acceleration.copyFrom(this._force);
        this._acceleration.scaleBy(1 / this.mass);
        this._velocity.incrementBy(this._acceleration);
        var position = this._pTargetObject.transform.position.add(this._velocity);
        this._pTargetObject.transform.moveTo(position.x, position.y, position.z);
        _super.prototype.update.call(this);
    };
    return SpringController;
}(LookAtController));

/**
 * The Billboard class represents display objects that represent bitmap images.
 * These can be images that you load with the <code>flash.Assets</code> or
 * <code>flash.display.Loader</code> classes, or they can be images that you
 * create with the <code>Billboard()</code> constructor.
 *
 * <p>The <code>Billboard()</code> constructor allows you to create a Billboard
 * object that contains a reference to a Image2D object. After you create a
 * Billboard object, use the <code>addChild()</code> or <code>addChildAt()</code>
 * method of the parent DisplayObjectContainer instance to place the bitmap on
 * the display list.</p>
 *
 * <p>A Billboard object can share its Image2D reference among several Billboard
 * objects, independent of translation or rotation properties. Because you can
 * create multiple Billboard objects that reference the same Image2D object,
 * multiple display objects can use the same complex Image2D object without
 * incurring the memory overhead of a Image2D object for each display
 * object instance.</p>
 *
 * <p>A Image2D object can be drawn to the screen by a Billboard object in one
 * of two ways: by using the default hardware renderer with a single hardware surface,
 * or by using the slower software renderer when 3D acceleration is not available.</p>
 *
 * <p>If you would prefer to perform a batch rendering command, rather than using a
 * single surface for each Billboard object, you can also draw to the screen using the
 * <code>drawTiles()</code> or <code>drawTriangles()</code> methods which are
 * available to <code>flash.display.Tilesheet</code> and <code>flash.display.Graphics
 * objects.</code></p>
 *
 * <p><b>Note:</b> The Billboard class is not a subclass of the InteractiveObject
 * class, so it cannot dispatch mouse events. However, you can use the
 * <code>addEventListener()</code> method of the display object container that
 * contains the Billboard object.</p>
 */
// todo: billboard needed to extend on DisplayObjectContainer in order for as3web/away3d adapters to compile without errors
// (in away3d Sprite3D extends on ObjectContainer3D)
var Billboard = (function (_super) {
    __extends(Billboard, _super);
    function Billboard(material, pixelSnapping, smoothing) {
        if (pixelSnapping === void 0) { pixelSnapping = "auto"; }
        if (smoothing === void 0) { smoothing = false; }
        var _this = _super.call(this) || this;
        _this._pIsEntity = true;
        _this._onInvalidateTextureDelegate = function (event) { return _this._onInvalidateTexture(event); };
        _this.material = material;
        _this._updateDimensions();
        //default bounds type
        _this._boundsType = BoundsType.AXIS_ALIGNED_BOX;
        return _this;
    }
    Object.defineProperty(Billboard.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return Billboard.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Billboard.prototype, "billboardRect", {
        /**
         *
         */
        get: function () {
            return this._billboardRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Billboard.prototype, "billboardHeight", {
        /**
         *
         */
        get: function () {
            return this._billboardHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Billboard.prototype, "billboardWidth", {
        /**
         *
         */
        get: function () {
            return this._billboardWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Billboard.prototype, "material", {
        /**
         *
         */
        get: function () {
            return this._material;
        },
        set: function (value) {
            if (value == this._material)
                return;
            if (this._material) {
                this._material.iRemoveOwner(this);
                this._material.removeEventListener(_awayjs_graphics.MaterialEvent.INVALIDATE_TEXTURE, this._onInvalidateTextureDelegate);
            }
            this._material = value;
            if (this._material) {
                this._material.iAddOwner(this);
                this._material.addEventListener(_awayjs_graphics.MaterialEvent.INVALIDATE_TEXTURE, this._onInvalidateTextureDelegate);
            }
            this._updateDimensions();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     */
    Billboard.prototype._pUpdateBoxBounds = function () {
        _super.prototype._pUpdateBoxBounds.call(this);
        this._pBoxBounds.x = 0;
        this._pBoxBounds.y = 0;
        this._pBoxBounds.z = 0;
        this._pBoxBounds.width = this._billboardRect.width;
        this._pBoxBounds.height = this._billboardRect.height;
        this._pBoxBounds.depth = 0;
    };
    Billboard.prototype.clone = function () {
        var newInstance = new Billboard(this.material);
        this.copyTo(newInstance);
        return newInstance;
    };
    Billboard.prototype._acceptTraverser = function (traverser) {
        traverser[Billboard.traverseName](this);
    };
    Billboard.prototype._updateDimensions = function () {
        var texture = this.material.getTextureAt(0);
        var image = texture ? ((this._style ? this._style.getImageAt(texture) : null) || (this.material.style ? this.material.style.getImageAt(texture) : null) || texture.getImageAt(0)) : null;
        if (image) {
            var sampler = ((this._style ? this._style.getSamplerAt(texture) : null) || (this.material.style ? this.material.style.getSamplerAt(texture) : null) || texture.getSamplerAt(0) || _awayjs_graphics.DefaultMaterialManager.getDefaultSampler());
            if (sampler.imageRect) {
                this._billboardWidth = sampler.imageRect.width * image.width;
                this._billboardHeight = sampler.imageRect.height * image.height;
            }
            else {
                this._billboardWidth = image.rect.width;
                this._billboardHeight = image.rect.height;
            }
            this._billboardRect = sampler.frameRect || new _awayjs_core.Rectangle(0, 0, this._billboardWidth, this._billboardHeight);
        }
        else {
            this._billboardWidth = 1;
            this._billboardHeight = 1;
            this._billboardRect = new _awayjs_core.Rectangle(0, 0, 1, 1);
        }
        this._pInvalidateBounds();
        this.invalidateElements();
        if (this._width != null)
            this._setScaleX(this._width / this._billboardRect.width);
        if (this._height != null)
            this._setScaleY(this._height / this._billboardRect.height);
    };
    Billboard.prototype.invalidateElements = function () {
        this.dispatchEvent(new _awayjs_graphics.RenderableEvent(_awayjs_graphics.RenderableEvent.INVALIDATE_ELEMENTS, this));
    };
    Billboard.prototype.invalidateMaterial = function () {
        this.dispatchEvent(new _awayjs_graphics.RenderableEvent(_awayjs_graphics.RenderableEvent.INVALIDATE_MATERIAL, this));
    };
    Billboard.prototype._onInvalidateProperties = function (event) {
        if (event === void 0) { event = null; }
        this.invalidateMaterial();
        this._updateDimensions();
    };
    /**
     * @private
     */
    Billboard.prototype._onInvalidateTexture = function (event) {
        this._updateDimensions();
    };
    return Billboard;
}(DisplayObjectContainer));
Billboard.traverseName = _awayjs_graphics.TraverserBase.addRenderableName("applyBillboard");
Billboard.assetType = "[asset Billboard]";

/**
 * @class away.events.CameraEvent
 */
var CameraEvent = (function (_super) {
    __extends(CameraEvent, _super);
    function CameraEvent(type, camera) {
        var _this = _super.call(this, type) || this;
        _this._camera = camera;
        return _this;
    }
    Object.defineProperty(CameraEvent.prototype, "camera", {
        get: function () {
            return this._camera;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     * @return An exact duplicate of the current object.
     */
    CameraEvent.prototype.clone = function () {
        return new CameraEvent(this.type, this._camera);
    };
    return CameraEvent;
}(_awayjs_core.EventBase));
CameraEvent.PROJECTION_CHANGED = "projectionChanged";

var Camera = (function (_super) {
    __extends(Camera, _super);
    function Camera(projection) {
        if (projection === void 0) { projection = null; }
        var _this = _super.call(this) || this;
        _this._pIsEntity = true;
        _this._projection = projection || new _awayjs_core.PerspectiveProjection();
        _this._projection.transform = _this._transform;
        _this.z = -1000;
        //default bounds type
        _this._boundsType = BoundsType.NULL;
        return _this;
    }
    Object.defineProperty(Camera.prototype, "assetType", {
        //@override
        get: function () {
            return Camera.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Camera.prototype, "projection", {
        /**
         *
         */
        get: function () {
            return this._projection;
        },
        set: function (value) {
            if (this._projection == value)
                return;
            if (!value)
                throw new Error("Projection cannot be null!");
            this._projection.transform = null;
            this._projection = value;
            this._projection.transform = this._transform;
            this.dispatchEvent(new CameraEvent(CameraEvent.PROJECTION_CHANGED, this));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Calculates the normalised position in screen space of the given scene position.
     *
     * @param point3d the position vector of the scene coordinates to be projected.
     * @return The normalised screen position of the given scene coordinates.
     */
    Camera.prototype.project = function (vector3D) {
        return this._projection.project(vector3D);
    };
    /**
     * Calculates the scene position of the given normalized coordinates in screen space.
     *
     * @param nX The normalised x coordinate in screen space, minus the originX offset of the projection property.
     * @param nY The normalised y coordinate in screen space, minus the originY offset of the projection property.
     * @param sZ The z coordinate in screen space, representing the distance into the screen.
     * @return The scene position of the given screen coordinates.
     */
    Camera.prototype.unproject = function (nX, nY, sZ, target) {
        if (target === void 0) { target = null; }
        return this._projection.unproject(nX, nY, sZ, target);
    };
    return Camera;
}(DisplayObjectContainer));
Camera.traverseName = _awayjs_graphics.TraverserBase.addEntityName("applyCamera");
Camera.assetType = "[asset Camera]";

var ShadowMapperBase = (function (_super) {
    __extends(ShadowMapperBase, _super);
    function ShadowMapperBase() {
        var _this = _super.apply(this, arguments) || this;
        _this._depthMapSize = 2048;
        _this._autoUpdateShadows = true;
        return _this;
    }
    Object.defineProperty(ShadowMapperBase.prototype, "autoUpdateShadows", {
        get: function () {
            return this._autoUpdateShadows;
        },
        set: function (value) {
            this._autoUpdateShadows = value;
        },
        enumerable: true,
        configurable: true
    });
    ShadowMapperBase.prototype.updateShadows = function () {
        this._iShadowsInvalid = true;
    };
    ShadowMapperBase.prototype.iSetDepthMap = function (depthMap) {
        if (this._depthMap && !this._explicitDepthMap)
            this._depthMap.dispose();
        this._depthMap = depthMap;
    };
    Object.defineProperty(ShadowMapperBase.prototype, "light", {
        get: function () {
            return this._light;
        },
        set: function (value) {
            this._light = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowMapperBase.prototype, "depthMap", {
        get: function () {
            if (!this._depthMap)
                this._depthMap = this._createDepthTexture();
            return this._depthMap;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowMapperBase.prototype, "depthMapSize", {
        get: function () {
            return this._depthMapSize;
        },
        set: function (value) {
            if (value == this._depthMapSize)
                return;
            this._setDepthMapSize(value);
        },
        enumerable: true,
        configurable: true
    });
    ShadowMapperBase.prototype.dispose = function () {
        if (this._depthMap && !this._explicitDepthMap)
            this._depthMap.dispose();
        this._depthMap = null;
    };
    ShadowMapperBase.prototype._createDepthTexture = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    ShadowMapperBase.prototype.iRenderDepthMap = function (view, renderer) {
        this._iShadowsInvalid = false;
        this._updateDepthProjection(view.camera.projection);
        if (!this._depthMap)
            this._depthMap = this._createDepthTexture();
        this._drawDepthMap(view, this._depthMap, renderer);
    };
    ShadowMapperBase.prototype._updateDepthProjection = function (projection) {
        throw new _awayjs_core.AbstractMethodError();
    };
    ShadowMapperBase.prototype._drawDepthMap = function (view, target, renderer) {
        throw new _awayjs_core.AbstractMethodError();
    };
    ShadowMapperBase.prototype._setDepthMapSize = function (value) {
        this._depthMapSize = value;
        if (this._explicitDepthMap) {
            throw Error("Cannot set depth map size for the current renderer.");
        }
        else if (this._depthMap) {
            this._depthMap.dispose();
            this._depthMap = null;
        }
    };
    return ShadowMapperBase;
}(_awayjs_core.AssetBase));

var DirectionalShadowMapper = (function (_super) {
    __extends(DirectionalShadowMapper, _super);
    function DirectionalShadowMapper() {
        var _this = _super.call(this) || this;
        _this._lightOffset = 10000;
        _this._snap = 64;
        _this._cullPlanes = [];
        _this._overallDepthProjection = new _awayjs_core.PerspectiveProjection();
        _this._overallDepthProjection.transform = new _awayjs_core.Transform();
        _this._localFrustum = [];
        _this._matrix = new _awayjs_core.Matrix3D();
        return _this;
    }
    Object.defineProperty(DirectionalShadowMapper.prototype, "snap", {
        get: function () {
            return this._snap;
        },
        set: function (value) {
            this._snap = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalShadowMapper.prototype, "lightOffset", {
        get: function () {
            return this._lightOffset;
        },
        set: function (value) {
            this._lightOffset = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalShadowMapper.prototype, "iDepthProjection", {
        //@arcane
        get: function () {
            return this._overallDepthProjection.viewMatrix3D;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalShadowMapper.prototype, "depth", {
        //@arcane
        get: function () {
            return this._maxZ - this._minZ;
        },
        enumerable: true,
        configurable: true
    });
    DirectionalShadowMapper.prototype.iSetDepthMap = function (depthMap) {
        if (this._depthMap == depthMap)
            return;
        _super.prototype.iSetDepthMap.call(this, depthMap);
        if (this._depthMap) {
            this._explicitDepthMap = true;
            this._depthMapSize = depthMap.image2D.rect.width;
        }
        else {
            this._explicitDepthMap = false;
        }
    };
    DirectionalShadowMapper.prototype._createDepthTexture = function () {
        return new _awayjs_graphics.Single2DTexture(new _awayjs_graphics.Image2D(this._depthMapSize, this._depthMapSize));
    };
    //@override
    DirectionalShadowMapper.prototype._drawDepthMap = function (view, target, renderer) {
        renderer.cullPlanes = this._cullPlanes;
        renderer._iRender(this._overallDepthProjection, view, target.image2D);
    };
    /**
     *
     * @param projection
     * @private
     */
    DirectionalShadowMapper.prototype._updateCullPlanes = function (projection) {
        var lightFrustumPlanes = this._overallDepthProjection.frustumPlanes;
        var viewFrustumPlanes = projection.frustumPlanes;
        this._cullPlanes.length = 4;
        this._cullPlanes[0] = lightFrustumPlanes[0];
        this._cullPlanes[1] = lightFrustumPlanes[1];
        this._cullPlanes[2] = lightFrustumPlanes[2];
        this._cullPlanes[3] = lightFrustumPlanes[3];
        var light = this._light;
        var dir = light.sceneDirection;
        var dirX = dir.x;
        var dirY = dir.y;
        var dirZ = dir.z;
        var j = 4;
        for (var i = 0; i < 6; ++i) {
            var plane = viewFrustumPlanes[i];
            if (plane.a * dirX + plane.b * dirY + plane.c * dirZ < 0)
                this._cullPlanes[j++] = plane;
        }
    };
    /**
     *
     * @param projection
     * @private
     */
    DirectionalShadowMapper.prototype._updateDepthProjection = function (projection) {
        this._updateProjectionFromFrustumCorners(projection, projection.frustumCorners, this._matrix);
        this._overallDepthProjection.frustumMatrix3D = this._matrix;
        this._updateCullPlanes(projection);
    };
    /**
     *
     * @param projection
     * @param matrix
     * @private
     */
    DirectionalShadowMapper.prototype._updateProjectionFromFrustumCorners = function (projection, corners, matrix) {
        var dir;
        var x, y, z;
        var minX, minY;
        var maxX, maxY;
        var i;
        var position = projection.transform.concatenatedMatrix3D.position;
        var light = this._light;
        dir = light.sceneDirection;
        this._overallDepthProjection.transform.matrix3D = this._light.transform.concatenatedMatrix3D;
        x = Math.floor((position.x - dir.x * this._lightOffset) / this._snap) * this._snap;
        y = Math.floor((position.y - dir.y * this._lightOffset) / this._snap) * this._snap;
        z = Math.floor((position.z - dir.z * this._lightOffset) / this._snap) * this._snap;
        this._overallDepthProjection.transform.moveTo(x, y, z);
        this._matrix.copyFrom(this._overallDepthProjection.transform.inverseConcatenatedMatrix3D);
        this._matrix.prepend(projection.transform.concatenatedMatrix3D);
        this._matrix.transformVectors(corners, this._localFrustum);
        minX = maxX = this._localFrustum[0];
        minY = maxY = this._localFrustum[1];
        this._maxZ = this._localFrustum[2];
        i = 3;
        while (i < 24) {
            x = this._localFrustum[i];
            y = this._localFrustum[i + 1];
            z = this._localFrustum[i + 2];
            if (x < minX)
                minX = x;
            if (x > maxX)
                maxX = x;
            if (y < minY)
                minY = y;
            if (y > maxY)
                maxY = y;
            if (z > this._maxZ)
                this._maxZ = z;
            i += 3;
        }
        this._minZ = 1;
        var w = maxX - minX;
        var h = maxY - minY;
        var d = 1 / (this._maxZ - this._minZ);
        if (minX < 0)
            minX -= this._snap; // because int() rounds up for < 0
        if (minY < 0)
            minY -= this._snap;
        minX = Math.floor(minX / this._snap) * this._snap;
        minY = Math.floor(minY / this._snap) * this._snap;
        var snap2 = 2 * this._snap;
        w = Math.floor(w / snap2 + 2) * snap2;
        h = Math.floor(h / snap2 + 2) * snap2;
        maxX = minX + w;
        maxY = minY + h;
        w = 1 / w;
        h = 1 / h;
        var raw = matrix._rawData;
        raw[0] = 2 * w;
        raw[5] = 2 * h;
        raw[10] = d;
        raw[12] = -(maxX + minX) * w;
        raw[13] = -(maxY + minY) * h;
        raw[14] = -this._minZ * d;
        raw[15] = 1;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
        matrix.invalidatePosition();
    };
    return DirectionalShadowMapper;
}(ShadowMapperBase));

var LightEvent = (function (_super) {
    __extends(LightEvent, _super);
    function LightEvent(type) {
        return _super.call(this, type) || this;
    }
    //@override
    LightEvent.prototype.clone = function () {
        return new LightEvent(this.type);
    };
    return LightEvent;
}(_awayjs_core.EventBase));
LightEvent.CASTS_SHADOW_CHANGE = "castsShadowChange";

var LightBase = (function (_super) {
    __extends(LightBase, _super);
    function LightBase() {
        var _this = _super.call(this) || this;
        _this._color = 0xffffff;
        _this._colorR = 1;
        _this._colorG = 1;
        _this._colorB = 1;
        _this._ambientColor = 0xffffff;
        _this._ambient = 0;
        _this._iAmbientR = 0;
        _this._iAmbientG = 0;
        _this._iAmbientB = 0;
        _this._specular = 1;
        _this._iSpecularR = 1;
        _this._iSpecularG = 1;
        _this._iSpecularB = 1;
        _this._diffuse = 1;
        _this._iDiffuseR = 1;
        _this._iDiffuseG = 1;
        _this._iDiffuseB = 1;
        _this._shadowsEnabled = false;
        _this.castsShadows = false;
        return _this;
    }
    Object.defineProperty(LightBase.prototype, "shadowsEnabled", {
        get: function () {
            return this._shadowsEnabled;
        },
        set: function (value) {
            if (this._shadowsEnabled == value)
                return;
            this._shadowsEnabled = value;
            if (value) {
                if (this._shadowMapper == null)
                    this._shadowMapper = this.pCreateShadowMapper();
                this._shadowMapper.light = this;
            }
            else {
                this._shadowMapper.dispose();
                this._shadowMapper = null;
            }
            //*/
            this.dispatchEvent(new LightEvent(LightEvent.CASTS_SHADOW_CHANGE));
        },
        enumerable: true,
        configurable: true
    });
    LightBase.prototype.pCreateShadowMapper = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    Object.defineProperty(LightBase.prototype, "specular", {
        get: function () {
            return this._specular;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            this._specular = value;
            this.updateSpecular();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "diffuse", {
        get: function () {
            return this._diffuse;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            this._diffuse = value;
            this.updateDiffuse();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "color", {
        get: function () {
            return this._color;
        },
        set: function (value) {
            this._color = value;
            this._colorR = ((this._color >> 16) & 0xff) / 0xff;
            this._colorG = ((this._color >> 8) & 0xff) / 0xff;
            this._colorB = (this._color & 0xff) / 0xff;
            this.updateDiffuse();
            this.updateSpecular();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "ambient", {
        get: function () {
            return this._ambient;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            this._ambient = value;
            this.updateAmbient();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightBase.prototype, "ambientColor", {
        get: function () {
            return this._ambientColor;
        },
        set: function (value) {
            this._ambientColor = value;
            this.updateAmbient();
        },
        enumerable: true,
        configurable: true
    });
    LightBase.prototype.updateAmbient = function () {
        this._iAmbientR = ((this._ambientColor >> 16) & 0xff) / 0xff * this._ambient;
        this._iAmbientG = ((this._ambientColor >> 8) & 0xff) / 0xff * this._ambient;
        this._iAmbientB = (this._ambientColor & 0xff) / 0xff * this._ambient;
    };
    LightBase.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
        if (target === void 0) { target = null; }
        throw new _awayjs_core.AbstractMethodError();
    };
    LightBase.prototype.updateSpecular = function () {
        this._iSpecularR = this._colorR * this._specular;
        this._iSpecularG = this._colorG * this._specular;
        this._iSpecularB = this._colorB * this._specular;
    };
    LightBase.prototype.updateDiffuse = function () {
        this._iDiffuseR = this._colorR * this._diffuse;
        this._iDiffuseG = this._colorG * this._diffuse;
        this._iDiffuseB = this._colorB * this._diffuse;
    };
    Object.defineProperty(LightBase.prototype, "shadowMapper", {
        get: function () {
            return this._shadowMapper;
        },
        set: function (value) {
            this._shadowMapper = value;
            this._shadowMapper.light = this;
        },
        enumerable: true,
        configurable: true
    });
    return LightBase;
}(DisplayObjectContainer));

var DirectionalLight = (function (_super) {
    __extends(DirectionalLight, _super);
    function DirectionalLight(xDir, yDir, zDir) {
        if (xDir === void 0) { xDir = 0; }
        if (yDir === void 0) { yDir = -1; }
        if (zDir === void 0) { zDir = 1; }
        var _this = _super.call(this) || this;
        _this._pAabbPoints = new Array(24);
        _this._pIsEntity = true;
        _this.direction = new _awayjs_core.Vector3D(xDir, yDir, zDir);
        _this._sceneDirection = new _awayjs_core.Vector3D();
        //default bounds type
        _this._boundsType = BoundsType.NULL;
        return _this;
    }
    Object.defineProperty(DirectionalLight.prototype, "traverseName", {
        get: function () {
            return DirectionalLight.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalLight.prototype, "assetType", {
        get: function () {
            return DirectionalLight.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalLight.prototype, "sceneDirection", {
        get: function () {
            if (this._sceneDirectionDirty)
                this._updateSceneDirection();
            return this._sceneDirection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DirectionalLight.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        set: function (value) {
            this._direction = value;
            if (!this._tmpLookAt)
                this._tmpLookAt = new _awayjs_core.Vector3D();
            this._tmpLookAt.x = this.x + this._direction.x;
            this._tmpLookAt.y = this.y + this._direction.y;
            this._tmpLookAt.z = this.z + this._direction.z;
            this.lookAt(this._tmpLookAt);
        },
        enumerable: true,
        configurable: true
    });
    DirectionalLight.prototype.pInvalidateHierarchicalProperties = function (propDirty) {
        if (_super.prototype.pInvalidateHierarchicalProperties.call(this, propDirty))
            return true;
        if (this._hierarchicalPropsDirty & HierarchicalProperties.SCENE_TRANSFORM)
            this._sceneDirectionDirty = true;
        return false;
    };
    DirectionalLight.prototype._updateSceneDirection = function () {
        this._sceneDirectionDirty = false;
        this.transform.concatenatedMatrix3D.copyColumnTo(2, this._sceneDirection);
        this._sceneDirection.normalize();
    };
    //@override
    DirectionalLight.prototype.pCreateShadowMapper = function () {
        return new DirectionalShadowMapper();
    };
    //override
    DirectionalLight.prototype.iGetObjectProjectionMatrix = function (displayObject, cameraTransform, target) {
        if (target === void 0) { target = null; }
        if (!target)
            target = new _awayjs_core.Matrix3D();
        var m = _awayjs_core.Matrix3D.CALCULATION_MATRIX;
        m.copyFrom(displayObject.getRenderSceneTransform(cameraTransform));
        m.append(this.transform.inverseConcatenatedMatrix3D);
        if (!this._projAABBPoints)
            this._projAABBPoints = [];
        m.transformVectors(this._pAabbPoints, this._projAABBPoints);
        var xMin = Infinity, xMax = -Infinity;
        var yMin = Infinity, yMax = -Infinity;
        var zMin = Infinity, zMax = -Infinity;
        var d;
        for (var i = 0; i < 24;) {
            d = this._projAABBPoints[i++];
            if (d < xMin)
                xMin = d;
            if (d > xMax)
                xMax = d;
            d = this._projAABBPoints[i++];
            if (d < yMin)
                yMin = d;
            if (d > yMax)
                yMax = d;
            d = this._projAABBPoints[i++];
            if (d < zMin)
                zMin = d;
            if (d > zMax)
                zMax = d;
        }
        var invXRange = 1 / (xMax - xMin);
        var invYRange = 1 / (yMax - yMin);
        var invZRange = 1 / (zMax - zMin);
        var targetData = target._rawData;
        targetData[0] = 2 * invXRange;
        targetData[5] = 2 * invYRange;
        targetData[10] = invZRange;
        targetData[12] = -(xMax + xMin) * invXRange;
        targetData[13] = -(yMax + yMin) * invYRange;
        targetData[14] = -zMin * invZRange;
        targetData[1] = targetData[2] = targetData[3] = targetData[4] = targetData[6] = targetData[7] = targetData[8] = targetData[9] = targetData[11] = 0;
        targetData[15] = 1;
        target.prepend(m);
        return target;
    };
    /**
     * //TODO
     *
     * @protected
     */
    DirectionalLight.prototype._pUpdateBoxBounds = function () {
        _super.prototype._pUpdateBoxBounds.call(this);
        //update points
        var minX = this._pBoxBounds.x;
        var minY = this._pBoxBounds.y - this._pBoxBounds.height;
        var minZ = this._pBoxBounds.z;
        var maxX = this._pBoxBounds.x + this._pBoxBounds.width;
        var maxY = this._pBoxBounds.y;
        var maxZ = this._pBoxBounds.z + this._pBoxBounds.depth;
        this._pAabbPoints[0] = minX;
        this._pAabbPoints[1] = minY;
        this._pAabbPoints[2] = minZ;
        this._pAabbPoints[3] = maxX;
        this._pAabbPoints[4] = minY;
        this._pAabbPoints[5] = minZ;
        this._pAabbPoints[6] = minX;
        this._pAabbPoints[7] = maxY;
        this._pAabbPoints[8] = minZ;
        this._pAabbPoints[9] = maxX;
        this._pAabbPoints[10] = maxY;
        this._pAabbPoints[11] = minZ;
        this._pAabbPoints[12] = minX;
        this._pAabbPoints[13] = minY;
        this._pAabbPoints[14] = maxZ;
        this._pAabbPoints[15] = maxX;
        this._pAabbPoints[16] = minY;
        this._pAabbPoints[17] = maxZ;
        this._pAabbPoints[18] = minX;
        this._pAabbPoints[19] = maxY;
        this._pAabbPoints[20] = maxZ;
        this._pAabbPoints[21] = maxX;
        this._pAabbPoints[22] = maxY;
        this._pAabbPoints[23] = maxZ;
    };
    return DirectionalLight;
}(LightBase));
DirectionalLight.traverseName = _awayjs_graphics.TraverserBase.addEntityName("applyDirectionalLight");
DirectionalLight.assetType = "[light DirectionalLight]";

var LightProbe = (function (_super) {
    __extends(LightProbe, _super);
    function LightProbe(diffuseMap, specularMap) {
        if (specularMap === void 0) { specularMap = null; }
        var _this = _super.call(this) || this;
        _this.diffuseSampler = new _awayjs_graphics.SamplerCube();
        _this.specularSampler = new _awayjs_graphics.SamplerCube();
        _this._pIsEntity = true;
        _this.diffuseMap = diffuseMap;
        _this.specularMap = specularMap;
        //default bounds type
        _this._boundsType = BoundsType.NULL;
        return _this;
    }
    Object.defineProperty(LightProbe.prototype, "traverseName", {
        get: function () {
            return LightProbe.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightProbe.prototype, "assetType", {
        get: function () {
            return LightProbe.assetType;
        },
        enumerable: true,
        configurable: true
    });
    //@override
    LightProbe.prototype.iGetObjectProjectionMatrix = function (entity, cameraTransform, target) {
        if (target === void 0) { target = null; }
        throw new _awayjs_core.ErrorBase("Object projection matrices are not supported for LightProbe objects!");
    };
    return LightProbe;
}(LightBase));
LightProbe.traverseName = _awayjs_graphics.TraverserBase.addEntityName("applyLightProbe");
LightProbe.assetType = "[light LightProbe]";

/**
 * A Line Segment primitive.
 */
var LineSegment = (function (_super) {
    __extends(LineSegment, _super);
    /**
     * Create a line segment
     *
     * @param startPosition Start position of the line segment
     * @param endPosition Ending position of the line segment
     * @param thickness Thickness of the line
     */
    function LineSegment(material, startPosition, endPosition, thickness) {
        if (thickness === void 0) { thickness = 1; }
        var _this = _super.call(this) || this;
        _this._pIsEntity = true;
        _this.material = material;
        _this._startPosition = startPosition;
        _this._endPosition = endPosition;
        _this._halfThickness = thickness * 0.5;
        //default bounds type
        _this._boundsType = BoundsType.AXIS_ALIGNED_BOX;
        return _this;
    }
    Object.defineProperty(LineSegment.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return LineSegment.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSegment.prototype, "startPostion", {
        /**
         *
         */
        get: function () {
            return this._startPosition;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSegment.prototype, "startPosition", {
        set: function (value) {
            if (this._startPosition == value)
                return;
            this._startPosition = value;
            this.invalidateElements();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSegment.prototype, "endPosition", {
        /**
         *
         */
        get: function () {
            return this._endPosition;
        },
        set: function (value) {
            if (this._endPosition == value)
                return;
            this._endPosition = value;
            this.invalidateElements();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LineSegment.prototype, "thickness", {
        /**
         *
         */
        get: function () {
            return this._halfThickness * 2;
        },
        set: function (value) {
            if (this._halfThickness == value)
                return;
            this._halfThickness = value * 0.5;
            this.invalidateElements();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @protected
     */
    LineSegment.prototype._pUpdateBoxBounds = function () {
        _super.prototype._pUpdateBoxBounds.call(this);
        this._pBoxBounds.x = Math.min(this._startPosition.x, this._endPosition.x);
        this._pBoxBounds.y = Math.min(this._startPosition.y, this._endPosition.y);
        this._pBoxBounds.z = Math.min(this._startPosition.z, this._endPosition.z);
        this._pBoxBounds.width = Math.abs(this._startPosition.x - this._endPosition.x);
        this._pBoxBounds.height = Math.abs(this._startPosition.y - this._endPosition.y);
        this._pBoxBounds.depth = Math.abs(this._startPosition.z - this._endPosition.z);
    };
    LineSegment.prototype._pUpdateSphereBounds = function () {
        _super.prototype._pUpdateSphereBounds.call(this);
        this._pUpdateBoxBounds();
        var halfWidth = (this._endPosition.x - this._startPosition.x) / 2;
        var halfHeight = (this._endPosition.y - this._startPosition.y) / 2;
        var halfDepth = (this._endPosition.z - this._startPosition.z) / 2;
        this._pSphereBounds.x = this._startPosition.x + halfWidth;
        this._pSphereBounds.y = this._startPosition.y + halfHeight;
        this._pSphereBounds.z = this._startPosition.z + halfDepth;
        this._pSphereBounds.radius = Math.sqrt(halfWidth * halfWidth + halfHeight * halfHeight + halfDepth * halfDepth);
    };
    /**
     * @private
     */
    LineSegment.prototype.invalidateElements = function () {
        this.dispatchEvent(new _awayjs_graphics.RenderableEvent(_awayjs_graphics.RenderableEvent.INVALIDATE_ELEMENTS, this)); //TODO improve performance by only using one geometry for all line segments
    };
    LineSegment.prototype.invalidateMaterial = function () {
        this.dispatchEvent(new _awayjs_graphics.RenderableEvent(_awayjs_graphics.RenderableEvent.INVALIDATE_MATERIAL, this));
    };
    LineSegment.prototype._acceptTraverser = function (traverser) {
        traverser[LineSegment.traverseName](this);
    };
    return LineSegment;
}(DisplayObject));
LineSegment.traverseName = _awayjs_graphics.TraverserBase.addRenderableName("applyLineSegment");
LineSegment.assetType = "[asset LineSegment]";

/**
 * The LoaderContainer class is used to load SWF files or image(JPG, PNG, or GIF)
 * files. Use the <code>load()</code> method to initiate loading. The loaded
 * display object is added as a child of the LoaderContainer object.
 *
 * <p>Use the URLLoader class to load text or binary data.</p>
 *
 * <p>The LoaderContainer class overrides the following methods that it inherits,
 * because a LoaderContainer object can only have one child display object - the
 * display object that it loads. Calling the following methods throws an
 * exception: <code>addChild()</code>, <code>addChildAt()</code>,
 * <code>removeChild()</code>, <code>removeChildAt()</code>, and
 * <code>setChildIndex()</code>. To remove a loaded display object, you must
 * remove the <i>LoaderContainer</i> object from its parent DisplayObjectContainer
 * child array. </p>
 *
 * <p><b>Note:</b> The ActionScript 2.0 MovieClipLoader and LoadVars classes
 * are not used in ActionScript 3.0. The LoaderContainer and URLLoader classes replace
 * them.</p>
 *
 * <p>When you use the LoaderContainer class, consider the Flash Player and Adobe AIR
 * security model: </p>
 *
 * <ul>
 *   <li>You can load content from any accessible source. </li>
 *   <li>Loading is not allowed if the calling SWF file is in a network
 * sandbox and the file to be loaded is local. </li>
 *   <li>If the loaded content is a SWF file written with ActionScript 3.0, it
 * cannot be cross-scripted by a SWF file in another security sandbox unless
 * that cross-scripting arrangement was approved through a call to the
 * <code>System.allowDomain()</code> or the
 * <code>System.allowInsecureDomain()</code> method in the loaded content
 * file.</li>
 *   <li>If the loaded content is an AVM1 SWF file(written using ActionScript
 * 1.0 or 2.0), it cannot be cross-scripted by an AVM2 SWF file(written using
 * ActionScript 3.0). However, you can communicate between the two SWF files
 * by using the LocalConnection class.</li>
 *   <li>If the loaded content is an image, its data cannot be accessed by a
 * SWF file outside of the security sandbox, unless the domain of that SWF
 * file was included in a URL policy file at the origin domain of the
 * image.</li>
 *   <li>Movie clips in the local-with-file-system sandbox cannot script movie
 * clips in the local-with-networking sandbox, and the reverse is also
 * prevented. </li>
 *   <li>You cannot connect to commonly reserved ports. For a complete list of
 * blocked ports, see "Restricting Networking APIs" in the <i>ActionScript 3.0
 * Developer's Guide</i>. </li>
 * </ul>
 *
 * <p>However, in AIR, content in the <code>application</code> security
 * sandbox(content installed with the AIR application) are not restricted by
 * these security limitations.</p>
 *
 * <p>For more information related to security, see the Flash Player Developer
 * Center Topic: <a href="http://www.adobe.com/go/devnet_security_en"
 * scope="external">Security</a>.</p>
 *
 * <p>When loading a SWF file from an untrusted source(such as a domain other
 * than that of the LoaderContainer object's root SWF file), you may want to define a
 * mask for the LoaderContainer object, to prevent the loaded content(which is a child
 * of the LoaderContainer object) from drawing to portions of the Stage outside of that
 * mask, as shown in the following code:</p>
 */
var LoaderContainer = (function (_super) {
    __extends(LoaderContainer, _super);
    /**
     * Creates a Loader object that you can use to load files, such as SWF, JPEG,
     * GIF, or PNG files. Call the <code>load()</code> method to load the asset
     * as a child of the Loader instance. You can then add the Loader object to
     * the display list(for instance, by using the <code>addChild()</code>
     * method of a DisplayObjectContainer instance). The asset appears on the
     * Stage as it loads.
     *
     * <p>You can also use a Loader instance "offlist," that is without adding it
     * to a display object container on the display list. In this mode, the
     * Loader instance might be used to load a SWF file that contains additional
     * modules of an application. </p>
     *
     * <p>To detect when the SWF file is finished loading, you can use the events
     * of the LoaderInfo object associated with the
     * <code>contentLoaderInfo</code> property of the Loader object. At that
     * point, the code in the module SWF file can be executed to initialize and
     * start the module. In the offlist mode, a Loader instance might also be
     * used to load a SWF file that contains components or media assets. Again,
     * you can use the LoaderInfo object event notifications to detect when the
     * components are finished loading. At that point, the application can start
     * using the components and media assets in the library of the SWF file by
     * instantiating the ActionScript 3.0 classes that represent those components
     * and assets.</p>
     *
     * <p>To determine the status of a Loader object, monitor the following
     * events that the LoaderInfo object associated with the
     * <code>contentLoaderInfo</code> property of the Loader object:</p>
     *
     * <ul>
     *   <li>The <code>open</code> event is dispatched when loading begins.</li>
     *   <li>The <code>ioError</code> or <code>securityError</code> event is
     * dispatched if the file cannot be loaded or if an error occured during the
     * load process. </li>
     *   <li>The <code>progress</code> event fires continuously while the file is
     * being loaded.</li>
     *   <li>The <code>complete</code> event is dispatched when a file completes
     * downloading, but before the loaded movie clip's methods and properties are
     * available. </li>
     *   <li>The <code>init</code> event is dispatched after the properties and
     * methods of the loaded SWF file are accessible, so you can begin
     * manipulating the loaded SWF file. This event is dispatched before the
     * <code>complete</code> handler. In streaming SWF files, the
     * <code>init</code> event can occur significantly earlier than the
     * <code>complete</code> event. For most purposes, use the <code>init</code>
     * handler.</li>
     * </ul>
     */
    function LoaderContainer(useAssetLibrary, assetLibraryId) {
        if (useAssetLibrary === void 0) { useAssetLibrary = true; }
        if (assetLibraryId === void 0) { assetLibraryId = null; }
        var _this = _super.call(this) || this;
        _this._useAssetLib = useAssetLibrary;
        _this._assetLibId = assetLibraryId;
        _this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
        _this._onTextureSizeErrorDelegate = function (event) { return _this.onTextureSizeError(event); };
        _this._onLoadCompleteDelegate = function (event) { return _this.onLoadComplete(event); };
        _this._onLoadErrorDelegate = function (event) { return _this.onLoadError(event); };
        _this._onParseErrorDelegate = function (event) { return _this.onParseError(event); };
        return _this;
    }
    Object.defineProperty(LoaderContainer.prototype, "content", {
        /**
         * Contains the root display object of the SWF file or image(JPG, PNG, or
         * GIF) file that was loaded by using the <code>load()</code> or
         * <code>loadBytes()</code> methods.
         *
         * @throws SecurityError The loaded SWF file or image file belongs to a
         *                       security sandbox to which you do not have access.
         *                       For a loaded SWF file, you can avoid this situation
         *                       by having the file call the
         *                       <code>Security.allowDomain()</code> method or by
         *                       having the loading file specify a
         *                       <code>loaderContext</code> parameter with its
         *                       <code>securityDomain</code> property set to
         *                       <code>SecurityDomain.currentDomain</code> when you
         *                       call the <code>load()</code> or
         *                       <code>loadBytes()</code> method.
         */
        get: function () {
            return this._content;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Cancels a <code>load()</code> method operation that is currently in
     * progress for the Loader instance.
     *
     */
    LoaderContainer.prototype.close = function () {
        if (!this._loader)
            return;
        if (this._useAssetLib) {
            var lib;
            lib = _awayjs_core.AssetLibraryBundle.getInstance(this._assetLibId);
            lib.disposeLoader(this._loader);
        }
        this._disposeLoader();
    };
    /**
     * Loads a SWF, JPEG, progressive JPEG, unanimated GIF, or PNG file into an
     * object that is a child of this Loader object. If you load an animated GIF
     * file, only the first frame is displayed. As the Loader object can contain
     * only a single child, issuing a subsequent <code>load()</code> request
     * terminates the previous request, if still pending, and commences a new
     * load.
     *
     * <p><b>Note</b>: In AIR 1.5 and Flash Player 10, the maximum size for a
     * loaded image is 8,191 pixels in width or height, and the total number of
     * pixels cannot exceed 16,777,215 pixels.(So, if an loaded image is 8,191
     * pixels wide, it can only be 2,048 pixels high.) In Flash Player 9 and
     * earlier and AIR 1.1 and earlier, the limitation is 2,880 pixels in height
     * and 2,880 pixels in width.</p>
     *
     * <p>A SWF file or image loaded into a Loader object inherits the position,
     * rotation, and scale properties of the parent display objects of the Loader
     * object. </p>
     *
     * <p>Use the <code>unload()</code> method to remove movies or images loaded
     * with this method, or to cancel a load operation that is in progress.</p>
     *
     * <p>You can prevent a SWF file from using this method by setting the
     * <code>allowNetworking</code> parameter of the the <code>object</code> and
     * <code>embed</code> tags in the HTML page that contains the SWF
     * content.</p>
     *
     * <p>When you use this method, consider the Flash Player security model,
     * which is described in the Loader class description. </p>
     *
     * <p> In Flash Player 10 and later, if you use a multipart Content-Type(for
     * example "multipart/form-data") that contains an upload(indicated by a
     * "filename" parameter in a "content-disposition" header within the POST
     * body), the POST operation is subject to the security rules applied to
     * uploads:</p>
     *
     * <ul>
     *   <li>The POST operation must be performed in response to a user-initiated
     * action, such as a mouse click or key press.</li>
     *   <li>If the POST operation is cross-domain(the POST target is not on the
     * same server as the SWF file that is sending the POST request), the target
     * server must provide a URL policy file that permits cross-domain
     * access.</li>
     * </ul>
     *
     * <p>Also, for any multipart Content-Type, the syntax must be valid
     * (according to the RFC2046 standard). If the syntax appears to be invalid,
     * the POST operation is subject to the security rules applied to
     * uploads.</p>
     *
     * <p>For more information related to security, see the Flash Player
     * Developer Center Topic: <a
     * href="http://www.adobe.com/go/devnet_security_en"
     * scope="external">Security</a>.</p>
     *
     * @param request The absolute or relative URL of the SWF, JPEG, GIF, or PNG
     *                file to be loaded. A relative path must be relative to the
     *                main SWF file. Absolute URLs must include the protocol
     *                reference, such as http:// or file:///. Filenames cannot
     *                include disk drive specifications.
     * @param context A LoaderContext object, which has properties that define
     *                the following:
     *                <ul>
     *                  <li>Whether or not to check for the existence of a policy
     *                file upon loading the object</li>
     *                  <li>The ApplicationDomain for the loaded object</li>
     *                  <li>The SecurityDomain for the loaded object</li>
     *                  <li>The ImageDecodingPolicy for the loaded image
     *                object</li>
     *                </ul>
     *
     *                <p>If the <code>context</code> parameter is not specified
     *                or refers to a null object, the loaded content remains in
     *                its own security domain.</p>
     *
     *                <p>For complete details, see the description of the
     *                properties in the <a
     *                href="../system/LoaderContext.html">LoaderContext</a>
     *                class.</p>
     * @param ns      An optional namespace string under which the file is to be
     *                loaded, allowing the differentiation of two resources with
     *                identical assets.
     * @param parser  An optional parser object for translating the loaded data
     *                into a usable resource. If not provided, Loader will
     *                attempt to auto-detect the file type.
     * @throws IOError               The <code>digest</code> property of the
     *                               <code>request</code> object is not
     *                               <code>null</code>. You should only set the
     *                               <code>digest</code> property of a URLRequest
     *                               object when calling the
     *                               <code>URLLoader.load()</code> method when
     *                               loading a SWZ file(an Adobe platform
     *                               component).
     * @throws IllegalOperationError If the <code>requestedContentParent</code>
     *                               property of the <code>context</code>
     *                               parameter is a <code>Loader</code>.
     * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
     *                               parameter is set to non-null and has some
     *                               values which are not Strings.
     * @throws SecurityError         The value of
     *                               <code>LoaderContext.securityDomain</code>
     *                               must be either <code>null</code> or
     *                               <code>SecurityDomain.currentDomain</code>.
     *                               This reflects the fact that you can only
     *                               place the loaded media in its natural
     *                               security sandbox or your own(the latter
     *                               requires a policy file).
     * @throws SecurityError         Local SWF files may not set
     *                               LoaderContext.securityDomain to anything
     *                               other than <code>null</code>. It is not
     *                               permitted to import non-local media into a
     *                               local sandbox, or to place other local media
     *                               in anything other than its natural sandbox.
     * @throws SecurityError         You cannot connect to commonly reserved
     *                               ports. For a complete list of blocked ports,
     *                               see "Restricting Networking APIs" in the
     *                               <i>ActionScript 3.0 Developer's Guide</i>.
     * @throws SecurityError         If the <code>applicationDomain</code> or
     *                               <code>securityDomain</code> properties of
     *                               the <code>context</code> parameter are from
     *                               a disallowed domain.
     * @throws SecurityError         If a local SWF file is attempting to use the
     *                               <code>securityDomain</code> property of the
     *                               <code>context</code> parameter.
     * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
     *                      object if the
     *                      <code>LoaderContext.requestedContentParent</code>
     *                      property has been specified and it is not possible to
     *                      add the loaded content as a child to the specified
     *                      DisplayObjectContainer. This could happen if the
     *                      loaded content is a
     *                      <code>flash.display.AVM1Movie</code> or if the
     *                      <code>addChild()</code> call to the
     *                      requestedContentParent throws an error.
     * @event complete      Dispatched by the <code>contentLoaderInfo</code>
     *                      object when the file has completed loading. The
     *                      <code>complete</code> event is always dispatched
     *                      after the <code>init</code> event.
     * @event httpStatus    Dispatched by the <code>contentLoaderInfo</code>
     *                      object when a network request is made over HTTP and
     *                      Flash Player can detect the HTTP status code.
     * @event init          Dispatched by the <code>contentLoaderInfo</code>
     *                      object when the properties and methods of the loaded
     *                      SWF file are accessible. The <code>init</code> event
     *                      always precedes the <code>complete</code> event.
     * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
     *                      object when an input or output error occurs that
     *                      causes a load operation to fail.
     * @event open          Dispatched by the <code>contentLoaderInfo</code>
     *                      object when the loading operation starts.
     * @event progress      Dispatched by the <code>contentLoaderInfo</code>
     *                      object as data is received while load operation
     *                      progresses.
     * @event securityError Dispatched by the <code>contentLoaderInfo</code>
     *                      object if a SWF file in the local-with-filesystem
     *                      sandbox attempts to load content in the
     *                      local-with-networking sandbox, or vice versa.
     * @event securityError Dispatched by the <code>contentLoaderInfo</code>
     *                      object if the
     *                      <code>LoaderContext.requestedContentParent</code>
     *                      property has been specified and the security sandbox
     *                      of the
     *                      <code>LoaderContext.requestedContentParent</code>
     *                      does not have access to the loaded SWF.
     * @event unload        Dispatched by the <code>contentLoaderInfo</code>
     *                      object when a loaded object is removed.
     */
    LoaderContainer.prototype.load = function (request, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        this._getLoader().load(request, context, ns, parser);
    };
    /**
     * Loads from binary data stored in a ByteArray object.
     *
     * <p>The <code>loadBytes()</code> method is asynchronous. You must wait for
     * the "init" event before accessing the properties of a loaded object.</p>
     *
     * <p>When you use this method, consider the Flash Player security model,
     * which is described in the Loader class description. </p>
     *
     * @param bytes   A ByteArray object. The contents of the ByteArray can be
     *                any of the file formats supported by the Loader class: SWF,
     *                GIF, JPEG, or PNG.
     * @param context A LoaderContext object. Only the
     *                <code>applicationDomain</code> property of the
     *                LoaderContext object applies; the
     *                <code>checkPolicyFile</code> and
     *                <code>securityDomain</code> properties of the LoaderContext
     *                object do not apply.
     *
     *                <p>If the <code>context</code> parameter is not specified
     *                or refers to a null object, the content is loaded into the
     *                current security domain -  a process referred to as "import
     *                loading" in Flash Player security documentation.
     *                Specifically, if the loading SWF file trusts the remote SWF
     *                by incorporating the remote SWF into its code, then the
     *                loading SWF can import it directly into its own security
     *                domain.</p>
     *
     *                <p>For more information related to security, see the Flash
     *                Player Developer Center Topic: <a
     *                href="http://www.adobe.com/go/devnet_security_en"
     *                scope="external">Security</a>.</p>
     * @throws ArgumentError         If the <code>length</code> property of the
     *                               ByteArray object is not greater than 0.
     * @throws IllegalOperationError If the <code>checkPolicyFile</code> or
     *                               <code>securityDomain</code> property of the
     *                               <code>context</code> parameter are non-null.
     * @throws IllegalOperationError If the <code>requestedContentParent</code>
     *                               property of the <code>context</code>
     *                               parameter is a <code>Loader</code>.
     * @throws IllegalOperationError If the <code>LoaderContext.parameters</code>
     *                               parameter is set to non-null and has some
     *                               values which are not Strings.
     * @throws SecurityError         If the provided
     *                               <code>applicationDomain</code> property of
     *                               the <code>context</code> property is from a
     *                               disallowed domain.
     * @throws SecurityError         You cannot connect to commonly reserved
     *                               ports. For a complete list of blocked ports,
     *                               see "Restricting Networking APIs" in the
     *                               <i>ActionScript 3.0 Developer's Guide</i>.
     * @event asyncError    Dispatched by the <code>contentLoaderInfo</code>
     *                      object if the
     *                      <code>LoaderContext.requestedContentParent</code>
     *                      property has been specified and it is not possible to
     *                      add the loaded content as a child to the specified
     *                      DisplayObjectContainer. This could happen if the
     *                      loaded content is a
     *                      <code>flash.display.AVM1Movie</code> or if the
     *                      <code>addChild()</code> call to the
     *                      requestedContentParent throws an error.
     * @event complete      Dispatched by the <code>contentLoaderInfo</code>
     *                      object when the operation is complete. The
     *                      <code>complete</code> event is always dispatched
     *                      after the <code>init</code> event.
     * @event init          Dispatched by the <code>contentLoaderInfo</code>
     *                      object when the properties and methods of the loaded
     *                      data are accessible. The <code>init</code> event
     *                      always precedes the <code>complete</code> event.
     * @event ioError       Dispatched by the <code>contentLoaderInfo</code>
     *                      object when the runtime cannot parse the data in the
     *                      byte array.
     * @event open          Dispatched by the <code>contentLoaderInfo</code>
     *                      object when the operation starts.
     * @event progress      Dispatched by the <code>contentLoaderInfo</code>
     *                      object as data is transfered in memory.
     * @event securityError Dispatched by the <code>contentLoaderInfo</code>
     *                      object if the
     *                      <code>LoaderContext.requestedContentParent</code>
     *                      property has been specified and the security sandbox
     *                      of the
     *                      <code>LoaderContext.requestedContentParent</code>
     *                      does not have access to the loaded SWF.
     * @event unload        Dispatched by the <code>contentLoaderInfo</code>
     *                      object when a loaded object is removed.
     */
    LoaderContainer.prototype.loadData = function (data, context, ns, parser) {
        if (context === void 0) { context = null; }
        if (ns === void 0) { ns = null; }
        if (parser === void 0) { parser = null; }
        this._getLoader().loadData(data, '', context, ns, parser);
    };
    LoaderContainer.prototype._getLoader = function () {
        if (this._useAssetLib) {
            var lib = _awayjs_core.AssetLibraryBundle.getInstance(this._assetLibId);
            this._loader = lib.getLoader();
        }
        else {
            this._loader = new _awayjs_core.Loader();
        }
        this._loader.addEventListener(_awayjs_core.LoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
        this._loader.addEventListener(_awayjs_core.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        this._loader.addEventListener(_awayjs_core.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        // Error are handled separately (see documentation for addErrorHandler)
        this._loader._iAddErrorHandler(this._onLoadErrorDelegate);
        this._loader._iAddParseErrorHandler(this._onParseErrorDelegate);
        return this._loader;
    };
    LoaderContainer.prototype._disposeLoader = function () {
        this._loader.removeEventListener(_awayjs_core.LoaderEvent.LOAD_COMPLETE, this._onLoadCompleteDelegate);
        this._loader.removeEventListener(_awayjs_core.AssetEvent.TEXTURE_SIZE_ERROR, this._onTextureSizeErrorDelegate);
        this._loader.removeEventListener(_awayjs_core.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        if (!this._useAssetLib)
            this._loader.stop();
        this._loader = null;
    };
    /**
     * Removes a child of this Loader object that was loaded by using the
     * <code>load()</code> method. The <code>property</code> of the associated
     * LoaderInfo object is reset to <code>null</code>. The child is not
     * necessarily destroyed because other objects might have references to it;
     * however, it is no longer a child of the Loader object.
     *
     * <p>As a best practice, before you unload a child SWF file, you should
     * explicitly close any streams in the child SWF file's objects, such as
     * LocalConnection, NetConnection, NetStream, and Sound objects. Otherwise,
     * audio in the child SWF file might continue to play, even though the child
     * SWF file was unloaded. To close streams in the child SWF file, add an
     * event listener to the child that listens for the <code>unload</code>
     * event. When the parent calls <code>Loader.unload()</code>, the
     * <code>unload</code> event is dispatched to the child. The following code
     * shows how you might do this:</p>
     * <pre xml:space="preserve"> public closeAllStreams(evt:Event) {
     * myNetStream.close(); mySound.close(); myNetConnection.close();
     * myLocalConnection.close(); }
     * myMovieClip.loaderInfo.addEventListener(Event.UNLOAD,
     * closeAllStreams);</pre>
     *
     */
    LoaderContainer.prototype.unload = function () {
        //TODO
    };
    /**
     * Enables a specific parser.
     * When no specific parser is set for a loading/parsing opperation,
     * loader3d can autoselect the correct parser to use.
     * A parser must have been enabled, to be considered when autoselecting the parser.
     *
     * @param parserClass The parser class to enable.
     * @see away.parsers.Parsers
     */
    LoaderContainer.enableParser = function (parserClass) {
        _awayjs_core.Loader.enableParser(parserClass);
    };
    /**
     * Enables a list of parsers.
     * When no specific parser is set for a loading/parsing opperation,
     * loader3d can autoselect the correct parser to use.
     * A parser must have been enabled, to be considered when autoselecting the parser.
     *
     * @param parserClasses A Vector of parser classes to enable.
     * @see away.parsers.Parsers
     */
    LoaderContainer.enableParsers = function (parserClasses) {
        _awayjs_core.Loader.enableParsers(parserClasses);
    };
    LoaderContainer.prototype.onAssetComplete = function (event) {
        this.dispatchEvent(event);
    };
    /**
     * Called when an error occurs during loading
     */
    LoaderContainer.prototype.onLoadError = function (event) {
        if (this.hasEventListener(_awayjs_core.URLLoaderEvent.LOAD_ERROR)) {
            this.dispatchEvent(event);
            return true;
        }
        else {
            return false;
        }
    };
    /**
     * Called when a an error occurs during parsing
     */
    LoaderContainer.prototype.onParseError = function (event) {
        if (this.hasEventListener(_awayjs_core.ParserEvent.PARSE_ERROR)) {
            this.dispatchEvent(event);
            return true;
        }
        else {
            return false;
        }
    };
    LoaderContainer.prototype.onTextureSizeError = function (event) {
        this.dispatchEvent(event);
    };
    /**
     * Called when the resource and all of its dependencies was retrieved.
     */
    LoaderContainer.prototype.onLoadComplete = function (event) {
        this._content = event.content;
        if (this._content)
            this.addChild(this._content);
        this.dispatchEvent(event);
        this._disposeLoader();
    };
    return LoaderContainer;
}(DisplayObjectContainer));

/**
 * A MouseEvent is dispatched when a mouse event occurs over a mouseEnabled object in View.
 * TODO: we don't have screenZ data, tho this should be easy to implement
 */
var MouseEvent = (function (_super) {
    __extends(MouseEvent, _super);
    /**
     * Create a new MouseEvent object.
     * @param type The type of the MouseEvent.
     */
    function MouseEvent(type) {
        var _this = _super.call(this, type) || this;
        // Private.
        _this._iAllowedToPropagate = true;
        return _this;
    }
    Object.defineProperty(MouseEvent.prototype, "bubbles", {
        /**
         * @inheritDoc
         */
        get: function () {
            var doesBubble = this._iAllowedToPropagate;
            this._iAllowedToPropagate = true;
            // Don't bubble if propagation has been stopped.
            return doesBubble;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    MouseEvent.prototype.stopPropagation = function () {
        this._iAllowedToPropagate = false;
        if (this._iParentEvent)
            this._iParentEvent.stopPropagation();
    };
    /**
     * @inheritDoc
     */
    MouseEvent.prototype.stopImmediatePropagation = function () {
        this._iAllowedToPropagate = false;
        if (this._iParentEvent)
            this._iParentEvent.stopImmediatePropagation();
    };
    /**
     * Creates a copy of the MouseEvent object and sets the value of each property to match that of the original.
     */
    MouseEvent.prototype.clone = function () {
        var result = new MouseEvent(this.type);
        /* TODO: Debug / test - look into isDefaultPrevented
         if (isDefaultPrevented())
         result.preventDefault();
         */
        result.screenX = this.screenX;
        result.screenY = this.screenY;
        result.view = this.view;
        result.entity = this.entity;
        result.renderable = this.renderable;
        result.material = this.material;
        result.uv = this.uv;
        result.position = this.position;
        result.normal = this.normal;
        result.elementIndex = this.elementIndex;
        result.delta = this.delta;
        result.ctrlKey = this.ctrlKey;
        result.shiftKey = this.shiftKey;
        result._iParentEvent = this;
        result._iAllowedToPropagate = this._iAllowedToPropagate;
        return result;
    };
    Object.defineProperty(MouseEvent.prototype, "scenePosition", {
        /**
         * The position in scene space where the event took place
         */
        get: function () {
            return this.entity.transform.concatenatedMatrix3D.transformVector(this.position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MouseEvent.prototype, "sceneNormal", {
        /**
         * The normal in scene space where the event took place
         */
        get: function () {
            var sceneNormal = this.entity.transform.concatenatedMatrix3D.deltaTransformVector(this.normal);
            sceneNormal.normalize();
            return sceneNormal;
        },
        enumerable: true,
        configurable: true
    });
    return MouseEvent;
}(_awayjs_core.EventBase));
/**
 * Defines the value of the type property of a mouseOver3d event object.
 */
MouseEvent.MOUSE_OVER = "mouseOver3d";
/**
 * Defines the value of the type property of a mouseOut3d event object.
 */
MouseEvent.MOUSE_OUT = "mouseOut3d";
/**
 * Defines the value of the type property of a mouseUp3d event object.
 */
MouseEvent.MOUSE_UP = "mouseUp3d";
/**
 * Defines the value of the type property of a mouseDown3d event object.
 */
MouseEvent.MOUSE_DOWN = "mouseDown3d";
/**
 * Defines the value of the type property of a mouseMove3d event object.
 */
MouseEvent.MOUSE_MOVE = "mouseMove3d";
/**
 * Defines the value of the type property of a rollOver3d event object.
 */
//		public static ROLL_OVER : string = "rollOver3d";
/**
 * Defines the value of the type property of a rollOut3d event object.
 */
//		public static ROLL_OUT : string = "rollOut3d";
/**
 * Defines the value of the type property of a click3d event object.
 */
MouseEvent.CLICK = "click3d";
/**
 * Defines the value of the type property of a doubleClick3d event object.
 */
MouseEvent.DOUBLE_CLICK = "doubleClick3d";
/**
 * Defines the value of the type property of a mouseWheel3d event object.
 */
MouseEvent.MOUSE_WHEEL = "mouseWheel3d";

/**
 * The TextFormat class represents character formatting information. Use the
 * TextFormat class to create specific text formatting for text fields. You
 * can apply text formatting to both static and dynamic text fields. The
 * properties of the TextFormat class apply to device and embedded fonts.
 * However, for embedded fonts, bold and italic text actually require specific
 * fonts. If you want to display bold or italic text with an embedded font,
 * you need to embed the bold and italic variations of that font.
 *
 * <p> You must use the constructor <code>new TextFormat()</code> to create a
 * TextFormat object before setting its properties. When you apply a
 * TextFormat object to a text field using the
 * <code>TextField.defaultTextFormat</code> property or the
 * <code>TextField.setTextFormat()</code> method, only its defined properties
 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
 * by default because if you don't provide values for the properties, Flash
 * Player uses its own default formatting. The default formatting that Flash
 * Player uses for each property(if property's value is <code>null</code>) is
 * as follows:</p>
 *
 * <p>The default formatting for each property is also described in each
 * property description.</p>
 */
var TesselatedFontChar = (function () {
    function TesselatedFontChar(fill_data, stroke_data) {
        if (fill_data === void 0) { fill_data = null; }
        if (stroke_data === void 0) { stroke_data = null; }
        /**
         * the char_codes that this geom has kerning set for
         */
        this.kerningCharCodes = [];
        /**
         * the kerning values per char_code
         */
        this.kerningValues = [];
        this.fill_data = fill_data;
        this.stroke_data = stroke_data;
    }
    return TesselatedFontChar;
}());

/**
 * GraphicBase wraps a TriangleElements as a scene graph instantiation. A GraphicBase is owned by a Sprite object.
 *
 *
 * @see away.base.TriangleElements
 * @see away.entities.Sprite
 *
 * @class away.base.GraphicBase
 */
var TesselatedFontTable = (function (_super) {
    __extends(TesselatedFontTable, _super);
    //TODO test shader picking
    //		public get shaderPickingDetails():boolean
    //		{
    //
    //			return this.sourceEntity.shaderPickingDetails;
    //		}
    /**
     * Creates a new TesselatedFont object
     * If a opentype_font object is passed, the chars will get tessellated whenever requested.
     * If no opentype font object is passed, it is expected that tesselated chars
     */
    function TesselatedFontTable(opentype_font) {
        if (opentype_font === void 0) { opentype_font = null; }
        var _this = _super.call(this) || this;
        _this._font_chars = [];
        _this._font_chars_dic = new Object();
        _this._current_size = 0;
        _this._size_multiply = 0;
        _this._ascent = 0;
        _this._descent = 0;
        _this._usesCurves = false;
        if (opentype_font) {
            _this._opentype_font = opentype_font;
            /*
             console.log("head.yMax "+head.yMax);
             console.log("head.yMin "+head.yMin);
             console.log("font.numGlyphs "+font.numGlyphs);
             console.log('Ascender', font.tables.hhea.ascender);
             console.log('Descender', font.tables.hhea.descender);
             console.log('Typo Ascender', font.tables.os2.sTypoAscender);
             console.log('Typo Descender', font.tables.os2.sTypoDescender);
             */
            //this._ascent=this._opentype_font.tables.hhea.ascender;
            //this._descent=this._opentype_font.tables.hhea.descender;
            _this._font_em_size = 72;
            _this._current_size = 0;
            _this._size_multiply = 0;
            return _this;
        }
        return _this;
    }
    TesselatedFontTable.prototype.hasChar = function (char_code) {
        return this._font_chars_dic[char_code] != null;
    };
    TesselatedFontTable.prototype.changeOpenTypeFont = function (newOpenTypeFont, tesselateAllOld) {
        if (tesselateAllOld === void 0) { tesselateAllOld = true; }
        if ((tesselateAllOld) && (this._opentype_font)) {
        }
        // todo: when updating a font we must take care that they are compatible in terms of em_size
        this._opentype_font = newOpenTypeFont;
    };
    TesselatedFontTable.prototype.initFontSize = function (font_size) {
        if (this.fallbackTable)
            this.fallbackTable.initFontSize(font_size);
        if (this._current_size == font_size)
            return;
        this._current_size = font_size;
        this._size_multiply = font_size / this._font_em_size;
        //console.log("text-font-table: ",this._ascent, this._descent, this._font_em_size)
    };
    TesselatedFontTable.prototype.getCharVertCnt = function (char_code) {
        var tesselated_font_char = this._font_chars_dic[char_code];
        if (tesselated_font_char) {
            return tesselated_font_char.fill_data.length;
        }
        return 0;
    };
    TesselatedFontTable.prototype.getCharWidth = function (char_code) {
        if (char_code == "32") {
            return this._whitespace_width * this._size_multiply;
        }
        var tesselated_font_char = this._font_chars_dic[char_code];
        if (tesselated_font_char) {
            return tesselated_font_char.char_width * this._size_multiply;
        }
        if (this.fallbackTable)
            return this.fallbackTable.getCharWidth(char_code);
        return 0;
    };
    Object.defineProperty(TesselatedFontTable.prototype, "usesCurves", {
        get: function () {
            return this._usesCurves;
        },
        enumerable: true,
        configurable: true
    });
    TesselatedFontTable.prototype.getLineHeight = function () {
        var thisLineheighttest = this._current_size * (this._font_em_size / this._ascent);
        if (this.name == "BoldStyle") {
            thisLineheighttest = this._current_size;
        }
        //return thisLineheighttest; // sf
        return (this._ascent + this._descent) * this._size_multiply; // enable for icycle
    };
    Object.defineProperty(TesselatedFontTable.prototype, "assetType", {
        get: function () {
            return TesselatedFontTable.assetType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    TesselatedFontTable.prototype.dispose = function () {
    };
    Object.defineProperty(TesselatedFontTable.prototype, "ascent", {
        get: function () {
            return this._ascent;
        },
        set: function (value) {
            this._ascent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TesselatedFontTable.prototype, "descent", {
        get: function () {
            return this._descent;
        },
        set: function (value) {
            this._descent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TesselatedFontTable.prototype, "offset_x", {
        get: function () {
            return this._offset_x;
        },
        set: function (value) {
            this._offset_x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TesselatedFontTable.prototype, "offset_y", {
        get: function () {
            return this._offset_y;
        },
        set: function (value) {
            this._offset_y = value;
        },
        enumerable: true,
        configurable: true
    });
    TesselatedFontTable.prototype.get_font_chars = function () {
        return this._font_chars;
    };
    TesselatedFontTable.prototype.get_font_em_size = function () {
        return this._font_em_size;
    };
    TesselatedFontTable.prototype.set_whitespace_width = function (value) {
        this._whitespace_width = value;
    };
    TesselatedFontTable.prototype.get_whitespace_width = function () {
        return this._whitespace_width;
    };
    TesselatedFontTable.prototype.set_font_em_size = function (font_em_size) {
        this._font_em_size = font_em_size;
    };
    TesselatedFontTable.prototype.fillTextRun = function (tf, format, startWord, wordCnt) {
        var textShape = tf.getTextShapeForIdentifierAndFormat(format.color.toString(), format);
        var charGlyph;
        var w = 0;
        var w_len = startWord + (wordCnt * 5);
        var char_vertices;
        var c = 0;
        var c_len = 0;
        var x = 0;
        var y = 0;
        var startIdx = 0;
        var buffer;
        var v;
        var size_multiply;
        var hack_x_mirror = false;
        // loop over all the words and create the text data for it
        // each word provides its own start-x and start-y values, so we can just ignore whitespace-here
        for (w = startWord; w < w_len; w += 5) {
            startIdx = tf.words[w];
            x = tf.words[w + 1];
            y = tf.words[w + 2]; //-this.getLineHeight())+(this._size_multiply*this.ascent); // sunflower
            if (this.name == "BoldStyle") {
                y -= 0.2 * this.getLineHeight();
            }
            else {
            }
            //todo: this is a temporary fix for sunflower `si` VoltMeter text vertical align
            if (format.font_name == "DJB Get Digital") {
                y -= 2;
            }
            y = tf.words[w + 2] + (this.ascent - this.get_font_em_size()) * this._size_multiply; // enable for icycle
            c_len = startIdx + tf.words[w + 4];
            for (c = startIdx; c < c_len; c++) {
                hack_x_mirror = false;
                if (tf.chars_codes[c] == 40) {
                    tf.chars_codes[c] = 41;
                    hack_x_mirror = true;
                }
                if (tf.chars_codes[c] != 32) {
                    charGlyph = this.getChar(tf.chars_codes[c].toString());
                    size_multiply = this._size_multiply;
                    if (!charGlyph && this.fallbackTable) {
                        charGlyph = this.fallbackTable.getChar(tf.chars_codes[c].toString());
                        size_multiply = this.fallbackTable._size_multiply;
                    }
                    if (charGlyph) {
                        char_vertices = charGlyph.fill_data;
                        buffer = new Float32Array(char_vertices.buffer);
                        if (this.usesCurves) {
                            for (v = 0; v < char_vertices.count; v++) {
                                textShape.verts[textShape.verts.length] = buffer[v * 3] * size_multiply + x;
                                textShape.verts[textShape.verts.length] = buffer[v * 3 + 1] * size_multiply + y;
                                textShape.verts[textShape.verts.length] = buffer[v * 3 + 2];
                            }
                        }
                        else {
                            if (hack_x_mirror) {
                                for (v = 0; v < char_vertices.count; v++) {
                                    textShape.verts[textShape.verts.length] = (charGlyph.char_width - buffer[v * 2]) * size_multiply + x;
                                    textShape.verts[textShape.verts.length] = buffer[v * 2 + 1] * size_multiply + y;
                                }
                            }
                            else {
                                for (v = 0; v < char_vertices.count; v++) {
                                    textShape.verts[textShape.verts.length] = buffer[v * 2] * size_multiply + x;
                                    textShape.verts[textShape.verts.length] = buffer[v * 2 + 1] * size_multiply + y;
                                }
                            }
                        }
                        x += charGlyph.char_width * size_multiply;
                    }
                    else {
                        console.log("TesselatedFontTable: Error: char not found in fontTable");
                    }
                }
            }
        }
    };
    /**
     *
     */
    TesselatedFontTable.prototype.getChar = function (name) {
        if (this._font_chars_dic[name] == null) {
            if (this._opentype_font) {
                //console.log("get char for '"+String.fromCharCode(parseInt(name))+"'. char does not exists yet. try creating it from opentype.");
                var thisGlyph = this._opentype_font.charToGlyph(String.fromCharCode(parseInt(name)));
                if (thisGlyph) {
                    //console.log("got the glyph from opentype");
                    {
                        var thisPath = thisGlyph.getPath();
                        var awayPath = new _awayjs_graphics.GraphicsPath();
                        var i = 0;
                        var len = thisPath.commands.length;
                        //awayPath.lineTo(0, 0);
                        //awayPath.moveTo(0,0);//-100);
                        //awayPath.curveTo(100, 250, 200,0);
                        //awayPath.lineTo(150, 100);
                        //awayPath.moveTo(0,20);
                        //awayPath.curveTo(100, 270, 200,20);
                        //awayPath.moveTo(0,-20);
                        //awayPath.moveTo(0,-10);
                        //awayPath.curveTo(100, -110, 200,-10);
                        var startx = 0;
                        var starty = 0;
                        for (i = 0; i < len; i++) {
                            var cmd = thisPath.commands[i];
                            if (cmd.type === 'M') {
                                awayPath.moveTo(cmd.x, cmd.y);
                                startx = cmd.x;
                                starty = cmd.y;
                            }
                            else if (cmd.type === 'L') {
                                awayPath.lineTo(cmd.x, cmd.y);
                            }
                            else if (cmd.type === 'Q') {
                                awayPath.curveTo(cmd.x1, cmd.y1, cmd.x, cmd.y);
                            }
                            else if (cmd.type === 'C') {
                                awayPath.cubicCurveTo(cmd.x1, cmd.y1, cmd.x2, cmd.y2, cmd.x, cmd.y);
                            }
                            else if (cmd.type === 'Z') {
                                awayPath.lineTo(startx, starty);
                            }
                        }
                        awayPath.style = new _awayjs_graphics.GraphicsStrokeStyle(0xff0000, 1, 1, _awayjs_graphics.JointStyle.MITER, _awayjs_graphics.CapsStyle.NONE, 100);
                        var final_vert_list = [];
                        //todo
                        //GraphicsFactoryStrokes.draw_pathes([awayPath], final_vert_list, false);
                        var attributesView = new _awayjs_core.AttributesView(Float32Array, 3);
                        attributesView.set(final_vert_list);
                        var attributesBuffer = attributesView.attributesBuffer;
                        attributesView.dispose();
                        var tesselated_font_char = new TesselatedFontChar(attributesBuffer, null);
                        tesselated_font_char.char_width = (thisGlyph.advanceWidth * (1 / thisGlyph.path.unitsPerEm * 72));
                        //console.log("tesselated_font_char.char_width "+tesselated_font_char.char_width);
                        this._font_chars.push(tesselated_font_char);
                        this._font_chars_dic[name] = tesselated_font_char;
                    }
                }
            }
        }
        return this._font_chars_dic[name];
    };
    /**
     *
     */
    TesselatedFontTable.prototype.setChar = function (name, char_width, fills_data, stroke_data, uses_curves) {
        if (fills_data === void 0) { fills_data = null; }
        if (stroke_data === void 0) { stroke_data = null; }
        if (uses_curves === void 0) { uses_curves = false; }
        if ((fills_data == null) && (stroke_data == null))
            throw ("TesselatedFontTable: trying to create a TesselatedFontChar with no data (fills_data and stroke_data is null)");
        if (this._font_chars.length > 0) {
            if (uses_curves != this._usesCurves) {
                throw ("TesselatedFontTable: Can not set different types of graphic-glyphs (curves vs non-cuves) on the same FontTable!");
            }
        }
        else {
            this._usesCurves = uses_curves;
        }
        var tesselated_font_char = new TesselatedFontChar(fills_data, stroke_data);
        tesselated_font_char.char_width = char_width;
        this._font_chars.push(tesselated_font_char);
        this._font_chars_dic[name] = tesselated_font_char;
    };
    TesselatedFontTable.prototype.buildTextRuns = function (textRuns, output_verts) {
        if ((textRuns.length * 2) != (output_verts.length))
            throw ("Invalid data passed to TesselatedFontTable.buildTextRuns(). output_verts.length is not double textRuns.length.");
        var i = 0;
        var font_size = 0;
        var drawMode = 0;
        var charCode = 0;
        var xpos = 0;
        var ypos = 0;
        var runCnt = 0;
        var runLen = 0;
        var vertCnt = 0;
        var len = textRuns.length;
        var textrun;
        var thisChar;
        for (i = 0; i < len; i++) {
            textrun = textRuns[i];
            font_size = textrun[0];
            drawMode = textrun[1];
            ypos = textrun[2];
            runLen = textrun.length;
            for (runCnt = 3; runCnt < runLen; runCnt += 2) {
                charCode = textrun[runCnt];
                xpos = textrun[runCnt + 1];
                thisChar = this.getChar(charCode.toString());
                if ((drawMode == _awayjs_graphics.DrawMode.BOTH) || (drawMode == _awayjs_graphics.DrawMode.STROKE)) {
                    if (output_verts[i * 2] == null) {
                        throw ("Trying to render strokes for a textrun, but no output_vert list was set for this textrun strokes");
                    }
                }
                if ((drawMode == _awayjs_graphics.DrawMode.BOTH) || (drawMode == _awayjs_graphics.DrawMode.FILL)) {
                    if (output_verts[i * 2 + 1] == null) {
                        throw ("Trying to render fills for a textrun, but no output_vert list was set for this textrun fills");
                    }
                }
            }
        }
    };
    return TesselatedFontTable;
}(_awayjs_core.AssetBase));
TesselatedFontTable.assetType = "[asset TesselatedFontTable]";

/**
 * The TextFieldAutoSize class is an enumeration of constant values used in
 * setting the <code>autoSize</code> property of the TextField class.
 */
var TextFieldAutoSize = (function () {
    function TextFieldAutoSize() {
    }
    return TextFieldAutoSize;
}());
/**
 * Specifies that the text is to be treated as center-justified text. Any
 * resizing of a single line of a text field is equally distributed to both
 * the right and left sides.
 */
TextFieldAutoSize.CENTER = "center";
/**
 * Specifies that the text is to be treated as left-justified text, meaning
 * that the left side of the text field remains fixed and any resizing of a
 * single line is on the right side.
 */
TextFieldAutoSize.LEFT = "left";
/**
 * Specifies that no resizing is to occur.
 */
TextFieldAutoSize.NONE = "none";
/**
 * Specifies that the text is to be treated as right-justified text, meaning
 * that the right side of the text field remains fixed and any resizing of a
 * single line is on the left side.
 */
TextFieldAutoSize.RIGHT = "right";

/**
 * The TextFieldType class is an enumeration of constant values used in setting the
 * <code>type</code> property of the TextField class.
 *
 * @see away.entities.TextField#type
 */
var TextFieldType = (function () {
    function TextFieldType() {
    }
    return TextFieldType;
}());
/**
 * Used to specify a <code>dynamic</code> TextField.
 */
TextFieldType.DYNAMIC = "dynamic";
/**
 * Used to specify an <code>input</code> TextField.
 */
TextFieldType.INPUT = "input";
/**
 * Used to specify an <code>static</code> TextField.
 */
TextFieldType.STATIC = "input";

/**
 * The TextFormat class represents character formatting information. Use the
 * TextFormat class to create specific text formatting for text fields. You
 * can apply text formatting to both static and dynamic text fields. The
 * properties of the TextFormat class apply to device and embedded fonts.
 * However, for embedded fonts, bold and italic text actually require specific
 * fonts. If you want to display bold or italic text with an embedded font,
 * you need to embed the bold and italic variations of that font.
 *
 * <p> You must use the constructor <code>new TextFormat()</code> to create a
 * TextFormat object before setting its properties. When you apply a
 * TextFormat object to a text field using the
 * <code>TextField.defaultTextFormat</code> property or the
 * <code>TextField.setTextFormat()</code> method, only its defined properties
 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
 * by default because if you don't provide values for the properties, Flash
 * Player uses its own default formatting. The default formatting that Flash
 * Player uses for each property(if property's value is <code>null</code>) is
 * as follows:</p>
 *
 * <p>The default formatting for each property is also described in each
 * property description.</p>
 */
var TextFormat = (function (_super) {
    __extends(TextFormat, _super);
    /**
     * Creates a TextFormat object with the specified properties. You can then
     * change the properties of the TextFormat object to change the formatting of
     * text fields.
     *
     * <p>Any parameter may be set to <code>null</code> to indicate that it is
     * not defined. All of the parameters are optional; any omitted parameters
     * are treated as <code>null</code>.</p>
     *
     * @param font        The name of a font for text as a string.
     * @param size        An integer that indicates the size in pixels.
     * @param color       The color of text using this text format. A number
     *                    containing three 8-bit RGB components; for example,
     *                    0xFF0000 is red, and 0x00FF00 is green.
     * @param bold        A Boolean value that indicates whether the text is
     *                    boldface.
     * @param italic      A Boolean value that indicates whether the text is
     *                    italicized.
     * @param underline   A Boolean value that indicates whether the text is
     *                    underlined.
     * @param url         The URL to which the text in this text format
     *                    hyperlinks. If <code>url</code> is an empty string, the
     *                    text does not have a hyperlink.
     * @param target      The target window where the hyperlink is displayed. If
     *                    the target window is an empty string, the text is
     *                    displayed in the default target window
     *                    <code>_self</code>. If the <code>url</code> parameter
     *                    is set to an empty string or to the value
     *                    <code>null</code>, you can get or set this property,
     *                    but the property will have no effect.
     * @param align       The alignment of the paragraph, as a TextFormatAlign
     *                    value.
     * @param leftMargin  Indicates the left margin of the paragraph, in pixels.
     * @param rightMargin Indicates the right margin of the paragraph, in pixels.
     * @param indent      An integer that indicates the indentation from the left
     *                    margin to the first character in the paragraph.
     * @param leading     A number that indicates the amount of leading vertical
     *                    space between lines.
     */
    function TextFormat(font, size, color, bold, italic, underline, url, link_target, align, leftMargin, rightMargin, indent, leading) {
        if (font === void 0) { font = "Times New Roman"; }
        if (size === void 0) { size = 12; }
        if (color === void 0) { color = 0x000000; }
        if (bold === void 0) { bold = false; }
        if (italic === void 0) { italic = false; }
        if (underline === void 0) { underline = false; }
        if (url === void 0) { url = ""; }
        if (link_target === void 0) { link_target = ""; }
        if (align === void 0) { align = "left"; }
        if (leftMargin === void 0) { leftMargin = 0; }
        if (rightMargin === void 0) { rightMargin = 0; }
        if (indent === void 0) { indent = 0; }
        if (leading === void 0) { leading = 0; }
        var _this = _super.call(this) || this;
        /**
         * Specifies custom tab stops as an array of non-negative integers. Each tab
         * stop is specified in pixels. If custom tab stops are not specified
         * (<code>null</code>), the default tab stop is 4(average character width).
         */
        //todo: not used with in tesselated-font-table yet
        _this.tabStops = [];
        _this.font_name = font;
        _this.size = size;
        _this.color = color;
        _this.bold = bold;
        _this.italic = italic;
        _this.underline = underline;
        _this.url = url;
        _this.link_target = link_target;
        _this.align = align;
        _this.leftMargin = leftMargin;
        _this.rightMargin = rightMargin;
        _this.indent = indent;
        _this.leading = leading;
        _this.letterSpacing = 0;
        // todo: implement a way to supply a default fonttable / font to formats
        _this.font_table = new TesselatedFontTable();
        return _this;
    }
    Object.defineProperty(TextFormat.prototype, "size", {
        get: function () {
            return this._size;
        },
        set: function (value) {
            this._size = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextFormat.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return TextFormat.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return TextFormat;
}(_awayjs_core.AssetBase));
TextFormat.assetType = "[asset TextFormat]";

var TextShape = (function () {
    function TextShape() {
        this.verts = [];
    }
    return TextShape;
}());

/**
 * The TextField class is used to create display objects for text display and
 * input. <ph outputclass="flexonly">You can use the TextField class to
 * perform low-level text rendering. However, in Flex, you typically use the
 * Label, Text, TextArea, and TextInput controls to process text. <ph
 * outputclass="flashonly">You can give a text field an instance name in the
 * Property inspector and use the methods and properties of the TextField
 * class to manipulate it with ActionScript. TextField instance names are
 * displayed in the Movie Explorer and in the Insert Target Path dialog box in
 * the Actions panel.
 *
 * <p>To create a text field dynamically, use the <code>TextField()</code>
 * constructor.</p>
 *
 * <p>The methods of the TextField class let you set, select, and manipulate
 * text in a dynamic or input text field that you create during authoring or
 * at runtime. </p>
 *
 * <p>ActionScript provides several ways to format your text at runtime. The
 * TextFormat class lets you set character and paragraph formatting for
 * TextField objects. You can apply Cascading Style Sheets(CSS) styles to
 * text fields by using the <code>TextField.styleSheet</code> property and the
 * StyleSheet class. You can use CSS to style built-in HTML tags, define new
 * formatting tags, or apply styles. You can assign HTML formatted text, which
 * optionally uses CSS styles, directly to a text field. HTML text that you
 * assign to a text field can contain embedded media(movie clips, SWF files,
 * GIF files, PNG files, and JPEG files). The text wraps around the embedded
 * media in the same way that a web browser wraps text around media embedded
 * in an HTML document. </p>
 *
 * <p>Flash Player supports a subset of HTML tags that you can use to format
 * text. See the list of supported HTML tags in the description of the
 * <code>htmlText</code> property.</p>
 *
 * @event change                    Dispatched after a control value is
 *                                  modified, unlike the
 *                                  <code>textInput</code> event, which is
 *                                  dispatched before the value is modified.
 *                                  Unlike the W3C DOM Event Model version of
 *                                  the <code>change</code> event, which
 *                                  dispatches the event only after the
 *                                  control loses focus, the ActionScript 3.0
 *                                  version of the <code>change</code> event
 *                                  is dispatched any time the control
 *                                  changes. For example, if a user types text
 *                                  into a text field, a <code>change</code>
 *                                  event is dispatched after every keystroke.
 * @event link                      Dispatched when a user clicks a hyperlink
 *                                  in an HTML-enabled text field, where the
 *                                  URL begins with "event:". The remainder of
 *                                  the URL after "event:" is placed in the
 *                                  text property of the LINK event.
 *
 *                                  <p><b>Note:</b> The default behavior,
 *                                  adding the text to the text field, occurs
 *                                  only when Flash Player generates the
 *                                  event, which in this case happens when a
 *                                  user attempts to input text. You cannot
 *                                  put text into a text field by sending it
 *                                  <code>textInput</code> events.</p>
 * @event scroll                    Dispatched by a TextField object
 *                                  <i>after</i> the user scrolls.
 * @event textInput                 Flash Player dispatches the
 *                                  <code>textInput</code> event when a user
 *                                  enters one or more characters of text.
 *                                  Various text input methods can generate
 *                                  this event, including standard keyboards,
 *                                  input method editors(IMEs), voice or
 *                                  speech recognition systems, and even the
 *                                  act of pasting plain text with no
 *                                  formatting or style information.
 * @event textInteractionModeChange Flash Player dispatches the
 *                                  <code>textInteractionModeChange</code>
 *                                  event when a user changes the interaction
 *                                  mode of a text field. for example on
 *                                  Android, one can toggle from NORMAL mode
 *                                  to SELECTION mode using context menu
 *                                  options
 */
var TextField = (function (_super) {
    __extends(TextField, _super);
    /**
     * Creates a new TextField instance. After you create the TextField instance,
     * call the <code>addChild()</code> or <code>addChildAt()</code> method of
     * the parent DisplayObjectContainer object to add the TextField instance to
     * the display list.
     *
     * <p>The default size for a text field is 100 x 100 pixels.</p>
     */
    function TextField() {
        var _this = _super.call(this) || this;
        _this._line_indices = [];
        _this._text = "";
        _this._textDirty = false; // if text is dirty, the text-content or the text-size has changed, and we need to recalculate word-width
        _this._positionsDirty = false; // if formatting is dirty, we need to recalculate text-positions / size
        _this._glyphsDirty = false; // if glyphs are dirty, we need to recollect the glyphdata and build the text-graphics. this should ony be done max once a frame
        _this.chars_codes = []; // stores charcode per char
        _this.chars_width = []; // stores charcode per char
        _this.words = []; // stores offset and length and width for each word
        _this._textRuns_formats = []; // stores textFormat for each textrun
        _this._textRuns_words = []; // stores words-offset, word-count and width for each textrun
        _this._maxWidthLine = 0;
        _this.textShapes = {};
        _this._textColor = -1;
        _this._width = 100;
        _this._height = 100;
        _this._textWidth = 0;
        _this._textHeight = 0;
        _this.type = TextFieldType.STATIC;
        _this._numLines = 0;
        _this.multiline = false;
        _this.selectable = true;
        _this._autoSize = TextFieldAutoSize.NONE;
        _this._wordWrap = false;
        _this._background = false;
        _this._backgroundColor = 0xffffff;
        _this._border = false;
        _this._borderColor = 0x000000;
        _this._graphics = _awayjs_graphics.Graphics.getGraphics(_this); //unique graphics object for each TextField
        return _this;
    }
    TextField.getNewTextField = function () {
        return (TextField._textFields.length) ? TextField._textFields.pop() : new TextField();
    };
    TextField.prototype.getTextShapeForIdentifierAndFormat = function (id, format) {
        if (this.textShapes.hasOwnProperty(id)) {
            return this.textShapes[id];
        }
        this.textShapes[id] = new TextShape();
        this.textShapes[id].format = format;
        return this.textShapes[id];
    };
    Object.defineProperty(TextField.prototype, "autoSize", {
        get: function () {
            return this._autoSize;
        },
        set: function (value) {
            if (this._autoSize == value)
                return;
            this._autoSize = value;
            this._positionsDirty = true;
            if (this._autoSize != TextFieldAutoSize.NONE)
                this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    TextField.prototype._pUpdateBoxBounds = function () {
        _super.prototype._pUpdateBoxBounds.call(this);
        this.reConstruct();
        this._pBoxBounds.x = 0;
        this._pBoxBounds.y = 0;
        this._pBoxBounds.width = this._width;
        this._pBoxBounds.height = this._height;
    };
    TextField.prototype.getBox = function (targetCoordinateSpace) {
        if (targetCoordinateSpace === void 0) { targetCoordinateSpace = null; }
        //TODO targetCoordinateSpace
        if (this._boxBoundsInvalid)
            this._pUpdateBoxBounds();
        if (targetCoordinateSpace == null || targetCoordinateSpace == this)
            return this._pBoxBounds;
        if (targetCoordinateSpace == this._pParent) {
            if (this._registrationMatrix3D) {
                if (this._tempTransform == null)
                    this._tempTransform = new _awayjs_core.Matrix3D();
                this._tempTransform.copyFrom(this._transform.matrix3D);
                this._tempTransform.prepend(this._registrationMatrix3D);
                if (this.alignmentMode != AlignmentMode.REGISTRATION_POINT)
                    this._tempTransform.appendTranslation(-this._registrationMatrix3D._rawData[12] * this._transform.scale.x, -this._registrationMatrix3D._rawData[13] * this._transform.scale.y, -this._registrationMatrix3D._rawData[14] * this._transform.scale.z);
                return this._tempTransform.transformBox(this._pBoxBounds);
            }
            return this._transform.matrix3D.transformBox(this._pBoxBounds);
        }
        else
            return targetCoordinateSpace.transform.inverseConcatenatedMatrix3D.transformBox(this.transform.concatenatedMatrix3D.transformBox(this._pBoxBounds));
    };
    Object.defineProperty(TextField.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return TextField.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "background", {
        get: function () {
            return this._background;
        },
        set: function (value) {
            this._background = value;
            this._glyphsDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "backgroundColor", {
        get: function () {
            return this._backgroundColor;
        },
        set: function (value) {
            this._backgroundColor = value;
            this._glyphsDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "border", {
        get: function () {
            return this._border;
        },
        set: function (value) {
            this._border = value;
            this._glyphsDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "borderColor", {
        get: function () {
            return this._borderColor;
        },
        set: function (value) {
            this._borderColor = value;
            this._glyphsDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "bottomScrollV", {
        /**
         * An integer(1-based index) that indicates the bottommost line that is
         * currently visible in the specified text field. Think of the text field as
         * a window onto a block of text. The <code>scrollV</code> property is the
         * 1-based index of the topmost visible line in the window.
         *
         * <p>All the text between the lines indicated by <code>scrollV</code> and
         * <code>bottomScrollV</code> is currently visible in the text field.</p>
         */
        get: function () {
            return this._bottomScrollV;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "caretIndex", {
        /**
         * The index of the insertion point(caret) position. If no insertion point
         * is displayed, the value is the position the insertion point would be if
         * you restored focus to the field(typically where the insertion point last
         * was, or 0 if the field has not had focus).
         *
         * <p>Selection span indexes are zero-based(for example, the first position
         * is 0, the second position is 1, and so on).</p>
         */
        get: function () {
            return this._caretIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "defaultTextFormat", {
        get: function () {
            if (this._defaultTextFormat == null) {
                this._defaultTextFormat = new TextFormat();
            }
            return this._defaultTextFormat;
        },
        set: function (value) {
            if (this._defaultTextFormat == value)
                return;
            this._defaultTextFormat = value;
            this._textDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "height", {
        /**
         *
         */
        get: function () {
            if (this._autoSize != TextFieldAutoSize.NONE)
                this.reConstruct();
            return this._height;
        },
        set: function (val) {
            if (this._height == val)
                return;
            if (this._autoSize != TextFieldAutoSize.NONE)
                return;
            this._height = val;
            this._positionsDirty = true;
            this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "length", {
        /**
         * The number of characters in a text field. A character such as tab
         * (<code>\t</code>) counts as one character.
         */
        get: function () {
            return this._text.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * The maximum value of <code>scrollH</code>.
     */
    TextField.prototype.maxScrollH = function () {
        return this._maxScrollH;
    };
    /**
     * The maximum value of <code>scrollV</code>.
     */
    TextField.prototype.maxScrollV = function () {
        return this._maxScrollV;
    };
    Object.defineProperty(TextField.prototype, "numLines", {
        /**
         * Defines the number of text lines in a multiline text field. If
         * <code>wordWrap</code> property is set to <code>true</code>, the number of
         * lines increases when text wraps.
         */
        get: function () {
            this.reConstruct();
            return this._numLines;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "selectionBeginIndex", {
        /**
         * The zero-based character index value of the first character in the current
         * selection. For example, the first character is 0, the second character is
         * 1, and so on. If no text is selected, this property is the value of
         * <code>caretIndex</code>.
         */
        get: function () {
            return this._selectionBeginIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "selectionEndIndex", {
        /**
         * The zero-based character index value of the last character in the current
         * selection. For example, the first character is 0, the second character is
         * 1, and so on. If no text is selected, this property is the value of
         * <code>caretIndex</code>.
         */
        get: function () {
            return this._selectionEndIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "text", {
        /**
         * A string that is the current text in the text field. Lines are separated
         * by the carriage return character(<code>'\r'</code>, ASCII 13). This
         * property contains unformatted text in the text field, without HTML tags.
         *
         * <p>To get the text in HTML form, use the <code>htmlText</code>
         * property.</p>
         */
        get: function () {
            return this._text;
        },
        set: function (value) {
            value = value.toString();
            if (this._text == value)
                return;
            this._text = value;
            this._textDirty = true;
            if (this._autoSize != TextFieldAutoSize.NONE)
                this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "textFormat", {
        get: function () {
            if (this._textFormat == null) {
                this._textFormat = new TextFormat();
            }
            return this._textFormat;
        },
        set: function (value) {
            this._textDirty = true;
            this._textFormat = value;
            //this.reConstruct();
            if (this._autoSize != TextFieldAutoSize.NONE)
                this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    TextField.prototype._hitTestPointInternal = function (x, y, shapeFlag, masksFlag) {
        if (this._graphics.count) {
            if (this._graphics._hitTestPointInternal(this._tempPoint.x, this._tempPoint.y))
                return true;
        }
        return false;
    };
    /**
     *
     * @param renderer
     *
     * @internal
     */
    TextField.prototype._acceptTraverser = function (traverser) {
        this.reConstruct(true);
        if (this._textFormat && !this._textFormat.font_table.isAsset(TesselatedFontTable) && !this._textFormat.material) {
            var new_ct = this.transform.colorTransform || (this.transform.colorTransform = new _awayjs_core.ColorTransform());
            //if(new_ct.color==0xffffff){
            this.transform.colorTransform.color = (this.textColor != null) ? this.textColor : this._textFormat.color;
            this.pInvalidateHierarchicalProperties(HierarchicalProperties.COLOR_TRANSFORM);
        }
        this._graphics.acceptTraverser(traverser);
    };
    Object.defineProperty(TextField.prototype, "scaleX", {
        /**
         * Indicates the horizontal scale(percentage) of the object as applied from
         * the registration point. The default registration point is(0,0). 1.0
         * equals 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code> and
         * <code>y</code> property values, which are defined in whole pixels. </p>
         */
        get: function () {
            return this._transform.scale.x;
        },
        set: function (val) {
            this._setScaleX(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "scaleY", {
        /**
         * Indicates the vertical scale(percentage) of an object as applied from the
         * registration point of the object. The default registration point is(0,0).
         * 1.0 is 100% scale.
         *
         * <p>Scaling the local coordinate system changes the <code>x</code> and
         * <code>y</code> property values, which are defined in whole pixels. </p>
         */
        get: function () {
            return this._transform.scale.y;
        },
        set: function (val) {
            this._setScaleY(val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "textColor", {
        get: function () {
            return this._textColor;
        },
        set: function (value) {
            this._textColor = value;
            //this._textFormat.color=value;
            if (this._textFormat && !this._textFormat.font_table.isAsset(TesselatedFontTable) && !this._textFormat.material) {
                if (!this.transform.colorTransform)
                    this.transform.colorTransform = new _awayjs_core.ColorTransform();
                this.transform.colorTransform.color = value;
                this.pInvalidateHierarchicalProperties(HierarchicalProperties.COLOR_TRANSFORM);
            }
            else {
                this._glyphsDirty = true;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "textInteractionMode", {
        /**
         * The interaction mode property, Default value is
         * TextInteractionMode.NORMAL. On mobile platforms, the normal mode implies
         * that the text can be scrolled but not selected. One can switch to the
         * selectable mode through the in-built context menu on the text field. On
         * Desktop, the normal mode implies that the text is in scrollable as well as
         * selection mode.
         */
        get: function () {
            return this._textInteractionMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "textWidth", {
        /**
         * The width of the text in pixels.
         */
        get: function () {
            this.reConstruct();
            return this._textWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "textHeight", {
        /**
         * The width of the text in pixels.
         */
        get: function () {
            this.reConstruct();
            return this._textHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "x", {
        get: function () {
            if (this._autoSize != TextFieldAutoSize.NONE && !this._wordWrap)
                this.reConstruct();
            return this._transform.position.x;
        },
        set: function (val) {
            if (this._autoSize != TextFieldAutoSize.NONE && !this._wordWrap)
                this.reConstruct();
            if (this._transform.position.x == val)
                return;
            this._transform.matrix3D._rawData[12] = val;
            this._transform.invalidatePosition();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "width", {
        /**
         *
         */
        get: function () {
            if (this._autoSize != TextFieldAutoSize.NONE && !this._wordWrap)
                this.reConstruct();
            return this._width;
        },
        set: function (val) {
            if (this._width == val)
                return;
            if (this._autoSize != TextFieldAutoSize.NONE && !this._wordWrap)
                return;
            this._width = val;
            this._positionsDirty = true;
            this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "wordWrap", {
        /**
         * The width of the text in pixels.
         */
        get: function () {
            return this._wordWrap;
        },
        set: function (val) {
            if (this._wordWrap == val)
                return;
            this._wordWrap = val;
            this._positionsDirty = true;
            if (!val)
                this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextField.prototype, "isEntity", {
        /**
         *
         */
        get: function () {
            return true; //TODO do this better
        },
        enumerable: true,
        configurable: true
    });
    TextField.prototype.clear = function () {
        _super.prototype.clear.call(this);
        if (this._textElements)
            this._textElements.clear();
    };
    /**
     * @inheritDoc
     */
    TextField.prototype.dispose = function () {
        this.disposeValues();
        TextField._textFields.push(this);
    };
    /**
     * @inheritDoc
     */
    TextField.prototype.disposeValues = function () {
        _super.prototype.disposeValues.call(this);
        this._textFormat = null;
        this._textShape = null;
        this._textShape2 = null;
        if (this._textElements) {
            this._textElements.dispose();
            this._textElements = null;
        }
        if (this._textElements2) {
            this._textElements2.dispose();
            this._textElements2 = null;
        }
    };
    /**
     * Reconstructs the Graphics for this Text-field.
     */
    TextField.prototype.reConstruct = function (buildGraphics) {
        if (buildGraphics === void 0) { buildGraphics = false; }
        if (!this._textDirty && !this._positionsDirty && !this._glyphsDirty)
            return;
        // Step1: init text-data
        // this step splits the text into textRuns
        // each textRun spans a range of words that share the same text-format
        // a textRun can not be shared between paragraphs
        // for each word, 5 numbers are stored:
        // 		char-index,
        // 		x-pos,
        // 		y-pos,
        // 		word-width,
        // 		char-count,
        // a whitespace is considered as a word
        if (this._textDirty) {
            this._positionsDirty = true;
            this.chars_codes.length = 0;
            this.chars_width.length = 0;
            this.words.length = 0;
            this._textRuns_words.length = 0;
            this._textRuns_formats.length = 0;
            this._maxWidthLine = 0;
            if (this._text != "" && this._textFormat != null) {
                if (this.multiline) {
                    var paragraphs = this.text.toString().split("\\n");
                    var tl = 0;
                    var tl_len = paragraphs.length;
                    var extra_split;
                    var tl_extra = 0;
                    var tl_extra_len = paragraphs.length;
                    for (tl = 0; tl < tl_len; tl++) {
                        extra_split = paragraphs[tl].split("\n"); //match(/[^\r\n]+/g));
                        if (extra_split) {
                            tl_extra_len = extra_split.length;
                            for (tl_extra = 0; tl_extra < tl_extra_len; tl_extra++) {
                                this.buildParagraph(extra_split[tl_extra]);
                            }
                        }
                        else {
                            this.buildParagraph(paragraphs[tl]);
                        }
                    }
                }
                else {
                    var paragraphs = this.text.toString().split("\\n");
                    var tl = 0;
                    var tl_len = paragraphs.length;
                    for (tl = 0; tl < tl_len; tl++) {
                        this.buildParagraph(paragraphs[tl]);
                    }
                }
            }
        }
        // 	Step 2: positioning the words
        // 	if position is dirty, the text formatting has changed.
        // 	this step will modify the word-data stored in previous step.
        //	for each word, it adjusts the x-pos and y-pos position.
        //	this step also takes care of adjusting the textWidth and textHeight,
        //	if we have AUTOSIZE!=None
        if (this._positionsDirty) {
            this._glyphsDirty = true;
            if (this._text != "" && this._textFormat != null) {
                //console.log("TextField getWordPositions", this.id, this.words);
                this.getWordPositions();
            }
            else {
                // this is empty text, we need to reset the text-size
                this._textWidth = 0;
                this._textHeight = 0;
                if (this._autoSize != TextFieldAutoSize.NONE) {
                    this._width = 4;
                    this._height = 4;
                    this._pInvalidateBounds();
                }
            }
        }
        this._textDirty = false;
        this._positionsDirty = false;
        if (!buildGraphics)
            return;
        // 	Step 3: building the glyphs
        // 	this step is only done if this function was called when renderer collects the graphics.
        //	only than should the reconstruct function be called with "buildGraphics=true".
        // 	in this step, the text-shapes are cleared,
        //	the data for new text-shapes is collected from the font-tables
        //	and the new text-shapes are created and assigned to the graphics
        if (this._glyphsDirty) {
            //console.log("TextField buildGlyphs", this.id, this.words);
            this.buildGlyphs();
        }
        this._glyphsDirty = false;
    };
    TextField.prototype.buildParagraph = function (paragraphText) {
        // todo: support multiple textFormat per paragraph (multiple textRuns)
        this._textRuns_formats[this._textRuns_formats.length] = this._textFormat;
        this._textRuns_words[this._textRuns_words.length] = this.words.length;
        var c = 0;
        var c_len = paragraphText.length;
        var char_code = 0;
        var char_width = 0;
        var word_cnt = 0;
        var startNewWord = true;
        this._textFormat.font_table.initFontSize(this._textFormat.size);
        // splits the text into words and create the textRuns along the way.
        var linewidh = 0;
        var whitespace_cnt = 0;
        for (c = 0; c < c_len; c++) {
            char_code = paragraphText.charCodeAt(c);
            this.chars_codes[this.chars_codes.length] = char_code;
            char_width = this._textFormat.font_table.getCharWidth(char_code.toString());
            if (char_width <= 0) {
                char_width = this._textFormat.font_table.getCharWidth("32");
            }
            // if this is a letter, and next symbol is a letter, we add the letterSpacing to the letter-width
            if (char_code != 32 && c < c_len - 1) {
                char_width += (paragraphText.charCodeAt(c + 1) == 32) ? 0 : this._textFormat.letterSpacing;
            }
            linewidh += char_width;
            this.chars_width[this.chars_width.length] = char_width;
            if (char_code == 32) {
                whitespace_cnt++;
                // if this is a whitespace, we add a new word,
                this.words[this.words.length] = this.chars_codes.length - 1; //offset into chars
                this.words[this.words.length] = 0; //x-position
                this.words[this.words.length] = 0; //y-position
                this.words[this.words.length] = char_width;
                this.words[this.words.length] = 1;
                word_cnt++;
                // we also make sure to begin a new word for next char (could be whitespace again)
                startNewWord = true;
            }
            else {
                // no whitespace
                if (startNewWord) {
                    // create new word (either this is the first char, or the last char was whitespace)
                    this.words[this.words.length] = this.chars_codes.length - 1;
                    this.words[this.words.length] = 0; //x-position
                    this.words[this.words.length] = 0; //y-position
                    this.words[this.words.length] = char_width;
                    this.words[this.words.length] = 1;
                    word_cnt++;
                }
                else {
                    // update-char length and width of active word.
                    this.words[this.words.length - 2] += char_width;
                    this.words[this.words.length - 1]++;
                }
                startNewWord = false;
            }
        }
        this._textRuns_words[this._textRuns_words.length] = word_cnt;
        this._textRuns_words[this._textRuns_words.length] = linewidh;
        this._textRuns_words[this._textRuns_words.length] = whitespace_cnt;
        if (this._maxWidthLine < linewidh) {
            this._maxWidthLine = linewidh;
        }
    };
    TextField.prototype.getWordPositions = function () {
        /*console.log("this._text", this._text);
        console.log("this._width", this._width);
        console.log("this._height", this._height);*/
        var tr = 0;
        var tr_len = this._textRuns_formats.length;
        var w = 0;
        var w_len = 0;
        var tr_length = 0;
        var additionalWhiteSpace = 0;
        var format;
        var text_width = 0;
        var text_height = 0;
        var indent = 0;
        this._numLines = 0;
        var linecnt = 0;
        var linelength = 0;
        var word_width = 0;
        var lineWordStartIndices = [];
        var lineWordEndIndices = [];
        var lineLength = [];
        var numSpacesPerline = [];
        var offsety = 2;
        // if we have autosize enabled, and no wordWrap, we can adjust the textfield width
        if (this._autoSize != TextFieldAutoSize.NONE && !this._wordWrap && this._textDirty) {
            var oldSize = this._width;
            this._width = 4 + this._maxWidthLine + this._textFormat.indent + this._textFormat.leftMargin + this._textFormat.rightMargin;
            this._pInvalidateBounds();
            if (this._autoSize == TextFieldAutoSize.RIGHT) {
                this._transform.matrix3D._rawData[12] -= this._width - oldSize;
                this._transform.invalidatePosition();
            }
            else if (this._autoSize == TextFieldAutoSize.CENTER) {
                this._transform.matrix3D._rawData[12] -= (this._width - oldSize) / 2;
                this._transform.invalidatePosition();
            }
        }
        var maxLineWidth = this._width - (4 + this._textFormat.indent + this._textFormat.leftMargin + this._textFormat.rightMargin);
        for (tr = 0; tr < tr_len; tr++) {
            format = this._textRuns_formats[tr];
            format.font_table.initFontSize(format.size);
            indent = this._textFormat.indent;
            lineWordStartIndices.length = 1;
            lineWordEndIndices.length = 1;
            lineLength.length = 1;
            numSpacesPerline.length = 1;
            var line_width = 0;
            w_len = this._textRuns_words[(tr * 4)] + (this._textRuns_words[(tr * 4) + 1] * 5);
            tr_length = this._textRuns_words[(tr * 4) + 2];
            //console.log(this._textFieldWidth, tr_length, maxLineWidth);
            //80pro: change for icycle:
            if (!this.multiline || tr_length <= maxLineWidth || !this.wordWrap) {
                //if(tr_length<maxLineWidth || !this.wordWrap){
                // this must be a single textline
                //console.log("one line");
                lineWordStartIndices[0] = this._textRuns_words[(tr * 4)];
                lineWordEndIndices[0] = w_len;
                lineLength[0] = tr_length;
                numSpacesPerline[0] = 0;
            }
            else {
                //console.log("split lines");
                linecnt = 0;
                linelength = 0;
                word_width = 0;
                indent = 0;
                lineWordStartIndices[0] = this._textRuns_words[(tr * 4)];
                lineWordEndIndices[0] = 0;
                lineLength[0] = 0;
                numSpacesPerline[0] = 0;
                for (w = this._textRuns_words[(tr * 4)]; w < w_len; w += 5) {
                    word_width = this.words[w + 3];
                    linelength += word_width;
                    if (linelength <= (maxLineWidth - indent) || lineLength[linecnt] == 0) {
                        lineWordEndIndices[linecnt] = w + 5;
                        lineLength[linecnt] += word_width;
                    }
                    else {
                        linelength = word_width;
                        linecnt++;
                        lineWordStartIndices[linecnt] = w;
                        lineWordEndIndices[linecnt] = w + 5;
                        lineLength[linecnt] = word_width;
                        numSpacesPerline[linecnt] = 0;
                        indent = this._textFormat.indent;
                    }
                    if (this.chars_codes[this.words[w]] == 32) {
                        numSpacesPerline[linecnt] += 1;
                    }
                }
            }
            var offsetx = 0;
            var start_idx;
            var start_idx;
            var numSpaces;
            var end_idx;
            var lineSpaceLeft;
            var l;
            var l_cnt = lineWordStartIndices.length;
            this._numLines = l_cnt;
            for (l = 0; l < l_cnt; l++) {
                linelength = lineLength[l];
                start_idx = lineWordStartIndices[l];
                end_idx = lineWordEndIndices[l];
                numSpaces = numSpacesPerline[l];
                lineSpaceLeft = maxLineWidth - linelength;
                /*console.log("lineSpaceLeft", lineSpaceLeft);
                console.log("maxLineWidth", maxLineWidth);
                console.log("linelength", linelength);*/
                additionalWhiteSpace = 0;
                offsetx = 2 + format.leftMargin + format.indent;
                if (format.align == "justify") {
                    if ((l != l_cnt - 1) && lineSpaceLeft > 0 && numSpaces > 0) {
                        // this is a textline that should be justified
                        additionalWhiteSpace = lineSpaceLeft / numSpacesPerline[l];
                    }
                    if (l != 0) {
                        // only first line has indent
                        offsetx -= format.indent;
                    }
                }
                else if (format.align == "center") {
                    offsetx += lineSpaceLeft / 2;
                }
                else if (format.align == "right") {
                    offsetx += lineSpaceLeft;
                }
                line_width = 0;
                line_width += format.leftMargin + format.indent + format.rightMargin;
                for (w = start_idx; w < end_idx; w += 5) {
                    this.words[w + 1] = offsetx;
                    this.words[w + 2] = offsety;
                    offsetx += this.words[w + 3];
                    line_width += this.words[w + 3];
                    if (format.align == "justify" && this.chars_codes[this.words[w]] == 32) {
                        // this is whitepace, we need to add extra space for justified text
                        offsetx += additionalWhiteSpace;
                    }
                }
                offsety += format.font_table.getLineHeight() + format.leading;
                /* enable for icycle:*/
                if (format.leading == 11 && format.font_name == "DayPosterBlack") {
                    offsety += 1.5;
                }
                if (line_width > text_width) {
                    text_width = line_width;
                }
            }
        }
        // -2 so this values do not include the left and top border
        this._textWidth = text_width;
        this._textHeight = offsety;
        //console.log(this._textWidth, "/", this._textHeight);
        //this._textWidth+=this._textFormat.indent+ this._textFormat.leftMargin+ this._textFormat.rightMargin;
        // if autosize is enabled, we adjust the textFieldHeight
        if (this.autoSize != TextFieldAutoSize.NONE) {
            this._height = this._textHeight + 4;
            this._pInvalidateBounds();
        }
    };
    TextField.prototype.buildGlyphs = function () {
        var textShape;
        for (var key in this.textShapes) {
            textShape = this.textShapes[key];
            this._graphics.removeShape(textShape.shape);
            _awayjs_graphics.Shape.storeShape(textShape.shape);
            textShape.shape.dispose();
            textShape.shape = null;
            textShape.elements.clear();
            textShape.elements.dispose();
            textShape.elements = null;
            textShape.verts.length = 0;
        }
        this.textShapes = {};
        this._graphics.clear();
        if (this._background || this._border) {
            if (this._background)
                this._graphics.beginFill(this._backgroundColor, 1); //this.background?1:0);
            if (this._border)
                this._graphics.lineStyle(1, this._borderColor, 1); //this.borderColor, this.border?1:0);
            this._graphics.drawRect(0, 0, this._width, this._height);
            this._graphics.endFill();
        }
        var textShape;
        // process all textRuns
        var tr = 0;
        var tr_len = this._textRuns_formats.length;
        for (tr = 0; tr < tr_len; tr++) {
            this._textRuns_formats[tr].font_table.initFontSize(this._textRuns_formats[tr].size);
            this._textRuns_formats[tr].font_table.fillTextRun(this, this._textRuns_formats[tr], this._textRuns_words[(tr * 4)], this._textRuns_words[(tr * 4) + 1]);
        }
        for (var key in this.textShapes) {
            textShape = this.textShapes[key];
            var attr_length = 2; //(tess_fontTable.usesCurves)?3:2;
            var attributesView = new _awayjs_core.AttributesView(Float32Array, attr_length);
            attributesView.set(textShape.verts);
            var vertexBuffer = attributesView.attributesBuffer;
            attributesView.dispose();
            textShape.elements = new _awayjs_graphics.TriangleElements(vertexBuffer);
            textShape.elements.setPositions(new _awayjs_core.Float2Attributes(vertexBuffer));
            //if(tess_fontTable.usesCurves){
            //	this._textElements.setCustomAttributes("curves", new Byte4Attributes(vertexBuffer, false));
            //}
            textShape.shape = this._graphics.addShape(_awayjs_graphics.Shape.getShape(textShape.elements));
            var sampler = new _awayjs_graphics.Sampler2D();
            textShape.shape.style = new _awayjs_graphics.Style();
            if (textShape.format.material && this._textColor == -1) {
                textShape.shape.material = this._textFormat.material;
                textShape.shape.style.addSamplerAt(sampler, textShape.shape.material.getTextureAt(0));
                textShape.shape.material.animateUVs = true;
                textShape.shape.style.uvMatrix = new _awayjs_core.Matrix(0, 0, 0, 0, textShape.format.uv_values[0], textShape.format.uv_values[1]);
            }
            else {
                var obj = _awayjs_graphics.Graphics.get_material_for_color(this._textColor == -1 ? textShape.format.color : this._textColor, 1);
                textShape.shape.material = obj.material;
                if (obj.colorPos) {
                    textShape.shape.style.addSamplerAt(sampler, textShape.shape.material.getTextureAt(0));
                    textShape.shape.material.animateUVs = true;
                    textShape.shape.style.uvMatrix = new _awayjs_core.Matrix(0, 0, 0, 0, obj.colorPos.x, obj.colorPos.y);
                }
            }
        }
    };
    /**
     * Appends the string specified by the <code>newText</code> parameter to the
     * end of the text of the text field. This method is more efficient than an
     * addition assignment(<code>+=</code>) on a <code>text</code> property
     * (such as <code>someTextField.text += moreText</code>), particularly for a
     * text field that contains a significant amount of content.
     *
     * @param newText The string to append to the existing text.
     */
    TextField.prototype.appendText = function (newText) {
        this._text += newText;
        this._textDirty = true;
        if (this._autoSize != TextFieldAutoSize.NONE)
            this._pInvalidateBounds();
    };
    /**
     * *tells the Textfield that a paragraph is defined completly.
     * e.g. the textfield will start a new line for future added text.
     */
    TextField.prototype.closeParagraph = function () {
        this._text += "\n";
        this._textDirty = true;
        //TODO
        if (this._autoSize != TextFieldAutoSize.NONE)
            this._pInvalidateBounds();
    };
    /**
     * Returns a rectangle that is the bounding box of the character.
     *
     * @param charIndex The zero-based index value for the character(for
     *                  example, the first position is 0, the second position is
     *                  1, and so on).
     * @return A rectangle with <code>x</code> and <code>y</code> minimum and
     *         maximum values defining the bounding box of the character.
     */
    TextField.prototype.getCharBoundaries = function (charIndex) {
        return this._charBoundaries;
    };
    /**
     * Returns the zero-based index value of the character at the point specified
     * by the <code>x</code> and <code>y</code> parameters.
     *
     * @param x The <i>x</i> coordinate of the character.
     * @param y The <i>y</i> coordinate of the character.
     * @return The zero-based index value of the character(for example, the
     *         first position is 0, the second position is 1, and so on). Returns
     *         -1 if the point is not over any character.
     */
    TextField.prototype.getCharIndexAtPoint = function (x, y) {
        return this._charIndexAtPoint;
    };
    /**
     * Given a character index, returns the index of the first character in the
     * same paragraph.
     *
     * @param charIndex The zero-based index value of the character(for example,
     *                  the first character is 0, the second character is 1, and
     *                  so on).
     * @return The zero-based index value of the first character in the same
     *         paragraph.
     * @throws RangeError The character index specified is out of range.
     */
    TextField.prototype.getFirstCharInParagraph = function (charIndex /*int*/) {
        return this._firstCharInParagraph;
    };
    /**
     * Returns a DisplayObject reference for the given <code>id</code>, for an
     * image or SWF file that has been added to an HTML-formatted text field by
     * using an <code><img></code> tag. The <code><img></code> tag is in the
     * following format:
     *
     * <p><pre xml:space="preserve"><code> <img src = 'filename.jpg' id =
     * 'instanceName' ></code></pre></p>
     *
     * @param id The <code>id</code> to match(in the <code>id</code> attribute
     *           of the <code><img></code> tag).
     * @return The display object corresponding to the image or SWF file with the
     *         matching <code>id</code> attribute in the <code><img></code> tag
     *         of the text field. For media loaded from an external source, this
     *         object is a Loader object, and, once loaded, the media object is a
     *         child of that Loader object. For media embedded in the SWF file,
     *         it is the loaded object. If no <code><img></code> tag with the
     *         matching <code>id</code> exists, the method returns
     *         <code>null</code>.
     */
    TextField.prototype.getImageReference = function (id) {
        return this._imageReference;
    };
    /**
     * Returns the zero-based index value of the line at the point specified by
     * the <code>x</code> and <code>y</code> parameters.
     *
     * @param x The <i>x</i> coordinate of the line.
     * @param y The <i>y</i> coordinate of the line.
     * @return The zero-based index value of the line(for example, the first
     *         line is 0, the second line is 1, and so on). Returns -1 if the
     *         point is not over any line.
     */
    TextField.prototype.getLineIndexAtPoint = function (x, y) {
        return this._lineIndexAtPoint;
    };
    /**
     * Returns the zero-based index value of the line containing the character
     * specified by the <code>charIndex</code> parameter.
     *
     * @param charIndex The zero-based index value of the character(for example,
     *                  the first character is 0, the second character is 1, and
     *                  so on).
     * @return The zero-based index value of the line.
     * @throws RangeError The character index specified is out of range.
     */
    TextField.prototype.getLineIndexOfChar = function (charIndex /*int*/) {
        return this._lineIndexOfChar;
    };
    /**
     * Returns the number of characters in a specific text line.
     *
     * @param lineIndex The line number for which you want the length.
     * @return The number of characters in the line.
     * @throws RangeError The line number specified is out of range.
     */
    TextField.prototype.getLineLength = function (lineIndex /*int*/) {
        return this._lineLength;
    };
    /**
     * Returns metrics information about a given text line.
     *
     * @param lineIndex The line number for which you want metrics information.
     * @return A TextLineMetrics object.
     * @throws RangeError The line number specified is out of range.
     */
    TextField.prototype.getLineMetrics = function (lineIndex /*int*/) {
        return this._lineMetrics;
    };
    /**
     * Returns the character index of the first character in the line that the
     * <code>lineIndex</code> parameter specifies.
     *
     * @param lineIndex The zero-based index value of the line(for example, the
     *                  first line is 0, the second line is 1, and so on).
     * @return The zero-based index value of the first character in the line.
     * @throws RangeError The line number specified is out of range.
     */
    TextField.prototype.getLineOffset = function (lineIndex /*int*/) {
        return this._lineOffset;
    };
    /**
     * Returns the text of the line specified by the <code>lineIndex</code>
     * parameter.
     *
     * @param lineIndex The zero-based index value of the line(for example, the
     *                  first line is 0, the second line is 1, and so on).
     * @return The text string contained in the specified line.
     * @throws RangeError The line number specified is out of range.
     */
    TextField.prototype.getLineText = function (lineIndex /*int*/) {
        return this._lineText;
    };
    /**
     * Given a character index, returns the length of the paragraph containing
     * the given character. The length is relative to the first character in the
     * paragraph(as returned by <code>getFirstCharInParagraph()</code>), not to
     * the character index passed in.
     *
     * @param charIndex The zero-based index value of the character(for example,
     *                  the first character is 0, the second character is 1, and
     *                  so on).
     * @return Returns the number of characters in the paragraph.
     * @throws RangeError The character index specified is out of range.
     */
    TextField.prototype.getParagraphLength = function (charIndex /*int*/) {
        return this._paragraphLength;
    };
    /**
     * Returns a TextFormat object that contains formatting information for the
     * range of text that the <code>beginIndex</code> and <code>endIndex</code>
     * parameters specify. Only properties that are common to the entire text
     * specified are set in the resulting TextFormat object. Any property that is
     * <i>mixed</i>, meaning that it has different values at different points in
     * the text, has a value of <code>null</code>.
     *
     * <p>If you do not specify values for these parameters, this method is
     * applied to all the text in the text field. </p>
     *
     * <p>The following table describes three possible usages:</p>
     *
     * @return The TextFormat object that represents the formatting properties
     *         for the specified text.
     * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
     *                    specified is out of range.
     */
    TextField.prototype.getTextFormat = function (beginIndex, endIndex) {
        if (beginIndex === void 0) { beginIndex = -1; }
        if (endIndex === void 0) { endIndex = -1; }
        return this._textFormat;
    };
    /**
     * Replaces the current selection with the contents of the <code>value</code>
     * parameter. The text is inserted at the position of the current selection,
     * using the current default character format and default paragraph format.
     * The text is not treated as HTML.
     *
     * <p>You can use the <code>replaceSelectedText()</code> method to insert and
     * delete text without disrupting the character and paragraph formatting of
     * the rest of the text.</p>
     *
     * <p><b>Note:</b> This method does not work if a style sheet is applied to
     * the text field.</p>
     *
     * @param value The string to replace the currently selected text.
     * @throws Error This method cannot be used on a text field with a style
     *               sheet.
     */
    TextField.prototype.replaceSelectedText = function (value) {
    };
    /**
     * Replaces the range of characters that the <code>beginIndex</code> and
     * <code>endIndex</code> parameters specify with the contents of the
     * <code>newText</code> parameter. As designed, the text from
     * <code>beginIndex</code> to <code>endIndex-1</code> is replaced.
     *
     * <p><b>Note:</b> This method does not work if a style sheet is applied to
     * the text field.</p>
     *
     * @param beginIndex The zero-based index value for the start position of the
     *                   replacement range.
     * @param endIndex   The zero-based index position of the first character
     *                   after the desired text span.
     * @param newText    The text to use to replace the specified range of
     *                   characters.
     * @throws Error This method cannot be used on a text field with a style
     *               sheet.
     */
    TextField.prototype.replaceText = function (beginIndex /*int*/, endIndex /*int*/, newText) {
    };
    /**
     * Sets as selected the text designated by the index values of the first and
     * last characters, which are specified with the <code>beginIndex</code> and
     * <code>endIndex</code> parameters. If the two parameter values are the
     * same, this method sets the insertion point, as if you set the
     * <code>caretIndex</code> property.
     *
     * @param beginIndex The zero-based index value of the first character in the
     *                   selection(for example, the first character is 0, the
     *                   second character is 1, and so on).
     * @param endIndex   The zero-based index value of the last character in the
     *                   selection.
     */
    TextField.prototype.setSelection = function (beginIndex /*int*/, endIndex /*int*/) {
    };
    /**
     * Applies the text formatting that the <code>format</code> parameter
     * specifies to the specified text in a text field. The value of
     * <code>format</code> must be a TextFormat object that specifies the desired
     * text formatting changes. Only the non-null properties of
     * <code>format</code> are applied to the text field. Any property of
     * <code>format</code> that is set to <code>null</code> is not applied. By
     * default, all of the properties of a newly created TextFormat object are
     * set to <code>null</code>.
     *
     * <p><b>Note:</b> This method does not work if a style sheet is applied to
     * the text field.</p>
     *
     * <p>The <code>setTextFormat()</code> method changes the text formatting
     * applied to a range of characters or to the entire body of text in a text
     * field. To apply the properties of format to all text in the text field, do
     * not specify values for <code>beginIndex</code> and <code>endIndex</code>.
     * To apply the properties of the format to a range of text, specify values
     * for the <code>beginIndex</code> and the <code>endIndex</code> parameters.
     * You can use the <code>length</code> property to determine the index
     * values.</p>
     *
     * <p>The two types of formatting information in a TextFormat object are
     * character level formatting and paragraph level formatting. Each character
     * in a text field can have its own character formatting settings, such as
     * font name, font size, bold, and italic.</p>
     *
     * <p>For paragraphs, the first character of the paragraph is examined for
     * the paragraph formatting settings for the entire paragraph. Examples of
     * paragraph formatting settings are left margin, right margin, and
     * indentation.</p>
     *
     * <p>Any text inserted manually by the user, or replaced by the
     * <code>replaceSelectedText()</code> method, receives the default text field
     * formatting for new text, and not the formatting specified for the text
     * insertion point. To set the default formatting for new text, use
     * <code>defaultTextFormat</code>.</p>
     *
     * @param format A TextFormat object that contains character and paragraph
     *               formatting information.
     * @throws Error      This method cannot be used on a text field with a style
     *                    sheet.
     * @throws RangeError The <code>beginIndex</code> or <code>endIndex</code>
     *                    specified is out of range.
     */
    TextField.prototype.setTextFormat = function (format, beginIndex, endIndex) {
        if (beginIndex === void 0) { beginIndex = -1; }
        if (endIndex === void 0) { endIndex = -1; }
    };
    /**
     * Returns true if an embedded font is available with the specified
     * <code>fontName</code> and <code>fontStyle</code> where
     * <code>Font.fontType</code> is <code>flash.text.FontType.EMBEDDED</code>.
     * Starting with Flash Player 10, two kinds of embedded fonts can appear in a
     * SWF file. Normal embedded fonts are only used with TextField objects. CFF
     * embedded fonts are only used with the flash.text.engine classes. The two
     * types are distinguished by the <code>fontType</code> property of the
     * <code>Font</code> class, as returned by the <code>enumerateFonts()</code>
     * function.
     *
     * <p>TextField cannot use a font of type <code>EMBEDDED_CFF</code>. If
     * <code>embedFonts</code> is set to <code>true</code> and the only font
     * available at run time with the specified name and style is of type
     * <code>EMBEDDED_CFF</code>, Flash Player fails to render the text, as if no
     * embedded font were available with the specified name and style.</p>
     *
     * <p>If both <code>EMBEDDED</code> and <code>EMBEDDED_CFF</code> fonts are
     * available with the same name and style, the <code>EMBEDDED</code> font is
     * selected and text renders with the <code>EMBEDDED</code> font.</p>
     *
     * @param fontName  The name of the embedded font to check.
     * @param fontStyle Specifies the font style to check. Use
     *                  <code>flash.text.FontStyle</code>
     * @return <code>true</code> if a compatible embedded font is available,
     *         otherwise <code>false</code>.
     * @throws ArgumentError The <code>fontStyle</code> specified is not a member
     *                       of <code>flash.text.FontStyle</code>.
     */
    TextField.isFontCompatible = function (fontName, fontStyle) {
        return false;
    };
    TextField.prototype.clone = function () {
        var newInstance = TextField.getNewTextField();
        this.copyTo(newInstance);
        return newInstance;
    };
    TextField.prototype.copyTo = function (newInstance) {
        _super.prototype.copyTo.call(this, newInstance);
        newInstance.width = this._width;
        newInstance.height = this._height;
        newInstance.textFormat = this._textFormat;
        //newInstance.textColor = this._textColor;
        newInstance.text = this._text;
    };
    return TextField;
}(DisplayObject));
TextField._textFields = [];
TextField.assetType = "[asset TextField]";

var MovieClip = (function (_super) {
    __extends(MovieClip, _super);
    function MovieClip(timeline) {
        if (timeline === void 0) { timeline = null; }
        var _this = _super.call(this) || this;
        _this._isButton = false;
        _this._time = 0; // the current time inside the animation
        _this._currentFrameIndex = -1; // the current frame
        _this._isPlaying = true; // false if paused or stopped
        _this._isInit = true;
        _this._potentialInstances = [];
        _this._depth_sessionIDs = {};
        _this._sessionID_childs = {};
        /**
         *
         */
        _this.loop = true;
        /**
         * the current index of the current active frame
         */
        _this.constructedKeyFrameIndex = -1;
        _this._enterFrame = new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.ENTER_FRAME, _this);
        _this.inheritColorTransform = true;
        // todo: allow to set cursor-types for movieclip
        _this._onMouseOver = function (event) {
            document.body.style.cursor = "pointer";
            _this.currentFrameIndex = 1;
        };
        _this._onMouseOut = function (event) {
            document.body.style.cursor = "initial";
            _this.currentFrameIndex = 0;
        };
        _this._onMouseDown = function (event) {
            document.body.style.cursor = "initial";
            _this.currentFrameIndex = 2;
        };
        _this._onMouseUp = function (event) {
            document.body.style.cursor = "initial";
            _this.currentFrameIndex = _this.currentFrameIndex == 0 ? 0 : 1;
        };
        _this._timeline = timeline || new Timeline();
        return _this;
    }
    MovieClip.getNewMovieClip = function (timeline) {
        if (timeline === void 0) { timeline = null; }
        return (MovieClip._movieClips.length) ? MovieClip._movieClips.pop() : new MovieClip(timeline);
    };
    MovieClip.prototype.dispose = function () {
        this.disposeValues();
        MovieClip._movieClips.push(this);
    };
    MovieClip.prototype.disposeValues = function () {
        _super.prototype.disposeValues.call(this);
        this._potentialInstances = [];
        this._depth_sessionIDs = {};
        this._sessionID_childs = {};
    };
    MovieClip.prototype.reset_textclones = function () {
        if (this.timeline) {
            var len = this._potentialInstances.length;
            for (var i = 0; i < len; i++) {
                if (this._potentialInstances[i] != null) {
                    if (this._potentialInstances[i].isAsset(TextField))
                        this._potentialInstances[i].text = this.timeline.getPotentialChildPrototype(i).text;
                    else if (this._potentialInstances[i].isAsset(MovieClip))
                        this._potentialInstances[i].reset_textclones();
                }
            }
        }
    };
    Object.defineProperty(MovieClip.prototype, "isInit", {
        get: function () {
            return this._isInit;
        },
        set: function (value) {
            this._isInit = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MovieClip.prototype, "timeline", {
        get: function () {
            return this._timeline;
        },
        set: function (value) {
            this._timeline = value;
            this.reset();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MovieClip.prototype, "numFrames", {
        get: function () {
            return this._timeline.numFrames;
        },
        enumerable: true,
        configurable: true
    });
    MovieClip.prototype.jumpToLabel = function (label) {
        // the timeline.jumpTolabel will set currentFrameIndex
        this._timeline.jumpToLabel(this, label);
    };
    MovieClip.prototype.reset = function () {
        _super.prototype.reset.call(this);
        // time only is relevant for the root mc, as it is the only one that executes the update function
        this._time = 0;
        if (this._adapter)
            this.adapter.freeFromScript();
        this.constructedKeyFrameIndex = -1;
        for (var i = this.numChildren - 1; i >= 0; i--)
            this.removeChildAt(i);
        this._skipAdvance = MovieClip._skipAdvance;
        var numFrames = this._timeline.keyframe_indices.length;
        this._isPlaying = Boolean(numFrames > 1);
        if (numFrames) {
            this._currentFrameIndex = 0;
            this._timeline.constructNextFrame(this, true, true);
        }
        else {
            this._currentFrameIndex = -1;
        }
    };
    MovieClip.prototype.resetSessionIDs = function () {
        this._depth_sessionIDs = {};
    };
    Object.defineProperty(MovieClip.prototype, "currentFrameIndex", {
        /*
        * Setting the currentFrameIndex will move the playhead for this movieclip to the new position
         */
        get: function () {
            return this._currentFrameIndex;
        },
        set: function (value) {
            //if currentFrame is set greater than the available number of
            //frames, the playhead is moved to the last frame in the timeline.
            //But because the frame specified was not a keyframe, no scripts are
            //executed, even if they exist on the last frame.
            var skip_script = false;
            var numFrames = this._timeline.keyframe_indices.length;
            if (!numFrames)
                return;
            if (value < 0) {
                value = 0;
            }
            else if (value >= numFrames) {
                value = numFrames - 1;
                skip_script = true;
            }
            if (this._currentFrameIndex == value)
                return;
            this._currentFrameIndex = value;
            //changing current frame will ignore advance command for that
            //update's advanceFrame function, unless advanceFrame has
            //already been executed
            this._skipAdvance = MovieClip._skipAdvance;
            this._timeline.gotoFrame(this, value, skip_script);
        },
        enumerable: true,
        configurable: true
    });
    MovieClip.prototype.addButtonListeners = function () {
        this._isButton = true;
        this.stop();
        this.addEventListener(MouseEvent.MOUSE_OVER, this._onMouseOver);
        this.addEventListener(MouseEvent.MOUSE_OUT, this._onMouseOut);
        this.addEventListener(MouseEvent.MOUSE_DOWN, this._onMouseDown);
        this.addEventListener(MouseEvent.MOUSE_UP, this._onMouseUp);
    };
    MovieClip.prototype.removeButtonListeners = function () {
        this.removeEventListener(MouseEvent.MOUSE_OVER, this._onMouseOver);
        this.removeEventListener(MouseEvent.MOUSE_OUT, this._onMouseOut);
        this.removeEventListener(MouseEvent.MOUSE_DOWN, this._onMouseDown);
        this.removeEventListener(MouseEvent.MOUSE_UP, this._onMouseUp);
    };
    MovieClip.prototype.getChildAtSessionID = function (sessionID) {
        return this._sessionID_childs[sessionID];
    };
    MovieClip.prototype.getSessionIDDepths = function () {
        return this._depth_sessionIDs;
    };
    MovieClip.prototype.addChildAtDepth = function (child, depth, replace) {
        if (replace === void 0) { replace = true; }
        child.reset(); // this takes care of transform and visibility
        return _super.prototype.addChildAtDepth.call(this, child, depth, replace);
    };
    MovieClip.prototype._addTimelineChildAt = function (child, depth, sessionID) {
        this._depth_sessionIDs[depth] = child._sessionID = sessionID;
        this._sessionID_childs[sessionID] = child;
        return this.addChildAtDepth(child, depth);
    };
    MovieClip.prototype.removeChildAtInternal = function (index) {
        var child = this._children[index];
        if (child._adapter)
            child.adapter.freeFromScript();
        this.adapter.unregisterScriptObject(child);
        //check to make sure _depth_sessionIDs wasn't modified with a new child
        if (this._depth_sessionIDs[child._depthID] == child._sessionID)
            delete this._depth_sessionIDs[child._depthID];
        delete this._sessionID_childs[child._sessionID];
        child._sessionID = -1;
        return _super.prototype.removeChildAtInternal.call(this, index);
    };
    Object.defineProperty(MovieClip.prototype, "assetType", {
        get: function () {
            return MovieClip.assetType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Starts playback of animation from current position
     */
    MovieClip.prototype.play = function () {
        if (this._timeline.keyframe_indices.length > 1)
            this._isPlaying = true;
    };
    /**
     * should be called right before the call to away3d-render.
     */
    MovieClip.prototype.update = function (events) {
        //if events is null, this is as2, if it is not null, this is as3web
        if (events === void 0) { events = null; }
        MovieClip._skipAdvance = true;
        if (events != null) {
            this.adapter.dispatchEvent(events[0]);
        }
        this.advanceFrame();
        MovieClip._skipAdvance = false;
        // after we advanced the scenegraph, we might have some script that needs executing
        FrameScriptManager.execute_queue();
        //this.dispatchEvent(this._enterFrame);
        // after we executed the onEnter, we might have some script that needs executing
        FrameScriptManager.execute_queue();
        // now we execute any intervals queued
        FrameScriptManager.execute_intervals();
        // finally, we execute any scripts that were added from intervals
        FrameScriptManager.execute_queue();
        //execute any disposes as a result of framescripts
        FrameScriptManager.execute_dispose();
        if (events != null) {
            this.adapter.dispatchEvent(events[1]);
        }
    };
    MovieClip.prototype.getPotentialChildInstance = function (id) {
        if (!this._potentialInstances[id])
            this._potentialInstances[id] = this._timeline.getPotentialChildInstance(id);
        return this._potentialInstances[id];
    };
    /**
     * Stop playback of animation and hold current position
     */
    MovieClip.prototype.stop = function () {
        this._isPlaying = false;
    };
    MovieClip.prototype.clone = function () {
        var newInstance = MovieClip.getNewMovieClip(this._timeline);
        this.copyTo(newInstance);
        return newInstance;
    };
    MovieClip.prototype.copyTo = function (newInstance) {
        _super.prototype.copyTo.call(this, newInstance);
        newInstance.timeline = this._timeline;
        newInstance.loop = this.loop;
    };
    MovieClip.prototype.advanceFrame = function () {
        if (this._isPlaying && !this._skipAdvance) {
            if (this._currentFrameIndex == this._timeline.keyframe_indices.length - 1) {
                if (this.loop)
                    this.currentFrameIndex = 0;
                else
                    this._isPlaying = false;
            }
            else {
                this._currentFrameIndex++;
                this._timeline.constructNextFrame(this);
            }
        }
        var len = this._children.length;
        var child;
        for (var i = 0; i < len; ++i) {
            child = this._children[i];
            if (child.isAsset(MovieClip))
                child.advanceFrame();
        }
        this.dispatchEvent(this._enterFrame);
        this._skipAdvance = false;
    };
    // DEBUG CODE:
    MovieClip.prototype.logHierarchy = function (depth) {
        if (depth === void 0) { depth = 0; }
        this.printHierarchyName(depth, this);
        var len = this._children.length;
        var child;
        for (var i = 0; i < len; i++) {
            child = this._children[i];
            if (child.isAsset(MovieClip))
                child.logHierarchy(depth + 1);
            else
                this.printHierarchyName(depth + 1, child);
        }
    };
    MovieClip.prototype.printHierarchyName = function (depth, target) {
        var str = "";
        for (var i = 0; i < depth; ++i)
            str += "--";
        str += " " + target.name + " = " + target.id;
        console.log(str);
    };
    MovieClip.prototype.clear = function () {
        //clear out potential instances
        var len = this._potentialInstances.length;
        for (var i = 0; i < len; i++) {
            var instance = this._potentialInstances[i];
            //only dispose instances that are not used in script ie. do not have an instance name
            if (instance && instance.name == "") {
                FrameScriptManager.add_child_to_dispose(instance);
                delete this._potentialInstances[i];
            }
        }
        _super.prototype.clear.call(this);
    };
    return MovieClip;
}(Sprite));
MovieClip._movieClips = new Array();
MovieClip.assetType = "[asset MovieClip]";

var CubeMapShadowMapper = (function (_super) {
    __extends(CubeMapShadowMapper, _super);
    function CubeMapShadowMapper() {
        var _this = _super.call(this) || this;
        _this._depthMapSize = 512;
        _this._needsRender = new Array();
        _this.initCameras();
        return _this;
    }
    CubeMapShadowMapper.prototype.initCameras = function () {
        this._depthProjections = new Array();
        // posX, negX, posY, negY, posZ, negZ
        this.addProjection(0, 90, 0);
        this.addProjection(0, -90, 0);
        this.addProjection(-90, 0, 0);
        this.addProjection(90, 0, 0);
        this.addProjection(0, 0, 0);
        this.addProjection(0, 180, 0);
    };
    CubeMapShadowMapper.prototype.addProjection = function (rotationX, rotationY, rotationZ) {
        var projection = new _awayjs_core.PerspectiveProjection();
        projection.transform.rotateTo(rotationX, rotationY, rotationZ);
        projection.near = .01;
        projection.fieldOfView = 90;
        this._depthProjections.push(projection);
    };
    /**
     *
     * @returns {SingleCubeTexture}
     * @private
     */
    CubeMapShadowMapper.prototype._createDepthTexture = function () {
        return new _awayjs_graphics.SingleCubeTexture(new _awayjs_graphics.ImageCube(this._depthMapSize));
    };
    /**
     *
     * @param projection
     * @private
     */
    CubeMapShadowMapper.prototype._updateDepthProjection = function (projection) {
        var light = (this._light);
        var maxDistance = light._pFallOff;
        var pos = this._light.scenePosition;
        // todo: faces outside frustum which are pointing away from camera need not be rendered!
        for (var i = 0; i < 6; ++i) {
            this._depthProjections[i].far = maxDistance;
            this._depthProjections[i].transform.moveTo(pos.x, pos.y, pos.z);
            this._needsRender[i] = true;
        }
    };
    /**
     *
     * @param view
     * @param target
     * @param renderer
     * @private
     */
    CubeMapShadowMapper.prototype._drawDepthMap = function (view, target, renderer) {
        for (var i = 0; i < 6; ++i)
            if (this._needsRender[i])
                renderer._iRender(this._depthProjections[i], view, target.imageCube, null, i);
    };
    return CubeMapShadowMapper;
}(ShadowMapperBase));

var PointLight = (function (_super) {
    __extends(PointLight, _super);
    function PointLight() {
        var _this = _super.call(this) || this;
        _this._pRadius = 90000;
        _this._pFallOff = 100000;
        _this._pIsEntity = true;
        _this._pFallOffFactor = 1 / (_this._pFallOff * _this._pFallOff - _this._pRadius * _this._pRadius);
        //default bounds type
        _this._boundsType = BoundsType.SPHERE;
        return _this;
    }
    Object.defineProperty(PointLight.prototype, "traverseName", {
        get: function () {
            return PointLight.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PointLight.prototype, "assetType", {
        get: function () {
            return PointLight.assetType;
        },
        enumerable: true,
        configurable: true
    });
    PointLight.prototype.pCreateShadowMapper = function () {
        return new CubeMapShadowMapper();
    };
    Object.defineProperty(PointLight.prototype, "radius", {
        get: function () {
            return this._pRadius;
        },
        set: function (value) {
            this._pRadius = value;
            if (this._pRadius < 0) {
                this._pRadius = 0;
            }
            else if (this._pRadius > this._pFallOff) {
                this._pFallOff = this._pRadius;
                this._pInvalidateBounds();
            }
            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
        },
        enumerable: true,
        configurable: true
    });
    PointLight.prototype.iFallOffFactor = function () {
        return this._pFallOffFactor;
    };
    Object.defineProperty(PointLight.prototype, "fallOff", {
        get: function () {
            return this._pFallOff;
        },
        set: function (value) {
            this._pFallOff = value;
            if (this._pFallOff < 0)
                this._pFallOff = 0;
            if (this._pFallOff < this._pRadius)
                this._pRadius = this._pFallOff;
            this._pFallOffFactor = 1 / (this._pFallOff * this._pFallOff - this._pRadius * this._pRadius);
            this._pInvalidateBounds();
        },
        enumerable: true,
        configurable: true
    });
    PointLight.prototype._pUpdateSphereBounds = function () {
        _super.prototype._pUpdateSphereBounds.call(this);
        this._pSphereBounds.radius = this._pFallOff;
    };
    PointLight.prototype.iGetObjectProjectionMatrix = function (displayObject, cameraTransform, target) {
        if (target === void 0) { target = null; }
        if (!target)
            target = new _awayjs_core.Matrix3D();
        var m = _awayjs_core.Matrix3D.CALCULATION_MATRIX;
        // todo: do not use lookAt on Light
        m.copyFrom(displayObject.getRenderSceneTransform(cameraTransform));
        m.append(this._pParent.transform.inverseConcatenatedMatrix3D);
        this.lookAt(m.position);
        m.copyFrom(displayObject.getRenderSceneTransform(cameraTransform));
        m.append(this.transform.inverseConcatenatedMatrix3D);
        var box = displayObject.getBox();
        var v1 = m.deltaTransformVector(new _awayjs_core.Vector3D(box.left, box.bottom, box.front));
        var v2 = m.deltaTransformVector(new _awayjs_core.Vector3D(box.right, box.top, box.back));
        var d1 = v1.x * v1.x + v1.y * v1.y + v1.z * v1.z;
        var d2 = v2.x * v2.x + v2.y * v2.y + v2.z * v2.z;
        var d = Math.sqrt(d1 > d2 ? d1 : d2);
        var zMin;
        var zMax;
        var z = m._rawData[14];
        zMin = z - d;
        zMax = z + d;
        var targetData = target._rawData;
        targetData[5] = targetData[0] = zMin / d;
        targetData[10] = zMax / (zMax - zMin);
        targetData[11] = 1;
        targetData[1] = targetData[2] = targetData[3] = targetData[4] = targetData[6] = targetData[7] = targetData[8] = targetData[9] = targetData[12] = targetData[13] = targetData[15] = 0;
        targetData[14] = -zMin * targetData[10];
        target.prepend(m);
        return target;
    };
    return PointLight;
}(LightBase));
PointLight.traverseName = _awayjs_graphics.TraverserBase.addEntityName("applyPointLight");
PointLight.assetType = "[light PointLight]";

/**
 * A Skybox class is used to render a sky in the scene. It's always considered static and 'at infinity', and as
 * such it's always centered at the camera's position and sized to exactly fit within the camera's frustum, ensuring
 * the sky box is always as large as possible without being clipped.
 */
var Skybox = (function (_super) {
    __extends(Skybox, _super);
    /**
     * Create a new Skybox object.
     *
     * @param material	The material with which to render the Skybox.
     */
    function Skybox(image) {
        if (image === void 0) { image = null; }
        var _this = _super.call(this) || this;
        _this._textures = new Array();
        _this._pAlphaThreshold = 0;
        _this._pBlendMode = _awayjs_graphics.BlendMode.NORMAL;
        _this._curves = false;
        _this._imageRect = false;
        _this._onTextureInvalidateDelegate = function (event) { return _this.onTextureInvalidate(event); };
        _this._pIsEntity = true;
        _this._owners = new Array(_this);
        _this.style = new _awayjs_graphics.Style();
        _this.style.image = image;
        _this.texture = new _awayjs_graphics.SingleCubeTexture();
        //default bounds type
        _this._boundsType = BoundsType.NULL;
        return _this;
    }
    Object.defineProperty(Skybox.prototype, "bothSides", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "traverseName", {
        get: function () {
            return Skybox.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "alphaThreshold", {
        /**
         * The minimum alpha value for which pixels should be drawn. This is used for transparency that is either
         * invisible or entirely opaque, often used with textures for foliage, etc.
         * Recommended values are 0 to disable alpha, or 0.5 to create smooth edges. Default value is 0 (disabled).
         */
        get: function () {
            return this._pAlphaThreshold;
        },
        set: function (value) {
            if (value < 0)
                value = 0;
            else if (value > 1)
                value = 1;
            if (this._pAlphaThreshold == value)
                return;
            this._pAlphaThreshold = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "curves", {
        /**
         * Indicates whether skybox should use curves. Defaults to false.
         */
        get: function () {
            return this._curves;
        },
        set: function (value) {
            if (this._curves == value)
                return;
            this._curves = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "imageRect", {
        /**
         * Indicates whether or not the Skybox texture should use imageRects. Defaults to false.
         */
        get: function () {
            return this._imageRect;
        },
        set: function (value) {
            if (this._imageRect == value)
                return;
            this._imageRect = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "lightPicker", {
        /**
         * The light picker used by the material to provide lights to the material if it supports lighting.
         *
         * @see LightPickerBase
         * @see StaticLightPicker
         */
        get: function () {
            return this._pLightPicker;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "animationSet", {
        /**
         *
         */
        get: function () {
            return this._animationSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "blendMode", {
        /**
         * The blend mode to use when drawing this renderable. The following blend modes are supported:
         * <ul>
         * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
         * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
         * <li>BlendMode.MULTIPLY</li>
         * <li>BlendMode.ADD</li>
         * <li>BlendMode.ALPHA</li>
         * </ul>
         */
        get: function () {
            return this._pBlendMode;
        },
        set: function (value) {
            if (this._pBlendMode == value)
                return;
            this._pBlendMode = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "iOwners", {
        /**
         * A list of the IRenderables that use this material
         *
         * @private
         */
        get: function () {
            return this._owners;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Skybox.prototype, "texture", {
        /**
        * The cube texture to use as the skybox.
        */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture == value)
                return;
            if (this._texture)
                this.removeTexture(this._texture);
            this._texture = value;
            if (this._texture)
                this.addTexture(this._texture);
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Skybox.prototype.getNumTextures = function () {
        return this._textures.length;
    };
    Skybox.prototype.getTextureAt = function (index) {
        return this._textures[index];
    };
    Object.defineProperty(Skybox.prototype, "assetType", {
        get: function () {
            return Skybox.assetType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Marks the shader programs for all passes as invalid, so they will be recompiled before the next use.
     *
     * @private
     */
    Skybox.prototype.invalidatePasses = function () {
        this.dispatchEvent(new _awayjs_graphics.MaterialEvent(_awayjs_graphics.MaterialEvent.INVALIDATE_PASSES, this));
    };
    Skybox.prototype.invalidateElements = function () {
        this.dispatchEvent(new _awayjs_graphics.RenderableEvent(_awayjs_graphics.RenderableEvent.INVALIDATE_ELEMENTS, this));
    };
    Skybox.prototype.invalidateMaterial = function () {
        this.dispatchEvent(new _awayjs_graphics.RenderableEvent(_awayjs_graphics.RenderableEvent.INVALIDATE_MATERIAL, this));
    };
    Skybox.prototype.addTexture = function (texture) {
        this._textures.push(texture);
        texture.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
        this.onTextureInvalidate();
    };
    Skybox.prototype.removeTexture = function (texture) {
        this._textures.splice(this._textures.indexOf(texture), 1);
        texture.removeEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onTextureInvalidateDelegate);
        this.onTextureInvalidate();
    };
    Skybox.prototype.onTextureInvalidate = function (event) {
        if (event === void 0) { event = null; }
        this.invalidate();
    };
    Skybox.prototype._onInvalidateProperties = function (event) {
        this.invalidateMaterial();
        this.invalidatePasses();
    };
    Skybox.prototype._acceptTraverser = function (traverser) {
        traverser.applyRenderable(this);
    };
    Skybox.prototype.iAddOwner = function (owner) {
    };
    /**
     * Removes an IEntity as owner.
     * @param owner
     *
     * @internal
     */
    Skybox.prototype.iRemoveOwner = function (owner) {
    };
    return Skybox;
}(DisplayObject));
Skybox.traverseName = _awayjs_graphics.TraverserBase.addEntityName("applySkybox");
Skybox.assetType = "[asset Skybox]";

var TextureProjectorEvent = (function (_super) {
    __extends(TextureProjectorEvent, _super);
    function TextureProjectorEvent(type) {
        return _super.call(this, type) || this;
    }
    //@override
    TextureProjectorEvent.prototype.clone = function () {
        return new TextureProjectorEvent(this.type);
    };
    return TextureProjectorEvent;
}(_awayjs_core.EventBase));
TextureProjectorEvent.TEXTURE_CHANGE = "textureChange";

/**
 * TextureProjector is an object in the scene that can be used to project textures onto geometry. To do so,
 * the object's material must have a ProjectiveTextureMethod method added to it with a TextureProjector object
 * passed in the constructor.
 * This can be used for various effects apart from acting like a normal projector, such as projecting fake shadows
 * unto a surface, the impact of light coming through a stained glass window, ...
 *
 * @see away3d.materials.methods.ProjectiveTextureMethod
 */
var TextureProjector = (function (_super) {
    __extends(TextureProjector, _super);
    /**
     * Creates a new TextureProjector object.
     * @param texture The texture to be projected on the geometry. Since any point that is projected out of the range
     * of the projector's cone is clamped to the texture's edges, the edges should be entirely neutral.
     */
    function TextureProjector(texture) {
        var _this = _super.call(this) || this;
        _this._projection = new _awayjs_core.PerspectiveProjection();
        _this._projection.transform = _this._transform;
        _this._texture = texture;
        var width = texture.getImageAt(0).width;
        var height = texture.getImageAt(0).height;
        _this._projection.setViewRect(0, 0, width, height);
        _this._projection.setStageRect(0, 0, width, height);
        return _this;
    }
    Object.defineProperty(TextureProjector.prototype, "projection", {
        /**
         *
         */
        get: function () {
            return this._projection;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProjector.prototype, "traverseName", {
        get: function () {
            return TextureProjector.traverseName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProjector.prototype, "assetType", {
        get: function () {
            return TextureProjector.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureProjector.prototype, "texture", {
        /**
         * The texture to be projected on the geometry.
         * IMPORTANT: Since any point that is projected out of the range of the projector's cone is clamped to the texture's edges,
         * the edges should be entirely neutral. Depending on the blend mode, the neutral color is:
         * White for MULTIPLY,
         * Black for ADD,
         * Transparent for MIX
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (value == this._texture)
                return;
            this._texture = value;
            var width = value.getImageAt(0).width;
            var height = value.getImageAt(0).height;
            this._projection.setViewRect(0, 0, width, height);
            this._projection.setStageRect(0, 0, width, height);
            this.dispatchEvent(new TextureProjectorEvent(TextureProjectorEvent.TEXTURE_CHANGE));
        },
        enumerable: true,
        configurable: true
    });
    return TextureProjector;
}(DisplayObjectContainer));
TextureProjector.traverseName = _awayjs_graphics.TraverserBase.addEntityName("applyTextureProjector");
TextureProjector.assetType = "[asset TextureProjector]";

var CastError = (function (_super) {
    __extends(CastError, _super);
    function CastError(message) {
        return _super.call(this, message) || this;
    }
    return CastError;
}(_awayjs_core.ErrorBase));

var ResizeEvent = (function (_super) {
    __extends(ResizeEvent, _super);
    function ResizeEvent(type, oldHeight, oldWidth) {
        if (oldHeight === void 0) { oldHeight = NaN; }
        if (oldWidth === void 0) { oldWidth = NaN; }
        var _this = _super.call(this, type) || this;
        _this._oldHeight = oldHeight;
        _this._oldWidth = oldWidth;
        return _this;
    }
    Object.defineProperty(ResizeEvent.prototype, "oldHeight", {
        get: function () {
            return this._oldHeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ResizeEvent.prototype, "oldWidth", {
        get: function () {
            return this._oldWidth;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current object.
     */
    ResizeEvent.prototype.clone = function () {
        return new ResizeEvent(this.type, this._oldHeight, this._oldWidth);
    };
    return ResizeEvent;
}(_awayjs_core.EventBase));
ResizeEvent.RESIZE = "resize";

var TouchEvent = (function (_super) {
    __extends(TouchEvent, _super);
    /**
     * Create a new TouchEvent object.
     * @param type The type of the TouchEvent.
     */
    function TouchEvent(type) {
        var _this = _super.call(this, type) || this;
        // Private.
        _this._iAllowedToPropagate = true;
        return _this;
    }
    Object.defineProperty(TouchEvent.prototype, "bubbles", {
        /**
         * @inheritDoc
         */
        get: function () {
            var doesBubble = this._iAllowedToPropagate;
            this._iAllowedToPropagate = true;
            // Don't bubble if propagation has been stopped.
            return doesBubble;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    TouchEvent.prototype.stopPropagation = function () {
        this._iAllowedToPropagate = false;
        if (this._iParentEvent)
            this._iParentEvent.stopPropagation();
    };
    /**
     * @inheritDoc
     */
    TouchEvent.prototype.stopImmediatePropagation = function () {
        this._iAllowedToPropagate = false;
        if (this._iParentEvent)
            this._iParentEvent.stopImmediatePropagation();
    };
    /**
     * Creates a copy of the TouchEvent object and sets the value of each property to match that of the original.
     */
    TouchEvent.prototype.clone = function () {
        var result = new TouchEvent(this.type);
        /* TODO: Debug / test - look into isDefaultPrevented
         if (isDefaultPrevented())
         result.preventDefault();
         */
        result.screenX = this.screenX;
        result.screenY = this.screenY;
        result.view = this.view;
        result.entity = this.entity;
        result.renderable = this.renderable;
        result.material = this.material;
        result.uv = this.uv;
        result.position = this.position;
        result.normal = this.normal;
        result.elementIndex = this.elementIndex;
        result.ctrlKey = this.ctrlKey;
        result.shiftKey = this.shiftKey;
        result._iParentEvent = this;
        return result;
    };
    Object.defineProperty(TouchEvent.prototype, "scenePosition", {
        /**
         * The position in scene space where the event took place
         */
        get: function () {
            return this.entity.transform.concatenatedMatrix3D.transformVector(this.position);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TouchEvent.prototype, "sceneNormal", {
        /**
         * The normal in scene space where the event took place
         */
        get: function () {
            var sceneNormal = this.entity.transform.concatenatedMatrix3D.deltaTransformVector(this.normal);
            sceneNormal.normalize();
            return sceneNormal;
        },
        enumerable: true,
        configurable: true
    });
    return TouchEvent;
}(_awayjs_core.EventBase));
/**
 *
 */
TouchEvent.TOUCH_END = "touchEnd3d";
/**
 *
 */
TouchEvent.TOUCH_BEGIN = "touchBegin3d";
/**
 *
 */
TouchEvent.TOUCH_MOVE = "touchMove3d";
/**
 *
 */
TouchEvent.TOUCH_OUT = "touchOut3d";
/**
 *
 */
TouchEvent.TOUCH_OVER = "touchOver3d";

/**
 * LightPickerBase provides an abstract base clase for light picker classes. These classes are responsible for
 * feeding materials with relevant lights. Usually, StaticLightPicker can be used, but LightPickerBase can be
 * extended to provide more application-specific dynamic selection of lights.
 *
 * @see StaticLightPicker
 */
var LightPickerBase = (function (_super) {
    __extends(LightPickerBase, _super);
    /**
     * Creates a new LightPickerBase object.
     */
    function LightPickerBase() {
        var _this = _super.call(this) || this;
        _this._pNumPointLights = 0;
        _this._pNumDirectionalLights = 0;
        _this._pNumCastingPointLights = 0;
        _this._pNumCastingDirectionalLights = 0;
        _this._pNumLightProbes = 0;
        return _this;
    }
    /**
     * Disposes resources used by the light picker.
     */
    LightPickerBase.prototype.dispose = function () {
    };
    Object.defineProperty(LightPickerBase.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return LightPickerBase.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numDirectionalLights", {
        /**
         * The maximum amount of directional lights that will be provided.
         */
        get: function () {
            return this._pNumDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numPointLights", {
        /**
         * The maximum amount of point lights that will be provided.
         */
        get: function () {
            return this._pNumPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numCastingDirectionalLights", {
        /**
         * The maximum amount of directional lights that cast shadows.
         */
        get: function () {
            return this._pNumCastingDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numCastingPointLights", {
        /**
         * The amount of point lights that cast shadows.
         */
        get: function () {
            return this._pNumCastingPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "numLightProbes", {
        /**
         * The maximum amount of light probes that will be provided.
         */
        get: function () {
            return this._pNumLightProbes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "pointLights", {
        /**
         * The collected point lights to be used for shading.
         */
        get: function () {
            return this._pPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "directionalLights", {
        /**
         * The collected directional lights to be used for shading.
         */
        get: function () {
            return this._pDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "castingPointLights", {
        /**
         * The collected point lights that cast shadows to be used for shading.
         */
        get: function () {
            return this._pCastingPointLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "castingDirectionalLights", {
        /**
         * The collected directional lights that cast shadows to be used for shading.
         */
        get: function () {
            return this._pCastingDirectionalLights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "lightProbes", {
        /**
         * The collected light probes to be used for shading.
         */
        get: function () {
            return this._pLightProbes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "lightProbeWeights", {
        /**
         * The weights for each light probe, defining their influence on the object.
         */
        get: function () {
            return this._pLightProbeWeights;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(LightPickerBase.prototype, "allPickedLights", {
        /**
         * A collection of all the collected lights.
         */
        get: function () {
            return this._pAllPickedLights;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates set of lights for a given renderable and EntityCollector. Always call super.collectLights() after custom overridden code.
     */
    LightPickerBase.prototype.collectLights = function (entity) {
        this.updateProbeWeights(entity);
    };
    /**
     * Updates the weights for the light probes, based on the renderable's position relative to them.
     * @param renderable The renderble for which to calculate the light probes' influence.
     */
    LightPickerBase.prototype.updateProbeWeights = function (entity) {
        // todo: this will cause the same calculations to occur per TriangleGraphic. See if this can be improved.
        var objectPos = entity.scenePosition;
        var lightPos;
        var rx = objectPos.x, ry = objectPos.y, rz = objectPos.z;
        var dx, dy, dz;
        var w, total = 0;
        var i;
        // calculates weights for probes
        for (i = 0; i < this._pNumLightProbes; ++i) {
            lightPos = this._pLightProbes[i].scenePosition;
            dx = rx - lightPos.x;
            dy = ry - lightPos.y;
            dz = rz - lightPos.z;
            // weight is inversely proportional to square of distance
            w = dx * dx + dy * dy + dz * dz;
            // just... huge if at the same spot
            w = w > .00001 ? 1 / w : 50000000;
            this._pLightProbeWeights[i] = w;
            total += w;
        }
        // normalize
        total = 1 / total;
        for (i = 0; i < this._pNumLightProbes; ++i)
            this._pLightProbeWeights[i] *= total;
    };
    return LightPickerBase;
}(_awayjs_core.AssetBase));
LightPickerBase.assetType = "[asset LightPicker]";

/**
 * Enumeration class for defining which lighting types affect the specific material
 * lighting component (diffuse and specular). This can be useful if, for example, you
 * want to use light probes for diffuse global lighting, but want specular reflections from
 * traditional light sources without those affecting the diffuse light.
 *
 * @see away.materials.ColorMaterial.diffuseLightSources
 * @see away.materials.ColorMaterial.specularLightSources
 * @see away.materials.TextureMaterial.diffuseLightSources
 * @see away.materials.TextureMaterial.specularLightSources
 */
var LightSources = (function () {
    function LightSources() {
    }
    return LightSources;
}());
/**
 * Defines normal lights are to be used as the source for the lighting
 * component.
 */
LightSources.LIGHTS = 0x01;
/**
 * Defines that global lighting probes are to be used as the source for the
 * lighting component.
 */
LightSources.PROBES = 0x02;
/**
 * Defines that both normal and global lighting probes  are to be used as the
 * source for the lighting component. This is equivalent to LightSources.LIGHTS | LightSources.PROBES.
 */
LightSources.ALL = 0x03;

/**
 * StaticLightPicker is a light picker that provides a static set of lights. The lights can be reassigned, but
 * if the configuration changes (number of directional lights, point lights, etc), a material recompilation may
 * occur.
 */
var StaticLightPicker = (function (_super) {
    __extends(StaticLightPicker, _super);
    /**
     * Creates a new StaticLightPicker object.
     * @param lights The lights to be used for shading.
     */
    function StaticLightPicker(lights) {
        var _this = _super.call(this) || this;
        _this._onCastShadowChangeDelegate = function (event) { return _this.onCastShadowChange(event); };
        _this.lights = lights;
        return _this;
    }
    Object.defineProperty(StaticLightPicker.prototype, "lights", {
        /**
         * The lights used for shading.
         */
        get: function () {
            return this._lights;
        },
        set: function (value) {
            var numPointLights = 0;
            var numDirectionalLights = 0;
            var numCastingPointLights = 0;
            var numCastingDirectionalLights = 0;
            var numLightProbes = 0;
            var light;
            if (this._lights)
                this.clearListeners();
            this._lights = value;
            this._pAllPickedLights = value;
            this._pPointLights = new Array();
            this._pCastingPointLights = new Array();
            this._pDirectionalLights = new Array();
            this._pCastingDirectionalLights = new Array();
            this._pLightProbes = new Array();
            var len = value.length;
            for (var i = 0; i < len; ++i) {
                light = value[i];
                light.addEventListener(LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
                if (light instanceof PointLight) {
                    if (light.shadowsEnabled)
                        this._pCastingPointLights[numCastingPointLights++] = light;
                    else
                        this._pPointLights[numPointLights++] = light;
                }
                else if (light instanceof DirectionalLight) {
                    if (light.shadowsEnabled)
                        this._pCastingDirectionalLights[numCastingDirectionalLights++] = light;
                    else
                        this._pDirectionalLights[numDirectionalLights++] = light;
                }
                else if (light instanceof LightProbe) {
                    this._pLightProbes[numLightProbes++] = light;
                }
            }
            if (this._pNumDirectionalLights == numDirectionalLights && this._pNumPointLights == numPointLights && this._pNumLightProbes == numLightProbes && this._pNumCastingPointLights == numCastingPointLights && this._pNumCastingDirectionalLights == numCastingDirectionalLights)
                return;
            this._pNumDirectionalLights = numDirectionalLights;
            this._pNumCastingDirectionalLights = numCastingDirectionalLights;
            this._pNumPointLights = numPointLights;
            this._pNumCastingPointLights = numCastingPointLights;
            this._pNumLightProbes = numLightProbes;
            // MUST HAVE MULTIPLE OF 4 ELEMENTS!
            this._pLightProbeWeights = new Array(Math.ceil(numLightProbes / 4) * 4);
            // notify material lights have changed
            this.dispatchEvent(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.INVALIDATE, this));
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Remove configuration change listeners on the lights.
     */
    StaticLightPicker.prototype.clearListeners = function () {
        var len = this._lights.length;
        for (var i = 0; i < len; ++i)
            this._lights[i].removeEventListener(LightEvent.CASTS_SHADOW_CHANGE, this._onCastShadowChangeDelegate);
    };
    /**
     * Notifies the material of a configuration change.
     */
    StaticLightPicker.prototype.onCastShadowChange = function (event) {
        // TODO: Assign to special caster collections, just append it to the lights in SinglePass
        // But keep seperated in multipass
        var light = event.target;
        if (light instanceof PointLight)
            this.updatePointCasting(light);
        else if (light instanceof DirectionalLight)
            this.updateDirectionalCasting(light);
        this.dispatchEvent(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.INVALIDATE, this));
    };
    /**
     * Called when a directional light's shadow casting configuration changes.
     */
    StaticLightPicker.prototype.updateDirectionalCasting = function (light) {
        var dl = light;
        if (light.shadowsEnabled) {
            --this._pNumDirectionalLights;
            ++this._pNumCastingDirectionalLights;
            this._pDirectionalLights.splice(this._pDirectionalLights.indexOf(dl), 1);
            this._pCastingDirectionalLights.push(light);
        }
        else {
            ++this._pNumDirectionalLights;
            --this._pNumCastingDirectionalLights;
            this._pCastingDirectionalLights.splice(this._pCastingDirectionalLights.indexOf(dl), 1);
            this._pDirectionalLights.push(light);
        }
    };
    /**
     * Called when a point light's shadow casting configuration changes.
     */
    StaticLightPicker.prototype.updatePointCasting = function (light) {
        var pl = light;
        if (light.shadowsEnabled) {
            --this._pNumPointLights;
            ++this._pNumCastingPointLights;
            this._pPointLights.splice(this._pPointLights.indexOf(pl), 1);
            this._pCastingPointLights.push(light);
        }
        else {
            ++this._pNumPointLights;
            --this._pNumCastingPointLights;
            this._pCastingPointLights.splice(this._pCastingPointLights.indexOf(pl), 1);
            this._pPointLights.push(light);
        }
    };
    return StaticLightPicker;
}(LightPickerBase));

var CascadeShadowMapper = (function (_super) {
    __extends(CascadeShadowMapper, _super);
    function CascadeShadowMapper(numCascades) {
        if (numCascades === void 0) { numCascades = 3; }
        var _this = _super.call(this) || this;
        _this._scissorRectsInvalid = true;
        if (numCascades < 1 || numCascades > 4)
            throw new Error("numCascades must be an integer between 1 and 4");
        _this._numCascades = numCascades;
        _this.init();
        return _this;
    }
    CascadeShadowMapper.prototype.getSplitRatio = function (index /*uint*/) {
        return this._splitRatios[index];
    };
    CascadeShadowMapper.prototype.setSplitRatio = function (index /*uint*/, value) {
        if (value < 0)
            value = 0;
        else if (value > 1)
            value = 1;
        if (index >= this._numCascades)
            throw new Error("index must be smaller than the number of cascades!");
        this._splitRatios[index] = value;
    };
    CascadeShadowMapper.prototype.getDepthProjections = function (partition /*uint*/) {
        return this._depthProjections[partition].viewMatrix3D;
    };
    CascadeShadowMapper.prototype.init = function () {
        this._splitRatios = new Array(this._numCascades);
        this._nearPlaneDistances = new Array(this._numCascades);
        var s = 1;
        for (var i = this._numCascades - 1; i >= 0; --i) {
            this._splitRatios[i] = s;
            s *= .4;
        }
        this._texOffsetsX = Array(-1, 1, -1, 1);
        this._texOffsetsY = Array(1, 1, -1, -1);
        this._pScissorRects = new Array(4);
        this._depthProjections = new Array();
        for (i = 0; i < this._numCascades; ++i)
            this._depthProjections[i] = new _awayjs_core.PerspectiveProjection();
    };
    CascadeShadowMapper.prototype._setDepthMapSize = function (value /*uint*/) {
        _super.prototype._setDepthMapSize.call(this, value);
        this.invalidateScissorRects();
    };
    CascadeShadowMapper.prototype.invalidateScissorRects = function () {
        this._scissorRectsInvalid = true;
    };
    Object.defineProperty(CascadeShadowMapper.prototype, "numCascades", {
        get: function () {
            return this._numCascades;
        },
        set: function (value /*int*/) {
            if (value == this._numCascades)
                return;
            if (value < 1 || value > 4)
                throw new Error("numCascades must be an integer between 1 and 4");
            this._numCascades = value;
            this.invalidateScissorRects();
            this.init();
            this.dispatchEvent(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.INVALIDATE, this));
        },
        enumerable: true,
        configurable: true
    });
    CascadeShadowMapper.prototype._drawDepthMap = function (view, target, renderer) {
        if (this._scissorRectsInvalid)
            this.updateScissorRects();
        renderer.cullPlanes = this._cullPlanes;
        renderer._iRenderCascades(this._overallDepthProjection, view, target.image2D, this._numCascades, this._pScissorRects, this._depthProjections);
    };
    CascadeShadowMapper.prototype.updateScissorRects = function () {
        var half = this._depthMapSize * .5;
        this._pScissorRects[0] = new _awayjs_core.Rectangle(0, 0, half, half);
        this._pScissorRects[1] = new _awayjs_core.Rectangle(half, 0, half, half);
        this._pScissorRects[2] = new _awayjs_core.Rectangle(0, half, half, half);
        this._pScissorRects[3] = new _awayjs_core.Rectangle(half, half, half, half);
        this._scissorRectsInvalid = false;
    };
    CascadeShadowMapper.prototype._updateDepthProjection = function (projection) {
        var matrix;
        var projectionNear = projection.near;
        var projectionRange = projection.far - projectionNear;
        this._updateProjectionFromFrustumCorners(projection, projection.frustumCorners, this._matrix);
        this._matrix.appendScale(.96, .96, 1);
        this._overallDepthProjection.frustumMatrix3D = this._matrix;
        this._updateCullPlanes(projection);
        for (var i = 0; i < this._numCascades; ++i) {
            matrix = this._depthProjections[i].frustumMatrix3D;
            this._nearPlaneDistances[i] = projectionNear + this._splitRatios[i] * projectionRange;
            this._depthProjections[i].transform.matrix3D = this._overallDepthProjection.transform.matrix3D;
            this.updateProjectionPartition(matrix, this._splitRatios[i], this._texOffsetsX[i], this._texOffsetsY[i]);
            this._depthProjections[i].frustumMatrix3D = matrix;
        }
    };
    CascadeShadowMapper.prototype.updateProjectionPartition = function (matrix, splitRatio, texOffsetX, texOffsetY) {
        var xN, yN, zN;
        var xF, yF, zF;
        var minX = Number.POSITIVE_INFINITY, minY = Number.POSITIVE_INFINITY, minZ;
        var maxX = Number.NEGATIVE_INFINITY, maxY = Number.NEGATIVE_INFINITY, maxZ = Number.NEGATIVE_INFINITY;
        var i = 0;
        while (i < 12) {
            xN = this._localFrustum[i];
            yN = this._localFrustum[i + 1];
            zN = this._localFrustum[i + 2];
            xF = xN + (this._localFrustum[i + 12] - xN) * splitRatio;
            yF = yN + (this._localFrustum[i + 13] - yN) * splitRatio;
            zF = zN + (this._localFrustum[i + 14] - zN) * splitRatio;
            if (xN < minX)
                minX = xN;
            if (xN > maxX)
                maxX = xN;
            if (yN < minY)
                minY = yN;
            if (yN > maxY)
                maxY = yN;
            if (zN > maxZ)
                maxZ = zN;
            if (xF < minX)
                minX = xF;
            if (xF > maxX)
                maxX = xF;
            if (yF < minY)
                minY = yF;
            if (yF > maxY)
                maxY = yF;
            if (zF > maxZ)
                maxZ = zF;
            i += 3;
        }
        minZ = 1;
        var w = (maxX - minX);
        var h = (maxY - minY);
        var d = 1 / (maxZ - minZ);
        if (minX < 0)
            minX -= this._snap; // because int() rounds up for < 0
        if (minY < 0)
            minY -= this._snap;
        minX = Math.floor(minX / this._snap) * this._snap;
        minY = Math.floor(minY / this._snap) * this._snap;
        var snap2 = 2 * this._snap;
        w = Math.floor(w / snap2 + 1) * snap2;
        h = Math.floor(h / snap2 + 1) * snap2;
        maxX = minX + w;
        maxY = minY + h;
        w = 1 / w;
        h = 1 / h;
        var raw = matrix._rawData;
        raw[0] = 2 * w;
        raw[5] = 2 * h;
        raw[10] = d;
        raw[12] = -(maxX + minX) * w;
        raw[13] = -(maxY + minY) * h;
        raw[14] = -minZ * d;
        raw[15] = 1;
        raw[1] = raw[2] = raw[3] = raw[4] = raw[6] = raw[7] = raw[8] = raw[9] = raw[11] = 0;
        matrix.appendScale(.96, .96, 1);
        matrix.appendTranslation(texOffsetX, texOffsetY, 0);
        matrix.appendScale(.5, .5, 1);
    };
    Object.defineProperty(CascadeShadowMapper.prototype, "_iNearPlaneDistances", {
        get: function () {
            return this._nearPlaneDistances;
        },
        enumerable: true,
        configurable: true
    });
    return CascadeShadowMapper;
}(DirectionalShadowMapper));

var NearDirectionalShadowMapper = (function (_super) {
    __extends(NearDirectionalShadowMapper, _super);
    function NearDirectionalShadowMapper(coverageRatio) {
        if (coverageRatio === void 0) { coverageRatio = .5; }
        var _this = _super.call(this) || this;
        _this.coverageRatio = coverageRatio;
        return _this;
    }
    Object.defineProperty(NearDirectionalShadowMapper.prototype, "coverageRatio", {
        /**
         * A value between 0 and 1 to indicate the ratio of the view frustum that needs to be covered by the shadow map.
         */
        get: function () {
            return this._coverageRatio;
        },
        set: function (value) {
            if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            this._coverageRatio = value;
        },
        enumerable: true,
        configurable: true
    });
    NearDirectionalShadowMapper.prototype._updateDepthProjection = function (projection) {
        var corners = projection.frustumCorners;
        for (var i = 0; i < 12; ++i) {
            var v = corners[i];
            this._localFrustum[i] = v;
            this._localFrustum[i + 12] = v + (corners[i + 12] - v) * this._coverageRatio;
        }
        this._updateProjectionFromFrustumCorners(projection, this._localFrustum, this._matrix);
        this._overallDepthProjection.frustumMatrix3D = this._matrix;
    };
    return NearDirectionalShadowMapper;
}(DirectionalShadowMapper));

/**
 * A Capsule primitive sprite.
 */
var PrimitiveCapsulePrefab = (function (_super) {
    __extends(PrimitiveCapsulePrefab, _super);
    /**
     * Creates a new Capsule object.
     * @param radius The radius of the capsule.
     * @param height The height of the capsule.
     * @param segmentsW Defines the number of horizontal segments that make up the capsule. Defaults to 16.
     * @param segmentsH Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven value.
     * @param yUp Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
     */
    function PrimitiveCapsulePrefab(material, elementsType, radius, height, segmentsW, segmentsH, yUp) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (radius === void 0) { radius = 50; }
        if (height === void 0) { height = 100; }
        if (segmentsW === void 0) { segmentsW = 16; }
        if (segmentsH === void 0) { segmentsH = 15; }
        if (yUp === void 0) { yUp = true; }
        var _this = _super.call(this, material, elementsType) || this;
        _this._numVertices = 0;
        _this._radius = radius;
        _this._height = height;
        _this._segmentsW = segmentsW;
        _this._segmentsH = (segmentsH % 2 == 0) ? segmentsH + 1 : segmentsH;
        _this._yUp = yUp;
        return _this;
    }
    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "radius", {
        /**
         * The radius of the capsule.
         */
        get: function () {
            return this._radius;
        },
        set: function (value) {
            this._radius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "height", {
        /**
         * The height of the capsule.
         */
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "segmentsW", {
        /**
         * Defines the number of horizontal segments that make up the capsule. Defaults to 16.
         */
        get: function () {
            return this._segmentsW;
        },
        set: function (value) {
            this._segmentsW = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "segmentsH", {
        /**
         * Defines the number of vertical segments that make up the capsule. Defaults to 15. Must be uneven.
         */
        get: function () {
            return this._segmentsH;
        },
        set: function (value) {
            this._segmentsH = (value % 2 == 0) ? value + 1 : value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCapsulePrefab.prototype, "yUp", {
        /**
         * Defines whether the capsule poles should lay on the Y-axis (true) or on the Z-axis (false).
         */
        get: function () {
            return this._yUp;
        },
        set: function (value) {
            this._yUp = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    PrimitiveCapsulePrefab.prototype._pBuildGraphics = function (target, elementsType) {
        var indices;
        var positions;
        var normals;
        var tangents;
        var stride;
        var i;
        var j;
        var triIndex = 0;
        var index = 0;
        var startIndex;
        var comp1, comp2, t1, t2;
        var numIndices = 0;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            // evaluate target number of vertices, triangles and indices
            this._numVertices = (this._segmentsH + 1) * (this._segmentsW + 1); // segmentsH + 1 because of closure, segmentsW + 1 because of closure
            numIndices = (this._segmentsH - 1) * this._segmentsW * 6; // each level has segmentH quads, each of 2 triangles
            // need to initialize raw arrays or can be reused?
            if (this._numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateIndices();
                triangleGraphics.invalidateVertices(triangleGraphics.positions);
                triangleGraphics.invalidateVertices(triangleGraphics.normals);
                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
            }
            else {
                triangleGraphics.setIndices(new Uint16Array(numIndices));
                triangleGraphics.setPositions(new Float32Array(this._numVertices * 3));
                triangleGraphics.setNormals(new Float32Array(this._numVertices * 3));
                triangleGraphics.setTangents(new Float32Array(this._numVertices * 3));
                this._pInvalidateUVs();
            }
            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
            positions = triangleGraphics.positions.get(this._numVertices);
            normals = triangleGraphics.normals.get(this._numVertices);
            tangents = triangleGraphics.tangents.get(this._numVertices);
            stride = triangleGraphics.concatenatedBuffer.stride / 4;
            for (j = 0; j <= this._segmentsH; ++j) {
                var horangle = Math.PI * j / this._segmentsH;
                var z = -this._radius * Math.cos(horangle);
                var ringradius = this._radius * Math.sin(horangle);
                startIndex = index;
                for (i = 0; i <= this._segmentsW; ++i) {
                    var verangle = 2 * Math.PI * i / this._segmentsW;
                    var x = ringradius * Math.cos(verangle);
                    var offset = j > this._segmentsH / 2 ? this._height / 2 : -this._height / 2;
                    var y = ringradius * Math.sin(verangle);
                    var normLen = 1 / Math.sqrt(x * x + y * y + z * z);
                    var tanLen = Math.sqrt(y * y + x * x);
                    if (this._yUp) {
                        t1 = 0;
                        t2 = tanLen > .007 ? x / tanLen : 0;
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        t1 = tanLen > .007 ? x / tanLen : 0;
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this._segmentsW) {
                        positions[index] = positions[startIndex];
                        positions[index + 1] = positions[startIndex + 1];
                        positions[index + 2] = positions[startIndex + 2];
                        normals[index] = (normals[startIndex] + (x * normLen)) * .5;
                        normals[index + 1] = (normals[startIndex + 1] + (comp1 * normLen)) * .5;
                        normals[index + 2] = (normals[startIndex + 2] + (comp2 * normLen)) * .5;
                        tangents[index] = (tangents[startIndex] + (tanLen > .007 ? -y / tanLen : 1)) * .5;
                        tangents[index + 1] = (tangents[startIndex + 1] + t1) * .5;
                        tangents[index + 2] = (tangents[startIndex + 2] + t2) * .5;
                    }
                    else {
                        // vertex
                        positions[index] = x;
                        positions[index + 1] = (this._yUp) ? comp1 - offset : comp1;
                        positions[index + 2] = (this._yUp) ? comp2 : comp2 + offset;
                        // normal
                        normals[index] = x * normLen;
                        normals[index + 1] = comp1 * normLen;
                        normals[index + 2] = comp2 * normLen;
                        // tangent
                        tangents[index] = tanLen > .007 ? -y / tanLen : 1;
                        tangents[index + 1] = t1;
                        tangents[index + 2] = t2;
                    }
                    if (i > 0 && j > 0) {
                        var a = (this._segmentsW + 1) * j + i;
                        var b = (this._segmentsW + 1) * j + i - 1;
                        var c = (this._segmentsW + 1) * (j - 1) + i - 1;
                        var d = (this._segmentsW + 1) * (j - 1) + i;
                        if (j == this._segmentsH) {
                            positions[index] = positions[startIndex];
                            positions[index + 1] = positions[startIndex + 1];
                            positions[index + 2] = positions[startIndex + 2];
                            indices[triIndex++] = a;
                            indices[triIndex++] = c;
                            indices[triIndex++] = d;
                        }
                        else if (j == 1) {
                            indices[triIndex++] = a;
                            indices[triIndex++] = b;
                            indices[triIndex++] = c;
                        }
                        else {
                            indices[triIndex++] = a;
                            indices[triIndex++] = b;
                            indices[triIndex++] = c;
                            indices[triIndex++] = a;
                            indices[triIndex++] = c;
                            indices[triIndex++] = d;
                        }
                    }
                    index += stride;
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    /**
     * @inheritDoc
     */
    PrimitiveCapsulePrefab.prototype._pBuildUVs = function (target, elementsType) {
        var i, j;
        var uvs;
        var stride;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            // need to initialize raw array or can be reused?
            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
            }
            else {
                triangleGraphics.setUVs(new Float32Array(this._numVertices * 2));
            }
            uvs = triangleGraphics.uvs.get(this._numVertices);
            stride = triangleGraphics.uvs.stride;
            // current uv component index
            var index = 0;
            // surface
            for (j = 0; j <= this._segmentsH; ++j) {
                for (i = 0; i <= this._segmentsW; ++i) {
                    // revolution vertex
                    uvs[index] = (i / this._segmentsW) * this._scaleU;
                    uvs[index + 1] = (j / this._segmentsH) * this._scaleV;
                    index += stride;
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    return PrimitiveCapsulePrefab;
}(PrimitivePrefabBase));

/**
 * A Cylinder primitive sprite.
 */
var PrimitiveCylinderPrefab = (function (_super) {
    __extends(PrimitiveCylinderPrefab, _super);
    /**
     * Creates a new Cylinder object.
     * @param topRadius The radius of the top end of the cylinder.
     * @param bottomRadius The radius of the bottom end of the cylinder
     * @param height The radius of the bottom end of the cylinder
     * @param segmentsW Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
     * @param segmentsH Defines the number of vertical segments that make up the cylinder. Defaults to 1.
     * @param topClosed Defines whether the top end of the cylinder is closed (true) or open.
     * @param bottomClosed Defines whether the bottom end of the cylinder is closed (true) or open.
     * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
     */
    function PrimitiveCylinderPrefab(material, elementsType, topRadius, bottomRadius, height, segmentsW, segmentsH, topClosed, bottomClosed, surfaceClosed, yUp) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (topRadius === void 0) { topRadius = 50; }
        if (bottomRadius === void 0) { bottomRadius = 50; }
        if (height === void 0) { height = 100; }
        if (segmentsW === void 0) { segmentsW = 16; }
        if (segmentsH === void 0) { segmentsH = 1; }
        if (topClosed === void 0) { topClosed = true; }
        if (bottomClosed === void 0) { bottomClosed = true; }
        if (surfaceClosed === void 0) { surfaceClosed = true; }
        if (yUp === void 0) { yUp = true; }
        var _this = _super.call(this, material, elementsType) || this;
        _this._numVertices = 0;
        _this._topRadius = topRadius;
        _this._pBottomRadius = bottomRadius;
        _this._height = height;
        _this._pSegmentsW = segmentsW;
        _this._pSegmentsH = segmentsH;
        _this._topClosed = topClosed;
        _this._bottomClosed = bottomClosed;
        _this._surfaceClosed = surfaceClosed;
        _this._yUp = yUp;
        return _this;
    }
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "topRadius", {
        /**
         * The radius of the top end of the cylinder.
         */
        get: function () {
            return this._topRadius;
        },
        set: function (value) {
            this._topRadius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "bottomRadius", {
        /**
         * The radius of the bottom end of the cylinder.
         */
        get: function () {
            return this._pBottomRadius;
        },
        set: function (value) {
            this._pBottomRadius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "height", {
        /**
         * The radius of the top end of the cylinder.
         */
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "segmentsW", {
        /**
         * Defines the number of horizontal segments that make up the cylinder. Defaults to 16.
         */
        get: function () {
            return this._pSegmentsW;
        },
        set: function (value) {
            this.setSegmentsW(value);
        },
        enumerable: true,
        configurable: true
    });
    PrimitiveCylinderPrefab.prototype.setSegmentsW = function (value) {
        this._pSegmentsW = value;
        this._pInvalidatePrimitive();
        this._pInvalidateUVs();
    };
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "segmentsH", {
        /**
         * Defines the number of vertical segments that make up the cylinder. Defaults to 1.
         */
        get: function () {
            return this._pSegmentsH;
        },
        set: function (value) {
            this.setSegmentsH(value);
        },
        enumerable: true,
        configurable: true
    });
    PrimitiveCylinderPrefab.prototype.setSegmentsH = function (value) {
        this._pSegmentsH = value;
        this._pInvalidatePrimitive();
        this._pInvalidateUVs();
    };
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "topClosed", {
        /**
         * Defines whether the top end of the cylinder is closed (true) or open.
         */
        get: function () {
            return this._topClosed;
        },
        set: function (value) {
            this._topClosed = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "bottomClosed", {
        /**
         * Defines whether the bottom end of the cylinder is closed (true) or open.
         */
        get: function () {
            return this._bottomClosed;
        },
        set: function (value) {
            this._bottomClosed = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveCylinderPrefab.prototype, "yUp", {
        /**
         * Defines whether the cylinder poles should lay on the Y-axis (true) or on the Z-axis (false).
         */
        get: function () {
            return this._yUp;
        },
        set: function (value) {
            this._yUp = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    PrimitiveCylinderPrefab.prototype._pBuildGraphics = function (target, elementsType) {
        var indices;
        var positions;
        var normals;
        var tangents;
        var stride;
        var i;
        var j;
        var x;
        var y;
        var z;
        var vidx;
        var fidx;
        var radius;
        var revolutionAngle;
        var dr;
        var latNormElev;
        var latNormBase;
        var numIndices = 0;
        var comp1;
        var comp2;
        var startIndex = 0;
        var nextVertexIndex = 0;
        var centerVertexIndex = 0;
        var t1;
        var t2;
        // reset utility variables
        this._numVertices = 0;
        // evaluate revolution steps
        var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            // evaluate target number of vertices, triangles and indices
            if (this._surfaceClosed) {
                this._numVertices += (this._pSegmentsH + 1) * (this._pSegmentsW + 1); // segmentsH + 1 because of closure, segmentsW + 1 because of UV unwrapping
                numIndices += this._pSegmentsH * this._pSegmentsW * 6; // each level has segmentW quads, each of 2 triangles
            }
            if (this._topClosed) {
                this._numVertices += 2 * (this._pSegmentsW + 1); // segmentsW + 1 because of unwrapping
                numIndices += this._pSegmentsW * 3; // one triangle for each segment
            }
            if (this._bottomClosed) {
                this._numVertices += 2 * (this._pSegmentsW + 1);
                numIndices += this._pSegmentsW * 3;
            }
            // need to initialize raw arrays or can be reused?
            if (this._numVertices == triangleGraphics.numVertices) {
                /*triangleGraphics.invalidateIndices();
                triangleGraphics.invalidateVertices(triangleGraphics.positions);
                triangleGraphics.invalidateVertices(triangleGraphics.normals);
                triangleGraphics.invalidateVertices(triangleGraphics.tangents);*/
                triangleGraphics.positions.invalidate();
                triangleGraphics.normals.invalidate();
                triangleGraphics.tangents.invalidate();
                triangleGraphics.indices.invalidate();
            }
            else {
                triangleGraphics.setIndices(new Uint16Array(numIndices));
                triangleGraphics.setPositions(new Float32Array(this._numVertices * 3));
                triangleGraphics.setNormals(new Float32Array(this._numVertices * 3));
                triangleGraphics.setTangents(new Float32Array(this._numVertices * 3));
                this._pInvalidateUVs();
            }
            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
            positions = triangleGraphics.positions.get(this._numVertices);
            normals = triangleGraphics.normals.get(this._numVertices);
            tangents = triangleGraphics.tangents.get(this._numVertices);
            stride = triangleGraphics.concatenatedBuffer.stride / 4;
            vidx = 0;
            fidx = 0;
            // top
            if (this._topClosed && this._topRadius > 0) {
                z = -0.5 * this._height;
                // central vertex
                if (this._yUp) {
                    t1 = 1;
                    t2 = 0;
                    comp1 = -z;
                    comp2 = 0;
                }
                else {
                    t1 = 0;
                    t2 = -1;
                    comp1 = 0;
                    comp2 = z;
                }
                positions[vidx] = 0;
                positions[vidx + 1] = comp1;
                positions[vidx + 2] = comp2;
                normals[vidx] = 0;
                normals[vidx + 1] = t1;
                normals[vidx + 2] = t2;
                tangents[vidx] = 1;
                tangents[vidx + 1] = 0;
                tangents[vidx + 2] = 0;
                vidx += stride;
                nextVertexIndex++;
                for (i = 0; i <= this._pSegmentsW; ++i) {
                    // revolution vertex
                    revolutionAngle = i * revolutionAngleDelta;
                    x = this._topRadius * Math.cos(revolutionAngle);
                    y = this._topRadius * Math.sin(revolutionAngle);
                    if (this._yUp) {
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this._pSegmentsW) {
                        positions[vidx] = positions[startIndex + stride];
                        positions[vidx + 1] = positions[startIndex + stride + 1];
                        positions[vidx + 2] = positions[startIndex + stride + 2];
                    }
                    else {
                        positions[vidx] = x;
                        positions[vidx + 1] = comp1;
                        positions[vidx + 2] = comp2;
                    }
                    normals[vidx] = 0;
                    normals[vidx + 1] = t1;
                    normals[vidx + 2] = t2;
                    tangents[vidx] = 1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                    if (i > 0) {
                        // add triangle
                        indices[fidx++] = nextVertexIndex - 1;
                        indices[fidx++] = centerVertexIndex;
                        indices[fidx++] = nextVertexIndex;
                    }
                    nextVertexIndex++;
                }
            }
            // bottom
            if (this._bottomClosed && this._pBottomRadius > 0) {
                z = 0.5 * this._height;
                startIndex = nextVertexIndex * stride;
                centerVertexIndex = nextVertexIndex;
                // central vertex
                if (this._yUp) {
                    t1 = -1;
                    t2 = 0;
                    comp1 = -z;
                    comp2 = 0;
                }
                else {
                    t1 = 0;
                    t2 = 1;
                    comp1 = 0;
                    comp2 = z;
                }
                if (i > 0) {
                    positions[vidx] = 0;
                    positions[vidx + 1] = comp1;
                    positions[vidx + 2] = comp2;
                    normals[vidx] = 0;
                    normals[vidx + 1] = t1;
                    normals[vidx + 2] = t2;
                    tangents[vidx] = 1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                }
                nextVertexIndex++;
                for (i = 0; i <= this._pSegmentsW; ++i) {
                    // revolution vertex
                    revolutionAngle = i * revolutionAngleDelta;
                    x = this._pBottomRadius * Math.cos(revolutionAngle);
                    y = this._pBottomRadius * Math.sin(revolutionAngle);
                    if (this._yUp) {
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this._pSegmentsW) {
                        positions[vidx] = positions[startIndex + stride];
                        positions[vidx + 1] = positions[startIndex + stride + 1];
                        positions[vidx + 2] = positions[startIndex + stride + 2];
                    }
                    else {
                        positions[vidx] = x;
                        positions[vidx + 1] = comp1;
                        positions[vidx + 2] = comp2;
                    }
                    normals[vidx] = 0;
                    normals[vidx + 1] = t1;
                    normals[vidx + 2] = t2;
                    tangents[vidx] = 1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                    if (i > 0) {
                        // add triangle
                        indices[fidx++] = nextVertexIndex - 1;
                        indices[fidx++] = nextVertexIndex;
                        indices[fidx++] = centerVertexIndex;
                    }
                    nextVertexIndex++;
                }
            }
            // The normals on the lateral surface all have the same incline, i.e.
            // the "elevation" component (Y or Z depending on yUp) is constant.
            // Same principle goes for the "base" of these vectors, which will be
            // calculated such that a vector [base,elev] will be a unit vector.
            dr = (this._pBottomRadius - this._topRadius);
            latNormElev = dr / this._height;
            latNormBase = (latNormElev == 0) ? 1 : this._height / dr;
            // lateral surface
            if (this._surfaceClosed) {
                var a;
                var b;
                var c;
                var d;
                var na0, na1, naComp1, naComp2;
                for (j = 0; j <= this._pSegmentsH; ++j) {
                    radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
                    z = -(this._height / 2) + (j / this._pSegmentsH * this._height);
                    startIndex = nextVertexIndex * stride;
                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        // revolution vertex
                        revolutionAngle = i * revolutionAngleDelta;
                        x = radius * Math.cos(revolutionAngle);
                        y = radius * Math.sin(revolutionAngle);
                        na0 = latNormBase * Math.cos(revolutionAngle);
                        na1 = latNormBase * Math.sin(revolutionAngle);
                        if (this._yUp) {
                            t1 = 0;
                            t2 = -na0;
                            comp1 = -z;
                            comp2 = y;
                            naComp1 = latNormElev;
                            naComp2 = na1;
                        }
                        else {
                            t1 = -na0;
                            t2 = 0;
                            comp1 = y;
                            comp2 = z;
                            naComp1 = na1;
                            naComp2 = latNormElev;
                        }
                        if (i == this._pSegmentsW) {
                            positions[vidx] = positions[startIndex];
                            positions[vidx + 1] = positions[startIndex + 1];
                            positions[vidx + 2] = positions[startIndex + 2];
                            normals[vidx] = na0;
                            normals[vidx + 1] = latNormElev;
                            normals[vidx + 2] = na1;
                            tangents[vidx] = na1;
                            tangents[vidx + 1] = t1;
                            tangents[vidx + 2] = t2;
                        }
                        else {
                            positions[vidx] = x;
                            positions[vidx + 1] = comp1;
                            positions[vidx + 2] = comp2;
                            normals[vidx] = na0;
                            normals[vidx + 1] = naComp1;
                            normals[vidx + 2] = naComp2;
                            tangents[vidx] = -na1;
                            tangents[vidx + 1] = t1;
                            tangents[vidx + 2] = t2;
                        }
                        vidx += stride;
                        // close triangle
                        if (i > 0 && j > 0) {
                            a = nextVertexIndex; // current
                            b = nextVertexIndex - 1; // previous
                            c = b - this._pSegmentsW - 1; // previous of last level
                            d = a - this._pSegmentsW - 1; // current of last level
                            indices[fidx++] = a;
                            indices[fidx++] = b;
                            indices[fidx++] = c;
                            indices[fidx++] = a;
                            indices[fidx++] = c;
                            indices[fidx++] = d;
                        }
                        nextVertexIndex++;
                    }
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
            var lineGraphics = target;
            var numSegments = this._pSegmentsH * this._pSegmentsW * 2 + this._pSegmentsW;
            positions = new Float32Array(numSegments * 6);
            var thickness = new Float32Array(numSegments);
            vidx = 0;
            fidx = 0;
            var _radius = 50;
            for (j = 0; j <= this._pSegmentsH; ++j) {
                radius = this._topRadius - ((j / this._pSegmentsH) * (this._topRadius - this._pBottomRadius));
                z = -(this._height / 2) + (j / this._pSegmentsH * this._height);
                for (i = 0; i <= this._pSegmentsW; ++i) {
                    // revolution vertex
                    revolutionAngle = i * revolutionAngleDelta;
                    x = radius * Math.cos(revolutionAngle);
                    y = radius * Math.sin(revolutionAngle);
                    if (this._yUp) {
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i > 0) {
                        //horizonal lines
                        positions[vidx++] = x;
                        positions[vidx++] = comp1;
                        positions[vidx++] = comp2;
                        thickness[fidx++] = 1;
                        //vertical lines
                        if (j > 0) {
                            var addx = (j == 1) ? 3 - (6 * (this._pSegmentsW - i) + 12 * i) : 3 - this._pSegmentsW * 12;
                            positions[vidx] = positions[vidx++ + addx];
                            positions[vidx] = positions[vidx++ + addx];
                            positions[vidx] = positions[vidx++ + addx];
                            positions[vidx++] = x;
                            positions[vidx++] = comp1;
                            positions[vidx++] = comp2;
                            thickness[fidx++] = 1;
                        }
                    }
                    //horizonal lines
                    if (i < this._pSegmentsW) {
                        positions[vidx++] = x;
                        positions[vidx++] = comp1;
                        positions[vidx++] = comp2;
                    }
                }
            }
            // build real data from raw data
            lineGraphics.setPositions(positions);
            lineGraphics.setThickness(thickness);
        }
    };
    /**
     * @inheritDoc
     */
    PrimitiveCylinderPrefab.prototype._pBuildUVs = function (target, elementsType) {
        var i;
        var j;
        var x;
        var y;
        var revolutionAngle;
        var uvs;
        var stride;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            // need to initialize raw array or can be reused?
            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
            }
            else {
                triangleGraphics.setUVs(new Float32Array(this._numVertices * 2));
            }
            uvs = triangleGraphics.uvs.get(this._numVertices);
            stride = triangleGraphics.uvs.stride;
            // evaluate revolution steps
            var revolutionAngleDelta = 2 * Math.PI / this._pSegmentsW;
            // current uv component index
            var index = 0;
            // top
            if (this._topClosed) {
                uvs[index] = 0.5 * this._scaleU; // central vertex
                uvs[index + 1] = 0.5 * this._scaleV;
                index += stride;
                for (i = 0; i <= this._pSegmentsW; ++i) {
                    revolutionAngle = i * revolutionAngleDelta;
                    x = 0.5 + 0.5 * -Math.cos(revolutionAngle);
                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
                    uvs[index] = x * this._scaleU; // revolution vertex
                    uvs[index + 1] = y * this._scaleV;
                    index += stride;
                }
            }
            // bottom
            if (this._bottomClosed) {
                uvs[index] = 0.5 * this._scaleU; // central vertex
                uvs[index + 1] = 0.5 * this._scaleV;
                index += stride;
                for (i = 0; i <= this._pSegmentsW; ++i) {
                    revolutionAngle = i * revolutionAngleDelta;
                    x = 0.5 + 0.5 * Math.cos(revolutionAngle);
                    y = 0.5 + 0.5 * Math.sin(revolutionAngle);
                    uvs[index] = x * this._scaleU; // revolution vertex
                    uvs[index + 1] = y * this._scaleV;
                    index += stride;
                }
            }
            // lateral surface
            if (this._surfaceClosed) {
                for (j = 0; j <= this._pSegmentsH; ++j) {
                    for (i = 0; i <= this._pSegmentsW; ++i) {
                        // revolution vertex
                        uvs[index] = (i / this._pSegmentsW) * this._scaleU;
                        uvs[index + 1] = (j / this._pSegmentsH) * this._scaleV;
                        index += stride;
                    }
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    return PrimitiveCylinderPrefab;
}(PrimitivePrefabBase));

/**
 * A UV Cone primitive sprite.
 */
var PrimitiveConePrefab = (function (_super) {
    __extends(PrimitiveConePrefab, _super);
    /**
     * Creates a new Cone object.
     * @param radius The radius of the bottom end of the cone
     * @param height The height of the cone
     * @param segmentsW Defines the number of horizontal segments that make up the cone. Defaults to 16.
     * @param segmentsH Defines the number of vertical segments that make up the cone. Defaults to 1.
     * @param yUp Defines whether the cone poles should lay on the Y-axis (true) or on the Z-axis (false).
     */
    function PrimitiveConePrefab(material, elementsType, radius, height, segmentsW, segmentsH, closed, yUp) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (radius === void 0) { radius = 50; }
        if (height === void 0) { height = 100; }
        if (segmentsW === void 0) { segmentsW = 16; }
        if (segmentsH === void 0) { segmentsH = 1; }
        if (closed === void 0) { closed = true; }
        if (yUp === void 0) { yUp = true; }
        return _super.call(this, material, elementsType, 0, radius, height, segmentsW, segmentsH, false, closed, true, yUp) || this;
    }
    Object.defineProperty(PrimitiveConePrefab.prototype, "radius", {
        /**
         * The radius of the bottom end of the cone.
         */
        get: function () {
            return this._pBottomRadius;
        },
        set: function (value) {
            this._pBottomRadius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    return PrimitiveConePrefab;
}(PrimitiveCylinderPrefab));

/**
 * A Plane primitive sprite.
 */
var PrimitivePlanePrefab = (function (_super) {
    __extends(PrimitivePlanePrefab, _super);
    /**
     * Creates a new Plane object.
     * @param width The width of the plane.
     * @param height The height of the plane.
     * @param segmentsW The number of segments that make up the plane along the X-axis.
     * @param segmentsH The number of segments that make up the plane along the Y or Z-axis.
     * @param yUp Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false).
     * @param doubleSided Defines whether the plane will be visible from both sides, with correct vertex normals.
     */
    function PrimitivePlanePrefab(material, elementsType, width, height, segmentsW, segmentsH, yUp, doubleSided) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (width === void 0) { width = 100; }
        if (height === void 0) { height = 100; }
        if (segmentsW === void 0) { segmentsW = 1; }
        if (segmentsH === void 0) { segmentsH = 1; }
        if (yUp === void 0) { yUp = true; }
        if (doubleSided === void 0) { doubleSided = false; }
        var _this = _super.call(this, material, elementsType) || this;
        _this._segmentsW = segmentsW;
        _this._segmentsH = segmentsH;
        _this._yUp = yUp;
        _this._width = width;
        _this._height = height;
        _this._doubleSided = doubleSided;
        return _this;
    }
    Object.defineProperty(PrimitivePlanePrefab.prototype, "segmentsW", {
        /**
         * The number of segments that make up the plane along the X-axis. Defaults to 1.
         */
        get: function () {
            return this._segmentsW;
        },
        set: function (value) {
            this._segmentsW = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePlanePrefab.prototype, "segmentsH", {
        /**
         * The number of segments that make up the plane along the Y or Z-axis, depending on whether yUp is true or
         * false, respectively. Defaults to 1.
         */
        get: function () {
            return this._segmentsH;
        },
        set: function (value) {
            this._segmentsH = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePlanePrefab.prototype, "yUp", {
        /**
         *  Defines whether the normal vector of the plane should point along the Y-axis (true) or Z-axis (false). Defaults to true.
         */
        get: function () {
            return this._yUp;
        },
        set: function (value) {
            this._yUp = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePlanePrefab.prototype, "doubleSided", {
        /**
         * Defines whether the plane will be visible from both sides, with correct vertex normals (as opposed to bothSides on Material). Defaults to false.
         */
        get: function () {
            return this._doubleSided;
        },
        set: function (value) {
            this._doubleSided = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePlanePrefab.prototype, "width", {
        /**
         * The width of the plane.
         */
        get: function () {
            return this._width;
        },
        set: function (value) {
            this._width = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePlanePrefab.prototype, "height", {
        /**
         * The height of the plane.
         */
        get: function () {
            return this._height;
        },
        set: function (value) {
            this._height = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    PrimitivePlanePrefab.prototype._pBuildGraphics = function (target, elementsType) {
        var indices;
        var x, y;
        var numIndices;
        var stride;
        var base;
        var tw = this._segmentsW + 1;
        var vidx, fidx; // indices
        var xi;
        var yi;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            var numVertices = (this._segmentsH + 1) * tw;
            var positions;
            var normals;
            var tangents;
            if (this._doubleSided)
                numVertices *= 2;
            numIndices = this._segmentsH * this._segmentsW * 6;
            if (this._doubleSided)
                numIndices *= 2;
            if (triangleGraphics.indices != null && numIndices == triangleGraphics.indices.length) {
                triangleGraphics.invalidateIndices();
            }
            else {
                triangleGraphics.setIndices(new Uint16Array(numIndices));
                this._pInvalidateUVs();
            }
            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
            if (numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateVertices(triangleGraphics.positions);
                triangleGraphics.invalidateVertices(triangleGraphics.normals);
                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
            }
            else {
                triangleGraphics.setPositions(new Float32Array(numVertices * 3));
                triangleGraphics.setNormals(new Float32Array(numVertices * 3));
                triangleGraphics.setTangents(new Float32Array(numVertices * 3));
                this._pInvalidateUVs();
            }
            positions = triangleGraphics.positions.get(numVertices);
            normals = triangleGraphics.normals.get(numVertices);
            tangents = triangleGraphics.tangents.get(numVertices);
            stride = triangleGraphics.concatenatedBuffer.stride / 4;
            fidx = 0;
            vidx = 0;
            for (yi = 0; yi <= this._segmentsH; ++yi) {
                for (xi = 0; xi <= this._segmentsW; ++xi) {
                    x = (xi / this._segmentsW - .5) * this._width;
                    y = (yi / this._segmentsH - .5) * this._height;
                    positions[vidx] = x;
                    if (this._yUp) {
                        positions[vidx + 1] = 0;
                        positions[vidx + 2] = y;
                    }
                    else {
                        positions[vidx + 1] = y;
                        positions[vidx + 2] = 0;
                    }
                    normals[vidx] = 0;
                    if (this._yUp) {
                        normals[vidx + 1] = 1;
                        normals[vidx + 2] = 0;
                    }
                    else {
                        normals[vidx + 1] = 0;
                        normals[vidx + 2] = -1;
                    }
                    tangents[vidx] = 1;
                    tangents[vidx + 1] = 0;
                    tangents[vidx + 2] = 0;
                    vidx += stride;
                    // add vertex with same position, but with inverted normal & tangent
                    if (this._doubleSided) {
                        for (var i = vidx; i < vidx + 3; ++i) {
                            positions[i] = positions[i - 3];
                            normals[i] = -normals[i - 3];
                            tangents[i] = -tangents[i - 3];
                        }
                        vidx += stride;
                    }
                    if (xi != this._segmentsW && yi != this._segmentsH) {
                        base = xi + yi * tw;
                        var mult = this._doubleSided ? 2 : 1;
                        indices[fidx++] = base * mult;
                        indices[fidx++] = (base + tw) * mult;
                        indices[fidx++] = (base + tw + 1) * mult;
                        indices[fidx++] = base * mult;
                        indices[fidx++] = (base + tw + 1) * mult;
                        indices[fidx++] = (base + 1) * mult;
                        if (this._doubleSided) {
                            indices[fidx++] = (base + tw + 1) * mult + 1;
                            indices[fidx++] = (base + tw) * mult + 1;
                            indices[fidx++] = base * mult + 1;
                            indices[fidx++] = (base + 1) * mult + 1;
                            indices[fidx++] = (base + tw + 1) * mult + 1;
                            indices[fidx++] = base * mult + 1;
                        }
                    }
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
            var lineGraphics = target;
            var numSegments = (this._segmentsH + 1) + tw;
            var positions;
            var thickness;
            var hw = this._width / 2;
            var hh = this._height / 2;
            positions = new Float32Array(numSegments * 6);
            thickness = new Float32Array(numSegments);
            fidx = 0;
            vidx = 0;
            for (yi = 0; yi <= this._segmentsH; ++yi) {
                positions[vidx++] = -hw;
                positions[vidx++] = 0;
                positions[vidx++] = yi * this._height - hh;
                positions[vidx++] = hw;
                positions[vidx++] = 0;
                positions[vidx++] = yi * this._height - hh;
                thickness[fidx++] = 1;
            }
            for (xi = 0; xi <= this._segmentsW; ++xi) {
                positions[vidx++] = xi * this._width - hw;
                positions[vidx++] = 0;
                positions[vidx++] = -hh;
                positions[vidx++] = xi * this._width - hw;
                positions[vidx++] = 0;
                positions[vidx++] = hh;
                thickness[fidx++] = 1;
            }
            // build real data from raw data
            lineGraphics.setPositions(positions);
            lineGraphics.setThickness(thickness);
        }
    };
    /**
     * @inheritDoc
     */
    PrimitivePlanePrefab.prototype._pBuildUVs = function (target, elementsType) {
        var uvs;
        var stride;
        var numVertices;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            numVertices = (this._segmentsH + 1) * (this._segmentsW + 1);
            if (this._doubleSided)
                numVertices *= 2;
            var triangleGraphics = target;
            if (triangleGraphics.uvs && numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
            }
            else {
                triangleGraphics.setUVs(new Float32Array(numVertices * 2));
            }
            uvs = triangleGraphics.uvs.get(numVertices);
            stride = triangleGraphics.uvs.stride;
            var index = 0;
            for (var yi = 0; yi <= this._segmentsH; ++yi) {
                for (var xi = 0; xi <= this._segmentsW; ++xi) {
                    uvs[index] = (xi / this._segmentsW) * this._scaleU;
                    uvs[index + 1] = (1 - yi / this._segmentsH) * this._scaleV;
                    index += stride;
                    if (this._doubleSided) {
                        uvs[index] = (xi / this._segmentsW) * this._scaleU;
                        uvs[index + 1] = (1 - yi / this._segmentsH) * this._scaleV;
                        index += stride;
                    }
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    return PrimitivePlanePrefab;
}(PrimitivePrefabBase));

/**
 * A UV RegularPolygon primitive sprite.
 */
var PrimitivePolygonPrefab = (function (_super) {
    __extends(PrimitivePolygonPrefab, _super);
    /**
     * Creates a new RegularPolygon disc object.
     * @param radius The radius of the regular polygon
     * @param sides Defines the number of sides of the regular polygon.
     * @param yUp Defines whether the regular polygon should lay on the Y-axis (true) or on the Z-axis (false).
     */
    function PrimitivePolygonPrefab(material, elementsType, radius, sides, yUp) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (radius === void 0) { radius = 100; }
        if (sides === void 0) { sides = 16; }
        if (yUp === void 0) { yUp = true; }
        return _super.call(this, material, elementsType, radius, 0, 0, sides, 1, true, false, false, yUp) || this;
    }
    Object.defineProperty(PrimitivePolygonPrefab.prototype, "radius", {
        /**
         * The radius of the regular polygon.
         */
        get: function () {
            return this._pBottomRadius;
        },
        set: function (value) {
            this._pBottomRadius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePolygonPrefab.prototype, "sides", {
        /**
         * The number of sides of the regular polygon.
         */
        get: function () {
            return this._pSegmentsW;
        },
        set: function (value) {
            this.setSegmentsW(value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitivePolygonPrefab.prototype, "subdivisions", {
        /**
         * The number of subdivisions from the edge to the center of the regular polygon.
         */
        get: function () {
            return this._pSegmentsH;
        },
        set: function (value) {
            this.setSegmentsH(value);
        },
        enumerable: true,
        configurable: true
    });
    return PrimitivePolygonPrefab;
}(PrimitiveCylinderPrefab));

/**
 * A UV Cylinder primitive sprite.
 */
var PrimitiveTorusPrefab = (function (_super) {
    __extends(PrimitiveTorusPrefab, _super);
    /**
     * Creates a new <code>Torus</code> object.
     * @param radius The radius of the torus.
     * @param tuebRadius The radius of the inner tube of the torus.
     * @param segmentsR Defines the number of horizontal segments that make up the torus.
     * @param segmentsT Defines the number of vertical segments that make up the torus.
     * @param yUp Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
     */
    function PrimitiveTorusPrefab(material, elementsType, radius, tubeRadius, segmentsR, segmentsT, yUp) {
        if (material === void 0) { material = null; }
        if (elementsType === void 0) { elementsType = "triangle"; }
        if (radius === void 0) { radius = 50; }
        if (tubeRadius === void 0) { tubeRadius = 50; }
        if (segmentsR === void 0) { segmentsR = 16; }
        if (segmentsT === void 0) { segmentsT = 8; }
        if (yUp === void 0) { yUp = true; }
        var _this = _super.call(this, material, elementsType) || this;
        _this._numVertices = 0;
        _this._radius = radius;
        _this._tubeRadius = tubeRadius;
        _this._segmentsR = segmentsR;
        _this._segmentsT = segmentsT;
        _this._yUp = yUp;
        return _this;
    }
    Object.defineProperty(PrimitiveTorusPrefab.prototype, "radius", {
        /**
         * The radius of the torus.
         */
        get: function () {
            return this._radius;
        },
        set: function (value) {
            this._radius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveTorusPrefab.prototype, "tubeRadius", {
        /**
         * The radius of the inner tube of the torus.
         */
        get: function () {
            return this._tubeRadius;
        },
        set: function (value) {
            this._tubeRadius = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveTorusPrefab.prototype, "segmentsR", {
        /**
         * Defines the number of horizontal segments that make up the torus. Defaults to 16.
         */
        get: function () {
            return this._segmentsR;
        },
        set: function (value) {
            this._segmentsR = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveTorusPrefab.prototype, "segmentsT", {
        /**
         * Defines the number of vertical segments that make up the torus. Defaults to 8.
         */
        get: function () {
            return this._segmentsT;
        },
        set: function (value) {
            this._segmentsT = value;
            this._pInvalidatePrimitive();
            this._pInvalidateUVs();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PrimitiveTorusPrefab.prototype, "yUp", {
        /**
         * Defines whether the torus poles should lay on the Y-axis (true) or on the Z-axis (false).
         */
        get: function () {
            return this._yUp;
        },
        set: function (value) {
            this._yUp = value;
            this._pInvalidatePrimitive();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    PrimitiveTorusPrefab.prototype._pBuildGraphics = function (target, elementsType) {
        var indices;
        var positions;
        var normals;
        var tangents;
        var stride;
        var i, j;
        var x, y, z, nx, ny, nz, revolutionAngleR, revolutionAngleT;
        var vidx;
        var fidx;
        var numIndices = 0;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            // evaluate target number of vertices, triangles and indices
            this._numVertices = (this._segmentsT + 1) * (this._segmentsR + 1); // segmentsT + 1 because of closure, segmentsR + 1 because of closure
            numIndices = this._segmentsT * this._segmentsR * 6; // each level has segmentR quads, each of 2 triangles
            // need to initialize raw arrays or can be reused?
            if (this._numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateIndices();
                triangleGraphics.invalidateVertices(triangleGraphics.positions);
                triangleGraphics.invalidateVertices(triangleGraphics.normals);
                triangleGraphics.invalidateVertices(triangleGraphics.tangents);
            }
            else {
                triangleGraphics.setIndices(new Uint16Array(numIndices));
                triangleGraphics.setPositions(new Float32Array(this._numVertices * 3));
                triangleGraphics.setNormals(new Float32Array(this._numVertices * 3));
                triangleGraphics.setTangents(new Float32Array(this._numVertices * 3));
                this._pInvalidateUVs();
            }
            indices = triangleGraphics.indices.get(triangleGraphics.numElements);
            positions = triangleGraphics.positions.get(this._numVertices);
            normals = triangleGraphics.normals.get(this._numVertices);
            tangents = triangleGraphics.tangents.get(this._numVertices);
            stride = triangleGraphics.concatenatedBuffer.stride / 4;
            vidx = 0;
            fidx = 0;
            // evaluate revolution steps
            var revolutionAngleDeltaR = 2 * Math.PI / this._segmentsR;
            var revolutionAngleDeltaT = 2 * Math.PI / this._segmentsT;
            var comp1, comp2;
            var t1, t2, n1, n2;
            var startIndex = 0;
            var nextVertexIndex = 0;
            // surface
            var a, b, c, d, length;
            for (j = 0; j <= this._segmentsT; ++j) {
                startIndex = vidx;
                for (i = 0; i <= this._segmentsR; ++i) {
                    // revolution vertex
                    revolutionAngleR = i * revolutionAngleDeltaR;
                    revolutionAngleT = j * revolutionAngleDeltaT;
                    length = Math.cos(revolutionAngleT);
                    nx = length * Math.cos(revolutionAngleR);
                    ny = length * Math.sin(revolutionAngleR);
                    nz = Math.sin(revolutionAngleT);
                    x = this._radius * Math.cos(revolutionAngleR) + this._tubeRadius * nx;
                    y = this._radius * Math.sin(revolutionAngleR) + this._tubeRadius * ny;
                    z = (j == this._segmentsT) ? 0 : this._tubeRadius * nz;
                    if (this._yUp) {
                        n1 = -nz;
                        n2 = ny;
                        t1 = 0;
                        t2 = (length ? nx / length : x / this._radius);
                        comp1 = -z;
                        comp2 = y;
                    }
                    else {
                        n1 = ny;
                        n2 = nz;
                        t1 = (length ? nx / length : x / this._radius);
                        t2 = 0;
                        comp1 = y;
                        comp2 = z;
                    }
                    if (i == this._segmentsR) {
                        positions[vidx] = x;
                        positions[vidx + 1] = positions[startIndex + 1];
                        positions[vidx + 2] = positions[startIndex + 2];
                    }
                    else {
                        positions[vidx] = x;
                        positions[vidx + 1] = comp1;
                        positions[vidx + 2] = comp2;
                    }
                    normals[vidx] = nx;
                    normals[vidx + 1] = n1;
                    normals[vidx + 2] = n2;
                    tangents[vidx] = -(length ? ny / length : y / this._radius);
                    tangents[vidx + 1] = t1;
                    tangents[vidx + 2] = t2;
                    vidx += stride;
                    // close triangle
                    if (i > 0 && j > 0) {
                        a = nextVertexIndex; // current
                        b = nextVertexIndex - 1; // previous
                        c = b - this._segmentsR - 1; // previous of last level
                        d = a - this._segmentsR - 1; // current of last level
                        indices[fidx++] = a;
                        indices[fidx++] = b;
                        indices[fidx++] = c;
                        indices[fidx++] = a;
                        indices[fidx++] = c;
                        indices[fidx++] = d;
                    }
                    nextVertexIndex++;
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    /**
     * @inheritDoc
     */
    PrimitiveTorusPrefab.prototype._pBuildUVs = function (target, elementsType) {
        var i, j;
        var uvs;
        var stride;
        if (elementsType == _awayjs_graphics.ElementsType.TRIANGLE) {
            var triangleGraphics = target;
            // need to initialize raw array or can be reused?
            if (triangleGraphics.uvs && this._numVertices == triangleGraphics.numVertices) {
                triangleGraphics.invalidateVertices(triangleGraphics.uvs);
            }
            else {
                triangleGraphics.setUVs(new Float32Array(this._numVertices * 2));
            }
            uvs = triangleGraphics.uvs.get(this._numVertices);
            stride = triangleGraphics.uvs.stride;
            // current uv component index
            var index = 0;
            // surface
            for (j = 0; j <= this._segmentsT; ++j) {
                for (i = 0; i <= this._segmentsR; ++i) {
                    // revolution vertex
                    uvs[index] = (i / this._segmentsR) * this._scaleU;
                    uvs[index + 1] = (j / this._segmentsT) * this._scaleV;
                    index += stride;
                }
            }
        }
        else if (elementsType == _awayjs_graphics.ElementsType.LINE) {
        }
    };
    return PrimitiveTorusPrefab;
}(PrimitivePrefabBase));

/**
 * The AntiAliasType class provides values for anti-aliasing in the
 * away.text.TextField class.
 */
var AntiAliasType = (function () {
    function AntiAliasType() {
    }
    return AntiAliasType;
}());
/**
 * Sets anti-aliasing to advanced anti-aliasing. Advanced anti-aliasing
 * allows font faces to be rendered at very high quality at small sizes. It
 * is best used with applications that have a lot of small text. Advanced
 * anti-aliasing is not recommended for very large fonts(larger than 48
 * points). This constant is used for the <code>antiAliasType</code> property
 * in the TextField class. Use the syntax
 * <code>AntiAliasType.ADVANCED</code>.
 */
AntiAliasType.ADVANCED = "advanced";
/**
 * Sets anti-aliasing to the anti-aliasing that is used in Flash Player 7 and
 * earlier. This setting is recommended for applications that do not have a
 * lot of text. This constant is used for the <code>antiAliasType</code>
 * property in the TextField class. Use the syntax
 * <code>AntiAliasType.NORMAL</code>.
 */
AntiAliasType.NORMAL = "normal";

/**
 * The TextFormat class represents character formatting information. Use the
 * TextFormat class to create specific text formatting for text fields. You
 * can apply text formatting to both static and dynamic text fields. The
 * properties of the TextFormat class apply to device and embedded fonts.
 * However, for embedded fonts, bold and italic text actually require specific
 * fonts. If you want to display bold or italic text with an embedded font,
 * you need to embed the bold and italic variations of that font.
 *
 * <p> You must use the constructor <code>new TextFormat()</code> to create a
 * TextFormat object before setting its properties. When you apply a
 * TextFormat object to a text field using the
 * <code>TextField.defaultTextFormat</code> property or the
 * <code>TextField.setTextFormat()</code> method, only its defined properties
 * are applied. Use the <code>TextField.defaultTextFormat</code> property to
 * apply formatting BEFORE you add text to the <code>TextField</code>, and the
 * <code>setTextFormat()</code> method to add formatting AFTER you add text to
 * the <code>TextField</code>. The TextFormat properties are <code>null</code>
 * by default because if you don't provide values for the properties, Flash
 * Player uses its own default formatting. The default formatting that Flash
 * Player uses for each property(if property's value is <code>null</code>) is
 * as follows:</p>
 *
 * <p>The default formatting for each property is also described in each
 * property description.</p>
 */
var BitmapFontChar = (function () {
    function BitmapFontChar(id, x, y, width, height, xoff, yoff, xadv, page, channel) {
        this.id = id;
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
        this.x_offset = xoff;
        this.y_offset = yoff;
        this.x_advance = xadv;
        this.page = page;
        this.channel = channel;
    }
    return BitmapFontChar;
}());

/**
 * GraphicBase wraps a TriangleElements as a scene graph instantiation. A GraphicBase is owned by a Sprite object.
 *
 *
 * @see away.base.TriangleElements
 * @see away.entities.Sprite
 *
 * @class away.base.GraphicBase
 */
var BitmapFontTable = (function (_super) {
    __extends(BitmapFontTable, _super);
    //TODO test shader picking
    //		public get shaderPickingDetails():boolean
    //		{
    //
    //			return this.sourceEntity.shaderPickingDetails;
    //		}
    /**
     * Creates a new TesselatedFont object
     */
    function BitmapFontTable() {
        var _this = _super.call(this) || this;
        _this._font_chars = [];
        _this._materials = [];
        _this._font_chars_dic = new Object();
        _this._ascent = 0;
        _this._descent = 0;
        _this._current_size = 0;
        _this._size_multiply = 0;
        _this._init_size = 0;
        _this._texture_width = 0;
        _this._texture_height = 0;
        _this._adjust_size = 0;
        return _this;
    }
    Object.defineProperty(BitmapFontTable.prototype, "assetType", {
        get: function () {
            return BitmapFontTable.assetType;
        },
        enumerable: true,
        configurable: true
    });
    BitmapFontTable.prototype.initFontSize = function (font_size) {
        if (this.fallbackTable)
            this.fallbackTable.initFontSize(font_size);
        if (this._adjust_size)
            font_size *= this._adjust_size;
        if (this._current_size == font_size)
            return;
        this._current_size = font_size;
        this._size_multiply = font_size / this._init_size;
    };
    BitmapFontTable.prototype.getCharDataCanvas = function (char_code) {
        var this_char = this._font_chars_dic[char_code];
        if (this_char) {
            //console.log("this_char found");
            return [this_char.x, this_char.y, this_char.width, this_char.height, this_char.x_offset * this._size_multiply, this_char.y_offset * this._size_multiply];
        }
        //console.log("this_char not found" + char_code);
        return [];
    };
    BitmapFontTable.prototype.getCharData = function (char_code) {
        var this_char = this._font_chars_dic[char_code];
        if (this_char) {
            var realheight = (this_char.height / this._init_size) * this._current_size;
            var realWidth = (this_char.width / this._init_size) * this._current_size;
            //console.log("this_char found");
            return [this_char.x / this._texture_width, this_char.y / this._texture_height, this_char.width / this._texture_width, this_char.height / this._texture_height, this_char.x_offset * this._size_multiply, this_char.y_offset * this._size_multiply, realheight, realWidth];
        }
        //console.log("this_char not found" + char_code);
        return [];
    };
    BitmapFontTable.prototype.getCharVertCnt = function (char_code) {
        return 6 * 4;
    };
    Object.defineProperty(BitmapFontTable.prototype, "texture_width", {
        get: function () {
            return this._texture_width;
        },
        set: function (value) {
            this._texture_width = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapFontTable.prototype, "texture_height", {
        get: function () {
            return this._texture_height;
        },
        set: function (value) {
            this._texture_height = value;
        },
        enumerable: true,
        configurable: true
    });
    BitmapFontTable.prototype.hasChar = function (char_code) {
        return this._font_chars_dic[char_code] != null;
    };
    BitmapFontTable.prototype.getCharWidth = function (char_code) {
        var this_char = this._font_chars_dic[char_code];
        if (this_char)
            return this._size_multiply * (this_char.x_advance);
        return 0;
    };
    BitmapFontTable.prototype.fillTextRun = function (tf, format, startWord, wordCnt) {
    };
    BitmapFontTable.prototype.getLineHeight = function () {
        return this._current_size;
    };
    /**
     *
     */
    BitmapFontTable.prototype.dispose = function () {
        var len = this._materials.length;
        for (var i = 0; i < len; ++i) {
            this._materials[i].dispose();
        }
        this._materials.length = 0;
        this._font_chars.length = 0;
        this._font_chars_dic = null;
    };
    BitmapFontTable.prototype.addMaterial = function (material) {
        this._materials.push(material);
    };
    BitmapFontTable.prototype.getMaterial = function (idx) {
        if (idx === void 0) { idx = 0; }
        return this._materials[idx];
    };
    Object.defineProperty(BitmapFontTable.prototype, "ascent", {
        get: function () {
            return this._ascent;
        },
        set: function (value) {
            this._ascent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapFontTable.prototype, "descent", {
        get: function () {
            return this._descent;
        },
        set: function (value) {
            this._descent = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapFontTable.prototype, "offset_x", {
        get: function () {
            return this._offset_x;
        },
        set: function (value) {
            this._offset_x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BitmapFontTable.prototype, "offset_y", {
        get: function () {
            return this._offset_y;
        },
        set: function (value) {
            this._offset_y = value;
        },
        enumerable: true,
        configurable: true
    });
    BitmapFontTable.prototype.get_font_chars = function () {
        return this._font_chars;
    };
    BitmapFontTable.prototype.get_font_em_size = function () {
        return this._font_em_size;
    };
    BitmapFontTable.prototype.set_whitespace_width = function (value) {
        this._whitespace_width = value;
    };
    BitmapFontTable.prototype.get_whitespace_width = function () {
        return this._whitespace_width;
    };
    BitmapFontTable.prototype.set_font_em_size = function (font_em_size) {
        this._font_em_size = font_em_size;
    };
    /**
     *
     */
    BitmapFontTable.prototype.getChar = function (name) {
        return this._font_chars_dic[name];
    };
    /**
     *
     */
    BitmapFontTable.prototype.setChar = function (id, x, y, width, height, xoff, yoff, xadv, page, channel) {
        var bitmap_font_char = new BitmapFontChar(id, x, y, width, height, xoff, yoff, xadv, page, channel);
        this._font_chars.push(bitmap_font_char);
        this._font_chars_dic[id] = bitmap_font_char;
    };
    return BitmapFontTable;
}(_awayjs_core.AssetBase));
BitmapFontTable.assetType = "[asset BitmapFontTable]";

/**
 * Font is a container for FontTables.
 *
 *
 *
 */
var Font = (function (_super) {
    __extends(Font, _super);
    //TODO test shader picking
    //		public get shaderPickingDetails():boolean
    //		{
    //
    //			return this.sourceEntity.shaderPickingDetails;
    //		}
    /**
     * Creates a new TesselatedFont object
     */
    function Font() {
        var _this = _super.call(this) || this;
        _this._font_styles = [];
        // ------------ dummys for as3web:
        _this.fontName = null;
        return _this;
    }
    Font.registerFont = function (any) {
    };
    Object.defineProperty(Font.prototype, "font_styles", {
        // ------------
        get: function () {
            return this._font_styles;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Font.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return Font.assetType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    Font.prototype.dispose = function () {
        var len = this._font_styles.length;
        for (var i = 0; i < len; ++i) {
            this._font_styles[i].dispose();
        }
        this._font_styles.length = 0;
    };
    /**
     *Get a font-table for a specific name, or create one if it does not exists.
     */
    Font.prototype.get_font_table = function (style_name, assetType, openTypeFont) {
        if (assetType === void 0) { assetType = TesselatedFontTable.assetType; }
        if (openTypeFont === void 0) { openTypeFont = null; }
        var len = this._font_styles.length;
        //console.log("font name", this.name, style_name);
        for (var i = 0; i < len; ++i) {
            if ((this._font_styles[i].assetType == assetType) && (this._font_styles[i].name == style_name)) {
                // mak
                return this._font_styles[i];
            }
        }
        var font_style = null;
        if (assetType == TesselatedFontTable.assetType) {
            font_style = new TesselatedFontTable(openTypeFont);
        }
        else if (assetType == BitmapFontTable.assetType) {
            font_style = new BitmapFontTable();
        }
        font_style.name = style_name;
        this._font_styles.push(font_style);
        return font_style;
    };
    return Font;
}(_awayjs_core.AssetBase));
Font.assetType = "[asset Font]";

/**
 * The GridFitType class defines values for grid fitting in the TextField class.
 */
var GridFitType = (function () {
    function GridFitType() {
    }
    return GridFitType;
}());
/**
 * Doesn't set grid fitting. Horizontal and vertical lines in the glyphs are
 * not forced to the pixel grid. This constant is used in setting the
 * <code>gridFitType</code> property of the TextField class. This is often a
 * good setting for animation or for large font sizes. Use the syntax
 * <code>GridFitType.NONE</code>.
 */
GridFitType.NONE = "none";
/**
 * Fits strong horizontal and vertical lines to the pixel grid. This constant
 * is used in setting the <code>gridFitType</code> property of the TextField
 * class. This setting only works for left-justified text fields and acts
 * like the <code>GridFitType.SUBPIXEL</code> constant in static text. This
 * setting generally provides the best readability for left-aligned text. Use
 * the syntax <code>GridFitType.PIXEL</code>.
 */
GridFitType.PIXEL = "pixel";
/**
 * Fits strong horizontal and vertical lines to the sub-pixel grid on LCD
 * monitors. (Red, green, and blue are actual pixels on an LCD screen.) This
 * is often a good setting for right-aligned or center-aligned dynamic text,
 * and it is sometimes a useful tradeoff for animation vs. text quality. This
 * constant is used in setting the <code>gridFitType</code> property of the
 * TextField class. Use the syntax <code>GridFitType.SUBPIXEL</code>.
 */
GridFitType.SUBPIXEL = "subpixel";

/**
 * The TextFormatAlign class provides values for text alignment in the
 * TextFormat class.
 */
var TextFormatAlign = (function () {
    function TextFormatAlign() {
        /**
         * Constant; centers the text in the text field. Use the syntax
         * <code>TextFormatAlign.CENTER</code>.
         */
        this.CENTER = "center";
        /**
         * Constant; justifies text within the text field. Use the syntax
         * <code>TextFormatAlign.JUSTIFY</code>.
         */
        this.JUSTIFY = "justify";
        /**
         * Constant; aligns text to the left within the text field. Use the syntax
         * <code>TextFormatAlign.LEFT</code>.
         */
        this.LEFT = "left";
        /**
         * Constant; aligns text to the right within the text field. Use the syntax
         * <code>TextFormatAlign.RIGHT</code>.
         */
        this.RIGHT = "right";
    }
    return TextFormatAlign;
}());

/**
 * A class that defines the Interactive mode of a text field object.
 *
 * @see away.entities.TextField#textInteractionMode
 */
var TextInteractionMode = (function () {
    function TextInteractionMode() {
    }
    return TextInteractionMode;
}());
/**
 * The text field's default interaction mode is NORMAL and it varies across
 * platform. On Desktop, the normal mode implies that the text field is in
 * scrollable + selection mode. On Mobile platforms like Android, normal mode
 * implies that the text field can only be scrolled but the text can not be
 * selected.
 */
TextInteractionMode.NORMAL = "normal";
/**
 * On mobile platforms like Android, the text field starts in normal mode
 * (which implies scroll and non-selectable mode). The user can switch to
 * selection mode through the in-built context menu of the text field object.
 */
TextInteractionMode.SELECTION = "selection";

/**
 * The TextLineMetrics class contains information about the text position and
 * measurements of a line of text within a text field. All measurements are in
 * pixels. Objects of this class are returned by the
 * <code>away.entities.TextField.getLineMetrics()</code> method.
 */
var TextLineMetrics = (function () {
    /**
     * Creates a TextLineMetrics object. The TextLineMetrics object contains
     * information about the text metrics of a line of text in a text field.
     * Objects of this class are returned by the
     * away.entities.TextField.getLineMetrics() method.
     *
     * @param x           The left position of the first character in pixels.
     * @param width       The width of the text of the selected lines (not
     *                    necessarily the complete text) in pixels.
     * @param height      The height of the text of the selected lines (not
     *                    necessarily the complete text) in pixels.
     * @param ascent      The length from the baseline to the top of the line
     *                    height in pixels.
     * @param descent     The length from the baseline to the bottom depth of
     *                    the line in pixels.
     * @param leading     The measurement of the vertical distance between the
     *                    lines of text.
     */
    function TextLineMetrics(x, width, height, ascent, descent, leading) {
        if (x === void 0) { x = NaN; }
        if (width === void 0) { width = NaN; }
        if (height === void 0) { height = NaN; }
        if (ascent === void 0) { ascent = NaN; }
        if (descent === void 0) { descent = NaN; }
        if (leading === void 0) { leading = NaN; }
    }
    return TextLineMetrics;
}());

/**
 *  Class Merge merges two or more static sprites into one.<code>Merge</code>
 */
var Merge = (function () {
    /**
     * @param    keepMaterial    [optional]    Determines if the merged object uses the recevier sprite material information or keeps its source material(s). Defaults to false.
     * If false and receiver object has multiple materials, the last material found in receiver subsprites is applied to the merged subsprite(es).
     * @param    disposeSources  [optional]    Determines if the sprite and geometry source(s) used for the merging are disposed. Defaults to false.
     * If true, only receiver geometry and resulting sprite are kept in  memory.
     * @param    objectSpace     [optional]    Determines if source sprite(es) is/are merged using objectSpace or worldspace. Defaults to false.
     */
    function Merge(keepMaterial, disposeSources, objectSpace) {
        if (keepMaterial === void 0) { keepMaterial = false; }
        if (disposeSources === void 0) { disposeSources = false; }
        if (objectSpace === void 0) { objectSpace = false; }
        this._keepMaterial = keepMaterial;
        this._disposeSources = disposeSources;
        this._objectSpace = objectSpace;
    }
    Object.defineProperty(Merge.prototype, "disposeSources", {
        get: function () {
            return this._disposeSources;
        },
        /**
         * Determines if the sprite and geometry source(s) used for the merging are disposed. Defaults to false.
         */
        set: function (b) {
            this._disposeSources = b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Merge.prototype, "keepMaterial", {
        get: function () {
            return this._keepMaterial;
        },
        /**
         * Determines if the material source(s) used for the merging are disposed. Defaults to false.
         */
        set: function (b) {
            this._keepMaterial = b;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Merge.prototype, "objectSpace", {
        get: function () {
            return this._objectSpace;
        },
        /**
         * Determines if source sprite(es) is/are merged using objectSpace or worldspace. Defaults to false.
         */
        set: function (b) {
            this._objectSpace = b;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Merges all the children of a container into a single Sprite. If no Sprite object is found, method returns the receiver without modification.
     *
     * @param    receiver           The Sprite to receive the merged contents of the container.
     * @param    objectContainer    The DisplayObjectContainer holding the sprites to be mergd.
     *
     * @return The merged Sprite instance.
     */
    Merge.prototype.applyToContainer = function (receiver, objectContainer) {
        this.reset();
        //collect container sprites
        this.parseContainer(receiver, objectContainer);
        //collect receiver
        this.collect(receiver, false);
        //merge to receiver
        this.merge(receiver, this._disposeSources);
    };
    /**
     * Merges all the sprites found in the Array&lt;Sprite&gt; into a single Sprite.
     *
     * @param    receiver    The Sprite to receive the merged contents of the sprites.
     * @param    sprites      A series of Sprites to be merged with the reciever sprite.
     */
    Merge.prototype.applyToSprites = function (receiver, sprites) {
        this.reset();
        if (!sprites.length)
            return;
        //collect sprites in vector
        for (var i = 0; i < sprites.length; i++)
            if (sprites[i] != receiver)
                this.collect(sprites[i], this._disposeSources);
        //collect receiver
        this.collect(receiver, false);
        //merge to receiver
        this.merge(receiver, this._disposeSources);
    };
    /**
     *  Merges 2 sprites into one. It is recommand to use apply when 2 sprites are to be merged. If more need to be merged, use either applyToSprites or applyToContainer methods.
     *
     * @param    receiver    The Sprite to receive the merged contents of both sprites.
     * @param    sprite        The Sprite to be merged with the receiver sprite
     */
    Merge.prototype.apply = function (receiver, sprite) {
        this.reset();
        //collect sprite
        this.collect(sprite, this._disposeSources);
        //collect receiver
        this.collect(receiver, false);
        //merge to receiver
        this.merge(receiver, this._disposeSources);
    };
    Merge.prototype.reset = function () {
        this._toDispose = new Array();
        this._shapeVOs = new Array();
    };
    Merge.prototype.merge = function (destSprite, dispose) {
        var i;
        //var oldGraphics:Graphics;
        var destGraphics;
        var useSubMaterials;
        //oldGraphics = destSprite.graphics.clone();
        destGraphics = destSprite.graphics;
        // Only apply materials directly to sub-sprites if necessary,
        // i.e. if there is more than one material available.
        useSubMaterials = (this._shapeVOs.length > 1);
        for (i = 0; i < this._shapeVOs.length; i++) {
            var elements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
            elements.autoDeriveNormals = false;
            elements.autoDeriveTangents = false;
            var data = this._shapeVOs[i];
            elements.setIndices(data.indices);
            elements.setPositions(data.vertices);
            elements.setNormals(data.normals);
            elements.setTangents(data.tangents);
            elements.setUVs(data.uvs);
            if (this._keepMaterial && useSubMaterials)
                destGraphics.addShape(_awayjs_graphics.Shape.getShape(elements, data.material));
            else
                destGraphics.addShape(_awayjs_graphics.Shape.getShape(elements));
        }
        if (this._keepMaterial && !useSubMaterials && this._shapeVOs.length)
            destSprite.material = this._shapeVOs[0].material;
        if (dispose) {
            var len = this._toDispose.length;
            for (var i; i < len; i++)
                this._toDispose[i].dispose();
        }
        this._toDispose = null;
    };
    Merge.prototype.collect = function (sprite, dispose) {
        var subIdx;
        var calc;
        for (subIdx = 0; subIdx < sprite.graphics.count; subIdx++) {
            var i;
            var len;
            var iIdx, vIdx, nIdx, tIdx, uIdx;
            var indexOffset;
            var elements;
            var vo;
            var vertices;
            var normals;
            var tangents;
            var ind;
            elements = sprite.graphics.getShapeAt(subIdx).elements;
            // Get (or create) a VO for this material
            vo = this.getShapeData(sprite.graphics.getShapeAt(subIdx).material);
            // Vertices and normals are copied to temporary vectors, to be transformed
            // before concatenated onto those of the data. This is unnecessary if no
            // transformation will be performed, i.e. for object space merging.
            vertices = (this._objectSpace) ? vo.vertices : new Array();
            normals = (this._objectSpace) ? vo.normals : new Array();
            tangents = (this._objectSpace) ? vo.tangents : new Array();
            // Copy over vertex attributes
            vIdx = vertices.length;
            nIdx = normals.length;
            tIdx = tangents.length;
            uIdx = vo.uvs.length;
            this.copyAttributes(elements.positions, vertices, elements.numVertices, vIdx);
            this.copyAttributes(elements.normals, normals, elements.numVertices, nIdx);
            this.copyAttributes(elements.tangents, tangents, elements.numVertices, tIdx);
            this.copyAttributes(elements.uvs, vo.uvs, elements.numVertices, uIdx);
            // Copy over triangle indices
            indexOffset = (!this._objectSpace) ? vo.vertices.length / 3 : 0;
            iIdx = vo.indices.length;
            len = elements.numElements;
            ind = elements.indices.get(len);
            for (i = 0; i < len; i++) {
                calc = i * 3;
                vo.indices[iIdx++] = ind[calc] + indexOffset;
                vo.indices[iIdx++] = ind[calc + 1] + indexOffset;
                vo.indices[iIdx++] = ind[calc + 2] + indexOffset;
            }
            if (!this._objectSpace) {
                sprite.transform.concatenatedMatrix3D.transformVectors(vertices, vertices);
                sprite.transform.concatenatedMatrix3D.deltaTransformVectors(normals, normals);
                sprite.transform.concatenatedMatrix3D.deltaTransformVectors(tangents, tangents);
                // Copy vertex data from temporary (transformed) vectors
                vIdx = vo.vertices.length;
                nIdx = vo.normals.length;
                tIdx = vo.tangents.length;
                len = vertices.length;
                for (i = 0; i < len; i++) {
                    vo.vertices[vIdx++] = vertices[i];
                    vo.normals[nIdx++] = normals[i];
                    vo.tangents[tIdx++] = tangents[i];
                }
            }
        }
        if (dispose)
            this._toDispose.push(sprite);
    };
    Merge.prototype.copyAttributes = function (attributes, array, count, startIndex) {
        var vertices = attributes.get(count);
        var dim = attributes.dimensions;
        var stride = attributes.stride;
        var len = count * stride;
        for (var i = 0; i < len; i += stride)
            for (var j = 0; j < dim; j++)
                array[startIndex++] = vertices[i + j];
    };
    Merge.prototype.getShapeData = function (material) {
        var data;
        if (this._keepMaterial) {
            var i;
            var len;
            len = this._shapeVOs.length;
            for (i = 0; i < len; i++) {
                if (this._shapeVOs[i].material == material) {
                    data = this._shapeVOs[i];
                    break;
                }
            }
        }
        else if (this._shapeVOs.length) {
            // If materials are not to be kept, all data can be
            // put into a single VO, so return that one.
            data = this._shapeVOs[0];
        }
        // No data (for this material) found, create new.
        if (!data) {
            data = new ShapeVO();
            data.vertices = new Array();
            data.normals = new Array();
            data.tangents = new Array();
            data.uvs = new Array();
            data.indices = new Array();
            data.material = material;
            this._shapeVOs.push(data);
        }
        return data;
    };
    Merge.prototype.parseContainer = function (receiver, object) {
        var child;
        var i;
        if (object instanceof Sprite && object != receiver)
            this.collect(object, this._disposeSources);
        for (i = 0; i < object.numChildren; ++i) {
            child = object.getChildAt(i);
            this.parseContainer(receiver, child);
        }
    };
    return Merge;
}());
var ShapeVO = (function () {
    function ShapeVO() {
    }
    return ShapeVO;
}());

/**
 * Helper class for casting assets to usable objects
 */
var Cast = (function () {
    function Cast() {
    }
    Cast.string = function (data) {
        if (typeof (data) == 'function')
            data = new data;
        if (typeof (data) == 'string')
            return data;
        return data;
    };
    Cast.byteArray = function (data) {
        if (typeof (data) == 'function')
            data = new data;
        if (data instanceof _awayjs_core.ByteArray)
            return data;
        return data;
    };
    //        public static xml(data:any):XML
    //        {
    //            if (typeof(data) == 'function')
    //                data = new data;
    //
    //            if (data is XML)
    //                return data;
    //
    //            return XML(data);
    //        }
    Cast.isHex = function (str) {
        var length = str.length;
        for (var i = 0; i < length; ++i) {
            if (this._hexChars.indexOf(str.charAt(i)) == -1)
                return false;
        }
        return true;
    };
    Cast.tryColor = function (data) {
        if (typeof (data) == 'number' /*uint*/)
            return Math.floor(data);
        if (typeof (data) == 'string') {
            if (data == "random")
                return Math.floor(Math.random() * 0x1000000);
            if (this._colorNames == null) {
                this._colorNames = new Object();
                this._colorNames["steelblue"] = 0x4682B4;
                this._colorNames["royalblue"] = 0x041690;
                this._colorNames["cornflowerblue"] = 0x6495ED;
                this._colorNames["lightsteelblue"] = 0xB0C4DE;
                this._colorNames["mediumslateblue"] = 0x7B68EE;
                this._colorNames["slateblue"] = 0x6A5ACD;
                this._colorNames["darkslateblue"] = 0x483D8B;
                this._colorNames["midnightblue"] = 0x191970;
                this._colorNames["navy"] = 0x000080;
                this._colorNames["darkblue"] = 0x00008B;
                this._colorNames["mediumblue"] = 0x0000CD;
                this._colorNames["blue"] = 0x0000FF;
                this._colorNames["dodgerblue"] = 0x1E90FF;
                this._colorNames["deepskyblue"] = 0x00BFFF;
                this._colorNames["lightskyblue"] = 0x87CEFA;
                this._colorNames["skyblue"] = 0x87CEEB;
                this._colorNames["lightblue"] = 0xADD8E6;
                this._colorNames["powderblue"] = 0xB0E0E6;
                this._colorNames["azure"] = 0xF0FFFF;
                this._colorNames["lightcyan"] = 0xE0FFFF;
                this._colorNames["paleturquoise"] = 0xAFEEEE;
                this._colorNames["mediumturquoise"] = 0x48D1CC;
                this._colorNames["lightseagreen"] = 0x20B2AA;
                this._colorNames["darkcyan"] = 0x008B8B;
                this._colorNames["teal"] = 0x008080;
                this._colorNames["cadetblue"] = 0x5F9EA0;
                this._colorNames["darkturquoise"] = 0x00CED1;
                this._colorNames["aqua"] = 0x00FFFF;
                this._colorNames["cyan"] = 0x00FFFF;
                this._colorNames["turquoise"] = 0x40E0D0;
                this._colorNames["aquamarine"] = 0x7FFFD4;
                this._colorNames["mediumaquamarine"] = 0x66CDAA;
                this._colorNames["darkseagreen"] = 0x8FBC8F;
                this._colorNames["mediumseagreen"] = 0x3CB371;
                this._colorNames["seagreen"] = 0x2E8B57;
                this._colorNames["darkgreen"] = 0x006400;
                this._colorNames["green"] = 0x008000;
                this._colorNames["forestgreen"] = 0x228B22;
                this._colorNames["limegreen"] = 0x32CD32;
                this._colorNames["lime"] = 0x00FF00;
                this._colorNames["chartreuse"] = 0x7FFF00;
                this._colorNames["lawngreen"] = 0x7CFC00;
                this._colorNames["greenyellow"] = 0xADFF2F;
                this._colorNames["yellowgreen"] = 0x9ACD32;
                this._colorNames["palegreen"] = 0x98FB98;
                this._colorNames["lightgreen"] = 0x90EE90;
                this._colorNames["springgreen"] = 0x00FF7F;
                this._colorNames["mediumspringgreen"] = 0x00FA9A;
                this._colorNames["darkolivegreen"] = 0x556B2F;
                this._colorNames["olivedrab"] = 0x6B8E23;
                this._colorNames["olive"] = 0x808000;
                this._colorNames["darkkhaki"] = 0xBDB76B;
                this._colorNames["darkgoldenrod"] = 0xB8860B;
                this._colorNames["goldenrod"] = 0xDAA520;
                this._colorNames["gold"] = 0xFFD700;
                this._colorNames["yellow"] = 0xFFFF00;
                this._colorNames["khaki"] = 0xF0E68C;
                this._colorNames["palegoldenrod"] = 0xEEE8AA;
                this._colorNames["blanchedalmond"] = 0xFFEBCD;
                this._colorNames["moccasin"] = 0xFFE4B5;
                this._colorNames["wheat"] = 0xF5DEB3;
                this._colorNames["navajowhite"] = 0xFFDEAD;
                this._colorNames["burlywood"] = 0xDEB887;
                this._colorNames["tan"] = 0xD2B48C;
                this._colorNames["rosybrown"] = 0xBC8F8F;
                this._colorNames["sienna"] = 0xA0522D;
                this._colorNames["saddlebrown"] = 0x8B4513;
                this._colorNames["chocolate"] = 0xD2691E;
                this._colorNames["peru"] = 0xCD853F;
                this._colorNames["sandybrown"] = 0xF4A460;
                this._colorNames["darkred"] = 0x8B0000;
                this._colorNames["maroon"] = 0x800000;
                this._colorNames["brown"] = 0xA52A2A;
                this._colorNames["firebrick"] = 0xB22222;
                this._colorNames["indianred"] = 0xCD5C5C;
                this._colorNames["lightcoral"] = 0xF08080;
                this._colorNames["salmon"] = 0xFA8072;
                this._colorNames["darksalmon"] = 0xE9967A;
                this._colorNames["lightsalmon"] = 0xFFA07A;
                this._colorNames["coral"] = 0xFF7F50;
                this._colorNames["tomato"] = 0xFF6347;
                this._colorNames["darkorange"] = 0xFF8C00;
                this._colorNames["orange"] = 0xFFA500;
                this._colorNames["orangered"] = 0xFF4500;
                this._colorNames["crimson"] = 0xDC143C;
                this._colorNames["red"] = 0xFF0000;
                this._colorNames["deeppink"] = 0xFF1493;
                this._colorNames["fuchsia"] = 0xFF00FF;
                this._colorNames["magenta"] = 0xFF00FF;
                this._colorNames["hotpink"] = 0xFF69B4;
                this._colorNames["lightpink"] = 0xFFB6C1;
                this._colorNames["pink"] = 0xFFC0CB;
                this._colorNames["palevioletred"] = 0xDB7093;
                this._colorNames["mediumvioletred"] = 0xC71585;
                this._colorNames["purple"] = 0x800080;
                this._colorNames["darkmagenta"] = 0x8B008B;
                this._colorNames["mediumpurple"] = 0x9370DB;
                this._colorNames["blueviolet"] = 0x8A2BE2;
                this._colorNames["indigo"] = 0x4B0082;
                this._colorNames["darkviolet"] = 0x9400D3;
                this._colorNames["darkorchid"] = 0x9932CC;
                this._colorNames["mediumorchid"] = 0xBA55D3;
                this._colorNames["orchid"] = 0xDA70D6;
                this._colorNames["violet"] = 0xEE82EE;
                this._colorNames["plum"] = 0xDDA0DD;
                this._colorNames["thistle"] = 0xD8BFD8;
                this._colorNames["lavender"] = 0xE6E6FA;
                this._colorNames["ghostwhite"] = 0xF8F8FF;
                this._colorNames["aliceblue"] = 0xF0F8FF;
                this._colorNames["mintcream"] = 0xF5FFFA;
                this._colorNames["honeydew"] = 0xF0FFF0;
                this._colorNames["lightgoldenrodyellow"] = 0xFAFAD2;
                this._colorNames["lemonchiffon"] = 0xFFFACD;
                this._colorNames["cornsilk"] = 0xFFF8DC;
                this._colorNames["lightyellow"] = 0xFFFFE0;
                this._colorNames["ivory"] = 0xFFFFF0;
                this._colorNames["floralwhite"] = 0xFFFAF0;
                this._colorNames["linen"] = 0xFAF0E6;
                this._colorNames["oldlace"] = 0xFDF5E6;
                this._colorNames["antiquewhite"] = 0xFAEBD7;
                this._colorNames["bisque"] = 0xFFE4C4;
                this._colorNames["peachpuff"] = 0xFFDAB9;
                this._colorNames["papayawhip"] = 0xFFEFD5;
                this._colorNames["beige"] = 0xF5F5DC;
                this._colorNames["seashell"] = 0xFFF5EE;
                this._colorNames["lavenderblush"] = 0xFFF0F5;
                this._colorNames["mistyrose"] = 0xFFE4E1;
                this._colorNames["snow"] = 0xFFFAFA;
                this._colorNames["white"] = 0xFFFFFF;
                this._colorNames["whitesmoke"] = 0xF5F5F5;
                this._colorNames["gainsboro"] = 0xDCDCDC;
                this._colorNames["lightgrey"] = 0xD3D3D3;
                this._colorNames["silver"] = 0xC0C0C0;
                this._colorNames["darkgrey"] = 0xA9A9A9;
                this._colorNames["grey"] = 0x808080;
                this._colorNames["lightslategrey"] = 0x778899;
                this._colorNames["slategrey"] = 0x708090;
                this._colorNames["dimgrey"] = 0x696969;
                this._colorNames["darkslategrey"] = 0x2F4F4F;
                this._colorNames["black"] = 0x000000;
                this._colorNames["transparent"] = 0xFF000000;
            }
            if (this._colorNames[data] != null)
                return this._colorNames[data];
            if ((data.length == 6) && this.isHex(data))
                return parseInt("0x" + data);
        }
        return null;
    };
    Cast.color = function (data) {
        var result = this.tryColor(data);
        if (result == null)
            throw new CastError("Can't cast to color: " + data);
        return result;
    };
    Cast.tryClass = function (name) {
        if (this._notClasses[name])
            return name;
        var result = this._classes[name];
        if (result != null)
            return result;
        try {
            result = window[name];
            this._classes[name] = result;
            return result;
        }
        catch (e /*ReferenceError*/) {
        }
        this._notClasses[name] = true;
        return name;
    };
    Cast.image2D = function (data) {
        if (data == null)
            return null;
        if (typeof (data) == 'string')
            data = this.tryClass(data);
        if (typeof (data) == 'function') {
            try {
                data = new data();
            }
            catch (e /*ArgumentError*/) {
                data = new data(0, 0);
            }
        }
        if (data instanceof _awayjs_graphics.Image2D)
            return data;
        if (data instanceof _awayjs_graphics.Single2DTexture)
            data = data.image2D;
        throw new CastError("Can't cast to BitmapImage2D: " + data);
    };
    Cast.bitmapTexture = function (data) {
        if (data == null)
            return null;
        if (typeof (data) == 'string')
            data = this.tryClass(data);
        if (typeof (data) == 'function') {
            try {
                data = new data();
            }
            catch (e /*ArgumentError*/) {
                data = new data(0, 0);
            }
        }
        if (data instanceof _awayjs_graphics.Single2DTexture)
            return data;
        try {
            var bmd = Cast.image2D(data);
            return new _awayjs_graphics.Single2DTexture(bmd);
        }
        catch (e /*CastError*/) {
        }
        throw new CastError("Can't cast to Single2DTexture: " + data);
    };
    return Cast;
}());
Cast._hexChars = "0123456789abcdefABCDEF";
Cast._notClasses = new Object();
Cast._classes = new Object();

var Scene = (function (_super) {
    __extends(Scene, _super);
    function Scene() {
        var _this = _super.call(this) || this;
        _this._objects = new Object();
        _this._views = new Array();
        _this._iCollectionMark = 0;
        _this.mouseEnabled = false;
        _this._iIsRoot = true;
        _this._iIsPartition = true;
        _this._pScene = _this;
        _this._pPartition = _this;
        return _this;
    }
    Object.defineProperty(Scene.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return Scene.assetType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @internal
     */
    Scene.prototype._iRegisterObject = function (displayObject) {
        this._objects[displayObject.id] = displayObject;
        var len = this._views.length;
        for (var i = 0; i < len; i++)
            this._views[i].registerObject(displayObject);
    };
    /**
     * @internal
     */
    Scene.prototype._iUnregisterObject = function (displayObject) {
        delete this._objects[displayObject.id];
        var len = this._views.length;
        for (var i = 0; i < len; i++)
            this._views[i].unRegisterObject(displayObject);
    };
    /**
     * @internal
     */
    Scene.prototype._iRegisterView = function (view) {
        this._views.push(view);
        for (var key in this._objects)
            view.registerObject(this._objects[key]);
    };
    /**
     * @internal
     */
    Scene.prototype._iUnregisterView = function (view) {
        this._views.splice(this._views.indexOf(view), 1);
        for (var key in this._objects)
            view.unRegisterObject(this._objects[key]);
    };
    return Scene;
}(DisplayObjectContainer));
Scene.assetType = "[asset Scene]";

exports.AlignmentMode = AlignmentMode;
exports.HierarchicalProperties = HierarchicalProperties;
exports.OrientationMode = OrientationMode;
exports.Timeline = Timeline;
exports.TouchPoint = TouchPoint;
exports.AxisAlignedBoundingBox = AxisAlignedBoundingBox;
exports.AxisAlignedBoundingBox2D = AxisAlignedBoundingBox2D;
exports.BoundingSphere = BoundingSphere;
exports.BoundingVolumeBase = BoundingVolumeBase;
exports.BoundsType = BoundsType;
exports.NullBounds = NullBounds;
exports.ControllerBase = ControllerBase;
exports.FirstPersonController = FirstPersonController;
exports.FollowController = FollowController;
exports.HoverController = HoverController;
exports.LookAtController = LookAtController;
exports.SpringController = SpringController;
exports.Billboard = Billboard;
exports.Camera = Camera;
exports.DirectionalLight = DirectionalLight;
exports.DisplayObject = DisplayObject;
exports.DisplayObjectContainer = DisplayObjectContainer;
exports.LightBase = LightBase;
exports.LightProbe = LightProbe;
exports.LineSegment = LineSegment;
exports.LoaderContainer = LoaderContainer;
exports.MovieClip = MovieClip;
exports.PointLight = PointLight;
exports.Skybox = Skybox;
exports.Sprite = Sprite;
exports.TextField = TextField;
exports.TextureProjector = TextureProjector;
exports.CastError = CastError;
exports.CameraEvent = CameraEvent;
exports.DisplayObjectEvent = DisplayObjectEvent;
exports.LightEvent = LightEvent;
exports.MouseEvent = MouseEvent;
exports.ResizeEvent = ResizeEvent;
exports.TextureProjectorEvent = TextureProjectorEvent;
exports.TouchEvent = TouchEvent;
exports.FrameScriptManager = FrameScriptManager;
exports.LightPickerBase = LightPickerBase;
exports.LightSources = LightSources;
exports.StaticLightPicker = StaticLightPicker;
exports.CascadeShadowMapper = CascadeShadowMapper;
exports.CubeMapShadowMapper = CubeMapShadowMapper;
exports.DirectionalShadowMapper = DirectionalShadowMapper;
exports.NearDirectionalShadowMapper = NearDirectionalShadowMapper;
exports.ShadowMapperBase = ShadowMapperBase;
exports.PrefabBase = PrefabBase;
exports.PrimitiveCapsulePrefab = PrimitiveCapsulePrefab;
exports.PrimitiveConePrefab = PrimitiveConePrefab;
exports.PrimitiveCubePrefab = PrimitiveCubePrefab;
exports.PrimitiveCylinderPrefab = PrimitiveCylinderPrefab;
exports.PrimitivePlanePrefab = PrimitivePlanePrefab;
exports.PrimitivePolygonPrefab = PrimitivePolygonPrefab;
exports.PrimitivePrefabBase = PrimitivePrefabBase;
exports.PrimitiveSpherePrefab = PrimitiveSpherePrefab;
exports.PrimitiveTorusPrefab = PrimitiveTorusPrefab;
exports.AntiAliasType = AntiAliasType;
exports.Font = Font;
exports.GridFitType = GridFitType;
exports.TesselatedFontTable = TesselatedFontTable;
exports.BitmapFontTable = BitmapFontTable;
exports.TesselatedFontChar = TesselatedFontChar;
exports.BitmapFontChar = BitmapFontChar;
exports.TextFieldAutoSize = TextFieldAutoSize;
exports.TextFieldType = TextFieldType;
exports.TextFormat = TextFormat;
exports.TextFormatAlign = TextFormatAlign;
exports.TextInteractionMode = TextInteractionMode;
exports.TextLineMetrics = TextLineMetrics;
exports.Merge = Merge;
exports.Cast = Cast;
exports.Scene = Scene;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_player__ = __webpack_require__(20);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__awayjs_player___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__awayjs_player__);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__awayjs_player__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__awayjs_player__[key]; }) }(__WEBPACK_IMPORT_KEY__));



/***/ },
/* 12 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(7), __webpack_require__(9), __webpack_require__(13), __webpack_require__(10)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/core', '@awayjs/graphics', '@awayjs/stage', '@awayjs/scene'], factory) :
    (factory((global.AwayjsRenderer = global.AwayjsRenderer || {}),global.AwayjsCore,global.AwayjsGraphics,global.AwayjsStage,global.AwayjsScene));
}(this, (function (exports,_awayjs_core,_awayjs_graphics,_awayjs_stage,_awayjs_scene) { 'use strict';

/**
 * ...
 */
var AnimationElements = (function () {
    function AnimationElements() {
        this._pVertexBuffer = new Array(8);
        this._pBufferContext = new Array(8);
        this._pBufferDirty = new Array(8);
        this.numProcessedVertices = 0;
        this.previousTime = Number.NEGATIVE_INFINITY;
        this.animationParticles = new Array();
        for (var i = 0; i < 8; i++)
            this._pBufferDirty[i] = true;
        this._iUniqueId = AnimationElements.SUBGEOM_ID_COUNT++;
    }
    AnimationElements.prototype.createVertexData = function (numVertices, totalLenOfOneVertex) {
        this._numVertices = numVertices;
        this._totalLenOfOneVertex = totalLenOfOneVertex;
        this._pVertexData = new Array(numVertices * totalLenOfOneVertex);
    };
    AnimationElements.prototype.activateVertexBuffer = function (index, bufferOffset, stage, format) {
        var contextIndex = stage.stageIndex;
        var context = stage.context;
        var buffer = this._pVertexBuffer[contextIndex];
        if (!buffer || this._pBufferContext[contextIndex] != context) {
            buffer = this._pVertexBuffer[contextIndex] = context.createVertexBuffer(this._numVertices, this._totalLenOfOneVertex * 4);
            this._pBufferContext[contextIndex] = context;
            this._pBufferDirty[contextIndex] = true;
        }
        if (this._pBufferDirty[contextIndex]) {
            buffer.uploadFromArray(this._pVertexData, 0, this._numVertices);
            this._pBufferDirty[contextIndex] = false;
        }
        context.setVertexBufferAt(index, buffer, bufferOffset * 4, format);
    };
    AnimationElements.prototype.dispose = function () {
        while (this._pVertexBuffer.length) {
            var vertexBuffer = this._pVertexBuffer.pop();
            if (vertexBuffer)
                vertexBuffer.dispose();
        }
    };
    AnimationElements.prototype.invalidateBuffer = function () {
        for (var i = 0; i < 8; i++)
            this._pBufferDirty[i] = true;
    };
    Object.defineProperty(AnimationElements.prototype, "vertexData", {
        get: function () {
            return this._pVertexData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationElements.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationElements.prototype, "totalLenOfOneVertex", {
        get: function () {
            return this._totalLenOfOneVertex;
        },
        enumerable: true,
        configurable: true
    });
    return AnimationElements;
}());
AnimationElements.SUBGEOM_ID_COUNT = 0;

var ColorSegmentPoint = (function () {
    function ColorSegmentPoint(life, color) {
        //0<life<1
        if (life <= 0 || life >= 1)
            throw (new Error("life exceeds range (0,1)"));
        this._life = life;
        this._color = color;
    }
    Object.defineProperty(ColorSegmentPoint.prototype, "color", {
        get: function () {
            return this._color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ColorSegmentPoint.prototype, "life", {
        get: function () {
            return this._life;
        },
        enumerable: true,
        configurable: true
    });
    return ColorSegmentPoint;
}());

/**
 * Contains transformation data for a skeleton joint, used for skeleton animation.
 *
 * @see away.animation.Skeleton
 * @see away.animation.SkeletonJoint
 *
 * todo: support (uniform) scale
 */
var JointPose = (function () {
    function JointPose() {
        /**
         * The rotation of the pose stored as a quaternion
         */
        this.orientation = new _awayjs_core.Quaternion();
        /**
         * The translation of the pose
         */
        this.translation = new _awayjs_core.Vector3D();
    }
    /**
     * Converts the transformation to a Matrix3D representation.
     *
     * @param target An optional target matrix to store the transformation. If not provided, it will create a new instance.
     * @return The transformation matrix of the pose.
     */
    JointPose.prototype.toMatrix3D = function (target) {
        if (target === void 0) { target = null; }
        if (target == null)
            target = new _awayjs_core.Matrix3D();
        this.orientation.toMatrix3D(target);
        target.appendTranslation(this.translation.x, this.translation.y, this.translation.z);
        return target;
    };
    /**
     * Copies the transformation data from a source pose object into the existing pose object.
     *
     * @param pose The source pose to copy from.
     */
    JointPose.prototype.copyFrom = function (pose) {
        var or = pose.orientation;
        var tr = pose.translation;
        this.orientation.x = or.x;
        this.orientation.y = or.y;
        this.orientation.z = or.z;
        this.orientation.w = or.w;
        this.translation.x = tr.x;
        this.translation.y = tr.y;
        this.translation.z = tr.z;
    };
    return JointPose;
}());

/**
 * ...
 */
var ParticleAnimationData = (function () {
    function ParticleAnimationData(index, startTime, duration, delay, particle) {
        this.index = index;
        this.startTime = startTime;
        this.totalTime = duration + delay;
        this.duration = duration;
        this.delay = delay;
        this.startVertexIndex = particle.startVertexIndex;
        this.numVertices = particle.numVertices;
    }
    return ParticleAnimationData;
}());

/**
 * Dynamic class for holding the local properties of a particle, used for processing the static properties
 * of particles in the particle animation set before beginning upload to the GPU.
 */
var ParticleProperties = (function () {
    function ParticleProperties() {
    }
    return ParticleProperties;
}());

/**
 * Options for setting the properties mode of a particle animation node.
 */
var ParticlePropertiesMode = (function () {
    function ParticlePropertiesMode() {
    }
    return ParticlePropertiesMode;
}());
/**
 * Mode that defines the particle node as acting on global properties (ie. the properties set in the node constructor or the corresponding animation state).
 */
ParticlePropertiesMode.GLOBAL = 0;
/**
 * Mode that defines the particle node as acting on local static properties (ie. the properties of particles set in the initialising on the animation set).
 */
ParticlePropertiesMode.LOCAL_STATIC = 1;
/**
 * Mode that defines the particle node as acting on local dynamic properties (ie. the properties of the particles set in the corresponding animation state).
 */
ParticlePropertiesMode.LOCAL_DYNAMIC = 2;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

/**
 * A Skeleton object is a hierarchical grouping of joint objects that can be used for skeletal animation.
 *
 * @see away.animators.SkeletonJoint
 */
var Skeleton = (function (_super) {
    __extends(Skeleton, _super);
    /**
     * Creates a new <code>Skeleton</code> object
     */
    function Skeleton() {
        var _this = _super.call(this) || this;
        // in the long run, it might be a better idea to not store Joint objects, but keep all data in Vectors, that we can upload easily?
        _this.joints = new Array();
        return _this;
    }
    Object.defineProperty(Skeleton.prototype, "numJoints", {
        /**
         * The total number of joints in the skeleton.
         */
        get: function () {
            return this.joints.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the joint object in the skeleton with the given name, otherwise returns a null object.
     *
     * @param jointName The name of the joint object to be found.
     * @return The joint object with the given name.
     *
     * @see #joints
     */
    Skeleton.prototype.jointFromName = function (jointName) {
        var jointIndex = this.jointIndexFromName(jointName);
        if (jointIndex != -1)
            return this.joints[jointIndex];
        else
            return null;
    };
    /**
     * Returns the joint index, given the joint name. -1 is returned if the joint name is not found.
     *
     * @param jointName The name of the joint object to be found.
     * @return The index of the joint object in the joints Array
     *
     * @see #joints
     */
    Skeleton.prototype.jointIndexFromName = function (jointName) {
        // this is implemented as a linear search, rather than a possibly
        // more optimal method (Dictionary lookup, for example) because:
        // a) it is assumed that it will be called once for each joint
        // b) it is assumed that it will be called only during load, and not during main loop
        // c) maintaining a dictionary (for safety) would dictate an interface to access SkeletonJoints,
        //    rather than direct array access.  this would be sub-optimal.
        var jointIndex;
        var joint;
        for (var i; i < this.joints.length; i++) {
            joint = this.joints[i];
            if (joint.name == jointName)
                return jointIndex;
            jointIndex++;
        }
        return -1;
    };
    /**
     * @inheritDoc
     */
    Skeleton.prototype.dispose = function () {
        this.joints.length = 0;
    };
    Object.defineProperty(Skeleton.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return Skeleton.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return Skeleton;
}(_awayjs_core.AssetBase));
Skeleton.assetType = "[asset Skeleton]";

/**
 * A value obect representing a single joint in a skeleton object.
 *
 * @see away.animators.Skeleton
 */
var SkeletonJoint = (function () {
    /**
     * Creates a new <code>SkeletonJoint</code> object
     */
    function SkeletonJoint() {
        /**
         * The index of the parent joint in the skeleton's joints vector.
         *
         * @see away.animators.Skeleton#joints
         */
        this.parentIndex = -1;
    }
    return SkeletonJoint;
}());

/**
 * A collection of pose objects, determining the pose for an entire skeleton.
 * The <code>jointPoses</code> vector object corresponds to a skeleton's <code>joints</code> vector object, however, there is no
 * reference to a skeleton's instance, since several skeletons can be influenced by the same pose (eg: animation
 * clips are added to any animator with a valid skeleton)
 *
 * @see away.animators.Skeleton
 * @see away.animators.JointPose
 */
var SkeletonPose = (function (_super) {
    __extends(SkeletonPose, _super);
    /**
     * Creates a new <code>SkeletonPose</code> object.
     */
    function SkeletonPose() {
        var _this = _super.call(this) || this;
        _this.jointPoses = new Array();
        return _this;
    }
    Object.defineProperty(SkeletonPose.prototype, "numJointPoses", {
        /**
         * The total number of joint poses in the skeleton pose.
         */
        get: function () {
            return this.jointPoses.length;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonPose.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return SkeletonPose.assetType;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the joint pose object with the given joint name, otherwise returns a null object.
     *
     * @param jointName The name of the joint object whose pose is to be found.
     * @return The pose object with the given joint name.
     */
    SkeletonPose.prototype.jointPoseFromName = function (jointName) {
        var jointPoseIndex = this.jointPoseIndexFromName(jointName);
        if (jointPoseIndex != -1)
            return this.jointPoses[jointPoseIndex];
        else
            return null;
    };
    /**
     * Returns the pose index, given the joint name. -1 is returned if the joint name is not found in the pose.
     *
     * @param The name of the joint object whose pose is to be found.
     * @return The index of the pose object in the jointPoses Array
     *
     * @see #jointPoses
     */
    SkeletonPose.prototype.jointPoseIndexFromName = function (jointName) {
        // this is implemented as a linear search, rather than a possibly
        // more optimal method (Dictionary lookup, for example) because:
        // a) it is assumed that it will be called once for each joint
        // b) it is assumed that it will be called only during load, and not during main loop
        // c) maintaining a dictionary (for safety) would dictate an interface to access JointPoses,
        //    rather than direct array access.  this would be sub-optimal.
        var jointPoseIndex;
        var jointPose;
        for (var i; i < this.jointPoses.length; i++) {
            jointPose = this.jointPoses[i];
            if (jointPose.name == jointName)
                return jointPoseIndex;
            jointPoseIndex++;
        }
        return -1;
    };
    /**
     * Creates a copy of the <code>SkeletonPose</code> object, with a dulpicate of its component joint poses.
     *
     * @return SkeletonPose
     */
    SkeletonPose.prototype.clone = function () {
        var clone = new SkeletonPose();
        var numJointPoses = this.jointPoses.length;
        for (var i = 0; i < numJointPoses; i++) {
            var cloneJointPose = new JointPose();
            var thisJointPose = this.jointPoses[i];
            cloneJointPose.name = thisJointPose.name;
            cloneJointPose.copyFrom(thisJointPose);
            clone.jointPoses[i] = cloneJointPose;
        }
        return clone;
    };
    /**
     * @inheritDoc
     */
    SkeletonPose.prototype.dispose = function () {
        this.jointPoses.length = 0;
    };
    return SkeletonPose;
}(_awayjs_core.AssetBase));
SkeletonPose.assetType = "[asset SkeletonPose]";

/**
 * Options for setting the animation mode of a vertex animator object.
 *
 * @see away.animators.VertexAnimator
 */
var VertexAnimationMode = (function () {
    function VertexAnimationMode() {
    }
    return VertexAnimationMode;
}());
/**
 * Animation mode that adds all outputs from active vertex animation state to form the current vertex animation pose.
 */
VertexAnimationMode.ADDITIVE = "additive";
/**
 * Animation mode that picks the output from a single vertex animation state to form the current vertex animation pose.
 */
VertexAnimationMode.ABSOLUTE = "absolute";

/**
 * Provides an abstract base class for nodes with time-based animation data in an animation blend tree.
 */
var AnimationClipNodeBase = (function (_super) {
    __extends(AnimationClipNodeBase, _super);
    /**
     * Creates a new <code>AnimationClipNodeBase</code> object.
     */
    function AnimationClipNodeBase() {
        var _this = _super.call(this) || this;
        _this._pLooping = true;
        _this._pTotalDuration = 0;
        _this._pStitchDirty = true;
        _this._pStitchFinalFrame = false;
        _this._pNumFrames = 0;
        _this._pDurations = new Array();
        /*uint*/
        _this._pTotalDelta = new _awayjs_core.Vector3D();
        _this.fixedFrameRate = true;
        return _this;
    }
    Object.defineProperty(AnimationClipNodeBase.prototype, "looping", {
        /**
         * Determines whether the contents of the animation node have looping characteristics enabled.
         */
        get: function () {
            return this._pLooping;
        },
        set: function (value) {
            if (this._pLooping == value)
                return;
            this._pLooping = value;
            this._pStitchDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationClipNodeBase.prototype, "stitchFinalFrame", {
        /**
         * Defines if looping content blends the final frame of animation data with the first (true) or works on the
         * assumption that both first and last frames are identical (false). Defaults to false.
         */
        get: function () {
            return this._pStitchFinalFrame;
        },
        set: function (value) {
            if (this._pStitchFinalFrame == value)
                return;
            this._pStitchFinalFrame = value;
            this._pStitchDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationClipNodeBase.prototype, "totalDuration", {
        get: function () {
            if (this._pStitchDirty)
                this._pUpdateStitch();
            return this._pTotalDuration;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationClipNodeBase.prototype, "totalDelta", {
        get: function () {
            if (this._pStitchDirty)
                this._pUpdateStitch();
            return this._pTotalDelta;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationClipNodeBase.prototype, "lastFrame", {
        get: function () {
            if (this._pStitchDirty)
                this._pUpdateStitch();
            return this._pLastFrame;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationClipNodeBase.prototype, "durations", {
        /**
         * Returns a vector of time values representing the duration (in milliseconds) of each animation frame in the clip.
         */
        get: function () {
            return this._pDurations;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Updates the node's final frame stitch state.
     *
     * @see #stitchFinalFrame
     */
    AnimationClipNodeBase.prototype._pUpdateStitch = function () {
        this._pStitchDirty = false;
        this._pLastFrame = (this._pStitchFinalFrame) ? this._pNumFrames : this._pNumFrames - 1;
        this._pTotalDuration = 0;
        this._pTotalDelta.x = 0;
        this._pTotalDelta.y = 0;
        this._pTotalDelta.z = 0;
    };
    return AnimationClipNodeBase;
}(_awayjs_graphics.AnimationNodeBase));

/**
 *
 */
var AnimationStateBase = (function () {
    function AnimationStateBase(animator, animationNode) {
        this._pRootDelta = new _awayjs_core.Vector3D();
        this._pPositionDeltaDirty = true;
        this._pStartTime = 0;
        this._pAnimator = animator;
        this._pAnimationNode = animationNode;
    }
    Object.defineProperty(AnimationStateBase.prototype, "positionDelta", {
        /**
         * Returns a 3d vector representing the translation delta of the animating entity for the current timestep of animation
         */
        get: function () {
            if (this._pPositionDeltaDirty) {
                this._pUpdatePositionDelta();
            }
            return this._pRootDelta;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Resets the start time of the node to a  new value.
     *
     * @param startTime The absolute start time (in milliseconds) of the node's starting time.
     */
    AnimationStateBase.prototype.offset = function (startTime) {
        this._pStartTime = startTime;
        this._pPositionDeltaDirty = true;
    };
    /**
     * Updates the configuration of the node to its current state.
     *
     * @param time The absolute time (in milliseconds) of the animator's play head position.
     *
     * @see AnimatorBase#update()
     */
    AnimationStateBase.prototype.update = function (time) {
        if (this._pTime == time - this._pStartTime) {
            return;
        }
        this._pUpdateTime(time);
    };
    /**
     * Sets the animation phase of the node.
     *
     * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
     */
    AnimationStateBase.prototype.phase = function (value) {
    };
    /**
     * Updates the node's internal playhead position.
     *
     * @param time The local time (in milliseconds) of the node's playhead position.
     */
    AnimationStateBase.prototype._pUpdateTime = function (time) {
        this._pTime = time - this._pStartTime;
        this._pPositionDeltaDirty = true;
    };
    /**
     * Updates the node's root delta position
     */
    AnimationStateBase.prototype._pUpdatePositionDelta = function () {
    };
    return AnimationStateBase;
}());

/**
 * ...
 */
var ParticleStateBase = (function (_super) {
    __extends(ParticleStateBase, _super);
    function ParticleStateBase(animator, particleNode, needUpdateTime) {
        if (needUpdateTime === void 0) { needUpdateTime = false; }
        var _this = _super.call(this, animator, particleNode) || this;
        _this._pDynamicProperties = new Array();
        _this._pDynamicPropertiesDirty = new Object();
        _this._pParticleAnimator = animator;
        _this._particleNode = particleNode;
        _this._pNeedUpdateTime = needUpdateTime;
        return _this;
    }
    Object.defineProperty(ParticleStateBase.prototype, "needUpdateTime", {
        get: function () {
            return this._pNeedUpdateTime;
        },
        enumerable: true,
        configurable: true
    });
    ParticleStateBase.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
    };
    ParticleStateBase.prototype._pUpdateDynamicProperties = function (animationElements) {
        this._pDynamicPropertiesDirty[animationElements._iUniqueId] = true;
        var animationParticles = animationElements.animationParticles;
        var vertexData = animationElements.vertexData;
        var totalLenOfOneVertex = animationElements.totalLenOfOneVertex;
        var dataLength = this._particleNode.dataLength;
        var dataOffset = this._particleNode._iDataOffset;
        var vertexLength;
        //			var particleOffset:number;
        var startingOffset;
        var vertexOffset;
        var data;
        var animationParticle;
        //			var numParticles:number = _positions.length/dataLength;
        var numParticles = this._pDynamicProperties.length;
        var i = 0;
        var j = 0;
        var k = 0;
        //loop through all particles
        while (i < numParticles) {
            //loop through each particle data for the current particle
            while (j < numParticles && (animationParticle = animationParticles[j]).index == i) {
                data = this._pDynamicProperties[i];
                vertexLength = animationParticle.numVertices * totalLenOfOneVertex;
                startingOffset = animationParticle.startVertexIndex * totalLenOfOneVertex + dataOffset;
                //loop through each vertex in the particle data
                for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
                    vertexOffset = startingOffset + k;
                    //						particleOffset = i * dataLength;
                    //loop through all vertex data for the current particle data
                    for (k = 0; k < vertexLength; k += totalLenOfOneVertex) {
                        vertexOffset = startingOffset + k;
                        vertexData[vertexOffset++] = data.x;
                        vertexData[vertexOffset++] = data.y;
                        vertexData[vertexOffset++] = data.z;
                        if (dataLength == 4)
                            vertexData[vertexOffset++] = data.w;
                    }
                }
                j++;
            }
            i++;
        }
        animationElements.invalidateBuffer();
    };
    return ParticleStateBase;
}(AnimationStateBase));

/**
 * ...
 */
var ParticleAccelerationState = (function (_super) {
    __extends(ParticleAccelerationState, _super);
    function ParticleAccelerationState(animator, particleAccelerationNode) {
        var _this = _super.call(this, animator, particleAccelerationNode) || this;
        _this._particleAccelerationNode = particleAccelerationNode;
        _this._acceleration = _this._particleAccelerationNode._acceleration;
        _this.updateAccelerationData();
        return _this;
    }
    Object.defineProperty(ParticleAccelerationState.prototype, "acceleration", {
        /**
         * Defines the acceleration vector of the state, used when in global mode.
         */
        get: function () {
            return this._acceleration;
        },
        set: function (value) {
            this._acceleration.x = value.x;
            this._acceleration.y = value.y;
            this._acceleration.z = value.z;
            this.updateAccelerationData();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleAccelerationState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleAccelerationState.ACCELERATION_INDEX);
        if (this._particleAccelerationNode.mode == ParticlePropertiesMode.LOCAL_STATIC)
            animationElements.activateVertexBuffer(index, this._particleAccelerationNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
        else
            shader.setVertexConst(index, this._halfAcceleration.x, this._halfAcceleration.y, this._halfAcceleration.z);
    };
    ParticleAccelerationState.prototype.updateAccelerationData = function () {
        if (this._particleAccelerationNode.mode == ParticlePropertiesMode.GLOBAL)
            this._halfAcceleration = new _awayjs_core.Vector3D(this._acceleration.x / 2, this._acceleration.y / 2, this._acceleration.z / 2);
    };
    return ParticleAccelerationState;
}(ParticleStateBase));
/** @private */
ParticleAccelerationState.ACCELERATION_INDEX = 0;

/**
 * Provides an abstract base class for particle animation nodes.
 */
var ParticleNodeBase = (function (_super) {
    __extends(ParticleNodeBase, _super);
    /**
     * Creates a new <code>ParticleNodeBase</code> object.
     *
     * @param               name            Defines the generic name of the particle animation node.
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param               dataLength      Defines the length of the data used by the node when in <code>LOCAL_STATIC</code> mode.
     * @param    [optional] priority        the priority of the particle animation node, used to order the agal generated in a particle animation set. Defaults to 1.
     */
    function ParticleNodeBase(name, mode, dataLength, priority) {
        if (priority === void 0) { priority = 1; }
        var _this = _super.call(this) || this;
        _this._pDataLength = 3;
        name = name + ParticleNodeBase.MODES[mode];
        _this.name = name;
        _this._pMode = mode;
        _this._priority = priority;
        _this._pDataLength = dataLength;
        _this._pOneData = new Array(_this._pDataLength);
        return _this;
    }
    Object.defineProperty(ParticleNodeBase.prototype, "mode", {
        /**
         * Returns the property mode of the particle animation node. Typically set in the node constructor
         *
         * @see away.animators.ParticlePropertiesMode
         */
        get: function () {
            return this._pMode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleNodeBase.prototype, "priority", {
        /**
         * Returns the priority of the particle animation node, used to order the agal generated in a particle animation set. Set automatically on instantiation.
         *
         * @see away.animators.ParticleAnimationSet
         * @see #getAGALVertexCode
         */
        get: function () {
            return this._priority;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleNodeBase.prototype, "dataLength", {
        /**
         * Returns the length of the data used by the node when in <code>LOCAL_STATIC</code> mode. Used to generate the local static data of the particle animation set.
         *
         * @see away.animators.ParticleAnimationSet
         * @see #getAGALVertexCode
         */
        get: function () {
            return this._pDataLength;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleNodeBase.prototype, "oneData", {
        /**
         * Returns the generated data vector of the node after one particle pass during the generation of all local static data of the particle animation set.
         *
         * @see away.animators.ParticleAnimationSet
         * @see #generatePropertyOfOneParticle
         */
        get: function () {
            return this._pOneData;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the AGAL code of the particle animation node for use in the vertex shader.
     */
    ParticleNodeBase.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        return "";
    };
    /**
     * Returns the AGAL code of the particle animation node for use in the fragment shader.
     */
    ParticleNodeBase.prototype.getAGALFragmentCode = function (shader, animationSet, registerCache, animationRegisterData) {
        return "";
    };
    /**
     * Returns the AGAL code of the particle animation node for use in the fragment shader when UV coordinates are required.
     */
    ParticleNodeBase.prototype.getAGALUVCode = function (shader, animationSet, registerCache, animationRegisterData) {
        return "";
    };
    /**
     * Called internally by the particle animation set when assigning the set of static properties originally defined by the initParticleFunc of the set.
     *
     * @see away.animators.ParticleAnimationSet#initParticleFunc
     */
    ParticleNodeBase.prototype._iGeneratePropertyOfOneParticle = function (param) {
    };
    /**
     * Called internally by the particle animation set when determining the requirements of the particle animation node AGAL.
     */
    ParticleNodeBase.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
    };
    return ParticleNodeBase;
}(_awayjs_graphics.AnimationNodeBase));
//modes alias
ParticleNodeBase.GLOBAL = 'Global';
ParticleNodeBase.LOCAL_STATIC = 'LocalStatic';
ParticleNodeBase.LOCAL_DYNAMIC = 'LocalDynamic';
//modes list
ParticleNodeBase.MODES = {
    0: ParticleNodeBase.GLOBAL,
    1: ParticleNodeBase.LOCAL_STATIC,
    2: ParticleNodeBase.LOCAL_DYNAMIC
};

/**
 * A particle animation node used to apply a constant acceleration vector to the motion of a particle.
 */
var ParticleAccelerationNode = (function (_super) {
    __extends(ParticleAccelerationNode, _super);
    /**
     * Creates a new <code>ParticleAccelerationNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] acceleration    Defines the default acceleration vector of the node, used when in global mode.
     */
    function ParticleAccelerationNode(mode, acceleration) {
        if (acceleration === void 0) { acceleration = null; }
        var _this = _super.call(this, "ParticleAcceleration", mode, 3) || this;
        _this._pStateClass = ParticleAccelerationState;
        _this._acceleration = acceleration || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleAccelerationNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var accelerationValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleAccelerationState.ACCELERATION_INDEX, accelerationValue.index);
        var temp = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(temp, 1);
        var code = "mul " + temp + "," + animationRegisterData.vertexTime + "," + accelerationValue + "\n";
        if (animationSet.needVelocity) {
            var temp2 = registerCache.getFreeVertexVectorTemp();
            code += "mul " + temp2 + "," + temp + "," + animationRegisterData.vertexTwoConst + "\n";
            code += "add " + animationRegisterData.velocityTarget + ".xyz," + temp2 + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
        }
        registerCache.removeVertexTempUsage(temp);
        code += "mul " + temp + "," + temp + "," + animationRegisterData.vertexTime + "\n";
        code += "add " + animationRegisterData.positionTarget + ".xyz," + temp + "," + animationRegisterData.positionTarget + ".xyz\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleAccelerationNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleAccelerationNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var tempAcceleration = param[ParticleAccelerationNode.ACCELERATION_VECTOR3D];
        if (!tempAcceleration)
            throw new Error("there is no " + ParticleAccelerationNode.ACCELERATION_VECTOR3D + " in param!");
        this._pOneData[0] = tempAcceleration.x / 2;
        this._pOneData[1] = tempAcceleration.y / 2;
        this._pOneData[2] = tempAcceleration.z / 2;
    };
    return ParticleAccelerationNode;
}(ParticleNodeBase));
/**
 * Reference for acceleration node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the direction of acceleration on the particle.
 */
ParticleAccelerationNode.ACCELERATION_VECTOR3D = "AccelerationVector3D";

/**
 * ...
 */
var ParticleBezierCurveState = (function (_super) {
    __extends(ParticleBezierCurveState, _super);
    function ParticleBezierCurveState(animator, particleBezierCurveNode) {
        var _this = _super.call(this, animator, particleBezierCurveNode) || this;
        _this._particleBezierCurveNode = particleBezierCurveNode;
        _this._controlPoint = _this._particleBezierCurveNode._iControlPoint;
        _this._endPoint = _this._particleBezierCurveNode._iEndPoint;
        return _this;
    }
    Object.defineProperty(ParticleBezierCurveState.prototype, "controlPoint", {
        /**
         * Defines the default control point of the node, used when in global mode.
         */
        get: function () {
            return this._controlPoint;
        },
        set: function (value) {
            this._controlPoint = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleBezierCurveState.prototype, "endPoint", {
        /**
         * Defines the default end point of the node, used when in global mode.
         */
        get: function () {
            return this._endPoint;
        },
        set: function (value) {
            this._endPoint = value;
        },
        enumerable: true,
        configurable: true
    });
    ParticleBezierCurveState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        var controlIndex = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleBezierCurveState.BEZIER_CONTROL_INDEX);
        var endIndex = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleBezierCurveState.BEZIER_END_INDEX);
        if (this._particleBezierCurveNode.mode == ParticlePropertiesMode.LOCAL_STATIC) {
            animationElements.activateVertexBuffer(controlIndex, this._particleBezierCurveNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
            animationElements.activateVertexBuffer(endIndex, this._particleBezierCurveNode._iDataOffset + 3, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
        }
        else {
            shader.setVertexConst(controlIndex, this._controlPoint.x, this._controlPoint.y, this._controlPoint.z);
            shader.setVertexConst(endIndex, this._endPoint.x, this._endPoint.y, this._endPoint.z);
        }
    };
    return ParticleBezierCurveState;
}(ParticleStateBase));
/** @private */
ParticleBezierCurveState.BEZIER_CONTROL_INDEX = 0;
/** @private */
ParticleBezierCurveState.BEZIER_END_INDEX = 1;

/**
 * A particle animation node used to control the position of a particle over time along a bezier curve.
 */
var ParticleBezierCurveNode = (function (_super) {
    __extends(ParticleBezierCurveNode, _super);
    /**
     * Creates a new <code>ParticleBezierCurveNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] controlPoint    Defines the default control point of the node, used when in global mode.
     * @param    [optional] endPoint        Defines the default end point of the node, used when in global mode.
     */
    function ParticleBezierCurveNode(mode, controlPoint, endPoint) {
        if (controlPoint === void 0) { controlPoint = null; }
        if (endPoint === void 0) { endPoint = null; }
        var _this = _super.call(this, "ParticleBezierCurve", mode, 6) || this;
        _this._pStateClass = ParticleBezierCurveState;
        _this._iControlPoint = controlPoint || new _awayjs_core.Vector3D();
        _this._iEndPoint = endPoint || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleBezierCurveNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var controlValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleBezierCurveState.BEZIER_CONTROL_INDEX, controlValue.index);
        var endValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleBezierCurveState.BEZIER_END_INDEX, endValue.index);
        var temp = registerCache.getFreeVertexVectorTemp();
        var rev_time = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 0);
        var time_2 = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 1);
        var time_temp = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 2);
        registerCache.addVertexTempUsages(temp, 1);
        var temp2 = registerCache.getFreeVertexVectorTemp();
        var distance = new _awayjs_stage.ShaderRegisterElement(temp2.regName, temp2.index);
        registerCache.removeVertexTempUsage(temp);
        var code = "";
        code += "sub " + rev_time + "," + animationRegisterData.vertexOneConst + "," + animationRegisterData.vertexLife + "\n";
        code += "mul " + time_2 + "," + animationRegisterData.vertexLife + "," + animationRegisterData.vertexLife + "\n";
        code += "mul " + time_temp + "," + animationRegisterData.vertexLife + "," + rev_time + "\n";
        code += "mul " + time_temp + "," + time_temp + "," + animationRegisterData.vertexTwoConst + "\n";
        code += "mul " + distance + ".xyz," + time_temp + "," + controlValue + "\n";
        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
        code += "mul " + distance + ".xyz," + time_2 + "," + endValue + "\n";
        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
        if (animationSet.needVelocity) {
            code += "mul " + time_2 + "," + animationRegisterData.vertexLife + "," + animationRegisterData.vertexTwoConst + "\n";
            code += "sub " + time_temp + "," + animationRegisterData.vertexOneConst + "," + time_2 + "\n";
            code += "mul " + time_temp + "," + animationRegisterData.vertexTwoConst + "," + time_temp + "\n";
            code += "mul " + distance + ".xyz," + controlValue + "," + time_temp + "\n";
            code += "add " + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
            code += "mul " + distance + ".xyz," + endValue + "," + time_2 + "\n";
            code += "add " + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleBezierCurveNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleBezierCurveNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var bezierControl = param[ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D];
        if (!bezierControl)
            throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D + " in param!");
        var bezierEnd = param[ParticleBezierCurveNode.BEZIER_END_VECTOR3D];
        if (!bezierEnd)
            throw new Error("there is no " + ParticleBezierCurveNode.BEZIER_END_VECTOR3D + " in param!");
        this._pOneData[0] = bezierControl.x;
        this._pOneData[1] = bezierControl.y;
        this._pOneData[2] = bezierControl.z;
        this._pOneData[3] = bezierEnd.x;
        this._pOneData[4] = bezierEnd.y;
        this._pOneData[5] = bezierEnd.z;
    };
    return ParticleBezierCurveNode;
}(ParticleNodeBase));
/**
 * Reference for bezier curve node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the control point position (0, 1, 2) of the curve.
 */
ParticleBezierCurveNode.BEZIER_CONTROL_VECTOR3D = "BezierControlVector3D";
/**
 * Reference for bezier curve node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the end point position (0, 1, 2) of the curve.
 */
ParticleBezierCurveNode.BEZIER_END_VECTOR3D = "BezierEndVector3D";

/**
 * ...
 */
var ParticleBillboardState = (function (_super) {
    __extends(ParticleBillboardState, _super);
    /**
     *
     */
    function ParticleBillboardState(animator, particleNode) {
        var _this = _super.call(this, animator, particleNode) || this;
        _this._matrix = new _awayjs_core.Matrix3D;
        _this._billboardAxis = particleNode._iBillboardAxis;
        return _this;
    }
    ParticleBillboardState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        var comps;
        if (this._billboardAxis) {
            var pos = renderable.sourceEntity.transform.concatenatedMatrix3D.position;
            var look = projection.transform.concatenatedMatrix3D.position.subtract(pos);
            var right = look.crossProduct(this._billboardAxis);
            right.normalize();
            look = this.billboardAxis.crossProduct(right);
            look.normalize();
            //create a quick inverse projection matrix
            this._matrix.copyFrom(renderable.sourceEntity.transform.concatenatedMatrix3D);
            comps = this._matrix.decompose(_awayjs_core.Orientation3D.AXIS_ANGLE);
            this._matrix.copyColumnFrom(0, right);
            this._matrix.copyColumnFrom(1, this.billboardAxis);
            this._matrix.copyColumnFrom(2, look);
            this._matrix.copyColumnFrom(3, pos);
            this._matrix.appendRotation(-comps[1].w * _awayjs_core.MathConsts.RADIANS_TO_DEGREES, comps[1]);
        }
        else {
            //create a quick inverse projection matrix
            this._matrix.copyFrom(renderable.sourceEntity.transform.concatenatedMatrix3D);
            this._matrix.append(projection.transform.inverseConcatenatedMatrix3D);
            //decompose using axis angle rotations
            comps = this._matrix.decompose(_awayjs_core.Orientation3D.AXIS_ANGLE);
            //recreate the matrix with just the rotation data
            this._matrix.identity();
            this._matrix.appendRotation(-comps[1].w * _awayjs_core.MathConsts.RADIANS_TO_DEGREES, comps[1]);
        }
        //set a new matrix transform constant
        shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleBillboardState.MATRIX_INDEX), this._matrix);
    };
    Object.defineProperty(ParticleBillboardState.prototype, "billboardAxis", {
        /**
         * Defines the billboard axis.
         */
        get: function () {
            return this.billboardAxis;
        },
        set: function (value) {
            this.billboardAxis = value ? value.clone() : null;
            if (this.billboardAxis)
                this.billboardAxis.normalize();
        },
        enumerable: true,
        configurable: true
    });
    return ParticleBillboardState;
}(ParticleStateBase));
/** @private */
ParticleBillboardState.MATRIX_INDEX = 0;

/**
 * A particle animation node that controls the rotation of a particle to always face the camera.
 */
var ParticleBillboardNode = (function (_super) {
    __extends(ParticleBillboardNode, _super);
    /**
     * Creates a new <code>ParticleBillboardNode</code>
     */
    function ParticleBillboardNode(billboardAxis) {
        if (billboardAxis === void 0) { billboardAxis = null; }
        var _this = _super.call(this, "ParticleBillboard", ParticlePropertiesMode.GLOBAL, 0, 4) || this;
        _this._pStateClass = ParticleBillboardState;
        _this._iBillboardAxis = billboardAxis;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleBillboardNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var rotationMatrixRegister = registerCache.getFreeVertexConstant();
        animationRegisterData.setRegisterIndex(this, ParticleBillboardState.MATRIX_INDEX, rotationMatrixRegister.index);
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        var temp = registerCache.getFreeVertexVectorTemp();
        var code = "m33 " + temp + ".xyz," + animationRegisterData.scaleAndRotateTarget + "," + rotationMatrixRegister + "\n" +
            "mov " + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp + "\n";
        var shaderRegisterElement;
        for (var i = 0; i < animationRegisterData.rotationRegisters.length; i++) {
            shaderRegisterElement = animationRegisterData.rotationRegisters[i];
            code += "m33 " + temp + ".xyz," + shaderRegisterElement + "," + rotationMatrixRegister + "\n" +
                "mov " + shaderRegisterElement + ".xyz," + shaderRegisterElement + "\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleBillboardNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleBillboardNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
        particleAnimationSet.hasBillboard = true;
    };
    return ParticleBillboardNode;
}(ParticleNodeBase));

/**
 * ...
 * @author ...
 */
var ParticleColorState = (function (_super) {
    __extends(ParticleColorState, _super);
    function ParticleColorState(animator, particleColorNode) {
        var _this = _super.call(this, animator, particleColorNode) || this;
        _this._particleColorNode = particleColorNode;
        _this._usesMultiplier = _this._particleColorNode._iUsesMultiplier;
        _this._usesOffset = _this._particleColorNode._iUsesOffset;
        _this._usesCycle = _this._particleColorNode._iUsesCycle;
        _this._usesPhase = _this._particleColorNode._iUsesPhase;
        _this._startColor = _this._particleColorNode._iStartColor;
        _this._endColor = _this._particleColorNode._iEndColor;
        _this._cycleDuration = _this._particleColorNode._iCycleDuration;
        _this._cyclePhase = _this._particleColorNode._iCyclePhase;
        _this.updateColorData();
        return _this;
    }
    Object.defineProperty(ParticleColorState.prototype, "startColor", {
        /**
         * Defines the start color transform of the state, when in global mode.
         */
        get: function () {
            return this._startColor;
        },
        set: function (value) {
            this._startColor = value;
            this.updateColorData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleColorState.prototype, "endColor", {
        /**
         * Defines the end color transform of the state, when in global mode.
         */
        get: function () {
            return this._endColor;
        },
        set: function (value) {
            this._endColor = value;
            this.updateColorData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleColorState.prototype, "cycleDuration", {
        /**
         * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
         */
        get: function () {
            return this._cycleDuration;
        },
        set: function (value) {
            this._cycleDuration = value;
            this.updateColorData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleColorState.prototype, "cyclePhase", {
        /**
         * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
         */
        get: function () {
            return this._cyclePhase;
        },
        set: function (value) {
            this._cyclePhase = value;
            this.updateColorData();
        },
        enumerable: true,
        configurable: true
    });
    ParticleColorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (shader.usesFragmentAnimation) {
            var dataOffset = this._particleColorNode._iDataOffset;
            var index;
            if (this._usesCycle)
                shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.CYCLE_INDEX), this._cycleData.x, this._cycleData.y, this._cycleData.z, this._cycleData.w);
            if (this._usesMultiplier) {
                if (this._particleColorNode.mode == ParticlePropertiesMode.LOCAL_STATIC) {
                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_MULTIPLIER_INDEX), dataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
                    dataOffset += 4;
                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_MULTIPLIER_INDEX), dataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
                    dataOffset += 4;
                }
                else {
                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_MULTIPLIER_INDEX), this._startMultiplierData.x, this._startMultiplierData.y, this._startMultiplierData.z, this._startMultiplierData.w);
                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_MULTIPLIER_INDEX), this._deltaMultiplierData.x, this._deltaMultiplierData.y, this._deltaMultiplierData.z, this._deltaMultiplierData.w);
                }
            }
            if (this._usesOffset) {
                if (this._particleColorNode.mode == ParticlePropertiesMode.LOCAL_STATIC) {
                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_OFFSET_INDEX), dataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
                    dataOffset += 4;
                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_OFFSET_INDEX), dataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
                }
                else {
                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.START_OFFSET_INDEX), this._startOffsetData.x, this._startOffsetData.y, this._startOffsetData.z, this._startOffsetData.w);
                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleColorState.DELTA_OFFSET_INDEX), this._deltaOffsetData.x, this._deltaOffsetData.y, this._deltaOffsetData.z, this._deltaOffsetData.w);
                }
            }
        }
    };
    ParticleColorState.prototype.updateColorData = function () {
        if (this._usesCycle) {
            if (this._cycleDuration <= 0)
                throw (new Error("the cycle duration must be greater than zero"));
            this._cycleData = new _awayjs_core.Vector3D(Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180, 0, 0);
        }
        if (this._particleColorNode.mode == ParticlePropertiesMode.GLOBAL) {
            if (this._usesCycle) {
                if (this._usesMultiplier) {
                    this._startMultiplierData = new _awayjs_core.Vector3D((this._startColor.redMultiplier + this._endColor.redMultiplier) / 2, (this._startColor.greenMultiplier + this._endColor.greenMultiplier) / 2, (this._startColor.blueMultiplier + this._endColor.blueMultiplier) / 2, (this._startColor.alphaMultiplier + this._endColor.alphaMultiplier) / 2);
                    this._deltaMultiplierData = new _awayjs_core.Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier) / 2, (this._endColor.greenMultiplier - this._startColor.greenMultiplier) / 2, (this._endColor.blueMultiplier - this._startColor.blueMultiplier) / 2, (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier) / 2);
                }
                if (this._usesOffset) {
                    this._startOffsetData = new _awayjs_core.Vector3D((this._startColor.redOffset + this._endColor.redOffset) / (255 * 2), (this._startColor.greenOffset + this._endColor.greenOffset) / (255 * 2), (this._startColor.blueOffset + this._endColor.blueOffset) / (255 * 2), (this._startColor.alphaOffset + this._endColor.alphaOffset) / (255 * 2));
                    this._deltaOffsetData = new _awayjs_core.Vector3D((this._endColor.redOffset - this._startColor.redOffset) / (255 * 2), (this._endColor.greenOffset - this._startColor.greenOffset) / (255 * 2), (this._endColor.blueOffset - this._startColor.blueOffset) / (255 * 2), (this._endColor.alphaOffset - this._startColor.alphaOffset) / (255 * 2));
                }
            }
            else {
                if (this._usesMultiplier) {
                    this._startMultiplierData = new _awayjs_core.Vector3D(this._startColor.redMultiplier, this._startColor.greenMultiplier, this._startColor.blueMultiplier, this._startColor.alphaMultiplier);
                    this._deltaMultiplierData = new _awayjs_core.Vector3D((this._endColor.redMultiplier - this._startColor.redMultiplier), (this._endColor.greenMultiplier - this._startColor.greenMultiplier), (this._endColor.blueMultiplier - this._startColor.blueMultiplier), (this._endColor.alphaMultiplier - this._startColor.alphaMultiplier));
                }
                if (this._usesOffset) {
                    this._startOffsetData = new _awayjs_core.Vector3D(this._startColor.redOffset / 255, this._startColor.greenOffset / 255, this._startColor.blueOffset / 255, this._startColor.alphaOffset / 255);
                    this._deltaOffsetData = new _awayjs_core.Vector3D((this._endColor.redOffset - this._startColor.redOffset) / 255, (this._endColor.greenOffset - this._startColor.greenOffset) / 255, (this._endColor.blueOffset - this._startColor.blueOffset) / 255, (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255);
                }
            }
        }
    };
    return ParticleColorState;
}(ParticleStateBase));
/** @private */
ParticleColorState.START_MULTIPLIER_INDEX = 0;
/** @private */
ParticleColorState.DELTA_MULTIPLIER_INDEX = 1;
/** @private */
ParticleColorState.START_OFFSET_INDEX = 2;
/** @private */
ParticleColorState.DELTA_OFFSET_INDEX = 3;
/** @private */
ParticleColorState.CYCLE_INDEX = 4;

/**
 * ...
 */
var ParticleTimeState = (function (_super) {
    __extends(ParticleTimeState, _super);
    function ParticleTimeState(animator, particleTimeNode) {
        var _this = _super.call(this, animator, particleTimeNode, true) || this;
        _this._particleTimeNode = particleTimeNode;
        return _this;
    }
    ParticleTimeState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleTimeState.TIME_STREAM_INDEX), this._particleTimeNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
        var particleTime = this._pTime / 1000;
        shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleTimeState.TIME_CONSTANT_INDEX), particleTime, particleTime, particleTime, particleTime);
    };
    return ParticleTimeState;
}(ParticleStateBase));
/** @private */
ParticleTimeState.TIME_STREAM_INDEX = 0;
/** @private */
ParticleTimeState.TIME_CONSTANT_INDEX = 1;

/**
 * A particle animation node used as the base node for timekeeping inside a particle. Automatically added to a particle animation set on instatiation.
 */
var ParticleTimeNode = (function (_super) {
    __extends(ParticleTimeNode, _super);
    /**
     * Creates a new <code>ParticleTimeNode</code>
     *
     * @param    [optional] usesDuration    Defines whether the node uses the <code>duration</code> data in the static properties to determine how long a particle is visible for. Defaults to false.
     * @param    [optional] usesDelay       Defines whether the node uses the <code>delay</code> data in the static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesDuration</code> to be true.
     * @param    [optional] usesLooping     Defines whether the node creates a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in the static properties function. Defaults to false. Requires <code>usesLooping</code> to be true.
     */
    function ParticleTimeNode(usesDuration, usesLooping, usesDelay) {
        if (usesDuration === void 0) { usesDuration = false; }
        if (usesLooping === void 0) { usesLooping = false; }
        if (usesDelay === void 0) { usesDelay = false; }
        var _this = _super.call(this, "ParticleTime", ParticlePropertiesMode.LOCAL_STATIC, 4, 0) || this;
        _this._pStateClass = ParticleTimeState;
        _this._iUsesDuration = usesDuration;
        _this._iUsesLooping = usesLooping;
        _this._iUsesDelay = usesDelay;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleTimeNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var timeStreamRegister = registerCache.getFreeVertexAttribute(); //timeStreamRegister.x is start，timeStreamRegister.y is during time
        animationRegisterData.setRegisterIndex(this, ParticleTimeState.TIME_STREAM_INDEX, timeStreamRegister.index);
        var timeConst = registerCache.getFreeVertexConstant();
        animationRegisterData.setRegisterIndex(this, ParticleTimeState.TIME_CONSTANT_INDEX, timeConst.index);
        var code = "";
        code += "sub " + animationRegisterData.vertexTime + "," + timeConst + "," + timeStreamRegister + ".x\n";
        //if time=0,set the position to zero.
        var temp = registerCache.getFreeVertexSingleTemp();
        code += "sge " + temp + "," + animationRegisterData.vertexTime + "," + animationRegisterData.vertexZeroConst + "\n";
        code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp + "\n";
        if (this._iUsesDuration) {
            if (this._iUsesLooping) {
                var div = registerCache.getFreeVertexSingleTemp();
                if (this._iUsesDelay) {
                    code += "div " + div + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".z\n";
                    code += "frc " + div + "," + div + "\n";
                    code += "mul " + animationRegisterData.vertexTime + "," + div + "," + timeStreamRegister + ".z\n";
                    code += "slt " + div + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".y\n";
                    code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + div + "\n";
                }
                else {
                    code += "mul " + div + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".w\n";
                    code += "frc " + div + "," + div + "\n";
                    code += "mul " + animationRegisterData.vertexTime + "," + div + "," + timeStreamRegister + ".y\n";
                }
            }
            else {
                var sge = registerCache.getFreeVertexSingleTemp();
                code += "sge " + sge + "," + timeStreamRegister + ".y," + animationRegisterData.vertexTime + "\n";
                code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + sge + "\n";
            }
        }
        code += "mul " + animationRegisterData.vertexLife + "," + animationRegisterData.vertexTime + "," + timeStreamRegister + ".w\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleTimeNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleTimeNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        this._pOneData[0] = param.startTime;
        this._pOneData[1] = param.duration;
        this._pOneData[2] = param.delay + param.duration;
        this._pOneData[3] = 1 / param.duration;
    };
    return ParticleTimeNode;
}(ParticleNodeBase));

/**
 * The animation data set used by particle-based animators, containing particle animation data.
 *
 * @see away.animators.ParticleAnimator
 */
var ParticleAnimationSet = (function (_super) {
    __extends(ParticleAnimationSet, _super);
    /**
     * Creates a new <code>ParticleAnimationSet</code>
     *
     * @param    [optional] usesDuration    Defines whether the animation set uses the <code>duration</code> data in its static properties to determine how long a particle is visible for. Defaults to false.
     * @param    [optional] usesLooping     Defines whether the animation set uses a looping timeframe for each particle determined by the <code>startTime</code>, <code>duration</code> and <code>delay</code> data in its static properties function. Defaults to false. Requires <code>usesDuration</code> to be true.
     * @param    [optional] usesDelay       Defines whether the animation set uses the <code>delay</code> data in its static properties to determine how long a particle is hidden for. Defaults to false. Requires <code>usesLooping</code> to be true.
     */
    function ParticleAnimationSet(usesDuration, usesLooping, usesDelay) {
        if (usesDuration === void 0) { usesDuration = false; }
        if (usesLooping === void 0) { usesLooping = false; }
        if (usesDelay === void 0) { usesDelay = false; }
        var _this = _super.call(this) || this;
        _this._animationElements = new Object();
        _this._particleNodes = new Array();
        _this._localDynamicNodes = new Array();
        _this._localStaticNodes = new Array();
        _this._totalLenOfOneVertex = 0;
        /**
         *
         */
        _this.shareAnimationGraphics = true;
        //automatically add a particle time node to the set
        _this.addAnimation(_this._timeNode = new ParticleTimeNode(usesDuration, usesLooping, usesDelay));
        return _this;
    }
    Object.defineProperty(ParticleAnimationSet.prototype, "particleNodes", {
        /**
         * Returns a vector of the particle animation nodes contained within the set.
         */
        get: function () {
            return this._particleNodes;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleAnimationSet.prototype.addAnimation = function (node) {
        var i;
        var n = node;
        n._iProcessAnimationSetting(this);
        if (n.mode == ParticlePropertiesMode.LOCAL_STATIC) {
            n._iDataOffset = this._totalLenOfOneVertex;
            this._totalLenOfOneVertex += n.dataLength;
            this._localStaticNodes.push(n);
        }
        else if (n.mode == ParticlePropertiesMode.LOCAL_DYNAMIC)
            this._localDynamicNodes.push(n);
        for (i = this._particleNodes.length - 1; i >= 0; i--) {
            if (this._particleNodes[i].priority <= n.priority)
                break;
        }
        this._particleNodes.splice(i + 1, 0, n);
        _super.prototype.addAnimation.call(this, node);
    };
    /**
     * @inheritDoc
     */
    ParticleAnimationSet.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
        //grab animationRegisterData from the materialpassbase or create a new one if the first time
        this._iAnimationRegisterData = shader.animationRegisterData;
        if (this._iAnimationRegisterData == null)
            this._iAnimationRegisterData = shader.animationRegisterData = new _awayjs_stage.AnimationRegisterData();
        //reset animationRegisterData
        this._iAnimationRegisterData.reset(registerCache, sharedRegisters, this.needVelocity);
        var code = "";
        var len = sharedRegisters.animatableAttributes.length;
        for (var i = 0; i < len; i++)
            code += "mov " + sharedRegisters.animationTargetRegisters[i] + "," + sharedRegisters.animatableAttributes[i] + "\n";
        code += "mov " + this._iAnimationRegisterData.positionTarget + ".xyz," + this._iAnimationRegisterData.vertexZeroConst + "\n";
        if (this.needVelocity)
            code += "mov " + this._iAnimationRegisterData.velocityTarget + ".xyz," + this._iAnimationRegisterData.vertexZeroConst + "\n";
        var node;
        var i;
        for (i = 0; i < this._particleNodes.length; i++) {
            node = this._particleNodes[i];
            if (node.priority < ParticleAnimationSet.POST_PRIORITY)
                code += node.getAGALVertexCode(shader, this, registerCache, this._iAnimationRegisterData);
        }
        code += "add " + this._iAnimationRegisterData.scaleAndRotateTarget + ".xyz," + this._iAnimationRegisterData.scaleAndRotateTarget + ".xyz," + this._iAnimationRegisterData.positionTarget + ".xyz\n";
        for (i = 0; i < this._particleNodes.length; i++) {
            node = this._particleNodes[i];
            if (node.priority >= ParticleAnimationSet.POST_PRIORITY && node.priority < ParticleAnimationSet.COLOR_PRIORITY)
                code += node.getAGALVertexCode(shader, this, registerCache, this._iAnimationRegisterData);
        }
        if (this.hasColorMulNode) {
            this._iAnimationRegisterData.colorMulTarget = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(this._iAnimationRegisterData.colorMulTarget, 1);
            this._iAnimationRegisterData.colorMulVary = registerCache.getFreeVarying();
            code += "mov " + this._iAnimationRegisterData.colorMulTarget + "," + this._iAnimationRegisterData.vertexOneConst + "\n";
        }
        if (this.hasColorAddNode) {
            this._iAnimationRegisterData.colorAddTarget = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(this._iAnimationRegisterData.colorAddTarget, 1);
            this._iAnimationRegisterData.colorAddVary = registerCache.getFreeVarying();
            code += "mov " + this._iAnimationRegisterData.colorAddTarget + "," + this._iAnimationRegisterData.vertexZeroConst + "\n";
        }
        for (i = 0; i < this._particleNodes.length; i++) {
            node = this._particleNodes[i];
            if (node.priority >= ParticleAnimationSet.COLOR_PRIORITY)
                code += node.getAGALVertexCode(shader, this, registerCache, this._iAnimationRegisterData);
        }
        if (shader.usesFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
            if (this.hasColorMulNode)
                code += "mov " + this._iAnimationRegisterData.colorMulVary + "," + this._iAnimationRegisterData.colorMulTarget + "\n";
            if (this.hasColorAddNode)
                code += "mov " + this._iAnimationRegisterData.colorAddVary + "," + this._iAnimationRegisterData.colorAddTarget + "\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleAnimationSet.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
        var code = "";
        if (this.hasUVNode) {
            this._iAnimationRegisterData.setUVSourceAndTarget(sharedRegisters);
            code += "mov " + this._iAnimationRegisterData.uvTarget + ".xy," + this._iAnimationRegisterData.uvAttribute.toString() + "\n";
            var node;
            for (var i = 0; i < this._particleNodes.length; i++)
                node = this._particleNodes[i];
            code += node.getAGALUVCode(shader, this, registerCache, this._iAnimationRegisterData);
            code += "mov " + this._iAnimationRegisterData.uvVar + "," + this._iAnimationRegisterData.uvTarget + ".xy\n";
        }
        else
            code += "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleAnimationSet.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
        var code = "";
        if (shader.usesFragmentAnimation && (this.hasColorAddNode || this.hasColorMulNode)) {
            if (this.hasColorMulNode)
                code += "mul " + shadedTarget + "," + shadedTarget + "," + this._iAnimationRegisterData.colorMulVary + "\n";
            if (this.hasColorAddNode)
                code += "add " + shadedTarget + "," + shadedTarget + "," + this._iAnimationRegisterData.colorAddVary + "\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleAnimationSet.prototype.doneAGALCode = function (shader) {
        //set vertexZeroConst,vertexOneConst,vertexTwoConst
        shader.setVertexConst(this._iAnimationRegisterData.vertexZeroConst.index, 0, 1, 2, 0);
    };
    Object.defineProperty(ParticleAnimationSet.prototype, "usesCPU", {
        /**
         * @inheritDoc
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleAnimationSet.prototype.cancelGPUCompatibility = function () {
    };
    ParticleAnimationSet.prototype.dispose = function () {
        for (var key in this._animationElements)
            this._animationElements[key].dispose();
        _super.prototype.dispose.call(this);
    };
    ParticleAnimationSet.prototype.getAnimationElements = function (graphics, shape) {
        var animationElements = (this.shareAnimationGraphics) ? this._animationElements[shape.elements.id] : this._animationElements[shape.id];
        if (animationElements)
            return animationElements;
        this._iGenerateAnimationElements(graphics);
        return (this.shareAnimationGraphics) ? this._animationElements[shape.elements.id] : this._animationElements[shape.id];
    };
    /** @private */
    ParticleAnimationSet.prototype._iGenerateAnimationElements = function (graphics) {
        if (this.initParticleFunc == null)
            throw (new Error("no initParticleFunc set"));
        var i, j, k;
        var animationElements;
        var newAnimationElements = false;
        var elements;
        var shape;
        var localNode;
        for (i = 0; i < graphics.count; i++) {
            shape = graphics.getShapeAt(i);
            elements = shape.elements;
            if (this.shareAnimationGraphics) {
                animationElements = this._animationElements[elements.id];
                if (animationElements)
                    continue;
            }
            animationElements = new AnimationElements();
            if (this.shareAnimationGraphics)
                this._animationElements[elements.id] = animationElements;
            else
                this._animationElements[shape.id] = animationElements;
            newAnimationElements = true;
            //create the vertexData vector that will be used for local node data
            animationElements.createVertexData(elements.numVertices, this._totalLenOfOneVertex);
        }
        if (!newAnimationElements)
            return;
        var particles = graphics.particles;
        var particlesLength = particles.length;
        var numParticles = graphics.numParticles;
        var particleProperties = new ParticleProperties();
        var particle;
        var oneDataLen;
        var oneDataOffset;
        var counterForVertex;
        var counterForOneData;
        var oneData;
        var numVertices;
        var vertexData;
        var vertexLength;
        var startingOffset;
        var vertexOffset;
        //default values for particle param
        particleProperties.total = numParticles;
        particleProperties.startTime = 0;
        particleProperties.duration = 1000;
        particleProperties.delay = 0.1;
        i = 0;
        j = 0;
        while (i < numParticles) {
            particleProperties.index = i;
            //call the init on the particle parameters
            this.initParticleFunc.call(this.initParticleScope, particleProperties);
            //create the next set of node properties for the particle
            for (k = 0; k < this._localStaticNodes.length; k++)
                this._localStaticNodes[k]._iGeneratePropertyOfOneParticle(particleProperties);
            //loop through all particle data for the curent particle
            while (j < particlesLength && (particle = particles[j]).particleIndex == i) {
                //find the target animationElements
                for (k = 0; k < graphics.count; k++) {
                    shape = graphics.getShapeAt(k);
                    if (shape.elements == particle.elements) {
                        animationElements = (this.shareAnimationGraphics) ? this._animationElements[shape.elements.id] : this._animationElements[shape.id];
                        break;
                    }
                }
                numVertices = particle.numVertices;
                vertexData = animationElements.vertexData;
                vertexLength = numVertices * this._totalLenOfOneVertex;
                startingOffset = animationElements.numProcessedVertices * this._totalLenOfOneVertex;
                //loop through each static local node in the animation set
                for (k = 0; k < this._localStaticNodes.length; k++) {
                    localNode = this._localStaticNodes[k];
                    oneData = localNode.oneData;
                    oneDataLen = localNode.dataLength;
                    oneDataOffset = startingOffset + localNode._iDataOffset;
                    //loop through each vertex set in the vertex data
                    for (counterForVertex = 0; counterForVertex < vertexLength; counterForVertex += this._totalLenOfOneVertex) {
                        vertexOffset = oneDataOffset + counterForVertex;
                        //add the data for the local node to the vertex data
                        for (counterForOneData = 0; counterForOneData < oneDataLen; counterForOneData++)
                            vertexData[vertexOffset + counterForOneData] = oneData[counterForOneData];
                    }
                }
                //store particle properties if they need to be retreived for dynamic local nodes
                if (this._localDynamicNodes.length)
                    animationElements.animationParticles.push(new ParticleAnimationData(i, particleProperties.startTime, particleProperties.duration, particleProperties.delay, particle));
                animationElements.numProcessedVertices += numVertices;
                //next index
                j++;
            }
            //next particle
            i++;
        }
    };
    return ParticleAnimationSet;
}(_awayjs_stage.AnimationSetBase));
/**
 * Property used by particle nodes that require compilers at the end of the shader
 */
ParticleAnimationSet.POST_PRIORITY = 9;
/**
 * Property used by particle nodes that require color compilers
 */
ParticleAnimationSet.COLOR_PRIORITY = 18;

/**
 * A particle animation node used to control the color variation of a particle over time.
 */
var ParticleColorNode = (function (_super) {
    __extends(ParticleColorNode, _super);
    /**
     * Creates a new <code>ParticleColorNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] usesMultiplier  Defines whether the node uses multiplier data in the shader for its color transformations. Defaults to true.
     * @param    [optional] usesOffset      Defines whether the node uses offset data in the shader for its color transformations. Defaults to true.
     * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the animation independent of particle duration. Defaults to false.
     * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
     * @param    [optional] startColor      Defines the default start color transform of the node, when in global mode.
     * @param    [optional] endColor        Defines the default end color transform of the node, when in global mode.
     * @param    [optional] cycleDuration   Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
     * @param    [optional] cyclePhase      Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
     */
    function ParticleColorNode(mode, usesMultiplier, usesOffset, usesCycle, usesPhase, startColor, endColor, cycleDuration, cyclePhase) {
        if (usesMultiplier === void 0) { usesMultiplier = true; }
        if (usesOffset === void 0) { usesOffset = true; }
        if (usesCycle === void 0) { usesCycle = false; }
        if (usesPhase === void 0) { usesPhase = false; }
        if (startColor === void 0) { startColor = null; }
        if (endColor === void 0) { endColor = null; }
        if (cycleDuration === void 0) { cycleDuration = 1; }
        if (cyclePhase === void 0) { cyclePhase = 0; }
        var _this = _super.call(this, "ParticleColor", mode, (usesMultiplier && usesOffset) ? 16 : 8, ParticleAnimationSet.COLOR_PRIORITY) || this;
        _this._pStateClass = ParticleColorState;
        _this._iUsesMultiplier = usesMultiplier;
        _this._iUsesOffset = usesOffset;
        _this._iUsesCycle = usesCycle;
        _this._iUsesPhase = usesPhase;
        _this._iStartColor = startColor || new _awayjs_core.ColorTransform();
        _this._iEndColor = endColor || new _awayjs_core.ColorTransform();
        _this._iCycleDuration = cycleDuration;
        _this._iCyclePhase = cyclePhase;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleColorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var code = "";
        if (shader.usesFragmentAnimation) {
            var temp = registerCache.getFreeVertexVectorTemp();
            if (this._iUsesCycle) {
                var cycleConst = registerCache.getFreeVertexConstant();
                animationRegisterData.setRegisterIndex(this, ParticleColorState.CYCLE_INDEX, cycleConst.index);
                registerCache.addVertexTempUsages(temp, 1);
                var sin = registerCache.getFreeVertexSingleTemp();
                registerCache.removeVertexTempUsage(temp);
                code += "mul " + sin + "," + animationRegisterData.vertexTime + "," + cycleConst + ".x\n";
                if (this._iUsesPhase)
                    code += "add " + sin + "," + sin + "," + cycleConst + ".y\n";
                code += "sin " + sin + "," + sin + "\n";
            }
            if (this._iUsesMultiplier) {
                var startMultiplierValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
                var deltaMultiplierValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
                animationRegisterData.setRegisterIndex(this, ParticleColorState.START_MULTIPLIER_INDEX, startMultiplierValue.index);
                animationRegisterData.setRegisterIndex(this, ParticleColorState.DELTA_MULTIPLIER_INDEX, deltaMultiplierValue.index);
                code += "mul " + temp + "," + deltaMultiplierValue + "," + (this._iUsesCycle ? sin : animationRegisterData.vertexLife) + "\n";
                code += "add " + temp + "," + temp + "," + startMultiplierValue + "\n";
                code += "mul " + animationRegisterData.colorMulTarget + "," + temp + "," + animationRegisterData.colorMulTarget + "\n";
            }
            if (this._iUsesOffset) {
                var startOffsetValue = (this._pMode == ParticlePropertiesMode.LOCAL_STATIC) ? registerCache.getFreeVertexAttribute() : registerCache.getFreeVertexConstant();
                var deltaOffsetValue = (this._pMode == ParticlePropertiesMode.LOCAL_STATIC) ? registerCache.getFreeVertexAttribute() : registerCache.getFreeVertexConstant();
                animationRegisterData.setRegisterIndex(this, ParticleColorState.START_OFFSET_INDEX, startOffsetValue.index);
                animationRegisterData.setRegisterIndex(this, ParticleColorState.DELTA_OFFSET_INDEX, deltaOffsetValue.index);
                code += "mul " + temp + "," + deltaOffsetValue + "," + (this._iUsesCycle ? sin : animationRegisterData.vertexLife) + "\n";
                code += "add " + temp + "," + temp + "," + startOffsetValue + "\n";
                code += "add " + animationRegisterData.colorAddTarget + "," + temp + "," + animationRegisterData.colorAddTarget + "\n";
            }
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleColorNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
        if (this._iUsesMultiplier)
            particleAnimationSet.hasColorMulNode = true;
        if (this._iUsesOffset)
            particleAnimationSet.hasColorAddNode = true;
    };
    /**
     * @inheritDoc
     */
    ParticleColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var startColor = param[ParticleColorNode.COLOR_START_COLORTRANSFORM];
        if (!startColor)
            throw (new Error("there is no " + ParticleColorNode.COLOR_START_COLORTRANSFORM + " in param!"));
        var endColor = param[ParticleColorNode.COLOR_END_COLORTRANSFORM];
        if (!endColor)
            throw (new Error("there is no " + ParticleColorNode.COLOR_END_COLORTRANSFORM + " in param!"));
        var i = 0;
        if (!this._iUsesCycle) {
            //multiplier
            if (this._iUsesMultiplier) {
                this._pOneData[i++] = startColor.redMultiplier;
                this._pOneData[i++] = startColor.greenMultiplier;
                this._pOneData[i++] = startColor.blueMultiplier;
                this._pOneData[i++] = startColor.alphaMultiplier;
                this._pOneData[i++] = endColor.redMultiplier - startColor.redMultiplier;
                this._pOneData[i++] = endColor.greenMultiplier - startColor.greenMultiplier;
                this._pOneData[i++] = endColor.blueMultiplier - startColor.blueMultiplier;
                this._pOneData[i++] = endColor.alphaMultiplier - startColor.alphaMultiplier;
            }
            //offset
            if (this._iUsesOffset) {
                this._pOneData[i++] = startColor.redOffset / 255;
                this._pOneData[i++] = startColor.greenOffset / 255;
                this._pOneData[i++] = startColor.blueOffset / 255;
                this._pOneData[i++] = startColor.alphaOffset / 255;
                this._pOneData[i++] = (endColor.redOffset - startColor.redOffset) / 255;
                this._pOneData[i++] = (endColor.greenOffset - startColor.greenOffset) / 255;
                this._pOneData[i++] = (endColor.blueOffset - startColor.blueOffset) / 255;
                this._pOneData[i++] = (endColor.alphaOffset - startColor.alphaOffset) / 255;
            }
        }
        else {
            //multiplier
            if (this._iUsesMultiplier) {
                this._pOneData[i++] = (startColor.redMultiplier + endColor.redMultiplier) / 2;
                this._pOneData[i++] = (startColor.greenMultiplier + endColor.greenMultiplier) / 2;
                this._pOneData[i++] = (startColor.blueMultiplier + endColor.blueMultiplier) / 2;
                this._pOneData[i++] = (startColor.alphaMultiplier + endColor.alphaMultiplier) / 2;
                this._pOneData[i++] = (startColor.redMultiplier - endColor.redMultiplier) / 2;
                this._pOneData[i++] = (startColor.greenMultiplier - endColor.greenMultiplier) / 2;
                this._pOneData[i++] = (startColor.blueMultiplier - endColor.blueMultiplier) / 2;
                this._pOneData[i++] = (startColor.alphaMultiplier - endColor.alphaMultiplier) / 2;
            }
            //offset
            if (this._iUsesOffset) {
                this._pOneData[i++] = (startColor.redOffset + endColor.redOffset) / (255 * 2);
                this._pOneData[i++] = (startColor.greenOffset + endColor.greenOffset) / (255 * 2);
                this._pOneData[i++] = (startColor.blueOffset + endColor.blueOffset) / (255 * 2);
                this._pOneData[i++] = (startColor.alphaOffset + endColor.alphaOffset) / (255 * 2);
                this._pOneData[i++] = (startColor.redOffset - endColor.redOffset) / (255 * 2);
                this._pOneData[i++] = (startColor.greenOffset - endColor.greenOffset) / (255 * 2);
                this._pOneData[i++] = (startColor.blueOffset - endColor.blueOffset) / (255 * 2);
                this._pOneData[i++] = (startColor.alphaOffset - endColor.alphaOffset) / (255 * 2);
            }
        }
    };
    return ParticleColorNode;
}(ParticleNodeBase));
/**
 * Reference for color node properties on a single particle (when in local property mode).
 * Expects a <code>ColorTransform</code> object representing the start color transform applied to the particle.
 */
ParticleColorNode.COLOR_START_COLORTRANSFORM = "ColorStartColorTransform";
/**
 * Reference for color node properties on a single particle (when in local property mode).
 * Expects a <code>ColorTransform</code> object representing the end color transform applied to the particle.
 */
ParticleColorNode.COLOR_END_COLORTRANSFORM = "ColorEndColorTransform";

/**
 * ...
 */
var ParticleFollowState = (function (_super) {
    __extends(ParticleFollowState, _super);
    function ParticleFollowState(animator, particleFollowNode) {
        var _this = _super.call(this, animator, particleFollowNode, true) || this;
        _this._targetPos = new _awayjs_core.Vector3D();
        _this._targetEuler = new _awayjs_core.Vector3D();
        //temporary vector3D for calculation
        _this._temp = new _awayjs_core.Vector3D();
        _this._particleFollowNode = particleFollowNode;
        _this._smooth = particleFollowNode._iSmooth;
        return _this;
    }
    Object.defineProperty(ParticleFollowState.prototype, "followTarget", {
        get: function () {
            return this._followTarget;
        },
        set: function (value) {
            this._followTarget = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleFollowState.prototype, "smooth", {
        get: function () {
            return this._smooth;
        },
        set: function (value) {
            this._smooth = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleFollowState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (this._followTarget) {
            if (this._particleFollowNode._iUsesPosition) {
                this._targetPos.x = this._followTarget.transform.position.x / renderable.sourceEntity.transform.scale.x;
                this._targetPos.y = this._followTarget.transform.position.y / renderable.sourceEntity.transform.scale.y;
                this._targetPos.z = this._followTarget.transform.position.z / renderable.sourceEntity.transform.scale.z;
            }
            if (this._particleFollowNode._iUsesRotation) {
                this._targetEuler.x = this._followTarget.rotationX;
                this._targetEuler.y = this._followTarget.rotationY;
                this._targetEuler.z = this._followTarget.rotationZ;
                this._targetEuler.scaleBy(_awayjs_core.MathConsts.DEGREES_TO_RADIANS);
            }
        }
        //initialization
        if (!this._prePos)
            this._prePos = this._targetPos.clone();
        if (!this._preEuler)
            this._preEuler = this._targetEuler.clone();
        var currentTime = this._pTime / 1000;
        var previousTime = animationElements.previousTime;
        var deltaTime = currentTime - previousTime;
        var needProcess = previousTime != currentTime;
        if (this._particleFollowNode._iUsesPosition && this._particleFollowNode._iUsesRotation) {
            if (needProcess)
                this.processPositionAndRotation(currentTime, deltaTime, animationElements);
            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset + 3, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
        }
        else if (this._particleFollowNode._iUsesPosition) {
            if (needProcess)
                this.processPosition(currentTime, deltaTime, animationElements);
            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_POSITION_INDEX), this._particleFollowNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
        }
        else if (this._particleFollowNode._iUsesRotation) {
            if (needProcess)
                this.precessRotation(currentTime, deltaTime, animationElements);
            animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleFollowState.FOLLOW_ROTATION_INDEX), this._particleFollowNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
        }
        this._prePos.copyFrom(this._targetPos);
        this._targetEuler.copyFrom(this._targetEuler);
        animationElements.previousTime = currentTime;
    };
    ParticleFollowState.prototype.processPosition = function (currentTime, deltaTime, animationElements) {
        var data = animationElements.animationParticles;
        var vertexData = animationElements.vertexData;
        var changed = false;
        var len = data.length;
        var interpolatedPos;
        var posVelocity;
        if (this._smooth) {
            posVelocity = this._prePos.subtract(this._targetPos);
            posVelocity.scaleBy(1 / deltaTime);
        }
        else
            interpolatedPos = this._targetPos;
        for (var i = 0; i < len; i++) {
            var k = (currentTime - data[i].startTime) / data[i].totalTime;
            var t = (k - Math.floor(k)) * data[i].totalTime;
            if (t - deltaTime <= 0) {
                var inc = data[i].startVertexIndex * animationElements.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
                if (this._smooth) {
                    this._temp.copyFrom(posVelocity);
                    this._temp.scaleBy(t);
                    interpolatedPos = this._targetPos.add(this._temp);
                }
                if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z) {
                    changed = true;
                    for (var j = 0; j < data[i].numVertices; j++) {
                        vertexData[inc++] = interpolatedPos.x;
                        vertexData[inc++] = interpolatedPos.y;
                        vertexData[inc++] = interpolatedPos.z;
                    }
                }
            }
        }
        if (changed)
            animationElements.invalidateBuffer();
    };
    ParticleFollowState.prototype.precessRotation = function (currentTime, deltaTime, animationElements) {
        var data = animationElements.animationParticles;
        var vertexData = animationElements.vertexData;
        var changed = false;
        var len = data.length;
        var interpolatedRotation;
        var rotationVelocity;
        if (this._smooth) {
            rotationVelocity = this._preEuler.subtract(this._targetEuler);
            rotationVelocity.scaleBy(1 / deltaTime);
        }
        else
            interpolatedRotation = this._targetEuler;
        for (var i = 0; i < len; i++) {
            var k = (currentTime - data[i].startTime) / data[i].totalTime;
            var t = (k - Math.floor(k)) * data[i].totalTime;
            if (t - deltaTime <= 0) {
                var inc = data[i].startVertexIndex * animationElements.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
                if (this._smooth) {
                    this._temp.copyFrom(rotationVelocity);
                    this._temp.scaleBy(t);
                    interpolatedRotation = this._targetEuler.add(this._temp);
                }
                if (vertexData[inc] != interpolatedRotation.x || vertexData[inc + 1] != interpolatedRotation.y || vertexData[inc + 2] != interpolatedRotation.z) {
                    changed = true;
                    for (var j = 0; j < data[i].numVertices; j++) {
                        vertexData[inc++] = interpolatedRotation.x;
                        vertexData[inc++] = interpolatedRotation.y;
                        vertexData[inc++] = interpolatedRotation.z;
                    }
                }
            }
        }
        if (changed)
            animationElements.invalidateBuffer();
    };
    ParticleFollowState.prototype.processPositionAndRotation = function (currentTime, deltaTime, animationElements) {
        var data = animationElements.animationParticles;
        var vertexData = animationElements.vertexData;
        var changed = false;
        var len = data.length;
        var interpolatedPos;
        var interpolatedRotation;
        var posVelocity;
        var rotationVelocity;
        if (this._smooth) {
            posVelocity = this._prePos.subtract(this._targetPos);
            posVelocity.scaleBy(1 / deltaTime);
            rotationVelocity = this._preEuler.subtract(this._targetEuler);
            rotationVelocity.scaleBy(1 / deltaTime);
        }
        else {
            interpolatedPos = this._targetPos;
            interpolatedRotation = this._targetEuler;
        }
        for (var i = 0; i < len; i++) {
            var k = (currentTime - data[i].startTime) / data[i].totalTime;
            var t = (k - Math.floor(k)) * data[i].totalTime;
            if (t - deltaTime <= 0) {
                var inc = data[i].startVertexIndex * animationElements.totalLenOfOneVertex + this._particleFollowNode._iDataOffset;
                if (this._smooth) {
                    this._temp.copyFrom(posVelocity);
                    this._temp.scaleBy(t);
                    interpolatedPos = this._targetPos.add(this._temp);
                    this._temp.copyFrom(rotationVelocity);
                    this._temp.scaleBy(t);
                    interpolatedRotation = this._targetEuler.add(this._temp);
                }
                if (vertexData[inc] != interpolatedPos.x || vertexData[inc + 1] != interpolatedPos.y || vertexData[inc + 2] != interpolatedPos.z || vertexData[inc + 3] != interpolatedRotation.x || vertexData[inc + 4] != interpolatedRotation.y || vertexData[inc + 5] != interpolatedRotation.z) {
                    changed = true;
                    for (var j = 0; j < data[i].numVertices; j++) {
                        vertexData[inc++] = interpolatedPos.x;
                        vertexData[inc++] = interpolatedPos.y;
                        vertexData[inc++] = interpolatedPos.z;
                        vertexData[inc++] = interpolatedRotation.x;
                        vertexData[inc++] = interpolatedRotation.y;
                        vertexData[inc++] = interpolatedRotation.z;
                    }
                }
            }
        }
        if (changed)
            animationElements.invalidateBuffer();
    };
    return ParticleFollowState;
}(ParticleStateBase));
/** @private */
ParticleFollowState.FOLLOW_POSITION_INDEX = 0;
/** @private */
ParticleFollowState.FOLLOW_ROTATION_INDEX = 1;

/**
 * A particle animation node used to create a follow behaviour on a particle system.
 */
var ParticleFollowNode = (function (_super) {
    __extends(ParticleFollowNode, _super);
    /**
     * Creates a new <code>ParticleFollowNode</code>
     *
     * @param    [optional] usesPosition     Defines wehether the individual particle reacts to the position of the target.
     * @param    [optional] usesRotation     Defines wehether the individual particle reacts to the rotation of the target.
     * @param    [optional] smooth     Defines wehether the state calculate the interpolated value.
     */
    function ParticleFollowNode(usesPosition, usesRotation, smooth) {
        if (usesPosition === void 0) { usesPosition = true; }
        if (usesRotation === void 0) { usesRotation = true; }
        if (smooth === void 0) { smooth = false; }
        var _this = _super.call(this, "ParticleFollow", ParticlePropertiesMode.LOCAL_DYNAMIC, (usesPosition && usesRotation) ? 6 : 3, ParticleAnimationSet.POST_PRIORITY) || this;
        _this._pStateClass = ParticleFollowState;
        _this._iUsesPosition = usesPosition;
        _this._iUsesRotation = usesRotation;
        _this._iSmooth = smooth;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleFollowNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        //TODO: use Quaternion to implement this function
        var code = "";
        if (this._iUsesRotation) {
            var rotationAttribute = registerCache.getFreeVertexAttribute();
            animationRegisterData.setRegisterIndex(this, ParticleFollowState.FOLLOW_ROTATION_INDEX, rotationAttribute.index);
            var temp1 = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(temp1, 1);
            var temp2 = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(temp2, 1);
            var temp3 = registerCache.getFreeVertexVectorTemp();
            var temp4;
            if (animationSet.hasBillboard) {
                registerCache.addVertexTempUsages(temp3, 1);
                temp4 = registerCache.getFreeVertexVectorTemp();
            }
            registerCache.removeVertexTempUsage(temp1);
            registerCache.removeVertexTempUsage(temp2);
            if (animationSet.hasBillboard)
                registerCache.removeVertexTempUsage(temp3);
            var len = animationRegisterData.rotationRegisters.length;
            var i;
            //x axis
            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp1 + ".x," + animationRegisterData.vertexOneConst + "\n";
            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "sin " + temp3 + ".y," + rotationAttribute + ".x\n";
            code += "cos " + temp3 + ".z," + rotationAttribute + ".x\n";
            code += "mov " + temp2 + ".x," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp2 + ".y," + temp3 + ".z\n";
            code += "neg " + temp2 + ".z," + temp3 + ".y\n";
            if (animationSet.hasBillboard)
                code += "m33 " + temp4 + ".xyz," + animationRegisterData.positionTarget + ".xyz," + temp1 + "\n";
            else {
                code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                for (i = 0; i < len; i++)
                    code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
            }
            //y axis
            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "cos " + temp1 + ".x," + rotationAttribute + ".y\n";
            code += "sin " + temp1 + ".z," + rotationAttribute + ".y\n";
            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp2 + ".y," + animationRegisterData.vertexOneConst + "\n";
            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "neg " + temp3 + ".x," + temp1 + ".z\n";
            code += "mov " + temp3 + ".z," + temp1 + ".x\n";
            if (animationSet.hasBillboard)
                code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
            else {
                code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                for (i = 0; i < len; i++)
                    code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
            }
            //z axis
            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "sin " + temp2 + ".x," + rotationAttribute + ".z\n";
            code += "cos " + temp2 + ".y," + rotationAttribute + ".z\n";
            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp1 + ".x," + temp2 + ".y\n";
            code += "neg " + temp1 + ".y," + temp2 + ".x\n";
            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp3 + ".z," + animationRegisterData.vertexOneConst + "\n";
            if (animationSet.hasBillboard) {
                code += "m33 " + temp4 + ".xyz," + temp4 + ".xyz," + temp1 + "\n";
                code += "sub " + temp4 + ".xyz," + temp4 + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
                code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp4 + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
            }
            else {
                code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
                for (i = 0; i < len; i++)
                    code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
            }
        }
        if (this._iUsesPosition) {
            var positionAttribute = registerCache.getFreeVertexAttribute();
            animationRegisterData.setRegisterIndex(this, ParticleFollowState.FOLLOW_POSITION_INDEX, positionAttribute.index);
            code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + positionAttribute + "," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleFollowNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    return ParticleFollowNode;
}(ParticleNodeBase));

/**
*
*/
var ParticleInitialColorState = (function (_super) {
    __extends(ParticleInitialColorState, _super);
    function ParticleInitialColorState(animator, particleInitialColorNode) {
        var _this = _super.call(this, animator, particleInitialColorNode) || this;
        _this._particleInitialColorNode = particleInitialColorNode;
        _this._usesMultiplier = particleInitialColorNode._iUsesMultiplier;
        _this._usesOffset = particleInitialColorNode._iUsesOffset;
        _this._initialColor = particleInitialColorNode._iInitialColor;
        _this.updateColorData();
        return _this;
    }
    Object.defineProperty(ParticleInitialColorState.prototype, "initialColor", {
        /**
         * Defines the initial color transform of the state, when in global mode.
         */
        get: function () {
            return this._initialColor;
        },
        set: function (value) {
            this._initialColor = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleInitialColorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (shader.usesFragmentAnimation) {
            var index;
            if (this._particleInitialColorNode.mode == ParticlePropertiesMode.LOCAL_STATIC) {
                var dataOffset = this._particleInitialColorNode._iDataOffset;
                if (this._usesMultiplier) {
                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.MULTIPLIER_INDEX), dataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
                    dataOffset += 4;
                }
                if (this._usesOffset)
                    animationElements.activateVertexBuffer(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.OFFSET_INDEX), dataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
            }
            else {
                if (this._usesMultiplier)
                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.MULTIPLIER_INDEX), this._multiplierData.x, this._multiplierData.y, this._multiplierData.z, this._multiplierData.w);
                if (this._usesOffset)
                    shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleInitialColorState.OFFSET_INDEX), this._offsetData.x, this._offsetData.y, this._offsetData.z, this._offsetData.w);
            }
        }
    };
    ParticleInitialColorState.prototype.updateColorData = function () {
        if (this._particleInitialColorNode.mode == ParticlePropertiesMode.GLOBAL) {
            if (this._usesMultiplier)
                this._multiplierData = new _awayjs_core.Vector3D(this._initialColor.redMultiplier, this._initialColor.greenMultiplier, this._initialColor.blueMultiplier, this._initialColor.alphaMultiplier);
            if (this._usesOffset)
                this._offsetData = new _awayjs_core.Vector3D(this._initialColor.redOffset / 255, this._initialColor.greenOffset / 255, this._initialColor.blueOffset / 255, this._initialColor.alphaOffset / 255);
        }
    };
    return ParticleInitialColorState;
}(ParticleStateBase));
/** @private */
ParticleInitialColorState.MULTIPLIER_INDEX = 0;
/** @private */
ParticleInitialColorState.OFFSET_INDEX = 1;

/**
 *
 */
var ParticleInitialColorNode = (function (_super) {
    __extends(ParticleInitialColorNode, _super);
    function ParticleInitialColorNode(mode, usesMultiplier, usesOffset, initialColor) {
        if (usesMultiplier === void 0) { usesMultiplier = true; }
        if (usesOffset === void 0) { usesOffset = false; }
        if (initialColor === void 0) { initialColor = null; }
        var _this = _super.call(this, "ParticleInitialColor", mode, (usesMultiplier && usesOffset) ? 8 : 4, ParticleAnimationSet.COLOR_PRIORITY) || this;
        _this._pStateClass = ParticleInitialColorState;
        _this._iUsesMultiplier = usesMultiplier;
        _this._iUsesOffset = usesOffset;
        _this._iInitialColor = initialColor || new _awayjs_core.ColorTransform();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleInitialColorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var code = "";
        if (shader.usesFragmentAnimation) {
            if (this._iUsesMultiplier) {
                var multiplierValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
                animationRegisterData.setRegisterIndex(this, ParticleInitialColorState.MULTIPLIER_INDEX, multiplierValue.index);
                code += "mul " + animationRegisterData.colorMulTarget + "," + multiplierValue + "," + animationRegisterData.colorMulTarget + "\n";
            }
            if (this._iUsesOffset) {
                var offsetValue = (this._pMode == ParticlePropertiesMode.LOCAL_STATIC) ? registerCache.getFreeVertexAttribute() : registerCache.getFreeVertexConstant();
                animationRegisterData.setRegisterIndex(this, ParticleInitialColorState.OFFSET_INDEX, offsetValue.index);
                code += "add " + animationRegisterData.colorAddTarget + "," + offsetValue + "," + animationRegisterData.colorAddTarget + "\n";
            }
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleInitialColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
        if (this._iUsesMultiplier)
            particleAnimationSet.hasColorMulNode = true;
        if (this._iUsesOffset)
            particleAnimationSet.hasColorAddNode = true;
    };
    /**
     * @inheritDoc
     */
    ParticleInitialColorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var initialColor = param[ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM];
        if (!initialColor)
            throw (new Error("there is no " + ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM + " in param!"));
        var i = 0;
        //multiplier
        if (this._iUsesMultiplier) {
            this._pOneData[i++] = initialColor.redMultiplier;
            this._pOneData[i++] = initialColor.greenMultiplier;
            this._pOneData[i++] = initialColor.blueMultiplier;
            this._pOneData[i++] = initialColor.alphaMultiplier;
        }
        //offset
        if (this._iUsesOffset) {
            this._pOneData[i++] = initialColor.redOffset / 255;
            this._pOneData[i++] = initialColor.greenOffset / 255;
            this._pOneData[i++] = initialColor.blueOffset / 255;
            this._pOneData[i++] = initialColor.alphaOffset / 255;
        }
    };
    return ParticleInitialColorNode;
}(ParticleNodeBase));
/**
 * Reference for color node properties on a single particle (when in local property mode).
 * Expects a <code>ColorTransform</code> object representing the color transform applied to the particle.
 */
ParticleInitialColorNode.COLOR_INITIAL_COLORTRANSFORM = "ColorInitialColorTransform";

/**
 * ...
 */
var ParticleOrbitState = (function (_super) {
    __extends(ParticleOrbitState, _super);
    function ParticleOrbitState(animator, particleOrbitNode) {
        var _this = _super.call(this, animator, particleOrbitNode) || this;
        _this._particleOrbitNode = particleOrbitNode;
        _this._usesEulers = _this._particleOrbitNode._iUsesEulers;
        _this._usesCycle = _this._particleOrbitNode._iUsesCycle;
        _this._usesPhase = _this._particleOrbitNode._iUsesPhase;
        _this._eulers = _this._particleOrbitNode._iEulers;
        _this._radius = _this._particleOrbitNode._iRadius;
        _this._cycleDuration = _this._particleOrbitNode._iCycleDuration;
        _this._cyclePhase = _this._particleOrbitNode._iCyclePhase;
        _this.updateOrbitData();
        return _this;
    }
    Object.defineProperty(ParticleOrbitState.prototype, "radius", {
        /**
         * Defines the radius of the orbit when in global mode. Defaults to 100.
         */
        get: function () {
            return this._radius;
        },
        set: function (value) {
            this._radius = value;
            this.updateOrbitData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleOrbitState.prototype, "cycleDuration", {
        /**
         * Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
         */
        get: function () {
            return this._cycleDuration;
        },
        set: function (value) {
            this._cycleDuration = value;
            this.updateOrbitData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleOrbitState.prototype, "cyclePhase", {
        /**
         * Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
         */
        get: function () {
            return this._cyclePhase;
        },
        set: function (value) {
            this._cyclePhase = value;
            this.updateOrbitData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleOrbitState.prototype, "eulers", {
        /**
         * Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
         */
        get: function () {
            return this._eulers;
        },
        set: function (value) {
            this._eulers = value;
            this.updateOrbitData();
        },
        enumerable: true,
        configurable: true
    });
    ParticleOrbitState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleOrbitState.ORBIT_INDEX);
        if (this._particleOrbitNode.mode == ParticlePropertiesMode.LOCAL_STATIC) {
            if (this._usesPhase)
                animationElements.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
            else
                animationElements.activateVertexBuffer(index, this._particleOrbitNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
        }
        else
            shader.setVertexConst(index, this._orbitData.x, this._orbitData.y, this._orbitData.z, this._orbitData.w);
        if (this._usesEulers)
            shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleOrbitState.EULERS_INDEX), this._eulersMatrix);
    };
    ParticleOrbitState.prototype.updateOrbitData = function () {
        if (this._usesEulers) {
            this._eulersMatrix = new _awayjs_core.Matrix3D();
            this._eulersMatrix.appendRotation(this._eulers.x, _awayjs_core.Vector3D.X_AXIS);
            this._eulersMatrix.appendRotation(this._eulers.y, _awayjs_core.Vector3D.Y_AXIS);
            this._eulersMatrix.appendRotation(this._eulers.z, _awayjs_core.Vector3D.Z_AXIS);
        }
        if (this._particleOrbitNode.mode == ParticlePropertiesMode.GLOBAL) {
            this._orbitData = new _awayjs_core.Vector3D(this._radius, 0, this._radius * Math.PI * 2, this._cyclePhase * Math.PI / 180);
            if (this._usesCycle) {
                if (this._cycleDuration <= 0)
                    throw (new Error("the cycle duration must be greater than zero"));
                this._orbitData.y = Math.PI * 2 / this._cycleDuration;
            }
            else
                this._orbitData.y = Math.PI * 2;
        }
    };
    return ParticleOrbitState;
}(ParticleStateBase));
/** @private */
ParticleOrbitState.ORBIT_INDEX = 0;
/** @private */
ParticleOrbitState.EULERS_INDEX = 1;

/**
 * A particle animation node used to control the position of a particle over time around a circular orbit.
 */
var ParticleOrbitNode = (function (_super) {
    __extends(ParticleOrbitNode, _super);
    /**
     * Creates a new <code>ParticleOrbitNode</code> object.
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] usesEulers      Defines whether the node uses the <code>eulers</code> property in the shader to calculate a rotation on the orbit. Defaults to true.
     * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of the orbit independent of particle duration. Defaults to false.
     * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the cycle rotation of the particle. Defaults to false.
     * @param    [optional] radius          Defines the radius of the orbit when in global mode. Defaults to 100.
     * @param    [optional] cycleDuration   Defines the duration of the orbit in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
     * @param    [optional] cyclePhase      Defines the phase of the orbit in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
     * @param    [optional] eulers          Defines the euler rotation in degrees, applied to the orientation of the orbit when in global mode.
     */
    function ParticleOrbitNode(mode, usesEulers, usesCycle, usesPhase, radius, cycleDuration, cyclePhase, eulers) {
        if (usesEulers === void 0) { usesEulers = true; }
        if (usesCycle === void 0) { usesCycle = false; }
        if (usesPhase === void 0) { usesPhase = false; }
        if (radius === void 0) { radius = 100; }
        if (cycleDuration === void 0) { cycleDuration = 1; }
        if (cyclePhase === void 0) { cyclePhase = 0; }
        if (eulers === void 0) { eulers = null; }
        var _this;
        var len = 3;
        if (usesPhase)
            len++;
        _this = _super.call(this, "ParticleOrbit", mode, len) || this;
        _this._pStateClass = ParticleOrbitState;
        _this._iUsesEulers = usesEulers;
        _this._iUsesCycle = usesCycle;
        _this._iUsesPhase = usesPhase;
        _this._iRadius = radius;
        _this._iCycleDuration = cycleDuration;
        _this._iCyclePhase = cyclePhase;
        _this._iEulers = eulers || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleOrbitNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var orbitRegister = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleOrbitState.ORBIT_INDEX, orbitRegister.index);
        var eulersMatrixRegister = registerCache.getFreeVertexConstant();
        animationRegisterData.setRegisterIndex(this, ParticleOrbitState.EULERS_INDEX, eulersMatrixRegister.index);
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        var temp1 = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(temp1, 1);
        var distance = new _awayjs_stage.ShaderRegisterElement(temp1.regName, temp1.index);
        var temp2 = registerCache.getFreeVertexVectorTemp();
        var cos = new _awayjs_stage.ShaderRegisterElement(temp2.regName, temp2.index, 0);
        var sin = new _awayjs_stage.ShaderRegisterElement(temp2.regName, temp2.index, 1);
        var degree = new _awayjs_stage.ShaderRegisterElement(temp2.regName, temp2.index, 2);
        registerCache.removeVertexTempUsage(temp1);
        var code = "";
        if (this._iUsesCycle) {
            code += "mul " + degree + "," + animationRegisterData.vertexTime + "," + orbitRegister + ".y\n";
            if (this._iUsesPhase)
                code += "add " + degree + "," + degree + "," + orbitRegister + ".w\n";
        }
        else
            code += "mul " + degree + "," + animationRegisterData.vertexLife + "," + orbitRegister + ".y\n";
        code += "cos " + cos + "," + degree + "\n";
        code += "sin " + sin + "," + degree + "\n";
        code += "mul " + distance + ".x," + cos + "," + orbitRegister + ".x\n";
        code += "mul " + distance + ".y," + sin + "," + orbitRegister + ".x\n";
        code += "mov " + distance + ".wz" + animationRegisterData.vertexZeroConst + "\n";
        if (this._iUsesEulers)
            code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
        if (animationSet.needVelocity) {
            code += "neg " + distance + ".x," + sin + "\n";
            code += "mov " + distance + ".y," + cos + "\n";
            code += "mov " + distance + ".zw," + animationRegisterData.vertexZeroConst + "\n";
            if (this._iUsesEulers)
                code += "m44 " + distance + "," + distance + "," + eulersMatrixRegister + "\n";
            code += "mul " + distance + "," + distance + "," + orbitRegister + ".z\n";
            code += "div " + distance + "," + distance + "," + orbitRegister + ".y\n";
            if (!this._iUsesCycle)
                code += "div " + distance + "," + distance + "," + animationRegisterData.vertexLife + "\n";
            code += "add " + animationRegisterData.velocityTarget + ".xyz," + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleOrbitNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleOrbitNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        //Vector3D.x is radius, Vector3D.y is cycle duration, Vector3D.z is phase
        var orbit = param[ParticleOrbitNode.ORBIT_VECTOR3D];
        if (!orbit)
            throw new Error("there is no " + ParticleOrbitNode.ORBIT_VECTOR3D + " in param!");
        this._pOneData[0] = orbit.x;
        if (this._iUsesCycle && orbit.y <= 0)
            throw (new Error("the cycle duration must be greater than zero"));
        this._pOneData[1] = Math.PI * 2 / (!this._iUsesCycle ? 1 : orbit.y);
        this._pOneData[2] = orbit.x * Math.PI * 2;
        if (this._iUsesPhase)
            this._pOneData[3] = orbit.z * Math.PI / 180;
    };
    return ParticleOrbitNode;
}(ParticleNodeBase));
/**
 * Reference for orbit node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the radius (x), cycle speed (y) and cycle phase (z) of the motion on the particle.
 */
ParticleOrbitNode.ORBIT_VECTOR3D = "OrbitVector3D";

/**
 * ...
 */
var ParticleOscillatorState = (function (_super) {
    __extends(ParticleOscillatorState, _super);
    function ParticleOscillatorState(animator, particleOscillatorNode) {
        var _this = _super.call(this, animator, particleOscillatorNode) || this;
        _this._particleOscillatorNode = particleOscillatorNode;
        _this._oscillator = _this._particleOscillatorNode._iOscillator;
        _this.updateOscillatorData();
        return _this;
    }
    Object.defineProperty(ParticleOscillatorState.prototype, "oscillator", {
        /**
         * Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the state, used when in global mode.
         */
        get: function () {
            return this._oscillator;
        },
        set: function (value) {
            this._oscillator = value;
            this.updateOscillatorData();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleOscillatorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleOscillatorState.OSCILLATOR_INDEX);
        if (this._particleOscillatorNode.mode == ParticlePropertiesMode.LOCAL_STATIC)
            animationElements.activateVertexBuffer(index, this._particleOscillatorNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
        else
            shader.setVertexConst(index, this._oscillatorData.x, this._oscillatorData.y, this._oscillatorData.z, this._oscillatorData.w);
    };
    ParticleOscillatorState.prototype.updateOscillatorData = function () {
        if (this._particleOscillatorNode.mode == ParticlePropertiesMode.GLOBAL) {
            if (this._oscillator.w <= 0)
                throw (new Error("the cycle duration must greater than zero"));
            if (this._oscillatorData == null)
                this._oscillatorData = new _awayjs_core.Vector3D();
            this._oscillatorData.x = this._oscillator.x;
            this._oscillatorData.y = this._oscillator.y;
            this._oscillatorData.z = this._oscillator.z;
            this._oscillatorData.w = Math.PI * 2 / this._oscillator.w;
        }
    };
    return ParticleOscillatorState;
}(ParticleStateBase));
/** @private */
ParticleOscillatorState.OSCILLATOR_INDEX = 0;

/**
 * A particle animation node used to control the position of a particle over time using simple harmonic motion.
 */
var ParticleOscillatorNode = (function (_super) {
    __extends(ParticleOscillatorNode, _super);
    /**
     * Creates a new <code>ParticleOscillatorNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] oscillator      Defines the default oscillator axis (x, y, z) and cycleDuration (w) of the node, used when in global mode.
     */
    function ParticleOscillatorNode(mode, oscillator) {
        if (oscillator === void 0) { oscillator = null; }
        var _this = _super.call(this, "ParticleOscillator", mode, 4) || this;
        _this._pStateClass = ParticleOscillatorState;
        _this._iOscillator = oscillator || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleOscillatorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var oscillatorRegister = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleOscillatorState.OSCILLATOR_INDEX, oscillatorRegister.index);
        var temp = registerCache.getFreeVertexVectorTemp();
        var dgree = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 0);
        var sin = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 1);
        var cos = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 2);
        registerCache.addVertexTempUsages(temp, 1);
        var temp2 = registerCache.getFreeVertexVectorTemp();
        var distance = new _awayjs_stage.ShaderRegisterElement(temp2.regName, temp2.index);
        registerCache.removeVertexTempUsage(temp);
        var code = "";
        code += "mul " + dgree + "," + animationRegisterData.vertexTime + "," + oscillatorRegister + ".w\n";
        code += "sin " + sin + "," + dgree + "\n";
        code += "mul " + distance + ".xyz," + sin + "," + oscillatorRegister + ".xyz\n";
        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
        if (animationSet.needVelocity) {
            code += "cos " + cos + "," + dgree + "\n";
            code += "mul " + distance + ".xyz," + cos + "," + oscillatorRegister + ".xyz\n";
            code += "add " + animationRegisterData.velocityTarget + ".xyz," + distance + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleOscillatorNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleOscillatorNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        //(Vector3D.x,Vector3D.y,Vector3D.z) is oscillator axis, Vector3D.w is oscillator cycle duration
        var drift = param[ParticleOscillatorNode.OSCILLATOR_VECTOR3D];
        if (!drift)
            throw (new Error("there is no " + ParticleOscillatorNode.OSCILLATOR_VECTOR3D + " in param!"));
        this._pOneData[0] = drift.x;
        this._pOneData[1] = drift.y;
        this._pOneData[2] = drift.z;
        if (drift.w <= 0)
            throw (new Error("the cycle duration must greater than zero"));
        this._pOneData[3] = Math.PI * 2 / drift.w;
    };
    return ParticleOscillatorNode;
}(ParticleNodeBase));
/**
 * Reference for ocsillator node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the axis (x,y,z) and cycle speed (w) of the motion on the particle.
 */
ParticleOscillatorNode.OSCILLATOR_VECTOR3D = "OscillatorVector3D";

/**
 * ...
 * @author ...
 */
var ParticlePositionState = (function (_super) {
    __extends(ParticlePositionState, _super);
    function ParticlePositionState(animator, particlePositionNode) {
        var _this = _super.call(this, animator, particlePositionNode) || this;
        _this._particlePositionNode = particlePositionNode;
        _this._position = _this._particlePositionNode._iPosition;
        return _this;
    }
    Object.defineProperty(ParticlePositionState.prototype, "position", {
        /**
         * Defines the position of the particle when in global mode. Defaults to 0,0,0.
         */
        get: function () {
            return this._position;
        },
        set: function (value) {
            this._position = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    ParticlePositionState.prototype.getPositions = function () {
        return this._pDynamicProperties;
    };
    ParticlePositionState.prototype.setPositions = function (value) {
        this._pDynamicProperties = value;
        this._pDynamicPropertiesDirty = new Object();
    };
    /**
     * @inheritDoc
     */
    ParticlePositionState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (this._particlePositionNode.mode == ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationElements._iUniqueId])
            this._pUpdateDynamicProperties(animationElements);
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticlePositionState.POSITION_INDEX);
        if (this._particlePositionNode.mode == ParticlePropertiesMode.GLOBAL)
            shader.setVertexConst(index, this._position.x, this._position.y, this._position.z);
        else
            animationElements.activateVertexBuffer(index, this._particlePositionNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
    };
    return ParticlePositionState;
}(ParticleStateBase));
/** @private */
ParticlePositionState.POSITION_INDEX = 0;

/**
 * A particle animation node used to set the starting position of a particle.
 */
var ParticlePositionNode = (function (_super) {
    __extends(ParticlePositionNode, _super);
    /**
     * Creates a new <code>ParticlePositionNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] position        Defines the default position of the particle when in global mode. Defaults to 0,0,0.
     */
    function ParticlePositionNode(mode, position) {
        if (position === void 0) { position = null; }
        var _this = _super.call(this, "ParticlePosition", mode, 3) || this;
        _this._pStateClass = ParticlePositionState;
        _this._iPosition = position || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticlePositionNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var positionAttribute = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticlePositionState.POSITION_INDEX, positionAttribute.index);
        return "add " + animationRegisterData.positionTarget + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
    };
    /**
     * @inheritDoc
     */
    ParticlePositionNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticlePositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var offset = param[ParticlePositionNode.POSITION_VECTOR3D];
        if (!offset)
            throw (new Error("there is no " + ParticlePositionNode.POSITION_VECTOR3D + " in param!"));
        this._pOneData[0] = offset.x;
        this._pOneData[1] = offset.y;
        this._pOneData[2] = offset.z;
    };
    return ParticlePositionNode;
}(ParticleNodeBase));
/**
 * Reference for position node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing position of the particle.
 */
ParticlePositionNode.POSITION_VECTOR3D = "PositionVector3D";

/**
 * ...
 */
var ParticleRotateToHeadingState = (function (_super) {
    __extends(ParticleRotateToHeadingState, _super);
    function ParticleRotateToHeadingState(animator, particleNode) {
        var _this = _super.call(this, animator, particleNode) || this;
        _this._matrix = new _awayjs_core.Matrix3D();
        return _this;
    }
    ParticleRotateToHeadingState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (this._pParticleAnimator.animationSet.hasBillboard) {
            this._matrix.copyFrom(renderable.sourceEntity.transform.concatenatedMatrix3D);
            this._matrix.append(projection.transform.inverseConcatenatedMatrix3D);
            shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotateToHeadingState.MATRIX_INDEX), this._matrix);
        }
    };
    return ParticleRotateToHeadingState;
}(ParticleStateBase));
/** @private */
ParticleRotateToHeadingState.MATRIX_INDEX = 0;

/**
 * A particle animation node used to control the rotation of a particle to match its heading vector.
 */
var ParticleRotateToHeadingNode = (function (_super) {
    __extends(ParticleRotateToHeadingNode, _super);
    /**
     * Creates a new <code>ParticleBillboardNode</code>
     */
    function ParticleRotateToHeadingNode() {
        var _this = _super.call(this, "ParticleRotateToHeading", ParticlePropertiesMode.GLOBAL, 0, 3) || this;
        _this._pStateClass = ParticleRotateToHeadingState;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleRotateToHeadingNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var code = "";
        var len = animationRegisterData.rotationRegisters.length;
        var i;
        if (animationSet.hasBillboard) {
            var temp1 = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(temp1, 1);
            var temp2 = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(temp2, 1);
            var temp3 = registerCache.getFreeVertexVectorTemp();
            var rotationMatrixRegister = registerCache.getFreeVertexConstant();
            animationRegisterData.setRegisterIndex(this, ParticleRotateToHeadingState.MATRIX_INDEX, rotationMatrixRegister.index);
            registerCache.getFreeVertexConstant();
            registerCache.getFreeVertexConstant();
            registerCache.getFreeVertexConstant();
            registerCache.removeVertexTempUsage(temp1);
            registerCache.removeVertexTempUsage(temp2);
            //process the velocity
            code += "m33 " + temp1 + ".xyz," + animationRegisterData.velocityTarget + ".xyz," + rotationMatrixRegister + "\n";
            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
            code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";
            //temp3.x=cos,temp3.y=sin
            //only process z axis
            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp2 + ".x," + temp3 + ".y\n";
            code += "mov " + temp2 + ".y," + temp3 + ".x\n";
            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp1 + ".x," + temp3 + ".x\n";
            code += "neg " + temp1 + ".y," + temp3 + ".y\n";
            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp3 + ".z," + animationRegisterData.vertexOneConst + "\n";
            code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
            for (i = 0; i < len; i++)
                code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
        }
        else {
            var nrmVel = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(nrmVel, 1);
            var xAxis = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(xAxis, 1);
            var R = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(R, 1);
            var R_rev = registerCache.getFreeVertexVectorTemp();
            var cos = new _awayjs_stage.ShaderRegisterElement(R.regName, R.index, 3);
            var sin = new _awayjs_stage.ShaderRegisterElement(R_rev.regName, R_rev.index, 3);
            var cos2 = new _awayjs_stage.ShaderRegisterElement(nrmVel.regName, nrmVel.index, 3);
            var tempSingle = sin;
            registerCache.removeVertexTempUsage(nrmVel);
            registerCache.removeVertexTempUsage(xAxis);
            registerCache.removeVertexTempUsage(R);
            code += "mov " + xAxis + ".x," + animationRegisterData.vertexOneConst + "\n";
            code += "mov " + xAxis + ".yz," + animationRegisterData.vertexZeroConst + "\n";
            code += "nrm " + nrmVel + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
            code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
            code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
            code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";
            //use R as temp to judge if nrm is (0,0,0).
            //if nrm is (0,0,0) ,change it to (0,0,1).
            code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
            code += "sge " + R + ".x," + animationRegisterData.vertexZeroConst + "," + R + ".x\n";
            code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";
            code += "add " + tempSingle + "," + cos2 + "," + animationRegisterData.vertexOneConst + "\n";
            code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
            code += "sqt " + cos + "," + tempSingle + "\n";
            code += "sub " + tempSingle + "," + animationRegisterData.vertexOneConst + "," + cos2 + "\n";
            code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
            code += "sqt " + sin + "," + tempSingle + "\n";
            code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";
            //use cos as R.w
            code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
            code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
            //use cos as R_rev.w
            //nrmVel and xAxis are used as temp register
            code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
            //use cos as R.w
            code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
            code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
            code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
            code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
            code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
            //code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," +R_rev + ".w\n";
            code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
            code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
            code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
            code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
            for (i = 0; i < len; i++) {
                //just repeat the calculate above
                //because of the limited registers, no need to optimise
                code += "mov " + xAxis + ".x," + animationRegisterData.vertexOneConst + "\n";
                code += "mov " + xAxis + ".yz," + animationRegisterData.vertexZeroConst + "\n";
                code += "nrm " + nrmVel + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
                code += "dp3 " + cos2 + "," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                code += "crs " + nrmVel + ".xyz," + xAxis + ".xyz," + nrmVel + ".xyz\n";
                code += "nrm " + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                code += "dp3 " + R + ".x," + nrmVel + ".xyz," + nrmVel + ".xyz\n";
                code += "sge " + R + ".x," + animationRegisterData.vertexZeroConst + "," + R + ".x\n";
                code += "add " + nrmVel + ".z," + R + ".x," + nrmVel + ".z\n";
                code += "add " + tempSingle + "," + cos2 + "," + animationRegisterData.vertexOneConst + "\n";
                code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
                code += "sqt " + cos + "," + tempSingle + "\n";
                code += "sub " + tempSingle + "," + animationRegisterData.vertexOneConst + "," + cos2 + "\n";
                code += "div " + tempSingle + "," + tempSingle + "," + animationRegisterData.vertexTwoConst + "\n";
                code += "sqt " + sin + "," + tempSingle + "\n";
                code += "mul " + R + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
                code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
                code += "crs " + nrmVel + ".xyz," + R + ".xyz," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
                code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
                code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
                code += "dp3 " + xAxis + ".w," + R + ".xyz," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
                code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
                code += "crs " + R + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
                code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
                code += "add " + R + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
                code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
                code += "add " + animationRegisterData.rotationRegisters[i] + ".xyz," + R + ".xyz," + xAxis + ".xyz\n";
            }
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleRotateToHeadingNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleRotateToHeadingNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
        particleAnimationSet.needVelocity = true;
    };
    return ParticleRotateToHeadingNode;
}(ParticleNodeBase));

/**
 * ...
 */
var ParticleRotateToPositionState = (function (_super) {
    __extends(ParticleRotateToPositionState, _super);
    function ParticleRotateToPositionState(animator, particleRotateToPositionNode) {
        var _this = _super.call(this, animator, particleRotateToPositionNode) || this;
        _this._matrix = new _awayjs_core.Matrix3D();
        _this._particleRotateToPositionNode = particleRotateToPositionNode;
        _this._position = _this._particleRotateToPositionNode._iPosition;
        return _this;
    }
    Object.defineProperty(ParticleRotateToPositionState.prototype, "position", {
        /**
         * Defines the position of the point the particle will rotate to face when in global mode. Defaults to 0,0,0.
         */
        get: function () {
            return this._position;
        },
        set: function (value) {
            this._position = value;
        },
        enumerable: true,
        configurable: true
    });
    ParticleRotateToPositionState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotateToPositionState.POSITION_INDEX);
        if (this._pParticleAnimator.animationSet.hasBillboard) {
            this._matrix.copyFrom(renderable.sourceEntity.transform.concatenatedMatrix3D);
            this._matrix.append(projection.transform.inverseConcatenatedMatrix3D);
            shader.setVertexConstFromMatrix(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotateToPositionState.MATRIX_INDEX), this._matrix);
        }
        if (this._particleRotateToPositionNode.mode == ParticlePropertiesMode.GLOBAL) {
            this._offset = renderable.sourceEntity.transform.inverseConcatenatedMatrix3D.transformVector(this._position);
            shader.setVertexConst(index, this._offset.x, this._offset.y, this._offset.z);
        }
        else
            animationElements.activateVertexBuffer(index, this._particleRotateToPositionNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
    };
    return ParticleRotateToPositionState;
}(ParticleStateBase));
/** @private */
ParticleRotateToPositionState.MATRIX_INDEX = 0;
/** @private */
ParticleRotateToPositionState.POSITION_INDEX = 1;

/**
 * A particle animation node used to control the rotation of a particle to face to a position
 */
var ParticleRotateToPositionNode = (function (_super) {
    __extends(ParticleRotateToPositionNode, _super);
    /**
     * Creates a new <code>ParticleRotateToPositionNode</code>
     */
    function ParticleRotateToPositionNode(mode, position) {
        if (position === void 0) { position = null; }
        var _this = _super.call(this, "ParticleRotateToPosition", mode, 3, 3) || this;
        _this._pStateClass = ParticleRotateToPositionState;
        _this._iPosition = position || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleRotateToPositionNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var positionAttribute = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleRotateToPositionState.POSITION_INDEX, positionAttribute.index);
        var code = "";
        var len = animationRegisterData.rotationRegisters.length;
        var i;
        if (animationSet.hasBillboard) {
            var temp1 = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(temp1, 1);
            var temp2 = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(temp2, 1);
            var temp3 = registerCache.getFreeVertexVectorTemp();
            var rotationMatrixRegister = registerCache.getFreeVertexConstant();
            animationRegisterData.setRegisterIndex(this, ParticleRotateToPositionState.MATRIX_INDEX, rotationMatrixRegister.index);
            registerCache.getFreeVertexConstant();
            registerCache.getFreeVertexConstant();
            registerCache.getFreeVertexConstant();
            registerCache.removeVertexTempUsage(temp1);
            registerCache.removeVertexTempUsage(temp2);
            //process the position
            code += "sub " + temp1 + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
            code += "m33 " + temp1 + ".xyz," + temp1 + ".xyz," + rotationMatrixRegister + "\n";
            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp3 + ".xy," + temp1 + ".xy\n";
            code += "nrm " + temp3 + ".xyz," + temp3 + ".xyz\n";
            //temp3.x=cos,temp3.y=sin
            //only process z axis
            code += "mov " + temp2 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp2 + ".x," + temp3 + ".y\n";
            code += "mov " + temp2 + ".y," + temp3 + ".x\n";
            code += "mov " + temp1 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp1 + ".x," + temp3 + ".x\n";
            code += "neg " + temp1 + ".y," + temp3 + ".y\n";
            code += "mov " + temp3 + "," + animationRegisterData.vertexZeroConst + "\n";
            code += "mov " + temp3 + ".z," + animationRegisterData.vertexOneConst + "\n";
            code += "m33 " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp1 + "\n";
            for (i = 0; i < len; i++)
                code += "m33 " + animationRegisterData.rotationRegisters[i] + ".xyz," + animationRegisterData.rotationRegisters[i] + "," + temp1 + "\n";
        }
        else {
            var nrmDirection = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(nrmDirection, 1);
            var temp = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(temp, 1);
            var cos = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 0);
            var sin = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 1);
            var o_temp = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 2);
            var tempSingle = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 3);
            var R = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(R, 1);
            registerCache.removeVertexTempUsage(nrmDirection);
            registerCache.removeVertexTempUsage(temp);
            registerCache.removeVertexTempUsage(R);
            code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
            code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
            code += "mov " + sin + "," + nrmDirection + ".y\n";
            code += "mul " + cos + "," + sin + "," + sin + "\n";
            code += "sub " + cos + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
            code += "sqt " + cos + "," + cos + "\n";
            code += "mul " + R + ".x," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".y\n";
            code += "mul " + R + ".y," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
            code += "mul " + R + ".z," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".y\n";
            code += "mul " + R + ".w," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
            code += "sub " + animationRegisterData.scaleAndRotateTarget + ".y," + R + ".x," + R + ".y\n";
            code += "add " + animationRegisterData.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";
            code += "abs " + R + ".y," + nrmDirection + ".y\n";
            code += "sge " + R + ".z," + R + ".y," + animationRegisterData.vertexOneConst + "\n";
            code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";
            //judgu if nrmDirection=(0,1,0);
            code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
            code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
            code += "sge " + tempSingle + "," + animationRegisterData.vertexZeroConst + "," + sin + "\n";
            code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
            code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
            code += "sub " + sin + "," + animationRegisterData.vertexOneConst + "," + tempSingle + "\n";
            code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";
            code += "mov " + cos + "," + nrmDirection + ".z\n";
            code += "neg " + cos + "," + cos + "\n";
            code += "sub " + o_temp + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
            code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
            code += "add " + cos + "," + cos + "," + o_temp + "\n";
            code += "mul " + R + ".x," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".x\n";
            code += "mul " + R + ".y," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
            code += "mul " + R + ".z," + sin + "," + animationRegisterData.scaleAndRotateTarget + ".x\n";
            code += "mul " + R + ".w," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".z\n";
            code += "sub " + animationRegisterData.scaleAndRotateTarget + ".x," + R + ".x," + R + ".y\n";
            code += "add " + animationRegisterData.scaleAndRotateTarget + ".z," + R + ".z," + R + ".w\n";
            for (i = 0; i < len; i++) {
                //just repeat the calculate above
                //because of the limited registers, no need to optimise
                code += "sub " + nrmDirection + ".xyz," + positionAttribute + ".xyz," + animationRegisterData.positionTarget + ".xyz\n";
                code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                code += "mov " + sin + "," + nrmDirection + ".y\n";
                code += "mul " + cos + "," + sin + "," + sin + "\n";
                code += "sub " + cos + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
                code += "sqt " + cos + "," + cos + "\n";
                code += "mul " + R + ".x," + cos + "," + animationRegisterData.rotationRegisters[i] + ".y\n";
                code += "mul " + R + ".y," + sin + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
                code += "mul " + R + ".z," + sin + "," + animationRegisterData.rotationRegisters[i] + ".y\n";
                code += "mul " + R + ".w," + cos + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
                code += "sub " + animationRegisterData.rotationRegisters[i] + ".y," + R + ".x," + R + ".y\n";
                code += "add " + animationRegisterData.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
                code += "abs " + R + ".y," + nrmDirection + ".y\n";
                code += "sge " + R + ".z," + R + ".y," + animationRegisterData.vertexOneConst + "\n";
                code += "mul " + R + ".x," + R + ".y," + nrmDirection + ".y\n";
                code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
                code += "dp3 " + sin + "," + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                code += "sge " + tempSingle + "," + animationRegisterData.vertexZeroConst + "," + sin + "\n";
                code += "mov " + nrmDirection + ".y," + animationRegisterData.vertexZeroConst + "\n";
                code += "nrm " + nrmDirection + ".xyz," + nrmDirection + ".xyz\n";
                code += "sub " + sin + "," + animationRegisterData.vertexOneConst + "," + tempSingle + "\n";
                code += "mul " + sin + "," + sin + "," + nrmDirection + ".x\n";
                code += "mov " + cos + "," + nrmDirection + ".z\n";
                code += "neg " + cos + "," + cos + "\n";
                code += "sub " + o_temp + "," + animationRegisterData.vertexOneConst + "," + cos + "\n";
                code += "mul " + o_temp + "," + R + ".x," + tempSingle + "\n";
                code += "add " + cos + "," + cos + "," + o_temp + "\n";
                code += "mul " + R + ".x," + cos + "," + animationRegisterData.rotationRegisters[i] + ".x\n";
                code += "mul " + R + ".y," + sin + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
                code += "mul " + R + ".z," + sin + "," + animationRegisterData.rotationRegisters[i] + ".x\n";
                code += "mul " + R + ".w," + cos + "," + animationRegisterData.rotationRegisters[i] + ".z\n";
                code += "sub " + animationRegisterData.rotationRegisters[i] + ".x," + R + ".x," + R + ".y\n";
                code += "add " + animationRegisterData.rotationRegisters[i] + ".z," + R + ".z," + R + ".w\n";
            }
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleRotateToPositionNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleRotateToPositionNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var offset = param[ParticleRotateToPositionNode.POSITION_VECTOR3D];
        if (!offset)
            throw (new Error("there is no " + ParticleRotateToPositionNode.POSITION_VECTOR3D + " in param!"));
        this._pOneData[0] = offset.x;
        this._pOneData[1] = offset.y;
        this._pOneData[2] = offset.z;
    };
    return ParticleRotateToPositionNode;
}(ParticleNodeBase));
/**
 * Reference for the position the particle will rotate to face for a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the position that the particle must face.
 */
ParticleRotateToPositionNode.POSITION_VECTOR3D = "RotateToPositionVector3D";

/**
 * ...
 */
var ParticleRotationalVelocityState = (function (_super) {
    __extends(ParticleRotationalVelocityState, _super);
    function ParticleRotationalVelocityState(animator, particleRotationNode) {
        var _this = _super.call(this, animator, particleRotationNode) || this;
        _this._particleRotationalVelocityNode = particleRotationNode;
        _this._rotationalVelocity = _this._particleRotationalVelocityNode._iRotationalVelocity;
        _this.updateRotationalVelocityData();
        return _this;
    }
    Object.defineProperty(ParticleRotationalVelocityState.prototype, "rotationalVelocity", {
        /**
         * Defines the default rotationalVelocity of the state, used when in global mode.
         */
        get: function () {
            return this._rotationalVelocity;
        },
        set: function (value) {
            this._rotationalVelocity = value;
            this.updateRotationalVelocityData();
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    ParticleRotationalVelocityState.prototype.getRotationalVelocities = function () {
        return this._pDynamicProperties;
    };
    ParticleRotationalVelocityState.prototype.setRotationalVelocities = function (value) {
        this._pDynamicProperties = value;
        this._pDynamicPropertiesDirty = new Object();
    };
    /**
     * @inheritDoc
     */
    ParticleRotationalVelocityState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (this._particleRotationalVelocityNode.mode == ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationElements._iUniqueId])
            this._pUpdateDynamicProperties(animationElements);
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleRotationalVelocityState.ROTATIONALVELOCITY_INDEX);
        if (this._particleRotationalVelocityNode.mode == ParticlePropertiesMode.GLOBAL)
            shader.setVertexConst(index, this._rotationalVelocityData.x, this._rotationalVelocityData.y, this._rotationalVelocityData.z, this._rotationalVelocityData.w);
        else
            animationElements.activateVertexBuffer(index, this._particleRotationalVelocityNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
    };
    ParticleRotationalVelocityState.prototype.updateRotationalVelocityData = function () {
        if (this._particleRotationalVelocityNode.mode == ParticlePropertiesMode.GLOBAL) {
            if (this._rotationalVelocity.w <= 0)
                throw (new Error("the cycle duration must greater than zero"));
            var rotation = this._rotationalVelocity.clone();
            if (rotation.length <= 0)
                rotation.z = 1; //set the default direction
            else
                rotation.normalize();
            // w is used as angle/2 in agal
            this._rotationalVelocityData = new _awayjs_core.Vector3D(rotation.x, rotation.y, rotation.z, Math.PI / rotation.w);
        }
    };
    return ParticleRotationalVelocityState;
}(ParticleStateBase));
/** @private */
ParticleRotationalVelocityState.ROTATIONALVELOCITY_INDEX = 0;

/**
 * A particle animation node used to set the starting rotational velocity of a particle.
 */
var ParticleRotationalVelocityNode = (function (_super) {
    __extends(ParticleRotationalVelocityNode, _super);
    /**
     * Creates a new <code>ParticleRotationalVelocityNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     */
    function ParticleRotationalVelocityNode(mode, rotationalVelocity) {
        if (rotationalVelocity === void 0) { rotationalVelocity = null; }
        var _this = _super.call(this, "ParticleRotationalVelocity", mode, 4) || this;
        _this._pStateClass = ParticleRotationalVelocityState;
        _this._iRotationalVelocity = rotationalVelocity || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleRotationalVelocityNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var rotationRegister = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleRotationalVelocityState.ROTATIONALVELOCITY_INDEX, rotationRegister.index);
        var nrmVel = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(nrmVel, 1);
        var xAxis = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(xAxis, 1);
        var temp = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(temp, 1);
        var Rtemp = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index);
        var R_rev = registerCache.getFreeVertexVectorTemp();
        R_rev = new _awayjs_stage.ShaderRegisterElement(R_rev.regName, R_rev.index);
        var cos = new _awayjs_stage.ShaderRegisterElement(Rtemp.regName, Rtemp.index, 3);
        var sin = new _awayjs_stage.ShaderRegisterElement(R_rev.regName, R_rev.index, 3);
        registerCache.removeVertexTempUsage(nrmVel);
        registerCache.removeVertexTempUsage(xAxis);
        registerCache.removeVertexTempUsage(temp);
        var code = "";
        code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
        code += "mov " + nrmVel + ".w," + animationRegisterData.vertexZeroConst + "\n";
        code += "mul " + cos + "," + animationRegisterData.vertexTime + "," + rotationRegister + ".w\n";
        code += "sin " + sin + "," + cos + "\n";
        code += "cos " + cos + "," + cos + "\n";
        code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";
        code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
        code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
        //nrmVel and xAxis are used as temp register
        code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
        code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
        code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
        code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz\n";
        code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
        code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
        //use cos as R_rev.w
        code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
        code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
        code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
        code += "add " + animationRegisterData.scaleAndRotateTarget + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
        var len = animationRegisterData.rotationRegisters.length;
        for (var i = 0; i < len; i++) {
            code += "mov " + nrmVel + ".xyz," + rotationRegister + ".xyz\n";
            code += "mov " + nrmVel + ".w," + animationRegisterData.vertexZeroConst + "\n";
            code += "mul " + cos + "," + animationRegisterData.vertexTime + "," + rotationRegister + ".w\n";
            code += "sin " + sin + "," + cos + "\n";
            code += "cos " + cos + "," + cos + "\n";
            code += "mul " + Rtemp + ".xyz," + sin + "," + nrmVel + ".xyz\n";
            code += "mul " + R_rev + ".xyz," + sin + "," + nrmVel + ".xyz\n";
            code += "neg " + R_rev + ".xyz," + R_rev + ".xyz\n";
            code += "crs " + nrmVel + ".xyz," + Rtemp + ".xyz," + animationRegisterData.rotationRegisters[i] + ".xyz\n";
            code += "mul " + xAxis + ".xyz," + cos + "," + animationRegisterData.rotationRegisters[i] + "\n";
            code += "add " + nrmVel + ".xyz," + nrmVel + ".xyz," + xAxis + ".xyz\n";
            code += "dp3 " + xAxis + ".w," + Rtemp + ".xyz," + animationRegisterData.rotationRegisters[i] + "\n";
            code += "neg " + nrmVel + ".w," + xAxis + ".w\n";
            code += "crs " + Rtemp + ".xyz," + nrmVel + ".xyz," + R_rev + ".xyz\n";
            code += "mul " + xAxis + ".xyzw," + nrmVel + ".xyzw," + cos + "\n";
            code += "add " + Rtemp + ".xyz," + Rtemp + ".xyz," + xAxis + ".xyz\n";
            code += "mul " + xAxis + ".xyz," + nrmVel + ".w," + R_rev + ".xyz\n";
            code += "add " + animationRegisterData.rotationRegisters[i] + "," + Rtemp + ".xyz," + xAxis + ".xyz\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleRotationalVelocityNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleRotationalVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        //(Vector3d.x,Vector3d.y,Vector3d.z) is rotation axis,Vector3d.w is cycle duration
        var rotate = param[ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D];
        if (!rotate)
            throw (new Error("there is no " + ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D + " in param!"));
        if (rotate.length <= 0)
            rotate.z = 1; //set the default direction
        else
            rotate.normalize();
        this._pOneData[0] = rotate.x;
        this._pOneData[1] = rotate.y;
        this._pOneData[2] = rotate.z;
        if (rotate.w <= 0)
            throw (new Error("the cycle duration must greater than zero"));
        // it's used as angle/2 in agal
        this._pOneData[3] = Math.PI / rotate.w;
    };
    return ParticleRotationalVelocityNode;
}(ParticleNodeBase));
/**
 * Reference for rotational velocity node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the rotational velocity around an axis of the particle.
 */
ParticleRotationalVelocityNode.ROTATIONALVELOCITY_VECTOR3D = "RotationalVelocityVector3D";

/**
 * ...
 */
var ParticleScaleState = (function (_super) {
    __extends(ParticleScaleState, _super);
    function ParticleScaleState(animator, particleScaleNode) {
        var _this = _super.call(this, animator, particleScaleNode) || this;
        _this._particleScaleNode = particleScaleNode;
        _this._usesCycle = _this._particleScaleNode._iUsesCycle;
        _this._usesPhase = _this._particleScaleNode._iUsesPhase;
        _this._minScale = _this._particleScaleNode._iMinScale;
        _this._maxScale = _this._particleScaleNode._iMaxScale;
        _this._cycleDuration = _this._particleScaleNode._iCycleDuration;
        _this._cyclePhase = _this._particleScaleNode._iCyclePhase;
        _this.updateScaleData();
        return _this;
    }
    Object.defineProperty(ParticleScaleState.prototype, "minScale", {
        /**
         * Defines the end scale of the state, when in global mode. Defaults to 1.
         */
        get: function () {
            return this._minScale;
        },
        set: function (value) {
            this._minScale = value;
            this.updateScaleData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleScaleState.prototype, "maxScale", {
        /**
         * Defines the end scale of the state, when in global mode. Defaults to 1.
         */
        get: function () {
            return this._maxScale;
        },
        set: function (value) {
            this._maxScale = value;
            this.updateScaleData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleScaleState.prototype, "cycleDuration", {
        /**
         * Defines the duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
         */
        get: function () {
            return this._cycleDuration;
        },
        set: function (value) {
            this._cycleDuration = value;
            this.updateScaleData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleScaleState.prototype, "cyclePhase", {
        /**
         * Defines the phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
         */
        get: function () {
            return this._cyclePhase;
        },
        set: function (value) {
            this._cyclePhase = value;
            this.updateScaleData();
        },
        enumerable: true,
        configurable: true
    });
    ParticleScaleState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleScaleState.SCALE_INDEX);
        if (this._particleScaleNode.mode == ParticlePropertiesMode.LOCAL_STATIC) {
            if (this._usesCycle) {
                if (this._usesPhase)
                    animationElements.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_4);
                else
                    animationElements.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
            }
            else
                animationElements.activateVertexBuffer(index, this._particleScaleNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_2);
        }
        else
            shader.setVertexConst(index, this._scaleData.x, this._scaleData.y, this._scaleData.z, this._scaleData.w);
    };
    ParticleScaleState.prototype.updateScaleData = function () {
        if (this._particleScaleNode.mode == ParticlePropertiesMode.GLOBAL) {
            if (this._usesCycle) {
                if (this._cycleDuration <= 0)
                    throw (new Error("the cycle duration must be greater than zero"));
                this._scaleData = new _awayjs_core.Vector3D((this._minScale + this._maxScale) / 2, Math.abs(this._minScale - this._maxScale) / 2, Math.PI * 2 / this._cycleDuration, this._cyclePhase * Math.PI / 180);
            }
            else
                this._scaleData = new _awayjs_core.Vector3D(this._minScale, this._maxScale - this._minScale, 0, 0);
        }
    };
    return ParticleScaleState;
}(ParticleStateBase));
/** @private */
ParticleScaleState.SCALE_INDEX = 0;

/**
 * A particle animation node used to control the scale variation of a particle over time.
 */
var ParticleScaleNode = (function (_super) {
    __extends(ParticleScaleNode, _super);
    /**
     * Creates a new <code>ParticleScaleNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] usesCycle       Defines whether the node uses the <code>cycleDuration</code> property in the shader to calculate the period of animation independent of particle duration. Defaults to false.
     * @param    [optional] usesPhase       Defines whether the node uses the <code>cyclePhase</code> property in the shader to calculate a starting offset to the animation cycle. Defaults to false.
     * @param    [optional] minScale        Defines the default min scale transform of the node, when in global mode. Defaults to 1.
     * @param    [optional] maxScale        Defines the default max color transform of the node, when in global mode. Defaults to 1.
     * @param    [optional] cycleDuration   Defines the default duration of the animation in seconds, used as a period independent of particle duration when in global mode. Defaults to 1.
     * @param    [optional] cyclePhase      Defines the default phase of the cycle in degrees, used as the starting offset of the cycle when in global mode. Defaults to 0.
     */
    function ParticleScaleNode(mode, usesCycle, usesPhase, minScale, maxScale, cycleDuration, cyclePhase) {
        if (minScale === void 0) { minScale = 1; }
        if (maxScale === void 0) { maxScale = 1; }
        if (cycleDuration === void 0) { cycleDuration = 1; }
        if (cyclePhase === void 0) { cyclePhase = 0; }
        var _this = _super.call(this, "ParticleScale", mode, (usesCycle && usesPhase) ? 4 : ((usesCycle || usesPhase) ? 3 : 2), 3) || this;
        _this._pStateClass = ParticleScaleState;
        _this._iUsesCycle = usesCycle;
        _this._iUsesPhase = usesPhase;
        _this._iMinScale = minScale;
        _this._iMaxScale = maxScale;
        _this._iCycleDuration = cycleDuration;
        _this._iCyclePhase = cyclePhase;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleScaleNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var code = "";
        var temp = registerCache.getFreeVertexSingleTemp();
        var scaleRegister = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleScaleState.SCALE_INDEX, scaleRegister.index);
        if (this._iUsesCycle) {
            code += "mul " + temp + "," + animationRegisterData.vertexTime + "," + scaleRegister + ".z\n";
            if (this._iUsesPhase)
                code += "add " + temp + "," + temp + "," + scaleRegister + ".w\n";
            code += "sin " + temp + "," + temp + "\n";
        }
        code += "mul " + temp + "," + scaleRegister + ".y," + ((this._iUsesCycle) ? temp : animationRegisterData.vertexLife) + "\n";
        code += "add " + temp + "," + scaleRegister + ".x," + temp + "\n";
        code += "mul " + animationRegisterData.scaleAndRotateTarget + ".xyz," + animationRegisterData.scaleAndRotateTarget + ".xyz," + temp + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleScaleNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleScaleNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var scale = param[ParticleScaleNode.SCALE_VECTOR3D];
        if (!scale)
            throw (new Error("there is no " + ParticleScaleNode.SCALE_VECTOR3D + " in param!"));
        if (this._iUsesCycle) {
            this._pOneData[0] = (scale.x + scale.y) / 2;
            this._pOneData[1] = Math.abs(scale.x - scale.y) / 2;
            if (scale.z <= 0)
                throw (new Error("the cycle duration must be greater than zero"));
            this._pOneData[2] = Math.PI * 2 / scale.z;
            if (this._iUsesPhase)
                this._pOneData[3] = scale.w * Math.PI / 180;
        }
        else {
            this._pOneData[0] = scale.x;
            this._pOneData[1] = scale.y - scale.x;
        }
    };
    return ParticleScaleNode;
}(ParticleNodeBase));
/**
 * Reference for scale node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> representing the min scale (x), max scale(y), optional cycle speed (z) and phase offset (w) applied to the particle.
 */
ParticleScaleNode.SCALE_VECTOR3D = "ScaleVector3D";

/**
 *
 */
var ParticleSegmentedColorState = (function (_super) {
    __extends(ParticleSegmentedColorState, _super);
    function ParticleSegmentedColorState(animator, particleSegmentedColorNode) {
        var _this = _super.call(this, animator, particleSegmentedColorNode) || this;
        _this._usesMultiplier = particleSegmentedColorNode._iUsesMultiplier;
        _this._usesOffset = particleSegmentedColorNode._iUsesOffset;
        _this._startColor = particleSegmentedColorNode._iStartColor;
        _this._endColor = particleSegmentedColorNode._iEndColor;
        _this._segmentPoints = particleSegmentedColorNode._iSegmentPoints;
        _this._numSegmentPoint = particleSegmentedColorNode._iNumSegmentPoint;
        _this.updateColorData();
        return _this;
    }
    Object.defineProperty(ParticleSegmentedColorState.prototype, "startColor", {
        /**
         * Defines the start color transform of the state, when in global mode.
         */
        get: function () {
            return this._startColor;
        },
        set: function (value) {
            this._startColor = value;
            this.updateColorData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSegmentedColorState.prototype, "endColor", {
        /**
         * Defines the end color transform of the state, when in global mode.
         */
        get: function () {
            return this._endColor;
        },
        set: function (value) {
            this._endColor = value;
            this.updateColorData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSegmentedColorState.prototype, "numSegmentPoint", {
        /**
         * Defines the number of segments.
         */
        get: function () {
            return this._numSegmentPoint;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSegmentedColorState.prototype, "segmentPoints", {
        /**
         * Defines the key points of color
         */
        get: function () {
            return this._segmentPoints;
        },
        set: function (value) {
            this._segmentPoints = value;
            this.updateColorData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSegmentedColorState.prototype, "usesMultiplier", {
        get: function () {
            return this._usesMultiplier;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSegmentedColorState.prototype, "usesOffset", {
        get: function () {
            return this._usesOffset;
        },
        enumerable: true,
        configurable: true
    });
    ParticleSegmentedColorState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (shader.usesFragmentAnimation) {
            if (this._numSegmentPoint > 0)
                shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSegmentedColorState.TIME_DATA_INDEX), this._timeLifeData[0], this._timeLifeData[1], this._timeLifeData[2], this._timeLifeData[3]);
            if (this._usesMultiplier)
                shader.setVertexConstFromArray(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSegmentedColorState.START_MULTIPLIER_INDEX), this._multiplierData);
            if (this._usesOffset)
                shader.setVertexConstFromArray(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSegmentedColorState.START_OFFSET_INDEX), this._offsetData);
        }
    };
    ParticleSegmentedColorState.prototype.updateColorData = function () {
        this._timeLifeData = new Float32Array(4);
        this._multiplierData = new Float32Array(4 * (this._numSegmentPoint + 1));
        this._offsetData = new Float32Array(4 * (this._numSegmentPoint + 1));
        //cut off the time data
        var i;
        var j = 0;
        var count = this._numSegmentPoint > 3 ? 3 : this._numSegmentPoint;
        for (i = 0; i < count; i++) {
            if (i == 0)
                this._timeLifeData[j++] = this._segmentPoints[i].life;
            else
                this._timeLifeData[j++] = this._segmentPoints[i].life - this._segmentPoints[i - 1].life;
        }
        i = count;
        if (this._numSegmentPoint == 0)
            this._timeLifeData[j++] = 1;
        else
            this._timeLifeData[j++] = 1 - this._segmentPoints[i - 1].life;
        if (this._usesMultiplier) {
            j = 0;
            this._multiplierData[j++] = this._startColor.redMultiplier;
            this._multiplierData[j++] = this._startColor.greenMultiplier;
            this._multiplierData[j++] = this._startColor.blueMultiplier;
            this._multiplierData[j++] = this._startColor.alphaMultiplier;
            for (i = 0; i < this._numSegmentPoint; i++) {
                if (i == 0) {
                    this._multiplierData[j++] = (this._segmentPoints[i].color.redMultiplier - this._startColor.redMultiplier) / this._timeLifeData[i];
                    this._multiplierData[j++] = (this._segmentPoints[i].color.greenMultiplier - this._startColor.greenMultiplier) / this._timeLifeData[i];
                    this._multiplierData[j++] = (this._segmentPoints[i].color.blueMultiplier - this._startColor.blueMultiplier) / this._timeLifeData[i];
                    this._multiplierData[j++] = (this._segmentPoints[i].color.alphaMultiplier - this._startColor.alphaMultiplier) / this._timeLifeData[i];
                }
                else {
                    this._multiplierData[j++] = (this._segmentPoints[i].color.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i];
                    this._multiplierData[j++] = (this._segmentPoints[i].color.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i];
                    this._multiplierData[j++] = (this._segmentPoints[i].color.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i];
                    this._multiplierData[j++] = (this._segmentPoints[i].color.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i];
                }
            }
            i = this._numSegmentPoint;
            if (this._numSegmentPoint == 0) {
                this._multiplierData[j++] = this._endColor.redMultiplier - this._startColor.redMultiplier;
                this._multiplierData[j++] = this._endColor.greenMultiplier - this._startColor.greenMultiplier;
                this._multiplierData[j++] = this._endColor.blueMultiplier - this._startColor.blueMultiplier;
                this._multiplierData[j++] = this._endColor.alphaMultiplier - this._startColor.alphaMultiplier;
            }
            else {
                this._multiplierData[j++] = (this._endColor.redMultiplier - this._segmentPoints[i - 1].color.redMultiplier) / this._timeLifeData[i];
                this._multiplierData[j++] = (this._endColor.greenMultiplier - this._segmentPoints[i - 1].color.greenMultiplier) / this._timeLifeData[i];
                this._multiplierData[j++] = (this._endColor.blueMultiplier - this._segmentPoints[i - 1].color.blueMultiplier) / this._timeLifeData[i];
                this._multiplierData[j++] = (this._endColor.alphaMultiplier - this._segmentPoints[i - 1].color.alphaMultiplier) / this._timeLifeData[i];
            }
        }
        if (this._usesOffset) {
            j = 0;
            this._offsetData[j++] = this._startColor.redOffset / 255;
            this._offsetData[j++] = this._startColor.greenOffset / 255;
            this._offsetData[j++] = this._startColor.blueOffset / 255;
            this._offsetData[j++] = this._startColor.alphaOffset / 255;
            for (i = 0; i < this._numSegmentPoint; i++) {
                if (i == 0) {
                    this._offsetData[j++] = (this._segmentPoints[i].color.redOffset - this._startColor.redOffset) / this._timeLifeData[i] / 255;
                    this._offsetData[j++] = (this._segmentPoints[i].color.greenOffset - this._startColor.greenOffset) / this._timeLifeData[i] / 255;
                    this._offsetData[j++] = (this._segmentPoints[i].color.blueOffset - this._startColor.blueOffset) / this._timeLifeData[i] / 255;
                    this._offsetData[j++] = (this._segmentPoints[i].color.alphaOffset - this._startColor.alphaOffset) / this._timeLifeData[i] / 255;
                }
                else {
                    this._offsetData[j++] = (this._segmentPoints[i].color.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255;
                    this._offsetData[j++] = (this._segmentPoints[i].color.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255;
                    this._offsetData[j++] = (this._segmentPoints[i].color.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255;
                    this._offsetData[j++] = (this._segmentPoints[i].color.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255;
                }
            }
            i = this._numSegmentPoint;
            if (this._numSegmentPoint == 0) {
                this._offsetData[j++] = (this._endColor.redOffset - this._startColor.redOffset) / 255;
                this._offsetData[j++] = (this._endColor.greenOffset - this._startColor.greenOffset) / 255;
                this._offsetData[j++] = (this._endColor.blueOffset - this._startColor.blueOffset) / 255;
                this._offsetData[j++] = (this._endColor.alphaOffset - this._startColor.alphaOffset) / 255;
            }
            else {
                this._offsetData[i] = (this._endColor.redOffset - this._segmentPoints[i - 1].color.redOffset) / this._timeLifeData[i] / 255;
                this._offsetData[j++] = (this._endColor.greenOffset - this._segmentPoints[i - 1].color.greenOffset) / this._timeLifeData[i] / 255;
                this._offsetData[j++] = (this._endColor.blueOffset - this._segmentPoints[i - 1].color.blueOffset) / this._timeLifeData[i] / 255;
                this._offsetData[j++] = (this._endColor.alphaOffset - this._segmentPoints[i - 1].color.alphaOffset) / this._timeLifeData[i] / 255;
            }
        }
    };
    return ParticleSegmentedColorState;
}(ParticleStateBase));
/** @private */
ParticleSegmentedColorState.START_MULTIPLIER_INDEX = 0;
/** @private */
ParticleSegmentedColorState.START_OFFSET_INDEX = 1;
/** @private */
ParticleSegmentedColorState.TIME_DATA_INDEX = 2;

/**
 *
 */
var ParticleSegmentedColorNode = (function (_super) {
    __extends(ParticleSegmentedColorNode, _super);
    function ParticleSegmentedColorNode(usesMultiplier, usesOffset, numSegmentPoint, startColor, endColor, segmentPoints) {
        var _this = 
        //because of the stage3d register limitation, it only support the global mode
        _super.call(this, "ParticleSegmentedColor", ParticlePropertiesMode.GLOBAL, 0, ParticleAnimationSet.COLOR_PRIORITY) || this;
        _this._pStateClass = ParticleSegmentedColorState;
        if (numSegmentPoint > 4)
            throw (new Error("the numSegmentPoint must be less or equal 4"));
        _this._iUsesMultiplier = usesMultiplier;
        _this._iUsesOffset = usesOffset;
        _this._iNumSegmentPoint = numSegmentPoint;
        _this._iStartColor = startColor;
        _this._iEndColor = endColor;
        _this._iSegmentPoints = segmentPoints;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleSegmentedColorNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
        if (this._iUsesMultiplier)
            particleAnimationSet.hasColorMulNode = true;
        if (this._iUsesOffset)
            particleAnimationSet.hasColorAddNode = true;
    };
    /**
     * @inheritDoc
     */
    ParticleSegmentedColorNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var code = "";
        if (shader.usesFragmentAnimation) {
            var accMultiplierColor;
            //var accOffsetColor:ShaderRegisterElement;
            if (this._iUsesMultiplier) {
                accMultiplierColor = registerCache.getFreeVertexVectorTemp();
                registerCache.addVertexTempUsages(accMultiplierColor, 1);
            }
            var tempColor = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(tempColor, 1);
            var temp = registerCache.getFreeVertexVectorTemp();
            var accTime = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 0);
            var tempTime = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 1);
            if (this._iUsesMultiplier)
                registerCache.removeVertexTempUsage(accMultiplierColor);
            registerCache.removeVertexTempUsage(tempColor);
            //for saving all the life values (at most 4)
            var lifeTimeRegister = registerCache.getFreeVertexConstant();
            animationRegisterData.setRegisterIndex(this, ParticleSegmentedColorState.TIME_DATA_INDEX, lifeTimeRegister.index);
            var i;
            var startMulValue;
            var deltaMulValues;
            if (this._iUsesMultiplier) {
                startMulValue = registerCache.getFreeVertexConstant();
                animationRegisterData.setRegisterIndex(this, ParticleSegmentedColorState.START_MULTIPLIER_INDEX, startMulValue.index);
                deltaMulValues = new Array();
                for (i = 0; i < this._iNumSegmentPoint + 1; i++)
                    deltaMulValues.push(registerCache.getFreeVertexConstant());
            }
            var startOffsetValue;
            var deltaOffsetValues;
            if (this._iUsesOffset) {
                startOffsetValue = registerCache.getFreeVertexConstant();
                animationRegisterData.setRegisterIndex(this, ParticleSegmentedColorState.START_OFFSET_INDEX, startOffsetValue.index);
                deltaOffsetValues = new Array();
                for (i = 0; i < this._iNumSegmentPoint + 1; i++)
                    deltaOffsetValues.push(registerCache.getFreeVertexConstant());
            }
            if (this._iUsesMultiplier)
                code += "mov " + accMultiplierColor + "," + startMulValue + "\n";
            if (this._iUsesOffset)
                code += "add " + animationRegisterData.colorAddTarget + "," + animationRegisterData.colorAddTarget + "," + startOffsetValue + "\n";
            for (i = 0; i < this._iNumSegmentPoint; i++) {
                switch (i) {
                    case 0:
                        code += "min " + tempTime + "," + animationRegisterData.vertexLife + "," + lifeTimeRegister + ".x\n";
                        break;
                    case 1:
                        code += "sub " + accTime + "," + animationRegisterData.vertexLife + "," + lifeTimeRegister + ".x\n";
                        code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
                        code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".y\n";
                        break;
                    case 2:
                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
                        code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
                        code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".z\n";
                        break;
                    case 3:
                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
                        code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
                        code += "min " + tempTime + "," + tempTime + "," + lifeTimeRegister + ".w\n";
                        break;
                }
                if (this._iUsesMultiplier) {
                    code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[i] + "\n";
                    code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
                }
                if (this._iUsesOffset) {
                    code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[i] + "\n";
                    code += "add " + animationRegisterData.colorAddTarget + "," + animationRegisterData.colorAddTarget + "," + tempColor + "\n";
                }
            }
            //for the last segment:
            if (this._iNumSegmentPoint == 0)
                tempTime = animationRegisterData.vertexLife;
            else {
                switch (this._iNumSegmentPoint) {
                    case 1:
                        code += "sub " + accTime + "," + animationRegisterData.vertexLife + "," + lifeTimeRegister + ".x\n";
                        break;
                    case 2:
                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".y\n";
                        break;
                    case 3:
                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".z\n";
                        break;
                    case 4:
                        code += "sub " + accTime + "," + accTime + "," + lifeTimeRegister + ".w\n";
                        break;
                }
                code += "max " + tempTime + "," + accTime + "," + animationRegisterData.vertexZeroConst + "\n";
            }
            if (this._iUsesMultiplier) {
                code += "mul " + tempColor + "," + tempTime + "," + deltaMulValues[this._iNumSegmentPoint] + "\n";
                code += "add " + accMultiplierColor + "," + accMultiplierColor + "," + tempColor + "\n";
                code += "mul " + animationRegisterData.colorMulTarget + "," + animationRegisterData.colorMulTarget + "," + accMultiplierColor + "\n";
            }
            if (this._iUsesOffset) {
                code += "mul " + tempColor + "," + tempTime + "," + deltaOffsetValues[this._iNumSegmentPoint] + "\n";
                code += "add " + animationRegisterData.colorAddTarget + "," + animationRegisterData.colorAddTarget + "," + tempColor + "\n";
            }
        }
        return code;
    };
    return ParticleSegmentedColorNode;
}(ParticleNodeBase));

/**
 * ...
 */
var ParticleSpriteSheetState = (function (_super) {
    __extends(ParticleSpriteSheetState, _super);
    function ParticleSpriteSheetState(animator, particleSpriteSheetNode) {
        var _this = _super.call(this, animator, particleSpriteSheetNode) || this;
        _this._particleSpriteSheetNode = particleSpriteSheetNode;
        _this._usesCycle = _this._particleSpriteSheetNode._iUsesCycle;
        _this._usesPhase = _this._particleSpriteSheetNode._iUsesCycle;
        _this._totalFrames = _this._particleSpriteSheetNode._iTotalFrames;
        _this._numColumns = _this._particleSpriteSheetNode._iNumColumns;
        _this._numRows = _this._particleSpriteSheetNode._iNumRows;
        _this._cycleDuration = _this._particleSpriteSheetNode._iCycleDuration;
        _this._cyclePhase = _this._particleSpriteSheetNode._iCyclePhase;
        _this.updateSpriteSheetData();
        return _this;
    }
    Object.defineProperty(ParticleSpriteSheetState.prototype, "cyclePhase", {
        /**
         * Defines the cycle phase, when in global mode. Defaults to zero.
         */
        get: function () {
            return this._cyclePhase;
        },
        set: function (value) {
            this._cyclePhase = value;
            this.updateSpriteSheetData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSpriteSheetState.prototype, "cycleDuration", {
        /**
         * Defines the cycle duration in seconds, when in global mode. Defaults to 1.
         */
        get: function () {
            return this._cycleDuration;
        },
        set: function (value) {
            this._cycleDuration = value;
            this.updateSpriteSheetData();
        },
        enumerable: true,
        configurable: true
    });
    ParticleSpriteSheetState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (!shader.usesUVTransform) {
            shader.setVertexConst(animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSpriteSheetState.UV_INDEX_0), this._spriteSheetData[0], this._spriteSheetData[1], this._spriteSheetData[2], this._spriteSheetData[3]);
            if (this._usesCycle) {
                var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleSpriteSheetState.UV_INDEX_1);
                if (this._particleSpriteSheetNode.mode == ParticlePropertiesMode.LOCAL_STATIC) {
                    if (this._usesPhase)
                        animationElements.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
                    else
                        animationElements.activateVertexBuffer(index, this._particleSpriteSheetNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_2);
                }
                else
                    shader.setVertexConst(index, this._spriteSheetData[4], this._spriteSheetData[5]);
            }
        }
    };
    ParticleSpriteSheetState.prototype.updateSpriteSheetData = function () {
        this._spriteSheetData = new Array(8);
        var uTotal = this._totalFrames / this._numColumns;
        this._spriteSheetData[0] = uTotal;
        this._spriteSheetData[1] = 1 / this._numColumns;
        this._spriteSheetData[2] = 1 / this._numRows;
        if (this._usesCycle) {
            if (this._cycleDuration <= 0)
                throw (new Error("the cycle duration must be greater than zero"));
            this._spriteSheetData[4] = uTotal / this._cycleDuration;
            this._spriteSheetData[5] = this._cycleDuration;
            if (this._usesPhase)
                this._spriteSheetData[6] = this._cyclePhase;
        }
    };
    return ParticleSpriteSheetState;
}(ParticleStateBase));
/** @private */
ParticleSpriteSheetState.UV_INDEX_0 = 0;
/** @private */
ParticleSpriteSheetState.UV_INDEX_1 = 1;

/**
 * A particle animation node used when a spritesheet texture is required to animate the particle.
 * NB: to enable use of this node, the <code>repeat</code> property on the material has to be set to true.
 */
var ParticleSpriteSheetNode = (function (_super) {
    __extends(ParticleSpriteSheetNode, _super);
    /**
     * Creates a new <code>ParticleSpriteSheetNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] numColumns      Defines the number of columns in the spritesheet, when in global mode. Defaults to 1.
     * @param    [optional] numRows         Defines the number of rows in the spritesheet, when in global mode. Defaults to 1.
     * @param    [optional] cycleDuration   Defines the default cycle duration in seconds, when in global mode. Defaults to 1.
     * @param    [optional] cyclePhase      Defines the default cycle phase, when in global mode. Defaults to 0.
     * @param    [optional] totalFrames     Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows.
     * @param    [optional] looping         Defines whether the spritesheet animation is set to loop indefinitely. Defaults to true.
     */
    function ParticleSpriteSheetNode(mode, usesCycle, usesPhase, numColumns, numRows, cycleDuration, cyclePhase, totalFrames) {
        if (numColumns === void 0) { numColumns = 1; }
        if (numRows === void 0) { numRows = 1; }
        if (cycleDuration === void 0) { cycleDuration = 1; }
        if (cyclePhase === void 0) { cyclePhase = 0; }
        if (totalFrames === void 0) { totalFrames = Number.MAX_VALUE; }
        var _this = _super.call(this, "ParticleSpriteSheet", mode, usesCycle ? (usesPhase ? 3 : 2) : 1, ParticleAnimationSet.POST_PRIORITY + 1) || this;
        _this._pStateClass = ParticleSpriteSheetState;
        _this._iUsesCycle = usesCycle;
        _this._iUsesPhase = usesPhase;
        _this._iNumColumns = numColumns;
        _this._iNumRows = numRows;
        _this._iCyclePhase = cyclePhase;
        _this._iCycleDuration = cycleDuration;
        _this._iTotalFrames = Math.min(totalFrames, numColumns * numRows);
        return _this;
    }
    Object.defineProperty(ParticleSpriteSheetNode.prototype, "numColumns", {
        /**
         * Defines the number of columns in the spritesheet, when in global mode. Defaults to 1. Read only.
         */
        get: function () {
            return this._iNumColumns;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSpriteSheetNode.prototype, "numRows", {
        /**
         * Defines the number of rows in the spritesheet, when in global mode. Defaults to 1. Read only.
         */
        get: function () {
            return this._iNumRows;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleSpriteSheetNode.prototype, "totalFrames", {
        /**
         * Defines the total number of frames used by the spritesheet, when in global mode. Defaults to the number defined by numColumns and numRows. Read only.
         */
        get: function () {
            return this._iTotalFrames;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleSpriteSheetNode.prototype.getAGALUVCode = function (shader, animationSet, registerCache, animationRegisterData) {
        //get 2 vc
        var uvParamConst1 = registerCache.getFreeVertexConstant();
        var uvParamConst2 = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleSpriteSheetState.UV_INDEX_0, uvParamConst1.index);
        animationRegisterData.setRegisterIndex(this, ParticleSpriteSheetState.UV_INDEX_1, uvParamConst2.index);
        var uTotal = new _awayjs_stage.ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 0);
        var uStep = new _awayjs_stage.ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 1);
        var vStep = new _awayjs_stage.ShaderRegisterElement(uvParamConst1.regName, uvParamConst1.index, 2);
        var uSpeed = new _awayjs_stage.ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 0);
        var cycle = new _awayjs_stage.ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 1);
        var phaseTime = new _awayjs_stage.ShaderRegisterElement(uvParamConst2.regName, uvParamConst2.index, 2);
        var temp = registerCache.getFreeVertexVectorTemp();
        var time = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 0);
        var vOffset = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 1);
        temp = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 2);
        var temp2 = new _awayjs_stage.ShaderRegisterElement(temp.regName, temp.index, 3);
        var u = new _awayjs_stage.ShaderRegisterElement(animationRegisterData.uvTarget.regName, animationRegisterData.uvTarget.index, 0);
        var v = new _awayjs_stage.ShaderRegisterElement(animationRegisterData.uvTarget.regName, animationRegisterData.uvTarget.index, 1);
        var code = "";
        //scale uv
        code += "mul " + u + "," + u + "," + uStep + "\n";
        if (this._iNumRows > 1)
            code += "mul " + v + "," + v + "," + vStep + "\n";
        if (this._iUsesCycle) {
            if (this._iUsesPhase)
                code += "add " + time + "," + animationRegisterData.vertexTime + "," + phaseTime + "\n";
            else
                code += "mov " + time + "," + animationRegisterData.vertexTime + "\n";
            code += "div " + time + "," + time + "," + cycle + "\n";
            code += "frc " + time + "," + time + "\n";
            code += "mul " + time + "," + time + "," + cycle + "\n";
            code += "mul " + temp + "," + time + "," + uSpeed + "\n";
        }
        else
            code += "mul " + temp.toString() + "," + animationRegisterData.vertexLife + "," + uTotal + "\n";
        if (this._iNumRows > 1) {
            code += "frc " + temp2 + "," + temp + "\n";
            code += "sub " + vOffset + "," + temp + "," + temp2 + "\n";
            code += "mul " + vOffset + "," + vOffset + "," + vStep + "\n";
            code += "add " + v + "," + v + "," + vOffset + "\n";
        }
        code += "div " + temp2 + "," + temp + "," + uStep + "\n";
        code += "frc " + temp + "," + temp2 + "\n";
        code += "sub " + temp2 + "," + temp2 + "," + temp + "\n";
        code += "mul " + temp + "," + temp2 + "," + uStep + "\n";
        if (this._iNumRows > 1)
            code += "frc " + temp + "," + temp + "\n";
        code += "add " + u + "," + u + "," + temp + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleSpriteSheetNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleSpriteSheetNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
        particleAnimationSet.hasUVNode = true;
    };
    /**
     * @inheritDoc
     */
    ParticleSpriteSheetNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        if (this._iUsesCycle) {
            var uvCycle = param[ParticleSpriteSheetNode.UV_VECTOR3D];
            if (!uvCycle)
                throw (new Error("there is no " + ParticleSpriteSheetNode.UV_VECTOR3D + " in param!"));
            if (uvCycle.x <= 0)
                throw (new Error("the cycle duration must be greater than zero"));
            var uTotal = this._iTotalFrames / this._iNumColumns;
            this._pOneData[0] = uTotal / uvCycle.x;
            this._pOneData[1] = uvCycle.x;
            if (this._iUsesPhase)
                this._pOneData[2] = uvCycle.y;
        }
    };
    return ParticleSpriteSheetNode;
}(ParticleNodeBase));
/**
 * Reference for spritesheet node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> representing the cycleDuration (x), optional phaseTime (y).
 */
ParticleSpriteSheetNode.UV_VECTOR3D = "UVVector3D";

/**
 * ...
 */
var ParticleUVState = (function (_super) {
    __extends(ParticleUVState, _super);
    function ParticleUVState(animator, particleUVNode) {
        var _this = _super.call(this, animator, particleUVNode) || this;
        _this._particleUVNode = particleUVNode;
        return _this;
    }
    ParticleUVState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (!shader.usesUVTransform) {
            var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleUVState.UV_INDEX);
            var data = this._particleUVNode._iUvData;
            shader.setVertexConst(index, data.x, data.y);
        }
    };
    return ParticleUVState;
}(ParticleStateBase));
/** @private */
ParticleUVState.UV_INDEX = 0;

/**
 * A particle animation node used to control the UV offset and scale of a particle over time.
 */
var ParticleUVNode = (function (_super) {
    __extends(ParticleUVNode, _super);
    /**
     * Creates a new <code>ParticleTimeNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] cycle           Defines whether the time track is in loop mode. Defaults to false.
     * @param    [optional] scale           Defines whether the time track is in loop mode. Defaults to false.
     * @param    [optional] axis            Defines whether the time track is in loop mode. Defaults to false.
     */
    function ParticleUVNode(mode, cycle, scale, axis) {
        if (cycle === void 0) { cycle = 1; }
        if (scale === void 0) { scale = 1; }
        if (axis === void 0) { axis = "x"; }
        var _this = 
        //because of the stage3d register limitation, it only support the global mode
        _super.call(this, "ParticleUV", ParticlePropertiesMode.GLOBAL, 4, ParticleAnimationSet.POST_PRIORITY + 1) || this;
        _this._pStateClass = ParticleUVState;
        _this._cycle = cycle;
        _this._scale = scale;
        _this._axis = axis;
        _this.updateUVData();
        return _this;
    }
    Object.defineProperty(ParticleUVNode.prototype, "cycle", {
        /**
         *
         */
        get: function () {
            return this._cycle;
        },
        set: function (value) {
            this._cycle = value;
            this.updateUVData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleUVNode.prototype, "scale", {
        /**
         *
         */
        get: function () {
            return this._scale;
        },
        set: function (value) {
            this._scale = value;
            this.updateUVData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleUVNode.prototype, "axis", {
        /**
         *
         */
        get: function () {
            return this._axis;
        },
        set: function (value) {
            this._axis = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ParticleUVNode.prototype.getAGALUVCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var code = "";
        var uvConst = registerCache.getFreeVertexConstant();
        animationRegisterData.setRegisterIndex(this, ParticleUVState.UV_INDEX, uvConst.index);
        var axisIndex = this._axis == "x" ? 0 : (this._axis == "y" ? 1 : 2);
        var target = new _awayjs_stage.ShaderRegisterElement(animationRegisterData.uvTarget.regName, animationRegisterData.uvTarget.index, axisIndex);
        var sin = registerCache.getFreeVertexSingleTemp();
        if (this._scale != 1)
            code += "mul " + target + "," + target + "," + uvConst + ".y\n";
        code += "mul " + sin + "," + animationRegisterData.vertexTime + "," + uvConst + ".x\n";
        code += "sin " + sin + "," + sin + "\n";
        code += "add " + target + "," + target + "," + sin + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleUVNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    ParticleUVNode.prototype.updateUVData = function () {
        this._iUvData = new _awayjs_core.Vector3D(Math.PI * 2 / this._cycle, this._scale, 0, 0);
    };
    /**
     * @inheritDoc
     */
    ParticleUVNode.prototype._iProcessAnimationSetting = function (particleAnimationSet) {
        particleAnimationSet.hasUVNode = true;
    };
    return ParticleUVNode;
}(ParticleNodeBase));
/**
 *
 */
ParticleUVNode.U_AXIS = "x";
/**
 *
 */
ParticleUVNode.V_AXIS = "y";

/**
 * ...
 */
var ParticleVelocityState = (function (_super) {
    __extends(ParticleVelocityState, _super);
    function ParticleVelocityState(animator, particleVelocityNode) {
        var _this = _super.call(this, animator, particleVelocityNode) || this;
        _this._particleVelocityNode = particleVelocityNode;
        _this._velocity = _this._particleVelocityNode._iVelocity;
        return _this;
    }
    Object.defineProperty(ParticleVelocityState.prototype, "velocity", {
        /**
         * Defines the default velocity vector of the state, used when in global mode.
         */
        get: function () {
            return this._velocity;
        },
        set: function (value) {
            this._velocity = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    ParticleVelocityState.prototype.getVelocities = function () {
        return this._pDynamicProperties;
    };
    ParticleVelocityState.prototype.setVelocities = function (value) {
        this._pDynamicProperties = value;
        this._pDynamicPropertiesDirty = new Object();
    };
    ParticleVelocityState.prototype.setRenderState = function (shader, renderable, animationElements, animationRegisterData, projection, stage) {
        if (this._particleVelocityNode.mode == ParticlePropertiesMode.LOCAL_DYNAMIC && !this._pDynamicPropertiesDirty[animationElements._iUniqueId])
            this._pUpdateDynamicProperties(animationElements);
        var index = animationRegisterData.getRegisterIndex(this._pAnimationNode, ParticleVelocityState.VELOCITY_INDEX);
        if (this._particleVelocityNode.mode == ParticlePropertiesMode.GLOBAL)
            shader.setVertexConst(index, this._velocity.x, this._velocity.y, this._velocity.z);
        else
            animationElements.activateVertexBuffer(index, this._particleVelocityNode._iDataOffset, stage, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_3);
    };
    return ParticleVelocityState;
}(ParticleStateBase));
/** @private */
ParticleVelocityState.VELOCITY_INDEX = 0;

/**
 * A particle animation node used to set the starting velocity of a particle.
 */
var ParticleVelocityNode = (function (_super) {
    __extends(ParticleVelocityNode, _super);
    /**
     * Creates a new <code>ParticleVelocityNode</code>
     *
     * @param               mode            Defines whether the mode of operation acts on local properties of a particle or global properties of the node.
     * @param    [optional] velocity        Defines the default velocity vector of the node, used when in global mode.
     */
    function ParticleVelocityNode(mode, velocity) {
        if (velocity === void 0) { velocity = null; }
        var _this = _super.call(this, "ParticleVelocity", mode, 3) || this;
        _this._pStateClass = ParticleVelocityState;
        _this._iVelocity = velocity || new _awayjs_core.Vector3D();
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleVelocityNode.prototype.getAGALVertexCode = function (shader, animationSet, registerCache, animationRegisterData) {
        var velocityValue = (this._pMode == ParticlePropertiesMode.GLOBAL) ? registerCache.getFreeVertexConstant() : registerCache.getFreeVertexAttribute();
        animationRegisterData.setRegisterIndex(this, ParticleVelocityState.VELOCITY_INDEX, velocityValue.index);
        var distance = registerCache.getFreeVertexVectorTemp();
        var code = "";
        code += "mul " + distance + "," + animationRegisterData.vertexTime + "," + velocityValue + "\n";
        code += "add " + animationRegisterData.positionTarget + ".xyz," + distance + "," + animationRegisterData.positionTarget + ".xyz\n";
        if (animationSet.needVelocity)
            code += "add " + animationRegisterData.velocityTarget + ".xyz," + velocityValue + ".xyz," + animationRegisterData.velocityTarget + ".xyz\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ParticleVelocityNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    ParticleVelocityNode.prototype._iGeneratePropertyOfOneParticle = function (param) {
        var _tempVelocity = param[ParticleVelocityNode.VELOCITY_VECTOR3D];
        if (!_tempVelocity)
            throw new Error("there is no " + ParticleVelocityNode.VELOCITY_VECTOR3D + " in param!");
        this._pOneData[0] = _tempVelocity.x;
        this._pOneData[1] = _tempVelocity.y;
        this._pOneData[2] = _tempVelocity.z;
    };
    return ParticleVelocityNode;
}(ParticleNodeBase));
/**
 * Reference for velocity node properties on a single particle (when in local property mode).
 * Expects a <code>Vector3D</code> object representing the direction of movement on the particle.
 */
ParticleVelocityNode.VELOCITY_VECTOR3D = "VelocityVector3D";

/**
 *
 */
var SkeletonBinaryLERPState = (function (_super) {
    __extends(SkeletonBinaryLERPState, _super);
    function SkeletonBinaryLERPState(animator, skeletonAnimationNode) {
        var _this = _super.call(this, animator, skeletonAnimationNode) || this;
        _this._blendWeight = 0;
        _this._skeletonPose = new SkeletonPose();
        _this._skeletonPoseDirty = true;
        _this._skeletonAnimationNode = skeletonAnimationNode;
        _this._inputA = animator.getAnimationState(_this._skeletonAnimationNode.inputA);
        _this._inputB = animator.getAnimationState(_this._skeletonAnimationNode.inputB);
        return _this;
    }
    Object.defineProperty(SkeletonBinaryLERPState.prototype, "blendWeight", {
        /**
         * Defines a fractional value between 0 and 1 representing the blending ratio between inputA (0) and inputB (1),
         * used to produce the skeleton pose output.
         *
         * @see inputA
         * @see inputB
         */
        get: function () {
            return this._blendWeight;
        },
        set: function (value) {
            this._blendWeight = value;
            this._pPositionDeltaDirty = true;
            this._skeletonPoseDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    SkeletonBinaryLERPState.prototype.phase = function (value) {
        this._skeletonPoseDirty = true;
        this._pPositionDeltaDirty = true;
        this._inputA.phase(value);
        this._inputB.phase(value);
    };
    /**
     * @inheritDoc
     */
    SkeletonBinaryLERPState.prototype._pUpdateTime = function (time) {
        this._skeletonPoseDirty = true;
        this._inputA.update(time);
        this._inputB.update(time);
        _super.prototype._pUpdateTime.call(this, time);
    };
    /**
     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
     */
    SkeletonBinaryLERPState.prototype.getSkeletonPose = function (skeleton) {
        if (this._skeletonPoseDirty)
            this.updateSkeletonPose(skeleton);
        return this._skeletonPose;
    };
    /**
     * @inheritDoc
     */
    SkeletonBinaryLERPState.prototype._pUpdatePositionDelta = function () {
        this._pPositionDeltaDirty = false;
        var deltA = this._inputA.positionDelta;
        var deltB = this._inputB.positionDelta;
        this._pRootDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
        this._pRootDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
        this._pRootDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
    };
    /**
     * Updates the output skeleton pose of the node based on the blendWeight value between input nodes.
     *
     * @param skeleton The skeleton used by the animator requesting the ouput pose.
     */
    SkeletonBinaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
        this._skeletonPoseDirty = false;
        var endPose;
        var endPoses = this._skeletonPose.jointPoses;
        var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
        var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
        var pose1, pose2;
        var p1, p2;
        var tr;
        var numJoints = skeleton.numJoints;
        // :s
        if (endPoses.length != numJoints)
            endPoses.length = numJoints;
        for (var i = 0; i < numJoints; ++i) {
            endPose = endPoses[i];
            if (endPose == null)
                endPose = endPoses[i] = new JointPose();
            pose1 = poses1[i];
            pose2 = poses2[i];
            p1 = pose1.translation;
            p2 = pose2.translation;
            endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);
            tr = endPose.translation;
            tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
            tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
            tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
        }
    };
    return SkeletonBinaryLERPState;
}(AnimationStateBase));

/**
 * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
 */
var SkeletonBinaryLERPNode = (function (_super) {
    __extends(SkeletonBinaryLERPNode, _super);
    /**
     * Creates a new <code>SkeletonBinaryLERPNode</code> object.
     */
    function SkeletonBinaryLERPNode() {
        var _this = _super.call(this) || this;
        _this._pStateClass = SkeletonBinaryLERPState;
        return _this;
    }
    /**
     * @inheritDoc
     */
    SkeletonBinaryLERPNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    return SkeletonBinaryLERPNode;
}(_awayjs_graphics.AnimationNodeBase));

/**
 * Dispatched to notify changes in an animation state's state.
 */
var AnimationStateEvent = (function (_super) {
    __extends(AnimationStateEvent, _super);
    /**
     * Create a new <code>AnimatonStateEvent</code>
     *
     * @param type The event type.
     * @param animator The animation state object that is the subject of this event.
     * @param animationNode The animation node inside the animation state from which the event originated.
     */
    function AnimationStateEvent(type, animator, animationState, animationNode) {
        var _this = _super.call(this, type) || this;
        _this._animator = animator;
        _this._animationState = animationState;
        _this._animationNode = animationNode;
        return _this;
    }
    Object.defineProperty(AnimationStateEvent.prototype, "animator", {
        /**
         * The animator object that is the subject of this event.
         */
        get: function () {
            return this._animator;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationStateEvent.prototype, "animationState", {
        /**
         * The animation state object that is the subject of this event.
         */
        get: function () {
            return this._animationState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationStateEvent.prototype, "animationNode", {
        /**
         * The animation node inside the animation state from which the event originated.
         */
        get: function () {
            return this._animationNode;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current object.
     */
    AnimationStateEvent.prototype.clone = function () {
        return new AnimationStateEvent(this.type, this._animator, this._animationState, this._animationNode);
    };
    return AnimationStateEvent;
}(_awayjs_core.EventBase));
/**
 * Dispatched when a non-looping clip node inside an animation state reaches the end of its timeline.
 */
AnimationStateEvent.PLAYBACK_COMPLETE = "playbackComplete";
AnimationStateEvent.TRANSITION_COMPLETE = "transitionComplete";

/**
 *
 */
var AnimationClipState = (function (_super) {
    __extends(AnimationClipState, _super);
    function AnimationClipState(animator, animationClipNode) {
        var _this = _super.call(this, animator, animationClipNode) || this;
        _this._pFramesDirty = true;
        _this._animationClipNode = animationClipNode;
        return _this;
    }
    Object.defineProperty(AnimationClipState.prototype, "blendWeight", {
        /**
         * Returns a fractional value between 0 and 1 representing the blending ratio of the current playhead position
         * between the current frame (0) and next frame (1) of the animation.
         *
         * @see #currentFrame
         * @see #nextFrame
         */
        get: function () {
            if (this._pFramesDirty)
                this._pUpdateFrames();
            return this._pBlendWeight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationClipState.prototype, "currentFrame", {
        /**
         * Returns the current frame of animation in the clip based on the internal playhead position.
         */
        get: function () {
            if (this._pFramesDirty)
                this._pUpdateFrames();
            return this._pCurrentFrame;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationClipState.prototype, "nextFrame", {
        /**
         * Returns the next frame of animation in the clip based on the internal playhead position.
         */
        get: function () {
            if (this._pFramesDirty)
                this._pUpdateFrames();
            return this._pNextFrame;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    AnimationClipState.prototype.update = function (time) {
        if (!this._animationClipNode.looping) {
            if (time > this._pStartTime + this._animationClipNode.totalDuration)
                time = this._pStartTime + this._animationClipNode.totalDuration;
            else if (time < this._pStartTime)
                time = this._pStartTime;
        }
        if (this._pTime == time - this._pStartTime)
            return;
        this._pUpdateTime(time);
    };
    /**
     * @inheritDoc
     */
    AnimationClipState.prototype.phase = function (value) {
        var time = value * this._animationClipNode.totalDuration + this._pStartTime;
        if (this._pTime == time - this._pStartTime)
            return;
        this._pUpdateTime(time);
    };
    /**
     * @inheritDoc
     */
    AnimationClipState.prototype._pUpdateTime = function (time) {
        this._pFramesDirty = true;
        this._pTimeDir = (time - this._pStartTime > this._pTime) ? 1 : -1;
        _super.prototype._pUpdateTime.call(this, time);
    };
    /**
     * Updates the nodes internal playhead to determine the current and next animation frame, and the blendWeight between the two.
     *
     * @see #currentFrame
     * @see #nextFrame
     * @see #blendWeight
     */
    AnimationClipState.prototype._pUpdateFrames = function () {
        this._pFramesDirty = false;
        var looping = this._animationClipNode.looping;
        var totalDuration = this._animationClipNode.totalDuration;
        var lastFrame = this._animationClipNode.lastFrame;
        var time = this._pTime;
        //trace("time", time, totalDuration)
        if (looping && (time >= totalDuration || time < 0)) {
            time %= totalDuration;
            if (time < 0)
                time += totalDuration;
        }
        if (!looping && time >= totalDuration) {
            this.notifyPlaybackComplete();
            this._pCurrentFrame = lastFrame;
            this._pNextFrame = lastFrame;
            this._pBlendWeight = 0;
        }
        else if (!looping && time <= 0) {
            this._pCurrentFrame = 0;
            this._pNextFrame = 0;
            this._pBlendWeight = 0;
        }
        else if (this._animationClipNode.fixedFrameRate) {
            var t = time / totalDuration * lastFrame;
            this._pCurrentFrame = Math.floor(t);
            this._pBlendWeight = t - this._pCurrentFrame;
            this._pNextFrame = this._pCurrentFrame + 1;
        }
        else {
            this._pCurrentFrame = 0;
            this._pNextFrame = 0;
            var dur = 0, frameTime;
            var durations = this._animationClipNode.durations;
            do {
                frameTime = dur;
                dur += durations[this._pNextFrame];
                this._pCurrentFrame = this._pNextFrame++;
            } while (time > dur);
            if (this._pCurrentFrame == lastFrame) {
                this._pCurrentFrame = 0;
                this._pNextFrame = 1;
            }
            this._pBlendWeight = (time - frameTime) / durations[this._pCurrentFrame];
        }
    };
    AnimationClipState.prototype.notifyPlaybackComplete = function () {
        if (this._animationStatePlaybackComplete == null)
            this._animationStatePlaybackComplete = new AnimationStateEvent(AnimationStateEvent.PLAYBACK_COMPLETE, this._pAnimator, this, this._animationClipNode);
        this._animationClipNode.dispatchEvent(this._animationStatePlaybackComplete);
    };
    return AnimationClipState;
}(AnimationStateBase));

/**
 *
 */
var SkeletonClipState = (function (_super) {
    __extends(SkeletonClipState, _super);
    function SkeletonClipState(animator, skeletonClipNode) {
        var _this = _super.call(this, animator, skeletonClipNode) || this;
        _this._rootPos = new _awayjs_core.Vector3D();
        _this._skeletonPose = new SkeletonPose();
        _this._skeletonPoseDirty = true;
        _this._skeletonClipNode = skeletonClipNode;
        _this._frames = _this._skeletonClipNode.frames;
        return _this;
    }
    Object.defineProperty(SkeletonClipState.prototype, "currentPose", {
        /**
         * Returns the current skeleton pose frame of animation in the clip based on the internal playhead position.
         */
        get: function () {
            if (this._pFramesDirty)
                this._pUpdateFrames();
            return this._currentPose;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonClipState.prototype, "nextPose", {
        /**
         * Returns the next skeleton pose frame of animation in the clip based on the internal playhead position.
         */
        get: function () {
            if (this._pFramesDirty)
                this._pUpdateFrames();
            return this._nextPose;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
     */
    SkeletonClipState.prototype.getSkeletonPose = function (skeleton) {
        if (this._skeletonPoseDirty)
            this.updateSkeletonPose(skeleton);
        return this._skeletonPose;
    };
    /**
     * @inheritDoc
     */
    SkeletonClipState.prototype._pUpdateTime = function (time) {
        this._skeletonPoseDirty = true;
        _super.prototype._pUpdateTime.call(this, time);
    };
    /**
     * @inheritDoc
     */
    SkeletonClipState.prototype._pUpdateFrames = function () {
        _super.prototype._pUpdateFrames.call(this);
        this._currentPose = this._frames[this._pCurrentFrame];
        if (this._skeletonClipNode.looping && this._pNextFrame >= this._skeletonClipNode.lastFrame) {
            this._nextPose = this._frames[0];
            this._pAnimator.dispatchCycleEvent();
        }
        else
            this._nextPose = this._frames[this._pNextFrame];
    };
    /**
     * Updates the output skeleton pose of the node based on the internal playhead position.
     *
     * @param skeleton The skeleton used by the animator requesting the ouput pose.
     */
    SkeletonClipState.prototype.updateSkeletonPose = function (skeleton) {
        this._skeletonPoseDirty = false;
        if (!this._skeletonClipNode.totalDuration)
            return;
        if (this._pFramesDirty)
            this._pUpdateFrames();
        var currentPose = this._currentPose.jointPoses;
        var nextPose = this._nextPose.jointPoses;
        var numJoints = skeleton.numJoints;
        var p1, p2;
        var pose1, pose2;
        var endPoses = this._skeletonPose.jointPoses;
        var endPose;
        var tr;
        // :s
        if (endPoses.length != numJoints)
            endPoses.length = numJoints;
        if ((numJoints != currentPose.length) || (numJoints != nextPose.length))
            throw new Error("joint counts don't match!");
        for (var i = 0; i < numJoints; ++i) {
            endPose = endPoses[i];
            if (endPose == null)
                endPose = endPoses[i] = new JointPose();
            pose1 = currentPose[i];
            pose2 = nextPose[i];
            p1 = pose1.translation;
            p2 = pose2.translation;
            if (this._skeletonClipNode.highQuality)
                endPose.orientation.slerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
            else
                endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._pBlendWeight);
            if (i > 0) {
                tr = endPose.translation;
                tr.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
                tr.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
                tr.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
            }
        }
    };
    /**
     * @inheritDoc
     */
    SkeletonClipState.prototype._pUpdatePositionDelta = function () {
        this._pPositionDeltaDirty = false;
        if (this._pFramesDirty)
            this._pUpdateFrames();
        var p1, p2, p3;
        var totalDelta = this._skeletonClipNode.totalDelta;
        // jumping back, need to reset position
        if ((this._pTimeDir > 0 && this._pNextFrame < this._pOldFrame) || (this._pTimeDir < 0 && this._pNextFrame > this._pOldFrame)) {
            this._rootPos.x -= totalDelta.x * this._pTimeDir;
            this._rootPos.y -= totalDelta.y * this._pTimeDir;
            this._rootPos.z -= totalDelta.z * this._pTimeDir;
        }
        var dx = this._rootPos.x;
        var dy = this._rootPos.y;
        var dz = this._rootPos.z;
        if (this._skeletonClipNode.stitchFinalFrame && this._pNextFrame == this._skeletonClipNode.lastFrame) {
            p1 = this._frames[0].jointPoses[0].translation;
            p2 = this._frames[1].jointPoses[0].translation;
            p3 = this._currentPose.jointPoses[0].translation;
            this._rootPos.x = p3.x + p1.x + this._pBlendWeight * (p2.x - p1.x);
            this._rootPos.y = p3.y + p1.y + this._pBlendWeight * (p2.y - p1.y);
            this._rootPos.z = p3.z + p1.z + this._pBlendWeight * (p2.z - p1.z);
        }
        else {
            p1 = this._currentPose.jointPoses[0].translation;
            p2 = this._frames[this._pNextFrame].jointPoses[0].translation; //cover the instances where we wrap the pose but still want the final frame translation values
            this._rootPos.x = p1.x + this._pBlendWeight * (p2.x - p1.x);
            this._rootPos.y = p1.y + this._pBlendWeight * (p2.y - p1.y);
            this._rootPos.z = p1.z + this._pBlendWeight * (p2.z - p1.z);
        }
        this._pRootDelta.x = this._rootPos.x - dx;
        this._pRootDelta.y = this._rootPos.y - dy;
        this._pRootDelta.z = this._rootPos.z - dz;
        this._pOldFrame = this._pNextFrame;
    };
    return SkeletonClipState;
}(AnimationClipState));

/**
 * A skeleton animation node containing time-based animation data as individual skeleton poses.
 */
var SkeletonClipNode = (function (_super) {
    __extends(SkeletonClipNode, _super);
    /**
     * Creates a new <code>SkeletonClipNode</code> object.
     */
    function SkeletonClipNode() {
        var _this = _super.call(this) || this;
        _this._frames = new Array();
        /**
         * Determines whether to use SLERP equations (true) or LERP equations (false) in the calculation
         * of the output skeleton pose. Defaults to false.
         */
        _this.highQuality = false;
        _this._pStateClass = SkeletonClipState;
        return _this;
    }
    Object.defineProperty(SkeletonClipNode.prototype, "frames", {
        /**
         * Returns a vector of skeleton poses representing the pose of each animation frame in the clip.
         */
        get: function () {
            return this._frames;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a skeleton pose frame to the internal timeline of the animation node.
     *
     * @param skeletonPose The skeleton pose object to add to the timeline of the node.
     * @param duration The specified duration of the frame in milliseconds.
     */
    SkeletonClipNode.prototype.addFrame = function (skeletonPose, duration) {
        this._frames.push(skeletonPose);
        this._pDurations.push(duration);
        this._pNumFrames = this._pDurations.length;
        this._pStitchDirty = true;
    };
    /**
     * @inheritDoc
     */
    SkeletonClipNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    /**
     * @inheritDoc
     */
    SkeletonClipNode.prototype._pUpdateStitch = function () {
        _super.prototype._pUpdateStitch.call(this);
        var i = this._pNumFrames - 1;
        var p1, p2, delta;
        while (i--) {
            this._pTotalDuration += this._pDurations[i];
            p1 = this._frames[i].jointPoses[0].translation;
            p2 = this._frames[i + 1].jointPoses[0].translation;
            delta = p2.subtract(p1);
            this._pTotalDelta.x += delta.x;
            this._pTotalDelta.y += delta.y;
            this._pTotalDelta.z += delta.z;
        }
        if (this._pStitchFinalFrame || !this._pLooping) {
            this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
            p1 = this._frames[0].jointPoses[0].translation;
            p2 = this._frames[1].jointPoses[0].translation;
            delta = p2.subtract(p1);
            this._pTotalDelta.x += delta.x;
            this._pTotalDelta.y += delta.y;
            this._pTotalDelta.z += delta.z;
        }
    };
    return SkeletonClipNode;
}(AnimationClipNodeBase));

/**
 *
 */
var SkeletonDifferenceState = (function (_super) {
    __extends(SkeletonDifferenceState, _super);
    function SkeletonDifferenceState(animator, skeletonAnimationNode) {
        var _this = _super.call(this, animator, skeletonAnimationNode) || this;
        _this._blendWeight = 0;
        _this._skeletonPose = new SkeletonPose();
        _this._skeletonPoseDirty = true;
        _this._skeletonAnimationNode = skeletonAnimationNode;
        _this._baseInput = animator.getAnimationState(_this._skeletonAnimationNode.baseInput);
        _this._differenceInput = animator.getAnimationState(_this._skeletonAnimationNode.differenceInput);
        return _this;
    }
    Object.defineProperty(SkeletonDifferenceState.prototype, "blendWeight", {
        /**
         * Defines a fractional value between 0 and 1 representing the blending ratio between the base input (0) and difference input (1),
         * used to produce the skeleton pose output.
         *
         * @see #baseInput
         * @see #differenceInput
         */
        get: function () {
            return this._blendWeight;
        },
        set: function (value) {
            this._blendWeight = value;
            this._pPositionDeltaDirty = true;
            this._skeletonPoseDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    SkeletonDifferenceState.prototype.phase = function (value) {
        this._skeletonPoseDirty = true;
        this._pPositionDeltaDirty = true;
        this._baseInput.phase(value);
        this._baseInput.phase(value);
    };
    /**
     * @inheritDoc
     */
    SkeletonDifferenceState.prototype._pUpdateTime = function (time) {
        this._skeletonPoseDirty = true;
        this._baseInput.update(time);
        this._differenceInput.update(time);
        _super.prototype._pUpdateTime.call(this, time);
    };
    /**
     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
     */
    SkeletonDifferenceState.prototype.getSkeletonPose = function (skeleton) {
        if (this._skeletonPoseDirty)
            this.updateSkeletonPose(skeleton);
        return this._skeletonPose;
    };
    /**
     * @inheritDoc
     */
    SkeletonDifferenceState.prototype._pUpdatePositionDelta = function () {
        this._pPositionDeltaDirty = false;
        var deltA = this._baseInput.positionDelta;
        var deltB = this._differenceInput.positionDelta;
        this.positionDelta.x = deltA.x + this._blendWeight * deltB.x;
        this.positionDelta.y = deltA.y + this._blendWeight * deltB.y;
        this.positionDelta.z = deltA.z + this._blendWeight * deltB.z;
    };
    /**
     * Updates the output skeleton pose of the node based on the blendWeight value between base input and difference input nodes.
     *
     * @param skeleton The skeleton used by the animator requesting the ouput pose.
     */
    SkeletonDifferenceState.prototype.updateSkeletonPose = function (skeleton) {
        this._skeletonPoseDirty = false;
        var endPose;
        var endPoses = this._skeletonPose.jointPoses;
        var basePoses = this._baseInput.getSkeletonPose(skeleton).jointPoses;
        var diffPoses = this._differenceInput.getSkeletonPose(skeleton).jointPoses;
        var base, diff;
        var basePos, diffPos;
        var tr;
        var numJoints = skeleton.numJoints;
        // :s
        if (endPoses.length != numJoints)
            endPoses.length = numJoints;
        for (var i = 0; i < numJoints; ++i) {
            endPose = endPoses[i];
            if (endPose == null)
                endPose = endPoses[i] = new JointPose();
            base = basePoses[i];
            diff = diffPoses[i];
            basePos = base.translation;
            diffPos = diff.translation;
            SkeletonDifferenceState._tempQuat.multiply(diff.orientation, base.orientation);
            endPose.orientation.lerp(base.orientation, SkeletonDifferenceState._tempQuat, this._blendWeight);
            tr = endPose.translation;
            tr.x = basePos.x + this._blendWeight * diffPos.x;
            tr.y = basePos.y + this._blendWeight * diffPos.y;
            tr.z = basePos.z + this._blendWeight * diffPos.z;
        }
    };
    return SkeletonDifferenceState;
}(AnimationStateBase));
SkeletonDifferenceState._tempQuat = new _awayjs_core.Quaternion();

/**
 * A skeleton animation node that uses a difference input pose with a base input pose to blend a linearly interpolated output of a skeleton pose.
 */
var SkeletonDifferenceNode = (function (_super) {
    __extends(SkeletonDifferenceNode, _super);
    /**
     * Creates a new <code>SkeletonAdditiveNode</code> object.
     */
    function SkeletonDifferenceNode() {
        var _this = _super.call(this) || this;
        _this._pStateClass = SkeletonDifferenceState;
        return _this;
    }
    /**
     * @inheritDoc
     */
    SkeletonDifferenceNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    return SkeletonDifferenceNode;
}(_awayjs_graphics.AnimationNodeBase));

/**
 *
 */
var SkeletonDirectionalState = (function (_super) {
    __extends(SkeletonDirectionalState, _super);
    function SkeletonDirectionalState(animator, skeletonAnimationNode) {
        var _this = _super.call(this, animator, skeletonAnimationNode) || this;
        _this._skeletonPose = new SkeletonPose();
        _this._skeletonPoseDirty = true;
        _this._blendWeight = 0;
        _this._direction = 0;
        _this._blendDirty = true;
        _this._skeletonAnimationNode = skeletonAnimationNode;
        _this._forward = animator.getAnimationState(_this._skeletonAnimationNode.forward);
        _this._backward = animator.getAnimationState(_this._skeletonAnimationNode.backward);
        _this._left = animator.getAnimationState(_this._skeletonAnimationNode.left);
        _this._right = animator.getAnimationState(_this._skeletonAnimationNode.right);
        return _this;
    }
    Object.defineProperty(SkeletonDirectionalState.prototype, "direction", {
        get: function () {
            return this._direction;
        },
        /**
         * Defines the direction in degrees of the aniamtion between the forwards (0), right(90) backwards (180) and left(270) input nodes,
         * used to produce the skeleton pose output.
         */
        set: function (value) {
            if (this._direction == value)
                return;
            this._direction = value;
            this._blendDirty = true;
            this._skeletonPoseDirty = true;
            this._pPositionDeltaDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    SkeletonDirectionalState.prototype.phase = function (value) {
        if (this._blendDirty)
            this.updateBlend();
        this._skeletonPoseDirty = true;
        this._pPositionDeltaDirty = true;
        this._inputA.phase(value);
        this._inputB.phase(value);
    };
    /**
     * @inheritDoc
     */
    SkeletonDirectionalState.prototype._pUdateTime = function (time) {
        if (this._blendDirty)
            this.updateBlend();
        this._skeletonPoseDirty = true;
        this._inputA.update(time);
        this._inputB.update(time);
        _super.prototype._pUpdateTime.call(this, time);
    };
    /**
     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
     */
    SkeletonDirectionalState.prototype.getSkeletonPose = function (skeleton) {
        if (this._skeletonPoseDirty)
            this.updateSkeletonPose(skeleton);
        return this._skeletonPose;
    };
    /**
     * @inheritDoc
     */
    SkeletonDirectionalState.prototype._pUpdatePositionDelta = function () {
        this._pPositionDeltaDirty = false;
        if (this._blendDirty)
            this.updateBlend();
        var deltA = this._inputA.positionDelta;
        var deltB = this._inputB.positionDelta;
        this.positionDelta.x = deltA.x + this._blendWeight * (deltB.x - deltA.x);
        this.positionDelta.y = deltA.y + this._blendWeight * (deltB.y - deltA.y);
        this.positionDelta.z = deltA.z + this._blendWeight * (deltB.z - deltA.z);
    };
    /**
     * Updates the output skeleton pose of the node based on the direction value between forward, backwards, left and right input nodes.
     *
     * @param skeleton The skeleton used by the animator requesting the ouput pose.
     */
    SkeletonDirectionalState.prototype.updateSkeletonPose = function (skeleton) {
        this._skeletonPoseDirty = false;
        if (this._blendDirty)
            this.updateBlend();
        var endPose;
        var endPoses = this._skeletonPose.jointPoses;
        var poses1 = this._inputA.getSkeletonPose(skeleton).jointPoses;
        var poses2 = this._inputB.getSkeletonPose(skeleton).jointPoses;
        var pose1, pose2;
        var p1, p2;
        var tr;
        var numJoints = skeleton.numJoints;
        // :s
        if (endPoses.length != numJoints)
            endPoses.length = numJoints;
        for (var i = 0; i < numJoints; ++i) {
            endPose = endPoses[i];
            if (endPose == null)
                endPose = endPoses[i] = new JointPose();
            pose1 = poses1[i];
            pose2 = poses2[i];
            p1 = pose1.translation;
            p2 = pose2.translation;
            endPose.orientation.lerp(pose1.orientation, pose2.orientation, this._blendWeight);
            tr = endPose.translation;
            tr.x = p1.x + this._blendWeight * (p2.x - p1.x);
            tr.y = p1.y + this._blendWeight * (p2.y - p1.y);
            tr.z = p1.z + this._blendWeight * (p2.z - p1.z);
        }
    };
    /**
     * Updates the blend value for the animation output based on the direction value between forward, backwards, left and right input nodes.
     *
     * @private
     */
    SkeletonDirectionalState.prototype.updateBlend = function () {
        this._blendDirty = false;
        if (this._direction < 0 || this._direction > 360) {
            this._direction %= 360;
            if (this._direction < 0)
                this._direction += 360;
        }
        if (this._direction < 90) {
            this._inputA = this._forward;
            this._inputB = this._right;
            this._blendWeight = this._direction / 90;
        }
        else if (this._direction < 180) {
            this._inputA = this._right;
            this._inputB = this._backward;
            this._blendWeight = (this._direction - 90) / 90;
        }
        else if (this._direction < 270) {
            this._inputA = this._backward;
            this._inputB = this._left;
            this._blendWeight = (this._direction - 180) / 90;
        }
        else {
            this._inputA = this._left;
            this._inputB = this._forward;
            this._blendWeight = (this._direction - 270) / 90;
        }
    };
    return SkeletonDirectionalState;
}(AnimationStateBase));

/**
 * A skeleton animation node that uses four directional input poses with an input direction to blend a linearly interpolated output of a skeleton pose.
 */
var SkeletonDirectionalNode = (function (_super) {
    __extends(SkeletonDirectionalNode, _super);
    function SkeletonDirectionalNode() {
        var _this = _super.call(this) || this;
        _this._pStateClass = SkeletonDirectionalState;
        return _this;
    }
    /**
     * @inheritDoc
     */
    SkeletonDirectionalNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    return SkeletonDirectionalNode;
}(_awayjs_graphics.AnimationNodeBase));

/**
 *
 */
var SkeletonNaryLERPState = (function (_super) {
    __extends(SkeletonNaryLERPState, _super);
    function SkeletonNaryLERPState(animator, skeletonAnimationNode) {
        var _this = _super.call(this, animator, skeletonAnimationNode) || this;
        _this._skeletonPose = new SkeletonPose();
        _this._skeletonPoseDirty = true;
        _this._blendWeights = new Array();
        _this._inputs = new Array();
        _this._skeletonAnimationNode = skeletonAnimationNode;
        var i = _this._skeletonAnimationNode.numInputs;
        while (i--)
            _this._inputs[i] = animator.getAnimationState(_this._skeletonAnimationNode._iInputs[i]);
        return _this;
    }
    /**
     * @inheritDoc
     */
    SkeletonNaryLERPState.prototype.phase = function (value) {
        this._skeletonPoseDirty = true;
        this._pPositionDeltaDirty = true;
        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
            if (this._blendWeights[j])
                this._inputs[j].update(value);
        }
    };
    /**
     * @inheritDoc
     */
    SkeletonNaryLERPState.prototype._pUdateTime = function (time) {
        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
            if (this._blendWeights[j])
                this._inputs[j].update(time);
        }
        _super.prototype._pUpdateTime.call(this, time);
    };
    /**
     * Returns the current skeleton pose of the animation in the clip based on the internal playhead position.
     */
    SkeletonNaryLERPState.prototype.getSkeletonPose = function (skeleton) {
        if (this._skeletonPoseDirty)
            this.updateSkeletonPose(skeleton);
        return this._skeletonPose;
    };
    /**
     * Returns the blend weight of the skeleton aniamtion node that resides at the given input index.
     *
     * @param index The input index for which the skeleton animation node blend weight is requested.
     */
    SkeletonNaryLERPState.prototype.getBlendWeightAt = function (index) {
        return this._blendWeights[index];
    };
    /**
     * Sets the blend weight of the skeleton aniamtion node that resides at the given input index.
     *
     * @param index The input index on which the skeleton animation node blend weight is to be set.
     * @param blendWeight The blend weight value to use for the given skeleton animation node index.
     */
    SkeletonNaryLERPState.prototype.setBlendWeightAt = function (index, blendWeight) {
        this._blendWeights[index] = blendWeight;
        this._pPositionDeltaDirty = true;
        this._skeletonPoseDirty = true;
    };
    /**
     * @inheritDoc
     */
    SkeletonNaryLERPState.prototype._pUpdatePositionDelta = function () {
        this._pPositionDeltaDirty = false;
        var delta;
        var weight;
        this.positionDelta.x = 0;
        this.positionDelta.y = 0;
        this.positionDelta.z = 0;
        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
            weight = this._blendWeights[j];
            if (weight) {
                delta = this._inputs[j].positionDelta;
                this.positionDelta.x += weight * delta.x;
                this.positionDelta.y += weight * delta.y;
                this.positionDelta.z += weight * delta.z;
            }
        }
    };
    /**
     * Updates the output skeleton pose of the node based on the blend weight values given to the input nodes.
     *
     * @param skeleton The skeleton used by the animator requesting the ouput pose.
     */
    SkeletonNaryLERPState.prototype.updateSkeletonPose = function (skeleton) {
        this._skeletonPoseDirty = false;
        var weight;
        var endPoses = this._skeletonPose.jointPoses;
        var poses;
        var endPose, pose;
        var endTr, tr;
        var endQuat, q;
        var firstPose;
        var i;
        var w0, x0, y0, z0;
        var w1, x1, y1, z1;
        var numJoints = skeleton.numJoints;
        // :s
        if (endPoses.length != numJoints)
            endPoses.length = numJoints;
        for (var j = 0; j < this._skeletonAnimationNode.numInputs; ++j) {
            weight = this._blendWeights[j];
            if (!weight)
                continue;
            poses = this._inputs[j].getSkeletonPose(skeleton).jointPoses;
            if (!firstPose) {
                firstPose = poses;
                for (i = 0; i < numJoints; ++i) {
                    endPose = endPoses[i];
                    if (endPose == null)
                        endPose = endPoses[i] = new JointPose();
                    pose = poses[i];
                    q = pose.orientation;
                    tr = pose.translation;
                    endQuat = endPose.orientation;
                    endQuat.x = weight * q.x;
                    endQuat.y = weight * q.y;
                    endQuat.z = weight * q.z;
                    endQuat.w = weight * q.w;
                    endTr = endPose.translation;
                    endTr.x = weight * tr.x;
                    endTr.y = weight * tr.y;
                    endTr.z = weight * tr.z;
                }
            }
            else {
                for (i = 0; i < skeleton.numJoints; ++i) {
                    endPose = endPoses[i];
                    pose = poses[i];
                    q = firstPose[i].orientation;
                    x0 = q.x;
                    y0 = q.y;
                    z0 = q.z;
                    w0 = q.w;
                    q = pose.orientation;
                    tr = pose.translation;
                    x1 = q.x;
                    y1 = q.y;
                    z1 = q.z;
                    w1 = q.w;
                    // find shortest direction
                    if (x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1 < 0) {
                        x1 = -x1;
                        y1 = -y1;
                        z1 = -z1;
                        w1 = -w1;
                    }
                    endQuat = endPose.orientation;
                    endQuat.x += weight * x1;
                    endQuat.y += weight * y1;
                    endQuat.z += weight * z1;
                    endQuat.w += weight * w1;
                    endTr = endPose.translation;
                    endTr.x += weight * tr.x;
                    endTr.y += weight * tr.y;
                    endTr.z += weight * tr.z;
                }
            }
        }
        for (i = 0; i < skeleton.numJoints; ++i)
            endPoses[i].orientation.normalize();
    };
    return SkeletonNaryLERPState;
}(AnimationStateBase));

/**
 * A skeleton animation node that uses an n-dimensional array of animation node inputs to blend a lineraly interpolated output of a skeleton pose.
 */
var SkeletonNaryLERPNode = (function (_super) {
    __extends(SkeletonNaryLERPNode, _super);
    /**
     * Creates a new <code>SkeletonNaryLERPNode</code> object.
     */
    function SkeletonNaryLERPNode() {
        var _this = _super.call(this) || this;
        _this._iInputs = new Array();
        _this._pStateClass = SkeletonNaryLERPState;
        return _this;
    }
    Object.defineProperty(SkeletonNaryLERPNode.prototype, "numInputs", {
        get: function () {
            return this._numInputs;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns an integer representing the input index of the given skeleton animation node.
     *
     * @param input The skeleton animation node for with the input index is requested.
     */
    SkeletonNaryLERPNode.prototype.getInputIndex = function (input) {
        return this._iInputs.indexOf(input);
    };
    /**
     * Returns the skeleton animation node object that resides at the given input index.
     *
     * @param index The input index for which the skeleton animation node is requested.
     */
    SkeletonNaryLERPNode.prototype.getInputAt = function (index) {
        return this._iInputs[index];
    };
    /**
     * Adds a new skeleton animation node input to the animation node.
     */
    SkeletonNaryLERPNode.prototype.addInput = function (input) {
        this._iInputs[this._numInputs++] = input;
    };
    /**
     * @inheritDoc
     */
    SkeletonNaryLERPNode.prototype.getAnimationState = function (animator) {
        return animator.getAnimationState(this);
    };
    return SkeletonNaryLERPNode;
}(_awayjs_graphics.AnimationNodeBase));

/**
 *
 */
var VertexClipState = (function (_super) {
    __extends(VertexClipState, _super);
    function VertexClipState(animator, vertexClipNode) {
        var _this = _super.call(this, animator, vertexClipNode) || this;
        _this._vertexClipNode = vertexClipNode;
        _this._frames = _this._vertexClipNode.frames;
        return _this;
    }
    Object.defineProperty(VertexClipState.prototype, "currentGraphics", {
        /**
         * @inheritDoc
         */
        get: function () {
            if (this._pFramesDirty)
                this._pUpdateFrames();
            return this._currentGraphics;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexClipState.prototype, "nextGraphics", {
        /**
         * @inheritDoc
         */
        get: function () {
            if (this._pFramesDirty)
                this._pUpdateFrames();
            return this._nextGraphics;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    VertexClipState.prototype._pUpdateFrames = function () {
        _super.prototype._pUpdateFrames.call(this);
        this._currentGraphics = this._frames[this._pCurrentFrame];
        if (this._vertexClipNode.looping && this._pNextFrame >= this._vertexClipNode.lastFrame) {
            this._nextGraphics = this._frames[0];
            this._pAnimator.dispatchCycleEvent();
        }
        else
            this._nextGraphics = this._frames[this._pNextFrame];
    };
    /**
     * @inheritDoc
     */
    VertexClipState.prototype._pUpdatePositionDelta = function () {
        //TODO:implement positiondelta functionality for vertex animations
    };
    return VertexClipState;
}(AnimationClipState));

/**
 * A vertex animation node containing time-based animation data as individual geometry obejcts.
 */
var VertexClipNode = (function (_super) {
    __extends(VertexClipNode, _super);
    /**
     * Creates a new <code>VertexClipNode</code> object.
     */
    function VertexClipNode() {
        var _this = _super.call(this) || this;
        _this._frames = new Array();
        _this._translations = new Array();
        _this._pStateClass = VertexClipState;
        return _this;
    }
    Object.defineProperty(VertexClipNode.prototype, "frames", {
        /**
         * Returns a vector of geometry frames representing the vertex values of each animation frame in the clip.
         */
        get: function () {
            return this._frames;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Adds a geometry object to the internal timeline of the animation node.
     *
     * @param geometry The geometry object to add to the timeline of the node.
     * @param duration The specified duration of the frame in milliseconds.
     * @param translation The absolute translation of the frame, used in root delta calculations for sprite movement.
     */
    VertexClipNode.prototype.addFrame = function (geometry, duration, translation) {
        if (translation === void 0) { translation = null; }
        this._frames.push(geometry);
        this._pDurations.push(duration);
        this._translations.push(translation || new _awayjs_core.Vector3D());
        this._pNumFrames = this._pDurations.length;
        this._pStitchDirty = true;
    };
    /**
     * @inheritDoc
     */
    VertexClipNode.prototype._pUpdateStitch = function () {
        _super.prototype._pUpdateStitch.call(this);
        var i = this._pNumFrames - 1;
        var p1, p2, delta;
        while (i--) {
            this._pTotalDuration += this._pDurations[i];
            p1 = this._translations[i];
            p2 = this._translations[i + 1];
            delta = p2.subtract(p1);
            this._pTotalDelta.x += delta.x;
            this._pTotalDelta.y += delta.y;
            this._pTotalDelta.z += delta.z;
        }
        if (this._pNumFrames > 1 && (this._pStitchFinalFrame || !this._pLooping)) {
            this._pTotalDuration += this._pDurations[this._pNumFrames - 1];
            p1 = this._translations[0];
            p2 = this._translations[1];
            delta = p2.subtract(p1);
            this._pTotalDelta.x += delta.x;
            this._pTotalDelta.y += delta.y;
            this._pTotalDelta.z += delta.z;
        }
    };
    return VertexClipNode;
}(AnimationClipNodeBase));

/**
 *
 */
var CrossfadeTransitionState = (function (_super) {
    __extends(CrossfadeTransitionState, _super);
    function CrossfadeTransitionState(animator, skeletonAnimationNode) {
        var _this = _super.call(this, animator, skeletonAnimationNode) || this;
        _this._crossfadeTransitionNode = skeletonAnimationNode;
        return _this;
    }
    /**
     * @inheritDoc
     */
    CrossfadeTransitionState.prototype._pUpdateTime = function (time) {
        this.blendWeight = Math.abs(time - this._crossfadeTransitionNode.startBlend) / (1000 * this._crossfadeTransitionNode.blendSpeed);
        if (this.blendWeight >= 1) {
            this.blendWeight = 1;
            if (this._animationStateTransitionComplete == null)
                this._animationStateTransitionComplete = new AnimationStateEvent(AnimationStateEvent.TRANSITION_COMPLETE, this._pAnimator, this, this._crossfadeTransitionNode);
            this._crossfadeTransitionNode.dispatchEvent(this._animationStateTransitionComplete);
        }
        _super.prototype._pUpdateTime.call(this, time);
    };
    return CrossfadeTransitionState;
}(SkeletonBinaryLERPState));

/**
 * A skeleton animation node that uses two animation node inputs to blend a lineraly interpolated output of a skeleton pose.
 */
var CrossfadeTransitionNode = (function (_super) {
    __extends(CrossfadeTransitionNode, _super);
    /**
     * Creates a new <code>CrossfadeTransitionNode</code> object.
     */
    function CrossfadeTransitionNode() {
        var _this = _super.call(this) || this;
        _this._pStateClass = CrossfadeTransitionState;
        return _this;
    }
    return CrossfadeTransitionNode;
}(SkeletonBinaryLERPNode));

/**
 *
 */
var CrossfadeTransition = (function () {
    function CrossfadeTransition(blendSpeed) {
        this.blendSpeed = 0.5;
        this.blendSpeed = blendSpeed;
    }
    CrossfadeTransition.prototype.getAnimationNode = function (animator, startNode, endNode, startBlend) {
        var crossFadeTransitionNode = new CrossfadeTransitionNode();
        crossFadeTransitionNode.inputA = startNode;
        crossFadeTransitionNode.inputB = endNode;
        crossFadeTransitionNode.blendSpeed = this.blendSpeed;
        crossFadeTransitionNode.startBlend = startBlend;
        return crossFadeTransitionNode;
    };
    return CrossfadeTransition;
}());

/**
 * Provides an interface for assigning paricle-based animation data sets to sprite-based entity objects
 * and controlling the various available states of animation through an interative playhead that can be
 * automatically updated or manually triggered.
 *
 * Requires that the containing geometry of the parent sprite is particle geometry
 *
 * @see away.base.ParticleGraphics
 */
var ParticleAnimator = (function (_super) {
    __extends(ParticleAnimator, _super);
    /**
     * Creates a new <code>ParticleAnimator</code> object.
     *
     * @param particleAnimationSet The animation data set containing the particle animations used by the animator.
     */
    function ParticleAnimator(particleAnimationSet) {
        var _this = _super.call(this, particleAnimationSet) || this;
        _this._animationParticleStates = new Array();
        _this._animatorParticleStates = new Array();
        _this._timeParticleStates = new Array();
        _this._totalLenOfOneVertex = 0;
        _this._animatorSubGeometries = new Object();
        _this._particleAnimationSet = particleAnimationSet;
        var state;
        var node;
        for (var i = 0; i < _this._particleAnimationSet.particleNodes.length; i++) {
            node = _this._particleAnimationSet.particleNodes[i];
            state = _this.getAnimationState(node);
            if (node.mode == ParticlePropertiesMode.LOCAL_DYNAMIC) {
                _this._animatorParticleStates.push(state);
                node._iDataOffset = _this._totalLenOfOneVertex;
                _this._totalLenOfOneVertex += node.dataLength;
            }
            else {
                _this._animationParticleStates.push(state);
            }
            if (state.needUpdateTime)
                _this._timeParticleStates.push(state);
        }
        return _this;
    }
    /**
     * @inheritDoc
     */
    ParticleAnimator.prototype.clone = function () {
        return new ParticleAnimator(this._particleAnimationSet);
    };
    /**
     * @inheritDoc
     */
    ParticleAnimator.prototype.setRenderState = function (shader, renderable, stage, projection) {
        var animationRegisterData = this._particleAnimationSet._iAnimationRegisterData;
        var graphics = renderable.sourceEntity.graphics;
        var shape = renderable.shape;
        if (!shape)
            throw (new Error("Must be shape"));
        //process animation sub geometries
        var animationElements = this._particleAnimationSet.getAnimationElements(graphics, shape);
        var i;
        for (i = 0; i < this._animationParticleStates.length; i++)
            this._animationParticleStates[i].setRenderState(shader, renderable, animationElements, animationRegisterData, projection, stage);
        //process animator subgeometries
        var animatorElements = this.getAnimatorElements(graphics, shape);
        for (i = 0; i < this._animatorParticleStates.length; i++)
            this._animatorParticleStates[i].setRenderState(shader, renderable, animatorElements, animationRegisterData, projection, stage);
    };
    /**
     * @inheritDoc
     */
    ParticleAnimator.prototype.testGPUCompatibility = function (shader) {
    };
    /**
     * @inheritDoc
     */
    ParticleAnimator.prototype.start = function () {
        _super.prototype.start.call(this);
        for (var i = 0; i < this._timeParticleStates.length; i++)
            this._timeParticleStates[i].offset(this._pAbsoluteTime);
    };
    /**
     * @inheritDoc
     */
    ParticleAnimator.prototype._pUpdateDeltaTime = function (dt) {
        this._pAbsoluteTime += dt;
        for (var i = 0; i < this._timeParticleStates.length; i++)
            this._timeParticleStates[i].update(this._pAbsoluteTime);
    };
    /**
     * @inheritDoc
     */
    ParticleAnimator.prototype.resetTime = function (offset) {
        if (offset === void 0) { offset = 0; }
        for (var i = 0; i < this._timeParticleStates.length; i++)
            this._timeParticleStates[i].offset(this._pAbsoluteTime + offset);
        this.update(this.time);
    };
    ParticleAnimator.prototype.dispose = function () {
        for (var key in this._animatorSubGeometries)
            this._animatorSubGeometries[key].dispose();
    };
    ParticleAnimator.prototype.getAnimatorElements = function (graphics, shape) {
        if (!this._animatorParticleStates.length)
            return;
        var elements = shape.elements;
        var animatorElements = this._animatorSubGeometries[elements.id] = new AnimationElements();
        //create the vertexData vector that will be used for local state data
        animatorElements.createVertexData(elements.numVertices, this._totalLenOfOneVertex);
        //pass the particles data to the animator elements
        animatorElements.animationParticles = this._particleAnimationSet.getAnimationElements(graphics, shape).animationParticles;
    };
    return ParticleAnimator;
}(_awayjs_stage.AnimatorBase));

/**
 * The animation data set used by skeleton-based animators, containing skeleton animation data.
 *
 * @see away.animators.SkeletonAnimator
 */
var SkeletonAnimationSet = (function (_super) {
    __extends(SkeletonAnimationSet, _super);
    /**
     * Creates a new <code>SkeletonAnimationSet</code> object.
     *
     * @param jointsPerVertex Sets the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the maximum allowed value is 4. Defaults to 4.
     */
    function SkeletonAnimationSet(jointsPerVertex) {
        if (jointsPerVertex === void 0) { jointsPerVertex = 4; }
        var _this = _super.call(this) || this;
        _this._jointsPerVertex = jointsPerVertex;
        return _this;
    }
    Object.defineProperty(SkeletonAnimationSet.prototype, "jointsPerVertex", {
        /**
         * Returns the amount of skeleton joints that can be linked to a single vertex via skinned weight values. For GPU-base animation, the
         * maximum allowed value is 4.
         */
        get: function () {
            return this._jointsPerVertex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonAnimationSet.prototype, "matricesIndex", {
        get: function () {
            return this._matricesIndex;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    SkeletonAnimationSet.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
        this._matricesIndex = registerCache.numUsedVertexConstants;
        var indexOffset0 = this._matricesIndex;
        var indexOffset1 = this._matricesIndex + 1;
        var indexOffset2 = this._matricesIndex + 2;
        var indexStream = registerCache.getFreeVertexAttribute();
        shader.jointIndexIndex = indexStream.index;
        var weightStream = registerCache.getFreeVertexAttribute();
        shader.jointWeightIndex = weightStream.index;
        var indices = [indexStream + ".x", indexStream + ".y", indexStream + ".z", indexStream + ".w"];
        var weights = [weightStream + ".x", weightStream + ".y", weightStream + ".z", weightStream + ".w"];
        var temp1 = registerCache.getFreeVertexVectorTemp();
        var dot = "dp4";
        var code = "";
        var len = sharedRegisters.animatableAttributes.length;
        for (var i = 0; i < len; ++i) {
            var source = sharedRegisters.animatableAttributes[i];
            var target = sharedRegisters.animationTargetRegisters[i];
            for (var j = 0; j < this._jointsPerVertex; ++j) {
                registerCache.getFreeVertexConstant();
                registerCache.getFreeVertexConstant();
                registerCache.getFreeVertexConstant();
                code += dot + " " + temp1 + ".x, " + source + ", vc[" + indices[j] + "+" + indexOffset0 + "]\n" +
                    dot + " " + temp1 + ".y, " + source + ", vc[" + indices[j] + "+" + indexOffset1 + "]\n" +
                    dot + " " + temp1 + ".z, " + source + ", vc[" + indices[j] + "+" + indexOffset2 + "]\n" +
                    "mov " + temp1 + ".w, " + source + ".w\n" +
                    "mul " + temp1 + ", " + temp1 + ", " + weights[j] + "\n"; // apply weight
                // add or mov to target. Need to write to a temp reg first, because an output can be a target
                if (j == 0)
                    code += "mov " + target + ", " + temp1 + "\n";
                else
                    code += "add " + target + ", " + target + ", " + temp1 + "\n";
            }
            // switch to dp3 once positions have been transformed, from now on, it should only be vectors instead of points
            dot = "dp3";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    SkeletonAnimationSet.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
        return "";
    };
    /**
     * @inheritDoc
     */
    SkeletonAnimationSet.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
        return "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
    };
    /**
     * @inheritDoc
     */
    SkeletonAnimationSet.prototype.doneAGALCode = function (shader) {
    };
    return SkeletonAnimationSet;
}(_awayjs_stage.AnimationSetBase));

/**
 * Provides an interface for assigning skeleton-based animation data sets to sprite-based entity objects
 * and controlling the various available states of animation through an interative playhead that can be
 * automatically updated or manually triggered.
 */
var SkeletonAnimator = (function (_super) {
    __extends(SkeletonAnimator, _super);
    /**
     * Creates a new <code>SkeletonAnimator</code> object.
     *
     * @param skeletonAnimationSet The animation data set containing the skeleton animations used by the animator.
     * @param skeleton The skeleton object used for calculating the resulting global matrices for transforming skinned sprite data.
     * @param forceCPU Optional value that only allows the animator to perform calculation on the CPU. Defaults to false.
     */
    function SkeletonAnimator(animationSet, skeleton, forceCPU) {
        if (forceCPU === void 0) { forceCPU = false; }
        var _this = _super.call(this, animationSet) || this;
        _this._globalPose = new SkeletonPose();
        _this._morphedElements = new Object();
        _this._morphedElementsDirty = new Object();
        _this._skeletonAnimationSet = animationSet;
        _this._skeleton = skeleton;
        _this._forceCPU = forceCPU;
        _this._jointsPerVertex = animationSet.jointsPerVertex;
        _this._numJoints = _this._skeleton.numJoints;
        _this._globalMatrices = new Float32Array(_this._numJoints * 12);
        var j = 0;
        for (var i = 0; i < _this._numJoints; ++i) {
            _this._globalMatrices[j++] = 1;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 1;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 0;
            _this._globalMatrices[j++] = 1;
            _this._globalMatrices[j++] = 0;
        }
        _this._onTransitionCompleteDelegate = function (event) { return _this.onTransitionComplete(event); };
        _this._onIndicesUpdateDelegate = function (event) { return _this.onIndicesUpdate(event); };
        _this._onVerticesUpdateDelegate = function (event) { return _this.onVerticesUpdate(event); };
        return _this;
    }
    Object.defineProperty(SkeletonAnimator.prototype, "globalMatrices", {
        /**
         * returns the calculated global matrices of the current skeleton pose.
         *
         * @see #globalPose
         */
        get: function () {
            if (this._globalPropertiesDirty)
                this.updateGlobalProperties();
            return this._globalMatrices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonAnimator.prototype, "globalPose", {
        /**
         * returns the current skeleton pose output from the animator.
         *
         * @see away.animators.data.SkeletonPose
         */
        get: function () {
            if (this._globalPropertiesDirty)
                this.updateGlobalProperties();
            return this._globalPose;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonAnimator.prototype, "skeleton", {
        /**
         * Returns the skeleton object in use by the animator - this defines the number and heirarchy of joints used by the
         * skinned geoemtry to which skeleon animator is applied.
         */
        get: function () {
            return this._skeleton;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonAnimator.prototype, "forceCPU", {
        /**
         * Indicates whether the skeleton animator is disabled by default for GPU rendering, something that allows the animator to perform calculation on the GPU.
         * Defaults to false.
         */
        get: function () {
            return this._forceCPU;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SkeletonAnimator.prototype, "useCondensedIndices", {
        /**
         * Offers the option of enabling GPU accelerated animation on skeletons larger than 32 joints
         * by condensing the number of joint index values required per sprite. Only applicable to
         * skeleton animations that utilise more than one sprite object. Defaults to false.
         */
        get: function () {
            return this._useCondensedIndices;
        },
        set: function (value) {
            this._useCondensedIndices = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    SkeletonAnimator.prototype.clone = function () {
        return new SkeletonAnimator(this._skeletonAnimationSet, this._skeleton, this._forceCPU);
    };
    /**
     * Plays an animation state registered with the given name in the animation data set.
     *
     * @param name The data set name of the animation state to be played.
     * @param transition An optional transition object that determines how the animator will transition from the currently active animation state.
     * @param offset An option offset time (in milliseconds) that resets the state's internal clock to the absolute time of the animator plus the offset value. Required for non-looping animation states.
     */
    SkeletonAnimator.prototype.play = function (name, transition, offset) {
        if (transition === void 0) { transition = null; }
        if (offset === void 0) { offset = NaN; }
        if (this._pActiveAnimationName == name)
            return;
        this._pActiveAnimationName = name;
        if (!this._pAnimationSet.hasAnimation(name))
            throw new Error("Animation root node " + name + " not found!");
        if (transition && this._pActiveNode) {
            //setup the transition
            this._pActiveNode = transition.getAnimationNode(this, this._pActiveNode, this._pAnimationSet.getAnimation(name), this._pAbsoluteTime);
            this._pActiveNode.addEventListener(AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
        }
        else
            this._pActiveNode = this._pAnimationSet.getAnimation(name);
        this._pActiveState = this.getAnimationState(this._pActiveNode);
        if (this.updatePosition) {
            //update straight away to reset position deltas
            this._pActiveState.update(this._pAbsoluteTime);
            this._pActiveState.positionDelta;
        }
        this._activeSkeletonState = this._pActiveState;
        this.start();
        //apply a time offset if specified
        if (!isNaN(offset))
            this.reset(name, offset);
    };
    /**
     * @inheritDoc
     */
    SkeletonAnimator.prototype.setRenderState = function (shader, renderable, stage, projection) {
        // do on request of globalProperties
        if (this._globalPropertiesDirty)
            this.updateGlobalProperties();
        var elements = renderable.shape.elements;
        elements.useCondensedIndices = this._useCondensedIndices;
        if (this._useCondensedIndices) {
            // using a condensed data set
            this.updateCondensedMatrices(elements.condensedIndexLookUp);
            shader.setVertexConstFromArray(this._skeletonAnimationSet.matricesIndex, this._condensedMatrices);
        }
        else {
            if (this._pAnimationSet.usesCPU) {
                if (this._morphedElementsDirty[elements.id])
                    this.morphElements(renderable, elements);
                return;
            }
            shader.setVertexConstFromArray(this._skeletonAnimationSet.matricesIndex, this._globalMatrices);
        }
    };
    /**
     * @inheritDoc
     */
    SkeletonAnimator.prototype.testGPUCompatibility = function (shader) {
        if (!this._useCondensedIndices && (this._forceCPU || this._jointsPerVertex > 4 || shader.numUsedVertexConstants + this._numJoints * 3 > 128))
            this._pAnimationSet.cancelGPUCompatibility();
    };
    /**
     * Applies the calculated time delta to the active animation state node or state transition object.
     */
    SkeletonAnimator.prototype._pUpdateDeltaTime = function (dt) {
        _super.prototype._pUpdateDeltaTime.call(this, dt);
        //invalidate pose matrices
        this._globalPropertiesDirty = true;
        //trigger geometry invalidation if using CPU animation
        if (this._pAnimationSet.usesCPU)
            this.invalidateElements();
    };
    SkeletonAnimator.prototype.updateCondensedMatrices = function (condensedIndexLookUp) {
        var j = 0, k = 0;
        var len = condensedIndexLookUp.length;
        var srcIndex;
        this._condensedMatrices = new Float32Array(len * 12);
        for (var i = 0; i < len; i++) {
            srcIndex = condensedIndexLookUp[i] * 12; //12 required for the three 4-component vectors that store the matrix
            k = 12;
            // copy into condensed
            while (k--)
                this._condensedMatrices[j++] = this._globalMatrices[srcIndex++];
        }
    };
    SkeletonAnimator.prototype.updateGlobalProperties = function () {
        this._globalPropertiesDirty = false;
        //get global pose
        this.localToGlobalPose(this._activeSkeletonState.getSkeletonPose(this._skeleton), this._globalPose, this._skeleton);
        // convert pose to matrix
        var mtxOffset = 0;
        var globalPoses = this._globalPose.jointPoses;
        var raw;
        var ox, oy, oz, ow;
        var xy2, xz2, xw2;
        var yz2, yw2, zw2;
        var n11, n12, n13;
        var n21, n22, n23;
        var n31, n32, n33;
        var m11, m12, m13, m14;
        var m21, m22, m23, m24;
        var m31, m32, m33, m34;
        var joints = this._skeleton.joints;
        var pose;
        var quat;
        var vec;
        var t;
        for (var i = 0; i < this._numJoints; ++i) {
            pose = globalPoses[i];
            quat = pose.orientation;
            vec = pose.translation;
            ox = quat.x;
            oy = quat.y;
            oz = quat.z;
            ow = quat.w;
            xy2 = (t = 2.0 * ox) * oy;
            xz2 = t * oz;
            xw2 = t * ow;
            yz2 = (t = 2.0 * oy) * oz;
            yw2 = t * ow;
            zw2 = 2.0 * oz * ow;
            yz2 = 2.0 * oy * oz;
            yw2 = 2.0 * oy * ow;
            zw2 = 2.0 * oz * ow;
            ox *= ox;
            oy *= oy;
            oz *= oz;
            ow *= ow;
            n11 = (t = ox - oy) - oz + ow;
            n12 = xy2 - zw2;
            n13 = xz2 + yw2;
            n21 = xy2 + zw2;
            n22 = -t - oz + ow;
            n23 = yz2 - xw2;
            n31 = xz2 - yw2;
            n32 = yz2 + xw2;
            n33 = -ox - oy + oz + ow;
            // prepend inverse bind pose
            raw = joints[i].inverseBindPose;
            m11 = raw[0];
            m12 = raw[4];
            m13 = raw[8];
            m14 = raw[12];
            m21 = raw[1];
            m22 = raw[5];
            m23 = raw[9];
            m24 = raw[13];
            m31 = raw[2];
            m32 = raw[6];
            m33 = raw[10];
            m34 = raw[14];
            this._globalMatrices[mtxOffset] = n11 * m11 + n12 * m21 + n13 * m31;
            this._globalMatrices[mtxOffset + 1] = n11 * m12 + n12 * m22 + n13 * m32;
            this._globalMatrices[mtxOffset + 2] = n11 * m13 + n12 * m23 + n13 * m33;
            this._globalMatrices[mtxOffset + 3] = n11 * m14 + n12 * m24 + n13 * m34 + vec.x;
            this._globalMatrices[mtxOffset + 4] = n21 * m11 + n22 * m21 + n23 * m31;
            this._globalMatrices[mtxOffset + 5] = n21 * m12 + n22 * m22 + n23 * m32;
            this._globalMatrices[mtxOffset + 6] = n21 * m13 + n22 * m23 + n23 * m33;
            this._globalMatrices[mtxOffset + 7] = n21 * m14 + n22 * m24 + n23 * m34 + vec.y;
            this._globalMatrices[mtxOffset + 8] = n31 * m11 + n32 * m21 + n33 * m31;
            this._globalMatrices[mtxOffset + 9] = n31 * m12 + n32 * m22 + n33 * m32;
            this._globalMatrices[mtxOffset + 10] = n31 * m13 + n32 * m23 + n33 * m33;
            this._globalMatrices[mtxOffset + 11] = n31 * m14 + n32 * m24 + n33 * m34 + vec.z;
            mtxOffset = mtxOffset + 12;
        }
    };
    SkeletonAnimator.prototype.getRenderableElements = function (renderable, sourceElements) {
        this._morphedElementsDirty[sourceElements.id] = true;
        //early out for GPU animations
        if (!this._pAnimationSet.usesCPU)
            return sourceElements;
        var targetElements;
        if (!(targetElements = this._morphedElements[sourceElements.id])) {
            //not yet stored
            sourceElements.normals;
            sourceElements.tangents;
            targetElements = this._morphedElements[sourceElements.id] = sourceElements.clone();
            //turn off auto calculations on the morphed geometry
            targetElements.autoDeriveNormals = false;
            targetElements.autoDeriveTangents = false;
            //add event listeners for any changes in UV values on the source geometry
            sourceElements.addEventListener(_awayjs_graphics.ElementsEvent.INVALIDATE_INDICES, this._onIndicesUpdateDelegate);
            sourceElements.addEventListener(_awayjs_graphics.ElementsEvent.INVALIDATE_VERTICES, this._onVerticesUpdateDelegate);
        }
        return targetElements;
    };
    /**
     * If the animation can't be performed on GPU, transform vertices manually
     * @param subGeom The subgeometry containing the weights and joint index data per vertex.
     * @param pass The material pass for which we need to transform the vertices
     */
    SkeletonAnimator.prototype.morphElements = function (renderable, sourceElements) {
        this._morphedElementsDirty[sourceElements.id] = false;
        var numVertices = sourceElements.numVertices;
        var sourcePositions = sourceElements.positions.get(numVertices);
        var sourceNormals = sourceElements.normals.get(numVertices);
        var sourceTangents = sourceElements.tangents.get(numVertices);
        var posDim = sourceElements.positions.dimensions;
        var posStride = sourceElements.positions.stride;
        var normalStride = sourceElements.normals.stride;
        var tangentStride = sourceElements.tangents.stride;
        var jointIndices = sourceElements.jointIndices.get(numVertices);
        var jointWeights = sourceElements.jointWeights.get(numVertices);
        var jointStride = sourceElements.jointIndices.stride;
        var targetElements = this._morphedElements[sourceElements.id];
        var targetPositions = targetElements.positions.get(numVertices);
        var targetNormals = targetElements.normals.get(numVertices);
        var targetTangents = targetElements.tangents.get(numVertices);
        targetElements.positions.attributesBuffer.invalidate();
        targetElements.normals.attributesBuffer.invalidate();
        targetElements.tangents.attributesBuffer.invalidate();
        var index = 0;
        var i0 = 0;
        var i1 = 0;
        var i2 = 0;
        var i3 = 0;
        var k;
        var vx, vy, vz;
        var nx, ny, nz;
        var tx, ty, tz;
        var weight;
        var vertX, vertY, vertZ;
        var normX, normY, normZ;
        var tangX, tangY, tangZ;
        var m11, m12, m13, m14;
        var m21, m22, m23, m24;
        var m31, m32, m33, m34;
        while (index < numVertices) {
            i0 = index * posStride;
            vertX = sourcePositions[i0];
            vertY = sourcePositions[i0 + 1];
            vertZ = (posDim == 3) ? sourcePositions[i0 + 2] : 0;
            i1 = index * normalStride;
            normX = sourceNormals[i1];
            normY = sourceNormals[i1 + 1];
            normZ = sourceNormals[i1 + 2];
            i2 = index * tangentStride;
            tangX = sourceTangents[i2];
            tangY = sourceTangents[i2 + 1];
            tangZ = sourceTangents[i2 + 2];
            vx = 0;
            vy = 0;
            vz = 0;
            nx = 0;
            ny = 0;
            nz = 0;
            tx = 0;
            ty = 0;
            tz = 0;
            k = 0;
            i3 = index * jointStride;
            while (k < this._jointsPerVertex) {
                weight = jointWeights[i3 + k];
                if (weight > 0) {
                    // implicit /3*12 (/3 because indices are multiplied by 3 for gpu matrix access, *12 because it's the matrix size)
                    var mtxOffset = jointIndices[i3 + k] << 2;
                    m11 = this._globalMatrices[mtxOffset];
                    m12 = this._globalMatrices[mtxOffset + 1];
                    m13 = this._globalMatrices[mtxOffset + 2];
                    m14 = this._globalMatrices[mtxOffset + 3];
                    m21 = this._globalMatrices[mtxOffset + 4];
                    m22 = this._globalMatrices[mtxOffset + 5];
                    m23 = this._globalMatrices[mtxOffset + 6];
                    m24 = this._globalMatrices[mtxOffset + 7];
                    m31 = this._globalMatrices[mtxOffset + 8];
                    m32 = this._globalMatrices[mtxOffset + 9];
                    m33 = this._globalMatrices[mtxOffset + 10];
                    m34 = this._globalMatrices[mtxOffset + 11];
                    vx += weight * (m11 * vertX + m12 * vertY + m13 * vertZ + m14);
                    vy += weight * (m21 * vertX + m22 * vertY + m23 * vertZ + m24);
                    vz += weight * (m31 * vertX + m32 * vertY + m33 * vertZ + m34);
                    nx += weight * (m11 * normX + m12 * normY + m13 * normZ);
                    ny += weight * (m21 * normX + m22 * normY + m23 * normZ);
                    nz += weight * (m31 * normX + m32 * normY + m33 * normZ);
                    tx += weight * (m11 * tangX + m12 * tangY + m13 * tangZ);
                    ty += weight * (m21 * tangX + m22 * tangY + m23 * tangZ);
                    tz += weight * (m31 * tangX + m32 * tangY + m33 * tangZ);
                    k++;
                }
                else {
                    //if zero weight encountered, skip to the next vertex
                    k = this._jointsPerVertex;
                }
            }
            targetPositions[i0] = vx;
            targetPositions[i0 + 1] = vy;
            if (posDim == 3)
                targetPositions[i0 + 2] = vz;
            targetNormals[i1] = nx;
            targetNormals[i1 + 1] = ny;
            targetNormals[i1 + 2] = nz;
            targetTangents[i2] = tx;
            targetTangents[i2 + 1] = ty;
            targetTangents[i2 + 2] = tz;
            index++;
        }
    };
    /**
     * Converts a local hierarchical skeleton pose to a global pose
     * @param targetPose The SkeletonPose object that will contain the global pose.
     * @param skeleton The skeleton containing the joints, and as such, the hierarchical data to transform to global poses.
     */
    SkeletonAnimator.prototype.localToGlobalPose = function (sourcePose, targetPose, skeleton) {
        var globalPoses = targetPose.jointPoses;
        var globalJointPose;
        var joints = skeleton.joints;
        var len = sourcePose.numJointPoses;
        var jointPoses = sourcePose.jointPoses;
        var parentIndex;
        var joint;
        var parentPose;
        var pose;
        var or;
        var tr;
        var t;
        var q;
        var x1, y1, z1, w1;
        var x2, y2, z2, w2;
        var x3, y3, z3;
        // :s
        if (globalPoses.length != len)
            globalPoses.length = len;
        for (var i = 0; i < len; ++i) {
            globalJointPose = globalPoses[i];
            if (globalJointPose == null)
                globalJointPose = globalPoses[i] = new JointPose();
            joint = joints[i];
            parentIndex = joint.parentIndex;
            pose = jointPoses[i];
            q = globalJointPose.orientation;
            t = globalJointPose.translation;
            if (parentIndex < 0) {
                tr = pose.translation;
                or = pose.orientation;
                q.x = or.x;
                q.y = or.y;
                q.z = or.z;
                q.w = or.w;
                t.x = tr.x;
                t.y = tr.y;
                t.z = tr.z;
            }
            else {
                // append parent pose
                parentPose = globalPoses[parentIndex];
                // rotate point
                or = parentPose.orientation;
                tr = pose.translation;
                x2 = or.x;
                y2 = or.y;
                z2 = or.z;
                w2 = or.w;
                x3 = tr.x;
                y3 = tr.y;
                z3 = tr.z;
                w1 = -x2 * x3 - y2 * y3 - z2 * z3;
                x1 = w2 * x3 + y2 * z3 - z2 * y3;
                y1 = w2 * y3 - x2 * z3 + z2 * x3;
                z1 = w2 * z3 + x2 * y3 - y2 * x3;
                // append parent translation
                tr = parentPose.translation;
                t.x = -w1 * x2 + x1 * w2 - y1 * z2 + z1 * y2 + tr.x;
                t.y = -w1 * y2 + x1 * z2 + y1 * w2 - z1 * x2 + tr.y;
                t.z = -w1 * z2 - x1 * y2 + y1 * x2 + z1 * w2 + tr.z;
                // append parent orientation
                x1 = or.x;
                y1 = or.y;
                z1 = or.z;
                w1 = or.w;
                or = pose.orientation;
                x2 = or.x;
                y2 = or.y;
                z2 = or.z;
                w2 = or.w;
                q.w = w1 * w2 - x1 * x2 - y1 * y2 - z1 * z2;
                q.x = w1 * x2 + x1 * w2 + y1 * z2 - z1 * y2;
                q.y = w1 * y2 - x1 * z2 + y1 * w2 + z1 * x2;
                q.z = w1 * z2 + x1 * y2 - y1 * x2 + z1 * w2;
            }
        }
    };
    SkeletonAnimator.prototype.onTransitionComplete = function (event) {
        if (event.type == AnimationStateEvent.TRANSITION_COMPLETE) {
            event.animationNode.removeEventListener(AnimationStateEvent.TRANSITION_COMPLETE, this._onTransitionCompleteDelegate);
            //if this is the current active state transition, revert control to the active node
            if (this._pActiveState == event.animationState) {
                this._pActiveNode = this._pAnimationSet.getAnimation(this._pActiveAnimationName);
                this._pActiveState = this.getAnimationState(this._pActiveNode);
                this._activeSkeletonState = this._pActiveState;
            }
        }
    };
    SkeletonAnimator.prototype.onIndicesUpdate = function (event) {
        var elements = event.target;
        this._morphedElements[elements.id].setIndices(elements.indices);
    };
    SkeletonAnimator.prototype.onVerticesUpdate = function (event) {
        //only update uvs
        if (event.attributesView != elements.uvs && event.attributesView != elements.getCustomAtributes("secondaryUVs"))
            return;
        var elements = event.target;
        var morphGraphics = this._morphedElements[elements.id];
        var morphUVs = morphGraphics.uvs.get(elements.numVertices);
        morphGraphics.invalidateVertices(morphGraphics.uvs);
        var uvStride = morphGraphics.uvs.stride;
        var uvs = event.attributesView.get(elements.numVertices);
        var len = elements.numVertices * uvStride;
        for (var i = 0; i < len; i += uvStride) {
            morphUVs[i] = uvs[i];
            morphUVs[i + 1] = uvs[i + 1];
        }
    };
    return SkeletonAnimator;
}(_awayjs_stage.AnimatorBase));

/**
 * The animation data set used by vertex-based animators, containing vertex animation state data.
 *
 * @see VertexAnimator
 */
var VertexAnimationSet = (function (_super) {
    __extends(VertexAnimationSet, _super);
    /**
     * Returns whether or not normal data is used in last set GPU pass of the vertex shader.
     */
    //		public get useNormals():boolean
    //		{
    //			return this._uploadNormals;
    //		}
    /**
     * Creates a new <code>VertexAnimationSet</code> object.
     *
     * @param numPoses The number of poses made available at once to the GPU animation code.
     * @param blendMode Optional value for setting the animation mode of the vertex animator object.
     *
     * @see away3d.animators.data.VertexAnimationMode
     */
    function VertexAnimationSet(numPoses, blendMode) {
        if (numPoses === void 0) { numPoses = 2; }
        if (blendMode === void 0) { blendMode = "absolute"; }
        var _this = _super.call(this) || this;
        _this._numPoses = numPoses;
        _this._blendMode = blendMode;
        return _this;
    }
    Object.defineProperty(VertexAnimationSet.prototype, "numPoses", {
        /**
         * Returns the number of poses made available at once to the GPU animation code.
         */
        get: function () {
            return this._numPoses;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexAnimationSet.prototype, "blendMode", {
        /**
         * Returns the active blend mode of the vertex animator object.
         */
        get: function () {
            return this._blendMode;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    VertexAnimationSet.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
        //grab animationRegisterData from the materialpassbase or create a new one if the first time
        this._iAnimationRegisterData = shader.animationRegisterData;
        if (this._iAnimationRegisterData == null)
            this._iAnimationRegisterData = shader.animationRegisterData = new _awayjs_stage.AnimationRegisterData();
        if (this._blendMode == VertexAnimationMode.ABSOLUTE)
            return this.getAbsoluteAGALCode(shader, registerCache, sharedRegisters);
        else
            return this.getAdditiveAGALCode(shader, registerCache, sharedRegisters);
    };
    /**
     * @inheritDoc
     */
    VertexAnimationSet.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
        return "";
    };
    /**
     * @inheritDoc
     */
    VertexAnimationSet.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
        return "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
    };
    /**
     * @inheritDoc
     */
    VertexAnimationSet.prototype.doneAGALCode = function (shader) {
    };
    /**
     * Generates the vertex AGAL code for absolute blending.
     */
    VertexAnimationSet.prototype.getAbsoluteAGALCode = function (shader, registerCache, sharedRegisters) {
        var code = "";
        var temp1 = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(temp1, 1);
        var temp2 = registerCache.getFreeVertexVectorTemp();
        var regs = new Array(".x", ".y", ".z", ".w");
        var len = sharedRegisters.animatableAttributes.length;
        var constantReg = registerCache.getFreeVertexConstant();
        this._iAnimationRegisterData.weightsIndex = constantReg.index;
        this._iAnimationRegisterData.poseIndices = new Array(this._numPoses);
        var poseInput;
        var k = 0;
        if (len > 2)
            len = 2;
        for (var i = 0; i < len; ++i) {
            code += "mul " + temp1 + ", " + sharedRegisters.animatableAttributes[i] + ", " + constantReg + regs[0] + "\n";
            for (var j = 1; j < this._numPoses; ++j) {
                poseInput = registerCache.getFreeVertexAttribute();
                this._iAnimationRegisterData.poseIndices[k++] = poseInput.index;
                code += "mul " + temp2 + ", " + poseInput + ", " + constantReg + regs[j] + "\n";
                if (j < this._numPoses - 1)
                    code += "add " + temp1 + ", " + temp1 + ", " + temp2 + "\n";
            }
            code += "add " + sharedRegisters.animationTargetRegisters[i] + ", " + temp1 + ", " + temp2 + "\n";
        }
        // add code for bitangents if tangents are used
        if (shader.tangentDependencies > 0 || shader.outputsNormals) {
            code += "dp3 " + temp1 + ".x, " + sharedRegisters.animatableAttributes[2] + ", " + sharedRegisters.animationTargetRegisters[1] + "\n" +
                "mul " + temp1 + ", " + sharedRegisters.animationTargetRegisters[1] + ", " + temp1 + ".x\n" +
                "sub " + sharedRegisters.animationTargetRegisters[2] + ", " + sharedRegisters.animationTargetRegisters[2] + ", " + temp1 + "\n";
        }
        //
        // // simply write attributes to targets, do not animate them
        // // projection will pick up on targets[0] to do the projection
        // var len:number = sharedRegisters.animatableAttributes.length;
        // for (var i:number = 0; i < len; ++i)
        // 	code += "mov " + sharedRegisters.animationTargetRegisters[i] + ", " + sharedRegisters.animatableAttributes[i] + "\n";
        return code;
    };
    /**
     * Generates the vertex AGAL code for additive blending.
     */
    VertexAnimationSet.prototype.getAdditiveAGALCode = function (shader, registerCache, sharedRegisters) {
        var code = "";
        var len = sharedRegisters.animatableAttributes.length;
        var regs = [".x", ".y", ".z", ".w"];
        var temp1 = registerCache.getFreeVertexVectorTemp();
        var constantReg = registerCache.getFreeVertexConstant();
        this._iAnimationRegisterData.weightsIndex = constantReg.index;
        this._iAnimationRegisterData.poseIndices = new Array(this._numPoses);
        var poseInput;
        var k = 0;
        if (len > 2)
            len = 2;
        code += "mov  " + sharedRegisters.animationTargetRegisters[0] + ", " + sharedRegisters.animatableAttributes[0] + "\n";
        if (shader.normalDependencies > 0)
            code += "mov " + sharedRegisters.animationTargetRegisters[1] + ", " + sharedRegisters.animatableAttributes[1] + "\n";
        for (var i = 0; i < len; ++i) {
            for (var j = 0; j < this._numPoses; ++j) {
                poseInput = registerCache.getFreeVertexAttribute();
                this._iAnimationRegisterData.poseIndices[k++] = poseInput.index;
                code += "mul " + temp1 + ", " + poseInput + ", " + constantReg + regs[j] + "\n" +
                    "add " + sharedRegisters.animationTargetRegisters[i] + ", " + sharedRegisters.animationTargetRegisters[i] + ", " + temp1 + "\n";
            }
        }
        if (shader.tangentDependencies > 0 || shader.outputsNormals) {
            code += "dp3 " + temp1 + ".x, " + sharedRegisters.animatableAttributes[2] + ", " + sharedRegisters.animationTargetRegisters[1] + "\n" +
                "mul " + temp1 + ", " + sharedRegisters.animationTargetRegisters[1] + ", " + temp1 + ".x\n" +
                "sub " + sharedRegisters.animationTargetRegisters[2] + ", " + sharedRegisters.animatableAttributes[2] + ", " + temp1 + "\n";
        }
        return code;
    };
    return VertexAnimationSet;
}(_awayjs_stage.AnimationSetBase));

/**
 * Provides an interface for assigning vertex-based animation data sets to sprite-based entity objects
 * and controlling the various available states of animation through an interative playhead that can be
 * automatically updated or manually triggered.
 */
var VertexAnimator = (function (_super) {
    __extends(VertexAnimator, _super);
    /**
     * Creates a new <code>VertexAnimator</code> object.
     *
     * @param vertexAnimationSet The animation data set containing the vertex animations used by the animator.
     */
    function VertexAnimator(vertexAnimationSet) {
        var _this = _super.call(this, vertexAnimationSet) || this;
        _this._poses = new Array();
        _this._weights = new Float32Array([1, 0, 0, 0]);
        _this._vertexAnimationSet = vertexAnimationSet;
        return _this;
    }
    /**
     * @inheritDoc
     */
    VertexAnimator.prototype.clone = function () {
        return new VertexAnimator(this._vertexAnimationSet);
    };
    /**
     * Plays a sequence with a given name. If the sequence is not found, it may not be loaded yet, and it will retry every frame.
     * @param sequenceName The name of the clip to be played.
     */
    VertexAnimator.prototype.play = function (name, transition, offset) {
        if (transition === void 0) { transition = null; }
        if (offset === void 0) { offset = NaN; }
        if (this._pActiveAnimationName == name)
            return;
        this._pActiveAnimationName = name;
        //TODO: implement transitions in vertex animator
        if (!this._pAnimationSet.hasAnimation(name))
            throw new Error("Animation root node " + name + " not found!");
        this._pActiveNode = this._pAnimationSet.getAnimation(name);
        this._pActiveState = this.getAnimationState(this._pActiveNode);
        if (this.updatePosition) {
            //update straight away to reset position deltas
            this._pActiveState.update(this._pAbsoluteTime);
            this._pActiveState.positionDelta;
        }
        this._activeVertexState = this._pActiveState;
        this.start();
        //apply a time offset if specified
        if (!isNaN(offset))
            this.reset(name, offset);
    };
    /**
     * @inheritDoc
     */
    VertexAnimator.prototype._pUpdateDeltaTime = function (dt) {
        _super.prototype._pUpdateDeltaTime.call(this, dt);
        var geometryFlag = false;
        if (this._poses[0] != this._activeVertexState.currentGraphics) {
            this._poses[0] = this._activeVertexState.currentGraphics;
            geometryFlag = true;
        }
        if (this._poses[1] != this._activeVertexState.nextGraphics)
            this._poses[1] = this._activeVertexState.nextGraphics;
        this._weights[0] = 1 - (this._weights[1] = this._activeVertexState.blendWeight);
        if (geometryFlag)
            this.invalidateElements();
    };
    /**
     * @inheritDoc
     */
    VertexAnimator.prototype.setRenderState = function (shader, renderable, stage, projection) {
        // todo: add code for when running on cpu
        // this type of animation can only be Shape
        var shape = renderable.shape;
        var sprite = renderable.sourceEntity;
        var elements = shape.elements;
        // if no poses defined, set temp data
        if (!this._poses.length) {
            this.setNullPose(shader, elements, stage);
            return;
        }
        var animationRegisterData = shader.animationRegisterData;
        var i;
        var len = this._vertexAnimationSet.numPoses;
        shader.setVertexConstFromArray(animationRegisterData.weightsIndex, this._weights);
        if (this._vertexAnimationSet.blendMode == VertexAnimationMode.ABSOLUTE)
            i = 1;
        else
            i = 0;
        var elementsGL;
        var k = 0;
        var shapeIndex = sprite.graphics.getShapeIndex(shape);
        for (; i < len; ++i) {
            elements = this._poses[i].getShapeAt(shapeIndex).elements || shape.elements;
            elementsGL = stage.getAbstraction(elements);
            elementsGL._indexMappings = stage.getAbstraction(shape.elements).getIndexMappings();
            if (elements.isAsset(_awayjs_graphics.TriangleElements)) {
                elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.positions);
                if (shader.normalDependencies > 0)
                    elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.normals);
            }
        }
    };
    VertexAnimator.prototype.setNullPose = function (shader, elements, stage) {
        var animationRegisterData = shader.animationRegisterData;
        shader.setVertexConstFromArray(animationRegisterData.weightsIndex, this._weights);
        var elementsGL = stage.getAbstraction(elements);
        var k = 0;
        if (this._vertexAnimationSet.blendMode == VertexAnimationMode.ABSOLUTE) {
            var len = this._vertexAnimationSet.numPoses;
            for (var i = 1; i < len; ++i) {
                if (elements.isAsset(_awayjs_graphics.TriangleElements)) {
                    elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.positions);
                    if (shader.normalDependencies > 0)
                        elementsGL.activateVertexBufferVO(animationRegisterData.poseIndices[k++], elements.normals);
                }
            }
        }
        // todo: set temp data for additive?
    };
    /**
     * Verifies if the animation will be used on cpu. Needs to be true for all passes for a material to be able to use it on gpu.
     * Needs to be called if gpu code is potentially required.
     */
    VertexAnimator.prototype.testGPUCompatibility = function (shader) {
    };
    VertexAnimator.prototype.getRenderableElements = function (renderable, sourceElements) {
        if (this._vertexAnimationSet.blendMode == VertexAnimationMode.ABSOLUTE && this._poses.length)
            return this._poses[0].getShapeAt(renderable.sourceEntity.graphics.getShapeIndex(renderable.shape)).elements || sourceElements;
        //nothing to do here
        return sourceElements;
    };
    return VertexAnimator;
}(_awayjs_stage.AnimatorBase));

var RTTEvent = (function (_super) {
    __extends(RTTEvent, _super);
    function RTTEvent(type, rttManager) {
        var _this = _super.call(this, type) || this;
        _this._rttManager = rttManager;
        return _this;
    }
    Object.defineProperty(RTTEvent.prototype, "rttManager", {
        /**
         *
         */
        get: function () {
            return this._rttManager;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    RTTEvent.prototype.clone = function () {
        return new RTTEvent(this.type, this._rttManager);
    };
    return RTTEvent;
}(_awayjs_core.EventBase));
/**
 *
 */
RTTEvent.RESIZE = "rttManagerResize";

var RTTBufferManager = (function (_super) {
    __extends(RTTBufferManager, _super);
    function RTTBufferManager(stage) {
        var _this = _super.call(this) || this;
        _this._viewWidth = -1;
        _this._viewHeight = -1;
        _this._textureWidth = -1;
        _this._textureHeight = -1;
        _this._buffersInvalid = true;
        _this._renderToTextureRect = new _awayjs_core.Rectangle();
        _this._stage = stage;
        return _this;
    }
    RTTBufferManager.getInstance = function (stage) {
        if (!stage)
            throw new Error("stage key cannot be null!");
        if (RTTBufferManager._instances == null)
            RTTBufferManager._instances = new Array();
        var rttBufferManager = RTTBufferManager.getRTTBufferManagerFromStage(stage);
        if (rttBufferManager == null) {
            rttBufferManager = new RTTBufferManager(stage);
            var vo = new RTTBufferManagerVO();
            vo.stage3d = stage;
            vo.rttbfm = rttBufferManager;
            RTTBufferManager._instances.push(vo);
        }
        return rttBufferManager;
    };
    RTTBufferManager.getRTTBufferManagerFromStage = function (stage) {
        var l = RTTBufferManager._instances.length;
        var r;
        for (var c = 0; c < l; c++) {
            r = RTTBufferManager._instances[c];
            if (r.stage3d === stage)
                return r.rttbfm;
        }
        return null;
    };
    RTTBufferManager.deleteRTTBufferManager = function (stage) {
        var l = RTTBufferManager._instances.length;
        var r;
        for (var c = 0; c < l; c++) {
            r = RTTBufferManager._instances[c];
            if (r.stage3d === stage) {
                RTTBufferManager._instances.splice(c, 1);
                return;
            }
        }
    };
    Object.defineProperty(RTTBufferManager.prototype, "textureRatioX", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._textureRatioX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "textureRatioY", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._textureRatioY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "viewWidth", {
        get: function () {
            return this._viewWidth;
        },
        set: function (value) {
            if (value == this._viewWidth)
                return;
            this._viewWidth = value;
            this._buffersInvalid = true;
            this._textureWidth = _awayjs_graphics.ImageUtils.getBestPowerOf2(this._viewWidth);
            if (this._textureWidth > this._viewWidth) {
                this._renderToTextureRect.x = Math.floor((this._textureWidth - this._viewWidth) * .5);
                this._renderToTextureRect.width = this._viewWidth;
            }
            else {
                this._renderToTextureRect.x = 0;
                this._renderToTextureRect.width = this._textureWidth;
            }
            this.dispatchEvent(new RTTEvent(RTTEvent.RESIZE, this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "viewHeight", {
        get: function () {
            return this._viewHeight;
        },
        set: function (value) {
            if (value == this._viewHeight)
                return;
            this._viewHeight = value;
            this._buffersInvalid = true;
            this._textureHeight = _awayjs_graphics.ImageUtils.getBestPowerOf2(this._viewHeight);
            if (this._textureHeight > this._viewHeight) {
                this._renderToTextureRect.y = Math.floor((this._textureHeight - this._viewHeight) * .5);
                this._renderToTextureRect.height = this._viewHeight;
            }
            else {
                this._renderToTextureRect.y = 0;
                this._renderToTextureRect.height = this._textureHeight;
            }
            this.dispatchEvent(new RTTEvent(RTTEvent.RESIZE, this));
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureVertexBuffer", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._renderToTextureVertexBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "renderToScreenVertexBuffer", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._renderToScreenVertexBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "indexBuffer", {
        get: function () {
            return this._indexBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "renderToTextureRect", {
        get: function () {
            if (this._buffersInvalid)
                this.updateRTTBuffers();
            return this._renderToTextureRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "textureWidth", {
        get: function () {
            return this._textureWidth;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RTTBufferManager.prototype, "textureHeight", {
        get: function () {
            return this._textureHeight;
        },
        enumerable: true,
        configurable: true
    });
    RTTBufferManager.prototype.dispose = function () {
        RTTBufferManager.deleteRTTBufferManager(this._stage);
        if (this._indexBuffer) {
            this._indexBuffer.dispose();
            this._renderToScreenVertexBuffer.dispose();
            this._renderToTextureVertexBuffer.dispose();
            this._renderToScreenVertexBuffer = null;
            this._renderToTextureVertexBuffer = null;
            this._indexBuffer = null;
        }
    };
    // todo: place all this in a separate model, since it's used all over the place
    // maybe it even has a place in the core (together with screenRect etc)?
    // needs to be stored per view of course
    RTTBufferManager.prototype.updateRTTBuffers = function () {
        var context = this._stage.context;
        var textureVerts;
        var screenVerts;
        var x;
        var y;
        if (this._renderToTextureVertexBuffer == null)
            this._renderToTextureVertexBuffer = context.createVertexBuffer(4, 20);
        if (this._renderToScreenVertexBuffer == null)
            this._renderToScreenVertexBuffer = context.createVertexBuffer(4, 20);
        if (!this._indexBuffer) {
            this._indexBuffer = context.createIndexBuffer(6);
            this._indexBuffer.uploadFromArray([2, 1, 0, 3, 2, 0], 0, 6);
        }
        this._textureRatioX = x = Math.min(this._viewWidth / this._textureWidth, 1);
        this._textureRatioY = y = Math.min(this._viewHeight / this._textureHeight, 1);
        var u1 = (1 - x) * .5;
        var u2 = (x + 1) * .5;
        var v1 = (1 - y) * .5;
        var v2 = (y + 1) * .5;
        // last element contains indices for data per vertex that can be passed to the vertex shader if necessary (ie: frustum corners for deferred rendering)
        textureVerts = [-x, -y, u1, v1, 0, x, -y, u2, v1, 1, x, y, u2, v2, 2, -x, y, u1, v2, 3];
        screenVerts = [-1, -1, u1, v1, 0, 1, -1, u2, v1, 1, 1, 1, u2, v2, 2, -1, 1, u1, v2, 3];
        this._renderToTextureVertexBuffer.uploadFromArray(textureVerts, 0, 4);
        this._renderToScreenVertexBuffer.uploadFromArray(screenVerts, 0, 4);
        this._buffersInvalid = false;
    };
    return RTTBufferManager;
}(_awayjs_core.EventDispatcher));
var RTTBufferManagerVO = (function () {
    function RTTBufferManagerVO() {
    }
    return RTTBufferManagerVO;
}());

/**
 * GL_DepthMaterial forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var GL_DepthMaterial = (function (_super) {
    __extends(GL_DepthMaterial, _super);
    /**
     *
     * @param pool
     * @param surface
     * @param elementsClass
     * @param stage
     */
    function GL_DepthMaterial(material, materialPool) {
        var _this = _super.call(this, material, materialPool) || this;
        _this._shader = new _awayjs_stage.ShaderBase(materialPool.elementsClass, _this, _this._stage);
        _this._pAddPass(_this);
        return _this;
    }
    GL_DepthMaterial.prototype.invalidate = function () {
        _super.prototype.invalidate.call(this);
        this._textureVO = this._material.getTextureAt(0) ? this._shader.getAbstraction(this._material.getTextureAt(0)) : null;
    };
    GL_DepthMaterial.prototype._includeDependencies = function (shader) {
        _super.prototype._includeDependencies.call(this, shader);
        shader.projectionDependencies++;
        if (shader.alphaThreshold > 0)
            shader.uvDependencies++;
    };
    GL_DepthMaterial.prototype._initConstantData = function (shader) {
        _super.prototype._initConstantData.call(this, shader);
        var index = this._fragmentConstantsIndex;
        var data = shader.fragmentConstantData;
        data[index] = 1.0;
        data[index + 1] = 255.0;
        data[index + 2] = 65025.0;
        data[index + 3] = 16581375.0;
        data[index + 4] = 1.0 / 255.0;
        data[index + 5] = 1.0 / 255.0;
        data[index + 6] = 1.0 / 255.0;
        data[index + 7] = 0.0;
    };
    /**
     * @inheritDoc
     */
    GL_DepthMaterial.prototype._getFragmentCode = function (registerCache, sharedRegisters) {
        var code = "";
        var targetReg = sharedRegisters.shadedTarget;
        var dataReg1 = registerCache.getFreeFragmentConstant();
        var dataReg2 = registerCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = dataReg1.index * 4;
        var temp1 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp1, 1);
        var temp2 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp2, 1);
        code += "div " + temp1 + ", " + sharedRegisters.projectionFragment + ", " + sharedRegisters.projectionFragment + ".w\n" +
            "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" +
            "frc " + temp1 + ", " + temp1 + "\n" +
            "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
        //codeF += "mov ft1.w, fc1.w	\n" +
        //    "mov ft0.w, fc0.x	\n";
        if (this._textureVO && this._shader.alphaThreshold > 0) {
            var albedo = registerCache.getFreeFragmentVectorTemp();
            code += this._textureVO._getFragmentCode(albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);
            var cutOffReg = registerCache.getFreeFragmentConstant();
            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" +
                "kil " + albedo + ".w\n";
        }
        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
        registerCache.removeFragmentTempUsage(temp1);
        registerCache.removeFragmentTempUsage(temp2);
        return code;
    };
    /**
     * @inheritDoc
     */
    GL_DepthMaterial.prototype._activate = function (projection) {
        _super.prototype._activate.call(this, projection);
        if (this._textureVO && this._shader.alphaThreshold > 0) {
            this._textureVO.activate();
            this._shader.fragmentConstantData[this._fragmentConstantsIndex + 8] = this._shader.alphaThreshold;
        }
    };
    return GL_DepthMaterial;
}(_awayjs_stage.GL_MaterialPassBase));

/**
 * DistanceRender is a pass that writes distance values to a depth map as a 32-bit value exploded over the 4 texture channels.
 * This is used to render omnidirectional shadow maps.
 */
var GL_DistanceMaterial = (function (_super) {
    __extends(GL_DistanceMaterial, _super);
    /**
     * Creates a new DistanceRender object.
     *
     * @param material The material to which this pass belongs.
     */
    function GL_DistanceMaterial(material, materialPool) {
        var _this = _super.call(this, material, materialPool) || this;
        _this._shader = new _awayjs_stage.ShaderBase(materialPool.elementsClass, _this, _this._stage);
        _this._pAddPass(_this);
        return _this;
    }
    GL_DistanceMaterial.prototype.invalidate = function () {
        _super.prototype.invalidate.call(this);
        this._textureVO = this._material.getTextureAt(0) ? this._shader.getAbstraction(this._material.getTextureAt(0)) : null;
    };
    /**
     * Initializes the unchanging constant data for this material.
     */
    GL_DistanceMaterial.prototype._initConstantData = function (shader) {
        _super.prototype._initConstantData.call(this, shader);
        var index = this._fragmentConstantsIndex;
        var data = shader.fragmentConstantData;
        data[index + 4] = 1.0 / 255.0;
        data[index + 5] = 1.0 / 255.0;
        data[index + 6] = 1.0 / 255.0;
        data[index + 7] = 0.0;
    };
    GL_DistanceMaterial.prototype._includeDependencies = function (shader) {
        _super.prototype._includeDependencies.call(this, shader);
        shader.projectionDependencies++;
        shader.viewDirDependencies++;
        if (shader.alphaThreshold > 0)
            shader.uvDependencies++;
        if (shader.viewDirDependencies > 0)
            shader.globalPosDependencies++;
    };
    /**
     * @inheritDoc
     */
    GL_DistanceMaterial.prototype._getFragmentCode = function (registerCache, sharedRegisters) {
        var code;
        var targetReg = sharedRegisters.shadedTarget;
        var dataReg1 = registerCache.getFreeFragmentConstant();
        var dataReg2 = registerCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = dataReg1.index * 4;
        var temp1 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp1, 1);
        var temp2 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp2, 1);
        // squared distance to view
        code = "dp3 " + temp1 + ".z, " + sharedRegisters.viewDirVarying + ".xyz, " + sharedRegisters.viewDirVarying + ".xyz\n" +
            "mul " + temp1 + ", " + dataReg1 + ", " + temp1 + ".z\n" +
            "frc " + temp1 + ", " + temp1 + "\n" +
            "mul " + temp2 + ", " + temp1 + ".yzww, " + dataReg2 + "\n";
        if (this._textureVO && this._shader.alphaThreshold > 0) {
            var albedo = registerCache.getFreeFragmentVectorTemp();
            code += this._textureVO._getFragmentCode(albedo, registerCache, sharedRegisters, sharedRegisters.uvVarying);
            var cutOffReg = registerCache.getFreeFragmentConstant();
            code += "sub " + albedo + ".w, " + albedo + ".w, " + cutOffReg + ".x\n" +
                "kil " + albedo + ".w\n";
        }
        code += "sub " + targetReg + ", " + temp1 + ", " + temp2 + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    GL_DistanceMaterial.prototype._activate = function (projection) {
        _super.prototype._activate.call(this, projection);
        var f = projection.far;
        f = 1 / (2 * f * f);
        // sqrt(f*f+f*f) is largest possible distance for any frustum, so we need to divide by it. Rarely a tight fit, but with 32 bits precision, it's enough.
        var index = this._fragmentConstantsIndex;
        var data = this._shader.fragmentConstantData;
        data[index] = 1.0 * f;
        data[index + 1] = 255.0 * f;
        data[index + 2] = 65025.0 * f;
        data[index + 3] = 16581375.0 * f;
        if (this._textureVO && this._shader.alphaThreshold > 0) {
            this._textureVO.activate();
            data[index + 8] = this._shader.alphaThreshold;
        }
    };
    return GL_DistanceMaterial;
}(_awayjs_stage.GL_MaterialPassBase));

var RendererEvent = (function (_super) {
    __extends(RendererEvent, _super);
    function RendererEvent(type) {
        return _super.call(this, type) || this;
    }
    return RendererEvent;
}(_awayjs_core.EventBase));
RendererEvent.VIEWPORT_UPDATED = "viewportUpdated";
RendererEvent.SCISSOR_UPDATED = "scissorUpdated";

/**
 * @class away.sort.RenderableMergeSort
 */
var RenderableMergeSort = (function () {
    function RenderableMergeSort() {
    }
    RenderableMergeSort.prototype.sortBlendedRenderables = function (head) {
        var headB;
        var fast;
        var slow;
        if (!head || !head.next) {
            return head;
        }
        // split in two sublists
        slow = head;
        fast = head.next;
        while (fast) {
            fast = fast.next;
            if (fast) {
                slow = slow.next;
                fast = fast.next;
            }
        }
        headB = slow.next;
        slow.next = null;
        // recurse
        head = this.sortBlendedRenderables(head);
        headB = this.sortBlendedRenderables(headB);
        // merge sublists while respecting order
        var result;
        var curr;
        var l;
        if (!head)
            return headB;
        if (!headB)
            return head;
        while (head && headB) {
            if (head.zIndex < headB.zIndex) {
                l = head;
                head = head.next;
            }
            else {
                l = headB;
                headB = headB.next;
            }
            if (!result)
                result = l;
            else
                curr.next = l;
            curr = l;
        }
        if (head)
            curr.next = head;
        else if (headB)
            curr.next = headB;
        return result;
    };
    RenderableMergeSort.prototype.sortOpaqueRenderables = function (head) {
        var headB;
        var fast, slow;
        if (!head || !head.next) {
            return head;
        }
        // split in two sublists
        slow = head;
        fast = head.next;
        while (fast) {
            fast = fast.next;
            if (fast) {
                slow = slow.next;
                fast = fast.next;
            }
        }
        headB = slow.next;
        slow.next = null;
        // recurse
        head = this.sortOpaqueRenderables(head);
        headB = this.sortOpaqueRenderables(headB);
        // merge sublists while respecting order
        var result;
        var curr;
        var l;
        var cmp = 0;
        if (!head)
            return headB;
        if (!headB)
            return head;
        while (head && headB && head != null && headB != null) {
            // first sort per render order id (reduces program3D switches),
            // then on render object id (reduces setting props),
            // then on zIndex (reduces overdraw)
            var aid = head.renderOrderId;
            var bid = headB.renderOrderId;
            if (aid == bid) {
                var ma = head.materialID;
                var mb = headB.materialID;
                if (ma == mb) {
                    if (head.zIndex < headB.zIndex)
                        cmp = 1;
                    else
                        cmp = -1;
                }
                else if (ma > mb) {
                    cmp = 1;
                }
                else {
                    cmp = -1;
                }
            }
            else if (aid > bid) {
                cmp = 1;
            }
            else {
                cmp = -1;
            }
            if (cmp < 0) {
                l = head;
                head = head.next;
            }
            else {
                l = headB;
                headB = headB.next;
            }
            if (!result) {
                result = l;
                curr = l;
            }
            else {
                curr.next = l;
                curr = l;
            }
        }
        if (head)
            curr.next = head;
        else if (headB)
            curr.next = headB;
        return result;
    };
    return RenderableMergeSort;
}());

/**
 * RendererBase forms an abstract base class for classes that are used in the rendering pipeline to render the
 * contents of a partition
 *
 * @class away.render.RendererBase
 */
var RendererBase = (function (_super) {
    __extends(RendererBase, _super);
    /**
     * Creates a new RendererBase object.
     */
    function RendererBase(stage, forceSoftware, profile, mode) {
        if (stage === void 0) { stage = null; }
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = _awayjs_stage.ContextGLProfile.BASELINE; }
        if (mode === void 0) { mode = _awayjs_stage.ContextMode.AUTO; }
        var _this = _super.call(this) || this;
        _this._activeMasksConfig = new Array();
        _this._registeredMasks = new Array();
        _this._numUsedStreams = 0;
        _this._numUsedTextures = 0;
        _this._cameraForward = new _awayjs_core.Vector3D();
        _this._pBackBufferInvalid = true;
        _this._pDepthTextureInvalid = true;
        _this._depthPrepass = false;
        _this._backgroundR = 0;
        _this._backgroundG = 0;
        _this._backgroundB = 0;
        _this._backgroundAlpha = 1;
        // only used by renderers that need to render geometry to textures
        _this._width = 0;
        _this._height = 0;
        _this.textureRatioX = 1;
        _this.textureRatioY = 1;
        _this._x = 0;
        _this._y = 0;
        _this._pScissorRect = new _awayjs_core.Rectangle();
        _this._pNumElements = 0;
        _this._disableColor = false;
        _this._disableClear = false;
        _this._renderBlended = true;
        _this._numCullPlanes = 0;
        _this._onViewportUpdatedDelegate = function (event) { return _this.onViewportUpdated(event); };
        _this._onContextUpdateDelegate = function (event) { return _this.onContextUpdate(event); };
        //default sorting algorithm
        _this.renderableSorter = new RenderableMergeSort();
        //set stage
        _this._pStage = stage || _awayjs_stage.StageManager.getInstance().getFreeStage(forceSoftware, profile, mode);
        _this._pStage.addEventListener(_awayjs_stage.StageEvent.CONTEXT_CREATED, _this._onContextUpdateDelegate);
        _this._pStage.addEventListener(_awayjs_stage.StageEvent.CONTEXT_RECREATED, _this._onContextUpdateDelegate);
        _this._pStage.addEventListener(_awayjs_stage.StageEvent.VIEWPORT_UPDATED, _this._onViewportUpdatedDelegate);
        /*
         if (_backgroundImageRenderer)
         _backgroundImageRenderer.stage = value;
         */
        if (_this._pStage.context)
            _this._pContext = _this._pStage.context;
        return _this;
    }
    Object.defineProperty(RendererBase.prototype, "cullPlanes", {
        /**
         *
         */
        get: function () {
            return this._customCullPlanes;
        },
        set: function (value) {
            this._customCullPlanes = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "renderBlended", {
        get: function () {
            return this._renderBlended;
        },
        set: function (value) {
            this._renderBlended = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "disableColor", {
        get: function () {
            return this._disableColor;
        },
        set: function (value) {
            this._disableColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "disableClear", {
        get: function () {
            return this._disableClear;
        },
        set: function (value) {
            this._disableClear = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "numElements", {
        /**
         *
         */
        get: function () {
            return this._pNumElements;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "viewPort", {
        /**
         * A viewPort rectangle equivalent of the Stage size and position.
         */
        get: function () {
            return this._pStage.viewPort;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "scissorRect", {
        /**
         * A scissor rectangle equivalent of the view size and position.
         */
        get: function () {
            if (this._scissorDirty) {
                this._scissorDirty = false;
                if (this.shareContext) {
                    this._pScissorRect.x = this._x - this._pStage.viewPort.x;
                    this._pScissorRect.y = this._y - this._pStage.viewPort.y;
                }
                else {
                    this._pScissorRect.x = 0;
                    this._pScissorRect.y = 0;
                }
            }
            return this._pScissorRect;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "x", {
        /**
         *
         */
        get: function () {
            return this._x;
        },
        set: function (value) {
            if (this._x == value)
                return;
            this._x = value;
            if (!this.shareContext)
                this._pStage.x = value;
            this.notifyScissorUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "y", {
        /**
         *
         */
        get: function () {
            return this._y;
        },
        set: function (value) {
            if (this._y == value)
                return;
            this._y = value;
            if (!this.shareContext)
                this._pStage.y = value;
            this.notifyScissorUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "width", {
        /**
         *
         */
        get: function () {
            return this._width;
        },
        set: function (value) {
            if (this._width == value)
                return;
            this._width = value;
            this._pScissorRect.width = value;
            if (this._pRttBufferManager)
                this._pRttBufferManager.viewWidth = value;
            if (!this.shareContext) {
                this._pBackBufferInvalid = true;
                this._pDepthTextureInvalid = true;
            }
            this.notifyScissorUpdate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "height", {
        /**
         *
         */
        get: function () {
            return this._height;
        },
        set: function (value) {
            if (this._height == value)
                return;
            this._height = value;
            this._pScissorRect.height = value;
            if (this._pRttBufferManager)
                this._pRttBufferManager.viewHeight = value;
            if (!this.shareContext) {
                this._pBackBufferInvalid = true;
                this._pDepthTextureInvalid = true;
            }
            this.notifyScissorUpdate();
        },
        enumerable: true,
        configurable: true
    });
    RendererBase.prototype.activatePass = function (pass, projection) {
        //clear unused vertex streams
        var i;
        for (i = pass.shader.numUsedStreams; i < this._numUsedStreams; i++)
            this._pContext.setVertexBufferAt(i, null);
        //clear unused texture streams
        for (i = pass.shader.numUsedTextures; i < this._numUsedTextures; i++)
            this._pContext.setTextureAt(i, null);
        //check program data is uploaded
        var programData = pass.shader.programData;
        if (!programData.program) {
            programData.program = this._pContext.createProgram();
            var vertexByteCode = (new _awayjs_stage.AGALMiniAssembler().assemble("part vertex 1\n" + programData.vertexString + "endpart"))['vertex'].data;
            var fragmentByteCode = (new _awayjs_stage.AGALMiniAssembler().assemble("part fragment 1\n" + programData.fragmentString + "endpart"))['fragment'].data;
            programData.program.upload(vertexByteCode, fragmentByteCode);
        }
        //set program data
        this._pContext.setProgram(programData.program);
        //activate shader object through pass
        pass._activate(projection);
    };
    RendererBase.prototype.deactivatePass = function (pass) {
        //deactivate shader object through pass
        pass._deactivate();
        this._numUsedStreams = pass.shader.numUsedStreams;
        this._numUsedTextures = pass.shader.numUsedTextures;
    };
    Object.defineProperty(RendererBase.prototype, "_iBackgroundR", {
        /**
         * The background color's red component, used when clearing.
         *
         * @private
         */
        get: function () {
            return this._backgroundR;
        },
        set: function (value) {
            if (this._backgroundR == value)
                return;
            this._backgroundR = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "_iBackgroundG", {
        /**
         * The background color's green component, used when clearing.
         *
         * @private
         */
        get: function () {
            return this._backgroundG;
        },
        set: function (value) {
            if (this._backgroundG == value)
                return;
            this._backgroundG = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "_iBackgroundB", {
        /**
         * The background color's blue component, used when clearing.
         *
         * @private
         */
        get: function () {
            return this._backgroundB;
        },
        set: function (value) {
            if (this._backgroundB == value)
                return;
            this._backgroundB = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "context", {
        get: function () {
            return this._pContext;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RendererBase.prototype, "stage", {
        /**
         * The Stage that will provide the ContextGL used for rendering.
         */
        get: function () {
            return this._pStage;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the resources used by the RendererBase.
     */
    RendererBase.prototype.dispose = function () {
        this._pStage.removeEventListener(_awayjs_stage.StageEvent.CONTEXT_CREATED, this._onContextUpdateDelegate);
        this._pStage.removeEventListener(_awayjs_stage.StageEvent.CONTEXT_RECREATED, this._onContextUpdateDelegate);
        this._pStage.removeEventListener(_awayjs_stage.StageEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
        this._pStage = null;
        this._pContext = null;
        /*
         if (_backgroundImageRenderer) {
         _backgroundImageRenderer.dispose();
         _backgroundImageRenderer = null;
         }
         */
    };
    RendererBase.prototype.render = function (view) {
    };
    /**
     * Renders the potentially visible geometry to the back buffer or texture.
     * @param target An option target texture to render to.
     * @param surfaceSelector The index of a CubeTexture's face to render to.
     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
     */
    RendererBase.prototype._iRender = function (projection, view, target, scissorRect, surfaceSelector) {
        if (target === void 0) { target = null; }
        if (scissorRect === void 0) { scissorRect = null; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        //TODO refactor setTarget so that rendertextures are created before this check
        if (!this._pStage || !this._pContext)
            return;
        //reset head values
        this._pBlendedRenderableHead = null;
        this._pOpaqueRenderableHead = null;
        this._pNumElements = 0;
        this._cameraTransform = projection.transform.concatenatedMatrix3D;
        this._cameraForward = projection.transform.forwardVector;
        this._cullPlanes = this._customCullPlanes ? this._customCullPlanes : projection.frustumPlanes;
        this._numCullPlanes = this._cullPlanes ? this._cullPlanes.length : 0;
        RendererBase._iCollectionMark++;
        view.traversePartitions(this);
        //sort the resulting renderables
        if (this.renderableSorter) {
            this._pOpaqueRenderableHead = this.renderableSorter.sortOpaqueRenderables(this._pOpaqueRenderableHead);
            this._pBlendedRenderableHead = this.renderableSorter.sortBlendedRenderables(this._pBlendedRenderableHead);
        }
        // this._pRttViewProjectionMatrix.copyFrom(projection.viewMatrix3D);
        // this._pRttViewProjectionMatrix.appendScale(this.textureRatioX, this.textureRatioY, 1);
        this.pExecuteRender(projection, view, target, scissorRect, surfaceSelector);
        // invalidate mipmaps (if target exists) to regenerate if required
        if (target)
            target.invalidateMipmaps();
        // clear buffers
        for (var i = 0; i < 8; ++i) {
            this._pContext.setVertexBufferAt(i, null);
            this._pContext.setTextureAt(i, null);
        }
    };
    RendererBase.prototype._iRenderCascades = function (projection, view, target, numCascades, scissorRects, projections) {
        this._pStage.setRenderTarget(target, true, 0);
        this._pContext.clear(1, 1, 1, 1, 1, 0);
        this._pContext.setBlendFactors(_awayjs_stage.ContextGLBlendFactor.ONE, _awayjs_stage.ContextGLBlendFactor.ZERO);
        this._pContext.setDepthTest(true, _awayjs_stage.ContextGLCompareMode.LESS);
        var head = this._pOpaqueRenderableHead;
        var first = true;
        //TODO cascades must have separate collectors, rather than separate draw commands
        for (var i = numCascades - 1; i >= 0; --i) {
            this._pStage.scissorRect = scissorRects[i];
            //this.drawCascadeRenderables(head, cameras[i], first? null : cameras[i].frustumPlanes);
            first = false;
        }
        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
        this._pContext.setDepthTest(false, _awayjs_stage.ContextGLCompareMode.LESS_EQUAL);
        this._pStage.scissorRect = null;
    };
    /**
     * Renders the potentially visible geometry to the back buffer or texture. Only executed if everything is set up.
     *
     * @param target An option target texture to render to.
     * @param surfaceSelector The index of a CubeTexture's face to render to.
     * @param additionalClearMask Additional clear mask information, in case extra clear channels are to be omitted.
     */
    RendererBase.prototype.pExecuteRender = function (projection, view, target, scissorRect, surfaceSelector) {
        if (target === void 0) { target = null; }
        if (scissorRect === void 0) { scissorRect = null; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        this._pStage.setRenderTarget(target, true, surfaceSelector);
        if ((target || !this.shareContext) && !this._depthPrepass && !this._disableClear)
            this._pContext.clear(this._backgroundR, this._backgroundG, this._backgroundB, this._backgroundAlpha, 1, 0);
        this._pStage.scissorRect = scissorRect;
        /*
         if (_backgroundImageRenderer)
         _backgroundImageRenderer.render();
         */
        this._pContext.setBlendFactors(_awayjs_stage.ContextGLBlendFactor.ONE, _awayjs_stage.ContextGLBlendFactor.ZERO);
        this.pDraw(projection);
        //line required for correct rendering when using away3d with starling. DO NOT REMOVE UNLESS STARLING INTEGRATION IS RETESTED!
        //this._pContext.setDepthTest(false, ContextGLCompareMode.LESS_EQUAL); //oopsie
        if (target || !this.shareContext) {
            if (this._snapshotRequired && this._snapshotBitmapImage2D) {
                this._pContext.drawToBitmapImage2D(this._snapshotBitmapImage2D);
                this._snapshotRequired = false;
            }
        }
        this._pStage.scissorRect = null;
    };
    /*
     * Will draw the renderer's output on next render to the provided bitmap data.
     * */
    RendererBase.prototype.queueSnapshot = function (bmd) {
        this._snapshotRequired = true;
        this._snapshotBitmapImage2D = bmd;
    };
    /**
     * Performs the actual drawing of geometry to the target.
     */
    RendererBase.prototype.pDraw = function (projection) {
        this._pContext.setDepthTest(true, _awayjs_stage.ContextGLCompareMode.LESS_EQUAL);
        if (this._disableColor)
            this._pContext.setColorMask(false, false, false, false);
        this.drawRenderables(projection, this._pOpaqueRenderableHead);
        if (this._renderBlended)
            this.drawRenderables(projection, this._pBlendedRenderableHead);
        if (this._disableColor)
            this._pContext.setColorMask(true, true, true, true);
    };
    //private drawCascadeRenderables(renderableGL:GL_RenderableBase, camera:Camera, cullPlanes:Array<Plane3D>)
    //{
    //	var renderableGL2:GL_RenderableBase;
    //	var render:GL_MaterialBase;
    //	var pass:IPass;
    //
    //	while (renderableGL) {
    //		renderableGL2 = renderableGL;
    //		render = renderableGL.render;
    //		pass = render.passes[0] //assuming only one pass per material
    //
    //		this.activatePass(renderableGL, pass, camera);
    //
    //		do {
    //			// if completely in front, it will fall in a different cascade
    //			// do not use near and far planes
    //			if (!cullPlanes || renderableGL2.sourceEntity.worldBounds.isInFrustum(cullPlanes, 4)) {
    //				renderableGL2._iRender(pass, camera, this._pRttViewProjectionMatrix);
    //			} else {
    //				renderableGL2.cascaded = true;
    //			}
    //
    //			renderableGL2 = renderableGL2.next;
    //
    //		} while (renderableGL2 && renderableGL2.render == render && !renderableGL2.cascaded);
    //
    //		this.deactivatePass(renderableGL, pass);
    //
    //		renderableGL = renderableGL2;
    //	}
    //}
    /**
     * Draw a list of renderables.
     *
     * @param renderables The renderables to draw.
     */
    RendererBase.prototype.drawRenderables = function (projection, renderableGL) {
        var i;
        var len;
        var renderableGL2;
        var materialGL;
        var passes;
        var pass;
        this._pContext.setStencilActions(_awayjs_stage.ContextGLTriangleFace.FRONT_AND_BACK, _awayjs_stage.ContextGLCompareMode.ALWAYS, _awayjs_stage.ContextGLStencilAction.KEEP, _awayjs_stage.ContextGLStencilAction.KEEP, _awayjs_stage.ContextGLStencilAction.KEEP);
        this._registeredMasks.length = 0;
        //var gl = this._pContext["_gl"];
        //if(gl) {
        //gl.disable(gl.STENCIL_TEST);
        //}
        this._pContext.disableStencil();
        this._maskConfig = 0;
        while (renderableGL) {
            materialGL = renderableGL.materialGL;
            passes = materialGL.passes;
            // otherwise this would result in depth rendered anyway because fragment shader kil is ignored
            if (this._disableColor && materialGL._material.alphaThreshold != 0) {
                renderableGL2 = renderableGL;
                // fast forward
                do {
                    renderableGL2 = renderableGL2.next;
                } while (renderableGL2 && renderableGL2.materialGL == materialGL);
            }
            else {
                if (this._activeMasksDirty || this._checkMasksConfig(renderableGL.masksConfig)) {
                    this._activeMasksConfig = renderableGL.masksConfig;
                    if (!this._activeMasksConfig.length) {
                        // disable stencil
                        //if(gl) {
                        //gl.disable(gl.STENCIL_TEST);
                        this._pContext.disableStencil();
                        //gl.stencilFunc(gl.ALWAYS, 0, 0xff);
                        //gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
                        this._pContext.setStencilActions(_awayjs_stage.ContextGLTriangleFace.FRONT_AND_BACK, _awayjs_stage.ContextGLCompareMode.ALWAYS, _awayjs_stage.ContextGLStencilAction.KEEP, _awayjs_stage.ContextGLStencilAction.KEEP, _awayjs_stage.ContextGLStencilAction.KEEP);
                        this._pContext.setStencilReferenceValue(0);
                    }
                    else {
                        this._renderMasks(projection, renderableGL.sourceEntity._iAssignedMasks());
                    }
                    this._activeMasksDirty = false;
                }
                //iterate through each shader object
                len = passes.length;
                for (i = 0; i < len; i++) {
                    renderableGL2 = renderableGL;
                    pass = passes[i];
                    this.activatePass(pass, projection);
                    do {
                        if (renderableGL2.maskId !== -1) {
                            if (i == 0)
                                this._registerMask(renderableGL2);
                        }
                        else {
                            renderableGL2._iRender(pass, projection);
                        }
                        renderableGL2 = renderableGL2.next;
                    } while (renderableGL2 && renderableGL2.materialGL == materialGL && !(this._activeMasksDirty = this._checkMasksConfig(renderableGL2.masksConfig)));
                    this.deactivatePass(pass);
                }
            }
            renderableGL = renderableGL2;
        }
    };
    /**
     * Assign the context once retrieved
     */
    RendererBase.prototype.onContextUpdate = function (event) {
        this._pContext = this._pStage.context;
    };
    Object.defineProperty(RendererBase.prototype, "_iBackgroundAlpha", {
        get: function () {
            return this._backgroundAlpha;
        },
        set: function (value) {
            if (this._backgroundAlpha == value)
                return;
            this._backgroundAlpha = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    /*
     public get iBackground():Texture2DBase
     {
     return this._background;
     }
     */
    /*
     public set iBackground(value:Texture2DBase)
     {
     if (this._backgroundImageRenderer && !value) {
     this._backgroundImageRenderer.dispose();
     this._backgroundImageRenderer = null;
     }

     if (!this._backgroundImageRenderer && value)
     {

     this._backgroundImageRenderer = new BackgroundImageRenderer(this._pStage);

     }


     this._background = value;

     if (this._backgroundImageRenderer)
     this._backgroundImageRenderer.texture = value;
     }
     */
    /*
     public get backgroundImageRenderer():BackgroundImageRenderer
     {
     return _backgroundImageRenderer;
     }
     */
    /**
     * @private
     */
    RendererBase.prototype.notifyScissorUpdate = function () {
        if (this._scissorDirty)
            return;
        this._scissorDirty = true;
        if (!this._scissorUpdated)
            this._scissorUpdated = new RendererEvent(RendererEvent.SCISSOR_UPDATED);
        this.dispatchEvent(this._scissorUpdated);
    };
    /**
     * @private
     */
    RendererBase.prototype.notifyViewportUpdate = function () {
        if (!this._viewPortUpdated)
            this._viewPortUpdated = new RendererEvent(RendererEvent.VIEWPORT_UPDATED);
        this.dispatchEvent(this._viewPortUpdated);
    };
    /**
     *
     */
    RendererBase.prototype.onViewportUpdated = function (event) {
        if (this.shareContext)
            this.notifyScissorUpdate();
        this.notifyViewportUpdate();
    };
    /**
     *
     * @param node
     * @returns {boolean}
     */
    RendererBase.prototype.enterNode = function (node) {
        var enter = node._iCollectionMark != RendererBase._iCollectionMark && node.isRenderable() && node.isInFrustum(this._cullPlanes, this._numCullPlanes);
        node._iCollectionMark = RendererBase._iCollectionMark;
        return enter;
    };
    RendererBase.prototype.applyEntity = function (entity) {
        this._sourceEntity = entity;
        this._renderablePool = this._materialGroup.getRenderablePool(entity);
        // project onto camera's z-axis
        this._zIndex = entity.zOffset + this._cameraTransform.position.subtract(entity.scenePosition).dotProduct(this._cameraForward);
        //save sceneTransform
        this._renderSceneTransform = entity.getRenderSceneTransform(this._cameraTransform);
        //collect renderables
        entity._acceptTraverser(this);
    };
    RendererBase.prototype.applyRenderable = function (renderable) {
        var renderableGL = this._renderablePool.getAbstraction(renderable);
        //set local vars for faster referencing
        renderableGL.cascaded = false;
        renderableGL.zIndex = this._zIndex;
        renderableGL.maskId = this._sourceEntity._iAssignedMaskId();
        renderableGL.masksConfig = this._sourceEntity._iMasksConfig();
        var materialGL = renderableGL.materialGL;
        renderableGL.materialID = materialGL.materialID;
        renderableGL.renderOrderId = materialGL.renderOrderId;
        //store reference to scene transform
        renderableGL.renderSceneTransform = this._renderSceneTransform;
        if (materialGL.requiresBlending) {
            renderableGL.next = this._pBlendedRenderableHead;
            this._pBlendedRenderableHead = renderableGL;
        }
        else {
            renderableGL.next = this._pOpaqueRenderableHead;
            this._pOpaqueRenderableHead = renderableGL;
        }
        this._pNumElements += renderableGL.elementsGL.elements.numElements;
    };
    /**
     *
     * @param entity
     */
    RendererBase.prototype.applyDirectionalLight = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    RendererBase.prototype.applyLightProbe = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    RendererBase.prototype.applyPointLight = function (entity) {
        //don't do anything here
    };
    RendererBase.prototype._registerMask = function (obj) {
        //console.log("registerMask");
        this._registeredMasks.push(obj);
    };
    RendererBase.prototype._renderMasks = function (projection, masks) {
        //var gl = this._pContext["_gl"];
        //f (!gl)
        //	return;
        //var oldRenderTarget = this._stage.renderTarget;
        //this._stage.setRenderTarget(this._image);
        //this._stage.clear();
        this._pContext.setColorMask(false, false, false, false);
        // TODO: Could we create masks within masks by providing a previous configID, and supply "clear/keep" on stencil fail
        //context.setStencilActions("frontAndBack", "always", "set", "set", "set");
        //gl.enable(gl.STENCIL_TEST);
        this._pContext.enableStencil();
        this._maskConfig++;
        //gl.stencilFunc(gl.ALWAYS, this._maskConfig, 0xff);
        //gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);
        this._pContext.setStencilActions(_awayjs_stage.ContextGLTriangleFace.FRONT_AND_BACK, _awayjs_stage.ContextGLCompareMode.ALWAYS, _awayjs_stage.ContextGLStencilAction.SET, _awayjs_stage.ContextGLStencilAction.SET, _awayjs_stage.ContextGLStencilAction.SET);
        this._pContext.setStencilReferenceValue(this._maskConfig);
        var numLayers = masks.length;
        var numRenderables = this._registeredMasks.length;
        var renderableGL;
        var children;
        var numChildren;
        var mask;
        for (var i = 0; i < numLayers; ++i) {
            if (i != 0) {
                //gl.stencilFunc(gl.EQUAL, this._maskConfig, 0xff);
                //gl.stencilOp(gl.KEEP, gl.INCR, gl.INCR);
                this._pContext.setStencilActions(_awayjs_stage.ContextGLTriangleFace.FRONT_AND_BACK, _awayjs_stage.ContextGLCompareMode.EQUAL, _awayjs_stage.ContextGLStencilAction.INCREMENT_SATURATE, _awayjs_stage.ContextGLStencilAction.INCREMENT_SATURATE, _awayjs_stage.ContextGLStencilAction.KEEP);
                this._pContext.setStencilReferenceValue(this._maskConfig);
                this._maskConfig++;
            }
            children = masks[i];
            numChildren = children.length;
            for (var j = 0; j < numChildren; ++j) {
                mask = children[j];
                for (var k = 0; k < numRenderables; ++k) {
                    renderableGL = this._registeredMasks[k];
                    //console.log("testing for " + mask["hierarchicalMaskID"] + ", " + mask.name);
                    if (renderableGL.maskId == mask.id) {
                        //console.log("Rendering hierarchicalMaskID " + mask["hierarchicalMaskID"]);
                        this._drawMask(projection, renderableGL);
                    }
                }
            }
        }
        //gl.stencilFunc(gl.EQUAL, this._maskConfig, 0xff);
        //gl.stencilOp(gl.KEEP, gl.KEEP, gl.KEEP);
        this._pContext.setStencilActions(_awayjs_stage.ContextGLTriangleFace.FRONT_AND_BACK, _awayjs_stage.ContextGLCompareMode.EQUAL, _awayjs_stage.ContextGLStencilAction.KEEP, _awayjs_stage.ContextGLStencilAction.KEEP, _awayjs_stage.ContextGLStencilAction.KEEP);
        this._pContext.setStencilReferenceValue(this._maskConfig);
        this._pContext.setColorMask(true, true, true, true);
        this._pContext.setDepthTest(true, _awayjs_stage.ContextGLCompareMode.LESS_EQUAL);
        //this._stage.setRenderTarget(oldRenderTarget);
    };
    RendererBase.prototype._drawMask = function (projection, renderableGL) {
        var materialGL = renderableGL.materialGL;
        var passes = materialGL.passes;
        var len = passes.length;
        var pass = passes[len - 1];
        this.activatePass(pass, projection);
        this._pContext.setDepthTest(false, _awayjs_stage.ContextGLCompareMode.LESS_EQUAL); //TODO: setup so as not to override activate
        // only render last pass for now
        renderableGL._iRender(pass, projection);
        this.deactivatePass(pass);
    };
    RendererBase.prototype._checkMasksConfig = function (masksConfig) {
        if (this._activeMasksConfig.length != masksConfig.length)
            return true;
        var numLayers = masksConfig.length;
        var numChildren;
        var childConfig;
        var activeNumChildren;
        var activeChildConfig;
        for (var i = 0; i < numLayers; i++) {
            childConfig = masksConfig[i];
            numChildren = childConfig.length;
            activeChildConfig = this._activeMasksConfig[i];
            activeNumChildren = activeChildConfig.length;
            if (activeNumChildren != numChildren)
                return true;
            for (var j = 0; j < numChildren; j++) {
                if (activeChildConfig[j] != childConfig[j])
                    return true;
            }
        }
        return false;
    };
    return RendererBase;
}(_awayjs_graphics.TraverserBase));
RendererBase._iCollectionMark = 0;

/**
 * The DepthRenderer class renders 32-bit depth information encoded as RGBA
 *
 * @class away.render.DepthRenderer
 */
var DepthRenderer = (function (_super) {
    __extends(DepthRenderer, _super);
    /**
     * Creates a new DepthRenderer object.
     * @param renderBlended Indicates whether semi-transparent objects should be rendered.
     * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
     */
    function DepthRenderer(stage) {
        if (stage === void 0) { stage = null; }
        var _this = _super.call(this, stage) || this;
        _this._materialGroup = new _awayjs_stage.MaterialGroupBase(_this._pStage, DepthRenderer._abstractionClassPool);
        _this._iBackgroundR = 1;
        _this._iBackgroundG = 1;
        _this._iBackgroundB = 1;
        return _this;
    }
    /**
     *
     */
    DepthRenderer.prototype.enterNode = function (node) {
        var enter = node._iCollectionMark != RendererBase._iCollectionMark && node.isCastingShadow();
        if (!enter) {
            node._iCollectionMark = RendererBase._iCollectionMark;
            return false;
        }
        return _super.prototype.enterNode.call(this, node);
    };
    return DepthRenderer;
}(RendererBase));
DepthRenderer._abstractionClassPool = Object();

/**
 * The DistanceRenderer class renders 32-bit depth information encoded as RGBA
 *
 * @class away.render.DistanceRenderer
 */
var DistanceRenderer = (function (_super) {
    __extends(DistanceRenderer, _super);
    /**
     * Creates a new DistanceRenderer object.
     * @param renderBlended Indicates whether semi-transparent objects should be rendered.
     * @param distanceBased Indicates whether the written depth value is distance-based or projected depth-based
     */
    function DistanceRenderer(stage) {
        if (stage === void 0) { stage = null; }
        var _this = _super.call(this, stage) || this;
        _this._materialGroup = new _awayjs_stage.MaterialGroupBase(_this._pStage, DistanceRenderer._abstractionClassPool);
        _this._iBackgroundR = 1;
        _this._iBackgroundG = 1;
        _this._iBackgroundB = 1;
        return _this;
    }
    /**
     *
     */
    DistanceRenderer.prototype.enterNode = function (node) {
        var enter = node._iCollectionMark != RendererBase._iCollectionMark && node.isCastingShadow();
        if (!enter) {
            node._iCollectionMark = RendererBase._iCollectionMark;
            return false;
        }
        return _super.prototype.enterNode.call(this, node);
    };
    return DistanceRenderer;
}(RendererBase));
DistanceRenderer._abstractionClassPool = Object();

/**
 * @class away.pool.DefaultMaterialGroup
 */
var DefaultMaterialGroup = (function (_super) {
    __extends(DefaultMaterialGroup, _super);
    function DefaultMaterialGroup(stage) {
        return _super.call(this, stage, DefaultMaterialGroup._abstractionClassPool) || this;
    }
    /**
     *
     * @param imageObjectClass
     */
    DefaultMaterialGroup.registerAbstraction = function (materialClassGL, assetClass) {
        DefaultMaterialGroup._abstractionClassPool[assetClass.assetType] = materialClassGL;
        DepthRenderer._abstractionClassPool[assetClass.assetType] = GL_DepthMaterial;
        DistanceRenderer._abstractionClassPool[assetClass.assetType] = GL_DistanceMaterial;
    };
    return DefaultMaterialGroup;
}(_awayjs_stage.MaterialGroupBase));
DefaultMaterialGroup._abstractionClassPool = new Object();

/**
 * @class away.render.Filter3DRenderer
 */
var Filter3DRenderer = (function () {
    function Filter3DRenderer(stage) {
        var _this = this;
        this._filterSizesInvalid = true;
        this._onRTTResizeDelegate = function (event) { return _this.onRTTResize(event); };
        this._stage = stage;
        this._rttManager = RTTBufferManager.getInstance(stage);
        this._rttManager.addEventListener(RTTEvent.RESIZE, this._onRTTResizeDelegate);
        this._sampler = new _awayjs_graphics.Sampler2D(false, false, false);
        this._renderToTextureRect = new _awayjs_core.Rectangle();
    }
    Filter3DRenderer.prototype.onRTTResize = function (event) {
        this._filterSizesInvalid = true;
    };
    Object.defineProperty(Filter3DRenderer.prototype, "requireDepthRender", {
        get: function () {
            return this._requireDepthRender;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DRenderer.prototype.getMainInputTexture = function (stage) {
        if (this._filterTasksInvalid)
            this.updateFilterTasks(stage);
        return this._mainInputTexture;
    };
    Object.defineProperty(Filter3DRenderer.prototype, "filters", {
        get: function () {
            return this._filters;
        },
        set: function (value) {
            this._filters = value;
            this._filterTasksInvalid = true;
            this._requireDepthRender = false;
            if (!this._filters)
                return;
            for (var i = 0; i < this._filters.length; ++i)
                if (this._filters[i].requireDepthRender)
                    this._requireDepthRender = true;
            this._filterSizesInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DRenderer.prototype, "sampler", {
        get: function () {
            return this._sampler;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DRenderer.prototype, "renderToTextureRect", {
        get: function () {
            if (this._filterSizesInvalid)
                this.updateFilterSizes();
            return this._renderToTextureRect;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DRenderer.prototype.updateFilterTasks = function (stage) {
        var len;
        if (this._filterSizesInvalid)
            this.updateFilterSizes();
        if (!this._filters) {
            this._tasks = null;
            return;
        }
        this._tasks = new Array();
        len = this._filters.length - 1;
        var filter;
        for (var i = 0; i <= len; ++i) {
            // make sure all internal tasks are linked together
            filter = this._filters[i];
            filter.setRenderTargets(i == len ? null : this._filters[i + 1].getMainInputTexture(stage), stage);
            this._tasks = this._tasks.concat(filter.tasks);
        }
        this._mainInputTexture = this._filters[0].getMainInputTexture(stage);
    };
    Filter3DRenderer.prototype.render = function (stage, camera, depthTexture) {
        var len;
        var i;
        var task;
        var context = stage.context;
        var indexBuffer = this._rttManager.indexBuffer;
        var vertexBuffer = this._rttManager.renderToTextureVertexBuffer;
        if (!this._filters)
            return;
        if (this._filterSizesInvalid)
            this.updateFilterSizes();
        if (this._filterTasksInvalid)
            this.updateFilterTasks(stage);
        len = this._filters.length;
        for (i = 0; i < len; ++i)
            this._filters[i].update(stage, camera);
        len = this._tasks.length;
        if (len > 1) {
            context.setProgram(this._tasks[0].getProgram(stage));
            context.setVertexBufferAt(this._tasks[0]._positionIndex, vertexBuffer, 0, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_2);
            context.setVertexBufferAt(this._tasks[0]._uvIndex, vertexBuffer, 8, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_2);
        }
        for (i = 0; i < len; ++i) {
            task = this._tasks[i];
            stage.setRenderTarget(task.target);
            context.setProgram(task.getProgram(stage));
            stage.getAbstraction(this._sampler).activate(task._inputTextureIndex);
            stage.getAbstraction(task.getMainInputTexture(stage)).activate(task._inputTextureIndex, this._sampler.mipmap);
            if (!task.target) {
                stage.scissorRect = null;
                vertexBuffer = this._rttManager.renderToScreenVertexBuffer;
                context.setVertexBufferAt(task._positionIndex, vertexBuffer, 0, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_2);
                context.setVertexBufferAt(task._uvIndex, vertexBuffer, 8, _awayjs_stage.ContextGLVertexBufferFormat.FLOAT_2);
            }
            context.clear(0.0, 0.0, 0.0, 0.0);
            task.activate(stage, camera, depthTexture);
            context.setBlendFactors(_awayjs_stage.ContextGLBlendFactor.ONE, _awayjs_stage.ContextGLBlendFactor.ZERO);
            context.drawIndices(_awayjs_stage.ContextGLDrawMode.TRIANGLES, indexBuffer, 0, 6);
            task.deactivate(stage);
        }
        context.setTextureAt(0, null);
        context.setVertexBufferAt(0, null);
        context.setVertexBufferAt(1, null);
    };
    Filter3DRenderer.prototype.updateFilterSizes = function () {
        for (var i = 0; i < this._filters.length; ++i) {
            this._filters[i].textureWidth = this._rttManager.textureWidth;
            this._filters[i].textureHeight = this._rttManager.textureHeight;
            this._filters[i].rttManager = this._rttManager;
        }
        var scale = this._filters[0].textureScale;
        this._renderToTextureRect.x = this._rttManager.renderToTextureRect.x / scale;
        this._renderToTextureRect.y = this._rttManager.renderToTextureRect.y / scale;
        this._renderToTextureRect.width = this._rttManager.renderToTextureRect.width / scale;
        this._renderToTextureRect.height = this._rttManager.renderToTextureRect.height / scale;
        this._filterSizesInvalid = false;
    };
    Filter3DRenderer.prototype.dispose = function () {
        this._rttManager.removeEventListener(RTTEvent.RESIZE, this._onRTTResizeDelegate);
        this._rttManager = null;
        this._stage = null;
    };
    return Filter3DRenderer;
}());

/**
 * The DefaultRenderer class provides the default rendering method. It renders the scene graph objects using the
 * materials assigned to them.
 *
 * @class away.render.DefaultRenderer
 */
var DefaultRenderer = (function (_super) {
    __extends(DefaultRenderer, _super);
    /**
     * Creates a new DefaultRenderer object.
     *
     * @param antiAlias The amount of anti-aliasing to use.
     * @param renderMode The render mode to use.
     */
    function DefaultRenderer(stage, forceSoftware, profile, mode) {
        if (stage === void 0) { stage = null; }
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = _awayjs_stage.ContextGLProfile.BASELINE; }
        if (mode === void 0) { mode = _awayjs_stage.ContextMode.AUTO; }
        var _this = _super.call(this, stage, forceSoftware, profile, mode) || this;
        _this._antiAlias = 0;
        _this._directionalLights = new Array();
        _this._pointLights = new Array();
        _this._lightProbes = new Array();
        if (stage)
            _this.shareContext = true;
        _this._materialGroup = new DefaultMaterialGroup(_this._pStage);
        _this._pRttBufferManager = RTTBufferManager.getInstance(_this._pStage);
        _this._depthRenderer = new DepthRenderer(_this._pStage);
        _this._distanceRenderer = new DistanceRenderer(_this._pStage);
        if (_this._width == 0)
            _this.width = window.innerWidth;
        else
            _this._pRttBufferManager.viewWidth = _this._width;
        if (_this._height == 0)
            _this.height = window.innerHeight;
        else
            _this._pRttBufferManager.viewHeight = _this._height;
        return _this;
    }
    Object.defineProperty(DefaultRenderer.prototype, "distanceRenderer", {
        get: function () {
            return this._distanceRenderer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderer.prototype, "depthRenderer", {
        get: function () {
            return this._depthRenderer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderer.prototype, "antiAlias", {
        get: function () {
            return this._antiAlias;
        },
        set: function (value) {
            if (this._antiAlias == value)
                return;
            this._antiAlias = value;
            this._pBackBufferInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderer.prototype, "depthPrepass", {
        /**
         *
         */
        get: function () {
            return this._depthPrepass;
        },
        set: function (value) {
            this._depthPrepass = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DefaultRenderer.prototype, "filters3d", {
        /**
         *
         * @returns {*}
         */
        get: function () {
            return this._pFilter3DRenderer ? this._pFilter3DRenderer.filters : null;
        },
        set: function (value) {
            if (value && value.length == 0)
                value = null;
            if (this._pFilter3DRenderer && !value) {
                this._pFilter3DRenderer.dispose();
                this._pFilter3DRenderer = null;
            }
            else if (!this._pFilter3DRenderer && value) {
                this._pFilter3DRenderer = new Filter3DRenderer(this._pStage);
                this._pFilter3DRenderer.filters = value;
            }
            if (this._pFilter3DRenderer) {
                this._pFilter3DRenderer.filters = value;
                this._pRequireDepthRender = this._pFilter3DRenderer.requireDepthRender;
            }
            else {
                this._pRequireDepthRender = false;
                if (this._pDepthRender) {
                    this._pDepthRender.dispose();
                    this._pDepthRender = null;
                }
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    DefaultRenderer.prototype.enterNode = function (node) {
        var enter = _super.prototype.enterNode.call(this, node);
        if (enter && node.debugVisible)
            node.renderBounds(this);
        return enter;
    };
    DefaultRenderer.prototype.render = function (view) {
        _super.prototype.render.call(this, view);
        if (!this._pStage.recoverFromDisposal()) {
            this._pBackBufferInvalid = true;
            return;
        }
        if (this._pBackBufferInvalid)
            this.pUpdateBackBuffer();
        if (this.shareContext && this._pContext)
            this._pContext.clear(0, 0, 0, 1, 1, 0, _awayjs_stage.ContextGLClearMask.DEPTH);
        if (this._pFilter3DRenderer) {
            this.textureRatioX = this._pRttBufferManager.textureRatioX;
            this.textureRatioY = this._pRttBufferManager.textureRatioY;
        }
        else {
            this.textureRatioX = 1;
            this.textureRatioY = 1;
        }
        if (this._pRequireDepthRender)
            this.pRenderSceneDepthToTexture(view);
        if (this._depthPrepass)
            this.pRenderDepthPrepass(view);
        //reset lights
        this._directionalLights.length = 0;
        this._pointLights.length = 0;
        this._lightProbes.length = 0;
        if (this._pFilter3DRenderer && this._pContext) {
            this._iRender(view.camera.projection, view, this._pFilter3DRenderer.getMainInputTexture(this._pStage), this._pFilter3DRenderer.renderToTextureRect);
            this._pFilter3DRenderer.render(this._pStage, view.camera, this._pDepthRender);
        }
        else {
            if (this.shareContext)
                this._iRender(view.camera.projection, view, null, this._pScissorRect);
            else
                this._iRender(view.camera.projection, view);
        }
        if (!this.shareContext && this._pContext)
            this._pContext.present();
        // register that a view has been rendered
        this._pStage.bufferClear = false;
    };
    DefaultRenderer.prototype.pExecuteRender = function (projection, view, target, scissorRect, surfaceSelector) {
        if (target === void 0) { target = null; }
        if (scissorRect === void 0) { scissorRect = null; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        this.updateLights(projection, view);
        _super.prototype.pExecuteRender.call(this, projection, view, target, scissorRect, surfaceSelector);
    };
    DefaultRenderer.prototype.updateLights = function (projection, view) {
        var len, i;
        var light;
        var shadowMapper;
        len = this._directionalLights.length;
        for (i = 0; i < len; ++i) {
            light = this._directionalLights[i];
            shadowMapper = light.shadowMapper;
            if (light.shadowsEnabled && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                shadowMapper.iRenderDepthMap(view, this._depthRenderer);
        }
        len = this._pointLights.length;
        for (i = 0; i < len; ++i) {
            light = this._pointLights[i];
            shadowMapper = light.shadowMapper;
            if (light.shadowsEnabled && (shadowMapper.autoUpdateShadows || shadowMapper._iShadowsInvalid))
                shadowMapper.iRenderDepthMap(view, this._distanceRenderer);
        }
    };
    /**
     *
     * @param entity
     */
    DefaultRenderer.prototype.applyDirectionalLight = function (entity) {
        this._directionalLights.push(entity);
    };
    /**
     *
     * @param entity
     */
    DefaultRenderer.prototype.applyLightProbe = function (entity) {
        this._lightProbes.push(entity);
    };
    /**
     *
     * @param entity
     */
    DefaultRenderer.prototype.applyPointLight = function (entity) {
        this._pointLights.push(entity);
    };
    DefaultRenderer.prototype.dispose = function () {
        if (!this.shareContext)
            this._pStage.dispose();
        this._pRttBufferManager.dispose();
        this._pRttBufferManager = null;
        this._depthRenderer.dispose();
        this._distanceRenderer.dispose();
        this._depthRenderer = null;
        this._distanceRenderer = null;
        this._pDepthRender = null;
        _super.prototype.dispose.call(this);
    };
    /**
     *
     */
    DefaultRenderer.prototype.pRenderDepthPrepass = function (view) {
        this._depthRenderer.disableColor = true;
        if (this._pFilter3DRenderer) {
            this._depthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
            this._depthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
            this._depthRenderer._iRender(view.camera.projection, view, this._pFilter3DRenderer.getMainInputTexture(this._pStage), this._pRttBufferManager.renderToTextureRect);
        }
        else {
            this._depthRenderer.textureRatioX = 1;
            this._depthRenderer.textureRatioY = 1;
            this._depthRenderer._iRender(view.camera.projection, view);
        }
        this._depthRenderer.disableColor = false;
    };
    /**
     *
     */
    DefaultRenderer.prototype.pRenderSceneDepthToTexture = function (view) {
        if (this._pDepthTextureInvalid || !this._pDepthRender)
            this.initDepthTexture(this._pStage.context);
        this._depthRenderer.textureRatioX = this._pRttBufferManager.textureRatioX;
        this._depthRenderer.textureRatioY = this._pRttBufferManager.textureRatioY;
        this._depthRenderer._iRender(view.camera.projection, view, this._pDepthRender);
    };
    /**
     * Updates the backbuffer dimensions.
     */
    DefaultRenderer.prototype.pUpdateBackBuffer = function () {
        // No reason trying to configure back buffer if there is no context available.
        // Doing this anyway (and relying on _stage to cache width/height for
        // context does get available) means usesSoftwareRendering won't be reliable.
        if (this._pStage.context && !this.shareContext) {
            if (this._width && this._height) {
                this._pStage.configureBackBuffer(this._width, this._height, this._antiAlias, true);
                this._pBackBufferInvalid = false;
            }
        }
    };
    /**
     *
     */
    DefaultRenderer.prototype.initDepthTexture = function (context) {
        this._pDepthTextureInvalid = false;
        if (this._pDepthRender)
            this._pDepthRender.dispose();
        this._pDepthRender = new _awayjs_graphics.BitmapImage2D(this._pRttBufferManager.textureWidth, this._pRttBufferManager.textureHeight);
    };
    return DefaultRenderer;
}(RendererBase));

/**
 *
 * @class away.pool.GL_LineElements
 */
var GL_LineElements = (function (_super) {
    __extends(GL_LineElements, _super);
    function GL_LineElements(lineElements, stage) {
        var _this = _super.call(this, lineElements, stage) || this;
        _this._calcMatrix = new _awayjs_core.Matrix3D();
        _this._thickness = 1.25;
        _this._lineElements = lineElements;
        return _this;
    }
    Object.defineProperty(GL_LineElements.prototype, "elementsType", {
        get: function () {
            return GL_LineElements.elementsType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_LineElements.prototype, "elementsClass", {
        get: function () {
            return GL_LineElements;
        },
        enumerable: true,
        configurable: true
    });
    GL_LineElements._includeDependencies = function (shader) {
        shader.colorDependencies++;
    };
    GL_LineElements._getVertexCode = function (shader, registerCache, sharedRegisters) {
        //get the projection coordinates
        var position0 = (shader.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.animatedPosition;
        var position1 = registerCache.getFreeVertexAttribute();
        var thickness = registerCache.getFreeVertexAttribute();
        //reserving vertex constants for projection matrix
        var viewMatrixReg = registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        shader.viewMatrixIndex = viewMatrixReg.index * 4;
        registerCache.getFreeVertexConstant(); // not used
        var constOne = registerCache.getFreeVertexConstant();
        var constNegOne = registerCache.getFreeVertexConstant();
        var misc = registerCache.getFreeVertexConstant();
        var sceneMatrixReg = registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        shader.sceneMatrixIndex = sceneMatrixReg.index * 4;
        var q0 = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(q0, 1);
        var q1 = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(q1, 1);
        var l = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(l, 1);
        var behind = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(behind, 1);
        var qclipped = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(qclipped, 1);
        var offset = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(offset, 1);
        return "m44 " + q0 + ", " + position0 + ", " + sceneMatrixReg + "			\n" +
            "m44 " + q1 + ", " + position1 + ", " + sceneMatrixReg + "			\n" +
            "sub " + l + ", " + q1 + ", " + q0 + " 			\n" +
            // test if behind camera near plane
            // if 0 - Q0.z < Camera.near then the point needs to be clipped
            "slt " + behind + ".x, " + q0 + ".z, " + misc + ".z			\n" +
            "sub " + behind + ".y, " + constOne + ".x, " + behind + ".x			\n" +
            // p = point on the plane (0,0,-near)
            // n = plane normal (0,0,-1)
            // D = Q1 - Q0
            // t = ( dot( n, ( p - Q0 ) ) / ( dot( n, d )
            // solve for t where line crosses Camera.near
            "add " + offset + ".x, " + q0 + ".z, " + misc + ".z			\n" +
            "sub " + offset + ".y, " + q0 + ".z, " + q1 + ".z			\n" +
            // fix divide by zero for horizontal lines
            "seq " + offset + ".z, " + offset + ".y " + constNegOne + ".x			\n" +
            "add " + offset + ".y, " + offset + ".y, " + offset + ".z			\n" +
            "div " + offset + ".z, " + offset + ".x, " + offset + ".y			\n" +
            "mul " + offset + ".xyz, " + offset + ".zzz, " + l + ".xyz	\n" +
            "add " + qclipped + ".xyz, " + q0 + ".xyz, " + offset + ".xyz	\n" +
            "mov " + qclipped + ".w, " + constOne + ".x			\n" +
            // If necessary, replace Q0 with new Qclipped
            "mul " + q0 + ", " + q0 + ", " + behind + ".yyyy			\n" +
            "mul " + qclipped + ", " + qclipped + ", " + behind + ".xxxx			\n" +
            "add " + q0 + ", " + q0 + ", " + qclipped + "				\n" +
            // calculate side vector for line
            "nrm " + l + ".xyz, " + l + ".xyz			\n" +
            "nrm " + behind + ".xyz, " + q0 + ".xyz			\n" +
            "mov " + behind + ".w, " + constOne + ".x				\n" +
            "crs " + qclipped + ".xyz, " + l + ", " + behind + "			\n" +
            "nrm " + qclipped + ".xyz, " + qclipped + ".xyz			\n" +
            // face the side vector properly for the given point
            "mul " + qclipped + ".xyz, " + qclipped + ".xyz, " + thickness + ".xxx	\n" +
            "mov " + qclipped + ".w, " + constOne + ".x			\n" +
            // calculate the amount required to move at the point's distance to correspond to the line's pixel width
            // scale the side vector by that amount
            "dp3 " + offset + ".x, " + q0 + ", " + constNegOne + "			\n" +
            "mul " + offset + ".x, " + offset + ".x, " + misc + ".x			\n" +
            "mul " + qclipped + ".xyz, " + qclipped + ".xyz, " + offset + ".xxx	\n" +
            // add scaled side vector to Q0 and transform to clip space
            "add " + q0 + ".xyz, " + q0 + ".xyz, " + qclipped + ".xyz	\n" +
            "m44 op, " + q0 + ", " + viewMatrixReg + "			\n"; // transform Q0 to clip space
    };
    GL_LineElements._getFragmentCode = function (shader, registerCache, sharedRegisters) {
        return "";
    };
    GL_LineElements.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._lineElements = null;
    };
    GL_LineElements.prototype._setRenderState = function (renderable, shader, projection) {
        _super.prototype._setRenderState.call(this, renderable, shader, projection);
        if (shader.colorBufferIndex >= 0)
            this.activateVertexBufferVO(shader.colorBufferIndex, this._lineElements.colors);
        this.activateVertexBufferVO(0, this._lineElements.positions, 3);
        this.activateVertexBufferVO(2, this._lineElements.positions, 3, 12);
        this.activateVertexBufferVO(3, this._lineElements.thickness);
        shader.vertexConstantData[4 + 16] = 1;
        shader.vertexConstantData[5 + 16] = 1;
        shader.vertexConstantData[6 + 16] = 1;
        shader.vertexConstantData[7 + 16] = 1;
        shader.vertexConstantData[10 + 16] = -1;
        shader.vertexConstantData[12 + 16] = this._thickness / ((this._stage.scissorRect) ? Math.min(this._stage.scissorRect.width, this._stage.scissorRect.height) : Math.min(this._stage.width, this._stage.height));
        shader.vertexConstantData[13 + 16] = 1 / 255;
        shader.vertexConstantData[14 + 16] = projection.near;
        var context = this._stage.context;
    };
    GL_LineElements.prototype.draw = function (renderable, shader, projection, count, offset) {
        var context = this._stage.context;
        // projection matrix
        shader.viewMatrix.copyFrom(projection.frustumMatrix3D, true);
        var matrix3D = _awayjs_core.Matrix3D.CALCULATION_MATRIX;
        matrix3D.copyFrom(renderable.sourceEntity.transform.concatenatedMatrix3D);
        matrix3D.append(projection.transform.inverseConcatenatedMatrix3D);
        shader.sceneMatrix.copyFrom(matrix3D, true);
        context.setProgramConstantsFromArray(_awayjs_stage.ContextGLProgramType.VERTEX, shader.vertexConstantData);
        if (this._indices)
            this.getIndexBufferGL().draw(_awayjs_stage.ContextGLDrawMode.TRIANGLES, offset * 3, count * 3 || this.numIndices);
        else
            this._stage.context.drawVertices(_awayjs_stage.ContextGLDrawMode.TRIANGLES, offset, count || this.numVertices);
    };
    /**
     * //TODO
     *
     * @param pool
     * @param renderable
     * @param level
     * @param indexOffset
     * @returns {away.pool.LineSubSpriteRenderable}
     * @protected
     */
    GL_LineElements.prototype._pGetOverflowElements = function () {
        return new GL_LineElements(this._lineElements, this._stage);
    };
    return GL_LineElements;
}(_awayjs_stage.GL_ElementsBase));
GL_LineElements.elementsType = "[elements Line]";

/**
 *
 * @class away.pool.GL_SkyboxElements
 */
var GL_SkyboxElements = (function (_super) {
    __extends(GL_SkyboxElements, _super);
    function GL_SkyboxElements() {
        var _this = _super.apply(this, arguments) || this;
        _this._skyboxProjection = new _awayjs_core.Matrix3D();
        return _this;
    }
    Object.defineProperty(GL_SkyboxElements.prototype, "elementsType", {
        get: function () {
            return GL_SkyboxElements.elementsType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_SkyboxElements.prototype, "elementsClass", {
        get: function () {
            return GL_SkyboxElements;
        },
        enumerable: true,
        configurable: true
    });
    GL_SkyboxElements._includeDependencies = function (shader) {
    };
    /**
     * @inheritDoc
     */
    GL_SkyboxElements._getVertexCode = function (shader, registerCache, sharedRegisters) {
        var code = "";
        //get the projection coordinates
        var position = (shader.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.animatedPosition;
        //reserving vertex constants for projection matrix
        var viewMatrixReg = registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        shader.viewMatrixIndex = viewMatrixReg.index * 4;
        var scenePosition = registerCache.getFreeVertexConstant();
        shader.scenePositionIndex = scenePosition.index * 4;
        var skyboxScale = registerCache.getFreeVertexConstant();
        var temp = registerCache.getFreeVertexVectorTemp();
        code += "mul " + temp + ", " + position + ", " + skyboxScale + "\n" +
            "add " + temp + ", " + temp + ", " + scenePosition + "\n";
        if (shader.projectionDependencies > 0) {
            sharedRegisters.projectionFragment = registerCache.getFreeVarying();
            code += "m44 " + temp + ", " + temp + ", " + viewMatrixReg + "\n" +
                "mov " + sharedRegisters.projectionFragment + ", " + temp + "\n" +
                "mov op, " + temp + "\n";
        }
        else {
            code += "m44 op, " + temp + ", " + viewMatrixReg + "\n";
        }
        return code;
    };
    GL_SkyboxElements._getFragmentCode = function (shader, registerCache, sharedRegisters) {
        return "";
    };
    GL_SkyboxElements.prototype.draw = function (renderable, shader, projection, count, offset) {
        var index = shader.scenePositionIndex;
        var camPos = projection.transform.concatenatedMatrix3D.position;
        shader.vertexConstantData[index++] = 2 * camPos.x;
        shader.vertexConstantData[index++] = 2 * camPos.y;
        shader.vertexConstantData[index++] = 2 * camPos.z;
        shader.vertexConstantData[index++] = 1;
        shader.vertexConstantData[index++] = shader.vertexConstantData[index++] = shader.vertexConstantData[index++] = projection.far / Math.sqrt(3);
        shader.vertexConstantData[index] = 1;
        var near = new _awayjs_core.Vector3D();
        this._skyboxProjection.copyFrom(projection.viewMatrix3D);
        this._skyboxProjection.copyRowTo(2, near);
        var cx = near.x;
        var cy = near.y;
        var cz = near.z;
        var cw = -(near.x * camPos.x + near.y * camPos.y + near.z * camPos.z + Math.sqrt(cx * cx + cy * cy + cz * cz));
        var signX = cx >= 0 ? 1 : -1;
        var signY = cy >= 0 ? 1 : -1;
        var p = new _awayjs_core.Vector3D(signX, signY, 1, 1);
        var inverse = this._skyboxProjection.clone();
        inverse.invert();
        var q = inverse.transformVector(p);
        this._skyboxProjection.copyRowTo(3, p);
        var a = (q.x * p.x + q.y * p.y + q.z * p.z + q.w * p.w) / (cx * q.x + cy * q.y + cz * q.z + cw * q.w);
        this._skyboxProjection.copyRowFrom(2, new _awayjs_core.Vector3D(cx * a, cy * a, cz * a, cw * a));
        //set constants
        if (shader.sceneMatrixIndex >= 0)
            shader.sceneMatrix.copyFrom(renderable.renderSceneTransform, true);
        shader.viewMatrix.copyFrom(this._skyboxProjection, true);
        var context = this._stage.context;
        context.setProgramConstantsFromArray(_awayjs_stage.ContextGLProgramType.VERTEX, shader.vertexConstantData);
        context.setProgramConstantsFromArray(_awayjs_stage.ContextGLProgramType.FRAGMENT, shader.fragmentConstantData);
        if (this._indices)
            this.getIndexBufferGL().draw(_awayjs_stage.ContextGLDrawMode.TRIANGLES, 0, this.numIndices);
        else
            this._stage.context.drawVertices(_awayjs_stage.ContextGLDrawMode.TRIANGLES, offset, count || this.numVertices);
    };
    return GL_SkyboxElements;
}(_awayjs_stage.GL_TriangleElements));
GL_SkyboxElements.elementsType = "[elements Skybox]";

var ShadingMethodEvent = (function (_super) {
    __extends(ShadingMethodEvent, _super);
    function ShadingMethodEvent(type) {
        return _super.call(this, type) || this;
    }
    return ShadingMethodEvent;
}(_awayjs_core.EventBase));
ShadingMethodEvent.SHADER_INVALIDATED = "shaderInvalidated";

var Filter3DTaskBase = (function () {
    function Filter3DTaskBase(requireDepthRender) {
        if (requireDepthRender === void 0) { requireDepthRender = false; }
        this._scaledTextureWidth = -1;
        this._scaledTextureHeight = -1;
        this._textureWidth = -1;
        this._textureHeight = -1;
        this._textureDimensionsInvalid = true;
        this._program3DInvalid = true;
        this._textureScale = 1;
        this._requireDepthRender = requireDepthRender;
        this._registerCache = new _awayjs_stage.ShaderRegisterCache(_awayjs_stage.ContextGLProfile.BASELINE);
    }
    Object.defineProperty(Filter3DTaskBase.prototype, "textureScale", {
        /**
         * The texture scale for the input of this texture. This will define the output of the previous entry in the chain
         */
        get: function () {
            return this._textureScale;
        },
        set: function (value) {
            if (this._textureScale == value)
                return;
            this._textureScale = value;
            this._scaledTextureWidth = this._textureWidth / this._textureScale;
            this._scaledTextureHeight = this._textureHeight / this._textureScale;
            this._textureDimensionsInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DTaskBase.prototype, "target", {
        get: function () {
            return this._target;
        },
        set: function (value) {
            this._target = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DTaskBase.prototype, "rttManager", {
        get: function () {
            return this._rttManager;
        },
        set: function (value) {
            if (this._rttManager == value)
                return;
            this._rttManager = value;
            this._textureDimensionsInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DTaskBase.prototype, "textureWidth", {
        get: function () {
            return this._textureWidth;
        },
        set: function (value) {
            if (this._textureWidth == value)
                return;
            this._textureWidth = value;
            this._scaledTextureWidth = this._textureWidth / this._textureScale;
            this._textureDimensionsInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DTaskBase.prototype, "textureHeight", {
        get: function () {
            return this._textureHeight;
        },
        set: function (value) {
            if (this._textureHeight == value)
                return;
            this._textureHeight = value;
            this._scaledTextureHeight = this._textureHeight / this._textureScale;
            this._textureDimensionsInvalid = true;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DTaskBase.prototype.getMainInputTexture = function (stage) {
        if (this._textureDimensionsInvalid)
            this.updateTextures(stage);
        return this._mainInputTexture;
    };
    Filter3DTaskBase.prototype.dispose = function () {
        if (this._mainInputTexture)
            this._mainInputTexture.dispose();
        if (this._program3D)
            this._program3D.dispose();
    };
    Filter3DTaskBase.prototype.invalidateProgram = function () {
        this._program3DInvalid = true;
    };
    Filter3DTaskBase.prototype.updateProgram = function (stage) {
        if (this._program3D)
            this._program3D.dispose();
        this._program3D = stage.context.createProgram();
        this._registerCache.reset();
        var vertexByteCode = (new _awayjs_stage.AGALMiniAssembler().assemble("part vertex 1\n" + this.getVertexCode() + "endpart"))['vertex'].data;
        var fragmentByteCode = (new _awayjs_stage.AGALMiniAssembler().assemble("part fragment 1\n" + this.getFragmentCode() + "endpart"))['fragment'].data;
        this._program3D.upload(vertexByteCode, fragmentByteCode);
        this._program3DInvalid = false;
    };
    Filter3DTaskBase.prototype.getVertexCode = function () {
        var position = this._registerCache.getFreeVertexAttribute();
        this._positionIndex = position.index;
        var uv = this._registerCache.getFreeVertexAttribute();
        this._uvIndex = uv.index;
        this._uvVarying = this._registerCache.getFreeVarying();
        var code;
        code = "mov op, " + position + "\n" +
            "mov " + this._uvVarying + ", " + uv + "\n";
        return code;
    };
    Filter3DTaskBase.prototype.getFragmentCode = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    Filter3DTaskBase.prototype.updateTextures = function (stage) {
        if (this._mainInputTexture)
            this._mainInputTexture.dispose();
        this._mainInputTexture = new _awayjs_graphics.Image2D(this._scaledTextureWidth, this._scaledTextureHeight);
        this._textureDimensionsInvalid = false;
    };
    Filter3DTaskBase.prototype.getProgram = function (stage) {
        if (this._program3DInvalid)
            this.updateProgram(stage);
        return this._program3D;
    };
    Filter3DTaskBase.prototype.activate = function (stage, camera, depthTexture) {
    };
    Filter3DTaskBase.prototype.deactivate = function (stage) {
    };
    Object.defineProperty(Filter3DTaskBase.prototype, "requireDepthRender", {
        get: function () {
            return this._requireDepthRender;
        },
        enumerable: true,
        configurable: true
    });
    return Filter3DTaskBase;
}());

var Filter3DCompositeTask = (function (_super) {
    __extends(Filter3DCompositeTask, _super);
    function Filter3DCompositeTask(blendMode, exposure) {
        if (exposure === void 0) { exposure = 1; }
        var _this = _super.call(this) || this;
        _this._data = new Float32Array([exposure, 0.5, 2.0, -1, 0.0, 0.0, 0.0, 0.0]);
        _this._blendMode = blendMode;
        return _this;
    }
    Object.defineProperty(Filter3DCompositeTask.prototype, "overlayTexture", {
        get: function () {
            return this._overlayTexture;
        },
        set: function (value) {
            this._overlayTexture = value;
            this._overlayWidth = this._overlayTexture.width;
            this._overlayHeight = this._overlayTexture.height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DCompositeTask.prototype, "exposure", {
        get: function () {
            return this._data[0];
        },
        set: function (value) {
            this._data[0] = value;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DCompositeTask.prototype.getFragmentCode = function () {
        var temp1 = this._registerCache.getFreeFragmentVectorTemp();
        this._registerCache.addFragmentTempUsages(temp1, 1);
        var temp2 = this._registerCache.getFreeFragmentVectorTemp();
        this._registerCache.addFragmentTempUsages(temp2, 1);
        var temp3 = this._registerCache.getFreeFragmentVectorTemp();
        this._registerCache.addFragmentTempUsages(temp3, 1);
        var temp4 = this._registerCache.getFreeFragmentVectorTemp();
        this._registerCache.addFragmentTempUsages(temp4, 1);
        var inputTexture = this._registerCache.getFreeTextureReg();
        this._inputTextureIndex = inputTexture.index;
        var overlayTexture = this._registerCache.getFreeTextureReg();
        this._overlayTextureIndex = overlayTexture.index;
        var exposure = this._registerCache.getFreeFragmentConstant();
        this._exposureIndex = exposure.index * 4;
        var scaling = this._registerCache.getFreeFragmentConstant();
        this._scalingIndex = scaling.index * 4;
        var code;
        code = "tex " + temp1 + ", " + this._uvVarying + ", " + inputTexture + " <2d,linear,clamp>\n" +
            "mul " + temp2 + ", " + this._uvVarying + ", " + scaling + ".zw\n" +
            "add " + temp2 + ", " + temp2 + ", " + scaling + ".xy\n" +
            "tex " + temp2 + ", " + temp2 + ", " + overlayTexture + " <2d,linear,clamp>\n" +
            "mul " + temp2 + ", " + temp2 + ", " + exposure + ".xxx\n" +
            "add " + temp2 + ", " + temp2 + ", " + exposure + ".xxx\n";
        switch (this._blendMode) {
            case "multiply":
                code += "mul oc, " + temp1 + ", " + temp2 + "\n";
                break;
            case "add":
                code += "add oc, " + temp1 + ", " + temp2 + "\n";
                break;
            case "subtract":
                code += "sub oc, " + temp1 + ", " + temp2 + "\n";
                break;
            case "overlay":
                code += "sge " + temp3 + ", " + temp1 + ", " + exposure + ".yyy\n"; // t2 = (blend >= 0.5)? 1 : 0
                code += "sub " + temp1 + ", " + temp3 + ", " + temp1 + "\n"; // base = (1 : 0 - base)
                code += "sub " + temp2 + ", " + temp2 + ", " + temp3 + "\n"; // blend = (blend - 1 : 0)
                code += "mul " + temp2 + ", " + temp2 + ", " + temp1 + "\n"; // blend = blend * base
                code += "sub " + temp4 + ", " + temp3 + ", " + exposure + ".yyy\n"; // t3 = (blend >= 0.5)? 0.5 : -0.5
                code += "div " + temp2 + ", " + temp2 + ", " + temp4 + "\n"; // blend = blend / ( 0.5 : -0.5)
                code += "add oc, " + temp2 + ", " + temp3 + "\n";
                break;
            case "normal":
                // for debugging purposes
                code += "mov oc, " + temp1 + "\n";
                break;
            default:
                throw new Error("Unknown blend mode");
        }
        return code;
    };
    Filter3DCompositeTask.prototype.activate = function (stage, camera3D, depthTexture) {
        this._data[4] = -0.5 * (this._textureWidth - this._overlayWidth) / this._overlayWidth;
        this._data[5] = -0.5 * (this._textureHeight - this._overlayHeight) / this._overlayHeight;
        this._data[6] = this._textureWidth / this._overlayWidth;
        this._data[7] = this._textureHeight / this._overlayHeight;
        var context = stage.context;
        context.setProgramConstantsFromArray(_awayjs_stage.ContextGLProgramType.FRAGMENT, this._data);
        stage.getAbstraction(this._overlayTexture).activate(this._overlayTextureIndex, false);
    };
    Filter3DCompositeTask.prototype.deactivate = function (stage) {
        stage.context.setTextureAt(1, null);
    };
    return Filter3DCompositeTask;
}(Filter3DTaskBase));

var Filter3DFXAATask = (function (_super) {
    __extends(Filter3DFXAATask, _super);
    /**
     *
     * @param amount
     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
     */
    function Filter3DFXAATask(amount, stepSize) {
        if (amount === void 0) { amount = 1; }
        if (stepSize === void 0) { stepSize = -1; }
        var _this = _super.call(this) || this;
        _this._stepSize = 1;
        _this._data = new Float32Array(20);
        //luma
        _this._data.set([0.299, 0.587, 0.114, 0], 0); //0.212, 0.716, 0.072
        //helpers
        _this._data.set([0.25, 0.5, 0.75, 1], 4);
        //settings (screen x, screen y, ...)
        _this._data.set([1 / 1024, 1 / 1024, -1, 1], 8);
        //deltas
        _this._data.set([1 / 128, 1 / 8, 8, 0], 12);
        //deltas
        _this._data.set([1.0 / 3.0 - 0.5, 2.0 / 3.0 - 0.5, 0.0 / 3.0 - 0.5, 3.0 / 3.0 - 0.5], 16);
        _this.amount = amount;
        _this.stepSize = stepSize;
        return _this;
    }
    Object.defineProperty(Filter3DFXAATask.prototype, "amount", {
        get: function () {
            return this._amount;
        },
        set: function (value) {
            if (this._amount == value)
                return;
            this._amount = value;
            this.invalidateProgram();
            this.updateBlurData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DFXAATask.prototype, "stepSize", {
        get: function () {
            return this._stepSize;
        },
        set: function (value) {
            if (this._stepSize == value)
                return;
            this._stepSize = value;
            this.calculateStepSize();
            this.invalidateProgram();
            this.updateBlurData();
        },
        enumerable: true,
        configurable: true
    });
    Filter3DFXAATask.prototype.getFragmentCode = function () {
        var lum = "fc0"; //	0.299, 0.587, 0.114
        var _0 = "fc0.w";
        var _025 = "fc1.x";
        var _05 = "fc1.y";
        var _075 = "fc1.z";
        var _1 = "fc1.w";
        var pix = "fc2.xy";
        var dx = "fc2.x"; // 1/1024
        var dy = "fc2.y"; // 1/1024
        var mOne = "fc2.z"; // -1.0
        var mul = "fc2.w"; // 1.0  -- one for now
        var fxaaReduceMin = "fc3.x"; //1/128
        var fxaaReduceMul = "fc3.y"; //1/8
        var fxaaSpanMax = "fc3.z"; //8
        var delta1 = "fc4.x"; //1.0/3.0 - 0.5
        var delta2 = "fc4.y"; //2.0/3.0 - 0.5
        var delta3 = "fc4.z"; //0.0/3.0 - 0.5
        var delta4 = "fc4.w"; //3.0/3.0 - 0.5
        var uv_in = "v0";
        var uv = "ft0.xy";
        var uvx = "ft0.x";
        var uvy = "ft0.y";
        var TL = "ft2.x";
        var TR = "ft2.y";
        var BL = "ft2.z";
        var BR = "ft2.w";
        var M = "ft3.x";
        var tempf1 = "ft3.y";
        var tempf2 = "ft3.z";
        var tempf3 = "ft3.w";
        var tex = "ft1";
        var dir = "ft4";
        var dirx = "ft4.x";
        var diry = "ft4.y";
        var dirxy = "ft4.xy";
        var dirReduce = "ft5.x";
        var inverseDirAdjustment = "ft5.y";
        var result1 = "ft6";
        var result2 = "ft7";
        var lumaMin = "ft5.x";
        var lumaMax = "ft5.y";
        var sample = "fs0";
        var temp = tex;
        var tempxy = temp + ".xy";
        var code = new Array();
        //lumas
        code.push("tex", tex, uv_in, sample, "<2d wrap linear>", "\n");
        code.push("dp3", M, tex, lum, "\n");
        code.push("mov", uv, uv_in, "\n");
        code.push("sub", uv, uv, pix, "\n");
        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
        code.push("dp3", TL, tex, lum, "\n");
        code.push("mov", uv, uv_in, "\n");
        code.push("add", uv, uv, pix, "\n");
        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
        code.push("dp3", BR, tex, lum, "\n");
        code.push("mov", uv, uv_in, "\n");
        code.push("sub", uvy, uvy, dy, "\n");
        code.push("add", uvx, uvx, dx, "\n");
        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
        code.push("dp3", TR, tex, lum, "\n");
        code.push("mov", uv, uv_in, "\n");
        code.push("add", uvy, uvy, dy, "\n");
        code.push("sub", uvx, uvx, dx, "\n");
        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
        code.push("dp3", BL, tex, lum, "\n");
        //dir
        code.push("add", tempf1, TL, TR, "\n");
        code.push("add", tempf2, BL, BR, "\n");
        code.push("sub", dirx, tempf1, tempf2, "\n");
        code.push("neg", dirx, dirx, "\n");
        code.push("add", tempf1, TL, BL, "\n");
        code.push("add", tempf2, TR, BR, "\n");
        code.push("sub", diry, tempf1, tempf2, "\n");
        code.push("add", tempf1, tempf1, tempf2, "\n");
        code.push("mul", tempf1, tempf1, fxaaReduceMul, "\n");
        code.push("mul", tempf1, tempf1, _025, "\n");
        code.push("max", dirReduce, tempf1, fxaaReduceMin, "\n");
        code.push("abs", tempf1, dirx, "\n");
        code.push("abs", tempf2, diry, "\n");
        code.push("min", tempf1, tempf1, tempf2, "\n");
        code.push("add", tempf1, tempf1, dirReduce, "\n");
        code.push("rcp", inverseDirAdjustment, tempf1, "\n");
        code.push("mul", tempf1, dirx, inverseDirAdjustment, "\n");
        code.push("mov", tempf2, fxaaSpanMax, "\n");
        code.push("neg", tempf2, tempf2, "\n");
        code.push("max", tempf1, tempf1, tempf2, "\n");
        code.push("min", tempf1, fxaaSpanMax, tempf1, "\n");
        code.push("mul", dirx, tempf1, dx, "\n");
        code.push("mul", tempf1, diry, inverseDirAdjustment, "\n");
        code.push("mov", tempf2, fxaaSpanMax, "\n");
        code.push("neg", tempf2, tempf2, "\n");
        code.push("max", tempf1, tempf1, tempf2, "\n");
        code.push("min", tempf1, fxaaSpanMax, tempf1, "\n");
        code.push("mul", diry, tempf1, dy, "\n");
        code.push("mul", tempxy, dirxy, delta1, "\n");
        code.push("add", uv, uv_in, tempxy, "\n");
        code.push("tex", result1, uv, sample, "<2d wrap linear>", "\n");
        code.push("mul", tempxy, dirxy, delta2, "\n");
        code.push("add", uv, uv_in, tempxy, "\n");
        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
        code.push("add", result1, result1, tex, "\n");
        code.push("mul", result1, result1, _05, "\n");
        code.push("mul", tempxy, dirxy, delta3, "\n");
        code.push("add", uv, uv_in, tempxy, "\n");
        code.push("tex", result2, uv, sample, "<2d wrap linear>", "\n");
        code.push("mul", tempxy, dirxy, delta4, "\n");
        code.push("add", uv, uv_in, tempxy, "\n");
        code.push("tex", tex, uv, sample, "<2d wrap linear>", "\n");
        code.push("add", result2, result2, tex, "\n");
        code.push("mul", result2, result2, _025, "\n");
        code.push("mul", tex, result1, _05, "\n");
        code.push("add", result2, result2, tex, "\n");
        code.push("min", tempf1, BL, BR, "\n");
        code.push("min", tempf2, TL, TR, "\n");
        code.push("min", tempf1, tempf1, tempf2, "\n");
        code.push("min", lumaMin, tempf1, M, "\n");
        code.push("max", tempf1, BL, BR, "\n");
        code.push("max", tempf2, TL, TR, "\n");
        code.push("max", tempf1, tempf1, tempf2, "\n");
        code.push("max", lumaMax, tempf1, M, "\n");
        code.push("dp3", tempf1, lum, result2, "\n");
        code.push("slt", tempf2, tempf1, lumaMin, "\n");
        code.push("sge", tempf3, tempf1, lumaMax, "\n");
        code.push("mul", tempf2, tempf2, tempf3, "\n");
        code.push("mul", result1, result1, tempf2, "\n");
        code.push("sub", tempf2, _1, tempf2, "\n");
        code.push("mul", result2, result2, tempf2, "\n");
        code.push("add", "oc", result1, result2, "\n");
        //this._data[2] = 1/numSamples;
        return code.join(" ");
    };
    Filter3DFXAATask.prototype.activate = function (stage, camera3D, depthTexture) {
        stage.context.setProgramConstantsFromArray(_awayjs_stage.ContextGLProgramType.FRAGMENT, this._data);
    };
    Filter3DFXAATask.prototype.updateTextures = function (stage) {
        _super.prototype.updateTextures.call(this, stage);
        this.updateBlurData();
    };
    Filter3DFXAATask.prototype.updateBlurData = function () {
        // todo: must be normalized using view size ratio instead of texture
        if (this._rttManager) {
            this._data[8] = 1 / this._textureWidth;
            this._data[9] = 1 / this._textureHeight;
        }
    };
    Filter3DFXAATask.prototype.calculateStepSize = function () {
        this._realStepSize = 1; //this._stepSize > 0? this._stepSize : this._amount > Filter3DVBlurTask.MAX_AUTO_SAMPLES? this._amount/Filter3DVBlurTask.MAX_AUTO_SAMPLES : 1;
    };
    return Filter3DFXAATask;
}(Filter3DTaskBase));
//TODO - remove blur variables and create setters/getters for FXAA
Filter3DFXAATask.MAX_AUTO_SAMPLES = 15;

var Filter3DHBlurTask = (function (_super) {
    __extends(Filter3DHBlurTask, _super);
    /**
     * Creates a new Filter3DHDepthOfFFieldTask
     * @param amount The maximum amount of blur to apply in pixels at the most out-of-focus areas
     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
     */
    function Filter3DHBlurTask(amount, stepSize) {
        if (stepSize === void 0) { stepSize = -1; }
        var _this = _super.call(this) || this;
        _this._stepSize = 1;
        _this._amount = amount;
        _this._data = new Float32Array([0, 0, 0, 1]);
        _this.stepSize = stepSize;
        return _this;
    }
    Object.defineProperty(Filter3DHBlurTask.prototype, "amount", {
        get: function () {
            return this._amount;
        },
        set: function (value) {
            if (this._amount == value)
                return;
            this._amount = value;
            this.invalidateProgram();
            this.updateBlurData();
            this.calculateStepSize();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DHBlurTask.prototype, "stepSize", {
        get: function () {
            return this._stepSize;
        },
        set: function (value) {
            if (this._stepSize == value)
                return;
            this._stepSize = value;
            this.calculateStepSize();
            this.invalidateProgram();
            this.updateBlurData();
        },
        enumerable: true,
        configurable: true
    });
    Filter3DHBlurTask.prototype.getFragmentCode = function () {
        var code;
        var numSamples = 1;
        code = "mov ft0, v0	\n" +
            "sub ft0.x, v0.x, fc0.x\n";
        code += "tex ft1, ft0, fs0 <2d,linear,clamp>\n";
        for (var x = this._realStepSize; x <= this._amount; x += this._realStepSize) {
            code += "add ft0.x, ft0.x, fc0.y\n" +
                "tex ft2, ft0, fs0 <2d,linear,clamp>\n" +
                "add ft1, ft1, ft2\n";
            ++numSamples;
        }
        code += "mul oc, ft1, fc0.z\n";
        this._data[2] = 1 / numSamples;
        return code;
    };
    Filter3DHBlurTask.prototype.activate = function (stage, camera3D, depthTexture) {
        stage.context.setProgramConstantsFromArray(_awayjs_stage.ContextGLProgramType.FRAGMENT, this._data);
    };
    Filter3DHBlurTask.prototype.updateTextures = function (stage) {
        _super.prototype.updateTextures.call(this, stage);
        this.updateBlurData();
    };
    Filter3DHBlurTask.prototype.updateBlurData = function () {
        // todo: must be normalized using view size ratio instead of texture
        var invW = 1 / this._textureWidth;
        this._data[0] = this._amount * .5 * invW;
        this._data[1] = this._realStepSize * invW;
    };
    Filter3DHBlurTask.prototype.calculateStepSize = function () {
        this._realStepSize = this._stepSize > 0 ? this._stepSize : this._amount > Filter3DHBlurTask.MAX_AUTO_SAMPLES ? this._amount / Filter3DHBlurTask.MAX_AUTO_SAMPLES : 1;
    };
    return Filter3DHBlurTask;
}(Filter3DTaskBase));
Filter3DHBlurTask.MAX_AUTO_SAMPLES = 15;

var Filter3DVBlurTask = (function (_super) {
    __extends(Filter3DVBlurTask, _super);
    /**
     *
     * @param amount
     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
     */
    function Filter3DVBlurTask(amount, stepSize) {
        if (stepSize === void 0) { stepSize = -1; }
        var _this = _super.call(this) || this;
        _this._stepSize = 1;
        _this._amount = amount;
        _this._data = new Float32Array([0, 0, 0, 1]);
        _this.stepSize = stepSize;
        return _this;
    }
    Object.defineProperty(Filter3DVBlurTask.prototype, "amount", {
        get: function () {
            return this._amount;
        },
        set: function (value) {
            if (this._amount == value)
                return;
            this._amount = value;
            this.invalidateProgram();
            this.updateBlurData();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DVBlurTask.prototype, "stepSize", {
        get: function () {
            return this._stepSize;
        },
        set: function (value) {
            if (this._stepSize == value)
                return;
            this._stepSize = value;
            this.calculateStepSize();
            this.invalidateProgram();
            this.updateBlurData();
        },
        enumerable: true,
        configurable: true
    });
    Filter3DVBlurTask.prototype.getFragmentCode = function () {
        var code;
        var numSamples = 1;
        code = "mov ft0, v0	\n" +
            "sub ft0.y, v0.y, fc0.x\n";
        code += "tex ft1, ft0, fs0 <2d,linear,clamp>\n";
        for (var x = this._realStepSize; x <= this._amount; x += this._realStepSize) {
            code += "add ft0.y, ft0.y, fc0.y\n";
            code += "tex ft2, ft0, fs0 <2d,linear,clamp>\n" +
                "add ft1, ft1, ft2\n";
            ++numSamples;
        }
        code += "mul oc, ft1, fc0.z\n";
        this._data[2] = 1 / numSamples;
        return code;
    };
    Filter3DVBlurTask.prototype.activate = function (stage, camera3D, depthTexture) {
        stage.context.setProgramConstantsFromArray(_awayjs_stage.ContextGLProgramType.FRAGMENT, this._data);
    };
    Filter3DVBlurTask.prototype.updateTextures = function (stage) {
        _super.prototype.updateTextures.call(this, stage);
        this.updateBlurData();
    };
    Filter3DVBlurTask.prototype.updateBlurData = function () {
        // todo: must be normalized using view size ratio instead of texture
        var invH = 1 / this._textureHeight;
        this._data[0] = this._amount * .5 * invH;
        this._data[1] = this._realStepSize * invH;
    };
    Filter3DVBlurTask.prototype.calculateStepSize = function () {
        this._realStepSize = this._stepSize > 0 ? this._stepSize : this._amount > Filter3DVBlurTask.MAX_AUTO_SAMPLES ? this._amount / Filter3DVBlurTask.MAX_AUTO_SAMPLES : 1;
    };
    return Filter3DVBlurTask;
}(Filter3DTaskBase));
Filter3DVBlurTask.MAX_AUTO_SAMPLES = 15;

var Filter3DBase = (function () {
    function Filter3DBase() {
        this._textureScale = 1;
        this._tasks = new Array();
    }
    Object.defineProperty(Filter3DBase.prototype, "requireDepthRender", {
        get: function () {
            return this._requireDepthRender;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DBase.prototype.addTask = function (filter) {
        this._tasks.push(filter);
        if (this._requireDepthRender == null)
            this._requireDepthRender = filter.requireDepthRender;
    };
    Object.defineProperty(Filter3DBase.prototype, "tasks", {
        get: function () {
            return this._tasks;
        },
        enumerable: true,
        configurable: true
    });
    Filter3DBase.prototype.getMainInputTexture = function (stage) {
        return this._tasks[0].getMainInputTexture(stage);
    };
    Object.defineProperty(Filter3DBase.prototype, "textureWidth", {
        get: function () {
            return this._textureWidth;
        },
        set: function (value) {
            this._textureWidth = value;
            for (var i = 0; i < this._tasks.length; ++i)
                this._tasks[i].textureWidth = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DBase.prototype, "rttManager", {
        get: function () {
            return this._rttManager;
        },
        set: function (value) {
            this._rttManager = value;
            for (var i = 0; i < this._tasks.length; ++i)
                this._tasks[i].rttManager = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DBase.prototype, "textureHeight", {
        get: function () {
            return this._textureHeight;
        },
        set: function (value) {
            this._textureHeight = value;
            for (var i = 0; i < this._tasks.length; ++i)
                this._tasks[i].textureHeight = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Filter3DBase.prototype, "textureScale", {
        get: function () {
            return this._textureScale;
        },
        set: function (value) {
            this._textureScale = value;
            for (var i = 0; i < this._tasks.length; ++i)
                this._tasks[i].textureScale = value;
        },
        enumerable: true,
        configurable: true
    });
    // link up the filters correctly with the next filter
    Filter3DBase.prototype.setRenderTargets = function (mainTarget, stage) {
        this._tasks[this._tasks.length - 1].target = mainTarget;
    };
    Filter3DBase.prototype.dispose = function () {
        for (var i = 0; i < this._tasks.length; ++i)
            this._tasks[i].dispose();
    };
    Filter3DBase.prototype.update = function (stage, camera) {
    };
    return Filter3DBase;
}());

var BlurFilter3D = (function (_super) {
    __extends(BlurFilter3D, _super);
    /**
     * Creates a new BlurFilter3D object
     * @param blurX The amount of horizontal blur to apply
     * @param blurY The amount of vertical blur to apply
     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
     */
    function BlurFilter3D(blurX, blurY, stepSize) {
        if (blurX === void 0) { blurX = 3; }
        if (blurY === void 0) { blurY = 3; }
        if (stepSize === void 0) { stepSize = -1; }
        var _this = _super.call(this) || this;
        _this._hBlurTask = new Filter3DHBlurTask(blurX, stepSize);
        _this._vBlurTask = new Filter3DVBlurTask(blurY, stepSize);
        _this.addTask(_this._hBlurTask);
        _this.addTask(_this._vBlurTask);
        return _this;
    }
    Object.defineProperty(BlurFilter3D.prototype, "blurX", {
        get: function () {
            return this._hBlurTask.amount;
        },
        set: function (value) {
            this._hBlurTask.amount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlurFilter3D.prototype, "blurY", {
        get: function () {
            return this._vBlurTask.amount;
        },
        set: function (value) {
            this._vBlurTask.amount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BlurFilter3D.prototype, "stepSize", {
        /**
         * The distance between two blur samples. Set to -1 to autodetect with acceptable quality (default value).
         * Higher values provide better performance at the cost of reduces quality.
         */
        get: function () {
            return this._hBlurTask.stepSize;
        },
        set: function (value) {
            this._hBlurTask.stepSize = value;
            this._vBlurTask.stepSize = value;
        },
        enumerable: true,
        configurable: true
    });
    BlurFilter3D.prototype.setRenderTargets = function (mainTarget, stage) {
        this._hBlurTask.target = this._vBlurTask.getMainInputTexture(stage);
        _super.prototype.setRenderTargets.call(this, mainTarget, stage);
    };
    return BlurFilter3D;
}(Filter3DBase));

var CompositeFilter3D = (function (_super) {
    __extends(CompositeFilter3D, _super);
    /**
     * Creates a new CompositeFilter3D object
     * @param blurX The amount of horizontal blur to apply
     * @param blurY The amount of vertical blur to apply
     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
     */
    function CompositeFilter3D(blendMode, exposure) {
        if (exposure === void 0) { exposure = 1; }
        var _this = _super.call(this) || this;
        _this._compositeTask = new Filter3DCompositeTask(blendMode, exposure);
        _this.addTask(_this._compositeTask);
        return _this;
    }
    Object.defineProperty(CompositeFilter3D.prototype, "exposure", {
        get: function () {
            return this._compositeTask.exposure;
        },
        set: function (value) {
            this._compositeTask.exposure = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompositeFilter3D.prototype, "overlayTexture", {
        get: function () {
            return this._compositeTask.overlayTexture;
        },
        set: function (value) {
            this._compositeTask.overlayTexture = value;
        },
        enumerable: true,
        configurable: true
    });
    return CompositeFilter3D;
}(Filter3DBase));

var FXAAFilter3D = (function (_super) {
    __extends(FXAAFilter3D, _super);
    /**
     * Creates a new FXAAFilter3D object
     * @param amount
     * @param stepSize The distance between samples. Set to -1 to autodetect with acceptable quality.
     */
    function FXAAFilter3D(amount, stepSize) {
        if (stepSize === void 0) { stepSize = -1; }
        var _this = _super.call(this) || this;
        _this._fxaaTask = new Filter3DFXAATask(amount, stepSize);
        _this.addTask(_this._fxaaTask);
        return _this;
    }
    Object.defineProperty(FXAAFilter3D.prototype, "amount", {
        get: function () {
            return this._fxaaTask.amount;
        },
        set: function (value) {
            this._fxaaTask.amount = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(FXAAFilter3D.prototype, "stepSize", {
        get: function () {
            return this._fxaaTask.stepSize;
        },
        set: function (value) {
            this._fxaaTask.stepSize = value;
        },
        enumerable: true,
        configurable: true
    });
    return FXAAFilter3D;
}(Filter3DBase));

/**
 * @class away.pool.RenderableListItem
 */
var GL_BillboardRenderable = (function (_super) {
    __extends(GL_BillboardRenderable, _super);
    /**
     * //TODO
     *
     * @param pool
     * @param billboard
     */
    function GL_BillboardRenderable(billboard, renderablePool) {
        var _this = _super.call(this, billboard, renderablePool) || this;
        _this._billboard = billboard;
        return _this;
    }
    GL_BillboardRenderable.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._billboard = null;
    };
    /**
     * //TODO
     *
     * @returns {away.base.TriangleElements}
     */
    GL_BillboardRenderable.prototype._getElements = function () {
        var texture = this._billboard.material.getTextureAt(0);
        var width = this._billboard.billboardWidth;
        var height = this._billboard.billboardHeight;
        var billboardRect = this._billboard.billboardRect;
        var id = width.toString() + height.toString() + billboardRect.toString();
        this._id = id;
        var elements = GL_BillboardRenderable._samplerElements[id];
        if (!elements) {
            elements = GL_BillboardRenderable._samplerElements[id] = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer(11, 4));
            elements.autoDeriveNormals = false;
            elements.autoDeriveTangents = false;
            elements.setIndices(Array(0, 1, 2, 0, 2, 3));
            elements.setPositions(Array(-billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, -billboardRect.y, 0, -billboardRect.x, -billboardRect.y, 0));
            elements.setNormals(Array(1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0));
            elements.setTangents(Array(0, 0, -1, 0, 0, -1, 0, 0, -1, 0, 0, -1));
            elements.setUVs(Array(0, 1, 1, 1, 1, 0, 0, 0));
        }
        else {
            elements.setPositions(Array(-billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, height - billboardRect.y, 0, width - billboardRect.x, -billboardRect.y, 0, -billboardRect.x, -billboardRect.y, 0));
        }
        return this._stage.getAbstraction(elements);
    };
    GL_BillboardRenderable.prototype._getMaterial = function () {
        return this._materialGroup.getMaterialPool(this.elementsGL).getAbstraction(this._billboard.material || _awayjs_graphics.DefaultMaterialManager.getDefaultMaterial(this.renderable));
    };
    return GL_BillboardRenderable;
}(_awayjs_stage.GL_RenderableBase));
GL_BillboardRenderable._samplerElements = new Object();

/**
 * @class away.pool.GL_LineSegmentRenderable
 */
var GL_LineSegmentRenderable = (function (_super) {
    __extends(GL_LineSegmentRenderable, _super);
    /**
     * //TODO
     *
     * @param pool
     * @param graphic
     * @param level
     * @param dataOffset
     */
    function GL_LineSegmentRenderable(lineSegment, renderablePool) {
        var _this = _super.call(this, lineSegment, renderablePool) || this;
        _this._lineSegment = lineSegment;
        return _this;
    }
    GL_LineSegmentRenderable.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._lineSegment = null;
    };
    /**
     * //TODO
     *
     * @returns {base.LineElements}
     * @protected
     */
    GL_LineSegmentRenderable.prototype._getElements = function () {
        var elements = GL_LineSegmentRenderable._lineGraphics[this._lineSegment.id] || (GL_LineSegmentRenderable._lineGraphics[this._lineSegment.id] = new _awayjs_graphics.LineElements());
        var start = this._lineSegment.startPostion;
        var end = this._lineSegment.endPosition;
        var positions = new Float32Array(6);
        var thickness = new Float32Array(1);
        positions[0] = start.x;
        positions[1] = start.y;
        positions[2] = start.z;
        positions[3] = end.x;
        positions[4] = end.y;
        positions[5] = end.z;
        thickness[0] = this._lineSegment.thickness;
        elements.setPositions(positions);
        elements.setThickness(thickness);
        return this._stage.getAbstraction(elements);
    };
    GL_LineSegmentRenderable.prototype._getMaterial = function () {
        return this._materialGroup.getMaterialPool(this.elementsGL).getAbstraction(this._lineSegment.material || _awayjs_graphics.DefaultMaterialManager.getDefaultMaterial(this.renderable));
    };
    return GL_LineSegmentRenderable;
}(_awayjs_stage.GL_RenderableBase));
GL_LineSegmentRenderable._lineGraphics = new Object();

/**
 * @class away.pool.GL_SkyboxRenderable
 */
var GL_SkyboxRenderable = (function (_super) {
    __extends(GL_SkyboxRenderable, _super);
    /**
     * //TODO
     *
     * @param pool
     * @param skybox
     */
    function GL_SkyboxRenderable(skybox, renderablePool) {
        var _this = _super.call(this, skybox, renderablePool) || this;
        _this._skybox = skybox;
        return _this;
    }
    /**
     * //TODO
     *
     * @returns {away.base.TriangleElements}
     * @private
     */
    GL_SkyboxRenderable.prototype._getElements = function () {
        var elementsGL = GL_SkyboxRenderable._elementsGL;
        if (!elementsGL) {
            var elements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer(11, 4));
            elements.autoDeriveNormals = false;
            elements.autoDeriveTangents = false;
            elements.setIndices(Array(0, 1, 2, 2, 3, 0, 6, 5, 4, 4, 7, 6, 2, 6, 7, 7, 3, 2, 4, 5, 1, 1, 0, 4, 4, 0, 3, 3, 7, 4, 2, 1, 5, 5, 6, 2));
            elements.setPositions(Array(-1, 1, -1, 1, 1, -1, 1, 1, 1, -1, 1, 1, -1, -1, -1, 1, -1, -1, 1, -1, 1, -1, -1, 1));
            elementsGL = GL_SkyboxRenderable._elementsGL = new GL_SkyboxElements(elements, this._stage);
        }
        return elementsGL;
    };
    GL_SkyboxRenderable.prototype._getMaterial = function () {
        return this._materialGroup.getMaterialPool(this.elementsGL).getAbstraction(this._skybox);
    };
    GL_SkyboxRenderable._includeDependencies = function (shader) {
    };
    return GL_SkyboxRenderable;
}(_awayjs_stage.GL_RenderableBase));

/**
 * CompilerBase is an abstract base class for shader compilers that use modular shader methods to assemble a
 * material. Concrete subclasses are used by the default materials.
 *
 * @see away.materials.ShadingMethodBase
 */
var LightingCompiler = (function (_super) {
    __extends(LightingCompiler, _super);
    /**
     * Creates a new CompilerBase object.
     * @param profile The compatibility profile of the renderer.
     */
    function LightingCompiler(elementsClass, lightingPass, shaderLightingObject) {
        var _this = _super.call(this, elementsClass, lightingPass, shaderLightingObject) || this;
        _this._shaderLightingObject = shaderLightingObject;
        return _this;
    }
    /**
     * Compile the code for the methods.
     */
    LightingCompiler.prototype.pCompileDependencies = function () {
        _super.prototype.pCompileDependencies.call(this);
        //collect code from pass
        this._vertexCode += this._renderPass._getPreLightingVertexCode(this._registerCache, this._sharedRegisters);
        this._postAnimationFragmentCode += this._renderPass._getPreLightingFragmentCode(this._registerCache, this._sharedRegisters);
        //compile the lighting code
        if (this._shaderLightingObject.usesShadows)
            this.pCompileShadowCode();
        if (this._shaderLightingObject.usesLights) {
            this.initLightRegisters();
            this.compileLightCode();
        }
        if (this._shaderLightingObject.usesProbes)
            this.compileLightProbeCode();
    };
    /**
     * Provides the code to provide shadow mapping.
     */
    LightingCompiler.prototype.pCompileShadowCode = function () {
        if (this._shaderLightingObject.normalDependencies > 0) {
            this._sharedRegisters.shadowTarget = this._sharedRegisters.normalFragment;
        }
        else {
            this._sharedRegisters.shadowTarget = this._registerCache.getFreeFragmentVectorTemp();
            this._registerCache.addFragmentTempUsages(this._sharedRegisters.shadowTarget, 1);
        }
    };
    /**
     * Initializes constant registers to contain light data.
     */
    LightingCompiler.prototype.initLightRegisters = function () {
        // init these first so we're sure they're in sequence
        var i, len;
        if (this._dirLightVertexConstants) {
            len = this._dirLightVertexConstants.length;
            for (i = 0; i < len; ++i) {
                this._dirLightVertexConstants[i] = this._registerCache.getFreeVertexConstant();
                if (this._shaderLightingObject.lightVertexConstantIndex == -1)
                    this._shaderLightingObject.lightVertexConstantIndex = this._dirLightVertexConstants[i].index * 4;
            }
        }
        if (this._pointLightVertexConstants) {
            len = this._pointLightVertexConstants.length;
            for (i = 0; i < len; ++i) {
                this._pointLightVertexConstants[i] = this._registerCache.getFreeVertexConstant();
                if (this._shaderLightingObject.lightVertexConstantIndex == -1)
                    this._shaderLightingObject.lightVertexConstantIndex = this._pointLightVertexConstants[i].index * 4;
            }
        }
        len = this._dirLightFragmentConstants.length;
        for (i = 0; i < len; ++i) {
            this._dirLightFragmentConstants[i] = this._registerCache.getFreeFragmentConstant();
            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
                this._shaderLightingObject.lightFragmentConstantIndex = this._dirLightFragmentConstants[i].index * 4;
        }
        len = this._pointLightFragmentConstants.length;
        for (i = 0; i < len; ++i) {
            this._pointLightFragmentConstants[i] = this._registerCache.getFreeFragmentConstant();
            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
                this._shaderLightingObject.lightFragmentConstantIndex = this._pointLightFragmentConstants[i].index * 4;
        }
    };
    /**
     * Compiles the shading code for directional and point lights.
     */
    LightingCompiler.prototype.compileLightCode = function () {
        var diffuseColorReg;
        var specularColorReg;
        var lightPosReg;
        var lightDirReg;
        var vertexRegIndex = 0;
        var fragmentRegIndex = 0;
        var addSpec = this._shaderLightingObject.usesLightsForSpecular;
        var addDiff = this._shaderLightingObject.usesLightsForDiffuse;
        //compile the shading code for directional lights.
        for (var i = 0; i < this._shaderLightingObject.numDirectionalLights; ++i) {
            if (this._shaderLightingObject.usesTangentSpace) {
                lightDirReg = this._dirLightVertexConstants[vertexRegIndex++];
                var lightVarying = this._registerCache.getFreeVarying();
                this._vertexCode += "m33 " + lightVarying + ".xyz, " + lightDirReg + ", " + this._sharedRegisters.animatedTangent + "\n" +
                    "mov " + lightVarying + ".w, " + lightDirReg + ".w\n";
                lightDirReg = this._registerCache.getFreeFragmentVectorTemp();
                this._registerCache.addVertexTempUsages(lightDirReg, 1);
                this._postAnimationFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" +
                    "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
            }
            else {
                lightDirReg = this._dirLightFragmentConstants[fragmentRegIndex++];
            }
            diffuseColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
            specularColorReg = this._dirLightFragmentConstants[fragmentRegIndex++];
            if (addDiff)
                this._postAnimationFragmentCode += this._renderPass._getPerLightDiffuseFragmentCode(lightDirReg, diffuseColorReg, this._registerCache, this._sharedRegisters);
            if (addSpec)
                this._postAnimationFragmentCode += this._renderPass._getPerLightSpecularFragmentCode(lightDirReg, specularColorReg, this._registerCache, this._sharedRegisters);
            if (this._shaderLightingObject.usesTangentSpace)
                this._registerCache.removeVertexTempUsage(lightDirReg);
        }
        vertexRegIndex = 0;
        fragmentRegIndex = 0;
        //compile the shading code for point lights
        for (var i = 0; i < this._shaderLightingObject.numPointLights; ++i) {
            if (this._shaderLightingObject.usesTangentSpace || !this._shaderLightingObject.usesGlobalPosFragment)
                lightPosReg = this._pointLightVertexConstants[vertexRegIndex++];
            else
                lightPosReg = this._pointLightFragmentConstants[fragmentRegIndex++];
            diffuseColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
            specularColorReg = this._pointLightFragmentConstants[fragmentRegIndex++];
            lightDirReg = this._registerCache.getFreeFragmentVectorTemp();
            this._registerCache.addFragmentTempUsages(lightDirReg, 1);
            var lightVarying;
            if (this._shaderLightingObject.usesTangentSpace) {
                lightVarying = this._registerCache.getFreeVarying();
                var temp = this._registerCache.getFreeVertexVectorTemp();
                this._vertexCode += "sub " + temp + ", " + lightPosReg + ", " + this._sharedRegisters.animatedPosition + "\n" +
                    "m33 " + lightVarying + ".xyz, " + temp + ", " + this._sharedRegisters.animatedTangent + "\n" +
                    "mov " + lightVarying + ".w, " + this._sharedRegisters.animatedPosition + ".w\n";
            }
            else if (!this._shaderLightingObject.usesGlobalPosFragment) {
                lightVarying = this._registerCache.getFreeVarying();
                this._vertexCode += "sub " + lightVarying + ", " + lightPosReg + ", " + this._sharedRegisters.globalPositionVertex + "\n";
            }
            else {
                lightVarying = lightDirReg;
                this._postAnimationFragmentCode += "sub " + lightDirReg + ", " + lightPosReg + ", " + this._sharedRegisters.globalPositionVarying + "\n";
            }
            if (this._shaderLightingObject.usesLightFallOff) {
                // calculate attenuation
                this._postAnimationFragmentCode +=
                    "dp3 " + lightDirReg + ".w, " + lightVarying + ", " + lightVarying + "\n" +
                        "sub " + lightDirReg + ".w, " + lightDirReg + ".w, " + diffuseColorReg + ".w\n" +
                        "mul " + lightDirReg + ".w, " + lightDirReg + ".w, " + specularColorReg + ".w\n" +
                        "sat " + lightDirReg + ".w, " + lightDirReg + ".w\n" +
                        "sub " + lightDirReg + ".w, " + this._sharedRegisters.commons + ".w, " + lightDirReg + ".w\n" +
                        "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n";
            }
            else {
                this._postAnimationFragmentCode += "nrm " + lightDirReg + ".xyz, " + lightVarying + "\n" +
                    "mov " + lightDirReg + ".w, " + lightVarying + ".w\n";
            }
            if (this._shaderLightingObject.lightFragmentConstantIndex == -1)
                this._shaderLightingObject.lightFragmentConstantIndex = lightPosReg.index * 4;
            if (addDiff)
                this._postAnimationFragmentCode += this._renderPass._getPerLightDiffuseFragmentCode(lightDirReg, diffuseColorReg, this._registerCache, this._sharedRegisters);
            if (addSpec)
                this._postAnimationFragmentCode += this._renderPass._getPerLightSpecularFragmentCode(lightDirReg, specularColorReg, this._registerCache, this._sharedRegisters);
            this._registerCache.removeFragmentTempUsage(lightDirReg);
        }
    };
    /**
     * Compiles shading code for light probes.
     */
    LightingCompiler.prototype.compileLightProbeCode = function () {
        var weightReg;
        var weightComponents = [".x", ".y", ".z", ".w"];
        var weightRegisters = new Array();
        var i;
        var texReg;
        var addSpec = this._shaderLightingObject.usesProbesForSpecular;
        var addDiff = this._shaderLightingObject.usesProbesForDiffuse;
        if (addDiff)
            this._shaderLightingObject.lightProbeDiffuseIndices = new Array();
        if (addSpec)
            this._shaderLightingObject.lightProbeSpecularIndices = new Array();
        for (i = 0; i < this._pNumProbeRegisters; ++i) {
            weightRegisters[i] = this._registerCache.getFreeFragmentConstant();
            if (i == 0)
                this._shaderLightingObject.probeWeightsIndex = weightRegisters[i].index * 4;
        }
        for (i = 0; i < this._shaderLightingObject.numLightProbes; ++i) {
            weightReg = weightRegisters[Math.floor(i / 4)].toString() + weightComponents[i % 4];
            if (addDiff) {
                texReg = this._registerCache.getFreeTextureReg();
                this._shaderLightingObject.lightProbeDiffuseIndices[i] = texReg.index;
                this._postAnimationFragmentCode += this._renderPass._getPerProbeDiffuseFragmentCode(texReg, weightReg, this._registerCache, this._sharedRegisters);
            }
            if (addSpec) {
                texReg = this._registerCache.getFreeTextureReg();
                this._shaderLightingObject.lightProbeSpecularIndices[i] = texReg.index;
                this._postAnimationFragmentCode += this._renderPass._getPerProbeSpecularFragmentCode(texReg, weightReg, this._registerCache, this._sharedRegisters);
            }
        }
    };
    /**
     * Reset all the indices to "unused".
     */
    LightingCompiler.prototype.pInitRegisterIndices = function () {
        _super.prototype.pInitRegisterIndices.call(this);
        this._shaderLightingObject.lightVertexConstantIndex = -1;
        this._shaderLightingObject.lightFragmentConstantIndex = -1;
        this._shaderLightingObject.probeWeightsIndex = -1;
        this._pNumProbeRegisters = Math.ceil(this._shaderLightingObject.numLightProbes / 4);
        //init light data
        if (this._shaderLightingObject.usesTangentSpace || !this._shaderLightingObject.usesGlobalPosFragment) {
            this._pointLightVertexConstants = new Array(this._shaderLightingObject.numPointLights);
            this._pointLightFragmentConstants = new Array(this._shaderLightingObject.numPointLights * 2);
        }
        else {
            this._pointLightFragmentConstants = new Array(this._shaderLightingObject.numPointLights * 3);
        }
        if (this._shaderLightingObject.usesTangentSpace) {
            this._dirLightVertexConstants = new Array(this._shaderLightingObject.numDirectionalLights);
            this._dirLightFragmentConstants = new Array(this._shaderLightingObject.numDirectionalLights * 2);
        }
        else {
            this._dirLightFragmentConstants = new Array(this._shaderLightingObject.numDirectionalLights * 3);
        }
    };
    return LightingCompiler;
}(_awayjs_stage.CompilerBase));

/**
 * ShaderBase keeps track of the number of dependencies for "named registers" used across a pass.
 * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
 * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
 * each time a method has been compiled into the shader.
 *
 * @see RegisterPool.addUsage
 */
var LightingShader = (function (_super) {
    __extends(LightingShader, _super);
    /**
     * Creates a new MethodCompilerVO object.
     */
    function LightingShader(elementsClass, lightingPass, stage) {
        var _this = _super.call(this, elementsClass, lightingPass, stage) || this;
        _this._includeCasters = true;
        _this._lightingPass = lightingPass;
        return _this;
    }
    LightingShader.prototype._includeDependencies = function () {
        this.numPointLights = this._lightingPass.numPointLights;
        this.numDirectionalLights = this._lightingPass.numDirectionalLights;
        this.numLightProbes = this._lightingPass.numLightProbes;
        var numAllLights = this._lightingPass.numPointLights + this._lightingPass.numDirectionalLights;
        var numLightProbes = this._lightingPass.numLightProbes;
        var diffuseLightSources = this._lightingPass._iUsesDiffuse(this) ? this._lightingPass.diffuseLightSources : 0x00;
        var specularLightSources = this._lightingPass._iUsesSpecular(this) ? this._lightingPass.specularLightSources : 0x00;
        var combinedLightSources = diffuseLightSources | specularLightSources;
        this.usesLightFallOff = this._lightingPass.enableLightFallOff && this.profile != _awayjs_stage.ContextGLProfile.BASELINE_CONSTRAINED;
        this.usesCommonData = this.usesLightFallOff || this.usesCommonData;
        this.numLights = numAllLights + numLightProbes;
        this.usesLights = numAllLights > 0 && (combinedLightSources & _awayjs_scene.LightSources.LIGHTS) != 0;
        this.usesProbes = numLightProbes > 0 && (combinedLightSources & _awayjs_scene.LightSources.PROBES) != 0;
        this.usesLightsForSpecular = numAllLights > 0 && (specularLightSources & _awayjs_scene.LightSources.LIGHTS) != 0;
        this.usesProbesForSpecular = numLightProbes > 0 && (specularLightSources & _awayjs_scene.LightSources.PROBES) != 0;
        this.usesLightsForDiffuse = numAllLights > 0 && (diffuseLightSources & _awayjs_scene.LightSources.LIGHTS) != 0;
        this.usesProbesForDiffuse = numLightProbes > 0 && (diffuseLightSources & _awayjs_scene.LightSources.PROBES) != 0;
        this.usesShadows = this._lightingPass._iUsesShadows(this);
        //IMPORTANT this must occur after shader lighting initialisation above
        _super.prototype._includeDependencies.call(this);
    };
    /**
     * Factory method to create a concrete compiler object for this object
     *
     * @param materialPassVO
     * @returns {away.materials.LightingCompiler}
     */
    LightingShader.prototype.createCompiler = function (elementsClass, pass) {
        return new LightingCompiler(elementsClass, pass, this);
    };
    /**
     *
     *
     * @param renderable
     * @param stage
     * @param camera
     */
    LightingShader.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        if (this._lightingPass.lightPicker)
            this._lightingPass.lightPicker.collectLights(renderable.sourceEntity);
        if (this.usesLights)
            this.updateLights();
        if (this.usesProbes)
            this.updateProbes();
    };
    /**
     * Updates constant data render state used by the lights. This method is optional for subclasses to implement.
     */
    LightingShader.prototype.updateLights = function () {
        var dirLight;
        var pointLight;
        var i = 0;
        var k = 0;
        var len;
        var dirPos;
        var total = 0;
        var numLightTypes = this.usesShadows ? 2 : 1;
        var l;
        var offset;
        this.ambientR = this.ambientG = this.ambientB = 0;
        l = this.lightVertexConstantIndex;
        k = this.lightFragmentConstantIndex;
        var cast = 0;
        var dirLights = this._lightingPass.lightPicker.directionalLights;
        offset = this._lightingPass.directionalLightsOffset;
        len = this._lightingPass.lightPicker.directionalLights.length;
        if (offset > len) {
            cast = 1;
            offset -= len;
        }
        for (; cast < numLightTypes; ++cast) {
            if (cast)
                dirLights = this._lightingPass.lightPicker.castingDirectionalLights;
            len = dirLights.length;
            if (len > this.numDirectionalLights)
                len = this.numDirectionalLights;
            for (i = 0; i < len; ++i) {
                dirLight = dirLights[offset + i];
                dirPos = dirLight.sceneDirection;
                this.ambientR += dirLight._iAmbientR;
                this.ambientG += dirLight._iAmbientG;
                this.ambientB += dirLight._iAmbientB;
                if (this.usesTangentSpace) {
                    var x = -dirPos.x;
                    var y = -dirPos.y;
                    var z = -dirPos.z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z;
                    this.vertexConstantData[l++] = 1;
                }
                else {
                    this.fragmentConstantData[k++] = -dirPos.x;
                    this.fragmentConstantData[k++] = -dirPos.y;
                    this.fragmentConstantData[k++] = -dirPos.z;
                    this.fragmentConstantData[k++] = 1;
                }
                this.fragmentConstantData[k++] = dirLight._iDiffuseR;
                this.fragmentConstantData[k++] = dirLight._iDiffuseG;
                this.fragmentConstantData[k++] = dirLight._iDiffuseB;
                this.fragmentConstantData[k++] = 1;
                this.fragmentConstantData[k++] = dirLight._iSpecularR;
                this.fragmentConstantData[k++] = dirLight._iSpecularG;
                this.fragmentConstantData[k++] = dirLight._iSpecularB;
                this.fragmentConstantData[k++] = 1;
                if (++total == this.numDirectionalLights) {
                    // break loop
                    i = len;
                    cast = numLightTypes;
                }
            }
        }
        // more directional supported than currently picked, need to clamp all to 0
        if (this.numDirectionalLights > total) {
            i = k + (this.numDirectionalLights - total) * 12;
            while (k < i)
                this.fragmentConstantData[k++] = 0;
        }
        total = 0;
        var pointLights = this._lightingPass.lightPicker.pointLights;
        offset = this._lightingPass.pointLightsOffset;
        len = this._lightingPass.lightPicker.pointLights.length;
        if (offset > len) {
            cast = 1;
            offset -= len;
        }
        else {
            cast = 0;
        }
        for (; cast < numLightTypes; ++cast) {
            if (cast)
                pointLights = this._lightingPass.lightPicker.castingPointLights;
            len = pointLights.length;
            for (i = 0; i < len; ++i) {
                pointLight = pointLights[offset + i];
                dirPos = pointLight.scenePosition;
                this.ambientR += pointLight._iAmbientR;
                this.ambientG += pointLight._iAmbientG;
                this.ambientB += pointLight._iAmbientB;
                if (this.usesTangentSpace) {
                    x = dirPos.x;
                    y = dirPos.y;
                    z = dirPos.z;
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z + this._pInverseSceneMatrix[12];
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z + this._pInverseSceneMatrix[13];
                    this.vertexConstantData[l++] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z + this._pInverseSceneMatrix[14];
                    this.vertexConstantData[l++] = 1;
                }
                else if (!this.usesGlobalPosFragment) {
                    this.vertexConstantData[l++] = dirPos.x;
                    this.vertexConstantData[l++] = dirPos.y;
                    this.vertexConstantData[l++] = dirPos.z;
                    this.vertexConstantData[l++] = 1;
                }
                else {
                    this.fragmentConstantData[k++] = dirPos.x;
                    this.fragmentConstantData[k++] = dirPos.y;
                    this.fragmentConstantData[k++] = dirPos.z;
                    this.fragmentConstantData[k++] = 1;
                }
                this.fragmentConstantData[k++] = pointLight._iDiffuseR;
                this.fragmentConstantData[k++] = pointLight._iDiffuseG;
                this.fragmentConstantData[k++] = pointLight._iDiffuseB;
                var radius = pointLight._pRadius;
                this.fragmentConstantData[k++] = radius * radius;
                this.fragmentConstantData[k++] = pointLight._iSpecularR;
                this.fragmentConstantData[k++] = pointLight._iSpecularG;
                this.fragmentConstantData[k++] = pointLight._iSpecularB;
                this.fragmentConstantData[k++] = pointLight._pFallOffFactor;
                if (++total == this.numPointLights) {
                    // break loop
                    i = len;
                    cast = numLightTypes;
                }
            }
        }
        // more directional supported than currently picked, need to clamp all to 0
        if (this.numPointLights > total) {
            i = k + (total - this.numPointLights) * 12;
            for (; k < i; ++k)
                this.fragmentConstantData[k] = 0;
        }
    };
    /**
     * Updates constant data render state used by the light probes. This method is optional for subclasses to implement.
     */
    LightingShader.prototype.updateProbes = function () {
        var probe;
        var lightProbes = this._lightingPass.lightPicker.lightProbes;
        var weights = this._lightingPass.lightPicker.lightProbeWeights;
        var len = lightProbes.length - this._lightingPass.lightProbesOffset;
        var addDiff = this.usesProbesForDiffuse;
        var addSpec = this.usesProbesForSpecular;
        if (!(addDiff || addSpec))
            return;
        if (len > this.numLightProbes)
            len = this.numLightProbes;
        for (var i = 0; i < len; ++i) {
            probe = lightProbes[this._lightingPass.lightProbesOffset + i];
            if (addDiff)
                this._stage.getAbstraction(probe.diffuseMap).activate(this.lightProbeDiffuseIndices[i], probe.diffuseSampler.mipmap);
            if (addSpec)
                this._stage.getAbstraction(probe.specularMap).activate(this.lightProbeSpecularIndices[i], probe.diffuseSampler.mipmap);
        }
        for (i = 0; i < len; ++i)
            this.fragmentConstantData[this.probeWeightsIndex + i] = weights[this._lightingPass.lightProbesOffset + i];
    };
    return LightingShader;
}(_awayjs_stage.ShaderBase));

/**
 * @class away.sort.NullSort
 */
var RenderableNullSort = (function () {
    function RenderableNullSort() {
    }
    RenderableNullSort.prototype.sortBlendedRenderables = function (head) {
        return head;
    };
    RenderableNullSort.prototype.sortOpaqueRenderables = function (head) {
        return head;
    };
    return RenderableNullSort;
}());

/**
 * GL_SkyboxMaterial forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var GL_SkyboxMaterial = (function (_super) {
    __extends(GL_SkyboxMaterial, _super);
    function GL_SkyboxMaterial(skybox, materialPool) {
        var _this = _super.call(this, skybox, materialPool) || this;
        _this._skybox = skybox;
        _this._shader = new _awayjs_stage.ShaderBase(materialPool.elementsClass, _this, _this._stage);
        _this._texture = _this._shader.getAbstraction(_this._skybox.texture);
        _this._pAddPass(_this);
        return _this;
    }
    GL_SkyboxMaterial.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._texture.onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, this._skybox.texture));
        this._texture = null;
        this._skybox = null;
    };
    /**
     * @inheritDoc
     */
    GL_SkyboxMaterial.prototype._pUpdateRender = function () {
        _super.prototype._pUpdateRender.call(this);
        this._pRequiresBlending = (this._material.blendMode != _awayjs_graphics.BlendMode.NORMAL);
        this.shader.setBlendMode((this._material.blendMode == _awayjs_graphics.BlendMode.NORMAL && this._pRequiresBlending) ? _awayjs_graphics.BlendMode.LAYER : this._material.blendMode);
    };
    GL_SkyboxMaterial.prototype._includeDependencies = function (shader) {
        _super.prototype._includeDependencies.call(this, shader);
        shader.usesPositionFragment = true;
    };
    /**
     * @inheritDoc
     */
    GL_SkyboxMaterial.prototype._getFragmentCode = function (registerCache, sharedRegisters) {
        return this._texture._getFragmentCode(sharedRegisters.shadedTarget, registerCache, sharedRegisters, sharedRegisters.positionVarying);
    };
    GL_SkyboxMaterial.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        this._texture._setRenderState(renderable);
    };
    /**
     * @inheritDoc
     */
    GL_SkyboxMaterial.prototype._activate = function (projection) {
        _super.prototype._activate.call(this, projection);
        this._stage.context.setDepthTest(false, _awayjs_stage.ContextGLCompareMode.LESS);
        this._texture.activate();
    };
    return GL_SkyboxMaterial;
}(_awayjs_stage.GL_MaterialPassBase));

/**
 * ...
 */
var ParticleGraphicsHelper = (function () {
    function ParticleGraphicsHelper() {
    }
    ParticleGraphicsHelper.generateGraphics = function (output, graphicsArray, transforms) {
        if (transforms === void 0) { transforms = null; }
        var indicesVector = new Array();
        var positionsVector = new Array();
        var normalsVector = new Array();
        var tangentsVector = new Array();
        var uvsVector = new Array();
        var vertexCounters = new Array();
        var particles = new Array();
        var elementsArray = new Array();
        var numParticles = graphicsArray.length;
        var sourceGraphics;
        var sourceElements;
        var numGraphics;
        var indices;
        var positions;
        var normals;
        var tangents;
        var uvs;
        var vertexCounter;
        var elements;
        var i;
        var j;
        var sub2SubMap = new Array();
        var tempVertex = new _awayjs_core.Vector3D;
        var tempNormal = new _awayjs_core.Vector3D;
        var tempTangents = new _awayjs_core.Vector3D;
        var tempUV = new _awayjs_core.Point;
        for (i = 0; i < numParticles; i++) {
            sourceGraphics = graphicsArray[i];
            numGraphics = sourceGraphics.count;
            for (var srcIndex = 0; srcIndex < numGraphics; srcIndex++) {
                //create a different particle subgeometry group for each source subgeometry in a particle.
                if (sub2SubMap.length <= srcIndex) {
                    sub2SubMap.push(elementsArray.length);
                    indicesVector.push(new Array());
                    positionsVector.push(new Array());
                    normalsVector.push(new Array());
                    tangentsVector.push(new Array());
                    uvsVector.push(new Array());
                    elementsArray.push(new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer()));
                    vertexCounters.push(0);
                }
                sourceElements = sourceGraphics.getShapeAt(srcIndex).elements;
                //add a new particle subgeometry if this source subgeometry will take us over the maxvertex limit
                if (sourceElements.numVertices + vertexCounters[sub2SubMap[srcIndex]] > ParticleGraphicsHelper.MAX_VERTEX) {
                    //update submap and add new subgeom vectors
                    sub2SubMap[srcIndex] = elementsArray.length;
                    indicesVector.push(new Array());
                    positionsVector.push(new Array());
                    normalsVector.push(new Array());
                    tangentsVector.push(new Array());
                    uvsVector.push(new Array());
                    elementsArray.push(new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer()));
                    vertexCounters.push(0);
                }
                j = sub2SubMap[srcIndex];
                //select the correct vector
                indices = indicesVector[j];
                positions = positionsVector[j];
                normals = normalsVector[j];
                tangents = tangentsVector[j];
                uvs = uvsVector[j];
                vertexCounter = vertexCounters[j];
                elements = elementsArray[j];
                var particleData = new _awayjs_graphics.ParticleData();
                particleData.numVertices = sourceElements.numVertices;
                particleData.startVertexIndex = vertexCounter;
                particleData.particleIndex = i;
                particleData.elements = elements;
                particles.push(particleData);
                vertexCounters[j] += sourceElements.numVertices;
                var k;
                var index;
                var posIndex;
                var normalIndex;
                var tangentIndex;
                var uvIndex;
                var tempLen;
                var compact = sourceElements;
                var sourcePositions;
                var posStride;
                var sourceNormals;
                var normalStride;
                var sourceTangents;
                var tangentStride;
                var sourceUVs;
                var uvStride;
                if (compact) {
                    tempLen = compact.numVertices;
                    sourcePositions = compact.positions.get(tempLen);
                    posStride = compact.positions.stride;
                    sourceNormals = compact.normals.get(tempLen);
                    normalStride = compact.normals.stride;
                    sourceTangents = compact.tangents.get(tempLen);
                    tangentStride = compact.tangents.stride;
                    sourceUVs = compact.uvs.get(tempLen);
                    uvStride = compact.uvs.stride;
                    if (transforms) {
                        var particleGraphicsTransform = transforms[i];
                        var vertexTransform = particleGraphicsTransform.vertexTransform;
                        var invVertexTransform = particleGraphicsTransform.invVertexTransform;
                        var UVTransform = particleGraphicsTransform.UVTransform;
                        for (k = 0; k < tempLen; k++) {
                            /*
                             * 0 - 2: vertex position X, Y, Z
                             * 3 - 5: normal X, Y, Z
                             * 6 - 8: tangent X, Y, Z
                             * 9 - 10: U V
                             * 11 - 12: Secondary U V*/
                            posIndex = k * posStride;
                            tempVertex.x = sourcePositions[posIndex];
                            tempVertex.y = sourcePositions[posIndex + 1];
                            tempVertex.z = sourcePositions[posIndex + 2];
                            normalIndex = k * normalStride;
                            tempNormal.x = sourceNormals[normalIndex];
                            tempNormal.y = sourceNormals[normalIndex + 1];
                            tempNormal.z = sourceNormals[normalIndex + 2];
                            tangentIndex = k * tangentStride;
                            tempTangents.x = sourceTangents[tangentIndex];
                            tempTangents.y = sourceTangents[tangentIndex + 1];
                            tempTangents.z = sourceTangents[tangentIndex + 2];
                            uvIndex = k * uvStride;
                            tempUV.x = sourceUVs[uvIndex];
                            tempUV.y = sourceUVs[uvIndex + 1];
                            if (vertexTransform) {
                                tempVertex = vertexTransform.transformVector(tempVertex);
                                tempNormal = invVertexTransform.deltaTransformVector(tempNormal);
                                tempTangents = invVertexTransform.deltaTransformVector(tempNormal);
                            }
                            if (UVTransform)
                                tempUV = UVTransform.transformPoint(tempUV);
                            //this is faster than that only push one data
                            positions.push(tempVertex.x, tempVertex.y, tempVertex.z);
                            normals.push(tempNormal.x, tempNormal.y, tempNormal.z);
                            tangents.push(tempTangents.x, tempTangents.y, tempTangents.z);
                            uvs.push(tempUV.x, tempUV.y);
                        }
                    }
                    else {
                        for (k = 0; k < tempLen; k++) {
                            posIndex = k * posStride;
                            normalIndex = k * normalStride;
                            tangentIndex = k * tangentStride;
                            uvIndex = k * uvStride;
                            //this is faster than that only push one data
                            positions.push(sourcePositions[posIndex], sourcePositions[posIndex + 1], sourcePositions[posIndex + 2]);
                            normals.push(sourceNormals[normalIndex], sourceNormals[normalIndex + 1], sourceNormals[normalIndex + 2]);
                            tangents.push(sourceTangents[tangentIndex], sourceTangents[tangentIndex + 1], sourceTangents[tangentIndex + 2]);
                            uvs.push(sourceUVs[uvIndex], sourceUVs[uvIndex + 1]);
                        }
                    }
                }
                else {
                }
                tempLen = sourceElements.numElements;
                var sourceIndices = sourceElements.indices.get(tempLen);
                for (k = 0; k < tempLen; k++) {
                    index = k * 3;
                    indices.push(sourceIndices[index] + vertexCounter, sourceIndices[index + 1] + vertexCounter, sourceIndices[index + 2] + vertexCounter);
                }
            }
        }
        output.particles = particles;
        output.numParticles = numParticles;
        numParticles = elementsArray.length;
        for (i = 0; i < numParticles; i++) {
            elements = elementsArray[i];
            elements.autoDeriveNormals = false;
            elements.autoDeriveTangents = false;
            elements.setIndices(indicesVector[i]);
            elements.setPositions(positionsVector[i]);
            elements.setNormals(normalsVector[i]);
            elements.setTangents(tangentsVector[i]);
            elements.setUVs(uvsVector[i]);
            output.addShape(_awayjs_graphics.Shape.getShape(elements));
        }
    };
    return ParticleGraphicsHelper;
}());
ParticleGraphicsHelper.MAX_VERTEX = 65535;

/**
 * ...
 */
var ParticleGraphicsTransform = (function () {
    function ParticleGraphicsTransform() {
    }
    Object.defineProperty(ParticleGraphicsTransform.prototype, "vertexTransform", {
        get: function () {
            return this._defaultVertexTransform;
        },
        set: function (value) {
            this._defaultVertexTransform = value;
            this._defaultInvVertexTransform = value.clone();
            this._defaultInvVertexTransform.invert();
            this._defaultInvVertexTransform.transpose();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleGraphicsTransform.prototype, "UVTransform", {
        get: function () {
            return this._defaultUVTransform;
        },
        set: function (value) {
            this._defaultUVTransform = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ParticleGraphicsTransform.prototype, "invVertexTransform", {
        get: function () {
            return this._defaultInvVertexTransform;
        },
        enumerable: true,
        configurable: true
    });
    return ParticleGraphicsTransform;
}());

exports.AnimationElements = AnimationElements;
exports.ColorSegmentPoint = ColorSegmentPoint;
exports.JointPose = JointPose;
exports.ParticleAnimationData = ParticleAnimationData;
exports.ParticleProperties = ParticleProperties;
exports.ParticlePropertiesMode = ParticlePropertiesMode;
exports.Skeleton = Skeleton;
exports.SkeletonJoint = SkeletonJoint;
exports.SkeletonPose = SkeletonPose;
exports.VertexAnimationMode = VertexAnimationMode;
exports.AnimationClipNodeBase = AnimationClipNodeBase;
exports.ParticleAccelerationNode = ParticleAccelerationNode;
exports.ParticleBezierCurveNode = ParticleBezierCurveNode;
exports.ParticleBillboardNode = ParticleBillboardNode;
exports.ParticleColorNode = ParticleColorNode;
exports.ParticleFollowNode = ParticleFollowNode;
exports.ParticleInitialColorNode = ParticleInitialColorNode;
exports.ParticleNodeBase = ParticleNodeBase;
exports.ParticleOrbitNode = ParticleOrbitNode;
exports.ParticleOscillatorNode = ParticleOscillatorNode;
exports.ParticlePositionNode = ParticlePositionNode;
exports.ParticleRotateToHeadingNode = ParticleRotateToHeadingNode;
exports.ParticleRotateToPositionNode = ParticleRotateToPositionNode;
exports.ParticleRotationalVelocityNode = ParticleRotationalVelocityNode;
exports.ParticleScaleNode = ParticleScaleNode;
exports.ParticleSegmentedColorNode = ParticleSegmentedColorNode;
exports.ParticleSpriteSheetNode = ParticleSpriteSheetNode;
exports.ParticleTimeNode = ParticleTimeNode;
exports.ParticleUVNode = ParticleUVNode;
exports.ParticleVelocityNode = ParticleVelocityNode;
exports.SkeletonBinaryLERPNode = SkeletonBinaryLERPNode;
exports.SkeletonClipNode = SkeletonClipNode;
exports.SkeletonDifferenceNode = SkeletonDifferenceNode;
exports.SkeletonDirectionalNode = SkeletonDirectionalNode;
exports.SkeletonNaryLERPNode = SkeletonNaryLERPNode;
exports.VertexClipNode = VertexClipNode;
exports.AnimationClipState = AnimationClipState;
exports.AnimationStateBase = AnimationStateBase;
exports.ParticleAccelerationState = ParticleAccelerationState;
exports.ParticleBezierCurveState = ParticleBezierCurveState;
exports.ParticleBillboardState = ParticleBillboardState;
exports.ParticleColorState = ParticleColorState;
exports.ParticleFollowState = ParticleFollowState;
exports.ParticleInitialColorState = ParticleInitialColorState;
exports.ParticleStateBase = ParticleStateBase;
exports.ParticleOrbitState = ParticleOrbitState;
exports.ParticleOscillatorState = ParticleOscillatorState;
exports.ParticlePositionState = ParticlePositionState;
exports.ParticleRotateToHeadingState = ParticleRotateToHeadingState;
exports.ParticleRotateToPositionState = ParticleRotateToPositionState;
exports.ParticleRotationalVelocityState = ParticleRotationalVelocityState;
exports.ParticleScaleState = ParticleScaleState;
exports.ParticleSegmentedColorState = ParticleSegmentedColorState;
exports.ParticleSpriteSheetState = ParticleSpriteSheetState;
exports.ParticleTimeState = ParticleTimeState;
exports.ParticleUVState = ParticleUVState;
exports.ParticleVelocityState = ParticleVelocityState;
exports.SkeletonBinaryLERPState = SkeletonBinaryLERPState;
exports.SkeletonClipState = SkeletonClipState;
exports.SkeletonDifferenceState = SkeletonDifferenceState;
exports.SkeletonDirectionalState = SkeletonDirectionalState;
exports.SkeletonNaryLERPState = SkeletonNaryLERPState;
exports.VertexClipState = VertexClipState;
exports.CrossfadeTransition = CrossfadeTransition;
exports.CrossfadeTransitionNode = CrossfadeTransitionNode;
exports.CrossfadeTransitionState = CrossfadeTransitionState;
exports.ParticleAnimationSet = ParticleAnimationSet;
exports.ParticleAnimator = ParticleAnimator;
exports.SkeletonAnimationSet = SkeletonAnimationSet;
exports.SkeletonAnimator = SkeletonAnimator;
exports.VertexAnimationSet = VertexAnimationSet;
exports.VertexAnimator = VertexAnimator;
exports.DefaultRenderer = DefaultRenderer;
exports.DepthRenderer = DepthRenderer;
exports.DistanceRenderer = DistanceRenderer;
exports.GL_LineElements = GL_LineElements;
exports.GL_SkyboxElements = GL_SkyboxElements;
exports.AnimationStateEvent = AnimationStateEvent;
exports.RendererEvent = RendererEvent;
exports.RTTEvent = RTTEvent;
exports.ShadingMethodEvent = ShadingMethodEvent;
exports.Filter3DRenderer = Filter3DRenderer;
exports.Filter3DCompositeTask = Filter3DCompositeTask;
exports.Filter3DFXAATask = Filter3DFXAATask;
exports.Filter3DHBlurTask = Filter3DHBlurTask;
exports.Filter3DTaskBase = Filter3DTaskBase;
exports.Filter3DVBlurTask = Filter3DVBlurTask;
exports.BlurFilter3D = BlurFilter3D;
exports.CompositeFilter3D = CompositeFilter3D;
exports.Filter3DBase = Filter3DBase;
exports.FXAAFilter3D = FXAAFilter3D;
exports.RTTBufferManager = RTTBufferManager;
exports.GL_BillboardRenderable = GL_BillboardRenderable;
exports.GL_LineSegmentRenderable = GL_LineSegmentRenderable;
exports.GL_SkyboxRenderable = GL_SkyboxRenderable;
exports.RendererBase = RendererBase;
exports.LightingCompiler = LightingCompiler;
exports.LightingShader = LightingShader;
exports.RenderableMergeSort = RenderableMergeSort;
exports.RenderableNullSort = RenderableNullSort;
exports.DefaultMaterialGroup = DefaultMaterialGroup;
exports.GL_DepthMaterial = GL_DepthMaterial;
exports.GL_DistanceMaterial = GL_DistanceMaterial;
exports.GL_SkyboxMaterial = GL_SkyboxMaterial;
exports.ParticleGraphicsHelper = ParticleGraphicsHelper;
exports.ParticleGraphicsTransform = ParticleGraphicsTransform;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 13 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(7), __webpack_require__(9)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/core', '@awayjs/graphics'], factory) :
    (factory((global.AwayjsStage = global.AwayjsStage || {}),global.AwayjsCore,global.AwayjsGraphics));
}(this, (function (exports,_awayjs_core,_awayjs_graphics) { 'use strict';

var Flags = (function () {
    function Flags() {
    }
    return Flags;
}());

var FS = (function () {
    function FS() {
    }
    return FS;
}());

/**
 *
 */
var Opcode = (function () {
    function Opcode(dest, aformat, asize, bformat, bsize, opcode, simple, horizontal, fragonly, matrix) {
        this.a = new FS();
        this.b = new FS();
        this.flags = new Flags();
        this.dest = dest;
        this.a.format = aformat;
        this.a.size = asize;
        this.b.format = bformat;
        this.b.size = bsize;
        this.opcode = opcode;
        this.flags.simple = simple;
        this.flags.horizontal = horizontal;
        this.flags.fragonly = fragonly;
        this.flags.matrix = matrix;
    }
    return Opcode;
}());

var OpcodeMap = (function () {
    function OpcodeMap() {
    }
    Object.defineProperty(OpcodeMap, "map", {
        get: function () {
            if (!OpcodeMap._map) {
                OpcodeMap._map = new Array();
                OpcodeMap._map['mov'] = new Opcode("vector", "vector", 4, "none", 0, 0x00, true, null, null, null); //0
                OpcodeMap._map['add'] = new Opcode("vector", "vector", 4, "vector", 4, 0x01, true, null, null, null); //1
                OpcodeMap._map['sub'] = new Opcode("vector", "vector", 4, "vector", 4, 0x02, true, null, null, null); //2
                OpcodeMap._map['mul'] = new Opcode("vector", "vector", 4, "vector", 4, 0x03, true, null, null, null); //3
                OpcodeMap._map['div'] = new Opcode("vector", "vector", 4, "vector", 4, 0x04, true, null, null, null); //4
                OpcodeMap._map['rcp'] = new Opcode("vector", "vector", 4, "none", 0, 0x05, true, null, null, null); //5
                OpcodeMap._map['min'] = new Opcode("vector", "vector", 4, "vector", 4, 0x06, true, null, null, null); //6
                OpcodeMap._map['max'] = new Opcode("vector", "vector", 4, "vector", 4, 0x07, true, null, null, null); //7
                OpcodeMap._map['frc'] = new Opcode("vector", "vector", 4, "none", 0, 0x08, true, null, null, null); //8
                OpcodeMap._map['sqt'] = new Opcode("vector", "vector", 4, "none", 0, 0x09, true, null, null, null); //9
                OpcodeMap._map['rsq'] = new Opcode("vector", "vector", 4, "none", 0, 0x0a, true, null, null, null); //10
                OpcodeMap._map['pow'] = new Opcode("vector", "vector", 4, "vector", 4, 0x0b, true, null, null, null); //11
                OpcodeMap._map['log'] = new Opcode("vector", "vector", 4, "none", 0, 0x0c, true, null, null, null); //12
                OpcodeMap._map['exp'] = new Opcode("vector", "vector", 4, "none", 0, 0x0d, true, null, null, null); //13
                OpcodeMap._map['nrm'] = new Opcode("vector", "vector", 4, "none", 0, 0x0e, true, null, null, null); //14
                OpcodeMap._map['sin'] = new Opcode("vector", "vector", 4, "none", 0, 0x0f, true, null, null, null); //15
                OpcodeMap._map['cos'] = new Opcode("vector", "vector", 4, "none", 0, 0x10, true, null, null, null); //16
                OpcodeMap._map['crs'] = new Opcode("vector", "vector", 4, "vector", 4, 0x11, true, true, null, null); //17
                OpcodeMap._map['dp3'] = new Opcode("vector", "vector", 4, "vector", 4, 0x12, true, true, null, null); //18
                OpcodeMap._map['dp4'] = new Opcode("vector", "vector", 4, "vector", 4, 0x13, true, true, null, null); //19
                OpcodeMap._map['abs'] = new Opcode("vector", "vector", 4, "none", 0, 0x14, true, null, null, null); //20
                OpcodeMap._map['neg'] = new Opcode("vector", "vector", 4, "none", 0, 0x15, true, null, null, null); //21
                OpcodeMap._map['sat'] = new Opcode("vector", "vector", 4, "none", 0, 0x16, true, null, null, null); //22
                OpcodeMap._map['ted'] = new Opcode("vector", "vector", 4, "sampler", 1, 0x26, true, null, true, null); //38
                OpcodeMap._map['kil'] = new Opcode("none", "scalar", 1, "none", 0, 0x27, true, null, true, null); //39
                OpcodeMap._map['tex'] = new Opcode("vector", "vector", 4, "sampler", 1, 0x28, true, null, true, null); //40
                OpcodeMap._map['m33'] = new Opcode("vector", "matrix", 3, "vector", 3, 0x17, true, null, null, true); //23
                OpcodeMap._map['m44'] = new Opcode("vector", "matrix", 4, "vector", 4, 0x18, true, null, null, true); //24
                OpcodeMap._map['m43'] = new Opcode("vector", "matrix", 3, "vector", 4, 0x19, true, null, null, true); //25
                OpcodeMap._map['ddx'] = new Opcode("vector", "vector", 4, "none", 0, 0x1a, true, null, true, null); //26
                OpcodeMap._map['ddy'] = new Opcode("vector", "vector", 4, "none", 0, 0x1b, true, null, true, null); //27
                OpcodeMap._map['sge'] = new Opcode("vector", "vector", 4, "vector", 4, 0x29, true, null, null, null); //41
                OpcodeMap._map['slt'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2a, true, null, null, null); //42
                OpcodeMap._map['sgn'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2b, true, null, null, null); //43
                OpcodeMap._map['seq'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2c, true, null, null, null); //44
                OpcodeMap._map['sne'] = new Opcode("vector", "vector", 4, "vector", 4, 0x2d, true, null, null, null); //45
            }
            return OpcodeMap._map;
        },
        enumerable: true,
        configurable: true
    });
    return OpcodeMap;
}());

var Part = (function () {
    function Part(name, version) {
        if (name === void 0) { name = null; }
        if (version === void 0) { version = null; }
        this.name = "";
        this.version = 0;
        this.name = name;
        this.version = version;
        this.data = new _awayjs_core.ByteArray();
    }
    return Part;
}());

var Reg = (function () {
    function Reg(code, desc) {
        this.code = code;
        this.desc = desc;
    }
    return Reg;
}());
var RegMap = (function () {
    /*
     public static va:Reg = new Reg( 0x00, "vertex attribute" );
     public static fc:Reg = new Reg( 0x01, "fragment constant" );
     public static vc:Reg = new Reg( 0x01, "vertex constant" );
     public static ft:Reg = new Reg( 0x02, "fragment temporary" );
     public static vt:Reg = new Reg( 0x02, "vertex temporary" );
     public static vo:Reg = new Reg( 0x03, "vertex output" );
     public static op:Reg = new Reg( 0x03, "vertex output" );
     public static fd:Reg = new Reg( 0x03, "fragment depth output" );
     public static fo:Reg = new Reg( 0x03, "fragment output" );
     public static oc:Reg = new Reg( 0x03, "fragment output" );
     public static v: Reg = new Reg( 0x04, "varying" );
     public static vi:Reg = new Reg( 0x04, "varying output" );
     public static fi:Reg = new Reg( 0x04, "varying input" );
     public static fs:Reg = new Reg( 0x05, "sampler" );
     */
    function RegMap() {
    }
    Object.defineProperty(RegMap, "map", {
        get: function () {
            if (!RegMap._map) {
                RegMap._map = new Array();
                RegMap._map['va'] = new Reg(0x00, "vertex attribute");
                RegMap._map['fc'] = new Reg(0x01, "fragment constant");
                RegMap._map['vc'] = new Reg(0x01, "vertex constant");
                RegMap._map['ft'] = new Reg(0x02, "fragment temporary");
                RegMap._map['vt'] = new Reg(0x02, "vertex temporary");
                RegMap._map['vo'] = new Reg(0x03, "vertex output");
                RegMap._map['op'] = new Reg(0x03, "vertex output");
                RegMap._map['fd'] = new Reg(0x03, "fragment depth output");
                RegMap._map['fo'] = new Reg(0x03, "fragment output");
                RegMap._map['oc'] = new Reg(0x03, "fragment output");
                RegMap._map['v'] = new Reg(0x04, "varying");
                RegMap._map['vi'] = new Reg(0x04, "varying output");
                RegMap._map['fi'] = new Reg(0x04, "varying input");
                RegMap._map['fs'] = new Reg(0x05, "sampler");
            }
            return RegMap._map;
        },
        enumerable: true,
        configurable: true
    });
    return RegMap;
}());

var Sampler = (function () {
    function Sampler(shift, mask, value) {
        this.shift = shift;
        this.mask = mask;
        this.value = value;
    }
    return Sampler;
}());

var SamplerMap = (function () {
    /*
     public static map =     [ new Sampler( 8, 0xf, 0 ),
     new Sampler( 8, 0xf, 5 ),
     new Sampler( 8, 0xf, 4 ),
     new Sampler( 8, 0xf, 1 ),
     new Sampler( 8, 0xf, 2 ),
     new Sampler( 8, 0xf, 1 ),
     new Sampler( 8, 0xf, 2 ),

     // dimension
     new Sampler( 12, 0xf, 0 ),
     new Sampler( 12, 0xf, 1 ),
     new Sampler( 12, 0xf, 2 ),

     // special
     new Sampler( 16, 1, 1 ),
     new Sampler( 16, 4, 4 ),

     // repeat
     new Sampler( 20, 0xf, 0 ),
     new Sampler( 20, 0xf, 1 ),
     new Sampler( 20, 0xf, 1 ),

     // mip
     new Sampler( 24, 0xf, 0 ),
     new Sampler( 24, 0xf, 0 ),
     new Sampler( 24, 0xf, 1 ),
     new Sampler( 24, 0xf, 2 ),

     // filter
     new Sampler( 28, 0xf, 0 ),
     new Sampler( 28, 0xf, 1 ) ]
     */
    /*
     public static rgba: Sampler = new Sampler( 8, 0xf, 0 );
     public static rg: Sampler = new Sampler( 8, 0xf, 5 );
     public static r: Sampler = new Sampler( 8, 0xf, 4 );
     public static compressed: Sampler = new Sampler( 8, 0xf, 1 );
     public static compressed_alpha: Sampler = new Sampler( 8, 0xf, 2 );
     public static dxt1: Sampler = new Sampler( 8, 0xf, 1 );
     public static dxt5: Sampler = new Sampler( 8, 0xf, 2 );

     // dimension
     public static sampler2d: Sampler = new Sampler( 12, 0xf, 0 );
     public static cube: Sampler = new Sampler( 12, 0xf, 1 );
     public static sampler3d: Sampler = new Sampler( 12, 0xf, 2 );

     // special
     public static centroid: Sampler = new Sampler( 16, 1, 1 );
     public static ignoresampler: Sampler = new Sampler( 16, 4, 4 );

     // repeat
     public static clamp: Sampler = new Sampler( 20, 0xf, 0 );
     public static repeat: Sampler = new Sampler( 20, 0xf, 1 );
     public static wrap: Sampler = new Sampler( 20, 0xf, 1 );

     // mip
     public static nomip: Sampler = new Sampler( 24, 0xf, 0 );
     public static mipnone: Sampler = new Sampler( 24, 0xf, 0 );
     public static mipnearest: Sampler = new Sampler( 24, 0xf, 1 );
     public static miplinear: Sampler = new Sampler( 24, 0xf, 2 );

     // filter
     public static nearest: Sampler = new Sampler( 28, 0xf, 0 );
     public static linear: Sampler = new Sampler( 28, 0xf, 1 );
     */
    function SamplerMap() {
    }
    Object.defineProperty(SamplerMap, "map", {
        get: function () {
            if (!SamplerMap._map) {
                SamplerMap._map = new Array();
                SamplerMap._map['rgba'] = new Sampler(8, 0xf, 0);
                SamplerMap._map['rg'] = new Sampler(8, 0xf, 5);
                SamplerMap._map['r'] = new Sampler(8, 0xf, 4);
                SamplerMap._map['compressed'] = new Sampler(8, 0xf, 1);
                SamplerMap._map['compressed_alpha'] = new Sampler(8, 0xf, 2);
                SamplerMap._map['dxt1'] = new Sampler(8, 0xf, 1);
                SamplerMap._map['dxt5'] = new Sampler(8, 0xf, 2);
                // dimension
                SamplerMap._map['2d'] = new Sampler(12, 0xf, 0);
                SamplerMap._map['cube'] = new Sampler(12, 0xf, 1);
                SamplerMap._map['3d'] = new Sampler(12, 0xf, 2);
                // special
                SamplerMap._map['centroid'] = new Sampler(16, 1, 1);
                SamplerMap._map['ignoresampler'] = new Sampler(16, 4, 4);
                // repeat
                SamplerMap._map['clamp'] = new Sampler(20, 0xf, 0);
                SamplerMap._map['repeat'] = new Sampler(20, 0xf, 1);
                SamplerMap._map['wrap'] = new Sampler(20, 0xf, 1);
                // mip
                SamplerMap._map['nomip'] = new Sampler(24, 0xf, 0);
                SamplerMap._map['mipnone'] = new Sampler(24, 0xf, 0);
                SamplerMap._map['mipnearest'] = new Sampler(24, 0xf, 1);
                SamplerMap._map['miplinear'] = new Sampler(24, 0xf, 2);
                // filter
                SamplerMap._map['nearest'] = new Sampler(28, 0xf, 0);
                SamplerMap._map['linear'] = new Sampler(28, 0xf, 1);
            }
            return SamplerMap._map;
        },
        enumerable: true,
        configurable: true
    });
    return SamplerMap;
}());

var AGALMiniAssembler = (function () {
    function AGALMiniAssembler() {
        this.r = {};
        this.cur = new Part();
    }
    AGALMiniAssembler.prototype.assemble = function (source, ext_part, ext_version) {
        if (ext_part === void 0) { ext_part = null; }
        if (ext_version === void 0) { ext_version = null; }
        if (!ext_version) {
            ext_version = 1;
        }
        if (ext_part) {
            this.addHeader(ext_part, ext_version);
        }
        var lines = source.replace(/[\f\n\r\v]+/g, "\n").split("\n"); // handle breaks, then split into lines
        for (var i in lines) {
            this.processLine(lines[i], i);
        }
        return this.r;
    };
    AGALMiniAssembler.prototype.processLine = function (line, linenr) {
        var startcomment = line.search("//"); // remove comments
        if (startcomment != -1) {
            line = line.slice(0, startcomment);
        }
        line = line.replace(/^\s+|\s+$/g, ""); // remove outer space
        if (!(line.length > 0)) {
            return;
        }
        var optsi = line.search(/<.*>/g); // split of options part <*> if there
        var opts = null;
        if (optsi != -1) {
            opts = line.slice(optsi).match(/([\w\.\-\+]+)/gi);
            line = line.slice(0, optsi);
        }
        // get opcode/command				            
        var tokens = line.match(/([\w\.\+\[\]]+)/gi); // get tokens in line
        if (!tokens || tokens.length < 1) {
            if (line.length >= 3) {
                console.log("Warning: bad line " + linenr + ": " + line);
            }
            return;
        }
        //console.log ( linenr, line, cur, tokens ); 
        switch (tokens[0]) {
            case "part":
                this.addHeader(tokens[1], Number(tokens[2]));
                break;
            case "endpart":
                if (!this.cur) {
                    throw "Unexpected endpart";
                }
                this.cur.data.position = 0;
                this.cur = null;
                return;
            default:
                if (!this.cur) {
                    console.log("Warning: bad line " + linenr + ": " + line + " (Outside of any part definition)");
                    return;
                }
                if (this.cur.name == "comment") {
                    return;
                }
                var op = OpcodeMap.map[tokens[0]];
                if (!op) {
                    throw "Bad opcode " + tokens[0] + " " + linenr + ": " + line;
                }
                // console.log( 'AGALMiniAssembler' , 'op' , op );
                this.emitOpcode(this.cur, op.opcode);
                var ti = 1;
                if (op.dest && op.dest != "none") {
                    if (!this.emitDest(this.cur, tokens[ti++], op.dest)) {
                        throw "Bad destination register " + tokens[ti - 1] + " " + linenr + ": " + line;
                    }
                }
                else {
                    this.emitZeroDword(this.cur);
                }
                if (op.a && op.a.format != "none") {
                    if (!this.emitSource(this.cur, tokens[ti++], op.a))
                        throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
                }
                else {
                    this.emitZeroQword(this.cur);
                }
                if (op.b && op.b.format != "none") {
                    if (op.b.format == "sampler") {
                        if (!this.emitSampler(this.cur, tokens[ti++], op.b, opts)) {
                            throw "Bad sampler register " + tokens[ti - 1] + " " + linenr + ": " + line;
                        }
                    }
                    else {
                        if (!this.emitSource(this.cur, tokens[ti++], op.b)) {
                            throw "Bad source register " + tokens[ti - 1] + " " + linenr + ": " + line;
                        }
                    }
                }
                else {
                    this.emitZeroQword(this.cur);
                }
                break;
        }
    };
    AGALMiniAssembler.prototype.emitHeader = function (pr) {
        pr.data.writeUnsignedByte(0xa0); // tag version
        pr.data.writeUnsignedInt(pr.version);
        if (pr.version >= 0x10) {
            pr.data.writeUnsignedByte(0); // align, for higher versions
        }
        pr.data.writeUnsignedByte(0xa1); // tag program id
        switch (pr.name) {
            case "fragment":
                pr.data.writeUnsignedByte(1);
                break;
            case "vertex":
                pr.data.writeUnsignedByte(0);
                break;
            case "cpu":
                pr.data.writeUnsignedByte(2);
                break;
            default:
                pr.data.writeUnsignedByte(0xff);
                break; // unknown/comment
        }
    };
    AGALMiniAssembler.prototype.emitOpcode = function (pr, opcode) {
        pr.data.writeUnsignedInt(opcode);
        //console.log ( "Emit opcode: ", opcode ); 
    };
    AGALMiniAssembler.prototype.emitZeroDword = function (pr) {
        pr.data.writeUnsignedInt(0);
    };
    AGALMiniAssembler.prototype.emitZeroQword = function (pr) {
        pr.data.writeUnsignedInt(0);
        pr.data.writeUnsignedInt(0);
    };
    AGALMiniAssembler.prototype.emitDest = function (pr, token, opdest) {
        //console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map' , RegMap.map);
        var reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:mask
        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'reg' , reg , reg[1] , RegMap.map[reg[1]] );
        // console.log( 'AGALMiniAssembler' , 'emitDest' , 'RegMap.map[reg[1]]' , RegMap.map[reg[1]] , 'bool' , !RegMap.map[reg[1]] ) ;
        if (!RegMap.map[reg[1]])
            return false;
        var em = { num: reg[2] ? reg[2] : 0, code: RegMap.map[reg[1]].code, mask: this.stringToMask(reg[3]) };
        pr.data.writeUnsignedShort(em.num);
        pr.data.writeUnsignedByte(em.mask);
        pr.data.writeUnsignedByte(em.code);
        //console.log ( "  Emit dest: ", em );
        return true;
    };
    AGALMiniAssembler.prototype.stringToMask = function (s) {
        if (!s)
            return 0xf;
        var r = 0;
        if (s.indexOf("x") != -1)
            r |= 1;
        if (s.indexOf("y") != -1)
            r |= 2;
        if (s.indexOf("z") != -1)
            r |= 4;
        if (s.indexOf("w") != -1)
            r |= 8;
        return r;
    };
    AGALMiniAssembler.prototype.stringToSwizzle = function (s) {
        if (!s) {
            return 0xe4;
        }
        var chartoindex = { x: 0, y: 1, z: 2, w: 3 };
        var sw = 0;
        if (s.charAt(0) != ".") {
            throw "Missing . for swizzle";
        }
        if (s.length > 1) {
            sw |= chartoindex[s.charAt(1)];
        }
        if (s.length > 2) {
            sw |= chartoindex[s.charAt(2)] << 2;
        }
        else {
            sw |= (sw & 3) << 2;
        }
        if (s.length > 3) {
            sw |= chartoindex[s.charAt(3)] << 4;
        }
        else {
            sw |= (sw & (3 << 2)) << 2;
        }
        if (s.length > 4) {
            sw |= chartoindex[s.charAt(4)] << 6;
        }
        else {
            sw |= (sw & (3 << 4)) << 2;
        }
        return sw;
    };
    AGALMiniAssembler.prototype.emitSampler = function (pr, token, opsrc, opts) {
        var reg = token.match(/fs(\d*)/i); // g1:regnum
        if (!reg || !reg[1]) {
            return false;
        }
        pr.data.writeUnsignedShort(parseInt(reg[1]));
        pr.data.writeUnsignedByte(0); // bias
        pr.data.writeUnsignedByte(0);
        /*
         pr.data.writeUnsignedByte ( 0x5 );
         pr.data.writeUnsignedByte ( 0 );   // readmode, dim
         pr.data.writeUnsignedByte ( 0 );   // special, wrap
         pr.data.writeUnsignedByte ( 0 );   // mip, filter
         */
        var samplerbits = 0x5;
        var sampleroptset = 0;
        for (var i = 0; i < opts.length; i++) {
            var o = SamplerMap.map[opts[i].toLowerCase()];
            //console.log( 'AGALMiniAssembler' , 'emitSampler' , 'SampleMap opt:' , o , '<-------- WATCH FOR THIS');
            if (o) {
                if (((sampleroptset >> o.shift) & o.mask) != 0) {
                    console.log("Warning, duplicate sampler option");
                }
                sampleroptset |= o.mask << o.shift;
                samplerbits &= ~(o.mask << o.shift);
                samplerbits |= o.value << o.shift;
            }
            else {
                console.log("Warning, unknown sampler option: ", opts[i]);
            }
        }
        pr.data.writeUnsignedInt(samplerbits);
        return true;
    };
    AGALMiniAssembler.prototype.emitSource = function (pr, token, opsrc) {
        var indexed = token.match(/vc\[(v[tcai])(\d+)\.([xyzw])([\+\-]\d+)?\](\.[xyzw]{1,4})?/i); // g1: indexregname, g2:indexregnum, g3:select, [g4:offset], [g5:swizzle]
        var reg;
        if (indexed) {
            if (!RegMap.map[indexed[1]]) {
                return false;
            }
            var selindex = { x: 0, y: 1, z: 2, w: 3 };
            var em = { num: indexed[2] | 0, code: RegMap.map[indexed[1]].code, swizzle: this.stringToSwizzle(indexed[5]), select: selindex[indexed[3]], offset: indexed[4] | 0 };
            pr.data.writeUnsignedShort(em.num);
            pr.data.writeByte(em.offset);
            pr.data.writeUnsignedByte(em.swizzle);
            pr.data.writeUnsignedByte(0x1); // constant reg
            pr.data.writeUnsignedByte(em.code);
            pr.data.writeUnsignedByte(em.select);
            pr.data.writeUnsignedByte(1 << 7);
        }
        else {
            reg = token.match(/([fov]?[tpocidavs])(\d*)(\.[xyzw]{1,4})?/i); // g1: regname, g2:regnum, g3:swizzle
            if (!RegMap.map[reg[1]]) {
                return false;
            }
            var em = { num: reg[2] | 0, code: RegMap.map[reg[1]].code, swizzle: this.stringToSwizzle(reg[3]) };
            pr.data.writeUnsignedShort(em.num);
            pr.data.writeUnsignedByte(0);
            pr.data.writeUnsignedByte(em.swizzle);
            pr.data.writeUnsignedByte(em.code);
            pr.data.writeUnsignedByte(0);
            pr.data.writeUnsignedByte(0);
            pr.data.writeUnsignedByte(0);
        }
        return true;
    };
    AGALMiniAssembler.prototype.addHeader = function (partname, version) {
        if (!version) {
            version = 1;
        }
        if (this.r[partname] == undefined) {
            this.r[partname] = new Part(partname, version);
            this.emitHeader(this.r[partname]);
        }
        else if (this.r[partname].version != version) {
            throw "Multiple versions for part " + partname;
        }
        this.cur = this.r[partname];
    };
    return AGALMiniAssembler;
}());

var Header = (function () {
    function Header() {
        this.progid = 0;
        this.version = 0;
        this.type = "";
    }
    return Header;
}());

var Description = (function () {
    function Description() {
        this.regread = [
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ];
        this.regwrite = [
            [],
            [],
            [],
            [],
            [],
            [],
            []
        ];
        this.hasindirect = false;
        this.writedepth = false;
        this.hasmatrix = false;
        this.samplers = [];
        // added due to dynamic assignment 3*0xFFFFFFuuuu
        this.tokens = [];
        this.header = new Header();
    }
    return Description;
}());

var OpLUT = (function () {
    function OpLUT(s, flags, dest, a, b, matrixwidth, matrixheight, ndwm, scaler, dm, lod) {
        this.s = s;
        this.flags = flags;
        this.dest = dest;
        this.a = a;
        this.b = b;
        this.matrixwidth = matrixwidth;
        this.matrixheight = matrixheight;
        this.ndwm = ndwm;
        this.scalar = scaler;
        this.dm = dm;
        this.lod = lod;
    }
    return OpLUT;
}());

var Mapping = (function () {
    //TODO: get rid of hack that fixes including definition file
    function Mapping(include) {
    }
    return Mapping;
}());
Mapping.agal2glsllut = [
    //         s 												flags   dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
    new OpLUT("%dest = %cast(%a);\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(%a + %b);\n", 0, true, true, true, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(%a - %b);\n", 0, true, true, true, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(%a * %b);\n", 0, true, true, true, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(%a / %b);\n", 0, true, true, true, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(1.0) / %a;\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(min(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(max(%a,%b));\n", 0, true, true, true, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(fract(%a));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(sqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(inversesqrt(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(pow(abs(%a),%b));\n", 0, true, true, true, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(log2(abs(%a)));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(exp2(%a));\n", 0, true, true, false, null, null, null, null, null, null),
    //         s 												flags  	dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
    new OpLUT("%dest = %cast(normalize(vec3( %a ) ));\n", 0, true, true, false, null, null, true, null, null, null),
    new OpLUT("%dest = %cast(sin(%a));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(cos(%a));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(cross(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
    new OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
    new OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", 0, true, true, true, null, null, true, null, null, null),
    new OpLUT("%dest = %cast(abs(%a));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(%a * -1.0);\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(clamp(%a,0.0,1.0));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(dot(vec3(%a),vec3(%b)));\n", null, true, true, true, 3, 3, true, null, null, null),
    new OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 4, true, null, null, null),
    new OpLUT("%dest = %cast(dot(vec4(%a),vec4(%b)));\n", null, true, true, true, 4, 3, true, null, null, null),
    //s:string, flags:number, dest:boolean, a:boolean, b:boolean, matrixwidth:number, matrixheight:number, ndwm:boolean, scaler:boolean, dm:boolean, lod:boolean
    new OpLUT("%dest = %cast(dFdx(%a));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("%dest = %cast(dFdy(%a));\n", 0, true, true, false, null, null, null, null, null, null),
    new OpLUT("if (float(%a)==float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT("if (float(%a)!=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT("if (float(%a)>=float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT("if (float(%a)<float(%b)) {;\n", 0, false, true, true, null, null, null, true, null, null), new OpLUT("} else {;\n", 0, false, false, false, null, null, null, null, null, null), new OpLUT("};\n", 0, false, false, false, null, null, null, null, null, null), new OpLUT(null, null, null, null, false, null, null, null, null, null, null), new OpLUT(null, null, null, null, false, null, null, null, null, null, null), new OpLUT(null, null, null, null, false, null, null, null, null, null, null), new OpLUT(null, null, null, null, false, null, null, null, null, null, null),
    //         s 															flags  	dest    a     b 	    mw 	  mh    ndwm  scale dm	  lod
    new OpLUT("%dest = %cast(texture%texdimLod(%b,%texsize(%a)).%dm);\n", null, true, true, true, null, null, null, null, true, null), new OpLUT("if ( float(%a)<0.0 ) discard;\n", null, false, true, false, null, null, null, true, null, null), new OpLUT("%dest = %cast(texture%texdim(%b,%texsize(%a)%lod).%dm);\n", null, true, true, true, null, null, true, null, true, true), new OpLUT("%dest = %cast(greaterThanEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT("%dest = %cast(lessThan(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT("%dest = %cast(sign(%a));\n", 0, true, true, false, null, null, null, null, null, null), new OpLUT("%dest = %cast(equal(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null), new OpLUT("%dest = %cast(notEqual(%a,%b).%dm);\n", 0, true, true, true, null, null, true, null, true, null)
];

var Destination = (function () {
    function Destination() {
        this.mask = 0;
        this.regnum = 0;
        this.regtype = 0;
        this.dim = 0;
        this.indexoffset = 0;
        this.swizzle = 0;
        this.lodbiad = 0;
        this.readmode = 0;
        this.special = 0;
        this.wrap = 0;
        this.filter = 0;
        this.indexregtype = 0;
        this.indexselect = 0;
        this.indirectflag = 0;
    }
    return Destination;
}());

var Token = (function () {
    function Token() {
        this.dest = new Destination();
        this.opcode = 0;
        this.a = new Destination();
        this.b = new Destination();
    }
    return Token;
}());

var AGALTokenizer = (function () {
    function AGALTokenizer() {
    }
    AGALTokenizer.prototype.decribeAGALByteArray = function (bytes) {
        var header = new Header();
        if (bytes.readUnsignedByte() != 0xa0) {
            throw "Bad AGAL: Missing 0xa0 magic byte.";
        }
        header.version = bytes.readUnsignedInt();
        if (header.version >= 0x10) {
            bytes.readUnsignedByte();
            header.version >>= 1;
        }
        if (bytes.readUnsignedByte() != 0xa1) {
            throw "Bad AGAL: Missing 0xa1 magic byte.";
        }
        header.progid = bytes.readUnsignedByte();
        switch (header.progid) {
            case 1:
                header.type = "fragment";
                break;
            case 0:
                header.type = "vertex";
                break;
            case 2:
                header.type = "cpu";
                break;
            default:
                header.type = "";
                break;
        }
        var desc = new Description();
        var tokens = [];
        while (bytes.position < bytes.length) {
            var token = new Token();
            token.opcode = bytes.readUnsignedInt();
            var lutentry = Mapping.agal2glsllut[token.opcode];
            if (!lutentry) {
                throw "Opcode not valid or not implemented yet: " + token.opcode;
            }
            if (lutentry.matrixheight) {
                desc.hasmatrix = true;
            }
            if (lutentry.dest) {
                token.dest.regnum = bytes.readUnsignedShort();
                token.dest.mask = bytes.readUnsignedByte();
                token.dest.regtype = bytes.readUnsignedByte();
                desc.regwrite[token.dest.regtype][token.dest.regnum] |= token.dest.mask;
            }
            else {
                token.dest = null;
                bytes.readUnsignedInt();
            }
            if (lutentry.a) {
                this.readReg(token.a, 1, desc, bytes);
            }
            else {
                token.a = null;
                bytes.readUnsignedInt();
                bytes.readUnsignedInt();
            }
            if (lutentry.b) {
                this.readReg(token.b, lutentry.matrixheight | 0, desc, bytes);
            }
            else {
                token.b = null;
                bytes.readUnsignedInt();
                bytes.readUnsignedInt();
            }
            tokens.push(token);
        }
        desc.header = header;
        desc.tokens = tokens;
        return desc;
    };
    AGALTokenizer.prototype.readReg = function (s, mh, desc, bytes) {
        s.regnum = bytes.readUnsignedShort();
        s.indexoffset = bytes.readByte();
        s.swizzle = bytes.readUnsignedByte();
        s.regtype = bytes.readUnsignedByte();
        desc.regread[s.regtype][s.regnum] = 0xf; // sould be swizzle to mask? should be |=                                                 
        if (s.regtype == 0x5) {
            // sampler
            s.lodbiad = s.indexoffset;
            s.indexoffset = undefined;
            s.swizzle = undefined;
            // sampler 
            s.readmode = bytes.readUnsignedByte();
            s.dim = s.readmode >> 4;
            s.readmode &= 0xf;
            s.special = bytes.readUnsignedByte();
            s.wrap = s.special >> 4;
            s.special &= 0xf;
            s.mipmap = bytes.readUnsignedByte();
            s.filter = s.mipmap >> 4;
            s.mipmap &= 0xf;
            desc.samplers[s.regnum] = s;
        }
        else {
            s.indexregtype = bytes.readUnsignedByte();
            s.indexselect = bytes.readUnsignedByte();
            s.indirectflag = bytes.readUnsignedByte();
        }
        if (s.indirectflag) {
            desc.hasindirect = true;
        }
        if (!s.indirectflag && mh) {
            for (var mhi = 0; mhi < mh; mhi++) {
                desc.regread[s.regtype][s.regnum + mhi] = desc.regread[s.regtype][s.regnum];
            }
        }
    };
    return AGALTokenizer;
}());

var AGLSLParser = (function () {
    function AGLSLParser() {
    }
    AGLSLParser.prototype.parse = function (desc, precision) {
        var header = "";
        var body = "";
        header += "precision " + precision + " float;\n";
        var tag = desc.header.type[0]; //TODO
        // declare uniforms
        if (desc.header.type == "vertex") {
            header += "uniform float yflip;\n";
        }
        // if (!desc.hasindirect) {
        // 	for (var i:number = 0; i < desc.regread[0x1].length; i++) {
        // 		if (desc.regread[0x1][i]) {
        // 			header += "uniform vec4 " + tag + "c" + i + ";\n";
        // 		}
        // 	}
        // } else {
        // 	header += "uniform vec4 " + tag + "carrr[" + AGLSLParser.maxvertexconstants + "];\n";                // use max const count instead
        // }
        var constcount = desc.regread[0x1].length;
        if (constcount > 0)
            header += "uniform vec4 " + tag + "c[" + constcount + "];\n";
        // declare temps
        for (var i = 0; i < desc.regread[0x2].length || i < desc.regwrite[0x2].length; i++) {
            if (desc.regread[0x2][i] || desc.regwrite[0x2][i]) {
                header += "vec4 " + tag + "t" + i + ";\n";
            }
        }
        // declare streams
        for (var i = 0; i < desc.regread[0x0].length; i++) {
            if (desc.regread[0x0][i]) {
                header += "attribute vec4 va" + i + ";\n";
            }
        }
        // declare interpolated
        for (var i = 0; i < desc.regread[0x4].length || i < desc.regwrite[0x4].length; i++) {
            if (desc.regread[0x4][i] || desc.regwrite[0x4][i]) {
                header += "varying vec4 vi" + i + ";\n";
            }
        }
        // declare samplers
        var samptype = ["2D", "Cube", "3D", ""];
        for (var i = 0; i < desc.samplers.length; i++) {
            if (desc.samplers[i]) {
                header += "uniform sampler" + samptype[desc.samplers[i].dim & 3] + " fs" + i + ";\n";
            }
        }
        // extra gl fluff: setup position and depth adjust temps
        if (desc.header.type == "vertex") {
            header += "vec4 outpos;\n";
        }
        if (desc.writedepth) {
            header += "vec4 tmp_FragDepth;\n";
        }
        //if ( desc.hasmatrix ) 
        //    header += "vec4 tmp_matrix;\n";
        var derivatives = false;
        // start body of code
        body += "void main() {\n";
        for (var i = 0; i < desc.tokens.length; i++) {
            var lutentry = Mapping.agal2glsllut[desc.tokens[i].opcode];
            if (lutentry.s.indexOf("dFdx") != -1 || lutentry.s.indexOf("dFdy") != -1)
                derivatives = true;
            if (!lutentry) {
                throw "Opcode not valid or not implemented yet: ";
            }
            var sublines = lutentry.matrixheight || 1;
            for (var sl = 0; sl < sublines; sl++) {
                var line = "  " + lutentry.s;
                if (desc.tokens[i].dest) {
                    if (lutentry.matrixheight) {
                        if (((desc.tokens[i].dest.mask >> sl) & 1) != 1) {
                            continue;
                        }
                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
                        var destcaststring = "float";
                        var destmaskstring = ["x", "y", "z", "w"][sl];
                        destregstring += "." + destmaskstring;
                    }
                    else {
                        var destregstring = this.regtostring(desc.tokens[i].dest.regtype, desc.tokens[i].dest.regnum, desc, tag);
                        var destcaststring;
                        var destmaskstring;
                        if (desc.tokens[i].dest.mask != 0xf) {
                            var ndest = 0;
                            destmaskstring = "";
                            if (desc.tokens[i].dest.mask & 1) {
                                ndest++;
                                destmaskstring += "x";
                            }
                            if (desc.tokens[i].dest.mask & 2) {
                                ndest++;
                                destmaskstring += "y";
                            }
                            if (desc.tokens[i].dest.mask & 4) {
                                ndest++;
                                destmaskstring += "z";
                            }
                            if (desc.tokens[i].dest.mask & 8) {
                                ndest++;
                                destmaskstring += "w";
                            }
                            destregstring += "." + destmaskstring;
                            switch (ndest) {
                                case 1:
                                    destcaststring = "float";
                                    break;
                                case 2:
                                    destcaststring = "vec2";
                                    break;
                                case 3:
                                    destcaststring = "vec3";
                                    break;
                                default:
                                    throw "Unexpected destination mask";
                            }
                        }
                        else {
                            destcaststring = "vec4";
                            destmaskstring = "xyzw";
                        }
                    }
                    line = line.replace("%dest", destregstring);
                    line = line.replace("%cast", destcaststring);
                    line = line.replace("%dm", destmaskstring);
                }
                var dwm = 0xf;
                if (!lutentry.ndwm && lutentry.dest && desc.tokens[i].dest) {
                    dwm = desc.tokens[i].dest.mask;
                }
                if (desc.tokens[i].a) {
                    line = line.replace("%a", this.sourcetostring(desc.tokens[i].a, 0, dwm, lutentry.scalar, desc, tag));
                }
                if (desc.tokens[i].b) {
                    line = line.replace("%b", this.sourcetostring(desc.tokens[i].b, sl, dwm, lutentry.scalar, desc, tag));
                    if (desc.tokens[i].b.regtype == 0x5) {
                        // sampler dim
                        var texdim = ["2D", "Cube", "3D"][desc.tokens[i].b.dim];
                        var texsize = ["vec2", "vec3", "vec3"][desc.tokens[i].b.dim];
                        line = line.replace("%texdim", texdim);
                        line = line.replace("%texsize", texsize);
                        var texlod = "";
                        line = line.replace("%lod", texlod);
                    }
                }
                body += line;
            }
        }
        // adjust z from opengl range of -1..1 to 0..1 as in d3d, this also enforces a left handed coordinate system
        if (desc.header.type == "vertex") {
            body += "  gl_Position = vec4(outpos.x, outpos.y, outpos.z*2.0 - outpos.w, outpos.w);\n";
        }
        //flag based switch
        if (derivatives && desc.header.type == "fragment") {
            header = "#extension GL_OES_standard_derivatives : enable\n" + header;
        }
        // clamp fragment depth
        if (desc.writedepth) {
            body += "  gl_FragDepth = clamp(tmp_FragDepth,0.0,1.0);\n";
        }
        // close main
        body += "}\n";
        return header + body;
    };
    AGLSLParser.prototype.regtostring = function (regtype, regnum, desc, tag) {
        switch (regtype) {
            case 0x0:
                return "va" + regnum;
            case 0x1:
                return desc.header.type[0] + "c[" + regnum + "]";
            // case 0x1:
            // 	if (desc.hasindirect && desc.header.type == "vertex") {
            // 		return "vcarrr[" + regnum + "]";
            // 	} else {
            // 		return tag + "c" + regnum;
            // 	}
            case 0x2:
                return tag + "t" + regnum;
            case 0x3:
                return desc.header.type == "vertex" ? "outpos" : "gl_FragColor";
            case 0x4:
                return "vi" + regnum;
            case 0x5:
                return "fs" + regnum;
            case 0x6:
                return "tmp_FragDepth";
            default:
                throw "Unknown register type";
        }
    };
    AGLSLParser.prototype.sourcetostring = function (s, subline, dwm, isscalar, desc, tag) {
        var swiz = ["x", "y", "z", "w"];
        var r;
        if (s.indirectflag) {
            r = "vcarrr[int(" + this.regtostring(s.indexregtype, s.regnum, desc, tag) + "." + swiz[s.indexselect] + ")";
            var realofs = subline + s.indexoffset;
            if (realofs < 0)
                r += realofs.toString();
            if (realofs > 0)
                r += "+" + realofs.toString();
            r += "]";
        }
        else {
            r = this.regtostring(s.regtype, s.regnum + subline, desc, tag);
        }
        // samplers never add swizzle        
        if (s.regtype == 0x5) {
            return r;
        }
        // scalar, first component only
        if (isscalar) {
            return r + "." + swiz[(s.swizzle >> 0) & 3];
        }
        // identity
        if (s.swizzle == 0xe4 && dwm == 0xf) {
            return r;
        }
        // with destination write mask folded in
        r += ".";
        if (dwm & 1)
            r += swiz[(s.swizzle >> 0) & 3];
        if (dwm & 2)
            r += swiz[(s.swizzle >> 2) & 3];
        if (dwm & 4)
            r += swiz[(s.swizzle >> 4) & 3];
        if (dwm & 8)
            r += swiz[(s.swizzle >> 6) & 3];
        return r;
    };
    return AGLSLParser;
}());
AGLSLParser.maxvertexconstants = 128;
AGLSLParser.maxfragconstants = 28;
AGLSLParser.maxtemp = 8;
AGLSLParser.maxstreams = 8;
AGLSLParser.maxtextures = 8;

/**
 * A single register element (an entire register or a single register's component) used by the RegisterPool.
 */
var ShaderRegisterElement = (function () {
    /**
     * Creates a new ShaderRegisterElement object.
     *
     * @param regName The name of the register.
     * @param index The index of the register.
     * @param component The register's component, if not the entire register is represented.
     */
    function ShaderRegisterElement(regName, index, component) {
        if (component === void 0) { component = -1; }
        this._component = component;
        this._regName = regName;
        this._index = index;
        this._toStr = this._regName;
        if (this._index >= 0)
            this._toStr += this._index;
        if (component > -1)
            this._toStr += "." + ShaderRegisterElement.COMPONENTS[component];
    }
    /**
     * Converts the register or the components AGAL string representation.
     */
    ShaderRegisterElement.prototype.toString = function () {
        return this._toStr;
    };
    Object.defineProperty(ShaderRegisterElement.prototype, "regName", {
        /**
         * The register's name.
         */
        get: function () {
            return this._regName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterElement.prototype, "index", {
        /**
         * The register's index.
         */
        get: function () {
            return this._index;
        },
        enumerable: true,
        configurable: true
    });
    return ShaderRegisterElement;
}());
ShaderRegisterElement.COMPONENTS = ["x", "y", "z", "w"];

/**
 * ...
 */
var AnimationRegisterData = (function () {
    function AnimationRegisterData() {
        this.indexDictionary = new Object();
    }
    AnimationRegisterData.prototype.reset = function (registerCache, sharedRegisters, needVelocity) {
        this.rotationRegisters = new Array();
        this.positionAttribute = sharedRegisters.animatableAttributes[0];
        this.scaleAndRotateTarget = sharedRegisters.animationTargetRegisters[0];
        for (var i = 1; i < sharedRegisters.animationTargetRegisters.length; i++)
            this.rotationRegisters.push(sharedRegisters.animationTargetRegisters[i]);
        //allot const register
        this.vertexZeroConst = registerCache.getFreeVertexConstant();
        this.vertexZeroConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 0);
        this.vertexOneConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 1);
        this.vertexTwoConst = new ShaderRegisterElement(this.vertexZeroConst.regName, this.vertexZeroConst.index, 2);
        //allot temp register
        this.positionTarget = registerCache.getFreeVertexVectorTemp();
        registerCache.addVertexTempUsages(this.positionTarget, 1);
        this.positionTarget = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);
        if (needVelocity) {
            this.velocityTarget = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(this.velocityTarget, 1);
            this.velocityTarget = new ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index);
            this.vertexTime = new ShaderRegisterElement(this.velocityTarget.regName, this.velocityTarget.index, 3);
            this.vertexLife = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index, 3);
        }
        else {
            var tempTime = registerCache.getFreeVertexVectorTemp();
            registerCache.addVertexTempUsages(tempTime, 1);
            this.vertexTime = new ShaderRegisterElement(tempTime.regName, tempTime.index, 0);
            this.vertexLife = new ShaderRegisterElement(tempTime.regName, tempTime.index, 1);
        }
    };
    AnimationRegisterData.prototype.setUVSourceAndTarget = function (sharedRegisters) {
        this.uvVar = sharedRegisters.uvTarget;
        this.uvAttribute = sharedRegisters.uvSource;
        //uv action is processed after normal actions,so use offsetTarget as uvTarget
        this.uvTarget = new ShaderRegisterElement(this.positionTarget.regName, this.positionTarget.index);
    };
    AnimationRegisterData.prototype.setRegisterIndex = function (node, parameterIndex, registerIndex) {
        //8 should be enough for any node.
        var t = this.indexDictionary[node.id];
        if (t == null)
            t = this.indexDictionary[node.id] = new Array(8);
        t[parameterIndex] = registerIndex;
    };
    AnimationRegisterData.prototype.getRegisterIndex = function (node, parameterIndex) {
        return this.indexDictionary[node.id][parameterIndex];
    };
    return AnimationRegisterData;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

var AnimationSetError = (function (_super) {
    __extends(AnimationSetError, _super);
    function AnimationSetError(message) {
        return _super.call(this, message) || this;
    }
    return AnimationSetError;
}(_awayjs_core.ErrorBase));

/**
 * Provides an abstract base class for data set classes that hold animation data for use in animator classes.
 *
 * @see away.animators.AnimatorBase
 */
var AnimationSetBase = (function (_super) {
    __extends(AnimationSetBase, _super);
    function AnimationSetBase() {
        var _this = _super.call(this) || this;
        _this._animations = new Array();
        _this._animationNames = new Array();
        _this._animationDictionary = new Object();
        return _this;
    }
    /**
     * Retrieves a temporary GPU register that's still free.
     *
     * @param exclude An array of non-free temporary registers.
     * @param excludeAnother An additional register that's not free.
     * @return A temporary register that can be used.
     */
    AnimationSetBase.prototype._pFindTempReg = function (exclude, excludeAnother) {
        if (excludeAnother === void 0) { excludeAnother = null; }
        var i = 0;
        var reg;
        while (true) {
            reg = "vt" + i;
            if (exclude.indexOf(reg) == -1 && excludeAnother != reg)
                return reg;
            ++i;
        }
    };
    Object.defineProperty(AnimationSetBase.prototype, "usesCPU", {
        /**
         * Indicates whether the properties of the animation data contained within the set combined with
         * the vertex registers already in use on shading materials allows the animation data to utilise
         * GPU calls.
         */
        get: function () {
            return this._usesCPU;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Called by the material to reset the GPU indicator before testing whether register space in the shader
     * is available for running GPU-based animation code.
     *
     * @private
     */
    AnimationSetBase.prototype.resetGPUCompatibility = function () {
        this._usesCPU = false;
    };
    AnimationSetBase.prototype.cancelGPUCompatibility = function () {
        this._usesCPU = true;
    };
    /**
     * @inheritDoc
     */
    AnimationSetBase.prototype.getAGALVertexCode = function (shader, registerCache, sharedRegisters) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * @inheritDoc
     */
    AnimationSetBase.prototype.getAGALFragmentCode = function (shader, registerCache, shadedTarget) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * @inheritDoc
     */
    AnimationSetBase.prototype.getAGALUVCode = function (shader, registerCache, sharedRegisters) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * @inheritDoc
     */
    AnimationSetBase.prototype.doneAGALCode = function (shader) {
        throw new _awayjs_core.AbstractMethodError();
    };
    Object.defineProperty(AnimationSetBase.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AnimationSetBase.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationSetBase.prototype, "animations", {
        /**
         * Returns a vector of animation state objects that make up the contents of the animation data set.
         */
        get: function () {
            return this._animations;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimationSetBase.prototype, "animationNames", {
        /**
         * Returns a vector of animation state objects that make up the contents of the animation data set.
         */
        get: function () {
            return this._animationNames;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Check to determine whether a state is registered in the animation set under the given name.
     *
     * @param stateName The name of the animation state object to be checked.
     */
    AnimationSetBase.prototype.hasAnimation = function (name) {
        return this._animationDictionary[name] != null;
    };
    /**
     * Retrieves the animation state object registered in the animation data set under the given name.
     *
     * @param stateName The name of the animation state object to be retrieved.
     */
    AnimationSetBase.prototype.getAnimation = function (name) {
        return this._animationDictionary[name];
    };
    /**
     * Adds an animation state object to the aniamtion data set under the given name.
     *
     * @param stateName The name under which the animation state object will be stored.
     * @param animationState The animation state object to be staored in the set.
     */
    AnimationSetBase.prototype.addAnimation = function (node) {
        if (this._animationDictionary[node.name])
            throw new AnimationSetError("root node name '" + node.name + "' already exists in the set");
        this._animationDictionary[node.name] = node;
        this._animations.push(node);
        this._animationNames.push(node.name);
    };
    /**
     * Cleans up any resources used by the current object.
     */
    AnimationSetBase.prototype.dispose = function () {
    };
    return AnimationSetBase;
}(_awayjs_core.AssetBase));
AnimationSetBase.assetType = "[asset AnimationSet]";

/**
 * Dispatched to notify changes in an animator's state.
 */
var AnimatorEvent = (function (_super) {
    __extends(AnimatorEvent, _super);
    /**
     * Create a new <code>AnimatorEvent</code> object.
     *
     * @param type The event type.
     * @param animator The animator object that is the subject of this event.
     */
    function AnimatorEvent(type, animator) {
        var _this = _super.call(this, type) || this;
        _this._animator = animator;
        return _this;
    }
    Object.defineProperty(AnimatorEvent.prototype, "animator", {
        get: function () {
            return this._animator;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Clones the event.
     *
     * @return An exact duplicate of the current event object.
     */
    AnimatorEvent.prototype.clone = function () {
        return new AnimatorEvent(this.type, this._animator);
    };
    return AnimatorEvent;
}(_awayjs_core.EventBase));
/**
 * Defines the value of the type property of a start event object.
 */
AnimatorEvent.START = "animatorStart";
/**
 * Defines the value of the type property of a stop event object.
 */
AnimatorEvent.STOP = "animatorStop";
/**
 * Defines the value of the type property of a cycle complete event object.
 */
AnimatorEvent.CYCLE_COMPLETE = "animatorCycleComplete";

/**
 * Dispatched when playback of an animation inside the animator object starts.
 *
 * @eventType away3d.events.AnimatorEvent
 */
//[Event(name="start", type="away3d.events.AnimatorEvent")]
/**
 * Dispatched when playback of an animation inside the animator object stops.
 *
 * @eventType away3d.events.AnimatorEvent
 */
//[Event(name="stop", type="away3d.events.AnimatorEvent")]
/**
 * Dispatched when playback of an animation reaches the end of an animation.
 *
 * @eventType away3d.events.AnimatorEvent
 */
//[Event(name="cycle_complete", type="away3d.events.AnimatorEvent")]
/**
 * Provides an abstract base class for animator classes that control animation output from a data set subtype of <code>AnimationSetBase</code>.
 *
 * @see away.animators.AnimationSetBase
 */
var AnimatorBase = (function (_super) {
    __extends(AnimatorBase, _super);
    /**
     * Creates a new <code>AnimatorBase</code> object.
     *
     * @param animationSet The animation data set to be used by the animator object.
     */
    function AnimatorBase(animationSet) {
        var _this = _super.call(this) || this;
        _this._autoUpdate = true;
        _this._time = 0;
        _this._playbackSpeed = 1;
        _this._pOwners = new Array();
        _this._pAbsoluteTime = 0;
        _this._animationStates = new Object();
        /**
         * Enables translation of the animated graphics from data returned per frame via the positionDelta property of the active animation node. Defaults to true.
         *
         * @see away.animators.IAnimationState#positionDelta
         */
        _this.updatePosition = true;
        _this._pAnimationSet = animationSet;
        _this._broadcaster = new _awayjs_core.RequestAnimationFrame(_this.onEnterFrame, _this);
        return _this;
    }
    AnimatorBase.prototype.getAnimationState = function (node) {
        var className = node.stateClass;
        var uID = node.id;
        if (this._animationStates[uID] == null)
            this._animationStates[uID] = new className(this, node);
        return this._animationStates[uID];
    };
    AnimatorBase.prototype.getAnimationStateByName = function (name) {
        return this.getAnimationState(this._pAnimationSet.getAnimation(name));
    };
    Object.defineProperty(AnimatorBase.prototype, "absoluteTime", {
        /**
         * Returns the internal absolute time of the animator, calculated by the current time and the playback speed.
         *
         * @see #time
         * @see #playbackSpeed
         */
        get: function () {
            return this._pAbsoluteTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "animationSet", {
        /**
         * Returns the animation data set in use by the animator.
         */
        get: function () {
            return this._pAnimationSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "activeState", {
        /**
         * Returns the current active animation state.
         */
        get: function () {
            return this._pActiveState;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "activeAnimation", {
        /**
         * Returns the current active animation node.
         */
        get: function () {
            return this._pAnimationSet.getAnimation(this._pActiveAnimationName);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "activeAnimationName", {
        /**
         * Returns the current active animation node.
         */
        get: function () {
            return this._pActiveAnimationName;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "autoUpdate", {
        /**
         * Determines whether the animators internal update mechanisms are active. Used in cases
         * where manual updates are required either via the <code>time</code> property or <code>update()</code> method.
         * Defaults to true.
         *
         * @see #time
         * @see #update()
         */
        get: function () {
            return this._autoUpdate;
        },
        set: function (value) {
            if (this._autoUpdate == value)
                return;
            this._autoUpdate = value;
            if (this._autoUpdate)
                this.start();
            else
                this.stop();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AnimatorBase.prototype, "time", {
        /**
         * Gets and sets the internal time clock of the animator.
         */
        get: function () {
            return this._time;
        },
        set: function (value) {
            if (this._time == value)
                return;
            this.update(value);
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Sets the animation phase of the current active state's animation clip(s).
     *
     * @param value The phase value to use. 0 represents the beginning of an animation clip, 1 represents the end.
     */
    AnimatorBase.prototype.phase = function (value) {
        this._pActiveState.phase(value);
    };
    Object.defineProperty(AnimatorBase.prototype, "playbackSpeed", {
        /**
         * The amount by which passed time should be scaled. Used to slow down or speed up animations. Defaults to 1.
         */
        get: function () {
            return this._playbackSpeed;
        },
        set: function (value) {
            this._playbackSpeed = value;
        },
        enumerable: true,
        configurable: true
    });
    AnimatorBase.prototype.setRenderState = function (shader, renderable, stage, projection) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * Resumes the automatic playback clock controling the active state of the animator.
     */
    AnimatorBase.prototype.start = function () {
        if (this._isPlaying || !this._autoUpdate)
            return;
        this._time = this._pAbsoluteTime = _awayjs_core.getTimer();
        this._isPlaying = true;
        this._broadcaster.start();
        if (!this.hasEventListener(AnimatorEvent.START))
            return;
        if (this._startEvent == null)
            this._startEvent = new AnimatorEvent(AnimatorEvent.START, this);
        this.dispatchEvent(this._startEvent);
    };
    /**
     * Pauses the automatic playback clock of the animator, in case manual updates are required via the
     * <code>time</code> property or <code>update()</code> method.
     *
     * @see #time
     * @see #update()
     */
    AnimatorBase.prototype.stop = function () {
        if (!this._isPlaying)
            return;
        this._isPlaying = false;
        this._broadcaster.stop();
        if (!this.hasEventListener(AnimatorEvent.STOP))
            return;
        if (this._stopEvent == null)
            this._stopEvent = new AnimatorEvent(AnimatorEvent.STOP, this);
        this.dispatchEvent(this._stopEvent);
    };
    /**
     * Provides a way to manually update the active state of the animator when automatic
     * updates are disabled.
     *
     * @see #stop()
     * @see #autoUpdate
     */
    AnimatorBase.prototype.update = function (time) {
        var dt = (time - this._time) * this.playbackSpeed;
        this._pUpdateDeltaTime(dt);
        this._time = time;
    };
    AnimatorBase.prototype.reset = function (name, offset) {
        if (offset === void 0) { offset = 0; }
        this.getAnimationState(this._pAnimationSet.getAnimation(name)).offset(offset + this._pAbsoluteTime);
    };
    /**
     * Used by the graphics object to which the animator is applied, registers the owner for internal use.
     *
     * @private
     */
    AnimatorBase.prototype.addOwner = function (entity) {
        this._pOwners.push(entity);
    };
    /**
     * Used by the graphics object from which the animator is removed, unregisters the owner for internal use.
     *
     * @private
     */
    AnimatorBase.prototype.removeOwner = function (entity) {
        this._pOwners.splice(this._pOwners.indexOf(entity), 1);
    };
    /**
     * Internal abstract method called when the time delta property of the animator's contents requires updating.
     *
     * @private
     */
    AnimatorBase.prototype._pUpdateDeltaTime = function (dt) {
        this._pAbsoluteTime += dt;
        this._pActiveState.update(this._pAbsoluteTime);
        if (this.updatePosition)
            this.applyPositionDelta();
    };
    /**
     * Enter frame event handler for automatically updating the active state of the animator.
     */
    AnimatorBase.prototype.onEnterFrame = function (event) {
        if (event === void 0) { event = null; }
        this.update(_awayjs_core.getTimer());
    };
    AnimatorBase.prototype.applyPositionDelta = function () {
        var delta = this._pActiveState.positionDelta;
        var dist = delta.length;
        var len;
        if (dist > 0) {
            len = this._pOwners.length;
            for (var i = 0; i < len; ++i)
                this._pOwners[i].transform.translateLocal(delta, dist);
        }
    };
    /**
     *  for internal use.
     *
     * @private
     */
    AnimatorBase.prototype.dispatchCycleEvent = function () {
        if (this.hasEventListener(AnimatorEvent.CYCLE_COMPLETE)) {
            if (this._cycleEvent == null)
                this._cycleEvent = new AnimatorEvent(AnimatorEvent.CYCLE_COMPLETE, this);
            this.dispatchEvent(this._cycleEvent);
        }
    };
    /**
     * @inheritDoc
     */
    AnimatorBase.prototype.clone = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * @inheritDoc
     */
    AnimatorBase.prototype.dispose = function () {
    };
    AnimatorBase.prototype.invalidateElements = function () {
        var entity;
        var len = this._pOwners.length;
        for (var i = 0; i < len; i++) {
            entity = this._pOwners[i];
            entity.invalidateElements();
        }
    };
    /**
     * @inheritDoc
     */
    AnimatorBase.prototype.testGPUCompatibility = function (shader) {
        throw new _awayjs_core.AbstractMethodError();
    };
    Object.defineProperty(AnimatorBase.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AnimatorBase.assetType;
        },
        enumerable: true,
        configurable: true
    });
    AnimatorBase.prototype.getRenderableElements = function (renderable, sourceElements) {
        //nothing to do here
        return sourceElements;
    };
    return AnimatorBase;
}(_awayjs_core.AssetBase));
AnimatorBase.assetType = "[asset Animator]";

/**
 *
 * @class away.pool.GL_AttributesBuffer
 */
var GL_AttributesBuffer = (function (_super) {
    __extends(GL_AttributesBuffer, _super);
    function GL_AttributesBuffer(attributesBuffer, stage) {
        var _this = _super.call(this, attributesBuffer, stage) || this;
        _this._stage = stage;
        _this._attributesBuffer = attributesBuffer;
        return _this;
    }
    /**
     *
     */
    GL_AttributesBuffer.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._attributesBuffer = null;
        if (this._indexBuffer) {
            this._indexBuffer.dispose();
            this._indexBuffer = null;
        }
        if (this._vertexBuffer) {
            this._vertexBuffer.dispose();
            this._vertexBuffer = null;
        }
    };
    GL_AttributesBuffer.prototype.activate = function (index, size, dimensions, offset, unsigned) {
        if (unsigned === void 0) { unsigned = false; }
        this._stage.setVertexBuffer(index, this._getVertexBuffer(), size, dimensions, offset, unsigned);
    };
    GL_AttributesBuffer.prototype.draw = function (mode, firstIndex, numIndices) {
        this._stage.context.drawIndices(mode, this._getIndexBuffer(), firstIndex, numIndices);
    };
    GL_AttributesBuffer.prototype._getIndexBuffer = function () {
        if (!this._indexBuffer) {
            this._invalid = true;
            this._indexBuffer = this._stage.context.createIndexBuffer(this._attributesBuffer.count * this._attributesBuffer.stride / 2); //hardcoded assuming UintArray
        }
        if (this._invalid) {
            this._invalid = false;
            this._indexBuffer.uploadFromByteArray(this._attributesBuffer.buffer, 0, this._attributesBuffer.length);
        }
        return this._indexBuffer;
    };
    GL_AttributesBuffer.prototype._getVertexBuffer = function () {
        if (!this._vertexBuffer) {
            this._invalid = true;
            this._vertexBuffer = this._stage.context.createVertexBuffer(this._attributesBuffer.count, this._attributesBuffer.stride);
        }
        if (this._invalid) {
            this._invalid = false;
            this._vertexBuffer.uploadFromByteArray(this._attributesBuffer.buffer, 0, this._attributesBuffer.count);
        }
        return this._vertexBuffer;
    };
    return GL_AttributesBuffer;
}(_awayjs_core.AbstractionBase));

(function (ContextGLBlendFactor) {
    ContextGLBlendFactor[ContextGLBlendFactor["DESTINATION_ALPHA"] = 0] = "DESTINATION_ALPHA";
    ContextGLBlendFactor[ContextGLBlendFactor["DESTINATION_COLOR"] = 1] = "DESTINATION_COLOR";
    ContextGLBlendFactor[ContextGLBlendFactor["ONE"] = 2] = "ONE";
    ContextGLBlendFactor[ContextGLBlendFactor["ONE_MINUS_DESTINATION_ALPHA"] = 3] = "ONE_MINUS_DESTINATION_ALPHA";
    ContextGLBlendFactor[ContextGLBlendFactor["ONE_MINUS_DESTINATION_COLOR"] = 4] = "ONE_MINUS_DESTINATION_COLOR";
    ContextGLBlendFactor[ContextGLBlendFactor["ONE_MINUS_SOURCE_ALPHA"] = 5] = "ONE_MINUS_SOURCE_ALPHA";
    ContextGLBlendFactor[ContextGLBlendFactor["ONE_MINUS_SOURCE_COLOR"] = 6] = "ONE_MINUS_SOURCE_COLOR";
    ContextGLBlendFactor[ContextGLBlendFactor["SOURCE_ALPHA"] = 7] = "SOURCE_ALPHA";
    ContextGLBlendFactor[ContextGLBlendFactor["SOURCE_COLOR"] = 8] = "SOURCE_COLOR";
    ContextGLBlendFactor[ContextGLBlendFactor["ZERO"] = 9] = "ZERO";
})(exports.ContextGLBlendFactor || (exports.ContextGLBlendFactor = {}));

(function (ContextGLClearMask) {
    ContextGLClearMask[ContextGLClearMask["COLOR"] = 1] = "COLOR";
    ContextGLClearMask[ContextGLClearMask["DEPTH"] = 2] = "DEPTH";
    ContextGLClearMask[ContextGLClearMask["STENCIL"] = 4] = "STENCIL";
    ContextGLClearMask[ContextGLClearMask["ALL"] = 7] = "ALL";
})(exports.ContextGLClearMask || (exports.ContextGLClearMask = {}));

(function (ContextGLCompareMode) {
    ContextGLCompareMode[ContextGLCompareMode["ALWAYS"] = 0] = "ALWAYS";
    ContextGLCompareMode[ContextGLCompareMode["EQUAL"] = 1] = "EQUAL";
    ContextGLCompareMode[ContextGLCompareMode["GREATER"] = 2] = "GREATER";
    ContextGLCompareMode[ContextGLCompareMode["GREATER_EQUAL"] = 3] = "GREATER_EQUAL";
    ContextGLCompareMode[ContextGLCompareMode["LESS"] = 4] = "LESS";
    ContextGLCompareMode[ContextGLCompareMode["LESS_EQUAL"] = 5] = "LESS_EQUAL";
    ContextGLCompareMode[ContextGLCompareMode["NEVER"] = 6] = "NEVER";
    ContextGLCompareMode[ContextGLCompareMode["NOT_EQUAL"] = 7] = "NOT_EQUAL";
})(exports.ContextGLCompareMode || (exports.ContextGLCompareMode = {}));

(function (ContextGLDrawMode) {
    ContextGLDrawMode[ContextGLDrawMode["TRIANGLES"] = 0] = "TRIANGLES";
    ContextGLDrawMode[ContextGLDrawMode["LINES"] = 1] = "LINES";
})(exports.ContextGLDrawMode || (exports.ContextGLDrawMode = {}));

(function (ContextGLMipFilter) {
    ContextGLMipFilter[ContextGLMipFilter["MIPLINEAR"] = 0] = "MIPLINEAR";
    ContextGLMipFilter[ContextGLMipFilter["MIPNEAREST"] = 1] = "MIPNEAREST";
    ContextGLMipFilter[ContextGLMipFilter["MIPNONE"] = 2] = "MIPNONE";
})(exports.ContextGLMipFilter || (exports.ContextGLMipFilter = {}));

(function (ContextGLProfile) {
    ContextGLProfile[ContextGLProfile["BASELINE"] = 0] = "BASELINE";
    ContextGLProfile[ContextGLProfile["BASELINE_CONSTRAINED"] = 1] = "BASELINE_CONSTRAINED";
    ContextGLProfile[ContextGLProfile["BASELINE_EXTENDED"] = 2] = "BASELINE_EXTENDED";
})(exports.ContextGLProfile || (exports.ContextGLProfile = {}));

(function (ContextGLProgramType) {
    ContextGLProgramType[ContextGLProgramType["FRAGMENT"] = 0] = "FRAGMENT";
    ContextGLProgramType[ContextGLProgramType["SAMPLER"] = 1] = "SAMPLER";
    ContextGLProgramType[ContextGLProgramType["VERTEX"] = 2] = "VERTEX";
})(exports.ContextGLProgramType || (exports.ContextGLProgramType = {}));

(function (ContextGLStencilAction) {
    ContextGLStencilAction[ContextGLStencilAction["DECREMENT_SATURATE"] = 0] = "DECREMENT_SATURATE";
    ContextGLStencilAction[ContextGLStencilAction["DECREMENT_WRAP"] = 1] = "DECREMENT_WRAP";
    ContextGLStencilAction[ContextGLStencilAction["INCREMENT_SATURATE"] = 2] = "INCREMENT_SATURATE";
    ContextGLStencilAction[ContextGLStencilAction["INCREMENT_WRAP"] = 3] = "INCREMENT_WRAP";
    ContextGLStencilAction[ContextGLStencilAction["INVERT"] = 4] = "INVERT";
    ContextGLStencilAction[ContextGLStencilAction["KEEP"] = 5] = "KEEP";
    ContextGLStencilAction[ContextGLStencilAction["SET"] = 6] = "SET";
    ContextGLStencilAction[ContextGLStencilAction["ZERO"] = 7] = "ZERO";
})(exports.ContextGLStencilAction || (exports.ContextGLStencilAction = {}));

(function (ContextGLTextureFilter) {
    ContextGLTextureFilter[ContextGLTextureFilter["LINEAR"] = 0] = "LINEAR";
    ContextGLTextureFilter[ContextGLTextureFilter["NEAREST"] = 1] = "NEAREST";
})(exports.ContextGLTextureFilter || (exports.ContextGLTextureFilter = {}));

(function (ContextGLTextureFormat) {
    ContextGLTextureFormat[ContextGLTextureFormat["BGRA"] = 0] = "BGRA";
    ContextGLTextureFormat[ContextGLTextureFormat["BGRA_PACKED"] = 1] = "BGRA_PACKED";
    ContextGLTextureFormat[ContextGLTextureFormat["BGR_PACKED"] = 2] = "BGR_PACKED";
    ContextGLTextureFormat[ContextGLTextureFormat["COMPRESSED"] = 3] = "COMPRESSED";
    ContextGLTextureFormat[ContextGLTextureFormat["COMPRESSED_ALPHA"] = 4] = "COMPRESSED_ALPHA";
})(exports.ContextGLTextureFormat || (exports.ContextGLTextureFormat = {}));

(function (ContextGLTriangleFace) {
    ContextGLTriangleFace[ContextGLTriangleFace["BACK"] = 0] = "BACK";
    ContextGLTriangleFace[ContextGLTriangleFace["FRONT"] = 1] = "FRONT";
    ContextGLTriangleFace[ContextGLTriangleFace["FRONT_AND_BACK"] = 2] = "FRONT_AND_BACK";
    ContextGLTriangleFace[ContextGLTriangleFace["NONE"] = 3] = "NONE";
})(exports.ContextGLTriangleFace || (exports.ContextGLTriangleFace = {}));

(function (ContextGLVertexBufferFormat) {
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["FLOAT_1"] = 0] = "FLOAT_1";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["FLOAT_2"] = 1] = "FLOAT_2";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["FLOAT_3"] = 2] = "FLOAT_3";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["FLOAT_4"] = 3] = "FLOAT_4";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["BYTE_1"] = 4] = "BYTE_1";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["BYTE_2"] = 5] = "BYTE_2";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["BYTE_3"] = 6] = "BYTE_3";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["BYTE_4"] = 7] = "BYTE_4";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_BYTE_1"] = 8] = "UNSIGNED_BYTE_1";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_BYTE_2"] = 9] = "UNSIGNED_BYTE_2";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_BYTE_3"] = 10] = "UNSIGNED_BYTE_3";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_BYTE_4"] = 11] = "UNSIGNED_BYTE_4";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["SHORT_1"] = 12] = "SHORT_1";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["SHORT_2"] = 13] = "SHORT_2";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["SHORT_3"] = 14] = "SHORT_3";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["SHORT_4"] = 15] = "SHORT_4";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_SHORT_1"] = 16] = "UNSIGNED_SHORT_1";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_SHORT_2"] = 17] = "UNSIGNED_SHORT_2";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_SHORT_3"] = 18] = "UNSIGNED_SHORT_3";
    ContextGLVertexBufferFormat[ContextGLVertexBufferFormat["UNSIGNED_SHORT_4"] = 19] = "UNSIGNED_SHORT_4";
})(exports.ContextGLVertexBufferFormat || (exports.ContextGLVertexBufferFormat = {}));

(function (ContextGLWrapMode) {
    ContextGLWrapMode[ContextGLWrapMode["CLAMP"] = 0] = "CLAMP";
    ContextGLWrapMode[ContextGLWrapMode["REPEAT"] = 1] = "REPEAT";
})(exports.ContextGLWrapMode || (exports.ContextGLWrapMode = {}));

(function (ContextMode) {
    ContextMode[ContextMode["AUTO"] = 0] = "AUTO";
    ContextMode[ContextMode["WEBGL"] = 1] = "WEBGL";
    ContextMode[ContextMode["FLASH"] = 2] = "FLASH";
    ContextMode[ContextMode["GLES"] = 3] = "GLES";
    ContextMode[ContextMode["NATIVE"] = 4] = "NATIVE";
    ContextMode[ContextMode["SOFTWARE"] = 5] = "SOFTWARE";
})(exports.ContextMode || (exports.ContextMode = {}));

var SamplerState = (function () {
    function SamplerState() {
    }
    return SamplerState;
}());

/**
 *
 * @class away.pool.GL_ElementsBaseBase
 */
var GL_ElementsBase = (function (_super) {
    __extends(GL_ElementsBase, _super);
    function GL_ElementsBase(elements, stage) {
        var _this = _super.call(this, elements, stage) || this;
        _this.usages = 0;
        _this._vertices = new Object();
        _this._verticesUpdated = new Object();
        _this._indexMappings = Array();
        _this._numIndices = 0;
        _this._elements = elements;
        _this._stage = stage;
        _this._onInvalidateIndicesDelegate = function (event) { return _this._onInvalidateIndices(event); };
        _this._onClearIndicesDelegate = function (event) { return _this._onClearIndices(event); };
        _this._onInvalidateVerticesDelegate = function (event) { return _this._onInvalidateVertices(event); };
        _this._onClearVerticesDelegate = function (event) { return _this._onClearVertices(event); };
        _this._elements.addEventListener(_awayjs_graphics.ElementsEvent.CLEAR_INDICES, _this._onClearIndicesDelegate);
        _this._elements.addEventListener(_awayjs_graphics.ElementsEvent.INVALIDATE_INDICES, _this._onInvalidateIndicesDelegate);
        _this._elements.addEventListener(_awayjs_graphics.ElementsEvent.CLEAR_VERTICES, _this._onClearVerticesDelegate);
        _this._elements.addEventListener(_awayjs_graphics.ElementsEvent.INVALIDATE_VERTICES, _this._onInvalidateVerticesDelegate);
        return _this;
    }
    Object.defineProperty(GL_ElementsBase.prototype, "elementsType", {
        get: function () {
            throw new _awayjs_core.AbstractMethodError();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_ElementsBase.prototype, "elementsClass", {
        get: function () {
            throw new _awayjs_core.AbstractMethodError();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_ElementsBase.prototype, "elements", {
        get: function () {
            return this._elements;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_ElementsBase.prototype, "numIndices", {
        /**
         *
         */
        get: function () {
            return this._numIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_ElementsBase.prototype, "numVertices", {
        /**
         *
         */
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    GL_ElementsBase.prototype.getIndexMappings = function () {
        if (!this._indicesUpdated)
            this._updateIndices();
        return this._indexMappings;
    };
    /**
     *
     */
    GL_ElementsBase.prototype.getIndexBufferGL = function () {
        if (!this._indicesUpdated)
            this._updateIndices();
        return this._indices;
    };
    /**
     *
     */
    GL_ElementsBase.prototype.getVertexBufferGL = function (attributesView) {
        //first check if indices need updating which may affect vertices
        if (!this._indicesUpdated)
            this._updateIndices();
        var bufferId = attributesView.attributesBuffer.id;
        if (!this._verticesUpdated[bufferId])
            this._updateVertices(attributesView);
        return this._vertices[bufferId];
    };
    /**
     *
     */
    GL_ElementsBase.prototype.activateVertexBufferVO = function (index, attributesView, dimensions, offset) {
        if (dimensions === void 0) { dimensions = 0; }
        if (offset === void 0) { offset = 0; }
        this.getVertexBufferGL(attributesView).activate(index, attributesView.size, dimensions || attributesView.dimensions, attributesView.offset + offset, attributesView.unsigned);
    };
    /**
     *
     */
    GL_ElementsBase.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._elements.removeEventListener(_awayjs_graphics.ElementsEvent.CLEAR_INDICES, this._onClearIndicesDelegate);
        this._elements.removeEventListener(_awayjs_graphics.ElementsEvent.INVALIDATE_INDICES, this._onInvalidateIndicesDelegate);
        this._elements.removeEventListener(_awayjs_graphics.ElementsEvent.CLEAR_VERTICES, this._onClearVerticesDelegate);
        this._elements.removeEventListener(_awayjs_graphics.ElementsEvent.INVALIDATE_VERTICES, this._onInvalidateVerticesDelegate);
        this._elements = null;
        if (this._overflow) {
            this._overflow.onClear(event);
            this._overflow = null;
        }
    };
    GL_ElementsBase.prototype._setRenderState = function (renderable, shader, projection) {
        if (!this._verticesUpdated)
            this._updateIndices();
        //TODO replace overflow system with something sensible
        //this._render(renderable, camera, viewProjection);
        //
        // if (this._overflow)
        // 	this._overflow._iRender(renderable, camera, viewProjection);
    };
    GL_ElementsBase.prototype.draw = function (renderable, shader, projection, count, offset) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * //TODO
     *
     * @private
     */
    GL_ElementsBase.prototype._updateIndices = function (indexOffset) {
        if (indexOffset === void 0) { indexOffset = 0; }
        var indices = this._elements.indices;
        if (indices) {
            this._indices = this._stage.getAbstraction(_awayjs_graphics.ElementsUtils.getSubIndices(indices, this._elements.numVertices, this._indexMappings, indexOffset));
            this._numIndices = this._indices._attributesBuffer.count * indices.dimensions;
        }
        else {
            this._indices = null;
            this._numIndices = 0;
            this._indexMappings = Array();
        }
        indexOffset += this._numIndices;
        //check if there is more to split
        if (indices && indexOffset < indices.count * this._elements.indices.dimensions) {
            if (!this._overflow)
                this._overflow = this._pGetOverflowElements();
            this._overflow._updateIndices(indexOffset);
        }
        else if (this._overflow) {
            this._overflow.onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, this._elements));
            this._overflow = null;
        }
        this._indicesUpdated = true;
        //invalidate vertices if index mappings exist
        if (this._indexMappings.length)
            for (var key in this._verticesUpdated)
                this._verticesUpdated[key] = false;
    };
    /**
     * //TODO
     *
     * @param attributesView
     * @private
     */
    GL_ElementsBase.prototype._updateVertices = function (attributesView) {
        this._numVertices = this._elements.numVertices;
        var bufferId = attributesView.attributesBuffer.id;
        this._vertices[bufferId] = this._stage.getAbstraction(_awayjs_graphics.ElementsUtils.getSubVertices(attributesView.attributesBuffer, this._indexMappings));
        this._verticesUpdated[bufferId] = true;
    };
    /**
     * //TODO
     *
     * @param event
     * @private
     */
    GL_ElementsBase.prototype._onInvalidateIndices = function (event) {
        if (!event.attributesView)
            return;
        this._indicesUpdated = false;
    };
    /**
     * //TODO
     *
     * @param event
     * @private
     */
    GL_ElementsBase.prototype._onClearIndices = function (event) {
        if (!event.attributesView)
            return;
        this._indices.onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, event.attributesView));
        this._indices = null;
    };
    /**
     * //TODO
     *
     * @param event
     * @private
     */
    GL_ElementsBase.prototype._onInvalidateVertices = function (event) {
        if (!event.attributesView)
            return;
        var bufferId = event.attributesView.attributesBuffer.id;
        this._verticesUpdated[bufferId] = false;
    };
    /**
     * //TODO
     *
     * @param event
     * @private
     */
    GL_ElementsBase.prototype._onClearVertices = function (event) {
        if (!event.attributesView)
            return;
        var bufferId = event.attributesView.attributesBuffer.id;
        if (this._vertices[bufferId]) {
            this._vertices[bufferId].onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, event.attributesView));
            delete this._vertices[bufferId];
            delete this._verticesUpdated[bufferId];
        }
    };
    /**
     * //TODO
     *
     * @param pool
     * @param renderable
     * @param level
     * @param indexOffset
     * @returns {away.pool.GL_ShapeRenderable}
     * @protected
     */
    GL_ElementsBase.prototype._pGetOverflowElements = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    return GL_ElementsBase;
}(_awayjs_core.AbstractionBase));

/**
 *
 * @class away.pool.GL_TriangleElements
 */
var GL_TriangleElements = (function (_super) {
    __extends(GL_TriangleElements, _super);
    function GL_TriangleElements(triangleElements, stage) {
        var _this = _super.call(this, triangleElements, stage) || this;
        _this._triangleElements = triangleElements;
        return _this;
    }
    Object.defineProperty(GL_TriangleElements.prototype, "elementsType", {
        get: function () {
            return GL_TriangleElements.elementsType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_TriangleElements.prototype, "elementsClass", {
        get: function () {
            return GL_TriangleElements;
        },
        enumerable: true,
        configurable: true
    });
    GL_TriangleElements._includeDependencies = function (shader) {
    };
    GL_TriangleElements._getVertexCode = function (shader, registerCache, sharedRegisters) {
        var code = "";
        //get the projection coordinates
        var position = (shader.globalPosDependencies > 0) ? sharedRegisters.globalPositionVertex : sharedRegisters.animatedPosition;
        //reserving vertex constants for projection matrix
        var viewMatrixReg = registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        shader.viewMatrixIndex = viewMatrixReg.index * 4;
        if (shader.projectionDependencies > 0) {
            sharedRegisters.projectionFragment = registerCache.getFreeVarying();
            var temp = registerCache.getFreeVertexVectorTemp();
            code += "m44 " + temp + ", " + position + ", " + viewMatrixReg + "\n" +
                "mov " + sharedRegisters.projectionFragment + ", " + temp + "\n" +
                "mov op, " + temp + "\n";
        }
        else {
            code += "m44 op, " + position + ", " + viewMatrixReg + "\n";
        }
        return code;
    };
    GL_TriangleElements._getFragmentCode = function (shader, registerCache, sharedRegisters) {
        return "";
    };
    GL_TriangleElements.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._triangleElements = null;
    };
    GL_TriangleElements.prototype._setRenderState = function (renderable, shader, projection) {
        _super.prototype._setRenderState.call(this, renderable, shader, projection);
        //set buffers
        //TODO: find a better way to update a concatenated buffer when autoderiving
        if (shader.normalIndex >= 0 && this._triangleElements.autoDeriveNormals)
            this._triangleElements.normals;
        if (shader.tangentIndex >= 0 && this._triangleElements.autoDeriveTangents)
            this._triangleElements.tangents;
        if (shader.curvesIndex >= 0)
            this.activateVertexBufferVO(shader.curvesIndex, this._triangleElements.getCustomAtributes("curves"));
        if (shader.uvIndex >= 0)
            this.activateVertexBufferVO(shader.uvIndex, this._triangleElements.uvs || this._triangleElements.positions);
        if (shader.secondaryUVIndex >= 0)
            this.activateVertexBufferVO(shader.secondaryUVIndex, this._triangleElements.getCustomAtributes("secondaryUVs") || this._triangleElements.uvs || this._triangleElements.positions);
        if (shader.normalIndex >= 0)
            this.activateVertexBufferVO(shader.normalIndex, this._triangleElements.normals);
        if (shader.tangentIndex >= 0)
            this.activateVertexBufferVO(shader.tangentIndex, this._triangleElements.tangents);
        if (shader.jointIndexIndex >= 0)
            this.activateVertexBufferVO(shader.jointIndexIndex, this._triangleElements.jointIndices);
        if (shader.jointWeightIndex >= 0)
            this.activateVertexBufferVO(shader.jointIndexIndex, this._triangleElements.jointWeights);
        this.activateVertexBufferVO(0, this._triangleElements.positions);
    };
    GL_TriangleElements.prototype.draw = function (renderable, shader, projection, count, offset) {
        //set constants
        if (shader.sceneMatrixIndex >= 0) {
            shader.sceneMatrix.copyFrom(renderable.renderSceneTransform, true);
            shader.viewMatrix.copyFrom(projection.viewMatrix3D, true);
        }
        else {
            var matrix3D = _awayjs_core.Matrix3D.CALCULATION_MATRIX;
            matrix3D.copyFrom(renderable.renderSceneTransform);
            matrix3D.append(projection.viewMatrix3D);
            shader.viewMatrix.copyFrom(matrix3D, true);
        }
        var context = this._stage.context;
        context.setProgramConstantsFromArray(exports.ContextGLProgramType.VERTEX, shader.vertexConstantData);
        context.setProgramConstantsFromArray(exports.ContextGLProgramType.FRAGMENT, shader.fragmentConstantData);
        if (this._indices)
            this.getIndexBufferGL().draw(exports.ContextGLDrawMode.TRIANGLES, offset * 3, count * 3 || this.numIndices);
        else
            this._stage.context.drawVertices(exports.ContextGLDrawMode.TRIANGLES, offset, count || this.numVertices);
    };
    /**
     * //TODO
     *
     * @param pool
     * @param renderable
     * @param level
     * @param indexOffset
     * @returns {away.pool.GL_ShapeRenderable}
     * @protected
     */
    GL_TriangleElements.prototype._pGetOverflowElements = function () {
        return new GL_TriangleElements(this._triangleElements, this._stage);
    };
    return GL_TriangleElements;
}(GL_ElementsBase));
GL_TriangleElements.elementsType = "[elements Triangle]";

var StageEvent = (function (_super) {
    __extends(StageEvent, _super);
    function StageEvent(type, stage) {
        var _this = _super.call(this, type) || this;
        _this._stage = stage;
        return _this;
    }
    Object.defineProperty(StageEvent.prototype, "stage", {
        /**
         *
         */
        get: function () {
            return this._stage;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    StageEvent.prototype.clone = function () {
        return new StageEvent(this.type, this._stage);
    };
    return StageEvent;
}(_awayjs_core.EventBase));
/**
 *
 */
StageEvent.STAGE_ERROR = "stageError";
/**
 *
 */
StageEvent.CONTEXT_CREATED = "contextCreated";
/**
 *
 */
StageEvent.CONTEXT_DISPOSED = "contextDisposed";
/**
 *
 */
StageEvent.CONTEXT_RECREATED = "contextRecreated";
/**
 *
 */
StageEvent.VIEWPORT_UPDATED = "viewportUpdated";

var PassEvent = (function (_super) {
    __extends(PassEvent, _super);
    function PassEvent(type, pass) {
        var _this = _super.call(this, type) || this;
        _this._pass = pass;
        return _this;
    }
    Object.defineProperty(PassEvent.prototype, "pass", {
        /**
         *
         */
        get: function () {
            return this._pass;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     */
    PassEvent.prototype.clone = function () {
        return new PassEvent(this.type, this._pass);
    };
    return PassEvent;
}(_awayjs_core.EventBase));
/**
 *
 */
PassEvent.INVALIDATE = "invalidatePass";

var OpCodes = (function () {
    function OpCodes() {
    }
    return OpCodes;
}());
OpCodes.trueValue = 32;
OpCodes.falseValue = 33;
OpCodes.intMask = 63;
OpCodes.drawTriangles = 41;
OpCodes.setProgramConstant = 42;
OpCodes.setProgram = 43;
OpCodes.present = 44;
OpCodes.clear = 45;
OpCodes.initProgram = 46;
OpCodes.initVertexBuffer = 47;
OpCodes.initIndexBuffer = 48;
OpCodes.configureBackBuffer = 49;
OpCodes.uploadArrayIndexBuffer = 50;
OpCodes.uploadArrayVertexBuffer = 51;
OpCodes.uploadAGALBytesProgram = 52;
OpCodes.setVertexBufferAt = 53;
OpCodes.uploadBytesIndexBuffer = 54;
OpCodes.uploadBytesVertexBuffer = 55;
OpCodes.setColorMask = 56;
OpCodes.setDepthTest = 57;
OpCodes.disposeProgram = 58;
OpCodes.disposeContext = 59;
// must skip 60 '<' as it will invalidate xml being passed over the bridge
OpCodes.disposeVertexBuffer = 61;
// must skip 62 '>' as it will invalidate xml being passed over the bridge
OpCodes.disposeIndexBuffer = 63;
OpCodes.initTexture = 64;
OpCodes.setTextureAt = 65;
OpCodes.uploadBytesTexture = 66;
OpCodes.disposeTexture = 67;
OpCodes.setCulling = 68;
OpCodes.setScissorRect = 69;
OpCodes.clearScissorRect = 70;
OpCodes.setBlendFactors = 71;
OpCodes.setRenderToTexture = 72;
OpCodes.clearTextureAt = 73;
OpCodes.clearVertexBufferAt = 74;
OpCodes.setStencilActions = 75;
OpCodes.setStencilReferenceValue = 76;
OpCodes.initCubeTexture = 77;
OpCodes.disposeCubeTexture = 78;
OpCodes.uploadBytesCubeTexture = 79;
OpCodes.clearRenderToTexture = 80;
OpCodes.enableErrorChecking = 81;
// added for gles context:
OpCodes.drawVertices = 82;
OpCodes.getFrameBufferForTexture = 83;
OpCodes.uploadProgram = 84;
OpCodes.disableCulling = 85;
OpCodes.disableBlending = 86;
OpCodes.setSamplerStateAt = 87;
OpCodes.enableStencil = 88;
OpCodes.disableStencil = 89;
OpCodes.setStencilActionsMasks = 90;
//public static passBitmapToCpp:number = 91; //reserved for java message
OpCodes.uploadTextureFromURL = 92;
OpCodes.startSound = 101;
OpCodes.stopSound = 102;
OpCodes.updateSound = 103;

var ResourceBaseFlash = (function () {
    function ResourceBaseFlash() {
    }
    Object.defineProperty(ResourceBaseFlash.prototype, "id", {
        get: function () {
            return this._pId;
        },
        enumerable: true,
        configurable: true
    });
    ResourceBaseFlash.prototype.dispose = function () {
    };
    ResourceBaseFlash.prototype.generateMipmaps = function () {
        //TODO
    };
    return ResourceBaseFlash;
}());

var CubeTextureFlash = (function (_super) {
    __extends(CubeTextureFlash, _super);
    function CubeTextureFlash(context, size, format, forRTT, streaming) {
        if (streaming === void 0) { streaming = false; }
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._size = size;
        _this._context.addStream(String.fromCharCode(OpCodes.initCubeTexture, (forRTT ? OpCodes.trueValue : OpCodes.falseValue)) + size + "," + streaming + "," + format + "$");
        _this._pId = _this._context.execute();
        _this._context._iAddResource(_this);
        return _this;
    }
    Object.defineProperty(CubeTextureFlash.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    CubeTextureFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeCubeTexture) + this._pId.toString() + ",");
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    CubeTextureFlash.prototype.uploadFromImage = function (imageCube, side, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        var data = imageCube.getImageData(side).data;
        var pos = 0;
        var bytes = _awayjs_core.ByteArrayBase.internalGetBase64String(data.length, function () {
            return data[pos++];
        }, null);
        this._context.addStream(String.fromCharCode(OpCodes.uploadBytesCubeTexture) + this._pId + "," + miplevel + "," + side + "," + (this.size >> miplevel) + "," + bytes + "%");
        this._context.execute();
    };
    CubeTextureFlash.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        if (async === void 0) { async = false; }
    };
    return CubeTextureFlash;
}(ResourceBaseFlash));

var IndexBufferFlash = (function (_super) {
    __extends(IndexBufferFlash, _super);
    function IndexBufferFlash(context, numIndices) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._numIndices = numIndices;
        _this._context.addStream(String.fromCharCode(OpCodes.initIndexBuffer, numIndices + OpCodes.intMask));
        _this._pId = _this._context.execute();
        _this._context._iAddResource(_this);
        return _this;
    }
    IndexBufferFlash.prototype.uploadFromArray = function (data, startOffset, count) {
        this._context.addStream(String.fromCharCode(OpCodes.uploadArrayIndexBuffer, this._pId + OpCodes.intMask) + data.join() + "#" + startOffset + "," + count + ",");
        this._context.execute();
    };
    IndexBufferFlash.prototype.uploadFromByteArray = function (data, startOffset, count) {
    };
    IndexBufferFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeIndexBuffer, this._pId + OpCodes.intMask));
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    Object.defineProperty(IndexBufferFlash.prototype, "numIndices", {
        get: function () {
            return this._numIndices;
        },
        enumerable: true,
        configurable: true
    });
    return IndexBufferFlash;
}(ResourceBaseFlash));

var ProgramFlash = (function (_super) {
    __extends(ProgramFlash, _super);
    function ProgramFlash(context) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._context.addStream(String.fromCharCode(OpCodes.initProgram));
        _this._pId = _this._context.execute();
        _this._context._iAddResource(_this);
        return _this;
    }
    ProgramFlash.prototype.upload = function (vertexProgram, fragmentProgram) {
        this._context.addStream(String.fromCharCode(OpCodes.uploadAGALBytesProgram, this._pId + OpCodes.intMask) + vertexProgram.readBase64String(vertexProgram.length) + "%" + fragmentProgram.readBase64String(fragmentProgram.length) + "%");
        if (ContextFlash.debug)
            this._context.execute();
    };
    ProgramFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeProgram, this._pId + OpCodes.intMask));
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    return ProgramFlash;
}(ResourceBaseFlash));

var TextureFlash = (function (_super) {
    __extends(TextureFlash, _super);
    function TextureFlash(context, width, height, format, forRTT, streaming) {
        if (streaming === void 0) { streaming = false; }
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._width = width;
        _this._height = height;
        _this._context.addStream(String.fromCharCode(OpCodes.initTexture, (forRTT ? OpCodes.trueValue : OpCodes.falseValue)) + width + "," + height + "," + streaming + "," + format + "$");
        _this._pId = _this._context.execute();
        _this._context._iAddResource(_this);
        return _this;
    }
    Object.defineProperty(TextureFlash.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureFlash.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    TextureFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeTexture) + this._pId.toString() + ",");
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    TextureFlash.prototype.uploadFromImage = function (image2D, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        var data = image2D.getImageData().data;
        var pos = 0;
        var bytes = _awayjs_core.ByteArrayBase.internalGetBase64String(data.length, function () {
            return data[pos++];
        }, null);
        this._context.addStream(String.fromCharCode(OpCodes.uploadBytesTexture) + this._pId + "," + miplevel + "," + (this._width >> miplevel) + "," + (this._height >> miplevel) + "," + bytes + "%");
        this._context.execute();
    };
    TextureFlash.prototype.uploadFromURL = function (urlRequest, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
    };
    return TextureFlash;
}(ResourceBaseFlash));

var VertexBufferFlash = (function (_super) {
    __extends(VertexBufferFlash, _super);
    function VertexBufferFlash(context, numVertices, dataPerVertex) {
        var _this = _super.call(this) || this;
        _this._context = context;
        _this._numVertices = numVertices;
        _this._dataPerVertex = dataPerVertex;
        _this._context.addStream(String.fromCharCode(OpCodes.initVertexBuffer, dataPerVertex + OpCodes.intMask) + numVertices.toString() + ",");
        _this._pId = _this._context.execute();
        _this._context._iAddResource(_this);
        return _this;
    }
    VertexBufferFlash.prototype.uploadFromArray = function (data, startVertex, numVertices) {
        this._context.addStream(String.fromCharCode(OpCodes.uploadArrayVertexBuffer, this._pId + OpCodes.intMask) + data.join() + "#" + [startVertex, numVertices].join() + ",");
        this._context.execute();
    };
    VertexBufferFlash.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
    };
    Object.defineProperty(VertexBufferFlash.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferFlash.prototype, "dataPerVertex", {
        get: function () {
            return this._dataPerVertex;
        },
        enumerable: true,
        configurable: true
    });
    VertexBufferFlash.prototype.dispose = function () {
        this._context.addStream(String.fromCharCode(OpCodes.disposeVertexBuffer, this._pId + OpCodes.intMask));
        this._context.execute();
        this._context._iRemoveResource(this);
        this._context = null;
    };
    return VertexBufferFlash;
}(ResourceBaseFlash));

var ContextFlash = (function () {
    //TODO: get rid of hack that fixes including definition file
    function ContextFlash(container, callback) {
        this._cmdStream = "";
        this._resources = new Array();
        var swfVersionStr = "11.0.0";
        // To use express install, set to playerProductInstall.swf, otherwise the empty string.
        var flashvars = {
            id: container.id
        };
        var params = {
            quality: "high",
            bgcolor: "#ffffff",
            allowscriptaccess: "sameDomain",
            allowfullscreen: "true",
            wmode: "direct"
        };
        this._errorCheckingEnabled = false;
        this._iDriverInfo = "Unknown";
        var attributes = {
            salign: "tl",
            id: container.id,
            name: container["name"] //TODO: needed?
        };
        this._oldCanvas = container.cloneNode(); // keep the old one to restore on dispose
        this._oldParent = container.parentNode;
        var context3dObj = this;
        ContextFlash.contexts[container.id] = this;
        function callbackSWFObject(callbackInfo) {
            if (!callbackInfo.success)
                return;
            context3dObj._container = callbackInfo.ref;
            context3dObj._iCallback = callback;
        }
        //swfobject.embedSWF("libs/molehill_js_flashbridge.swf", container.id, String(container.width), String(container.height), swfVersionStr, "", flashvars, params, attributes, callbackSWFObject);
    }
    ContextFlash.prototype.enableStencil = function () {
    };
    ContextFlash.prototype.disableStencil = function () {
    };
    Object.defineProperty(ContextFlash.prototype, "container", {
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextFlash.prototype, "driverInfo", {
        get: function () {
            return this._iDriverInfo;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextFlash.prototype, "errorCheckingEnabled", {
        get: function () {
            return this._errorCheckingEnabled;
        },
        set: function (value) {
            if (this._errorCheckingEnabled == value)
                return;
            this._errorCheckingEnabled = value;
            this.addStream(String.fromCharCode(OpCodes.enableErrorChecking, value ? OpCodes.trueValue : OpCodes.falseValue));
            this.execute();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextFlash.prototype, "pixelRatio", {
        get: function () {
            return 1;
        },
        enumerable: true,
        configurable: true
    });
    ContextFlash.prototype._iAddResource = function (resource) {
        this._resources.push(resource);
    };
    ContextFlash.prototype._iRemoveResource = function (resource) {
        this._resources.splice(this._resources.indexOf(resource));
    };
    ContextFlash.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        //TODO:streaming
        return new TextureFlash(this, width, height, format, optimizeForRenderToTexture);
    };
    ContextFlash.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        //TODO:streaming
        return new CubeTextureFlash(this, size, format, optimizeForRenderToTexture);
    };
    ContextFlash.prototype.setTextureAt = function (sampler, texture) {
        if (texture) {
            this.addStream(String.fromCharCode(OpCodes.setTextureAt) + sampler + "," + texture.id + ",");
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.clearTextureAt) + sampler.toString() + ",");
        }
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
        //nothing to do here
    };
    ContextFlash.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
        if (triangleFace === void 0) { triangleFace = exports.ContextGLTriangleFace.FRONT_AND_BACK; }
        if (compareMode === void 0) { compareMode = exports.ContextGLCompareMode.ALWAYS; }
        if (actionOnBothPass === void 0) { actionOnBothPass = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthFail === void 0) { actionOnDepthFail = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = exports.ContextGLStencilAction.KEEP; }
        if (coordinateSystem === void 0) { coordinateSystem = _awayjs_core.CoordinateSystem.LEFT_HANDED; }
        this.addStream(String.fromCharCode(OpCodes.setStencilActions) + triangleFace + "$" + compareMode + "$" + actionOnBothPass + "$" + actionOnDepthFail + "$" + actionOnDepthPassStencilFail + "$");
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
        if (readMask === void 0) { readMask = 0xFF; }
        if (writeMask === void 0) { writeMask = 0xFF; }
        this.addStream(String.fromCharCode(OpCodes.setStencilReferenceValue, referenceValue + OpCodes.intMask, readMask + OpCodes.intMask, writeMask + OpCodes.intMask));
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
        if (coordinateSystem === void 0) { coordinateSystem = _awayjs_core.CoordinateSystem.LEFT_HANDED; }
        //TODO implement coordinateSystem option
        this.addStream(String.fromCharCode(OpCodes.setCulling) + triangleFaceToCull + "$");
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
        if (firstIndex === void 0) { firstIndex = 0; }
        if (numIndices === void 0) { numIndices = -1; }
        firstIndex = firstIndex || 0;
        if (!numIndices || numIndices < 0)
            numIndices = indexBuffer.numIndices;
        //assume triangles
        this.addStream(String.fromCharCode(OpCodes.drawTriangles, indexBuffer.id + OpCodes.intMask) + firstIndex + "," + numIndices + ",");
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.drawVertices = function (mode, firstVertex, numVertices) {
        if (firstVertex === void 0) { firstVertex = 0; }
        if (numVertices === void 0) { numVertices = -1; }
        //can't be done in Stage3D
    };
    ContextFlash.prototype.setProgramConstantsFromArray = function (programType, data) {
        var startIndex;
        var numRegisters = data.length / 4;
        var target = (programType == exports.ContextGLProgramType.VERTEX) ? OpCodes.trueValue : OpCodes.falseValue;
        for (var i = 0; i < numRegisters; i++) {
            startIndex = i * 4;
            this.addStream(String.fromCharCode(OpCodes.setProgramConstant, target, i + OpCodes.intMask) + data[startIndex] + "," + data[startIndex + 1] + "," + data[startIndex + 2] + "," + data[startIndex + 3] + ",");
            if (ContextFlash.debug)
                this.execute();
        }
    };
    ContextFlash.prototype.setProgram = function (program) {
        this.addStream(String.fromCharCode(OpCodes.setProgram, program.id + OpCodes.intMask));
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.present = function () {
        this.addStream(String.fromCharCode(OpCodes.present));
        this.execute();
    };
    ContextFlash.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
        if (red === void 0) { red = 0; }
        if (green === void 0) { green = 0; }
        if (blue === void 0) { blue = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (depth === void 0) { depth = 1; }
        if (stencil === void 0) { stencil = 0; }
        if (mask === void 0) { mask = exports.ContextGLClearMask.ALL; }
        this.addStream(String.fromCharCode(OpCodes.clear) + red + "," + green + "," + blue + "," + alpha + "," + depth + "," + stencil + "," + mask + ",");
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.createProgram = function () {
        return new ProgramFlash(this);
    };
    ContextFlash.prototype.createVertexBuffer = function (numVertices, data32PerVertex) {
        return new VertexBufferFlash(this, numVertices, data32PerVertex);
    };
    ContextFlash.prototype.createIndexBuffer = function (numIndices) {
        return new IndexBufferFlash(this, numIndices);
    };
    ContextFlash.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
        this._width = width;
        this._height = height;
        //TODO: add Anitalias setting
        this.addStream(String.fromCharCode(OpCodes.configureBackBuffer) + width + "," + height + ",");
    };
    ContextFlash.prototype.drawToBitmapImage2D = function (destination) {
        //TODO
    };
    ContextFlash.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
        if (bufferOffset === void 0) { bufferOffset = 0; }
        if (format === void 0) { format = null; }
        if (buffer) {
            this.addStream(String.fromCharCode(OpCodes.setVertexBufferAt, index + OpCodes.intMask) + buffer.id + "," + bufferOffset + "," + format + "$");
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.clearVertexBufferAt, index + OpCodes.intMask));
        }
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setColorMask = function (red, green, blue, alpha) {
        this.addStream(String.fromCharCode(OpCodes.setColorMask, red ? OpCodes.trueValue : OpCodes.falseValue, green ? OpCodes.trueValue : OpCodes.falseValue, blue ? OpCodes.trueValue : OpCodes.falseValue, alpha ? OpCodes.trueValue : OpCodes.falseValue));
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
        this.addStream(String.fromCharCode(OpCodes.setBlendFactors) + sourceFactor + "$" + destinationFactor + "$");
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (antiAlias === void 0) { antiAlias = 0; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        if (target === null || target === undefined) {
            this.addStream(String.fromCharCode(OpCodes.clearRenderToTexture));
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.setRenderToTexture, enableDepthAndStencil ? OpCodes.trueValue : OpCodes.falseValue) + target.id + "," + (antiAlias || 0) + ",");
        }
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setRenderToBackBuffer = function () {
        this.addStream(String.fromCharCode(OpCodes.clearRenderToTexture));
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setScissorRectangle = function (rectangle) {
        if (rectangle) {
            this.addStream(String.fromCharCode(OpCodes.setScissorRect) + rectangle.x + "," + rectangle.y + "," + rectangle.width + "," + rectangle.height + ",");
        }
        else {
            this.addStream(String.fromCharCode(OpCodes.clearScissorRect));
        }
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.setDepthTest = function (depthMask, passCompareMode) {
        this.addStream(String.fromCharCode(OpCodes.setDepthTest, depthMask ? OpCodes.trueValue : OpCodes.falseValue) + passCompareMode + "$");
        if (ContextFlash.debug)
            this.execute();
    };
    ContextFlash.prototype.dispose = function () {
        if (this._container == null)
            return;
        console.log("Context3D dispose, releasing " + this._resources.length + " resources.");
        while (this._resources.length)
            this._resources[0].dispose();
        if (this._container) {
            // encode command
            this.addStream(String.fromCharCode(OpCodes.disposeContext));
            this.execute();
            //swfobject.removeSWF(this._oldCanvas.id);
            if (this._oldCanvas && this._oldParent) {
                this._oldParent.appendChild(this._oldCanvas);
                this._oldParent = null;
            }
            this._container = null;
        }
        this._oldCanvas = null;
    };
    ContextFlash.prototype.addStream = function (stream) {
        this._cmdStream += stream;
    };
    ContextFlash.prototype.execute = function () {
        if (ContextFlash.logStream)
            console.log(this._cmdStream);
        var result = this._container["CallFunction"]("<invoke name=\"execStage3dOpStream\" returntype=\"javascript\"><arguments><string>" + this._cmdStream + "</string></arguments></invoke>");
        if (Number(result) <= -3)
            throw "Exec stream failed";
        this._cmdStream = "";
        return Number(result);
    };
    return ContextFlash;
}());
ContextFlash.contexts = new Object();
ContextFlash.debug = false;
ContextFlash.logStream = false;

var GLESAssetBase = (function () {
    function GLESAssetBase(context, id) {
        this._context = context;
        this._id = id;
    }
    Object.defineProperty(GLESAssetBase.prototype, "id", {
        get: function () {
            return this._id;
        },
        enumerable: true,
        configurable: true
    });
    return GLESAssetBase;
}());

var TextureBaseGLES = (function (_super) {
    __extends(TextureBaseGLES, _super);
    function TextureBaseGLES(context, gl, id) {
        var _this = _super.call(this, context, id) || this;
        _this.textureType = "";
        return _this;
        // this._gl = gl;
    }
    TextureBaseGLES.prototype.dispose = function () {
        //console.log("dispose texturedata "+this.id);
        ///this._context.addStream(String.fromCharCode(OpCodes.disposeTexture) + this.id.toString() + "#END");
        this._context._createBytes.writeInt(OpCodes.disposeTexture);
        this._context._createBytes.writeInt(this.id);
        //this._context.execute();
        //GLESConnector.gles.disposeTexture(this.id);
        // this._gl.deleteTexture(this._glTexture);
    };
    Object.defineProperty(TextureBaseGLES.prototype, "glTexture", {
        get: function () {
            return this._glTexture;
        },
        enumerable: true,
        configurable: true
    });
    TextureBaseGLES.prototype.generateMipmaps = function () {
        //GLESConnector.gles.generateMipmaps(this.id);
        // this._gl.bindTexture( this._gl.TEXTURE_2D, this._glTexture );
        // this._gl.generateMipmap(this._gl.TEXTURE_2D);
        // //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
    };
    return TextureBaseGLES;
}(GLESAssetBase));

var CubeTextureGLES = (function (_super) {
    __extends(CubeTextureGLES, _super);
    function CubeTextureGLES(context, gl, size, id) {
        var _this = _super.call(this, context, gl, id) || this;
        _this._textureSelectorDictionary = new Array(6);
        _this.textureType = "textureCube";
        _this._size = size;
        return _this;
        //todo
        // this._glTexture = this._gl.createTexture();
        //
        // this._textureSelectorDictionary[0] = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        // this._textureSelectorDictionary[1] = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
        // this._textureSelectorDictionary[2] = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
        // this._textureSelectorDictionary[3] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
        // this._textureSelectorDictionary[4] = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
        // this._textureSelectorDictionary[5] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
    }
    CubeTextureGLES.prototype.uploadFromImage = function (imageCube, side, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        //todo
        // this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._glTexture);
        // this._gl.texImage2D(this._textureSelectorDictionary[side], miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, data);
        // this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
    };
    CubeTextureGLES.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        //todo
        if (async === void 0) { async = false; }
    };
    Object.defineProperty(CubeTextureGLES.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    return CubeTextureGLES;
}(TextureBaseGLES));

var IndexBufferGLES = (function (_super) {
    __extends(IndexBufferGLES, _super);
    function IndexBufferGLES(context, gl, numIndices, id) {
        var _this = _super.call(this, context, id) || this;
        _this._gl = gl;
        // this._buffer = this._gl.createBuffer();
        _this._numIndices = numIndices;
        return _this;
    }
    IndexBufferGLES.prototype.uploadFromArray = function (data, startOffset, count) {
        //GLESConnector.gles.uploadIndexDataFromArray(this.id, data, startOffset, count);
        // this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
        //
        // if (startOffset)
        // 	this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset*2, new Uint16Array(data));
        // else
        // 	this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this._gl.STATIC_DRAW);
    };
    IndexBufferGLES.prototype.uploadFromByteArray = function (data, startOffset, count) {
        //GLESConnector.gles.uploadIndexDataFromByteArray(this.id, data, startOffset, count);
        // this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
        //
        // if (startOffset)
        // 	this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset*2, data);
        // else
        // 	this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
    };
    IndexBufferGLES.prototype.dispose = function () {
        //GLESConnector.gles.disposeIndexBuffer(this.id);
        // this._gl.deleteBuffer(this._buffer);
    };
    Object.defineProperty(IndexBufferGLES.prototype, "numIndices", {
        get: function () {
            return this._numIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IndexBufferGLES.prototype, "glBuffer", {
        get: function () {
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    return IndexBufferGLES;
}(GLESAssetBase));

var GLESConnector = (function () {
    function GLESConnector() {
    }
    Object.defineProperty(GLESConnector, "gles", {
        get: function () {
            if (!GLESConnector._gles)
                throw ("Error: Set GlesConnector.gles before calling methods on ContextGLES!");
            return GLESConnector._gles;
        },
        set: function (value) {
            GLESConnector._gles = value;
        },
        enumerable: true,
        configurable: true
    });
    
    
    return GLESConnector;
}());
GLESConnector._gles = null;

var ProgramGLES = (function (_super) {
    __extends(ProgramGLES, _super);
    function ProgramGLES(context, gl, id) {
        var _this = _super.call(this, context, id) || this;
        _this._uniforms = [[], [], []];
        _this._attribs = [];
        return _this;
        //console.log("awayjs created program with id "+ id);
        // this._gl = gl;
        // this._program = this._gl.createProgram();
    }
    ProgramGLES.prototype.upload = function (vertexProgram, fragmentProgram) {
        //detect whether highp can be used
        var vertexPrecision = (this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT).precision != 0) ? "highp" : "mediump";
        var fragmentPrecision = (this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT).precision != 0) ? "highp" : "mediump";
        var vertexString = ProgramGLES._aglslParser.parse(ProgramGLES._tokenizer.decribeAGALByteArray(vertexProgram), vertexPrecision);
        var fragmentString = ProgramGLES._aglslParser.parse(ProgramGLES._tokenizer.decribeAGALByteArray(fragmentProgram), fragmentPrecision);
        //(String.fromCharCode(OpCodes.uploadProgram)+""+this.id + "###"+vertexString +  "###" + fragmentString + "#END");
        var newSendbytes = new _awayjs_core.Byte32Array();
        newSendbytes.writeInt(1); //tells cpp that this is a create-bytes chunk
        newSendbytes.writeInt(OpCodes.uploadProgram);
        newSendbytes.writeInt(this.id);
        newSendbytes.writeUTFBytes(vertexString);
        newSendbytes.writeUTFBytes(fragmentString);
        newSendbytes.bytePosition = 0;
        var localInt32View = new Int32Array(newSendbytes.byteLength / 4);
        newSendbytes.readInt32Array(localInt32View);
        GLESConnector.gles.sendGLESCommands(localInt32View.buffer);
    };
    ProgramGLES.prototype.getUniformLocation = function (programType, index) {
        if (index === void 0) { index = -1; }
        // if (this._uniforms[programType][index + 1] != null)
        // 	return this._uniforms[programType][index + 1];
        //
        // var name:string =  (index == -1)? ProgramGLES._uniformLocationNameDictionary[programType] : ProgramGLES._uniformLocationNameDictionary[programType] + index;
        // return (this._uniforms[programType][index + 1] = this._gl.getUniformLocation(this._program, name));
        return null;
    };
    //
    // public getUniformLocation(programType:number, index:number):WebGLUniformLocation
    // {
    // 	if (this._uniforms[programType][index] != null)
    // 		return this._uniforms[programType][index];
    //
    // 	return (this._uniforms[programType][index] = this._gl.getUniformLocation(this._program, ProgramGLES._uniformLocationNameDictionary[programType] + index));
    // }
    ProgramGLES.prototype.getAttribLocation = function (index) {
        // if (this._attribs[index] != null)
        // 	return this._attribs[index];
        //
        // return (this._attribs[index] = this._gl.getAttribLocation(this._program, "va" + index));
        return 0;
    };
    ProgramGLES.prototype.dispose = function () {
        //this._context.addStream(String.fromCharCode(OpCodes.disposeProgram)+""+ this.id);
        this._context._createBytes.writeInt(OpCodes.disposeProgram);
        this._context._createBytes.writeInt(this.id);
        //GLESConnector.gles.disposeProgram(this.id);
        // this._gl.deleteProgram(this._program);
    };
    ProgramGLES.prototype.focusProgram = function () {
        //GLESConnector.gles.focusProgram(this.id);
        // this._gl.useProgram(this._program);
    };
    Object.defineProperty(ProgramGLES.prototype, "glProgram", {
        get: function () {
            return this._program;
        },
        enumerable: true,
        configurable: true
    });
    return ProgramGLES;
}(GLESAssetBase));
ProgramGLES._tokenizer = new AGALTokenizer();
ProgramGLES._aglslParser = new AGLSLParser();
ProgramGLES._uniformLocationNameDictionary = ["fc", "fs", "vc"];

var TextureGLES = (function (_super) {
    __extends(TextureGLES, _super);
    function TextureGLES(context, gl, width, height, id) {
        var _this = _super.call(this, context, gl, id) || this;
        _this.textureType = "texture2d";
        _this._width = width;
        _this._height = height;
        return _this;
        //
        // this._glTexture = this._gl.createTexture();
    }
    Object.defineProperty(TextureGLES.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureGLES.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureGLES.prototype, "frameBuffer", {
        get: function () {
            //this._context.addStream(String.fromCharCode(OpCodes.getFrameBufferForTexture) + this.id.toString() + "#END");
            /*
                    this._context._createBytes.ensureSpace(2);//the space for the text is ensured during writeUTFBytes
                    this._context._createBytes.writeUnsignedByte(OpCodes.disposeVertexBuffer);
                    this._context._createBytes.writeByte(this.id);
                    */
            //this._context.execute();
            // if (!this._frameBuffer) {
            // 	this._frameBuffer = this._gl.createFramebuffer();
            // 	this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
            // 	this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
            // 	this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._width, this._height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
            //
            // 	var renderBuffer:GLESRenderbuffer = this._gl.createRenderbuffer();
            // 	this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
            // 	this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_STENCIL, this._width, this._height);
            //
            // 	this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._glTexture, 0);
            // 	this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_STENCIL_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
            //
            // 	this._gl.bindTexture(this._gl.TEXTURE_2D, null);
            // 	this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
            // 	this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            // }
            return this._frameBuffer;
        },
        enumerable: true,
        configurable: true
    });
    TextureGLES.prototype.uploadFromImage = function (image2D, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        var newSendbytes = new _awayjs_core.Byte32Array();
        newSendbytes.writeInt(1); //tells cpp that this is a create-bytes chunk
        newSendbytes.writeInt(OpCodes.uploadBytesTexture | miplevel << 8);
        newSendbytes.writeInt(this.id);
        newSendbytes.writeFloat(this._width);
        newSendbytes.writeFloat(this._height);
        newSendbytes.writeInt(image2D.getImageData().data.buffer.byteLength);
        newSendbytes.writeInt32Array(new Int32Array(image2D.getImageData().data.buffer));
        newSendbytes.bytePosition = 0;
        var localInt32View = new Int32Array(newSendbytes.byteLength / 4);
        newSendbytes.readInt32Array(localInt32View);
        GLESConnector.gles.sendGLESCommands(localInt32View.buffer);
    };
    TextureGLES.prototype.uploadFromURL = function (urlRequest, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        var newSendbytes = new _awayjs_core.Byte32Array();
        newSendbytes.writeInt(1); //tells cpp that this is a create-bytes chunk
        newSendbytes.writeInt(OpCodes.uploadTextureFromURL | miplevel << 8);
        newSendbytes.writeInt(this.id);
        var myURLString = urlRequest.url.replace(/[^a-zA-Z0-9]/g, '');
        console.log("urlRequest.url " + myURLString);
        newSendbytes.writeUTFBytes(myURLString);
        newSendbytes.bytePosition = 0;
        var localInt32View = new Int32Array(newSendbytes.byteLength / 4);
        newSendbytes.readInt32Array(localInt32View);
        GLESConnector.gles.sendGLESCommands(localInt32View.buffer);
    };
    TextureGLES.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        if (async === void 0) { async = false; }
        //GLESConnector.gles.uploadCompressedTextureFromByteArray(this.id, data, byteArrayOffset, async);
        // var ext:Object = this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        // //this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this)
    };
    return TextureGLES;
}(TextureBaseGLES));

var VertexBufferGLES = (function (_super) {
    __extends(VertexBufferGLES, _super);
    function VertexBufferGLES(context, gl, numVertices, dataPerVertex, id) {
        var _this = _super.call(this, context, id) || this;
        // this._gl = gl;
        // this._buffer = this._gl.createBuffer();
        _this._numVertices = numVertices;
        _this._dataPerVertex = dataPerVertex;
        return _this;
    }
    VertexBufferGLES.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
        //GLESConnector.gles.uploadVertexDataFromArray(this.id, vertices, startVertex, numVertices);
        // this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
        //
        // if (startVertex)
        // 	this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex*this._dataPerVertex, new Float32Array(vertices));
        // else
        // 	this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);
    };
    VertexBufferGLES.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
        var newSendbytes = new _awayjs_core.Byte32Array();
        newSendbytes.writeInt(1); //send create bytes
        newSendbytes.writeInt(OpCodes.uploadArrayVertexBuffer);
        newSendbytes.writeInt(this.id);
        newSendbytes.writeInt(startVertex);
        newSendbytes.writeInt(data.byteLength);
        newSendbytes.writeInt32Array(new Int32Array(data)); //TODO: cache the view on the attributebuffer
        newSendbytes.bytePosition = 0;
        var localInt32View = new Int32Array(newSendbytes.byteLength / 4);
        newSendbytes.readInt32Array(localInt32View);
        GLESConnector.gles.sendGLESCommands(localInt32View.buffer);
    };
    Object.defineProperty(VertexBufferGLES.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferGLES.prototype, "dataPerVertex", {
        get: function () {
            return this._dataPerVertex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferGLES.prototype, "glBuffer", {
        get: function () {
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    VertexBufferGLES.prototype.dispose = function () {
        //console.log("dispose vertexdata "+this.id);
        //this._context.addCreateStream(String.fromCharCode(OpCodes.disposeVertexBuffer) + this.id+"#END");
        this._context._createBytes.writeInt(OpCodes.disposeVertexBuffer);
        this._context._createBytes.writeInt(this.id);
    };
    return VertexBufferGLES;
}(GLESAssetBase));

var ContextGLES = (function () {
    function ContextGLES(canvas) {
        this._blendFactorDictionary = new Object();
        this._drawModeDictionary = new Object();
        this._compareModeDictionary = new Object();
        this.stencilTriangleFace = new Object();
        this._stencilActionDictionary = new Object();
        this._textureIndexDictionary = new Array(8);
        this._textureTypeDictionary = new Object();
        this._wrapDictionary = new Object();
        this._filterDictionary = new Object();
        this._mipmapFilterDictionary = new Object();
        this._vertexBufferPropertiesDictionary = [];
        this._samplerStates = new Array(8);
        this._stencilReferenceValue = 0;
        this._stencilReadMask = 0xff;
        this._separateStencil = false;
        this._textureCnt = 0;
        this._programCnt = 0;
        this._cubeTextureCnt = 0;
        this._indexBufferCnt = 0;
        this._vertexBufferCnt = 0;
        this._container = canvas;
        this._cmdBytes = new _awayjs_core.Byte32Array();
        this._createBytes = new _awayjs_core.Byte32Array();
        ContextGLES._soundBytes = new _awayjs_core.Byte32Array();
        ContextGLES._soundBytes.writeUnsignedInt(100); //id for sending sound data
        this._cmdBytes.writeUnsignedInt(0); //id for sending cmd data
        this._createBytes.writeUnsignedInt(1); //id for sending create data
        this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE] = 0;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.DESTINATION_ALPHA] = 1;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.DESTINATION_COLOR] = 2;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA] = 3;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR] = 4;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA] = 5;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR] = 6;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.SOURCE_ALPHA] = 7;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.SOURCE_COLOR] = 8;
        this._blendFactorDictionary[exports.ContextGLBlendFactor.ZERO] = 9;
        this._drawModeDictionary[exports.ContextGLDrawMode.LINES] = 0;
        this._drawModeDictionary[exports.ContextGLDrawMode.TRIANGLES] = 1;
        this._compareModeDictionary[exports.ContextGLCompareMode.ALWAYS] = 0;
        this._compareModeDictionary[exports.ContextGLCompareMode.EQUAL] = 1;
        this._compareModeDictionary[exports.ContextGLCompareMode.GREATER] = 2;
        this._compareModeDictionary[exports.ContextGLCompareMode.GREATER_EQUAL] = 3;
        this._compareModeDictionary[exports.ContextGLCompareMode.LESS] = 4;
        this._compareModeDictionary[exports.ContextGLCompareMode.LESS_EQUAL] = 5;
        this._compareModeDictionary[exports.ContextGLCompareMode.NEVER] = 6;
        this._compareModeDictionary[exports.ContextGLCompareMode.NOT_EQUAL] = 7;
        this.stencilTriangleFace[exports.ContextGLTriangleFace.BACK] = 2;
        this.stencilTriangleFace[exports.ContextGLTriangleFace.FRONT] = 1;
        this.stencilTriangleFace[exports.ContextGLTriangleFace.FRONT_AND_BACK] = 0;
        //
        this._stencilActionDictionary[exports.ContextGLStencilAction.DECREMENT_SATURATE] = 0;
        this._stencilActionDictionary[exports.ContextGLStencilAction.DECREMENT_WRAP] = 1;
        this._stencilActionDictionary[exports.ContextGLStencilAction.INCREMENT_SATURATE] = 2;
        this._stencilActionDictionary[exports.ContextGLStencilAction.INCREMENT_WRAP] = 3;
        this._stencilActionDictionary[exports.ContextGLStencilAction.INVERT] = 4;
        this._stencilActionDictionary[exports.ContextGLStencilAction.KEEP] = 5;
        this._stencilActionDictionary[exports.ContextGLStencilAction.SET] = 6;
        this._stencilActionDictionary[exports.ContextGLStencilAction.ZERO] = 7;
        this._textureTypeDictionary["texture2d"] = 0;
        this._textureTypeDictionary["textureCube"] = 1;
        this._wrapDictionary[exports.ContextGLWrapMode.REPEAT] = 0;
        this._wrapDictionary[exports.ContextGLWrapMode.CLAMP] = 1;
        this._filterDictionary[exports.ContextGLTextureFilter.LINEAR] = 0;
        this._filterDictionary[exports.ContextGLTextureFilter.NEAREST] = 1;
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR] = new Object();
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR][exports.ContextGLMipFilter.MIPNEAREST] = 2;
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR][exports.ContextGLMipFilter.MIPLINEAR] = 3;
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR][exports.ContextGLMipFilter.MIPNONE] = 0;
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST] = new Object();
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST][exports.ContextGLMipFilter.MIPNEAREST] = 4;
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST][exports.ContextGLMipFilter.MIPLINEAR] = 5;
        this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST][exports.ContextGLMipFilter.MIPNONE] = 1;
    }
    // soundcommands are excuted on @away/player/AS2SoundAdapter, and stored here as binary data
    // when context is executed, they get send to java along woth the oother data
    ContextGLES.startSound = function (name, id, volume, loop) {
        ContextGLES._soundBytes.writeInt(OpCodes.startSound | ((loop ? 1 : 0) << 8));
        ContextGLES._soundBytes.writeFloat(volume);
        ContextGLES._soundBytes.writeInt(id);
        ContextGLES._soundBytes.writeUTFBytes(name);
    };
    ContextGLES.stopSound = function (id) {
        ContextGLES._soundBytes.writeInt(OpCodes.stopSound);
        ContextGLES._soundBytes.writeInt(id);
    };
    ContextGLES.updateSound = function (id, volume, loop) {
        ContextGLES._soundBytes.writeInt(OpCodes.updateSound | ((loop ? 1 : 0) << 8));
        ContextGLES._soundBytes.writeFloat(volume);
        ContextGLES._soundBytes.writeInt(id);
    };
    Object.defineProperty(ContextGLES.prototype, "container", {
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextGLES.prototype, "standardDerivatives", {
        get: function () {
            return this._standardDerivatives;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextGLES.prototype, "pixelRatio", {
        get: function () {
            return 1;
        },
        enumerable: true,
        configurable: true
    });
    ContextGLES.prototype.enableStencil = function () {
        this._cmdBytes.writeInt(OpCodes.enableStencil);
    };
    ContextGLES.prototype.disableStencil = function () {
        this._cmdBytes.writeInt(OpCodes.disableStencil);
    };
    ContextGLES.prototype.gl = function () {
        return this._gl;
    };
    ContextGLES.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
        if (red === void 0) { red = 0; }
        if (green === void 0) { green = 0; }
        if (blue === void 0) { blue = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (depth === void 0) { depth = 1; }
        if (stencil === void 0) { stencil = 0; }
        if (mask === void 0) { mask = exports.ContextGLClearMask.ALL; }
        this._cmdBytes.writeInt(OpCodes.clear);
        this._cmdBytes.writeFloat(red);
        this._cmdBytes.writeFloat(green);
        this._cmdBytes.writeFloat(blue);
        this._cmdBytes.writeFloat(alpha);
        this._cmdBytes.writeInt(depth);
        this._cmdBytes.writeInt(stencil);
        this._cmdBytes.writeInt(mask);
    };
    ContextGLES.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
        this._width = width;
        this._height = height;
        this._cmdBytes.writeInt(OpCodes.configureBackBuffer | (enableDepthAndStencil ? 1 : 0) << 8);
        this._cmdBytes.writeFloat(width);
        this._cmdBytes.writeFloat(height);
    };
    ContextGLES.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        // todo: cubetextures not finished / tested for opengl yet
        return new CubeTextureGLES(this, this._gl, size, this._cubeTextureCnt++);
    };
    ContextGLES.prototype.createIndexBuffer = function (numIndices) {
        // todo: indexBuffer not finished / tested for opengl yet
        return new IndexBufferGLES(this, this._gl, numIndices, this._indexBufferCnt++);
    };
    ContextGLES.prototype.createProgram = function () {
        return new ProgramGLES(this, this._gl, this._programCnt++);
    };
    ContextGLES.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        //TODO streaming
        return new TextureGLES(this, this._gl, width, height, this._textureCnt++);
    };
    ContextGLES.prototype.createVertexBuffer = function (numVertices, dataPerVertex) {
        return new VertexBufferGLES(this, this._gl, numVertices, dataPerVertex, this._vertexBufferCnt++);
    };
    ContextGLES.prototype.dispose = function () {
        this._cmdBytes.writeInt(OpCodes.disposeContext);
        this.execute();
    };
    ContextGLES.prototype.drawToBitmapImage2D = function (destination) {
        //todo (not needed for icycle (?) )
        // var pixels:Uint8ClampedArray = new Uint8ClampedArray(destination.width*destination.height*4);
        //
        // this._gl.readPixels(0, 0, destination.width, destination.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixels);
        //
        // destination.setPixels(new Rectangle(0, 0, destination.width, destination.height), pixels);
    };
    ContextGLES.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
        if (firstIndex === void 0) { firstIndex = 0; }
        if (numIndices === void 0) { numIndices = -1; }
        //todo (not needed for icycle)
        //GLESConnector.gles.drawIndices(mode, indexBuffer.id, firstIndex, numIndices);
        // if (!this._drawing)
        // 	throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
        //
        //
        // this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
        // this._gl.drawElements(this._drawModeDictionary[mode], (numIndices == -1)? indexBuffer.numIndices : numIndices, this._gl.UNSIGNED_SHORT, firstIndex*2);
    };
    ContextGLES.prototype.drawVertices = function (mode, firstVertex, numVertices) {
        if (firstVertex === void 0) { firstVertex = 0; }
        if (numVertices === void 0) { numVertices = -1; }
        // if (!this._drawing)
        // 	throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
        this._cmdBytes.writeInt(OpCodes.drawVertices | (this._drawModeDictionary[mode] << 8));
        this._cmdBytes.writeInt(firstVertex);
        this._cmdBytes.writeInt(numVertices);
    };
    ContextGLES.prototype.present = function () {
        this.execute();
    };
    ContextGLES.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
        this._blendEnabled = true;
        this._blendSourceFactor = this._blendFactorDictionary[sourceFactor];
        this._blendDestinationFactor = this._blendFactorDictionary[destinationFactor];
        this.updateBlendStatus();
    };
    ContextGLES.prototype.setColorMask = function (red, green, blue, alpha) {
        this._cmdBytes.writeInt(OpCodes.setColorMask);
        this._cmdBytes.writeInt((red ? 1 : 0) | (green ? 1 : 0) << 8 | (blue ? 1 : 0) << 16 | (alpha ? 1 : 0) << 24);
    };
    ContextGLES.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
        if (coordinateSystem === void 0) { coordinateSystem = _awayjs_core.CoordinateSystem.LEFT_HANDED; }
        if (triangleFaceToCull == exports.ContextGLTriangleFace.NONE) {
            //this.addStream(String.fromCharCode(OpCodes.disableCulling) + "#END");
            this._cmdBytes.writeInt(OpCodes.disableCulling);
            return;
        }
        var faceCulling = this.translateTriangleFace(triangleFaceToCull, coordinateSystem);
        this._cmdBytes.writeInt(OpCodes.setCulling | faceCulling << 8);
    };
    ContextGLES.prototype.setDepthTest = function (depthMask, passCompareMode) {
        this._cmdBytes.writeInt(OpCodes.setDepthTest | (depthMask ? 1 : 0) << 8 | this._compareModeDictionary[passCompareMode] << 16);
    };
    ContextGLES.prototype.setStencilActionsMasks = function (compareMode, referenceValue, writeMask, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
        if (actionOnBothPass === void 0) { actionOnBothPass = "keep"; }
        if (actionOnDepthFail === void 0) { actionOnDepthFail = "keep"; }
        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = "keep"; }
        if (coordinateSystem === void 0) { coordinateSystem = "leftHanded"; }
        var compareModeGL = this._compareModeDictionary[compareMode];
        var fail = this._stencilActionDictionary[actionOnDepthPassStencilFail];
        var zFail = this._stencilActionDictionary[actionOnDepthFail];
        var pass = this._stencilActionDictionary[actionOnBothPass];
        this._cmdBytes.writeInt(OpCodes.setStencilActionsMasks | (compareModeGL << 8));
        this._cmdBytes.writeInt(referenceValue);
        this._cmdBytes.writeInt(writeMask | fail << 8 | zFail << 16 | pass << 24);
    };
    ContextGLES.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
        if (triangleFace === void 0) { triangleFace = exports.ContextGLTriangleFace.FRONT_AND_BACK; }
        if (compareMode === void 0) { compareMode = exports.ContextGLCompareMode.ALWAYS; }
        if (actionOnBothPass === void 0) { actionOnBothPass = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthFail === void 0) { actionOnDepthFail = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = exports.ContextGLStencilAction.KEEP; }
        if (coordinateSystem === void 0) { coordinateSystem = _awayjs_core.CoordinateSystem.LEFT_HANDED; }
        var compareModeGL = this._compareModeDictionary[compareMode];
        var triangleFaceGL = this.stencilTriangleFace[triangleFace];
        var fail = this._stencilActionDictionary[actionOnDepthPassStencilFail];
        var zFail = this._stencilActionDictionary[actionOnDepthFail];
        var pass = this._stencilActionDictionary[actionOnBothPass];
        this._cmdBytes.writeInt(OpCodes.setStencilActions | triangleFaceGL << 8);
        this._cmdBytes.writeInt(compareModeGL | fail << 8 | zFail << 16 | pass << 24);
    };
    ContextGLES.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
        if (readMask === void 0) { readMask = 0xFF; }
        if (writeMask === void 0) { writeMask = 0xFF; }
        this._cmdBytes.writeInt(OpCodes.setStencilReferenceValue);
        this._cmdBytes.writeInt(referenceValue);
        this._cmdBytes.writeInt(readMask);
        this._cmdBytes.writeInt(writeMask);
    };
    ContextGLES.prototype.setProgram = function (program) {
        this._cmdBytes.writeInt(OpCodes.setProgram);
        this._cmdBytes.writeInt(program.id);
    };
    ContextGLES.prototype.setProgramConstantsFromArray = function (programType, data) {
        this._cmdBytes.writeInt(OpCodes.setProgramConstant | programType << 8);
        this._cmdBytes.writeInt(data.length);
        this._cmdBytes.writeFloat32Array(data);
    };
    ContextGLES.prototype.setScissorRectangle = function (rectangle) {
        if (rectangle) {
            this._cmdBytes.writeInt(OpCodes.setScissorRect);
            this._cmdBytes.writeFloat(rectangle.x);
            this._cmdBytes.writeFloat(rectangle.y);
            this._cmdBytes.writeFloat(rectangle.width);
            this._cmdBytes.writeFloat(rectangle.height);
        }
        else {
            this._cmdBytes.writeInt(OpCodes.clearScissorRect);
        }
    };
    ContextGLES.prototype.setTextureAt = function (sampler, texture) {
        if (texture) {
            this._cmdBytes.writeInt(OpCodes.setTextureAt | sampler << 8);
            this._cmdBytes.writeInt(texture.id);
        }
        else {
            this._cmdBytes.writeInt(OpCodes.clearTextureAt | sampler << 8);
        }
    };
    ContextGLES.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
        this._cmdBytes.writeInt(OpCodes.setSamplerStateAt | sampler << 8);
        this._cmdBytes.writeInt(this._wrapDictionary[wrap] | this._filterDictionary[filter] << 8 | this._mipmapFilterDictionary[filter][mipfilter] << 16);
    };
    ContextGLES.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
        if (bufferOffset === void 0) { bufferOffset = 0; }
        if (format === void 0) { format = 4; }
        if (buffer) {
            this._cmdBytes.writeInt(OpCodes.setVertexBufferAt | index << 8 | format << 16 | buffer.dataPerVertex << 24);
            this._cmdBytes.writeInt(buffer.id);
            this._cmdBytes.writeInt(bufferOffset);
        }
        else {
            this._cmdBytes.writeInt(OpCodes.clearVertexBufferAt | index << 8);
        }
    };
    ContextGLES.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (antiAlias === void 0) { antiAlias = 0; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        if (target === null || target === undefined) {
            this._cmdBytes.writeInt(OpCodes.clearRenderToTexture);
        }
        else {
            this._cmdBytes.writeInt(OpCodes.setRenderToTexture | (enableDepthAndStencil ? 1 : 0) << 8);
            this._cmdBytes.writeInt(target.id);
        }
        // var texture:TextureGLES = <TextureGLES> target;
        // var frameBuffer:WebGLFramebuffer = texture.frameBuffer;
        // this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);
        //
        // if (enableDepthAndStencil) {
        // 	this._gl.enable(this._gl.STENCIL_TEST);
        // 	this._gl.enable(this._gl.DEPTH_TEST);
        // }
        //
        // this._gl.viewport(0, 0, texture.width, texture.height );
    };
    ContextGLES.prototype.setRenderToBackBuffer = function () {
        this._cmdBytes.writeInt(OpCodes.clearRenderToTexture);
        //todo
        // this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
    };
    ContextGLES.prototype.updateBlendStatus = function () {
        if (this._blendEnabled) {
            this._cmdBytes.writeInt(OpCodes.setBlendFactors | this._blendSourceFactor << 8 | this._blendDestinationFactor << 16);
        }
        else {
            this._cmdBytes.writeUnsignedInt(OpCodes.disableBlending);
        }
    };
    ContextGLES.prototype.translateTriangleFace = function (triangleFace, coordinateSystem) {
        switch (triangleFace) {
            case exports.ContextGLTriangleFace.BACK:
                return (coordinateSystem == _awayjs_core.CoordinateSystem.LEFT_HANDED) ? 2 : 1;
            case exports.ContextGLTriangleFace.FRONT:
                return (coordinateSystem == _awayjs_core.CoordinateSystem.LEFT_HANDED) ? 1 : 2;
            case exports.ContextGLTriangleFace.FRONT_AND_BACK:
                return 0;
            default:
                throw "Unknown ContextGLTriangleFace type."; // TODO error
        }
    };
    ContextGLES.prototype.execute = function () {
        if (this._createBytes.bytePosition > 4) {
            this._createBytes.bytePosition = 0;
            var localInt32View1 = new Int32Array(this._createBytes.byteLength / 4);
            this._createBytes.readInt32Array(localInt32View1);
            GLESConnector.gles.sendGLESCommands(localInt32View1.buffer);
            this._createBytes.byteLength = 0;
            this._createBytes.bytePosition = 0;
            this._createBytes.writeUnsignedInt(1); // make sure first int in bytearray is the id (1 for create bytes)
        }
        if (this._cmdBytes.bytePosition > 4) {
            this._cmdBytes.bytePosition = 0;
            var localInt32View = new Int32Array(this._cmdBytes.byteLength / 4);
            this._cmdBytes.readInt32Array(localInt32View);
            GLESConnector.gles.sendGLESCommands(localInt32View.buffer);
            this._cmdBytes.byteLength = 0;
            this._cmdBytes.bytePosition = 0;
            this._cmdBytes.writeUnsignedInt(0); // make sure first int in bytearray is the id (0 for cmd bytes)
        }
        if (ContextGLES._soundBytes.bytePosition > 4) {
            ContextGLES._soundBytes.bytePosition = 0;
            var localInt32View2 = new Int32Array(ContextGLES._soundBytes.byteLength / 4);
            ContextGLES._soundBytes.readInt32Array(localInt32View2);
            GLESConnector.gles.sendGLESCommands(localInt32View2.buffer);
            ContextGLES._soundBytes.byteLength = 0;
            ContextGLES._soundBytes.bytePosition = 0;
            ContextGLES._soundBytes.writeUnsignedInt(100); // make sure first int in bytearray is the id (100 for cmd soundbytes)
        }
    };
    return ContextGLES;
}());
ContextGLES._uniformLocationNameDictionary = ["fc", "fs", "vc"];
ContextGLES.MAX_SAMPLERS = 8;
ContextGLES.modulo = 0;

/**
 *
 * @class away.pool.GL_ImageBase
 */
var GL_ImageBase = (function (_super) {
    __extends(GL_ImageBase, _super);
    function GL_ImageBase(asset, stage) {
        var _this = _super.call(this, asset, stage) || this;
        _this.usages = 0;
        _this._invalidMipmaps = true;
        _this._stage = stage;
        _this._onInvalidateMipmapsDelegate = function (event) { return _this.onInvalidateMipmaps(event); };
        _this._asset.addEventListener(_awayjs_graphics.ImageEvent.INVALIDATE_MIPMAPS, _this._onInvalidateMipmapsDelegate);
        return _this;
    }
    GL_ImageBase.prototype.getTexture = function () {
        if (!this._texture) {
            this._createTexture();
            this._invalid = true;
        }
        return this._texture;
    };
    /**
     *
     */
    GL_ImageBase.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        if (this._texture) {
            this._texture.dispose();
            this._texture = null;
        }
    };
    GL_ImageBase.prototype.activate = function (index, mipmap) {
        this._stage.context.setTextureAt(index, this.getTexture());
    };
    GL_ImageBase.prototype._createTexture = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     *
     */
    GL_ImageBase.prototype.onInvalidateMipmaps = function (event) {
        this._invalidMipmaps = true;
    };
    return GL_ImageBase;
}(_awayjs_core.AbstractionBase));

/**
 *
 * @class away.pool.GL_ImageBase
 */
var GL_Image2D = (function (_super) {
    __extends(GL_Image2D, _super);
    function GL_Image2D() {
        return _super.apply(this, arguments) || this;
    }
    GL_Image2D.prototype.activate = function (index, mipmap) {
        _super.prototype.activate.call(this, index, mipmap);
        if (mipmap && this._stage.globalDisableMipmap)
            mipmap = false;
        if (!this._mipmap && mipmap) {
            this._mipmap = true;
            this._invalidMipmaps = true;
        }
        if (this._invalidMipmaps) {
            this._invalidMipmaps = false;
            if (mipmap)
                this._texture.generateMipmaps();
        }
    };
    /**
     *
     * @param context
     * @returns {ITexture}
     */
    GL_Image2D.prototype._createTexture = function () {
        this._texture = this._stage.context.createTexture(this._asset.width, this._asset.height, exports.ContextGLTextureFormat.BGRA, true);
    };
    return GL_Image2D;
}(GL_ImageBase));

/**
 *
 * @class away.pool.ImageObjectBase
 */
var GL_BitmapImage2D = (function (_super) {
    __extends(GL_BitmapImage2D, _super);
    function GL_BitmapImage2D() {
        return _super.apply(this, arguments) || this;
    }
    GL_BitmapImage2D.prototype.getTexture = function () {
        _super.prototype.getTexture.call(this);
        if (this._invalid) {
            this._invalid = false;
            this._texture.uploadFromImage(this._asset, 0);
            this._invalidMipmaps = true;
        }
        return this._texture;
    };
    return GL_BitmapImage2D;
}(GL_Image2D));

/**
 *
 * @class away.pool.ImageObjectBase
 */
var GL_ExternalImage2D = (function (_super) {
    __extends(GL_ExternalImage2D, _super);
    function GL_ExternalImage2D() {
        return _super.apply(this, arguments) || this;
    }
    GL_ExternalImage2D.prototype.getTexture = function () {
        _super.prototype.getTexture.call(this);
        if (this._invalid) {
            this._invalid = false;
            this._texture.uploadFromURL(this._asset.urlRequest, 0);
            this._invalidMipmaps = true;
        }
        return this._texture;
    };
    return GL_ExternalImage2D;
}(GL_Image2D));

/**
 *
 * @class away.pool.GL_ImageCubeBase
 */
var GL_ImageCube = (function (_super) {
    __extends(GL_ImageCube, _super);
    function GL_ImageCube() {
        return _super.apply(this, arguments) || this;
    }
    /**
     *
     * @param context
     * @returns {ITexture}
     */
    GL_ImageCube.prototype._createTexture = function () {
        this._texture = this._stage.context.createCubeTexture(this._asset.size, exports.ContextGLTextureFormat.BGRA, false);
    };
    return GL_ImageCube;
}(GL_ImageBase));

/**
 *
 * @class away.pool.ImageObjectBase
 */
var GL_BitmapImageCube = (function (_super) {
    __extends(GL_BitmapImageCube, _super);
    function GL_BitmapImageCube() {
        var _this = _super.apply(this, arguments) || this;
        _this._mipmapDataArray = new Array(6);
        return _this;
    }
    GL_BitmapImageCube.prototype.activate = function (index, mipmap) {
        if (mipmap && this._stage.globalDisableMipmap)
            mipmap = false;
        if (!this._texture) {
            this._createTexture();
            this._invalid = true;
        }
        if (!this._mipmap && mipmap) {
            this._mipmap = true;
            this._invalid = true;
        }
        if (this._invalid) {
            this._invalid = false;
            for (var i = 0; i < 6; ++i)
                this._texture.uploadFromImage(this._asset, i, 0);
            if (mipmap)
                this._texture.generateMipmaps();
        }
        // if (this._invalid) {
        // 	this._invalid = false;
        // 	for (var i:number = 0; i < 6; ++i) {
        // 		if (mipmap) {
        // 			var mipmapData:Array<BitmapImage2D> = this._mipmapDataArray[i] || (this._mipmapDataArray[i] = new Array<BitmapImage2D>());
        //
        // 			MipmapGenerator._generateMipMaps((<BitmapImageCube> this._asset).getCanvas(i), mipmapData, true);
        // 			var len:number = mipmapData.length;
        // 			for (var j:number = 0; j < len; j++)
        // 				(<ICubeTexture> this._texture).uploadFromImage(mipmapData[j], i, j);
        // 		} else {
        // 			(<ICubeTexture> this._texture).uploadFromImage(<BitmapImageCube> this._asset, i, 0);
        // 		}
        // 	}
        // }
        _super.prototype.activate.call(this, index, mipmap);
    };
    /**
     *
     */
    GL_BitmapImageCube.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        for (var i = 0; i < 6; i++) {
            var mipmapData = this._mipmapDataArray[i];
            if (mipmapData) {
                var len = mipmapData.length;
                for (var j = 0; j < len; i++)
                    _awayjs_graphics.MipmapGenerator._freeMipMapHolder(mipmapData[j]);
            }
        }
    };
    return GL_BitmapImageCube;
}(GL_ImageCube));

/**
 *
 * @class away.pool.ImageObjectBase
 */
var GL_RenderImage2D = (function (_super) {
    __extends(GL_RenderImage2D, _super);
    function GL_RenderImage2D() {
        return _super.apply(this, arguments) || this;
    }
    return GL_RenderImage2D;
}(GL_Image2D));

/**
 *
 * @class away.pool.ImageObjectBase
 */
var GL_RenderImageCube = (function (_super) {
    __extends(GL_RenderImageCube, _super);
    function GL_RenderImageCube() {
        return _super.apply(this, arguments) || this;
    }
    GL_RenderImageCube.prototype.activate = function (index, mipmap) {
        _super.prototype.activate.call(this, index, false);
        //TODO: allow automatic mipmap generation
    };
    return GL_RenderImageCube;
}(GL_ImageCube));

/**
 *
 * @class away.pool.GL_SamplerBase
 */
var GL_SamplerBase = (function (_super) {
    __extends(GL_SamplerBase, _super);
    function GL_SamplerBase(asset, stage) {
        var _this = _super.call(this, asset, stage) || this;
        _this._stage = stage;
        return _this;
    }
    GL_SamplerBase.prototype.activate = function (index) {
        throw new _awayjs_core.AbstractMethodError();
    };
    return GL_SamplerBase;
}(_awayjs_core.AbstractionBase));

/**
 *
 * @class away.pool.GL_SamplerBase
 */
var GL_Sampler2D = (function (_super) {
    __extends(GL_Sampler2D, _super);
    function GL_Sampler2D(sampler, stage) {
        var _this = _super.call(this, sampler, stage) || this;
        _this._sampler = sampler;
        return _this;
    }
    GL_Sampler2D.prototype.activate = function (index) {
        this._stage.setSamplerState(index, this._sampler.repeat, this._sampler.smooth, this._sampler.mipmap);
    };
    return GL_Sampler2D;
}(GL_SamplerBase));

/**
 *
 * @class away.pool.GL_SamplerBase
 */
var GL_SamplerCube = (function (_super) {
    __extends(GL_SamplerCube, _super);
    function GL_SamplerCube(sampler, stage) {
        var _this = _super.call(this, sampler, stage) || this;
        _this._sampler = sampler;
        return _this;
    }
    GL_SamplerCube.prototype.activate = function (index) {
        this._stage.setSamplerState(index, false, this._sampler.smooth, this._sampler.mipmap);
    };
    return GL_SamplerCube;
}(GL_SamplerBase));

/**
 *
 * @class away.pool.ProgramDataBase
 */
var ProgramData = (function () {
    function ProgramData(pool, context, vertexString, fragmentString) {
        this.usages = 0;
        this._pool = pool;
        this.stage = context;
        this.vertexString = vertexString;
        this.fragmentString = fragmentString;
        this.stage.registerProgram(this);
    }
    /**
     *
     */
    ProgramData.prototype.dispose = function () {
        this.usages--;
        if (!this.usages) {
            this._pool.disposeItem(this.vertexString + this.fragmentString);
            this.stage.unRegisterProgram(this);
            if (this.program) {
                this.program.dispose();
                this.program = null;
            }
        }
    };
    return ProgramData;
}());
ProgramData.PROGRAMDATA_ID_COUNT = 0;

/**
 * @class away.pool.ProgramDataPool
 */
var ProgramDataPool = (function () {
    /**
     * //TODO
     *
     * @param textureDataClass
     */
    function ProgramDataPool(stage) {
        this._pool = new Object();
        this._stage = stage;
    }
    /**
     * //TODO
     *
     * @param materialOwner
     * @returns ITexture
     */
    ProgramDataPool.prototype.getItem = function (vertexString, fragmentString) {
        var key = vertexString + fragmentString;
        return this._pool[key] || (this._pool[key] = new ProgramData(this, this._stage, vertexString, fragmentString));
    };
    /**
     * //TODO
     *
     * @param materialOwner
     */
    ProgramDataPool.prototype.disposeItem = function (key) {
        this._pool[key] = null;
    };
    return ProgramDataPool;
}());

var IndexBufferSoftware = (function () {
    function IndexBufferSoftware(numIndices) {
        this._numIndices = numIndices;
    }
    IndexBufferSoftware.prototype.uploadFromArray = function (data, startOffset, count) {
        this._startOffset = startOffset * 2;
        this._data = new Uint16Array(data);
    };
    IndexBufferSoftware.prototype.uploadFromByteArray = function (data, startOffset, count) {
        this._startOffset = startOffset * 2;
        this._data = new Uint16Array(data);
    };
    IndexBufferSoftware.prototype.dispose = function () {
        this._data = null;
    };
    Object.defineProperty(IndexBufferSoftware.prototype, "numIndices", {
        get: function () {
            return this._numIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IndexBufferSoftware.prototype, "data", {
        get: function () {
            return this._data;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IndexBufferSoftware.prototype, "startOffset", {
        get: function () {
            return this._startOffset;
        },
        enumerable: true,
        configurable: true
    });
    return IndexBufferSoftware;
}());

var VertexBufferSoftware = (function () {
    //private _dataOffset:number;
    function VertexBufferSoftware(numVertices, dataPerVertex) {
        this._numVertices = numVertices;
        this._dataPerVertex = dataPerVertex;
    }
    VertexBufferSoftware.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
        //this._dataOffset = startVertex * this._dataPerVertex;
        this._floatData = new Float32Array(vertices);
    };
    VertexBufferSoftware.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
        //this._dataOffset = startVertex * this._dataPerVertex;
        this._floatData = new Float32Array(data, startVertex * this._dataPerVertex, numVertices * this._dataPerVertex / 4);
        this._uintData = new Uint8Array(data);
    };
    Object.defineProperty(VertexBufferSoftware.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferSoftware.prototype, "dataPerVertex", {
        get: function () {
            return this._dataPerVertex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferSoftware.prototype, "attributesPerVertex", {
        get: function () {
            return this._dataPerVertex / 4;
        },
        enumerable: true,
        configurable: true
    });
    VertexBufferSoftware.prototype.dispose = function () {
        this._floatData = null;
    };
    Object.defineProperty(VertexBufferSoftware.prototype, "data", {
        get: function () {
            return this._floatData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferSoftware.prototype, "uintData", {
        get: function () {
            return this._uintData;
        },
        enumerable: true,
        configurable: true
    });
    return VertexBufferSoftware;
}());

var TextureSoftware = (function () {
    function TextureSoftware(width, height) {
        this._mipLevels = [];
        this._width = width;
        this._height = height;
    }
    Object.defineProperty(TextureSoftware.prototype, "textureType", {
        get: function () {
            return TextureSoftware.textureType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureSoftware.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureSoftware.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    TextureSoftware.prototype.dispose = function () {
        this._mipLevels = null;
    };
    TextureSoftware.prototype.isTexture = function (textureClass) {
        return this.textureType == textureClass.textureType;
    };
    TextureSoftware.prototype.uploadFromImage = function (image2D, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        this._mipLevels[miplevel] = image2D.getImageData().data;
    };
    TextureSoftware.prototype.uploadFromURL = function (urlRequest, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
    };
    TextureSoftware.prototype.getData = function (miplevel) {
        return this._mipLevels[miplevel];
    };
    TextureSoftware.prototype.getMipLevelsCount = function () {
        return this._mipLevels.length;
    };
    TextureSoftware.prototype.generateMipmaps = function () {
        //TODO
    };
    return TextureSoftware;
}());
TextureSoftware.textureType = "texture2d";

var CubeTextureSoftware = (function () {
    function CubeTextureSoftware(size) {
        this._textureSelectorDictionary = [[], [], [], [], [], []];
        this._size = size;
    }
    Object.defineProperty(CubeTextureSoftware.prototype, "textureType", {
        get: function () {
            return CubeTextureSoftware.textureType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CubeTextureSoftware.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    CubeTextureSoftware.prototype.dispose = function () {
        this._textureSelectorDictionary = null;
    };
    CubeTextureSoftware.prototype.isTexture = function (textureClass) {
        return this.textureType == textureClass.textureType;
    };
    CubeTextureSoftware.prototype.uploadFromImage = function (imageCube, side, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        this._textureSelectorDictionary[side][miplevel] = imageCube.getImageData(side).data;
    };
    CubeTextureSoftware.prototype.getData = function (side, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        return this._textureSelectorDictionary[side][miplevel];
    };
    CubeTextureSoftware.prototype.getMipLevelsCount = function () {
        return 1;
    };
    CubeTextureSoftware.prototype.generateMipmaps = function () {
        //TODO
    };
    CubeTextureSoftware.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset, async) {
        // TODO
    };
    return CubeTextureSoftware;
}());
CubeTextureSoftware.textureType = "textureCube";

var ProgramVOSoftware = (function () {
    function ProgramVOSoftware() {
        this.outputColor = new Float32Array([0, 0, 0, 1]);
        this.discard = false;
    }
    return ProgramVOSoftware;
}());

/**
 * The same as SamplerState, but with strings
 * TODO: replace two similar classes with one
 */
var SoftwareSamplerState = (function () {
    function SoftwareSamplerState() {
        this.wrap = exports.ContextGLWrapMode.REPEAT;
        this.filter = exports.ContextGLTextureFilter.LINEAR;
        this.mipfilter = exports.ContextGLMipFilter.MIPLINEAR;
    }
    return SoftwareSamplerState;
}());

var ProgramSoftware = (function () {
    function ProgramSoftware() {
        this._numVarying = 0;
    }
    Object.defineProperty(ProgramSoftware.prototype, "numVarying", {
        get: function () {
            return this._numVarying;
        },
        enumerable: true,
        configurable: true
    });
    ProgramSoftware.prototype.upload = function (vertexProgram, fragmentProgram) {
        this._vertexDescr = ProgramSoftware._tokenizer.decribeAGALByteArray(vertexProgram);
        this._vertexVO = new ProgramVOSoftware();
        this._vertexVO.temp = new Float32Array(this._vertexDescr.regwrite[0x2].length * 4);
        this._vertexVO.attributes = new Float32Array(this._vertexDescr.regread[0x0].length * 4);
        this._numVarying = this._vertexDescr.regwrite[0x4].length;
        this._fragmentDescr = ProgramSoftware._tokenizer.decribeAGALByteArray(fragmentProgram);
        this._fragmentVO = new ProgramVOSoftware();
        this._fragmentVO.temp = new Float32Array(this._fragmentDescr.regwrite[0x2].length * 4);
        this._fragmentVO.varying = new Float32Array(this._fragmentDescr.regread[0x4].length * 4);
        this._fragmentVO.derivativeX = new Float32Array(this._fragmentVO.varying.length);
        this._fragmentVO.derivativeY = new Float32Array(this._fragmentVO.varying.length);
    };
    ProgramSoftware.prototype.dispose = function () {
        this._vertexDescr = null;
        this._fragmentDescr = null;
    };
    ProgramSoftware.prototype.vertex = function (context, vertexIndex, position, varying) {
        //set attributes
        var i;
        var j = 0;
        var numAttributes = this._vertexDescr.regread[0x0].length;
        var attributes = this._vertexVO.attributes;
        for (i = 0; i < numAttributes; i++) {
            var buffer = context._vertexBuffers[i];
            if (!buffer)
                continue;
            var index = context._vertexBufferOffsets[i] / 4 + vertexIndex * buffer.attributesPerVertex;
            if (context._vertexBufferFormats[i] == exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_4) {
                attributes[j++] = buffer.uintData[index * 4];
                attributes[j++] = buffer.uintData[index * 4 + 1];
                attributes[j++] = buffer.uintData[index * 4 + 2];
                attributes[j++] = buffer.uintData[index * 4 + 3];
            }
            else if (context._vertexBufferFormats[i] == exports.ContextGLVertexBufferFormat.FLOAT_4) {
                attributes[j++] = buffer.data[index];
                attributes[j++] = buffer.data[index + 1];
                attributes[j++] = buffer.data[index + 2];
                attributes[j++] = buffer.data[index + 3];
            }
            else if (context._vertexBufferFormats[i] == exports.ContextGLVertexBufferFormat.FLOAT_3) {
                attributes[j++] = buffer.data[index];
                attributes[j++] = buffer.data[index + 1];
                attributes[j++] = buffer.data[index + 2];
                attributes[j++] = 1;
            }
            else if (context._vertexBufferFormats[i] == exports.ContextGLVertexBufferFormat.FLOAT_2) {
                attributes[j++] = buffer.data[index];
                attributes[j++] = buffer.data[index + 1];
                attributes[j++] = 0;
                attributes[j++] = 1;
            }
            else if (context._vertexBufferFormats[i] == exports.ContextGLVertexBufferFormat.FLOAT_1) {
                attributes[j++] = buffer.data[index];
                attributes[j++] = 0;
                attributes[j++] = 0;
                attributes[j++] = 1;
            }
        }
        //clear temps
        var temp = this._vertexVO.temp;
        var numTemp = temp.length;
        for (var i = 0; i < numTemp; i += 4) {
            temp[i] = 0;
            temp[i + 1] = 0;
            temp[i + 2] = 0;
            temp[i + 3] = 1;
        }
        this._vertexVO.outputPosition = position;
        this._vertexVO.varying = varying;
        var len = this._vertexDescr.tokens.length;
        for (var i = 0; i < len; i++) {
            var token = this._vertexDescr.tokens[i];
            ProgramSoftware._opCodeFunc[token.opcode](this._vertexVO, this._vertexDescr, token.dest, token.a, token.b, context);
        }
    };
    ProgramSoftware.prototype.fragment = function (context, clip, clipRight, clipBottom, varying0, varying1, varying2, fragDepth) {
        this._fragmentVO.outputDepth = fragDepth;
        this._fragmentVO.discard = false;
        //clear temps
        var temp = this._fragmentVO.temp;
        var numTemp = temp.length;
        for (var i = 0; i < numTemp; i += 4) {
            temp[i] = 0;
            temp[i + 1] = 0;
            temp[i + 2] = 0;
            temp[i + 3] = 1;
        }
        //check for requirement of derivatives
        var varyingDerivatives = [];
        var len = this._fragmentDescr.tokens.length;
        for (var i = 0; i < len; i++) {
            var token = this._fragmentDescr.tokens[i];
            if (token.opcode == 0x28 && context._samplerStates[token.b.regnum] && context._samplerStates[token.b.regnum].mipfilter == exports.ContextGLMipFilter.MIPLINEAR && context._textures[token.b.regnum].getMipLevelsCount() > 1)
                varyingDerivatives.push(token.a.regnum);
        }
        var derivativeX = this._fragmentVO.derivativeX;
        var derivativeY = this._fragmentVO.derivativeY;
        var varying = this._fragmentVO.varying;
        var numVarying = varying.length;
        for (var i = 0; i < numVarying; i += 4) {
            // if (!varying0 || !varying1 || !varying2) continue;
            varying[i] = clip.x * varying0[i] + clip.y * varying1[i] + clip.z * varying2[i];
            varying[i + 1] = clip.x * varying0[i + 1] + clip.y * varying1[i + 1] + clip.z * varying2[i + 1];
            varying[i + 2] = clip.x * varying0[i + 2] + clip.y * varying1[i + 2] + clip.z * varying2[i + 2];
            varying[i + 3] = clip.x * varying0[i + 3] + clip.y * varying1[i + 3] + clip.z * varying2[i + 3];
            if (varyingDerivatives.indexOf(i) == -1)
                continue;
            derivativeX[i] = clipRight.x * varying0[i] + clipRight.y * varying1[i] + clipRight.z * varying2[i];
            derivativeX[i + 1] = clipRight.x * varying0[i + 1] + clipRight.y * varying1[i + 1] + clipRight.z * varying2[i + 1];
            derivativeX[i + 2] = clipRight.x * varying0[i + 2] + clipRight.y * varying1[i + 2] + clipRight.z * varying2[i + 2];
            derivativeX[i + 3] = clipRight.x * varying0[i + 3] + clipRight.y * varying1[i + 3] + clipRight.z * varying2[i + 3];
            derivativeX[i] -= varying[i];
            derivativeX[i + 1] -= varying[i + 1];
            derivativeX[i + 2] -= varying[i + 2];
            derivativeX[i + 3] -= varying[i + 3];
            derivativeY[i] = clipBottom.x * varying0[i] + clipBottom.y * varying1[i] + clipBottom.z * varying2[i];
            derivativeY[i + 1] = clipBottom.x * varying0[i + 1] + clipBottom.y * varying1[i + 1] + clipBottom.z * varying2[i + 1];
            derivativeY[i + 2] = clipBottom.x * varying0[i + 2] + clipBottom.y * varying1[i + 2] + clipBottom.z * varying2[i + 2];
            derivativeY[i + 3] = clipBottom.x * varying0[i + 3] + clipBottom.y * varying1[i + 3] + clipBottom.z * varying2[i + 3];
            derivativeY[i] -= varying[i];
            derivativeY[i + 1] -= varying[i + 1];
            derivativeY[i + 2] -= varying[i + 2];
            derivativeY[i + 3] -= varying[i + 3];
        }
        for (var i = 0; i < len; i++) {
            var token = this._fragmentDescr.tokens[i];
            ProgramSoftware._opCodeFunc[token.opcode](this._fragmentVO, this._fragmentDescr, token.dest, token.a, token.b, context);
        }
        return this._fragmentVO;
    };
    ProgramSoftware.getDestTarget = function (vo, desc, dest) {
        var target;
        if (dest.regtype == 0x2) {
            target = vo.temp;
        }
        else if (dest.regtype == 0x3) {
            if (desc.header.type == "vertex") {
                target = vo.outputPosition;
            }
            else {
                target = vo.outputColor;
            }
        }
        else if (dest.regtype == 0x4) {
            target = vo.varying;
        }
        return target;
    };
    ProgramSoftware.getSourceTarget = function (vo, desc, dest, context) {
        var target;
        if (dest.regtype == 0x0) {
            target = vo.attributes;
        }
        else if (dest.regtype == 0x1) {
            if (desc.header.type == "vertex") {
                target = context._vertexConstants;
            }
            else {
                target = context._fragmentConstants;
            }
        }
        else if (dest.regtype == 0x2) {
            target = vo.temp;
        }
        else if (dest.regtype == 0x4) {
            target = vo.varying;
        }
        return target;
    };
    ProgramSoftware.mov = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1.swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1.swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1.swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1.swizzle >> 6) & 3)];
    };
    ProgramSoftware.m44 = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg] * source2Target[source2Reg] + source1Target[source1Reg + 1] * source2Target[source2Reg + 1] + source1Target[source1Reg + 2] * source2Target[source2Reg + 2] + source2Target[source2Reg + 3];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg] * source2Target[source2Reg + 4] + source1Target[source1Reg + 1] * source2Target[source2Reg + 5] + source1Target[source1Reg + 2] * source2Target[source2Reg + 6] + source2Target[source2Reg + 7];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg] * source2Target[source2Reg + 8] + source1Target[source1Reg + 1] * source2Target[source2Reg + 9] + source1Target[source1Reg + 2] * source2Target[source2Reg + 10] + source2Target[source2Reg + 11];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg] * source2Target[source2Reg + 12] + source1Target[source1Reg + 1] * source2Target[source2Reg + 13] + source1Target[source1Reg + 2] * source2Target[source2Reg + 14] + source2Target[source2Reg + 15];
    };
    ProgramSoftware.sample = function (vo, desc, context, source1, textureIndex) {
        var texture = context._textures[textureIndex];
        if (texture.isTexture(TextureSoftware))
            return ProgramSoftware.sampleSimpleTexture(vo, desc, context, source1, textureIndex);
        if (texture.isTexture(CubeTextureSoftware))
            return ProgramSoftware.sampleCubeTexture(vo, desc, context, source1, textureIndex);
        throw new _awayjs_core.ArgumentError("Cannot sample provided texture type");
    };
    ProgramSoftware.sampleCubeTexture = function (vo, desc, context, source1, textureIndex) {
        var source1Reg = 4 * source1.regnum;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        // Get the direction vector.
        var x = source1Target[source1Reg + ((source1.swizzle >> 0) & 3)];
        var y = source1Target[source1Reg + ((source1.swizzle >> 2) & 3)];
        var z = source1Target[source1Reg + ((source1.swizzle >> 4) & 3)];
        // Determine which of the 6 cube sides to sample,
        // depending on the largest abs value of the direction vector.
        // Once determined, translate to uv within this side.
        var side = 0;
        var u = 0;
        var v = 0;
        var absx = Math.abs(x);
        var absy = Math.abs(y);
        var absz = Math.abs(z);
        var absmax = Math.max(absx, absy, absz);
        if (absmax == absx) {
            if (x >= 0) {
                side = 0;
                u = 0.5 - 0.5 * (z / x);
                v = 0.5 - 0.5 * (y / x);
            }
            else {
                side = 1;
                u = 0.5 - 0.5 * (z / x);
                v = 0.5 + 0.5 * (y / x);
            }
        }
        else if (absmax == absy) {
            if (y >= 0) {
                side = 2;
                u = 0.5 + 0.5 * (x / y);
                v = 0.5 + 0.5 * (z / y);
            }
            else {
                side = 3;
                u = 0.5 - 0.5 * (x / y);
                v = 0.5 + 0.5 * (z / y);
            }
        }
        else if (absmax == absz) {
            if (z >= 0) {
                side = 4;
                u = 0.5 + 0.5 * (x / z);
                v = 0.5 - 0.5 * (y / z);
            }
            else {
                side = 5;
                u = 0.5 + 0.5 * (x / z);
                v = 0.5 + 0.5 * (y / z);
            }
        }
        var texture = context._textures[textureIndex];
        var state = context._samplerStates[textureIndex] || this._defaultSamplerState;
        var repeat = state.wrap == exports.ContextGLWrapMode.REPEAT;
        var mipmap = state.mipfilter == exports.ContextGLMipFilter.MIPLINEAR;
        // TODO: implement mip mapping?
        if (state.filter == exports.ContextGLTextureFilter.LINEAR)
            return ProgramSoftware.sampleBilinear(u, v, texture.getData(side), texture.size, texture.size, repeat, ProgramSoftware._colorValue0);
        return ProgramSoftware.sampleNearest(u, v, texture.getData(side), texture.size, texture.size, repeat, ProgramSoftware._colorValue0);
    };
    ProgramSoftware.sampleSimpleTexture = function (vo, desc, context, source1, textureIndex) {
        var source1Reg = 4 * source1.regnum;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var u = source1Target[source1Reg + ((source1.swizzle >> 0) & 3)];
        var v = source1Target[source1Reg + ((source1.swizzle >> 2) & 3)];
        if (textureIndex >= context._textures.length || context._textures[textureIndex] == null)
            throw new _awayjs_core.ArgumentError("textureIndex contains no texture");
        var texture = context._textures[textureIndex];
        var state = context._samplerStates[textureIndex] || this._defaultSamplerState;
        var repeat = state.wrap == exports.ContextGLWrapMode.REPEAT;
        var mipmap = state.mipfilter == exports.ContextGLMipFilter.MIPLINEAR;
        if (mipmap && texture.getMipLevelsCount() > 1) {
            var dux = Math.abs(vo.derivativeX[source1Reg + ((source1.swizzle >> 0) & 3)]);
            var dvx = Math.abs(vo.derivativeX[source1Reg + ((source1.swizzle >> 2) & 3)]);
            var duy = Math.abs(vo.derivativeY[source1Reg + ((source1.swizzle >> 0) & 3)]);
            var dvy = Math.abs(vo.derivativeY[source1Reg + ((source1.swizzle >> 2) & 3)]);
            var lambda = Math.log(Math.max(texture.width * Math.sqrt(dux * dux + dvx * dvx), texture.height * Math.sqrt(duy * duy + dvy * dvy))) / Math.LN2;
            if (lambda > 0) {
                var miplevelLow = Math.floor(lambda);
                var miplevelHigh = Math.ceil(lambda);
                var maxmiplevel = Math.log(Math.min(texture.width, texture.height)) / Math.LN2;
                if (miplevelHigh > maxmiplevel)
                    miplevelHigh = maxmiplevel;
                if (miplevelLow > maxmiplevel)
                    miplevelLow = maxmiplevel;
                var mipblend = lambda - Math.floor(lambda);
                var dataLow = texture.getData(miplevelLow);
                var dataLowWidth = texture.width / Math.pow(2, miplevelLow);
                var dataLowHeight = texture.height / Math.pow(2, miplevelLow);
                var dataHigh = texture.getData(miplevelHigh);
                var dataHighWidth = texture.width / Math.pow(2, miplevelHigh);
                var dataHighHeight = texture.height / Math.pow(2, miplevelHigh);
                if (state.filter == exports.ContextGLTextureFilter.LINEAR) {
                    ProgramSoftware.sampleBilinear(u, v, dataLow, dataLowWidth, dataLowHeight, repeat, ProgramSoftware._colorValue0);
                    ProgramSoftware.sampleBilinear(u, v, dataHigh, dataHighWidth, dataHighHeight, repeat, ProgramSoftware._colorValue1);
                }
                else {
                    ProgramSoftware.sampleNearest(u, v, dataLow, dataLowWidth, dataLowHeight, repeat, ProgramSoftware._colorValue0);
                    ProgramSoftware.sampleNearest(u, v, dataHigh, dataHighWidth, dataHighHeight, repeat, ProgramSoftware._colorValue1);
                }
                return ProgramSoftware.interpolateColor(ProgramSoftware._colorValue0, ProgramSoftware._colorValue1, mipblend, ProgramSoftware._colorValue0);
            }
        }
        if (state.filter == exports.ContextGLTextureFilter.LINEAR)
            return ProgramSoftware.sampleBilinear(u, v, texture.getData(0), texture.width, texture.height, repeat, ProgramSoftware._colorValue0);
        return ProgramSoftware.sampleNearest(u, v, texture.getData(0), texture.width, texture.height, repeat, ProgramSoftware._colorValue0);
    };
    ProgramSoftware.sampleNearest = function (u, v, textureData, textureWidth, textureHeight, repeat, output) {
        u *= textureWidth;
        v *= textureHeight;
        if (repeat) {
            u = Math.abs(u % textureWidth);
            v = Math.abs(v % textureHeight);
        }
        else {
            if (u < 0)
                u = 0;
            else if (u > textureWidth - 1)
                u = textureWidth - 1;
            if (v < 0)
                v = 0;
            else if (v > textureHeight - 1)
                v = textureHeight - 1;
        }
        u = Math.floor(u);
        v = Math.floor(v);
        var pos = (u + v * textureWidth) * 4;
        output[0] = textureData[pos] / 255;
        output[1] = textureData[pos + 1] / 255;
        output[2] = textureData[pos + 2] / 255;
        output[3] = textureData[pos + 3] / 255;
        return output;
    };
    ProgramSoftware.sampleBilinear = function (u, v, textureData, textureWidth, textureHeight, repeat, output) {
        var texelSizeX = 1 / textureWidth;
        var texelSizeY = 1 / textureHeight;
        u -= texelSizeX / 2;
        v -= texelSizeY / 2;
        var a = u * textureWidth;
        a = a - Math.floor(a);
        var b = v * textureHeight;
        b = b - Math.floor(b);
        return ProgramSoftware.interpolateColor(ProgramSoftware.interpolateColor(ProgramSoftware.sampleNearest(u, v, textureData, textureWidth, textureHeight, repeat, ProgramSoftware._colorInterpolated0), ProgramSoftware.sampleNearest(u + texelSizeX, v, textureData, textureWidth, textureHeight, repeat, ProgramSoftware._colorValue0), a, ProgramSoftware._colorInterpolated0), ProgramSoftware.interpolateColor(ProgramSoftware.sampleNearest(u, v + texelSizeY, textureData, textureWidth, textureHeight, repeat, ProgramSoftware._colorInterpolated1), ProgramSoftware.sampleNearest(u + texelSizeX, v + texelSizeY, textureData, textureWidth, textureHeight, repeat, ProgramSoftware._colorValue0), a, ProgramSoftware._colorInterpolated1), b, output);
    };
    ProgramSoftware.interpolateColor = function (source, target, a, output) {
        output[0] = source[0] + (target[0] - source[0]) * a;
        output[1] = source[1] + (target[1] - source[1]) * a;
        output[2] = source[2] + (target[2] - source[2]) * a;
        output[3] = source[3] + (target[3] - source[3]) * a;
        return output;
    };
    ProgramSoftware.tex = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var color = ProgramSoftware.sample(vo, desc, context, source1, source2.regnum);
        var mask = dest.mask;
        if (mask & 1)
            target[targetReg] = color[0];
        if (mask & 2)
            target[targetReg + 1] = color[1];
        if (mask & 4)
            target[targetReg + 2] = color[2];
        if (mask & 8)
            target[targetReg + 3] = color[3];
    };
    ProgramSoftware.add = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] + source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
    };
    ProgramSoftware.sub = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] - source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
    };
    ProgramSoftware.mul = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] * source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
    };
    ProgramSoftware.div = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] / source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
    };
    ProgramSoftware.rcp = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = 1 / source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = 1 / source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = 1 / source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = 1 / source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
    };
    ProgramSoftware.min = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        if (mask & 1)
            target[targetReg] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)], source2Target[source2Reg + ((source2Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)], source2Target[source2Reg + ((source2Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)], source2Target[source2Reg + ((source2Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.min(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)], source2Target[source2Reg + ((source2Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.max = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        if (mask & 1)
            target[targetReg] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)], source2Target[source2Reg + ((source2Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)], source2Target[source2Reg + ((source2Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)], source2Target[source2Reg + ((source2Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.max(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)], source2Target[source2Reg + ((source2Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.frc = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)] - Math.floor(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.sqt = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.rsq = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = 1 / Math.sqrt(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.pow = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        if (mask & 1)
            target[targetReg] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)], source2Target[source2Reg + ((source2Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)], source2Target[source2Reg + ((source2Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)], source2Target[source2Reg + ((source2Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.pow(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)], source2Target[source2Reg + ((source2Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.log = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]) / Math.LN2;
        if (mask & 2)
            target[targetReg + 1] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]) / Math.LN2;
        if (mask & 4)
            target[targetReg + 2] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]) / Math.LN2;
        if (mask & 8)
            target[targetReg + 3] = Math.log(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]) / Math.LN2;
    };
    ProgramSoftware.exp = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.exp(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.nrm = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var x = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var y = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var z = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var len = Math.sqrt(x * x + y * y + z * z);
        x /= len;
        y /= len;
        z /= len;
        if (mask & 1)
            target[targetReg] = x;
        if (mask & 2)
            target[targetReg + 1] = y;
        if (mask & 4)
            target[targetReg + 2] = z;
    };
    ProgramSoftware.sin = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.sin(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.cos = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.cos(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.crs = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        if (mask & 1)
            target[targetReg] = source1TargetY * source2TargetZ - source1TargetZ * source2TargetY;
        if (mask & 2)
            target[targetReg + 1] = source1TargetZ * source2TargetX - source1TargetX * source2TargetZ;
        if (mask & 4)
            target[targetReg + 2] = source1TargetX * source2TargetY - source1TargetY * source2TargetX;
    };
    ProgramSoftware.dp3 = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        if (mask & 1)
            target[targetReg] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
        if (mask & 2)
            target[targetReg + 1] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
        if (mask & 4)
            target[targetReg + 2] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
        if (mask & 8)
            target[targetReg + 3] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ;
    };
    ProgramSoftware.dp4 = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
        if (mask & 1)
            target[targetReg] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
        if (mask & 2)
            target[targetReg + 1] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
        if (mask & 4)
            target[targetReg + 2] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
        if (mask & 8)
            target[targetReg + 3] = source1TargetX * source2TargetX + source1TargetY * source2TargetY + source1TargetZ * source2TargetZ + source1TargetW * source2TargetW;
    };
    ProgramSoftware.abs = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]);
        if (mask & 2)
            target[targetReg + 1] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]);
        if (mask & 4)
            target[targetReg + 2] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]);
        if (mask & 8)
            target[targetReg + 3] = Math.abs(source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]);
    };
    ProgramSoftware.neg = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = -source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = -source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = -source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = -source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
    };
    ProgramSoftware.sat = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 0) & 3)]));
        if (mask & 2)
            target[targetReg + 1] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 2) & 3)]));
        if (mask & 4)
            target[targetReg + 2] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 4) & 3)]));
        if (mask & 8)
            target[targetReg + 3] = Math.max(0, Math.min(1, source1Target[source1Reg + ((source1Swizzle >> 6) & 3)]));
    };
    ProgramSoftware.m33 = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg] * source2Target[source2Reg] + source1Target[source1Reg + 1] * source2Target[source2Reg + 1] + source1Target[source1Reg + 2] * source2Target[source2Reg + 2];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg] * source2Target[source2Reg + 4] + source1Target[source1Reg + 1] * source2Target[source2Reg + 5] + source1Target[source1Reg + 2] * source2Target[source2Reg + 6];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg] * source2Target[source2Reg + 8] + source1Target[source1Reg + 1] * source2Target[source2Reg + 9] + source1Target[source1Reg + 2] * source2Target[source2Reg + 10];
    };
    ProgramSoftware.m34 = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var mask = dest.mask;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg] * source2Target[source2Reg] + source1Target[source1Reg + 1] * source2Target[source2Reg + 1] + source1Target[source1Reg + 2] * source2Target[source2Reg + 2] + source2Target[source2Reg + 3];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg] * source2Target[source2Reg + 4] + source1Target[source1Reg + 1] * source2Target[source2Reg + 5] + source1Target[source1Reg + 2] * source2Target[source2Reg + 6] + source2Target[source2Reg + 7];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg] * source2Target[source2Reg + 8] + source1Target[source1Reg + 1] * source2Target[source2Reg + 9] + source1Target[source1Reg + 2] * source2Target[source2Reg + 10] + source2Target[source2Reg + 11];
    };
    ProgramSoftware.ddx = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = vo.derivativeX;
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
    };
    ProgramSoftware.ddy = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var source1Target = vo.derivativeY;
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        if (mask & 1)
            target[targetReg] = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        if (mask & 2)
            target[targetReg + 1] = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        if (mask & 4)
            target[targetReg + 2] = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        if (mask & 8)
            target[targetReg + 3] = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
    };
    ProgramSoftware.sge = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
        if (mask & 1)
            target[targetReg] = source1TargetX >= source2TargetX ? 1 : 0;
        if (mask & 2)
            target[targetReg + 1] = source1TargetY >= source2TargetY ? 1 : 0;
        if (mask & 4)
            target[targetReg + 2] = source1TargetZ >= source2TargetZ ? 1 : 0;
        if (mask & 8)
            target[targetReg + 3] = source1TargetW >= source2TargetW ? 1 : 0;
    };
    ProgramSoftware.slt = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source2.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
        if (mask & 1)
            target[targetReg] = source1TargetX < source2TargetX ? 1 : 0;
        if (mask & 2)
            target[targetReg + 1] = source1TargetY < source2TargetY ? 1 : 0;
        if (mask & 4)
            target[targetReg + 2] = source1TargetZ < source2TargetZ ? 1 : 0;
        if (mask & 8)
            target[targetReg + 3] = source1TargetW < source2TargetW ? 1 : 0;
    };
    ProgramSoftware.seq = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
        if (mask & 1)
            target[targetReg] = source1TargetX == source2TargetX ? 1 : 0;
        if (mask & 2)
            target[targetReg + 1] = source1TargetY == source2TargetY ? 1 : 0;
        if (mask & 4)
            target[targetReg + 2] = source1TargetZ == source2TargetZ ? 1 : 0;
        if (mask & 8)
            target[targetReg + 3] = source1TargetW == source2TargetW ? 1 : 0;
    };
    ProgramSoftware.sne = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var source2Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source2Swizzle = source2.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
        var source2Target = ProgramSoftware.getSourceTarget(vo, desc, source2, context);
        var source2TargetX = source2Target[source2Reg + ((source2Swizzle >> 0) & 3)];
        var source2TargetY = source2Target[source2Reg + ((source2Swizzle >> 2) & 3)];
        var source2TargetZ = source2Target[source2Reg + ((source2Swizzle >> 4) & 3)];
        var source2TargetW = source2Target[source2Reg + ((source2Swizzle >> 6) & 3)];
        if (mask & 1)
            target[targetReg] = source1TargetX != source2TargetX ? 1 : 0;
        if (mask & 2)
            target[targetReg + 1] = source1TargetY != source2TargetY ? 1 : 0;
        if (mask & 4)
            target[targetReg + 2] = source1TargetZ != source2TargetZ ? 1 : 0;
        if (mask & 8)
            target[targetReg + 3] = source1TargetW != source2TargetW ? 1 : 0;
    };
    ProgramSoftware.sgn = function (vo, desc, dest, source1, source2, context) {
        var targetReg = 4 * dest.regnum;
        var source1Reg = 4 * source1.regnum;
        var target = ProgramSoftware.getDestTarget(vo, desc, dest);
        var mask = dest.mask;
        var source1Swizzle = source1.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        var source1TargetY = source1Target[source1Reg + ((source1Swizzle >> 2) & 3)];
        var source1TargetZ = source1Target[source1Reg + ((source1Swizzle >> 4) & 3)];
        var source1TargetW = source1Target[source1Reg + ((source1Swizzle >> 6) & 3)];
        if (mask & 1)
            target[targetReg] = (source1TargetX < 0) ? -1 : (source1TargetX > 0) ? 1 : 0;
        if (mask & 2)
            target[targetReg + 1] = (source1TargetY < 0) ? -1 : (source1TargetY > 0) ? 1 : 0;
        if (mask & 4)
            target[targetReg + 2] = (source1TargetZ < 0) ? -1 : (source1TargetZ > 0) ? 1 : 0;
        if (mask & 8)
            target[targetReg + 3] = (source1TargetW < 0) ? -1 : (source1TargetW > 0) ? 1 : 0;
    };
    ProgramSoftware.kil = function (vo, desc, dest, source1, source2, context) {
        var source1Reg = 4 * source1.regnum;
        var source1Swizzle = source1.swizzle;
        var source1Target = ProgramSoftware.getSourceTarget(vo, desc, source1, context);
        var source1TargetX = source1Target[source1Reg + ((source1Swizzle >> 0) & 3)];
        if (source1TargetX < 0)
            vo.discard = true;
    };
    return ProgramSoftware;
}());
ProgramSoftware._defaultSamplerState = new SoftwareSamplerState();
ProgramSoftware._tokenizer = new AGALTokenizer();
ProgramSoftware._opCodeFunc = [
    ProgramSoftware.mov,
    ProgramSoftware.add,
    ProgramSoftware.sub,
    ProgramSoftware.mul,
    ProgramSoftware.div,
    ProgramSoftware.rcp,
    ProgramSoftware.min,
    ProgramSoftware.max,
    ProgramSoftware.frc,
    ProgramSoftware.sqt,
    ProgramSoftware.rsq,
    ProgramSoftware.pow,
    ProgramSoftware.log,
    ProgramSoftware.exp,
    ProgramSoftware.nrm,
    ProgramSoftware.sin,
    ProgramSoftware.cos,
    ProgramSoftware.crs,
    ProgramSoftware.dp3,
    ProgramSoftware.dp4,
    ProgramSoftware.abs,
    ProgramSoftware.neg,
    ProgramSoftware.sat,
    ProgramSoftware.m33,
    ProgramSoftware.m44,
    ProgramSoftware.m34,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    null,
    ProgramSoftware.kil,
    ProgramSoftware.tex,
    ProgramSoftware.sge,
    ProgramSoftware.slt,
    ProgramSoftware.sgn,
    ProgramSoftware.seq,
    ProgramSoftware.sne
];
ProgramSoftware._colorValue0 = new Float32Array(4);
ProgramSoftware._colorValue1 = new Float32Array(4);
ProgramSoftware._colorInterpolated0 = new Float32Array(4);
ProgramSoftware._colorInterpolated1 = new Float32Array(4);

var BlendModeSoftware = (function () {
    function BlendModeSoftware() {
    }
    BlendModeSoftware.destinationAlpha = function (result, target, dest, source) {
        result[0] = target[0] * dest[3] / 0xFF;
        result[1] = target[1] * dest[3] / 0xFF;
        result[2] = target[2] * dest[3] / 0xFF;
        result[3] = target[3] * dest[3] / 0xFF;
    };
    BlendModeSoftware.destinationColor = function (result, target, dest, source) {
        result[0] = target[0] * dest[0] / 0xFF;
        result[1] = target[1] * dest[1] / 0xFF;
        result[2] = target[2] * dest[2] / 0xFF;
        result[3] = target[3] * dest[3] / 0xFF;
    };
    BlendModeSoftware.one = function (result, target, dest, source) {
        result[0] = target[0];
        result[1] = target[1];
        result[2] = target[2];
        result[3] = target[3];
    };
    BlendModeSoftware.oneMinusDestinationAlpha = function (result, target, dest, source) {
        result[0] = target[0] * (1 - dest[3] / 0xFF);
        result[1] = target[1] * (1 - dest[3] / 0xFF);
        result[2] = target[2] * (1 - dest[3] / 0xFF);
        result[3] = target[3] * (1 - dest[3] / 0xFF);
    };
    BlendModeSoftware.oneMinusDestinationColor = function (result, target, dest, source) {
        result[0] = target[0] * (1 - dest[0] / 0xFF);
        result[1] = target[1] * (1 - dest[1] / 0xFF);
        result[2] = target[2] * (1 - dest[2] / 0xFF);
        result[3] = target[3] * (1 - dest[3] / 0xFF);
    };
    BlendModeSoftware.oneMinusSourceAlpha = function (result, target, dest, source) {
        result[0] = target[0] * (1 - source[3] / 0xFF);
        result[1] = target[1] * (1 - source[3] / 0xFF);
        result[2] = target[2] * (1 - source[3] / 0xFF);
        result[3] = target[3] * (1 - source[3] / 0xFF);
    };
    BlendModeSoftware.oneMinusSourceColor = function (result, target, dest, source) {
        result[0] = target[0] * (1 - source[0] / 0xFF);
        result[1] = target[1] * (1 - source[1] / 0xFF);
        result[2] = target[2] * (1 - source[2] / 0xFF);
        result[3] = target[3] * (1 - source[3] / 0xFF);
    };
    BlendModeSoftware.sourceAlpha = function (result, target, dest, source) {
        result[0] = target[0] * source[3] / 0xFF;
        result[1] = target[1] * source[3] / 0xFF;
        result[2] = target[2] * source[3] / 0xFF;
        result[3] = target[3] * source[3] / 0xFF;
    };
    BlendModeSoftware.sourceColor = function (result, target, dest, source) {
        result[0] = target[0] * source[0] / 0xFF;
        result[1] = target[1] * source[1] / 0xFF;
        result[2] = target[2] * source[2] / 0xFF;
        result[3] = target[3] * source[3] / 0xFF;
    };
    BlendModeSoftware.zero = function (result, target, dest, source) {
    };
    return BlendModeSoftware;
}());

var DepthCompareModeSoftware = (function () {
    function DepthCompareModeSoftware() {
    }
    DepthCompareModeSoftware.always = function (fragDepth, currentDepth) {
        return true;
    };
    DepthCompareModeSoftware.equal = function (fragDepth, currentDepth) {
        return fragDepth == currentDepth;
    };
    DepthCompareModeSoftware.greater = function (fragDepth, currentDepth) {
        return fragDepth > currentDepth;
    };
    DepthCompareModeSoftware.greaterEqual = function (fragDepth, currentDepth) {
        return fragDepth >= currentDepth;
    };
    DepthCompareModeSoftware.less = function (fragDepth, currentDepth) {
        return fragDepth < currentDepth;
    };
    DepthCompareModeSoftware.lessEqual = function (fragDepth, currentDepth) {
        return fragDepth <= currentDepth;
    };
    DepthCompareModeSoftware.never = function (fragDepth, currentDepth) {
        return false;
    };
    DepthCompareModeSoftware.notEqual = function (fragDepth, currentDepth) {
        return fragDepth != currentDepth;
    };
    return DepthCompareModeSoftware;
}());

var ContextSoftware = (function () {
    function ContextSoftware(canvas) {
        this._backBufferRect = new _awayjs_core.Rectangle();
        this._cullingMode = exports.ContextGLTriangleFace.BACK;
        this._blendSource = exports.ContextGLBlendFactor.ONE;
        this._blendDestination = exports.ContextGLBlendFactor.ZERO;
        this._colorMaskR = true;
        this._colorMaskG = true;
        this._colorMaskB = true;
        this._colorMaskA = true;
        this._writeDepth = true;
        this._depthCompareMode = exports.ContextGLCompareMode.LESS;
        this._depthCompareModeSoftware = function (fragDepth, currentDepth) { return void []; };
        this._blendModeSoftware = function (result, dest, source) { return void []; };
        this._screenMatrix = new _awayjs_core.Matrix3D();
        this._frontBufferMatrix = new _awayjs_core.Matrix();
        this._bboxMin = new _awayjs_core.Point();
        this._bboxMax = new _awayjs_core.Point();
        this._clamp = new _awayjs_core.Point();
        this._samplerStates = [];
        this._textures = [];
        this.textureBuffersColor = [];
        this.textureBuffersZ = [];
        this.textureBuffersZClear = [];
        this._vertexBuffers = [];
        this._vertexBufferOffsets = [];
        this._vertexBufferFormats = [];
        this._rgba = new Uint8ClampedArray(4);
        this._source = new Uint8ClampedArray(4);
        this._dest = new Uint8ClampedArray(4);
        this._destComp = new Uint8ClampedArray(4);
        this._sourceComp = new Uint8ClampedArray(4);
        //public static _drawCallback:Function = null;
        this._antialias = 0;
        this._p0 = new _awayjs_core.Vector3D();
        this._p1 = new _awayjs_core.Vector3D();
        this._p2 = new _awayjs_core.Vector3D();
        this._project = new _awayjs_core.Vector3D();
        this._barycentric = new _awayjs_core.Vector3D();
        this._barycentricRight = new _awayjs_core.Vector3D();
        this._barycentricBottom = new _awayjs_core.Vector3D();
        this._canvas = canvas;
        this._backBufferColor = new _awayjs_graphics.BitmapImage2D(100, 100, false, 0, false);
        this._frontBuffer = new _awayjs_graphics.BitmapImage2D(100, 100, false, 0, false);
        this._activeBufferColor = this._backBufferColor;
        var len = 100 * 100;
        var zbufferBytes = new ArrayBuffer(len * 8);
        this._backBufferZ = new Float32Array(zbufferBytes, 0, len);
        this._backBufferZClear = new Float32Array(zbufferBytes, len * 4, len);
        for (var i = 0; i < len; i++)
            this._backBufferZClear[i] = 10000000;
        this._activeBufferZ = this._backBufferZ;
        if (document && document.body) {
            var frontCanvas = this._frontBuffer.getCanvas();
            // TODO: remove software renderToTexture
            frontCanvas.style.position = "absolute";
            document.body.appendChild(frontCanvas);
        }
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.ALWAYS] = DepthCompareModeSoftware.always;
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.EQUAL] = DepthCompareModeSoftware.equal;
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.GREATER] = DepthCompareModeSoftware.greaterEqual;
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.GREATER_EQUAL] = DepthCompareModeSoftware.greater;
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.LESS] = DepthCompareModeSoftware.less;
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.LESS_EQUAL] = DepthCompareModeSoftware.lessEqual;
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.NEVER] = DepthCompareModeSoftware.never;
        this._depthCompareModeSoftware[exports.ContextGLCompareMode.NOT_EQUAL] = DepthCompareModeSoftware.notEqual;
        this._blendModeSoftware[exports.ContextGLBlendFactor.DESTINATION_ALPHA] = BlendModeSoftware.destinationAlpha;
        this._blendModeSoftware[exports.ContextGLBlendFactor.DESTINATION_COLOR] = BlendModeSoftware.destinationColor;
        this._blendModeSoftware[exports.ContextGLBlendFactor.ONE] = BlendModeSoftware.one;
        this._blendModeSoftware[exports.ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA] = BlendModeSoftware.oneMinusDestinationAlpha;
        this._blendModeSoftware[exports.ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR] = BlendModeSoftware.oneMinusDestinationColor;
        this._blendModeSoftware[exports.ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA] = BlendModeSoftware.oneMinusSourceAlpha;
        this._blendModeSoftware[exports.ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR] = BlendModeSoftware.oneMinusSourceColor;
        this._blendModeSoftware[exports.ContextGLBlendFactor.SOURCE_ALPHA] = BlendModeSoftware.sourceAlpha;
        this._blendModeSoftware[exports.ContextGLBlendFactor.SOURCE_COLOR] = BlendModeSoftware.sourceColor;
        this._blendModeSoftware[exports.ContextGLBlendFactor.ZERO] = BlendModeSoftware.zero;
    }
    Object.defineProperty(ContextSoftware.prototype, "pixelRatio", {
        get: function () {
            return 1;
        },
        enumerable: true,
        configurable: true
    });
    ContextSoftware.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
        this._antialias = antiAlias;
        if (this._antialias % 2 != 0)
            this._antialias = Math.floor(this._antialias - 0.5);
        if (this._antialias == 0)
            this._antialias = 1;
        this._frontBuffer._setSize(width, height);
        var backBufferWidth = width * this._antialias;
        var backBufferHeight = height * this._antialias;
        //double buffer for fast clearing
        var len = backBufferWidth * backBufferHeight;
        var zbufferBytes = new ArrayBuffer(len * 8);
        this._backBufferZ = new Float32Array(zbufferBytes, 0, len);
        this._backBufferZClear = new Float32Array(zbufferBytes, len * 4, len);
        for (var i = 0; i < len; i++)
            this._backBufferZClear[i] = 10000000;
        if (this._activeBufferColor == this._backBufferColor)
            this._activeBufferZ = this._backBufferZ;
        this._backBufferRect.width = backBufferWidth;
        this._backBufferRect.height = backBufferHeight;
        this._backBufferColor._setSize(backBufferWidth, backBufferHeight);
        this.activateScreenMatrix(this._backBufferRect.width, this._backBufferRect.height, true);
        this._frontBufferMatrix = new _awayjs_core.Matrix();
        this._frontBufferMatrix.scale(1 / this._antialias, 1 / this._antialias);
    };
    ContextSoftware.prototype.activateScreenMatrix = function (width, height, yflip) {
        var raw = this._screenMatrix._rawData;
        raw[0] = width / 2;
        raw[1] = 0;
        raw[2] = 0;
        raw[3] = 0;
        raw[4] = 0;
        raw[5] = yflip ? -height / 2 : height / 2;
        raw[6] = 0;
        raw[7] = 0;
        raw[8] = 0;
        raw[9] = 0;
        raw[10] = 1;
        raw[11] = 0;
        raw[12] = width / 2;
        raw[13] = height / 2;
        raw[14] = 0;
        raw[15] = 0;
        this._yflip = yflip;
    };
    ContextSoftware.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
        // Create texture buffer and screen matrix if needed.
        var textureBufferColor = this.textureBuffersColor[surfaceSelector];
        if (textureBufferColor == null) {
            // TODO: consider transparency prop
            // TODO: consider fill color prop
            // TODO: consider powerOfTwo prop
            textureBufferColor = this.textureBuffersColor[surfaceSelector] = new _awayjs_graphics.BitmapImage2D(target.width, target.height, false, 0xFFFFFF, true);
            // TODO: transfer the initial image2D data from the texture to the BitmapImage2D object.
            target.uploadFromImage(textureBufferColor);
        }
        else {
            textureBufferColor.fillRect(textureBufferColor.rect, 0xFFFFFF);
        }
        this._activeBufferColor = textureBufferColor;
        this._activeBufferColor.lock();
        var textureBufferZ = this.textureBuffersZ[surfaceSelector];
        var textureBufferZClear = this.textureBuffersZClear[surfaceSelector];
        if (textureBufferZ == null) {
            //double buffer for fast clearing
            var len = target.width * target.height;
            var zbufferBytes = new ArrayBuffer(len * 8);
            textureBufferZ = this.textureBuffersZ[surfaceSelector] = new Float32Array(zbufferBytes, 0, len);
            textureBufferZClear = this.textureBuffersZClear[surfaceSelector] = new Float32Array(zbufferBytes, len * 4, len);
            for (var i = 0; i < len; i++)
                textureBufferZClear[i] = 10000000;
        }
        textureBufferZ.set(textureBufferZClear); //fast memcpy
        this._activeBufferZ = textureBufferZ;
        this.activateScreenMatrix(target.width, target.height, false);
        this._activeTexture = target;
    };
    ContextSoftware.prototype.setRenderToBackBuffer = function () {
        this._activeBufferColor = this._backBufferColor;
        this._activeBufferZ = this._backBufferZ;
        this.activateScreenMatrix(this._backBufferColor.width, this._backBufferColor.height, true);
    };
    ContextSoftware.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
        if (!this._program)
            return;
        // These are place holders for vertex transformation operations.
        // Additional placeholders are for potentially interpolated values generated by near clipping
        // used to avoid trying to draw behind the camera
        var position0 = new Float32Array(4);
        var position1 = new Float32Array(4);
        var position2 = new Float32Array(4);
        var position3 = new Float32Array(4); // potentially interpolated
        var position4 = new Float32Array(4); // potentially interpolated
        var varying0 = new Float32Array(this._program.numVarying * 4);
        var varying1 = new Float32Array(this._program.numVarying * 4);
        var varying2 = new Float32Array(this._program.numVarying * 4);
        var varying3 = new Float32Array(this._program.numVarying * 4); // potentially interpolated
        var varying4 = new Float32Array(this._program.numVarying * 4); // potentially interpolated
        var incomingVertices = new Array(5);
        var outgoingVertices = new Array(4);
        incomingVertices[0] = position1;
        incomingVertices[1] = position2;
        incomingVertices[2] = position0; // notice position0 in index 2
        incomingVertices[3] = position3;
        incomingVertices[4] = position4;
        var incomingVaryings = new Array(5);
        var outgoingVaryings = new Array(4);
        incomingVaryings[0] = varying1;
        incomingVaryings[1] = varying2;
        incomingVaryings[2] = varying0;
        incomingVaryings[3] = varying3;
        incomingVaryings[4] = varying4;
        // Sweep triangles according to culling mode and process thru vertex shader.
        if (this._yflip && this._cullingMode == exports.ContextGLTriangleFace.BACK || !this._yflip && this._cullingMode == exports.ContextGLTriangleFace.FRONT) {
            for (var i = firstIndex; i < numIndices; i += 3) {
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position0, varying0);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position2, varying2);
                this._triangle(incomingVertices, outgoingVertices, incomingVaryings, outgoingVaryings);
            }
        }
        else if (this._yflip && this._cullingMode == exports.ContextGLTriangleFace.FRONT || !this._yflip && this._cullingMode == exports.ContextGLTriangleFace.BACK) {
            for (var i = firstIndex; i < numIndices; i += 3) {
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position0, varying0);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position2, varying2);
                this._triangle(incomingVertices, outgoingVertices, incomingVaryings, outgoingVaryings);
            }
        }
        else if (this._cullingMode == exports.ContextGLTriangleFace.FRONT_AND_BACK || this._cullingMode == exports.ContextGLTriangleFace.NONE) {
            for (var i = firstIndex; i < numIndices; i += 3) {
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position0, varying0);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position2, varying2);
                this._triangle(incomingVertices, outgoingVertices, incomingVaryings, outgoingVaryings);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i], position0, varying0);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 1], position1, varying1);
                this._program.vertex(this, indexBuffer.data[indexBuffer.startOffset + i + 2], position2, varying2);
                this._triangle(incomingVertices, outgoingVertices, incomingVaryings, outgoingVaryings);
            }
        }
        // Transfer buffer data to texture.
        if (this._activeBufferColor != this._backBufferColor) {
            this._activeBufferColor.unlock();
            this._activeTexture.uploadFromImage(this._activeBufferColor);
        }
    };
    ContextSoftware.prototype._triangle = function (incomingVertices, outgoingVertices, incomingVaryings, outgoingVaryings) {
        var numOriginalVerticesInside = 0;
        var numInterpolations = 0;
        var numOutgoingVertices = 0;
        // Check if the vertices are behind the near plane and interpolate
        // new vertices whenever one vertex in a side is in front of the camera AND the other is behind it.
        // Start by considering p0 as the previous vertex.
        var previousVertex = incomingVertices[2]; // p0
        var previousVarying = incomingVaryings[2]; // v0
        var previousVertexIsInside = previousVertex[2] > 0; // z > 0
        if (previousVertexIsInside) {
            outgoingVertices[0] = previousVertex;
            outgoingVaryings[0] = previousVarying;
            numOutgoingVertices++;
            numOriginalVerticesInside++;
        }
        for (var i = 0; i < 3; i++) {
            var currentVertex = incomingVertices[i];
            var currentVarying = incomingVaryings[i];
            // Need interpolation?
            var currentVertexIsInside = currentVertex[2] > 0; // z > 0
            if (currentVertexIsInside != previousVertexIsInside) {
                // Interpolate vertex pair and create a new vertex.
                // z factor
                var dz_current = Math.abs(currentVertex[2]);
                var dz_previous = Math.abs(previousVertex[2]);
                var factorZ = dz_previous / (dz_previous + dz_current);
                this._interpolateVertexPair(factorZ, currentVertex, previousVertex, incomingVertices[3 + numInterpolations]);
                outgoingVertices[numOutgoingVertices] = incomingVertices[3 + numInterpolations];
                this._interpolateVertexPair(factorZ, currentVarying, previousVarying, incomingVaryings[3 + numInterpolations]);
                outgoingVaryings[numOutgoingVertices] = incomingVaryings[3 + numInterpolations];
                numOutgoingVertices++;
                numInterpolations++;
            }
            if (currentVertexIsInside && i != 2) {
                outgoingVertices[numOutgoingVertices] = currentVertex;
                outgoingVaryings[numOutgoingVertices] = currentVarying;
                numOutgoingVertices++;
                numOriginalVerticesInside++;
            }
            previousVertex = currentVertex;
            previousVarying = currentVarying;
            previousVertexIsInside = currentVertexIsInside;
        }
        // Project the resulting vertices as triangles.
        if (numOriginalVerticesInside == 3) {
            this._projectTriangle(incomingVertices[0], incomingVertices[1], incomingVertices[2], incomingVaryings[0], incomingVaryings[1], incomingVaryings[2]);
        }
        else if (numOriginalVerticesInside == 2) {
            this._projectTriangle(outgoingVertices[0], outgoingVertices[1], outgoingVertices[2], outgoingVaryings[0], outgoingVaryings[1], outgoingVaryings[2]);
            this._projectTriangle(outgoingVertices[0], outgoingVertices[2], outgoingVertices[3], outgoingVaryings[0], outgoingVaryings[2], outgoingVaryings[3]);
        }
        else if (numOriginalVerticesInside == 1) {
            this._projectTriangle(outgoingVertices[0], outgoingVertices[1], outgoingVertices[2], outgoingVaryings[0], outgoingVaryings[1], outgoingVaryings[2]);
        }
        // else if (numOriginalVerticesInside == 0) { // full clipping (do nothing)
        // }
    };
    ContextSoftware.prototype._projectTriangle = function (position0, position1, position2, varying0, varying1, varying2) {
        // Wrap the vertex transformed positions in Vector3D objects.
        this._p0.x = position0[0];
        this._p0.y = position0[1];
        this._p0.z = position0[2];
        this._p0.w = position0[3];
        this._p1.x = position1[0];
        this._p1.y = position1[1];
        this._p1.z = position1[2];
        this._p1.w = position1[3];
        this._p2.x = position2[0];
        this._p2.y = position2[1];
        this._p2.z = position2[2];
        this._p2.w = position2[3];
        // Reject any invalid vertices.
        if (this._p0.w == 0 || this._p1.w == 0 || this._p2.w == 0) {
            return;
        } // w = 0 represent direction vectors and we want positions
        if (isNaN(this._p0.x) || isNaN(this._p0.y) || isNaN(this._p0.z) || isNaN(this._p0.w)) {
            return;
        }
        if (isNaN(this._p1.x) || isNaN(this._p1.y) || isNaN(this._p1.z) || isNaN(this._p1.w)) {
            return;
        }
        if (isNaN(this._p2.x) || isNaN(this._p2.y) || isNaN(this._p2.z) || isNaN(this._p2.w)) {
            return;
        }
        // Clip space.
        this._p0.z = this._p0.z * 2 - this._p0.w;
        this._p1.z = this._p1.z * 2 - this._p1.w;
        this._p2.z = this._p2.z * 2 - this._p2.w;
        // Perspective divide.
        this._p0.project();
        this._p1.project();
        this._p2.project();
        // Transform into screen space.
        this._project.x = this._p0.w;
        this._project.y = this._p1.w;
        this._project.z = this._p2.w;
        this._p0.w = 1;
        this._p1.w = 1;
        this._p2.w = 1;
        this._p0 = this._screenMatrix.transformVector(this._p0, this._p0);
        this._p1 = this._screenMatrix.transformVector(this._p1, this._p1);
        this._p2 = this._screenMatrix.transformVector(this._p2, this._p2);
        // Prepare rasterization bounds.
        this._bboxMin.x = 1000000;
        this._bboxMin.y = 1000000;
        this._bboxMax.x = -1000000;
        this._bboxMax.y = -1000000;
        this._clamp.x = this._activeBufferColor.width - 1;
        this._clamp.y = this._activeBufferColor.height - 1;
        this._bboxMin.x = Math.max(0, Math.min(this._bboxMin.x, this._p0.x));
        this._bboxMin.y = Math.max(0, Math.min(this._bboxMin.y, this._p0.y));
        this._bboxMin.x = Math.max(0, Math.min(this._bboxMin.x, this._p1.x));
        this._bboxMin.y = Math.max(0, Math.min(this._bboxMin.y, this._p1.y));
        this._bboxMin.x = Math.max(0, Math.min(this._bboxMin.x, this._p2.x));
        this._bboxMin.y = Math.max(0, Math.min(this._bboxMin.y, this._p2.y));
        this._bboxMax.x = Math.min(this._clamp.x, Math.max(this._bboxMax.x, this._p0.x));
        this._bboxMax.y = Math.min(this._clamp.y, Math.max(this._bboxMax.y, this._p0.y));
        this._bboxMax.x = Math.min(this._clamp.x, Math.max(this._bboxMax.x, this._p1.x));
        this._bboxMax.y = Math.min(this._clamp.y, Math.max(this._bboxMax.y, this._p1.y));
        this._bboxMax.x = Math.min(this._clamp.x, Math.max(this._bboxMax.x, this._p2.x));
        this._bboxMax.y = Math.min(this._clamp.y, Math.max(this._bboxMax.y, this._p2.y));
        this._bboxMin.x = Math.floor(this._bboxMin.x);
        this._bboxMin.y = Math.floor(this._bboxMin.y);
        this._bboxMax.x = Math.floor(this._bboxMax.x);
        this._bboxMax.y = Math.floor(this._bboxMax.y);
        /*
            NOTE:
            'simplified cross' product calculations below are inlined cross product calculations that ignore the z value and just use the output z value.
         */
        // Skip invalid bounds.
        var w = this._bboxMax.x - this._bboxMin.x;
        var h = this._bboxMax.y - this._bboxMin.y;
        if (w <= 0 || h <= 0) {
            return;
        }
        // Calculate the area division for all barycentric coordinates.
        var area = (this._p1.x - this._p0.x) * (this._p2.y - this._p0.y) - (this._p1.y - this._p0.y) * (this._p2.x - this._p0.x); // simplified cross
        if (area < 0) {
            return;
        } // skip null areas.
        // Pre-calculate barycentric x and y derivatives (steps).
        var w0_dx = -(this._p2.y - this._p1.y) / area;
        var w1_dx = -(this._p0.y - this._p2.y) / area;
        var w2_dx = -(this._p1.y - this._p0.y) / area;
        var w0_dy = (this._p2.x - this._p1.x) / area;
        var w1_dy = (this._p0.x - this._p2.x) / area;
        var w2_dy = (this._p1.x - this._p0.x) / area;
        // Calculate top left barycentric coordinate.
        var w0 = ((this._p2.x - this._p1.x) * (this._bboxMin.y - this._p1.y) - (this._p2.y - this._p1.y) * (this._bboxMin.x - this._p1.x)) / area; // simplified cross
        var w1 = ((this._p0.x - this._p2.x) * (this._bboxMin.y - this._p2.y) - (this._p0.y - this._p2.y) * (this._bboxMin.x - this._p2.x)) / area; // simplified cross
        var w2 = ((this._p1.x - this._p0.x) * (this._bboxMin.y - this._p0.y) - (this._p1.y - this._p0.y) * (this._bboxMin.x - this._p0.x)) / area; // simplified cross
        // Rasterize.
        var cx = 0;
        var cy = 0;
        for (var x = this._bboxMin.x; x <= this._bboxMax.x; x++) {
            for (var y = this._bboxMin.y; y <= this._bboxMax.y; y++) {
                // Calculate the barycentric weights of the pixel.
                this._barycentric.x = w0 + w0_dx * cx + w0_dy * cy;
                this._barycentric.y = w1 + w1_dx * cx + w1_dy * cy;
                this._barycentric.z = w2 + w2_dx * cx + w2_dy * cy;
                // Step y.
                cy += 1;
                // Skip pixel if its not inside the triangle.
                if (this._barycentric.x < 0 || this._barycentric.y < 0 || this._barycentric.z < 0)
                    continue;
                // Calculate derivative (neighbor) weights.
                if (x != this._bboxMax.x) {
                    this._barycentricRight.x = this._barycentric.x + w0_dx;
                    this._barycentricRight.y = this._barycentric.y + w1_dx;
                    this._barycentricRight.z = this._barycentric.z + w2_dx;
                    this._barycentricRight.x /= this._project.x;
                    this._barycentricRight.y /= this._project.y;
                    this._barycentricRight.z /= this._project.z;
                    this._barycentricRight.scaleBy(1 / (this._barycentricRight.x + this._barycentricRight.y + this._barycentricRight.z));
                }
                if (y != this._bboxMax.y) {
                    this._barycentricBottom.x = this._barycentric.x + w0_dy;
                    this._barycentricBottom.y = this._barycentric.y + w1_dy;
                    this._barycentricBottom.z = this._barycentric.z + w2_dy;
                    this._barycentricBottom.x /= this._project.x;
                    this._barycentricBottom.y /= this._project.y;
                    this._barycentricBottom.z /= this._project.z;
                    this._barycentricBottom.scaleBy(1 / (this._barycentricBottom.x + this._barycentricBottom.y + this._barycentricBottom.z));
                }
                // Interpolate frag depth.
                var index = (x % this._activeBufferColor.width) + y * this._activeBufferColor.width;
                var fragDepth = (this._barycentric.x * this._p0.z + this._barycentric.y * this._p1.z + this._barycentric.z * this._p2.z) / (this._barycentric.x + this._barycentric.y + this._barycentric.z);
                this._barycentric.x /= this._project.x;
                this._barycentric.y /= this._project.y;
                this._barycentric.z /= this._project.z;
                this._barycentric.scaleBy(1 / (this._barycentric.x + this._barycentric.y + this._barycentric.z));
                // Depth test.
                if (!this._depthCompareModeSoftware[this._depthCompareMode](fragDepth, this._activeBufferZ[index]))
                    continue;
                // Process fragment shader.
                var fragmentVO = this._program.fragment(this, this._barycentric, this._barycentricRight, this._barycentricBottom, varying0, varying1, varying2, fragDepth);
                if (fragmentVO.discard)
                    continue;
                // Write z buffer.
                if (this._writeDepth)
                    this._activeBufferZ[index] = fragDepth; // TODO: fragmentVO.outputDepth?
                // Write to source and transform color space.
                this._source[0] = fragmentVO.outputColor[0] * 0xFF;
                this._source[1] = fragmentVO.outputColor[1] * 0xFF;
                this._source[2] = fragmentVO.outputColor[2] * 0xFF;
                this._source[3] = fragmentVO.outputColor[3] * 0xFF;
                // Read dest.
                this._activeBufferColor.getPixelData(x, y, this._dest);
                // Write to color buffer.
                this._putPixel(x, y);
            }
            // Step x.
            cy = 0;
            cx += 1;
        }
    };
    ContextSoftware.prototype._putPixel = function (x, y) {
        this._blendModeSoftware[this._blendDestination](this._destComp, this._dest, this._dest, this._source);
        this._blendModeSoftware[this._blendSource](this._sourceComp, this._source, this._dest, this._source);
        this._rgba[0] = this._sourceComp[0] + this._destComp[0];
        this._rgba[1] = this._sourceComp[1] + this._destComp[1];
        this._rgba[2] = this._sourceComp[2] + this._destComp[2];
        this._rgba[3] = this._sourceComp[3] + this._destComp[3];
        this._activeBufferColor.setPixelData(x, y, this._rgba);
    };
    ContextSoftware.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
        return new CubeTextureSoftware(size);
    };
    ContextSoftware.prototype.createIndexBuffer = function (numIndices) {
        return new IndexBufferSoftware(numIndices);
    };
    ContextSoftware.prototype.createProgram = function () {
        return new ProgramSoftware();
    };
    ContextSoftware.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
        return new TextureSoftware(width, height);
    };
    ContextSoftware.prototype.createVertexBuffer = function (numVertices, dataPerVertex) {
        return new VertexBufferSoftware(numVertices, dataPerVertex);
    };
    ContextSoftware.prototype.dispose = function () {
    };
    ContextSoftware.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
        this._blendSource = sourceFactor;
        this._blendDestination = destinationFactor;
    };
    ContextSoftware.prototype.setColorMask = function (red, green, blue, alpha) {
        this._colorMaskR = red;
        this._colorMaskG = green;
        this._colorMaskB = blue;
        this._colorMaskA = alpha;
    };
    ContextSoftware.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
        if (triangleFace === void 0) { triangleFace = exports.ContextGLTriangleFace.FRONT_AND_BACK; }
        if (compareMode === void 0) { compareMode = exports.ContextGLCompareMode.ALWAYS; }
        if (actionOnBothPass === void 0) { actionOnBothPass = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthFail === void 0) { actionOnDepthFail = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = exports.ContextGLStencilAction.KEEP; }
        if (coordinateSystem === void 0) { coordinateSystem = _awayjs_core.CoordinateSystem.LEFT_HANDED; }
        //TODO:
    };
    ContextSoftware.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
        //TODO:
    };
    ContextSoftware.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
        //TODO: CoordinateSystem.RIGHT_HAND
        this._cullingMode = triangleFaceToCull;
    };
    ContextSoftware.prototype.setDepthTest = function (depthMask, passCompareMode) {
        this._writeDepth = depthMask;
        this._depthCompareMode = passCompareMode;
    };
    ContextSoftware.prototype.setProgram = function (program) {
        this._program = program;
    };
    ContextSoftware.prototype.setProgramConstantsFromArray = function (programType, data) {
        var target;
        if (programType == exports.ContextGLProgramType.VERTEX)
            target = this._vertexConstants = new Float32Array(data.length);
        else if (programType == exports.ContextGLProgramType.FRAGMENT)
            target = this._fragmentConstants = new Float32Array(data.length);
        target.set(data);
    };
    ContextSoftware.prototype.setTextureAt = function (sampler, texture) {
        this._textures[sampler] = texture;
    };
    ContextSoftware.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
        this._vertexBuffers[index] = buffer;
        this._vertexBufferOffsets[index] = bufferOffset;
        this._vertexBufferFormats[index] = format;
    };
    ContextSoftware.prototype.present = function () {
        this._backBufferColor.unlock();
        this._frontBuffer.fillRect(this._frontBuffer.rect, 0);
        this._frontBuffer.draw(this._backBufferColor, this._frontBufferMatrix);
    };
    ContextSoftware.prototype.drawToBitmapImage2D = function (destination) {
        destination.setPixels(this._activeBufferColor.rect, this._activeBufferColor.getImageData().data);
    };
    ContextSoftware.prototype._interpolateVertexPair = function (factor, v0, v1, result) {
        for (var i = 0; i < v0.length; i++) {
            var delta = v0[i] - v1[i];
            result[i] = v1[i] + delta * factor;
        }
    };
    ContextSoftware.prototype.clamp = function (value, min, max) {
        if (min === void 0) { min = 0; }
        if (max === void 0) { max = 1; }
        return Math.max(min, Math.min(value, max));
    };
    ContextSoftware.prototype.interpolate = function (min, max, gradient) {
        return min + (max - min) * this.clamp(gradient);
    };
    ContextSoftware.prototype.drawVertices = function (mode, firstVertex, numVertices) {
        //TODO:
    };
    ContextSoftware.prototype.setScissorRectangle = function (rectangle) {
        //TODO:
    };
    ContextSoftware.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
        var state = this._samplerStates[sampler];
        if (!state)
            state = this._samplerStates[sampler] = new SoftwareSamplerState();
        state.wrap = wrap;
        state.filter = filter;
        state.mipfilter = mipfilter;
    };
    ContextSoftware.prototype.enableStencil = function () {
    };
    ContextSoftware.prototype.disableStencil = function () {
    };
    Object.defineProperty(ContextSoftware.prototype, "frontBuffer", {
        get: function () {
            return this._frontBuffer;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextSoftware.prototype, "container", {
        get: function () {
            return this._canvas;
        },
        enumerable: true,
        configurable: true
    });
    ContextSoftware.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
        if (red === void 0) { red = 0; }
        if (green === void 0) { green = 0; }
        if (blue === void 0) { blue = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (depth === void 0) { depth = 1; }
        if (stencil === void 0) { stencil = 0; }
        if (mask === void 0) { mask = exports.ContextGLClearMask.ALL; }
        this._backBufferColor.lock();
        if (mask & exports.ContextGLClearMask.COLOR)
            this._backBufferColor.fillRect(this._backBufferRect, _awayjs_core.ColorUtils.ARGBtoFloat32(alpha * 0xFF, red * 0xFF, green * 0xFF, blue * 0xFF));
        //TODO: mask & ContextGLClearMask.STENCIL
        if (mask & exports.ContextGLClearMask.DEPTH)
            this._backBufferZ.set(this._backBufferZClear); //fast memcpy
    };
    return ContextSoftware;
}());
ContextSoftware.MAX_SAMPLERS = 8;

var TextureBaseWebGL = (function () {
    function TextureBaseWebGL(gl) {
        this.textureType = "";
        this._gl = gl;
    }
    TextureBaseWebGL.prototype.dispose = function () {
        this._gl.deleteTexture(this._glTexture);
    };
    Object.defineProperty(TextureBaseWebGL.prototype, "glTexture", {
        get: function () {
            return this._glTexture;
        },
        enumerable: true,
        configurable: true
    });
    TextureBaseWebGL.prototype.generateMipmaps = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    return TextureBaseWebGL;
}());

var CubeTextureWebGL = (function (_super) {
    __extends(CubeTextureWebGL, _super);
    function CubeTextureWebGL(gl, size) {
        var _this = _super.call(this, gl) || this;
        _this._textureSelectorDictionary = new Array(6);
        _this.textureType = "textureCube";
        _this._size = size;
        _this._glTexture = _this._gl.createTexture();
        _this._textureSelectorDictionary[0] = gl.TEXTURE_CUBE_MAP_POSITIVE_X;
        _this._textureSelectorDictionary[1] = gl.TEXTURE_CUBE_MAP_NEGATIVE_X;
        _this._textureSelectorDictionary[2] = gl.TEXTURE_CUBE_MAP_POSITIVE_Y;
        _this._textureSelectorDictionary[3] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Y;
        _this._textureSelectorDictionary[4] = gl.TEXTURE_CUBE_MAP_POSITIVE_Z;
        _this._textureSelectorDictionary[5] = gl.TEXTURE_CUBE_MAP_NEGATIVE_Z;
        return _this;
    }
    CubeTextureWebGL.prototype.uploadFromImage = function (imageCube, side, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._glTexture);
        this._gl.texImage2D(this._textureSelectorDictionary[side], miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, imageCube.getImageData(side));
        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, null);
    };
    CubeTextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        if (async === void 0) { async = false; }
    };
    Object.defineProperty(CubeTextureWebGL.prototype, "size", {
        get: function () {
            return this._size;
        },
        enumerable: true,
        configurable: true
    });
    CubeTextureWebGL.prototype.generateMipmaps = function () {
        this._gl.bindTexture(this._gl.TEXTURE_CUBE_MAP, this._glTexture);
        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
        //this._gl.bindTexture( this._gl.TEXTURE_CUBE_MAP, null );
    };
    return CubeTextureWebGL;
}(TextureBaseWebGL));

var IndexBufferWebGL = (function () {
    function IndexBufferWebGL(gl, numIndices) {
        this._gl = gl;
        this._buffer = this._gl.createBuffer();
        this._numIndices = numIndices;
    }
    IndexBufferWebGL.prototype.uploadFromArray = function (data, startOffset, count) {
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
        if (startOffset)
            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset * 2, new Uint16Array(data));
        else
            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(data), this._gl.STATIC_DRAW);
    };
    IndexBufferWebGL.prototype.uploadFromByteArray = function (data, startOffset, count) {
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, this._buffer);
        if (startOffset)
            this._gl.bufferSubData(this._gl.ELEMENT_ARRAY_BUFFER, startOffset * 2, data);
        else
            this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
    };
    IndexBufferWebGL.prototype.dispose = function () {
        this._gl.deleteBuffer(this._buffer);
    };
    Object.defineProperty(IndexBufferWebGL.prototype, "numIndices", {
        get: function () {
            return this._numIndices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(IndexBufferWebGL.prototype, "glBuffer", {
        get: function () {
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    return IndexBufferWebGL;
}());

var ProgramWebGL = (function () {
    function ProgramWebGL(gl) {
        this._uniforms = [[], [], []];
        this._attribs = [];
        this._gl = gl;
        this._program = this._gl.createProgram();
    }
    ProgramWebGL.prototype.upload = function (vertexProgram, fragmentProgram) {
        //detect whether highp can be used
        var vertexPrecision = (this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT).precision != 0) ? "highp" : "mediump";
        var fragmentPrecision = (this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT).precision != 0) ? "highp" : "mediump";
        var vertexString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(vertexProgram), vertexPrecision);
        var fragmentString = ProgramWebGL._aglslParser.parse(ProgramWebGL._tokenizer.decribeAGALByteArray(fragmentProgram), fragmentPrecision);
        this._vertexShader = this._gl.createShader(this._gl.VERTEX_SHADER);
        this._fragmentShader = this._gl.createShader(this._gl.FRAGMENT_SHADER);
        this._gl.shaderSource(this._vertexShader, vertexString);
        this._gl.compileShader(this._vertexShader);
        if (!this._gl.getShaderParameter(this._vertexShader, this._gl.COMPILE_STATUS))
            throw new Error(this._gl.getShaderInfoLog(this._vertexShader));
        this._gl.shaderSource(this._fragmentShader, fragmentString);
        this._gl.compileShader(this._fragmentShader);
        if (!this._gl.getShaderParameter(this._fragmentShader, this._gl.COMPILE_STATUS))
            throw new Error(this._gl.getShaderInfoLog(this._fragmentShader));
        this._gl.attachShader(this._program, this._vertexShader);
        this._gl.attachShader(this._program, this._fragmentShader);
        this._gl.linkProgram(this._program);
        if (!this._gl.getProgramParameter(this._program, this._gl.LINK_STATUS))
            throw new Error(this._gl.getProgramInfoLog(this._program));
        this._uniforms[0].length = 0;
        this._uniforms[1].length = 0;
        this._uniforms[2].length = 0;
        this._attribs.length = 0;
    };
    ProgramWebGL.prototype.getUniformLocation = function (programType, index) {
        if (index === void 0) { index = -1; }
        if (this._uniforms[programType][index + 1] != null)
            return this._uniforms[programType][index + 1];
        var name = (index == -1) ? ProgramWebGL._uniformLocationNameDictionary[programType] : ProgramWebGL._uniformLocationNameDictionary[programType] + index;
        return (this._uniforms[programType][index + 1] = this._gl.getUniformLocation(this._program, name));
    };
    //
    // public getUniformLocation(programType:number, index:number):WebGLUniformLocation
    // {
    // 	if (this._uniforms[programType][index] != null)
    // 		return this._uniforms[programType][index];
    //
    // 	return (this._uniforms[programType][index] = this._gl.getUniformLocation(this._program, ProgramWebGL._uniformLocationNameDictionary[programType] + index));
    // }
    ProgramWebGL.prototype.getAttribLocation = function (index) {
        if (this._attribs[index] != null)
            return this._attribs[index];
        return (this._attribs[index] = this._gl.getAttribLocation(this._program, "va" + index));
    };
    ProgramWebGL.prototype.dispose = function () {
        this._gl.deleteProgram(this._program);
    };
    ProgramWebGL.prototype.focusProgram = function () {
        this._gl.useProgram(this._program);
    };
    Object.defineProperty(ProgramWebGL.prototype, "glProgram", {
        get: function () {
            return this._program;
        },
        enumerable: true,
        configurable: true
    });
    return ProgramWebGL;
}());
ProgramWebGL._tokenizer = new AGALTokenizer();
ProgramWebGL._aglslParser = new AGLSLParser();
ProgramWebGL._uniformLocationNameDictionary = ["fc", "fs", "vc"];

var TextureWebGL = (function (_super) {
    __extends(TextureWebGL, _super);
    function TextureWebGL(gl, width, height) {
        var _this = _super.call(this, gl) || this;
        _this.textureType = "texture2d";
        _this._width = width;
        _this._height = height;
        _this._glTexture = _this._gl.createTexture();
        return _this;
    }
    Object.defineProperty(TextureWebGL.prototype, "width", {
        get: function () {
            return this._width;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureWebGL.prototype, "height", {
        get: function () {
            return this._height;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(TextureWebGL.prototype, "frameBuffer", {
        get: function () {
            if (!this._frameBuffer) {
                this._frameBuffer = this._gl.createFramebuffer();
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, this._frameBuffer);
                this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
                this._gl.texImage2D(this._gl.TEXTURE_2D, 0, this._gl.RGBA, this._width, this._height, 0, this._gl.RGBA, this._gl.UNSIGNED_BYTE, null);
                var renderBuffer = this._gl.createRenderbuffer();
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, renderBuffer);
                this._gl.renderbufferStorage(this._gl.RENDERBUFFER, this._gl.DEPTH_STENCIL, this._width, this._height);
                this._gl.framebufferTexture2D(this._gl.FRAMEBUFFER, this._gl.COLOR_ATTACHMENT0, this._gl.TEXTURE_2D, this._glTexture, 0);
                this._gl.framebufferRenderbuffer(this._gl.FRAMEBUFFER, this._gl.DEPTH_STENCIL_ATTACHMENT, this._gl.RENDERBUFFER, renderBuffer);
                this._gl.bindTexture(this._gl.TEXTURE_2D, null);
                this._gl.bindRenderbuffer(this._gl.RENDERBUFFER, null);
                this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
            }
            return this._frameBuffer;
        },
        enumerable: true,
        configurable: true
    });
    TextureWebGL.prototype.uploadFromImage = function (imageData, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
        this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, imageData.getImageData());
        this._gl.bindTexture(this._gl.TEXTURE_2D, null);
    };
    TextureWebGL.prototype.uploadFromURL = function (urlRequest, miplevel) {
        if (miplevel === void 0) { miplevel = 0; }
        //dummy code for testing
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
        this._gl.texImage2D(this._gl.TEXTURE_2D, miplevel, this._gl.RGBA, this._gl.RGBA, this._gl.UNSIGNED_BYTE, _awayjs_graphics.DefaultMaterialManager.getDefaultImage2D().getImageData());
        this._gl.bindTexture(this._gl.TEXTURE_2D, null);
    };
    TextureWebGL.prototype.uploadCompressedTextureFromByteArray = function (data, byteArrayOffset /*uint*/, async) {
        if (async === void 0) { async = false; }
        var ext = this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
        //this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this)
    };
    TextureWebGL.prototype.generateMipmaps = function () {
        this._gl.bindTexture(this._gl.TEXTURE_2D, this._glTexture);
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
        //this._gl.bindTexture( this._gl.TEXTURE_2D, null );
    };
    return TextureWebGL;
}(TextureBaseWebGL));

var VertexBufferWebGL = (function () {
    function VertexBufferWebGL(gl, numVertices, dataPerVertex) {
        this._gl = gl;
        this._buffer = this._gl.createBuffer();
        this._numVertices = numVertices;
        this._dataPerVertex = dataPerVertex;
    }
    VertexBufferWebGL.prototype.uploadFromArray = function (vertices, startVertex, numVertices) {
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
        if (startVertex)
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex * this._dataPerVertex, new Float32Array(vertices));
        else
            this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(vertices), this._gl.STATIC_DRAW);
    };
    VertexBufferWebGL.prototype.uploadFromByteArray = function (data, startVertex, numVertices) {
        this._gl.bindBuffer(this._gl.ARRAY_BUFFER, this._buffer);
        if (startVertex)
            this._gl.bufferSubData(this._gl.ARRAY_BUFFER, startVertex * this._dataPerVertex, data);
        else
            this._gl.bufferData(this._gl.ARRAY_BUFFER, data, this._gl.STATIC_DRAW);
    };
    Object.defineProperty(VertexBufferWebGL.prototype, "numVertices", {
        get: function () {
            return this._numVertices;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferWebGL.prototype, "dataPerVertex", {
        get: function () {
            return this._dataPerVertex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(VertexBufferWebGL.prototype, "glBuffer", {
        get: function () {
            return this._buffer;
        },
        enumerable: true,
        configurable: true
    });
    VertexBufferWebGL.prototype.dispose = function () {
        this._gl.deleteBuffer(this._buffer);
    };
    return VertexBufferWebGL;
}());

var ContextWebGL = (function () {
    function ContextWebGL(canvas) {
        this._blendFactorDictionary = new Object();
        this._drawModeDictionary = new Object();
        this._compareModeDictionary = new Object();
        this._stencilActionDictionary = new Object();
        this._textureIndexDictionary = new Array(8);
        this._textureTypeDictionary = new Object();
        this._wrapDictionary = new Object();
        this._filterDictionary = new Object();
        this._mipmapFilterDictionary = new Object();
        this._vertexBufferPropertiesDictionary = [];
        this._drawing = true;
        this._samplerStates = new Array(8);
        this._stencilReferenceValue = 0;
        this._stencilReadMask = 0xff;
        this._separateStencil = false;
        this._container = canvas;
        var props = {
            premultipliedAlpha: false,
            alpha: false,
            stencil: true
        };
        try {
            this._gl = canvas.getContext("experimental-webgl", props);
            if (!this._gl)
                this._gl = canvas.getContext("webgl", props);
        }
        catch (e) {
        }
        if (this._gl) {
            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_SUCCESS ) );
            if (this._gl.getExtension("OES_standard_derivatives")) {
                this._standardDerivatives = true;
            }
            else {
                this._standardDerivatives = false;
            }
            //setup shortcut dictionaries
            this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE] = this._gl.ONE;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.DESTINATION_ALPHA] = this._gl.DST_ALPHA;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.DESTINATION_COLOR] = this._gl.DST_COLOR;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE] = this._gl.ONE;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_DESTINATION_ALPHA] = this._gl.ONE_MINUS_DST_ALPHA;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_DESTINATION_COLOR] = this._gl.ONE_MINUS_DST_COLOR;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA] = this._gl.ONE_MINUS_SRC_ALPHA;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.ONE_MINUS_SOURCE_COLOR] = this._gl.ONE_MINUS_SRC_COLOR;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.SOURCE_ALPHA] = this._gl.SRC_ALPHA;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.SOURCE_COLOR] = this._gl.SRC_COLOR;
            this._blendFactorDictionary[exports.ContextGLBlendFactor.ZERO] = this._gl.ZERO;
            this._drawModeDictionary[exports.ContextGLDrawMode.LINES] = this._gl.LINES;
            this._drawModeDictionary[exports.ContextGLDrawMode.TRIANGLES] = this._gl.TRIANGLES;
            this._compareModeDictionary[exports.ContextGLCompareMode.ALWAYS] = this._gl.ALWAYS;
            this._compareModeDictionary[exports.ContextGLCompareMode.EQUAL] = this._gl.EQUAL;
            this._compareModeDictionary[exports.ContextGLCompareMode.GREATER] = this._gl.GREATER;
            this._compareModeDictionary[exports.ContextGLCompareMode.GREATER_EQUAL] = this._gl.GEQUAL;
            this._compareModeDictionary[exports.ContextGLCompareMode.LESS] = this._gl.LESS;
            this._compareModeDictionary[exports.ContextGLCompareMode.LESS_EQUAL] = this._gl.LEQUAL;
            this._compareModeDictionary[exports.ContextGLCompareMode.NEVER] = this._gl.NEVER;
            this._compareModeDictionary[exports.ContextGLCompareMode.NOT_EQUAL] = this._gl.NOTEQUAL;
            this._stencilActionDictionary[exports.ContextGLStencilAction.DECREMENT_SATURATE] = this._gl.DECR;
            this._stencilActionDictionary[exports.ContextGLStencilAction.DECREMENT_WRAP] = this._gl.DECR_WRAP;
            this._stencilActionDictionary[exports.ContextGLStencilAction.INCREMENT_SATURATE] = this._gl.INCR;
            this._stencilActionDictionary[exports.ContextGLStencilAction.INCREMENT_WRAP] = this._gl.INCR_WRAP;
            this._stencilActionDictionary[exports.ContextGLStencilAction.INVERT] = this._gl.INVERT;
            this._stencilActionDictionary[exports.ContextGLStencilAction.KEEP] = this._gl.KEEP;
            this._stencilActionDictionary[exports.ContextGLStencilAction.SET] = this._gl.REPLACE;
            this._stencilActionDictionary[exports.ContextGLStencilAction.ZERO] = this._gl.ZERO;
            this._textureIndexDictionary[0] = this._gl.TEXTURE0;
            this._textureIndexDictionary[1] = this._gl.TEXTURE1;
            this._textureIndexDictionary[2] = this._gl.TEXTURE2;
            this._textureIndexDictionary[3] = this._gl.TEXTURE3;
            this._textureIndexDictionary[4] = this._gl.TEXTURE4;
            this._textureIndexDictionary[5] = this._gl.TEXTURE5;
            this._textureIndexDictionary[6] = this._gl.TEXTURE6;
            this._textureIndexDictionary[7] = this._gl.TEXTURE7;
            this._textureTypeDictionary["texture2d"] = this._gl.TEXTURE_2D;
            this._textureTypeDictionary["textureCube"] = this._gl.TEXTURE_CUBE_MAP;
            this._wrapDictionary[exports.ContextGLWrapMode.REPEAT] = this._gl.REPEAT;
            this._wrapDictionary[exports.ContextGLWrapMode.CLAMP] = this._gl.CLAMP_TO_EDGE;
            this._filterDictionary[exports.ContextGLTextureFilter.LINEAR] = this._gl.LINEAR;
            this._filterDictionary[exports.ContextGLTextureFilter.NEAREST] = this._gl.NEAREST;
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR] = new Object();
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR][exports.ContextGLMipFilter.MIPNEAREST] = this._gl.LINEAR_MIPMAP_NEAREST;
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR][exports.ContextGLMipFilter.MIPLINEAR] = this._gl.LINEAR_MIPMAP_LINEAR;
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.LINEAR][exports.ContextGLMipFilter.MIPNONE] = this._gl.LINEAR;
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST] = new Object();
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST][exports.ContextGLMipFilter.MIPNEAREST] = this._gl.NEAREST_MIPMAP_NEAREST;
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST][exports.ContextGLMipFilter.MIPLINEAR] = this._gl.NEAREST_MIPMAP_LINEAR;
            this._mipmapFilterDictionary[exports.ContextGLTextureFilter.NEAREST][exports.ContextGLMipFilter.MIPNONE] = this._gl.NEAREST;
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.FLOAT_1] = new VertexBufferProperties$1(1, this._gl.FLOAT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.FLOAT_2] = new VertexBufferProperties$1(2, this._gl.FLOAT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.FLOAT_3] = new VertexBufferProperties$1(3, this._gl.FLOAT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.FLOAT_4] = new VertexBufferProperties$1(4, this._gl.FLOAT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.BYTE_1] = new VertexBufferProperties$1(1, this._gl.BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.BYTE_2] = new VertexBufferProperties$1(2, this._gl.BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.BYTE_3] = new VertexBufferProperties$1(3, this._gl.BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.BYTE_4] = new VertexBufferProperties$1(4, this._gl.BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_1] = new VertexBufferProperties$1(1, this._gl.UNSIGNED_BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_2] = new VertexBufferProperties$1(2, this._gl.UNSIGNED_BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_3] = new VertexBufferProperties$1(3, this._gl.UNSIGNED_BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_4] = new VertexBufferProperties$1(4, this._gl.UNSIGNED_BYTE, true);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.SHORT_1] = new VertexBufferProperties$1(1, this._gl.SHORT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.SHORT_2] = new VertexBufferProperties$1(2, this._gl.SHORT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.SHORT_3] = new VertexBufferProperties$1(3, this._gl.SHORT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.SHORT_4] = new VertexBufferProperties$1(4, this._gl.SHORT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_1] = new VertexBufferProperties$1(1, this._gl.UNSIGNED_SHORT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_2] = new VertexBufferProperties$1(2, this._gl.UNSIGNED_SHORT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_3] = new VertexBufferProperties$1(3, this._gl.UNSIGNED_SHORT, false);
            this._vertexBufferPropertiesDictionary[exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_4] = new VertexBufferProperties$1(4, this._gl.UNSIGNED_SHORT, false);
            this._stencilCompareMode = this._gl.ALWAYS;
            this._stencilCompareModeBack = this._gl.ALWAYS;
            this._stencilCompareModeFront = this._gl.ALWAYS;
            var dpr = window.devicePixelRatio || 1;
            var bsr = this._gl["webkitBackingStorePixelRatio"] ||
                this._gl["mozBackingStorePixelRatio"] ||
                this._gl["msBackingStorePixelRatio"] ||
                this._gl["oBackingStorePixelRatio"] ||
                this._gl["backingStorePixelRatio"] || 1;
            this._pixelRatio = dpr / bsr;
        }
        else {
            //this.dispatchEvent( new away.events.AwayEvent( away.events.AwayEvent.INITIALIZE_FAILED, e ) );
            alert("WebGL is not available.");
        }
        //defaults
        for (var i = 0; i < ContextWebGL.MAX_SAMPLERS; ++i) {
            this._samplerStates[i] = new SamplerState();
            this._samplerStates[i].wrap = this._gl.REPEAT;
            this._samplerStates[i].filter = this._gl.LINEAR;
            this._samplerStates[i].mipfilter = this._gl.LINEAR;
        }
    }
    Object.defineProperty(ContextWebGL.prototype, "pixelRatio", {
        get: function () {
            return this._pixelRatio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextWebGL.prototype, "container", {
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ContextWebGL.prototype, "standardDerivatives", {
        get: function () {
            return this._standardDerivatives;
        },
        enumerable: true,
        configurable: true
    });
    ContextWebGL.prototype.gl = function () {
        return this._gl;
    };
    ContextWebGL.prototype.clear = function (red, green, blue, alpha, depth, stencil, mask) {
        if (red === void 0) { red = 0; }
        if (green === void 0) { green = 0; }
        if (blue === void 0) { blue = 0; }
        if (alpha === void 0) { alpha = 1; }
        if (depth === void 0) { depth = 1; }
        if (stencil === void 0) { stencil = 0; }
        if (mask === void 0) { mask = exports.ContextGLClearMask.ALL; }
        if (!this._drawing) {
            this.updateBlendStatus();
            this._drawing = true;
        }
        var glmask = 0;
        if (mask & exports.ContextGLClearMask.COLOR)
            glmask |= this._gl.COLOR_BUFFER_BIT;
        if (mask & exports.ContextGLClearMask.STENCIL)
            glmask |= this._gl.STENCIL_BUFFER_BIT;
        if (mask & exports.ContextGLClearMask.DEPTH)
            glmask |= this._gl.DEPTH_BUFFER_BIT;
        this._gl.clearColor(red, green, blue, alpha);
        this._gl.clearDepth(depth);
        this._gl.clearStencil(stencil);
        this._gl.clear(glmask);
    };
    ContextWebGL.prototype.configureBackBuffer = function (width, height, antiAlias, enableDepthAndStencil) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = true; }
        this._width = width * this._pixelRatio;
        this._height = height * this._pixelRatio;
        if (enableDepthAndStencil) {
            this._gl.enable(this._gl.STENCIL_TEST);
            this._gl.enable(this._gl.DEPTH_TEST);
        }
        this._gl.viewport['width'] = this._width;
        this._gl.viewport['height'] = this._height;
        this._gl.viewport(0, 0, this._width, this._height);
    };
    ContextWebGL.prototype.createCubeTexture = function (size, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        return new CubeTextureWebGL(this._gl, size);
    };
    ContextWebGL.prototype.createIndexBuffer = function (numIndices) {
        return new IndexBufferWebGL(this._gl, numIndices);
    };
    ContextWebGL.prototype.createProgram = function () {
        return new ProgramWebGL(this._gl);
    };
    ContextWebGL.prototype.createTexture = function (width, height, format, optimizeForRenderToTexture, streamingLevels) {
        if (streamingLevels === void 0) { streamingLevels = 0; }
        //TODO streaming
        return new TextureWebGL(this._gl, width, height);
    };
    ContextWebGL.prototype.createVertexBuffer = function (numVertices, dataPerVertex) {
        return new VertexBufferWebGL(this._gl, numVertices, dataPerVertex);
    };
    ContextWebGL.prototype.dispose = function () {
        for (var i = 0; i < this._samplerStates.length; ++i)
            this._samplerStates[i] = null;
    };
    ContextWebGL.prototype.drawToBitmapImage2D = function (destination) {
        var pixels = new Uint8Array(destination.width * destination.height * 4);
        this._gl.readPixels(0, 0, destination.width, destination.height, this._gl.RGBA, this._gl.UNSIGNED_BYTE, pixels);
        var dummy = new _awayjs_graphics.BitmapImage2D(destination.width, destination.height, true, 0x0, false);
        dummy.setPixels(new _awayjs_core.Rectangle(0, 0, destination.width, destination.height), new Uint8ClampedArray(pixels.buffer));
        destination.draw(dummy);
    };
    ContextWebGL.prototype.drawIndices = function (mode, indexBuffer, firstIndex, numIndices) {
        if (firstIndex === void 0) { firstIndex = 0; }
        if (numIndices === void 0) { numIndices = -1; }
        if (!this._drawing)
            throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
        this._gl.bindBuffer(this._gl.ELEMENT_ARRAY_BUFFER, indexBuffer.glBuffer);
        // Note: The 2 code options below are for #1 production and #2 debugging. Pick one and comment the other.
        // #1
        this._gl.drawElements(this._drawModeDictionary[mode], (numIndices == -1) ? indexBuffer.numIndices : numIndices, this._gl.UNSIGNED_SHORT, firstIndex * 2);
        // #2
        // for (var i:number = 0; i < numIndices; i+=3) {
        // 	this._gl.drawElements(this._gl.LINE_LOOP, 3, this._gl.UNSIGNED_SHORT, (firstIndex+i)*2);
        // }
    };
    ContextWebGL.prototype.drawVertices = function (mode, firstVertex, numVertices) {
        if (firstVertex === void 0) { firstVertex = 0; }
        if (numVertices === void 0) { numVertices = -1; }
        if (!this._drawing)
            throw "Need to clear before drawing if the buffer has not been cleared since the last present() call.";
        //DEBUG: draws triangle outlines
        // for (var i:number = 0; i < numVertices; i+=3) {
        // 	this._gl.drawArrays(this._gl.LINE_LOOP, firstVertex+i, 3);
        // }
        // todo: this check should not be needed.
        // for now it is here to prevent ugly gpu warnings when trying to render numVertices=0
        if (numVertices == 0)
            return;
        this._gl.drawArrays(this._drawModeDictionary[mode], firstVertex, numVertices);
    };
    ContextWebGL.prototype.present = function () {
        //this._drawing = false;
    };
    ContextWebGL.prototype.setBlendFactors = function (sourceFactor, destinationFactor) {
        this._blendEnabled = true;
        this._blendSourceFactor = this._blendFactorDictionary[sourceFactor];
        this._blendDestinationFactor = this._blendFactorDictionary[destinationFactor];
        this.updateBlendStatus();
    };
    ContextWebGL.prototype.setColorMask = function (red, green, blue, alpha) {
        this._gl.colorMask(red, green, blue, alpha);
    };
    ContextWebGL.prototype.setCulling = function (triangleFaceToCull, coordinateSystem) {
        if (coordinateSystem === void 0) { coordinateSystem = _awayjs_core.CoordinateSystem.LEFT_HANDED; }
        if (triangleFaceToCull == exports.ContextGLTriangleFace.NONE) {
            this._gl.disable(this._gl.CULL_FACE);
        }
        else {
            this._gl.enable(this._gl.CULL_FACE);
            this._gl.cullFace(this.translateTriangleFace(triangleFaceToCull, coordinateSystem));
        }
    };
    // TODO ContextGLCompareMode
    ContextWebGL.prototype.setDepthTest = function (depthMask, passCompareMode) {
        this._gl.depthFunc(this._compareModeDictionary[passCompareMode]);
        this._gl.depthMask(depthMask);
    };
    ContextWebGL.prototype.enableStencil = function () {
        this._gl.enable(this._gl.STENCIL_TEST);
    };
    ContextWebGL.prototype.disableStencil = function () {
        this._gl.disable(this._gl.STENCIL_TEST);
    };
    ContextWebGL.prototype.setStencilActions = function (triangleFace, compareMode, actionOnBothPass, actionOnDepthFail, actionOnDepthPassStencilFail, coordinateSystem) {
        if (triangleFace === void 0) { triangleFace = exports.ContextGLTriangleFace.FRONT_AND_BACK; }
        if (compareMode === void 0) { compareMode = exports.ContextGLCompareMode.ALWAYS; }
        if (actionOnBothPass === void 0) { actionOnBothPass = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthFail === void 0) { actionOnDepthFail = exports.ContextGLStencilAction.KEEP; }
        if (actionOnDepthPassStencilFail === void 0) { actionOnDepthPassStencilFail = exports.ContextGLStencilAction.KEEP; }
        if (coordinateSystem === void 0) { coordinateSystem = _awayjs_core.CoordinateSystem.LEFT_HANDED; }
        this._separateStencil = triangleFace != exports.ContextGLTriangleFace.FRONT_AND_BACK;
        var compareModeGL = this._compareModeDictionary[compareMode];
        var fail = this._stencilActionDictionary[actionOnDepthPassStencilFail];
        var zFail = this._stencilActionDictionary[actionOnDepthFail];
        var pass = this._stencilActionDictionary[actionOnBothPass];
        if (!this._separateStencil) {
            this._stencilCompareMode = compareModeGL;
            this._gl.stencilFunc(compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
            this._gl.stencilOp(fail, zFail, pass);
        }
        else if (triangleFace == exports.ContextGLTriangleFace.BACK) {
            this._stencilCompareModeBack = compareModeGL;
            this._gl.stencilFuncSeparate(this._gl.BACK, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
            this._gl.stencilOpSeparate(this._gl.BACK, fail, zFail, pass);
        }
        else if (triangleFace == exports.ContextGLTriangleFace.FRONT) {
            this._stencilCompareModeFront = compareModeGL;
            this._gl.stencilFuncSeparate(this._gl.FRONT, compareModeGL, this._stencilReferenceValue, this._stencilReadMask);
            this._gl.stencilOpSeparate(this._gl.FRONT, fail, zFail, pass);
        }
    };
    ContextWebGL.prototype.setStencilReferenceValue = function (referenceValue, readMask, writeMask) {
        if (readMask === void 0) { readMask = 0xFF; }
        if (writeMask === void 0) { writeMask = 0xFF; }
        this._stencilReferenceValue = referenceValue;
        this._stencilReadMask = readMask;
        if (this._separateStencil) {
            this._gl.stencilFuncSeparate(this._gl.FRONT, this._stencilCompareModeFront, referenceValue, readMask);
            this._gl.stencilFuncSeparate(this._gl.BACK, this._stencilCompareModeBack, referenceValue, readMask);
        }
        else {
            this._gl.stencilFunc(this._stencilCompareMode, referenceValue, readMask);
        }
        this._gl.stencilMask(writeMask);
    };
    ContextWebGL.prototype.setProgram = function (program) {
        //TODO decide on construction/reference resposibilities
        this._currentProgram = program;
        program.focusProgram();
    };
    ContextWebGL.prototype.setProgramConstantsFromArray = function (programType, data) {
        if (data.length)
            this._gl.uniform4fv(this._currentProgram.getUniformLocation(programType), data);
    };
    ContextWebGL.prototype.setScissorRectangle = function (rectangle) {
        if (!rectangle) {
            this._gl.disable(this._gl.SCISSOR_TEST);
            return;
        }
        this._gl.enable(this._gl.SCISSOR_TEST);
        this._gl.scissor(rectangle.x * this._pixelRatio, this._height - (rectangle.y + rectangle.height) * this._pixelRatio, rectangle.width * this._pixelRatio, rectangle.height * this._pixelRatio);
    };
    ContextWebGL.prototype.setTextureAt = function (sampler, texture) {
        var samplerState = this._samplerStates[sampler];
        if (this._activeTexture != sampler && (texture || samplerState.type)) {
            this._activeTexture = sampler;
            this._gl.activeTexture(this._textureIndexDictionary[sampler]);
        }
        if (!texture) {
            if (samplerState.type) {
                this._gl.bindTexture(samplerState.type, null);
                samplerState.type = null;
            }
            return;
        }
        var textureType = this._textureTypeDictionary[texture.textureType];
        samplerState.type = textureType;
        this._gl.bindTexture(textureType, texture.glTexture);
        this._gl.uniform1i(this._currentProgram.getUniformLocation(exports.ContextGLProgramType.SAMPLER, sampler), sampler);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_S, samplerState.wrap);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_WRAP_T, samplerState.wrap);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_MAG_FILTER, samplerState.filter);
        this._gl.texParameteri(textureType, this._gl.TEXTURE_MIN_FILTER, samplerState.mipfilter);
    };
    ContextWebGL.prototype.setSamplerStateAt = function (sampler, wrap, filter, mipfilter) {
        if (0 <= sampler && sampler < ContextWebGL.MAX_SAMPLERS) {
            this._samplerStates[sampler].wrap = this._wrapDictionary[wrap];
            this._samplerStates[sampler].filter = this._filterDictionary[filter];
            this._samplerStates[sampler].mipfilter = this._mipmapFilterDictionary[filter][mipfilter];
        }
        else {
            throw "Sampler is out of bounds.";
        }
    };
    ContextWebGL.prototype.setVertexBufferAt = function (index, buffer, bufferOffset, format) {
        if (bufferOffset === void 0) { bufferOffset = 0; }
        if (format === void 0) { format = 4; }
        var location = this._currentProgram ? this._currentProgram.getAttribLocation(index) : -1;
        if (!buffer) {
            if (location > -1)
                this._gl.disableVertexAttribArray(location);
            return;
        }
        //buffer may not have changed if concatenated buffers are being used
        if (this._currentArrayBuffer != buffer) {
            this._currentArrayBuffer = buffer;
            this._gl.bindBuffer(this._gl.ARRAY_BUFFER, buffer ? buffer.glBuffer : null);
        }
        var properties = this._vertexBufferPropertiesDictionary[format];
        this._gl.enableVertexAttribArray(location);
        this._gl.vertexAttribPointer(location, properties.size, properties.type, properties.normalized, buffer.dataPerVertex, bufferOffset);
    };
    ContextWebGL.prototype.setRenderToTexture = function (target, enableDepthAndStencil, antiAlias, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (antiAlias === void 0) { antiAlias = 0; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        var texture = target;
        var frameBuffer = texture.frameBuffer;
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, frameBuffer);
        if (enableDepthAndStencil) {
            this._gl.enable(this._gl.STENCIL_TEST);
            this._gl.enable(this._gl.DEPTH_TEST);
        }
        this._gl.viewport(0, 0, texture.width, texture.height);
    };
    ContextWebGL.prototype.setRenderToBackBuffer = function () {
        this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, null);
    };
    ContextWebGL.prototype.updateBlendStatus = function () {
        if (this._blendEnabled) {
            this._gl.enable(this._gl.BLEND);
            this._gl.blendEquation(this._gl.FUNC_ADD);
            this._gl.blendFunc(this._blendSourceFactor, this._blendDestinationFactor);
        }
        else {
            this._gl.disable(this._gl.BLEND);
        }
    };
    ContextWebGL.prototype.translateTriangleFace = function (triangleFace, coordinateSystem) {
        switch (triangleFace) {
            case exports.ContextGLTriangleFace.BACK:
                return (coordinateSystem == _awayjs_core.CoordinateSystem.LEFT_HANDED) ? this._gl.FRONT : this._gl.BACK;
            case exports.ContextGLTriangleFace.FRONT:
                return (coordinateSystem == _awayjs_core.CoordinateSystem.LEFT_HANDED) ? this._gl.BACK : this._gl.FRONT;
            case exports.ContextGLTriangleFace.FRONT_AND_BACK:
                return this._gl.FRONT_AND_BACK;
            default:
                throw "Unknown ContextGLTriangleFace type."; // TODO error
        }
    };
    return ContextWebGL;
}());
ContextWebGL.MAX_SAMPLERS = 8;
ContextWebGL.modulo = 0;
var VertexBufferProperties$1 = (function () {
    function VertexBufferProperties(size, type, normalized) {
        this.size = size;
        this.type = type;
        this.normalized = normalized;
    }
    return VertexBufferProperties;
}());

/**
 * Stage provides a proxy class to handle the creation and attachment of the Context
 * (and in turn the back buffer) it uses. Stage should never be created directly,
 * but requested through StageManager.
 *
 * @see away.managers.StageManager
 *
 */
var Stage = (function (_super) {
    __extends(Stage, _super);
    function Stage(container, stageIndex, stageManager, forceSoftware, profile) {
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = exports.ContextGLProfile.BASELINE; }
        var _this = _super.call(this) || this;
        _this._abstractionPool = new Object();
        _this._programData = new Array();
        _this._x = 0;
        _this._y = 0;
        //private static _frameEventDriver:Shape = new Shape(); // TODO: add frame driver/request animation frame
        _this._stageIndex = -1;
        _this._antiAlias = 0;
        //private var _activeVertexBuffers : Vector.<VertexBuffer> = new Vector.<VertexBuffer>(8, true);
        //private var _activeTextures : Vector.<TextureBase> = new Vector.<TextureBase>(8, true);
        _this._renderTarget = null;
        _this._renderSurfaceSelector = 0;
        //private _mouse3DManager:away.managers.Mouse3DManager;
        //private _touch3DManager:Touch3DManager; //TODO: imeplement dependency Touch3DManager
        _this._initialised = false;
        _this._bufferFormatDictionary = new Array(5);
        _this.globalDisableMipmap = false;
        _this.globalDisableSmooth = false;
        _this._programDataPool = new ProgramDataPool(_this);
        _this._container = container;
        if (_this._container) {
            _this._container.addEventListener("webglcontextlost", function (event) { return _this.onContextLost(event); });
            _this._container.addEventListener("webglcontextrestored", function (event) { return _this.onContextRestored(event); });
        }
        _this._stageIndex = stageIndex;
        _this._stageManager = stageManager;
        _this._viewPort = new _awayjs_core.Rectangle();
        _this._enableDepthAndStencil = true;
        _awayjs_core.CSS.setElementX(_this._container, 0);
        _awayjs_core.CSS.setElementY(_this._container, 0);
        _this._bufferFormatDictionary[1] = new Array(5);
        _this._bufferFormatDictionary[1][1] = exports.ContextGLVertexBufferFormat.BYTE_1;
        _this._bufferFormatDictionary[1][2] = exports.ContextGLVertexBufferFormat.BYTE_2;
        _this._bufferFormatDictionary[1][3] = exports.ContextGLVertexBufferFormat.BYTE_3;
        _this._bufferFormatDictionary[1][4] = exports.ContextGLVertexBufferFormat.BYTE_4;
        _this._bufferFormatDictionary[2] = new Array(5);
        _this._bufferFormatDictionary[2][1] = exports.ContextGLVertexBufferFormat.SHORT_1;
        _this._bufferFormatDictionary[2][2] = exports.ContextGLVertexBufferFormat.SHORT_2;
        _this._bufferFormatDictionary[2][3] = exports.ContextGLVertexBufferFormat.SHORT_3;
        _this._bufferFormatDictionary[2][4] = exports.ContextGLVertexBufferFormat.SHORT_4;
        _this._bufferFormatDictionary[4] = new Array(5);
        _this._bufferFormatDictionary[4][1] = exports.ContextGLVertexBufferFormat.FLOAT_1;
        _this._bufferFormatDictionary[4][2] = exports.ContextGLVertexBufferFormat.FLOAT_2;
        _this._bufferFormatDictionary[4][3] = exports.ContextGLVertexBufferFormat.FLOAT_3;
        _this._bufferFormatDictionary[4][4] = exports.ContextGLVertexBufferFormat.FLOAT_4;
        _this._bufferFormatDictionary[5] = new Array(5);
        _this._bufferFormatDictionary[5][1] = exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_1;
        _this._bufferFormatDictionary[5][2] = exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_2;
        _this._bufferFormatDictionary[5][3] = exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_3;
        _this._bufferFormatDictionary[5][4] = exports.ContextGLVertexBufferFormat.UNSIGNED_BYTE_4;
        _this._bufferFormatDictionary[6] = new Array(5);
        _this._bufferFormatDictionary[6][1] = exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_1;
        _this._bufferFormatDictionary[6][2] = exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_2;
        _this._bufferFormatDictionary[6][3] = exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_3;
        _this._bufferFormatDictionary[6][4] = exports.ContextGLVertexBufferFormat.UNSIGNED_SHORT_4;
        _this.visible = true;
        return _this;
    }
    Stage.prototype.getProgramData = function (vertexString, fragmentString) {
        return this._programDataPool.getItem(vertexString, fragmentString);
    };
    Stage.prototype.setRenderTarget = function (target, enableDepthAndStencil, surfaceSelector) {
        if (enableDepthAndStencil === void 0) { enableDepthAndStencil = false; }
        if (surfaceSelector === void 0) { surfaceSelector = 0; }
        if (this._renderTarget === target && surfaceSelector == this._renderSurfaceSelector && this._enableDepthAndStencil == enableDepthAndStencil)
            return;
        this._renderTarget = target;
        this._renderSurfaceSelector = surfaceSelector;
        this._enableDepthAndStencil = enableDepthAndStencil;
        if (target) {
            this._context.setRenderToTexture(this.getAbstraction(target).getTexture(), enableDepthAndStencil, this._antiAlias, surfaceSelector);
        }
        else {
            this._context.setRenderToBackBuffer();
            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
        }
    };
    Stage.prototype.getAbstraction = function (asset) {
        return (this._abstractionPool[asset.id] || (this._abstractionPool[asset.id] = new Stage._abstractionClassPool[asset.assetType](asset, this)));
    };
    /**
     *
     * @param image
     */
    Stage.prototype.clearAbstraction = function (asset) {
        this._abstractionPool[asset.id] = null;
    };
    /**
     *
     * @param imageObjectClass
     */
    Stage.registerAbstraction = function (gl_assetClass, assetClass) {
        Stage._abstractionClassPool[assetClass.assetType] = gl_assetClass;
    };
    /**
     * Requests a Context object to attach to the managed gl canvas.
     */
    Stage.prototype.requestContext = function (forceSoftware, profile, mode) {
        // If forcing software, we can be certain that the
        // returned Context will be running software mode.
        // If not, we can't be sure and should stick to the
        // old value (will likely be same if re-requesting.)
        var _this = this;
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = exports.ContextGLProfile.BASELINE; }
        if (mode === void 0) { mode = exports.ContextMode.AUTO; }
        if (this._usesSoftwareRendering != null)
            this._usesSoftwareRendering = forceSoftware;
        this._profile = profile;
        try {
            if (mode == exports.ContextMode.FLASH)
                new ContextFlash(this._container, function (context) { return _this._callback(context); });
            else if (mode == exports.ContextMode.SOFTWARE)
                this._context = new ContextSoftware(this._container);
            else if (mode == exports.ContextMode.GLES)
                this._context = new ContextGLES(this._container);
            else
                this._context = new ContextWebGL(this._container);
        }
        catch (e) {
            try {
                if (mode == exports.ContextMode.AUTO)
                    new ContextFlash(this._container, function (context) { return _this._callback(context); });
                else
                    this.dispatchEvent(new StageEvent(StageEvent.STAGE_ERROR, this));
            }
            catch (e) {
                this.dispatchEvent(new StageEvent(StageEvent.STAGE_ERROR, this));
            }
        }
        if (this._context)
            this._callback(this._context);
    };
    Object.defineProperty(Stage.prototype, "width", {
        /**
         * The width of the gl canvas
         */
        get: function () {
            return this._width;
        },
        set: function (val) {
            if (this._width == val)
                return;
            this._container.style.width = val + "px";
            this._container.width = val * this._context.pixelRatio;
            this._width = this._viewPort.width = val;
            this._backBufferDirty = true;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "height", {
        /**
         * The height of the gl canvas
         */
        get: function () {
            return this._height;
        },
        set: function (val) {
            if (this._height == val)
                return;
            this._container.style.height = val + "px";
            this._container.height = val * this._context.pixelRatio;
            this._height = this._viewPort.height = val;
            this._backBufferDirty = true;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "x", {
        /**
         * The x position of the gl canvas
         */
        get: function () {
            return this._x;
        },
        set: function (val) {
            if (this._x == val)
                return;
            _awayjs_core.CSS.setElementX(this._container, val);
            this._x = this._viewPort.x = val;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "y", {
        /**
         * The y position of the gl canvas
         */
        get: function () {
            return this._y;
        },
        set: function (val) {
            if (this._y == val)
                return;
            _awayjs_core.CSS.setElementY(this._container, val);
            this._y = this._viewPort.y = val;
            this.notifyViewportUpdated();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "visible", {
        get: function () {
            return _awayjs_core.CSS.getElementVisibility(this._container);
        },
        set: function (val) {
            _awayjs_core.CSS.setElementVisibility(this._container, val);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "container", {
        get: function () {
            return this._container;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "context", {
        /**
         * The Context object associated with the given stage object.
         */
        get: function () {
            return this._context;
        },
        enumerable: true,
        configurable: true
    });
    Stage.prototype.notifyViewportUpdated = function () {
        if (this._viewportDirty)
            return;
        this._viewportDirty = true;
        this.dispatchEvent(new StageEvent(StageEvent.VIEWPORT_UPDATED, this));
    };
    Object.defineProperty(Stage.prototype, "profile", {
        get: function () {
            return this._profile;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Disposes the Stage object, freeing the Context attached to the Stage.
     */
    Stage.prototype.dispose = function () {
        for (var id in this._abstractionPool)
            this._abstractionPool[id].clear();
        this._abstractionPool = null;
        this._stageManager.iRemoveStage(this);
        this.freeContext();
        this._stageManager = null;
        this._stageIndex = -1;
    };
    /**
     * Configures the back buffer associated with the Stage object.
     * @param backBufferWidth The width of the backbuffer.
     * @param backBufferHeight The height of the backbuffer.
     * @param antiAlias The amount of anti-aliasing to use.
     * @param enableDepthAndStencil Indicates whether the back buffer contains a depth and stencil buffer.
     */
    Stage.prototype.configureBackBuffer = function (backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil) {
        this.width = backBufferWidth;
        this.height = backBufferHeight;
        this._antiAlias = antiAlias;
        this._enableDepthAndStencil = enableDepthAndStencil;
        if (this._context)
            this._context.configureBackBuffer(backBufferWidth, backBufferHeight, antiAlias, enableDepthAndStencil);
    };
    Object.defineProperty(Stage.prototype, "enableDepthAndStencil", {
        /*
         * Indicates whether the depth and stencil buffer is used
         */
        get: function () {
            return this._enableDepthAndStencil;
        },
        set: function (enableDepthAndStencil) {
            this._enableDepthAndStencil = enableDepthAndStencil;
            this._backBufferDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "renderTarget", {
        get: function () {
            return this._renderTarget;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "renderSurfaceSelector", {
        get: function () {
            return this._renderSurfaceSelector;
        },
        enumerable: true,
        configurable: true
    });
    /*
     * Clear and reset the back buffer when using a shared context
     */
    Stage.prototype.clear = function () {
        if (!this._context)
            return;
        if (this._backBufferDirty) {
            this.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
            this._backBufferDirty = false;
        }
        this._context.clear((this._color & 0xff000000) >>> 24, // <--------- Zero-fill right shift
        (this._color & 0xff0000) >>> 16, // <-------------|
        (this._color & 0xff00) >>> 8, // <----------------|
        this._color & 0xff);
        this._bufferClear = true;
    };
    Object.defineProperty(Stage.prototype, "scissorRect", {
        get: function () {
            return this._scissorRect;
        },
        set: function (value) {
            this._scissorRect = value;
            this._context.setScissorRectangle(this._scissorRect);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "stageIndex", {
        /**
         * The index of the Stage which is managed by this instance of StageProxy.
         */
        get: function () {
            return this._stageIndex;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "usesSoftwareRendering", {
        /**
         * Indicates whether the Stage managed by this proxy is running in software mode.
         * Remember to wait for the CONTEXT_CREATED event before checking this property,
         * as only then will it be guaranteed to be accurate.
         */
        get: function () {
            return this._usesSoftwareRendering;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "antiAlias", {
        /**
         * The antiAliasing of the Stage.
         */
        get: function () {
            return this._antiAlias;
        },
        set: function (antiAlias) {
            this._antiAlias = antiAlias;
            this._backBufferDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "viewPort", {
        /**
         * A viewPort rectangle equivalent of the Stage size and position.
         */
        get: function () {
            this._viewportDirty = false;
            return this._viewPort;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "color", {
        /**
         * The background color of the Stage.
         */
        get: function () {
            return this._color;
        },
        set: function (color) {
            this._color = color;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Stage.prototype, "bufferClear", {
        /**
         * The freshly cleared state of the backbuffer before any rendering
         */
        get: function () {
            return this._bufferClear;
        },
        set: function (newBufferClear) {
            this._bufferClear = newBufferClear;
        },
        enumerable: true,
        configurable: true
    });
    Stage.prototype.registerProgram = function (programData) {
        var i = 0;
        while (this._programData[i] != null)
            i++;
        this._programData[i] = programData;
        programData.id = i;
    };
    Stage.prototype.unRegisterProgram = function (programData) {
        this._programData[programData.id] = null;
        programData.id = -1;
    };
    /**
     * Frees the Context associated with this StageProxy.
     */
    Stage.prototype.freeContext = function () {
        if (this._context) {
            this._context.dispose();
            this.dispatchEvent(new StageEvent(StageEvent.CONTEXT_DISPOSED, this));
        }
        this._context = null;
        this._initialised = false;
    };
    Stage.prototype.onContextLost = function (event) {
    };
    Stage.prototype.onContextRestored = function (event) {
    };
    Stage.prototype.recoverFromDisposal = function () {
        if (!this._context)
            return false;
        //away.Debug.throwPIR( 'StageProxy' , 'recoverFromDisposal' , '' );
        /*
         if (this._iContext.driverInfo == "Disposed")
         {
         this._iContext = null;
         this.dispatchEvent(new StageEvent(StageEvent.CONTEXT_DISPOSED));
         return false;

         }
         */
        return true;
    };
    Stage.prototype._callback = function (context) {
        this._context = context;
        this._container = this._context.container;
        // Only configure back buffer if width and height have been set,
        // which they may not have been if View.render() has yet to be
        // invoked for the first time.
        if (this._width && this._height)
            this._context.configureBackBuffer(this._width, this._height, this._antiAlias, this._enableDepthAndStencil);
        // Dispatch the appropriate event depending on whether context was
        // created for the first time or recreated after a device loss.
        this.dispatchEvent(new StageEvent(this._initialised ? StageEvent.CONTEXT_RECREATED : StageEvent.CONTEXT_CREATED, this));
        this._initialised = true;
    };
    Stage.prototype.setVertexBuffer = function (index, buffer, size, dimensions, offset, unsigned) {
        if (unsigned === void 0) { unsigned = false; }
        this._context.setVertexBufferAt(index, buffer, offset, this._bufferFormatDictionary[unsigned ? size + 4 : size][dimensions]);
    };
    Stage.prototype.setSamplerState = function (index, repeat, smooth, mipmap) {
        var wrap = repeat ? exports.ContextGLWrapMode.REPEAT : exports.ContextGLWrapMode.CLAMP;
        var filter = (smooth && !this.globalDisableSmooth) ? exports.ContextGLTextureFilter.LINEAR : exports.ContextGLTextureFilter.NEAREST;
        var mipfilter = (mipmap && !this.globalDisableMipmap) ? exports.ContextGLMipFilter.MIPLINEAR : exports.ContextGLMipFilter.MIPNONE;
        this._context.setSamplerStateAt(index, wrap, filter, mipfilter);
    };
    return Stage;
}(_awayjs_core.EventDispatcher));
Stage._abstractionClassPool = new Object();

/**
 * The StageManager class provides a multiton object that handles management for Stage objects.
 *
 * @see away.base.Stage
 */
var StageManager = (function (_super) {
    __extends(StageManager, _super);
    /**
     * Creates a new StageManager class.
     * @param stage The Stage object that contains the Stage objects to be managed.
     * @private
     */
    function StageManager() {
        var _this = _super.call(this) || this;
        _this._stages = new Array(StageManager.STAGE_MAX_QUANTITY);
        _this._onContextCreatedDelegate = function (event) { return _this.onContextCreated(event); };
        return _this;
    }
    /**
     * Gets a StageManager instance for the given Stage object.
     * @param stage The Stage object that contains the Stage objects to be managed.
     * @return The StageManager instance for the given Stage object.
     */
    StageManager.getInstance = function () {
        if (this._instance == null)
            this._instance = new StageManager();
        return this._instance;
    };
    /**
     * Requests the Stage for the given index.
     *
     * @param index The index of the requested Stage.
     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
     * @param profile The compatibility profile, an enumeration of ContextProfile
     * @return The Stage for the given index.
     */
    StageManager.prototype.getStageAt = function (index, forceSoftware, profile, mode) {
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = exports.ContextGLProfile.BASELINE; }
        if (mode === void 0) { mode = exports.ContextMode.AUTO; }
        if (index < 0 || index >= StageManager.STAGE_MAX_QUANTITY)
            throw new _awayjs_core.ArgumentError("Index is out of bounds [0.." + StageManager.STAGE_MAX_QUANTITY + "]");
        if (!this._stages[index]) {
            StageManager._numStages++;
            if (document) {
                var canvas = document.createElement("canvas");
                canvas.id = "stage" + index;
                document.body.appendChild(canvas);
            }
            var stage = this._stages[index] = new Stage(canvas, index, this, forceSoftware, profile);
            stage.addEventListener(StageEvent.CONTEXT_CREATED, this._onContextCreatedDelegate);
            stage.requestContext(forceSoftware, profile, mode);
        }
        return this._stages[index];
    };
    /**
     * Removes a Stage from the manager.
     * @param stage
     * @private
     */
    StageManager.prototype.iRemoveStage = function (stage) {
        StageManager._numStages--;
        stage.removeEventListener(StageEvent.CONTEXT_CREATED, this._onContextCreatedDelegate);
        this._stages[stage.stageIndex] = null;
    };
    /**
     * Get the next available stage. An error is thrown if there are no StageProxies available
     * @param forceSoftware Whether to force software mode even if hardware acceleration is available.
     * @param profile The compatibility profile, an enumeration of ContextProfile
     * @return The allocated stage
     */
    StageManager.prototype.getFreeStage = function (forceSoftware, profile, mode) {
        if (forceSoftware === void 0) { forceSoftware = false; }
        if (profile === void 0) { profile = exports.ContextGLProfile.BASELINE; }
        if (mode === void 0) { mode = exports.ContextMode.AUTO; }
        var i = 0;
        var len = this._stages.length;
        while (i < len) {
            if (!this._stages[i])
                return this.getStageAt(i, forceSoftware, profile, mode);
            ++i;
        }
        return null;
    };
    Object.defineProperty(StageManager.prototype, "hasFreeStage", {
        /**
         * Checks if a new stage can be created and managed by the class.
         * @return true if there is one slot free for a new stage
         */
        get: function () {
            return StageManager._numStages < StageManager.STAGE_MAX_QUANTITY ? true : false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StageManager.prototype, "numSlotsFree", {
        /**
         * Returns the amount of stage objects that can be created and managed by the class
         * @return the amount of free slots
         */
        get: function () {
            return StageManager.STAGE_MAX_QUANTITY - StageManager._numStages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StageManager.prototype, "numSlotsUsed", {
        /**
         * Returns the amount of Stage objects currently managed by the class.
         * @return the amount of slots used
         */
        get: function () {
            return StageManager._numStages;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(StageManager.prototype, "numSlotsTotal", {
        /**
         * The maximum amount of Stage objects that can be managed by the class
         */
        get: function () {
            return this._stages.length;
        },
        enumerable: true,
        configurable: true
    });
    StageManager.prototype.onContextCreated = function (event) {
        //var stage:Stage = <Stage> e.target;
        //document.body.appendChild(stage.canvas)
    };
    return StageManager;
}(_awayjs_core.EventDispatcher));
StageManager.STAGE_MAX_QUANTITY = 8;
StageManager._numStages = 0;

/**
 * RegisterPool is used by the shader compilers process to keep track of which registers of a certain type are
 * currently used and should not be allowed to be written to. Either entire registers can be requested and locked,
 * or single components (x, y, z, w) of a single register.
 * It is used by ShaderRegisterCache to track usages of individual register types.
 *
 * @see away.materials.ShaderRegisterCache
 */
var RegisterPool = (function () {
    /**
     * Creates a new RegisterPool object.
     * @param regName The base name of the register type ("ft" for fragment temporaries, "vc" for vertex constants, etc)
     * @param regCount The amount of available registers of this type.
     * @param persistent Whether or not registers, once reserved, can be freed again. For example, temporaries are not persistent, but constants are.
     */
    function RegisterPool(regName, regCount, persistent) {
        if (persistent === void 0) { persistent = true; }
        this._regName = regName;
        this._regCount = regCount;
        this._persistent = persistent;
        this.initRegisters(regName, regCount);
    }
    /**
     * Retrieve an entire vector register that's still available.
     */
    RegisterPool.prototype.requestFreeVectorReg = function () {
        for (var i = 0; i < this._regCount; ++i) {
            if (!this.isRegisterUsed(i)) {
                if (this._persistent)
                    this._usedVectorCount[i]++;
                return this._vectorRegisters[i];
            }
        }
        throw new Error("Register overflow!");
    };
    /**
     * Retrieve a single vector component that's still available.
     */
    RegisterPool.prototype.requestFreeRegComponent = function () {
        for (var i = 0; i < this._regCount; ++i) {
            if (this._usedVectorCount[i] > 0)
                continue;
            for (var j = 0; j < 4; ++j) {
                if (this._usedSingleCount[j][i] == 0) {
                    if (this._persistent)
                        this._usedSingleCount[j][i]++;
                    return this._registerComponents[j][i];
                }
            }
        }
        throw new Error("Register overflow!");
    };
    /**
     * Marks a register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
     * has been called usageCount times again.
     * @param register The register to mark as used.
     * @param usageCount The amount of usages to add.
     */
    RegisterPool.prototype.addUsage = function (register, usageCount) {
        if (register._component > -1)
            this._usedSingleCount[register._component][register.index] += usageCount;
        else
            this._usedVectorCount[register.index] += usageCount;
    };
    /**
     * Removes a usage from a register. When usages reach 0, the register is freed again.
     * @param register The register for which to remove a usage.
     */
    RegisterPool.prototype.removeUsage = function (register) {
        if (register._component > -1) {
            if (--this._usedSingleCount[register._component][register.index] < 0)
                throw new Error("More usages removed than exist!");
        }
        else {
            if (--this._usedVectorCount[register.index] < 0)
                throw new Error("More usages removed than exist!");
        }
    };
    /**
     * Disposes any resources used by the current RegisterPool object.
     */
    RegisterPool.prototype.dispose = function () {
        this._vectorRegisters = null;
        this._registerComponents = null;
        this._usedSingleCount = null;
        this._usedVectorCount = null;
    };
    /**
     * Indicates whether or not any registers are in use.
     */
    RegisterPool.prototype.hasRegisteredRegs = function () {
        for (var i = 0; i < this._regCount; ++i)
            if (this.isRegisterUsed(i))
                return true;
        return false;
    };
    /**
     * Initializes all registers.
     */
    RegisterPool.prototype.initRegisters = function (regName, regCount) {
        var hash = RegisterPool._initPool(regName, regCount);
        this._vectorRegisters = RegisterPool._regPool[hash];
        this._registerComponents = RegisterPool._regCompsPool[hash];
        this._usedVectorCount = this._initArray(Array(regCount), 0);
        this._usedSingleCount = new Array(4);
        this._usedSingleCount[0] = this._initArray(new Array(regCount), 0);
        this._usedSingleCount[1] = this._initArray(new Array(regCount), 0);
        this._usedSingleCount[2] = this._initArray(new Array(regCount), 0);
        this._usedSingleCount[3] = this._initArray(new Array(regCount), 0);
    };
    RegisterPool._initPool = function (regName, regCount) {
        var hash = regName + regCount;
        if (RegisterPool._regPool[hash] != undefined)
            return hash;
        var vectorRegisters = new Array(regCount);
        RegisterPool._regPool[hash] = vectorRegisters;
        var registerComponents = [
            [],
            [],
            [],
            []
        ];
        RegisterPool._regCompsPool[hash] = registerComponents;
        for (var i = 0; i < regCount; ++i) {
            vectorRegisters[i] = new ShaderRegisterElement(regName, i);
            for (var j = 0; j < 4; ++j)
                registerComponents[j][i] = new ShaderRegisterElement(regName, i, j);
        }
        return hash;
    };
    /**
     * Check if the temp register is either used for single or vector use
     */
    RegisterPool.prototype.isRegisterUsed = function (index) {
        if (this._usedVectorCount[index] > 0)
            return true;
        for (var i = 0; i < 4; ++i)
            if (this._usedSingleCount[i][index] > 0)
                return true;
        return false;
    };
    RegisterPool.prototype._initArray = function (a, val) {
        var l = a.length;
        for (var c = 0; c < l; c++)
            a[c] = val;
        return a;
    };
    return RegisterPool;
}());
RegisterPool._regPool = new Object();
RegisterPool._regCompsPool = new Object();

/**
 * ShaderRegister Cache provides the usage management system for all registers during shading compilers.
 */
var ShaderRegisterCache = (function () {
    /**
     * Create a new ShaderRegisterCache object.
     *
     * @param profile The compatibility profile used by the renderer.
     */
    function ShaderRegisterCache(profile) {
        this._numUsedVertexConstants = 0;
        this._numUsedFragmentConstants = 0;
        this._numUsedStreams = 0;
        this._numUsedTextures = 0;
        this._numUsedVaryings = 0;
        this._profile = profile;
        this.reset();
    }
    /**
     * Resets all registers.
     */
    ShaderRegisterCache.prototype.reset = function () {
        this._fragmentTempCache = new RegisterPool("ft", 8, false);
        this._vertexTempCache = new RegisterPool("vt", 8, false);
        this._varyingCache = new RegisterPool("v", 8);
        this._textureCache = new RegisterPool("fs", 8);
        this._vertexAttributesCache = new RegisterPool("va", 8);
        this._fragmentConstantsCache = new RegisterPool("fc", 28);
        this._vertexConstantsCache = new RegisterPool("vc", 128);
        this._fragmentOutputRegister = new ShaderRegisterElement("oc", -1);
        this._vertexOutputRegister = new ShaderRegisterElement("op", -1);
        this._numUsedVertexConstants = 0;
        this._numUsedStreams = 0;
        this._numUsedTextures = 0;
        this._numUsedVaryings = 0;
        this._numUsedFragmentConstants = 0;
    };
    /**
     * Disposes all resources used.
     */
    ShaderRegisterCache.prototype.dispose = function () {
        this._fragmentTempCache.dispose();
        this._vertexTempCache.dispose();
        this._varyingCache.dispose();
        this._fragmentConstantsCache.dispose();
        this._vertexAttributesCache.dispose();
        this._fragmentTempCache = null;
        this._vertexTempCache = null;
        this._varyingCache = null;
        this._fragmentConstantsCache = null;
        this._vertexAttributesCache = null;
        this._fragmentOutputRegister = null;
        this._vertexOutputRegister = null;
    };
    /**
     * Marks a fragment temporary register as used, so it cannot be retrieved. The register won't be able to be used until removeUsage
     * has been called usageCount times again.
     * @param register The register to mark as used.
     * @param usageCount The amount of usages to add.
     */
    ShaderRegisterCache.prototype.addFragmentTempUsages = function (register, usageCount) {
        this._fragmentTempCache.addUsage(register, usageCount);
    };
    /**
     * Removes a usage from a fragment temporary register. When usages reach 0, the register is freed again.
     * @param register The register for which to remove a usage.
     */
    ShaderRegisterCache.prototype.removeFragmentTempUsage = function (register) {
        this._fragmentTempCache.removeUsage(register);
    };
    /**
     * Marks a vertex temporary register as used, so it cannot be retrieved. The register won't be able to be used
     * until removeUsage has been called usageCount times again.
     * @param register The register to mark as used.
     * @param usageCount The amount of usages to add.
     */
    ShaderRegisterCache.prototype.addVertexTempUsages = function (register, usageCount) {
        this._vertexTempCache.addUsage(register, usageCount);
    };
    /**
     * Removes a usage from a vertex temporary register. When usages reach 0, the register is freed again.
     * @param register The register for which to remove a usage.
     */
    ShaderRegisterCache.prototype.removeVertexTempUsage = function (register) {
        this._vertexTempCache.removeUsage(register);
    };
    /**
     * Retrieve an entire fragment temporary register that's still available. The register won't be able to be used until removeUsage
     * has been called usageCount times again.
     */
    ShaderRegisterCache.prototype.getFreeFragmentVectorTemp = function () {
        return this._fragmentTempCache.requestFreeVectorReg();
    };
    /**
     * Retrieve a single component from a fragment temporary register that's still available.
     */
    ShaderRegisterCache.prototype.getFreeFragmentSingleTemp = function () {
        return this._fragmentTempCache.requestFreeRegComponent();
    };
    /**
     * Retrieve an available varying register
     */
    ShaderRegisterCache.prototype.getFreeVarying = function () {
        ++this._numUsedVaryings;
        return this._varyingCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an available fragment constant register
     */
    ShaderRegisterCache.prototype.getFreeFragmentConstant = function () {
        ++this._numUsedFragmentConstants;
        return this._fragmentConstantsCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an available vertex constant register
     */
    ShaderRegisterCache.prototype.getFreeVertexConstant = function () {
        ++this._numUsedVertexConstants;
        return this._vertexConstantsCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an entire vertex temporary register that's still available.
     */
    ShaderRegisterCache.prototype.getFreeVertexVectorTemp = function () {
        return this._vertexTempCache.requestFreeVectorReg();
    };
    /**
     * Retrieve a single component from a vertex temporary register that's still available.
     */
    ShaderRegisterCache.prototype.getFreeVertexSingleTemp = function () {
        return this._vertexTempCache.requestFreeRegComponent();
    };
    /**
     * Retrieve an available vertex attribute register
     */
    ShaderRegisterCache.prototype.getFreeVertexAttribute = function () {
        ++this._numUsedStreams;
        return this._vertexAttributesCache.requestFreeVectorReg();
    };
    /**
     * Retrieve an available texture register
     */
    ShaderRegisterCache.prototype.getFreeTextureReg = function () {
        ++this._numUsedTextures;
        return this._textureCache.requestFreeVectorReg();
    };
    Object.defineProperty(ShaderRegisterCache.prototype, "fragmentOutputRegister", {
        /**
         * The fragment output register.
         */
        get: function () {
            return this._fragmentOutputRegister;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVertexConstants", {
        /**
         * The amount of used vertex constant registers.
         */
        get: function () {
            return this._numUsedVertexConstants;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedFragmentConstants", {
        /**
         * The amount of used fragment constant registers.
         */
        get: function () {
            return this._numUsedFragmentConstants;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedStreams", {
        /**
         * The amount of used vertex streams.
         */
        get: function () {
            return this._numUsedStreams;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedTextures", {
        /**
         * The amount of used texture slots.
         */
        get: function () {
            return this._numUsedTextures;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderRegisterCache.prototype, "numUsedVaryings", {
        /**
         * The amount of used varying registers.
         */
        get: function () {
            return this._numUsedVaryings;
        },
        enumerable: true,
        configurable: true
    });
    return ShaderRegisterCache;
}());

/**
 * ShaderRegisterData contains the "named" registers, generated by the compiler and to be passed on to the methods.
 */
var ShaderRegisterData = (function () {
    function ShaderRegisterData() {
        this.textures = new Array();
        this.animatableAttributes = new Array();
        this.animationTargetRegisters = new Array();
    }
    return ShaderRegisterData;
}());

/**
 * CompilerBase is an abstract base class for shader compilers that use modular shader methods to assemble a
 * material. Concrete subclasses are used by the default materials.
 *
 * @see away.materials.ShadingMethodBase
 */
var CompilerBase = (function () {
    /**
     * Creates a new CompilerBase object.
     * @param profile The compatibility profile of the renderer.
     */
    function CompilerBase(elementsClass, pass, shader) {
        this._vertexCode = ''; // Changed to emtpy string- AwayTS
        this._fragmentCode = ''; // Changed to emtpy string - AwayTS
        this._postAnimationFragmentCode = ''; // Changed to emtpy string - AwayTS
        this._elementsClass = elementsClass;
        this._renderPass = pass;
        this._shader = shader;
        this._sharedRegisters = new ShaderRegisterData();
        this._registerCache = new ShaderRegisterCache(shader.profile);
    }
    /**
     * Compiles the code after all setup on the compiler has finished.
     */
    CompilerBase.prototype.compile = function () {
        this._shader.reset();
        this._shader._includeDependencies();
        this.pInitRegisterIndices();
        this.pCompileDependencies();
        //compile custom vertex & fragment codes
        this._vertexCode += this._renderPass._getVertexCode(this._registerCache, this._sharedRegisters);
        this._fragmentCode += this._renderPass._getFragmentCode(this._registerCache, this._sharedRegisters);
        this._postAnimationFragmentCode += this._renderPass._getPostAnimationFragmentCode(this._registerCache, this._sharedRegisters);
        //assign the final output color to the output register
        this._postAnimationFragmentCode += "mov " + this._registerCache.fragmentOutputRegister + ", " + this._sharedRegisters.shadedTarget + "\n";
        this._registerCache.removeFragmentTempUsage(this._sharedRegisters.shadedTarget);
    };
    /**
     * Calculate the transformed colours
     */
    CompilerBase.prototype.compileColorTransformCode = function () {
        // rm, gm, bm, am - multiplier
        // ro, go, bo, ao - offset
        var ct1 = this._registerCache.getFreeFragmentConstant();
        var ct2 = this._registerCache.getFreeFragmentConstant();
        this._shader.colorTransformIndex = ct1.index * 4;
        this._postAnimationFragmentCode += "mul " + this._sharedRegisters.shadedTarget + ", " + this._sharedRegisters.shadedTarget + ", " + ct1 + "\n";
        this._postAnimationFragmentCode += "add " + this._sharedRegisters.shadedTarget + ", " + this._sharedRegisters.shadedTarget + ", " + ct2 + "\n";
    };
    /**
     * Compile the code for the methods.
     */
    CompilerBase.prototype.pCompileDependencies = function () {
        this._sharedRegisters.shadedTarget = this._registerCache.getFreeFragmentVectorTemp();
        this._registerCache.addFragmentTempUsages(this._sharedRegisters.shadedTarget, 1);
        //compile the world-space position if required
        if (this._shader.globalPosDependencies > 0)
            this.compileGlobalPositionCode();
        //compile the local-space position if required
        if (this._shader.usesPositionFragment)
            this.compilePositionCode();
        if (this._shader.usesCurves)
            this.compileCurvesCode();
        if (this._shader.usesColorTransform)
            this.compileColorTransformCode();
        //Calculate the (possibly animated) UV coordinates.
        if (this._shader.uvDependencies > 0)
            this.compileUVCode();
        if (this._shader.secondaryUVDependencies > 0)
            this.compileSecondaryUVCode();
        if (this._shader.normalDependencies > 0)
            this.compileNormalCode();
        if (this._shader.viewDirDependencies > 0)
            this.compileViewDirCode();
        //collect code from material
        this._vertexCode += this._elementsClass._getVertexCode(this._shader, this._registerCache, this._sharedRegisters);
        this._fragmentCode += this._elementsClass._getFragmentCode(this._shader, this._registerCache, this._sharedRegisters);
    };
    CompilerBase.prototype.compileGlobalPositionCode = function () {
        this._registerCache.addVertexTempUsages(this._sharedRegisters.globalPositionVertex = this._registerCache.getFreeVertexVectorTemp(), this._shader.globalPosDependencies);
        var sceneMatrixReg = this._registerCache.getFreeVertexConstant();
        this._registerCache.getFreeVertexConstant();
        this._registerCache.getFreeVertexConstant();
        this._registerCache.getFreeVertexConstant();
        this._shader.sceneMatrixIndex = sceneMatrixReg.index * 4;
        this._vertexCode += "m44 " + this._sharedRegisters.globalPositionVertex + ", " + this._sharedRegisters.animatedPosition + ", " + sceneMatrixReg + "\n";
        if (this._shader.usesGlobalPosFragment) {
            this._sharedRegisters.globalPositionVarying = this._registerCache.getFreeVarying();
            this._vertexCode += "mov " + this._sharedRegisters.globalPositionVarying + ", " + this._sharedRegisters.globalPositionVertex + "\n";
        }
    };
    CompilerBase.prototype.compilePositionCode = function () {
        this._sharedRegisters.positionVarying = this._registerCache.getFreeVarying();
        this._vertexCode += "mov " + this._sharedRegisters.positionVarying + ", " + this._sharedRegisters.animatedPosition + "\n";
    };
    CompilerBase.prototype.compileCurvesCode = function () {
        this._sharedRegisters.curvesInput = this._registerCache.getFreeVertexAttribute();
        this._shader.curvesIndex = this._sharedRegisters.curvesInput.index;
        this._sharedRegisters.curvesVarying = this._registerCache.getFreeVarying();
        this._vertexCode += "mov " + this._sharedRegisters.curvesVarying + ", " + this._sharedRegisters.curvesInput + "\n";
        var temp = this._registerCache.getFreeFragmentSingleTemp();
        this._fragmentCode += "mul " + temp + ", " + this._sharedRegisters.curvesVarying + ".y, " + this._sharedRegisters.curvesVarying + ".y\n" +
            "sub " + temp + ", " + temp + ", " + this._sharedRegisters.curvesVarying + ".z\n" +
            "mul " + temp + ", " + temp + ", " + this._sharedRegisters.curvesVarying + ".x\n" +
            "kil " + temp + "\n";
        // var temp:ShaderRegisterElement = this._registerCache.getFreeFragmentVectorTemp();
        //
        // this._postAnimationFragmentCode += "mul " + temp + ".x, " + this._sharedRegisters.curvesVarying + ".y, " + this._sharedRegisters.curvesVarying + ".y\n" +
        // 					"sub " + temp + ".x, " + temp + ".x, " + this._sharedRegisters.curvesVarying + ".z\n" +
        // 					"mul " + temp + ".x, " + temp + ".x, " + this._sharedRegisters.curvesVarying + ".x\n" +
        // 					"ddx " + temp + ".y," + temp + ".x\n" +
        // 					"ddy " + temp + ".z," + temp + ".x\n" +
        // 					"mul " + temp + ".y, " + temp + ".y, " + temp + ".y\n" +
        // 					"mul " + temp + ".z, " + temp + ".z, " + temp + ".z\n" +
        // 					"add " + this._sharedRegisters.shadedTarget + ".w, " + temp + ".y, " + temp + ".z\n" +
        // 					"sqt " + this._sharedRegisters.shadedTarget + ".w, " + this._sharedRegisters.shadedTarget + ".w\n" +
        // 					"div " + this._sharedRegisters.shadedTarget + ".w, " + temp + ".x, " + this._sharedRegisters.shadedTarget + ".w\n" +
        // 					"max " + this._sharedRegisters.shadedTarget + ".w, " + this._sharedRegisters.shadedTarget + ".w, " + this._sharedRegisters.commons + ".y\n" +
        // 					"min " + this._sharedRegisters.shadedTarget + ".w, " + this._sharedRegisters.shadedTarget + ".w, " + this._sharedRegisters.commons + ".w\n";
    };
    /**
     * Calculate the (possibly animated) UV coordinates.
     */
    CompilerBase.prototype.compileUVCode = function () {
        var uvAttributeReg = this._registerCache.getFreeVertexAttribute();
        this._shader.uvIndex = uvAttributeReg.index;
        var varying = this._sharedRegisters.uvVarying = this._registerCache.getFreeVarying();
        if (this._shader.usesUVTransform) {
            // a, b, 0, tx
            // c, d, 0, ty
            var uvTransform1 = this._registerCache.getFreeVertexConstant();
            var uvTransform2 = this._registerCache.getFreeVertexConstant();
            this._shader.uvMatrixIndex = uvTransform1.index * 4;
            this._vertexCode += "dp4 " + varying + ".x, " + uvAttributeReg + ", " + uvTransform1 + "\n" +
                "dp4 " + varying + ".y, " + uvAttributeReg + ", " + uvTransform2 + "\n" +
                "mov " + varying + ".zw, " + uvAttributeReg + ".zw \n";
        }
        else {
            this._shader.uvMatrixIndex = -1;
            this._sharedRegisters.uvTarget = varying;
            this._sharedRegisters.uvSource = uvAttributeReg;
        }
    };
    /**
     * Provide the secondary UV coordinates.
     */
    CompilerBase.prototype.compileSecondaryUVCode = function () {
        var uvAttributeReg = this._registerCache.getFreeVertexAttribute();
        this._shader.secondaryUVIndex = uvAttributeReg.index;
        this._sharedRegisters.secondaryUVVarying = this._registerCache.getFreeVarying();
        this._vertexCode += "mov " + this._sharedRegisters.secondaryUVVarying + ", " + uvAttributeReg + "\n";
    };
    /**
     * Calculate the view direction.
     */
    CompilerBase.prototype.compileViewDirCode = function () {
        var cameraPositionReg = this._registerCache.getFreeVertexConstant();
        this._sharedRegisters.viewDirVarying = this._registerCache.getFreeVarying();
        this._sharedRegisters.viewDirFragment = this._registerCache.getFreeFragmentVectorTemp();
        this._registerCache.addFragmentTempUsages(this._sharedRegisters.viewDirFragment, this._shader.viewDirDependencies);
        this._shader.cameraPositionIndex = cameraPositionReg.index * 4;
        if (this._shader.usesTangentSpace) {
            var temp = this._registerCache.getFreeVertexVectorTemp();
            this._vertexCode += "sub " + temp + ", " + cameraPositionReg + ", " + this._sharedRegisters.animatedPosition + "\n" +
                "m33 " + this._sharedRegisters.viewDirVarying + ".xyz, " + temp + ", " + this._sharedRegisters.animatedTangent + "\n" +
                "mov " + this._sharedRegisters.viewDirVarying + ".w, " + this._sharedRegisters.animatedPosition + ".w\n";
        }
        else {
            this._vertexCode += "sub " + this._sharedRegisters.viewDirVarying + ", " + cameraPositionReg + ", " + this._sharedRegisters.globalPositionVertex + "\n";
            this._registerCache.removeVertexTempUsage(this._sharedRegisters.globalPositionVertex);
        }
        //TODO is this required in all cases? (re: distancemappass)
        this._fragmentCode += "nrm " + this._sharedRegisters.viewDirFragment + ".xyz, " + this._sharedRegisters.viewDirVarying + "\n" +
            "mov " + this._sharedRegisters.viewDirFragment + ".w,   " + this._sharedRegisters.viewDirVarying + ".w\n";
    };
    /**
     * Calculate the normal.
     */
    CompilerBase.prototype.compileNormalCode = function () {
        this._sharedRegisters.normalFragment = this._registerCache.getFreeFragmentVectorTemp();
        this._registerCache.addFragmentTempUsages(this._sharedRegisters.normalFragment, this._shader.normalDependencies);
        //simple normal aquisition if no tangent space is being used
        if (this._shader.outputsNormals && !this._shader.outputsTangentNormals) {
            this._vertexCode += this._renderPass._getNormalVertexCode(this._registerCache, this._sharedRegisters);
            this._fragmentCode += this._renderPass._getNormalFragmentCode(this._registerCache, this._sharedRegisters);
            return;
        }
        var normalMatrix;
        if (!this._shader.outputsNormals || !this._shader.usesTangentSpace) {
            normalMatrix = new Array(3);
            normalMatrix[0] = this._registerCache.getFreeVertexConstant();
            normalMatrix[1] = this._registerCache.getFreeVertexConstant();
            normalMatrix[2] = this._registerCache.getFreeVertexConstant();
            this._registerCache.getFreeVertexConstant();
            this._shader.sceneNormalMatrixIndex = normalMatrix[0].index * 4;
            this._sharedRegisters.normalVarying = this._registerCache.getFreeVarying();
        }
        if (this._shader.outputsNormals) {
            if (this._shader.usesTangentSpace) {
                // normalize normal + tangent vector and generate (approximated) bitangent used in m33 operation for view
                this._vertexCode += "nrm " + this._sharedRegisters.animatedNormal + ".xyz, " + this._sharedRegisters.animatedNormal + "\n" +
                    "nrm " + this._sharedRegisters.animatedTangent + ".xyz, " + this._sharedRegisters.animatedTangent + "\n" +
                    "crs " + this._sharedRegisters.bitangent + ".xyz, " + this._sharedRegisters.animatedNormal + ", " + this._sharedRegisters.animatedTangent + "\n";
                this._fragmentCode += this._renderPass._getNormalFragmentCode(this._registerCache, this._sharedRegisters);
            }
            else {
                //Compiles the vertex shader code for tangent-space normal maps.
                this._sharedRegisters.tangentVarying = this._registerCache.getFreeVarying();
                this._sharedRegisters.bitangentVarying = this._registerCache.getFreeVarying();
                var temp = this._registerCache.getFreeVertexVectorTemp();
                this._vertexCode += "m33 " + temp + ".xyz, " + this._sharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" +
                    "nrm " + this._sharedRegisters.animatedNormal + ".xyz, " + temp + "\n" +
                    "m33 " + temp + ".xyz, " + this._sharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" +
                    "nrm " + this._sharedRegisters.animatedTangent + ".xyz, " + temp + "\n" +
                    "mov " + this._sharedRegisters.tangentVarying + ".x, " + this._sharedRegisters.animatedTangent + ".x  \n" +
                    "mov " + this._sharedRegisters.tangentVarying + ".z, " + this._sharedRegisters.animatedNormal + ".x  \n" +
                    "mov " + this._sharedRegisters.tangentVarying + ".w, " + this._sharedRegisters.normalInput + ".w  \n" +
                    "mov " + this._sharedRegisters.bitangentVarying + ".x, " + this._sharedRegisters.animatedTangent + ".y  \n" +
                    "mov " + this._sharedRegisters.bitangentVarying + ".z, " + this._sharedRegisters.animatedNormal + ".y  \n" +
                    "mov " + this._sharedRegisters.bitangentVarying + ".w, " + this._sharedRegisters.normalInput + ".w  \n" +
                    "mov " + this._sharedRegisters.normalVarying + ".x, " + this._sharedRegisters.animatedTangent + ".z  \n" +
                    "mov " + this._sharedRegisters.normalVarying + ".z, " + this._sharedRegisters.animatedNormal + ".z  \n" +
                    "mov " + this._sharedRegisters.normalVarying + ".w, " + this._sharedRegisters.normalInput + ".w  \n" +
                    "crs " + temp + ".xyz, " + this._sharedRegisters.animatedNormal + ", " + this._sharedRegisters.animatedTangent + "\n" +
                    "mov " + this._sharedRegisters.tangentVarying + ".y, " + temp + ".x    \n" +
                    "mov " + this._sharedRegisters.bitangentVarying + ".y, " + temp + ".y  \n" +
                    "mov " + this._sharedRegisters.normalVarying + ".y, " + temp + ".z    \n";
                this._registerCache.removeVertexTempUsage(this._sharedRegisters.animatedTangent);
                //Compiles the fragment shader code for tangent-space normal maps.
                var t;
                var b;
                var n;
                t = this._registerCache.getFreeFragmentVectorTemp();
                this._registerCache.addFragmentTempUsages(t, 1);
                b = this._registerCache.getFreeFragmentVectorTemp();
                this._registerCache.addFragmentTempUsages(b, 1);
                n = this._registerCache.getFreeFragmentVectorTemp();
                this._registerCache.addFragmentTempUsages(n, 1);
                this._fragmentCode += "nrm " + t + ".xyz, " + this._sharedRegisters.tangentVarying + "\n" +
                    "mov " + t + ".w, " + this._sharedRegisters.tangentVarying + ".w	\n" +
                    "nrm " + b + ".xyz, " + this._sharedRegisters.bitangentVarying + "\n" +
                    "nrm " + n + ".xyz, " + this._sharedRegisters.normalVarying + "\n";
                //compile custom fragment code for normal calcs
                this._fragmentCode += this._renderPass._getNormalFragmentCode(this._registerCache, this._sharedRegisters) +
                    "m33 " + this._sharedRegisters.normalFragment + ".xyz, " + this._sharedRegisters.normalFragment + ", " + t + "\n" +
                    "mov " + this._sharedRegisters.normalFragment + ".w, " + this._sharedRegisters.normalVarying + ".w\n";
                this._registerCache.removeFragmentTempUsage(b);
                this._registerCache.removeFragmentTempUsage(t);
                this._registerCache.removeFragmentTempUsage(n);
            }
        }
        else {
            // no output, world space is enough
            this._vertexCode += "m33 " + this._sharedRegisters.normalVarying + ".xyz, " + this._sharedRegisters.animatedNormal + ", " + normalMatrix[0] + "\n" +
                "mov " + this._sharedRegisters.normalVarying + ".w, " + this._sharedRegisters.animatedNormal + ".w\n";
            this._fragmentCode += "nrm " + this._sharedRegisters.normalFragment + ".xyz, " + this._sharedRegisters.normalVarying + "\n" +
                "mov " + this._sharedRegisters.normalFragment + ".w, " + this._sharedRegisters.normalVarying + ".w\n";
            if (this._shader.tangentDependencies > 0) {
                this._sharedRegisters.tangentVarying = this._registerCache.getFreeVarying();
                this._vertexCode += "m33 " + this._sharedRegisters.tangentVarying + ".xyz, " + this._sharedRegisters.animatedTangent + ", " + normalMatrix[0] + "\n" +
                    "mov " + this._sharedRegisters.tangentVarying + ".w, " + this._sharedRegisters.animatedTangent + ".w\n";
            }
        }
        if (!this._shader.usesTangentSpace)
            this._registerCache.removeVertexTempUsage(this._sharedRegisters.animatedNormal);
    };
    /**
     * Reset all the indices to "unused".
     */
    CompilerBase.prototype.pInitRegisterIndices = function () {
        this._shader.pInitRegisterIndices();
        this._sharedRegisters.animatedPosition = this._registerCache.getFreeVertexVectorTemp();
        this._registerCache.addVertexTempUsages(this._sharedRegisters.animatedPosition, 1);
        this._sharedRegisters.animatableAttributes.push(this._registerCache.getFreeVertexAttribute());
        this._sharedRegisters.animationTargetRegisters.push(this._sharedRegisters.animatedPosition);
        this._vertexCode = "";
        this._fragmentCode = "";
        this._postAnimationFragmentCode = "";
        //create commonly shared constant registers
        if (this._shader.usesCommonData || this._shader.normalDependencies > 0) {
            this._sharedRegisters.commons = this._registerCache.getFreeFragmentConstant();
            this._shader.commonsDataIndex = this._sharedRegisters.commons.index * 4;
        }
        //Creates the registers to contain the tangent data.
        //Needs to be created FIRST and in this order (for when using tangent space)
        if (this._shader.tangentDependencies > 0 || this._shader.outputsNormals) {
            this._sharedRegisters.tangentInput = this._registerCache.getFreeVertexAttribute();
            this._shader.tangentIndex = this._sharedRegisters.tangentInput.index;
            this._sharedRegisters.animatedTangent = this._registerCache.getFreeVertexVectorTemp();
            this._registerCache.addVertexTempUsages(this._sharedRegisters.animatedTangent, 1);
            if (this._shader.usesTangentSpace) {
                this._sharedRegisters.bitangent = this._registerCache.getFreeVertexVectorTemp();
                this._registerCache.addVertexTempUsages(this._sharedRegisters.bitangent, 1);
            }
            this._sharedRegisters.animatableAttributes.push(this._sharedRegisters.tangentInput);
            this._sharedRegisters.animationTargetRegisters.push(this._sharedRegisters.animatedTangent);
        }
        if (this._shader.normalDependencies > 0) {
            this._sharedRegisters.normalInput = this._registerCache.getFreeVertexAttribute();
            this._shader.normalIndex = this._sharedRegisters.normalInput.index;
            this._sharedRegisters.animatedNormal = this._registerCache.getFreeVertexVectorTemp();
            this._registerCache.addVertexTempUsages(this._sharedRegisters.animatedNormal, 1);
            this._sharedRegisters.animatableAttributes.push(this._sharedRegisters.normalInput);
            this._sharedRegisters.animationTargetRegisters.push(this._sharedRegisters.animatedNormal);
        }
        if (this._shader.colorDependencies > 0) {
            this._sharedRegisters.colorInput = this._registerCache.getFreeVertexAttribute();
            this._shader.colorBufferIndex = this._sharedRegisters.colorInput.index;
            this._sharedRegisters.colorVarying = this._registerCache.getFreeVarying();
            this._vertexCode += "mov " + this._sharedRegisters.colorVarying + ", " + this._sharedRegisters.colorInput + "\n";
        }
    };
    /**
     * Disposes all resources used by the compiler.
     */
    CompilerBase.prototype.dispose = function () {
        this._registerCache.dispose();
        this._registerCache = null;
        this._sharedRegisters = null;
    };
    Object.defineProperty(CompilerBase.prototype, "vertexCode", {
        /**
         * The generated vertex code.
         */
        get: function () {
            return this._vertexCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompilerBase.prototype, "fragmentCode", {
        /**
         * The generated fragment code.
         */
        get: function () {
            return this._fragmentCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompilerBase.prototype, "postAnimationFragmentCode", {
        /**
         * The generated fragment code.
         */
        get: function () {
            return this._postAnimationFragmentCode;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompilerBase.prototype, "sharedRegisters", {
        /**
         * The shared registers.
         */
        get: function () {
            return this._sharedRegisters;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(CompilerBase.prototype, "registerCache", {
        /**
         * The shared registers.
         */
        get: function () {
            return this._registerCache;
        },
        enumerable: true,
        configurable: true
    });
    return CompilerBase;
}());

/**
 * ShaderBase keeps track of the number of dependencies for "named registers" used across a pass.
 * Named registers are that are not necessarily limited to a single method. They are created by the compiler and
 * passed on to methods. The compiler uses the results to reserve usages through RegisterPool, which can be removed
 * each time a method has been compiled into the shader.
 *
 * @see RegisterPool.addUsage
 */
var ShaderBase = (function () {
    /**
     * Creates a new MethodCompilerVO object.
     */
    function ShaderBase(elementsClass, pass, stage) {
        this._abstractionPool = new Object();
        this._blendFactorSource = exports.ContextGLBlendFactor.ONE;
        this._blendFactorDest = exports.ContextGLBlendFactor.ZERO;
        this._invalidProgram = true;
        this._animationVertexCode = "";
        this._animationFragmentCode = "";
        this.usesBlending = false;
        this.useImageRect = false;
        this.usesCurves = false;
        /**
         * The depth compare mode used to render the renderables using this material.
         *
         * @see away.stagegl.ContextGLCompareMode
         */
        this.depthCompareMode = exports.ContextGLCompareMode.LESS_EQUAL;
        /**
         * Indicate whether the shader should write to the depth buffer or not. Ignored when blending is enabled.
         */
        this.writeDepth = true;
        this._defaultCulling = exports.ContextGLTriangleFace.BACK;
        this._pInverseSceneMatrix = new Float32Array(16);
        //set ambient values to default
        this.ambientR = 0xFF;
        this.ambientG = 0xFF;
        this.ambientB = 0xFF;
        /**
         * Indicates whether there are any dependencies on the world-space position vector.
         */
        this.usesGlobalPosFragment = false;
        /**
         * Indicates whether there are any dependencies on the local position vector.
         */
        this.usesPositionFragment = false;
        /**
         *
         */
        this.imageIndices = new Array();
        this._elementsClass = elementsClass;
        this._pass = pass;
        this._stage = stage;
        this.profile = this._stage.profile;
    }
    Object.defineProperty(ShaderBase.prototype, "pass", {
        get: function () {
            return this._pass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderBase.prototype, "programData", {
        get: function () {
            if (this._invalidProgram)
                this._updateProgram();
            return this._programData;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderBase.prototype, "usesAnimation", {
        get: function () {
            return this._usesAnimation;
        },
        set: function (value) {
            if (this._usesAnimation == value)
                return;
            this._usesAnimation = value;
            this.invalidateProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderBase.prototype, "numUsedVertexConstants", {
        get: function () {
            if (this._invalidProgram)
                this._updateProgram();
            return this._numUsedVertexConstants;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderBase.prototype, "numUsedFragmentConstants", {
        get: function () {
            if (this._invalidProgram)
                this._updateProgram();
            return this._numUsedFragmentConstants;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderBase.prototype, "numUsedStreams", {
        /**
         * The amount of used vertex streams in the vertex code. Used by the animation code generation to know from which index on streams are available.
         */
        get: function () {
            if (this._invalidProgram)
                this._updateProgram();
            return this._numUsedStreams;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShaderBase.prototype, "numUsedTextures", {
        /**
         *
         */
        get: function () {
            if (this._invalidProgram)
                this._updateProgram();
            return this._numUsedTextures;
        },
        enumerable: true,
        configurable: true
    });
    ShaderBase.prototype.getAbstraction = function (asset) {
        return (this._abstractionPool[asset.id] || (this._abstractionPool[asset.id] = new ShaderBase._abstractionClassPool[asset.assetType](asset, this)));
    };
    /**
     *
     * @param image
     */
    ShaderBase.prototype.clearAbstraction = function (texture) {
        this._abstractionPool[texture.id] = null;
    };
    /**
     *
     * @param imageObjectClass
     */
    ShaderBase.registerAbstraction = function (gl_assetClass, assetClass) {
        ShaderBase._abstractionClassPool[assetClass.assetType] = gl_assetClass;
    };
    ShaderBase.prototype.getImageIndex = function (texture, index) {
        if (index === void 0) { index = 0; }
        return this._pass.getImageIndex(texture, index);
    };
    ShaderBase.prototype._includeDependencies = function () {
        this._pass._includeDependencies(this);
        //this.usesCommonData = this.usesCurves || this.usesCommonData;
    };
    /**
     * Factory method to create a concrete compiler object for this object
     *
     * @param elementsClass
     * @param pass
     * @param stage
     * @returns {CompilerBase}
     */
    ShaderBase.prototype.createCompiler = function (elementsClass, pass) {
        return new CompilerBase(elementsClass, pass, this);
    };
    /**
     * Clears dependency counts for all registers. Called when recompiling a pass.
     */
    ShaderBase.prototype.reset = function () {
        this.projectionDependencies = 0;
        this.normalDependencies = 0;
        this.colorDependencies = 0;
        this.viewDirDependencies = 0;
        this.uvDependencies = 0;
        this.secondaryUVDependencies = 0;
        this.globalPosDependencies = 0;
        this.tangentDependencies = 0;
        this.usesCommonData = false;
        this.usesGlobalPosFragment = false;
        this.usesPositionFragment = false;
        this.usesFragmentAnimation = false;
        this.usesTangentSpace = false;
        this.outputsNormals = false;
        this.outputsTangentNormals = false;
    };
    ShaderBase.prototype.pInitRegisterIndices = function () {
        this.commonsDataIndex = -1;
        this.cameraPositionIndex = -1;
        this.curvesIndex = -1;
        this.uvIndex = -1;
        this.uvMatrixIndex = -1;
        this.colorTransformIndex = -1;
        this.secondaryUVIndex = -1;
        this.normalIndex = -1;
        this.colorBufferIndex = -1;
        this.tangentIndex = -1;
        this.sceneMatrixIndex = -1;
        this.sceneNormalMatrixIndex = -1;
        this.jointIndexIndex = -1;
        this.jointWeightIndex = -1;
        this.imageIndices.length = 0;
    };
    /**
     * Initializes the unchanging constant data for this shader object.
     */
    ShaderBase.prototype.initConstantData = function (registerCache) {
        //Updates the amount of used register indices.
        this._numUsedVertexConstants = registerCache.numUsedVertexConstants;
        this._numUsedFragmentConstants = registerCache.numUsedFragmentConstants;
        this._numUsedStreams = registerCache.numUsedStreams;
        this._numUsedTextures = registerCache.numUsedTextures;
        this.vertexConstantData = new Float32Array(registerCache.numUsedVertexConstants * 4);
        this.fragmentConstantData = new Float32Array(registerCache.numUsedFragmentConstants * 4);
        //Initialies viewMatrix
        if (this.viewMatrixIndex >= 0) {
            this.viewMatrix = new _awayjs_core.Matrix3D(new Float32Array(this.vertexConstantData.buffer, this.viewMatrixIndex * 4, 16));
        }
        else if (this.viewMatrix) {
            this.viewMatrix = null;
        }
        //Initialies sceneMatrix
        if (this.sceneMatrixIndex >= 0) {
            this.sceneMatrix = new _awayjs_core.Matrix3D(new Float32Array(this.vertexConstantData.buffer, this.sceneMatrixIndex * 4, 16));
        }
        else if (this.sceneMatrix) {
            this.sceneMatrix = null;
        }
        //Initializes commonly required constant values.
        if (this.commonsDataIndex >= 0) {
            this.fragmentConstantData[this.commonsDataIndex] = .5;
            this.fragmentConstantData[this.commonsDataIndex + 1] = 0;
            this.fragmentConstantData[this.commonsDataIndex + 2] = 1 / 255;
            this.fragmentConstantData[this.commonsDataIndex + 3] = 1;
        }
        //Initializes the default UV transformation matrix.
        if (this.uvMatrixIndex >= 0) {
            this.vertexConstantData[this.uvMatrixIndex] = 1;
            this.vertexConstantData[this.uvMatrixIndex + 1] = 0;
            this.vertexConstantData[this.uvMatrixIndex + 2] = 0;
            this.vertexConstantData[this.uvMatrixIndex + 3] = 0;
            this.vertexConstantData[this.uvMatrixIndex + 4] = 0;
            this.vertexConstantData[this.uvMatrixIndex + 5] = 1;
            this.vertexConstantData[this.uvMatrixIndex + 6] = 0;
            this.vertexConstantData[this.uvMatrixIndex + 7] = 0;
        }
        //Initializes the default colorTransform.
        if (this.colorTransformIndex >= 0) {
            this.fragmentConstantData[this.colorTransformIndex] = 1;
            this.fragmentConstantData[this.colorTransformIndex + 1] = 1;
            this.fragmentConstantData[this.colorTransformIndex + 2] = 1;
            this.fragmentConstantData[this.colorTransformIndex + 3] = 1;
            this.fragmentConstantData[this.colorTransformIndex + 4] = 0;
            this.fragmentConstantData[this.colorTransformIndex + 5] = 0;
            this.fragmentConstantData[this.colorTransformIndex + 6] = 0;
            this.fragmentConstantData[this.colorTransformIndex + 7] = 0;
        }
        if (this.sceneNormalMatrixIndex >= 0) {
            this.sceneNormalMatrix = new _awayjs_core.Matrix3D(new Float32Array(this.vertexConstantData.buffer, this.sceneNormalMatrixIndex * 4, 16));
        }
        else if (this.sceneNormalMatrix) {
            this.sceneNormalMatrix = null;
        }
        if (this.cameraPositionIndex >= 0)
            this.vertexConstantData[this.cameraPositionIndex + 3] = 1;
        // init constant data in pass
        this._pass._initConstantData(this);
        //init constant data in animation
        if (this.usesAnimation)
            this._pass.animationSet.doneAGALCode(this);
    };
    /**
     * The blend mode to use when drawing this renderable. The following blend modes are supported:
     * <ul>
     * <li>BlendMode.NORMAL: No blending, unless the material inherently needs it</li>
     * <li>BlendMode.LAYER: Force blending. This will draw the object the same as NORMAL, but without writing depth writes.</li>
     * <li>BlendMode.MULTIPLY</li>
     * <li>BlendMode.ADD</li>
     * <li>BlendMode.ALPHA</li>
     * </ul>
     */
    ShaderBase.prototype.setBlendMode = function (value) {
        switch (value) {
            case _awayjs_graphics.BlendMode.NORMAL:
                this._blendFactorSource = exports.ContextGLBlendFactor.ONE;
                this._blendFactorDest = exports.ContextGLBlendFactor.ZERO;
                this.usesBlending = false;
                break;
            case _awayjs_graphics.BlendMode.LAYER:
                this._blendFactorSource = exports.ContextGLBlendFactor.SOURCE_ALPHA;
                this._blendFactorDest = exports.ContextGLBlendFactor.ONE_MINUS_SOURCE_ALPHA;
                this.usesBlending = true;
                break;
            case _awayjs_graphics.BlendMode.MULTIPLY:
                this._blendFactorSource = exports.ContextGLBlendFactor.ZERO;
                this._blendFactorDest = exports.ContextGLBlendFactor.SOURCE_COLOR;
                this.usesBlending = true;
                break;
            case _awayjs_graphics.BlendMode.ADD:
                this._blendFactorSource = exports.ContextGLBlendFactor.SOURCE_ALPHA;
                this._blendFactorDest = exports.ContextGLBlendFactor.ONE;
                this.usesBlending = true;
                break;
            case _awayjs_graphics.BlendMode.ALPHA:
                this._blendFactorSource = exports.ContextGLBlendFactor.ZERO;
                this._blendFactorDest = exports.ContextGLBlendFactor.SOURCE_ALPHA;
                this.usesBlending = true;
                break;
            default:
                throw new _awayjs_core.ArgumentError("Unsupported blend mode!");
        }
    };
    /**
     * @inheritDoc
     */
    ShaderBase.prototype._activate = function (projection) {
        this._stage.context.setCulling(this.useBothSides ? exports.ContextGLTriangleFace.NONE : this._defaultCulling, projection.coordinateSystem);
        if (!this.usesTangentSpace && this.cameraPositionIndex >= 0) {
            var pos = projection.transform.concatenatedMatrix3D.position;
            this.vertexConstantData[this.cameraPositionIndex] = pos.x;
            this.vertexConstantData[this.cameraPositionIndex + 1] = pos.y;
            this.vertexConstantData[this.cameraPositionIndex + 2] = pos.z;
        }
        this._stage.context.setDepthTest((this.writeDepth && !this.usesBlending), this.depthCompareMode);
        if (this.usesBlending)
            this._stage.context.setBlendFactors(this._blendFactorSource, this._blendFactorDest);
        this.activeElements = null;
    };
    /**
     * @inheritDoc
     */
    ShaderBase.prototype._deactivate = function () {
        //For the love of god don't remove this if you want your multi-material shadows to not flicker like shit
        this._stage.context.setDepthTest(true, exports.ContextGLCompareMode.LESS_EQUAL);
        this.activeElements = null;
    };
    /**
     *
     *
     * @param renderable
     * @param stage
     * @param camera
     */
    ShaderBase.prototype._setRenderState = function (renderable, projection) {
        if (renderable.sourceEntity.animator)
            renderable.sourceEntity.animator.setRenderState(this, renderable, this._stage, projection);
        var rawData;
        if (this.usesUVTransform) {
            var uvMatrix = renderable.uvMatrix;
            if (uvMatrix) {
                //transpose
                rawData = uvMatrix.rawData;
                this.vertexConstantData[this.uvMatrixIndex] = rawData[0];
                this.vertexConstantData[this.uvMatrixIndex + 1] = rawData[2];
                this.vertexConstantData[this.uvMatrixIndex + 3] = rawData[4];
                this.vertexConstantData[this.uvMatrixIndex + 4] = rawData[1];
                this.vertexConstantData[this.uvMatrixIndex + 5] = rawData[3];
                this.vertexConstantData[this.uvMatrixIndex + 7] = rawData[5];
            }
            else {
                this.vertexConstantData[this.uvMatrixIndex] = 1;
                this.vertexConstantData[this.uvMatrixIndex + 1] = 0;
                this.vertexConstantData[this.uvMatrixIndex + 3] = 0;
                this.vertexConstantData[this.uvMatrixIndex + 4] = 0;
                this.vertexConstantData[this.uvMatrixIndex + 5] = 1;
                this.vertexConstantData[this.uvMatrixIndex + 7] = 0;
            }
        }
        if (this.usesColorTransform) {
            var colorTransform = renderable.sourceEntity._iAssignedColorTransform();
            if (colorTransform) {
                //TODO: AWDParser to write normalised color offsets
                rawData = colorTransform._rawData;
                this.fragmentConstantData[this.colorTransformIndex] = rawData[0];
                this.fragmentConstantData[this.colorTransformIndex + 1] = rawData[1];
                this.fragmentConstantData[this.colorTransformIndex + 2] = rawData[2];
                this.fragmentConstantData[this.colorTransformIndex + 3] = rawData[3];
                this.fragmentConstantData[this.colorTransformIndex + 4] = rawData[4] / 255;
                this.fragmentConstantData[this.colorTransformIndex + 5] = rawData[5] / 255;
                this.fragmentConstantData[this.colorTransformIndex + 6] = rawData[6] / 255;
                this.fragmentConstantData[this.colorTransformIndex + 7] = rawData[7] / 255;
            }
            else {
                this.fragmentConstantData[this.colorTransformIndex] = 1;
                this.fragmentConstantData[this.colorTransformIndex + 1] = 1;
                this.fragmentConstantData[this.colorTransformIndex + 2] = 1;
                this.fragmentConstantData[this.colorTransformIndex + 3] = 1;
                this.fragmentConstantData[this.colorTransformIndex + 4] = 0;
                this.fragmentConstantData[this.colorTransformIndex + 5] = 0;
                this.fragmentConstantData[this.colorTransformIndex + 6] = 0;
                this.fragmentConstantData[this.colorTransformIndex + 7] = 0;
            }
        }
        if (this.sceneNormalMatrixIndex >= 0) {
            this.sceneNormalMatrix.copyFrom(renderable.sourceEntity.transform.inverseConcatenatedMatrix3D);
        }
        if (this.usesTangentSpace && this.cameraPositionIndex >= 0) {
            renderable.sourceEntity.transform.inverseConcatenatedMatrix3D.copyRawDataTo(this._pInverseSceneMatrix);
            var pos = projection.transform.concatenatedMatrix3D.position;
            var x = pos.x;
            var y = pos.y;
            var z = pos.z;
            this.vertexConstantData[this.cameraPositionIndex] = this._pInverseSceneMatrix[0] * x + this._pInverseSceneMatrix[4] * y + this._pInverseSceneMatrix[8] * z + this._pInverseSceneMatrix[12];
            this.vertexConstantData[this.cameraPositionIndex + 1] = this._pInverseSceneMatrix[1] * x + this._pInverseSceneMatrix[5] * y + this._pInverseSceneMatrix[9] * z + this._pInverseSceneMatrix[13];
            this.vertexConstantData[this.cameraPositionIndex + 2] = this._pInverseSceneMatrix[2] * x + this._pInverseSceneMatrix[6] * y + this._pInverseSceneMatrix[10] * z + this._pInverseSceneMatrix[14];
        }
    };
    ShaderBase.prototype.invalidateProgram = function () {
        this._invalidProgram = true;
    };
    ShaderBase.prototype.dispose = function () {
        this._programData.dispose();
        this._programData = null;
    };
    ShaderBase.prototype._updateProgram = function () {
        this._invalidProgram = false;
        var compiler = this.createCompiler(this._elementsClass, this._pass);
        compiler.compile();
        this._calcAnimationCode(compiler.registerCache, compiler.sharedRegisters.shadedTarget, compiler.sharedRegisters);
        //initialise the required shader constants
        this.initConstantData(compiler.registerCache);
        var programData = this._stage.getProgramData(this._animationVertexCode + compiler.vertexCode, compiler.fragmentCode + this._animationFragmentCode + compiler.postAnimationFragmentCode);
        //check program data hasn't changed, keep count of program usages
        if (this._programData != programData) {
            if (this._programData)
                this._programData.dispose();
            this._programData = programData;
            programData.usages++;
        }
    };
    ShaderBase.prototype._calcAnimationCode = function (registerCache, shadedTarget, sharedRegisters) {
        //reset code
        this._animationVertexCode = "";
        this._animationFragmentCode = "";
        //check to see if GPU animation is used
        if (this.usesAnimation) {
            var animationSet = this._pass.animationSet;
            this._animationVertexCode += animationSet.getAGALVertexCode(this, registerCache, sharedRegisters);
            if (this.uvDependencies > 0 && !this.usesUVTransform)
                this._animationVertexCode += animationSet.getAGALUVCode(this, registerCache, sharedRegisters);
            if (this.usesFragmentAnimation)
                this._animationFragmentCode += animationSet.getAGALFragmentCode(this, registerCache, shadedTarget);
        }
        else {
            // simply write attributes to targets, do not animate them
            // projection will pick up on targets[0] to do the projection
            var len = sharedRegisters.animatableAttributes.length;
            for (var i = 0; i < len; ++i)
                this._animationVertexCode += "mov " + sharedRegisters.animationTargetRegisters[i] + ", " + sharedRegisters.animatableAttributes[i] + "\n";
            if (this.uvDependencies > 0 && !this.usesUVTransform)
                this._animationVertexCode += "mov " + sharedRegisters.uvTarget + "," + sharedRegisters.uvSource + "\n";
        }
    };
    ShaderBase.prototype.setVertexConst = function (index, x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 0; }
        index *= 4;
        this.vertexConstantData[index++] = x;
        this.vertexConstantData[index++] = y;
        this.vertexConstantData[index++] = z;
        this.vertexConstantData[index] = w;
    };
    ShaderBase.prototype.setVertexConstFromArray = function (index, data) {
        index *= 4;
        for (var i = 0; i < data.length; i++)
            this.vertexConstantData[index++] = data[i];
    };
    ShaderBase.prototype.setVertexConstFromMatrix = function (index, matrix) {
        index *= 4;
        var rawData = matrix._rawData;
        this.vertexConstantData[index++] = rawData[0];
        this.vertexConstantData[index++] = rawData[4];
        this.vertexConstantData[index++] = rawData[8];
        this.vertexConstantData[index++] = rawData[12];
        this.vertexConstantData[index++] = rawData[1];
        this.vertexConstantData[index++] = rawData[5];
        this.vertexConstantData[index++] = rawData[9];
        this.vertexConstantData[index++] = rawData[13];
        this.vertexConstantData[index++] = rawData[2];
        this.vertexConstantData[index++] = rawData[6];
        this.vertexConstantData[index++] = rawData[10];
        this.vertexConstantData[index++] = rawData[14];
        this.vertexConstantData[index++] = rawData[3];
        this.vertexConstantData[index++] = rawData[7];
        this.vertexConstantData[index++] = rawData[11];
        this.vertexConstantData[index] = rawData[15];
    };
    ShaderBase.prototype.setFragmentConst = function (index, x, y, z, w) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (w === void 0) { w = 0; }
        index *= 4;
        this.fragmentConstantData[index++] = x;
        this.fragmentConstantData[index++] = y;
        this.fragmentConstantData[index++] = z;
        this.fragmentConstantData[index] = w;
    };
    return ShaderBase;
}());
ShaderBase._abstractionClassPool = new Object();

/**
 * PassBase provides an abstract base class for material shader passes. A material pass constitutes at least
 * a render call per required renderable.
 */
var PassBase = (function (_super) {
    __extends(PassBase, _super);
    /**
     * Creates a new PassBase object.
     */
    function PassBase(material, materialPool) {
        var _this = _super.call(this) || this;
        _this._preserveAlpha = true;
        _this._forceSeparateMVP = false;
        _this._material = material;
        _this._elementsClass = materialPool.elementsClass;
        _this._stage = materialPool.materialGroup.stage;
        return _this;
    }
    Object.defineProperty(PassBase.prototype, "shader", {
        get: function () {
            return this._shader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PassBase.prototype, "samplers", {
        get: function () {
            return this._material.samplers;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PassBase.prototype, "images", {
        get: function () {
            return this._material.images;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PassBase.prototype, "style", {
        get: function () {
            return this._material.material.style;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PassBase.prototype, "animationSet", {
        get: function () {
            return this._material.material.animationSet;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PassBase.prototype, "preserveAlpha", {
        /**
         * Indicates whether the output alpha value should remain unchanged compared to the material's original alpha.
         */
        get: function () {
            return this._preserveAlpha;
        },
        set: function (value) {
            if (this._preserveAlpha == value)
                return;
            this._preserveAlpha = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(PassBase.prototype, "forceSeparateMVP", {
        /**
         * Indicates whether the screen projection should be calculated by forcing a separate scene matrix and
         * view-projection matrix. This is used to prevent rounding errors when using multiple passes with different
         * projection code.
         */
        get: function () {
            return this._forceSeparateMVP;
        },
        set: function (value) {
            if (this._forceSeparateMVP == value)
                return;
            this._forceSeparateMVP = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    PassBase.prototype.getImageIndex = function (texture, index) {
        if (index === void 0) { index = 0; }
        return this._material.getImageIndex(texture, index);
    };
    /**
     * Marks the shader program as invalid, so it will be recompiled before the next render.
     */
    PassBase.prototype.invalidate = function () {
        this._shader.invalidateProgram();
        this.dispatchEvent(new PassEvent(PassEvent.INVALIDATE, this));
    };
    /**
     * Cleans up any resources used by the current object.
     * @param deep Indicates whether other resources should be cleaned up, that could potentially be shared across different instances.
     */
    PassBase.prototype.dispose = function () {
        this._material = null;
        this._elementsClass = null;
        this._stage = null;
        if (this._shader) {
            this._shader.dispose();
            this._shader = null;
        }
    };
    /**
     * Renders the current pass. Before calling pass, activatePass needs to be called with the same index.
     * @param pass The pass used to render the renderable.
     * @param renderable The IRenderable object to draw.
     * @param stage The Stage object used for rendering.
     * @param entityCollector The EntityCollector object that contains the visible scene data.
     * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
     * camera.viewProjection as it includes the scaling factors when rendering to textures.
     *
     * @internal
     */
    PassBase.prototype._setRenderState = function (renderable, projection) {
        this._shader._setRenderState(renderable, projection);
    };
    /**
     * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
     * calling pass. Before activating a pass, the previously used pass needs to be deactivated.
     * @param stage The Stage object which is currently used for rendering.
     * @param camera The camera from which the scene is viewed.
     * @private
     */
    PassBase.prototype._activate = function (projection) {
        this._shader._activate(projection);
    };
    /**
     * Clears the render state for the pass. This needs to be called before activating another pass.
     * @param stage The Stage used for rendering
     *
     * @private
     */
    PassBase.prototype._deactivate = function () {
        this._shader._deactivate();
    };
    PassBase.prototype._includeDependencies = function (shader) {
        this._material._includeDependencies(shader);
        if (this._forceSeparateMVP)
            this._shader.globalPosDependencies++;
    };
    PassBase.prototype._initConstantData = function (shader) {
    };
    PassBase.prototype._getVertexCode = function (registerCache, sharedRegisters) {
        return "";
    };
    PassBase.prototype._getFragmentCode = function (registerCache, sharedRegisters) {
        return "";
    };
    PassBase.prototype._getPostAnimationFragmentCode = function (registerCache, sharedRegisters) {
        return "";
    };
    PassBase.prototype._getNormalVertexCode = function (registerCache, sharedRegisters) {
        return "";
    };
    PassBase.prototype._getNormalFragmentCode = function (registerCache, sharedRegisters) {
        return "";
    };
    return PassBase;
}(_awayjs_core.EventDispatcher));

/**
 * BasicMaterialPass forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var BasicMaterialPass = (function (_super) {
    __extends(BasicMaterialPass, _super);
    function BasicMaterialPass(material, materialPool) {
        var _this = _super.call(this, material, materialPool) || this;
        _this._diffuseR = 1;
        _this._diffuseG = 1;
        _this._diffuseB = 1;
        _this._diffuseA = 1;
        _this._shader = new ShaderBase(materialPool.elementsClass, _this, _this._stage);
        _this.invalidate();
        return _this;
    }
    BasicMaterialPass.prototype._includeDependencies = function (shader) {
        _super.prototype._includeDependencies.call(this, shader);
        if (this._textureVO != null)
            shader.uvDependencies++;
    };
    BasicMaterialPass.prototype.invalidate = function () {
        _super.prototype.invalidate.call(this);
        this._textureVO = this._material.material.getTextureAt(0) ? this._shader.getAbstraction(this._material.material.getTextureAt(0)) : null;
    };
    BasicMaterialPass.prototype.dispose = function () {
        if (this._textureVO) {
            this._textureVO.onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, this._material.material.getTextureAt(0)));
            this._textureVO = null;
        }
        _super.prototype.dispose.call(this);
    };
    /**
     * @inheritDoc
     */
    BasicMaterialPass.prototype._getFragmentCode = function (regCache, sharedReg) {
        var code = "";
        var alphaReg;
        if (this.preserveAlpha) {
            alphaReg = regCache.getFreeFragmentSingleTemp();
            regCache.addFragmentTempUsages(alphaReg, 1);
            code += "mov " + alphaReg + ", " + sharedReg.shadedTarget + ".w\n";
        }
        var targetReg = sharedReg.shadedTarget;
        if (this._textureVO != null) {
            code += this._textureVO._getFragmentCode(targetReg, regCache, sharedReg, sharedReg.uvVarying);
            if (this._shader.alphaThreshold > 0) {
                var cutOffReg = regCache.getFreeFragmentConstant();
                this._fragmentConstantsIndex = cutOffReg.index * 4;
                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" + "kil " + targetReg + ".w\n" + "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
            }
        }
        else if (this._shader.colorBufferIndex != -1) {
            code += "mov " + targetReg + ", " + sharedReg.colorVarying + "\n";
        }
        else {
            var diffuseInputReg = regCache.getFreeFragmentConstant();
            this._fragmentConstantsIndex = diffuseInputReg.index * 4;
            code += "mov " + targetReg + ", " + diffuseInputReg + "\n";
        }
        if (this.preserveAlpha) {
            code += "mul " + sharedReg.shadedTarget + ".w, " + sharedReg.shadedTarget + ".w, " + alphaReg + "\n";
            regCache.removeFragmentTempUsage(alphaReg);
        }
        return code;
    };
    BasicMaterialPass.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        if (this._textureVO != null)
            this._textureVO._setRenderState(renderable);
    };
    /**
     * @inheritDoc
     */
    BasicMaterialPass.prototype._activate = function (projection) {
        _super.prototype._activate.call(this, projection);
        if (this._textureVO != null) {
            this._textureVO.activate();
            if (this._shader.alphaThreshold > 0)
                this._shader.fragmentConstantData[this._fragmentConstantsIndex] = this._shader.alphaThreshold;
        }
        else if (this._shader.colorBufferIndex == -1) {
            var index = this._fragmentConstantsIndex;
            var data = this._shader.fragmentConstantData;
            data[index] = this._diffuseR;
            data[index + 1] = this._diffuseG;
            data[index + 2] = this._diffuseB;
            data[index + 3] = this._diffuseA;
        }
    };
    return BasicMaterialPass;
}(PassBase));

/**
 *
 * @class away.pool.Passes
 */
var GL_MaterialBase = (function (_super) {
    __extends(GL_MaterialBase, _super);
    function GL_MaterialBase(material, materialPool) {
        var _this = _super.call(this, material, materialPool) || this;
        _this.usages = 0;
        _this._forceSeparateMVP = false;
        _this._usesAnimation = true;
        _this._invalidAnimation = true;
        _this._invalidRender = true;
        _this._invalidImages = true;
        _this._passes = new Array();
        _this._imageIndices = new Object();
        _this._pRequiresBlending = false;
        _this.images = new Array();
        _this.samplers = new Array();
        _this._onInvalidateAnimationDelegate = function (event) { return _this.onInvalidateAnimation(event); };
        _this._onInvalidatePassesDelegate = function (event) { return _this.onInvalidatePasses(event); };
        _this.materialID = material.id;
        _this._material = material;
        _this._elementsClass = materialPool.elementsClass;
        _this._stage = materialPool.materialGroup.stage;
        _this._material.addEventListener(_awayjs_graphics.MaterialEvent.INVALIDATE_ANIMATION, _this._onInvalidateAnimationDelegate);
        _this._material.addEventListener(_awayjs_graphics.MaterialEvent.INVALIDATE_PASSES, _this._onInvalidatePassesDelegate);
        _this._onPassInvalidateDelegate = function (event) { return _this.onPassInvalidate(event); };
        return _this;
    }
    Object.defineProperty(GL_MaterialBase.prototype, "style", {
        get: function () {
            return this._material.style;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MaterialBase.prototype, "requiresBlending", {
        /**
         * Indicates whether or not the renderable requires alpha blending during rendering.
         */
        get: function () {
            return this._pRequiresBlending;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MaterialBase.prototype, "renderOrderId", {
        get: function () {
            if (this._invalidAnimation)
                this._updateAnimation();
            return this._renderOrderId;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MaterialBase.prototype, "passes", {
        get: function () {
            if (this._invalidAnimation)
                this._updateAnimation();
            return this._passes;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MaterialBase.prototype, "material", {
        get: function () {
            return this._material;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MaterialBase.prototype, "numImages", {
        get: function () {
            if (this._invalidImages)
                this._updateImages();
            return this._numImages;
        },
        enumerable: true,
        configurable: true
    });
    GL_MaterialBase.prototype._includeDependencies = function (shader) {
        this._elementsClass._includeDependencies(shader);
        shader.alphaThreshold = this._material.alphaThreshold;
        shader.useImageRect = this._material.imageRect;
        shader.usesCurves = this._material.curves;
        if (this._material instanceof _awayjs_graphics.MaterialBase) {
            var material = this._material;
            shader.useAlphaPremultiplied = material.alphaPremultiplied;
            shader.useBothSides = material.bothSides;
            shader.usesUVTransform = material.animateUVs;
            shader.usesColorTransform = material.useColorTransform;
        }
    };
    GL_MaterialBase.prototype.getImageIndex = function (texture, index) {
        if (index === void 0) { index = 0; }
        if (this._invalidImages)
            this._updateImages();
        return this._imageIndices[texture.id][index];
    };
    /**
     *
     */
    GL_MaterialBase.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        var len = this._passes.length;
        for (var i = 0; i < len; i++) {
            this._passes[i].removeEventListener(PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
            this._passes[i].dispose();
        }
        this._passes = null;
        this._material.removeEventListener(_awayjs_graphics.MaterialEvent.INVALIDATE_ANIMATION, this._onInvalidateAnimationDelegate);
        this._material.removeEventListener(_awayjs_graphics.MaterialEvent.INVALIDATE_PASSES, this._onInvalidatePassesDelegate);
        this._material = null;
        this._elementsClass = null;
        this._stage = null;
    };
    /**
     *
     */
    GL_MaterialBase.prototype.onInvalidate = function (event) {
        _super.prototype.onInvalidate.call(this, event);
        this._invalidRender = true;
        this._invalidAnimation = true;
    };
    /**
     *
     */
    GL_MaterialBase.prototype.onInvalidatePasses = function (event) {
        var len = this._passes.length;
        for (var i = 0; i < len; i++)
            this._passes[i].invalidate();
        this._invalidAnimation = true;
        this._invalidImages = true;
    };
    /**
     *
     */
    GL_MaterialBase.prototype.onInvalidateAnimation = function (event) {
        this._invalidAnimation = true;
    };
    /**
     *
     * @param surface
     */
    GL_MaterialBase.prototype._updateAnimation = function () {
        if (this._invalidRender)
            this._pUpdateRender();
        this._invalidAnimation = false;
        var usesAnimation = this._getEnabledGPUAnimation();
        var renderOrderId = 0;
        var mult = 1;
        var shader;
        var len = this._passes.length;
        for (var i = 0; i < len; i++) {
            shader = this._passes[i].shader;
            shader.usesAnimation = usesAnimation;
            renderOrderId += shader.programData.id * mult;
            mult *= 1000;
        }
        if (this._usesAnimation != usesAnimation) {
            this._usesAnimation = usesAnimation;
            var renderables = this._material.iOwners;
            var numOwners = renderables.length;
            for (var j = 0; j < numOwners; j++)
                renderables[j].invalidateElements();
        }
        this._renderOrderId = renderOrderId;
    };
    GL_MaterialBase.prototype._updateImages = function () {
        this._invalidImages = false;
        var numTextures = this._material.getNumTextures();
        var texture;
        var numImages;
        var images;
        var image;
        var sampler;
        var index = 0;
        for (var i = 0; i < numTextures; i++) {
            texture = this._material.getTextureAt(i);
            numImages = texture.getNumImages();
            images = this._imageIndices[texture.id] = new Array();
            for (var j = 0; j < numImages; j++) {
                image = texture.getImageAt(j) || (this._material.style ? this._material.style.getImageAt(texture, j) : null) || _awayjs_graphics.DefaultMaterialManager.getDefaultImage2D();
                this.images[index] = this._stage.getAbstraction(image);
                sampler = texture.getSamplerAt(j) || (this._material.style ? this._material.style.getSamplerAt(texture, j) : null) || _awayjs_graphics.DefaultMaterialManager.getDefaultSampler();
                this.samplers[index] = this._stage.getAbstraction(sampler);
                images[j] = index++;
            }
        }
        this._numImages = index;
    };
    /**
     * Performs any processing that needs to occur before any of its passes are used.
     *
     * @private
     */
    GL_MaterialBase.prototype._pUpdateRender = function () {
        this._invalidRender = false;
        //overrride to update shader object properties
    };
    /**
     * Removes a pass from the surface.
     * @param pass The pass to be removed.
     */
    GL_MaterialBase.prototype._pRemovePass = function (pass) {
        pass.removeEventListener(PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
        this._passes.splice(this._passes.indexOf(pass), 1);
    };
    /**
     * Removes all passes from the surface
     */
    GL_MaterialBase.prototype._pClearPasses = function () {
        var len = this._passes.length;
        for (var i = 0; i < len; ++i)
            this._passes[i].removeEventListener(PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
        this._passes.length = 0;
    };
    /**
     * Adds a pass to the surface
     * @param pass
     */
    GL_MaterialBase.prototype._pAddPass = function (pass) {
        this._passes.push(pass);
        pass.addEventListener(PassEvent.INVALIDATE, this._onPassInvalidateDelegate);
    };
    /**
     * Listener for when a pass's shader code changes. It recalculates the render order id.
     */
    GL_MaterialBase.prototype.onPassInvalidate = function (event) {
        this._invalidAnimation = true;
    };
    /**
     * test if animation will be able to run on gpu BEFORE compiling materials
     * test if the shader objects supports animating the animation set in the vertex shader
     * if any object using this material fails to support accelerated animations for any of the shader objects,
     * we should do everything on cpu (otherwise we have the cost of both gpu + cpu animations)
     */
    GL_MaterialBase.prototype._getEnabledGPUAnimation = function () {
        if (this._material.animationSet) {
            this._material.animationSet.resetGPUCompatibility();
            var entities = this._material.iOwners;
            var numOwners = entities.length;
            var len = this._passes.length;
            var shader;
            for (var i = 0; i < len; i++) {
                shader = this._passes[i].shader;
                shader.usesAnimation = false;
                for (var j = 0; j < numOwners; j++)
                    if (entities[j].animator)
                        entities[j].animator.testGPUCompatibility(shader);
            }
            return !this._material.animationSet.usesCPU;
        }
        return false;
    };
    return GL_MaterialBase;
}(_awayjs_core.AbstractionBase));

/**
 * RenderMaterialObject forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var GL_BasicMaterial = (function (_super) {
    __extends(GL_BasicMaterial, _super);
    function GL_BasicMaterial(material, materialPool) {
        var _this = _super.call(this, material, materialPool) || this;
        _this._basicMaterial = material;
        _this._pAddPass(_this._pass = new BasicMaterialPass(_this, materialPool));
        return _this;
    }
    GL_BasicMaterial.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._basicMaterial = null;
    };
    /**
     * @inheritDoc
     */
    GL_BasicMaterial.prototype._pUpdateRender = function () {
        _super.prototype._pUpdateRender.call(this);
        this._pRequiresBlending = (this._basicMaterial.blendMode != _awayjs_graphics.BlendMode.NORMAL || this._basicMaterial.alphaBlending || (this._basicMaterial.colorTransform && this._basicMaterial.colorTransform.alphaMultiplier < 1));
        this._pass.preserveAlpha = this._basicMaterial.preserveAlpha; //this._pRequiresBlending;
        this._pass.shader.setBlendMode((this._basicMaterial.blendMode == _awayjs_graphics.BlendMode.NORMAL && this._pRequiresBlending) ? _awayjs_graphics.BlendMode.LAYER : this._basicMaterial.blendMode);
        //this._pass.forceSeparateMVP = false;
    };
    return GL_BasicMaterial;
}(GL_MaterialBase));

/**
 * GL_MaterialPassBase provides an abstract base class for material shader passes. A material pass constitutes at least
 * a render call per required renderable.
 */
var GL_MaterialPassBase = (function (_super) {
    __extends(GL_MaterialPassBase, _super);
    function GL_MaterialPassBase() {
        return _super.apply(this, arguments) || this;
    }
    Object.defineProperty(GL_MaterialPassBase.prototype, "shader", {
        get: function () {
            return this._shader;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MaterialPassBase.prototype, "animationSet", {
        get: function () {
            return this._material.animationSet;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Marks the shader program as invalid, so it will be recompiled before the next render.
     */
    GL_MaterialPassBase.prototype.invalidate = function () {
        this._shader.invalidateProgram();
        this.dispatchEvent(new PassEvent(PassEvent.INVALIDATE, this));
    };
    GL_MaterialPassBase.prototype.dispose = function () {
        if (this._shader) {
            this._shader.dispose();
            this._shader = null;
        }
    };
    /**
     * Renders the current pass. Before calling pass, activatePass needs to be called with the same index.
     * @param pass The pass used to render the renderable.
     * @param renderable The IRenderable object to draw.
     * @param stage The Stage object used for rendering.
     * @param entityCollector The EntityCollector object that contains the visible scene data.
     * @param viewProjection The view-projection matrix used to project to the screen. This is not the same as
     * camera.viewProjection as it includes the scaling factors when rendering to textures.
     *
     * @internal
     */
    GL_MaterialPassBase.prototype._setRenderState = function (renderable, projection) {
        this._shader._setRenderState(renderable, projection);
    };
    /**
     * Sets the render state for the pass that is independent of the rendered object. This needs to be called before
     * calling pass. Before activating a pass, the previously used pass needs to be deactivated.
     * @param stage The Stage object which is currently used for rendering.
     * @param camera The camera from which the scene is viewed.
     * @private
     */
    GL_MaterialPassBase.prototype._activate = function (projection) {
        this._shader._activate(projection);
    };
    /**
     * Clears the render state for the pass. This needs to be called before activating another pass.
     * @param stage The Stage used for rendering
     *
     * @private
     */
    GL_MaterialPassBase.prototype._deactivate = function () {
        this._shader._deactivate();
    };
    GL_MaterialPassBase.prototype._initConstantData = function (shader) {
    };
    GL_MaterialPassBase.prototype._getVertexCode = function (registerCache, sharedRegisters) {
        return "";
    };
    GL_MaterialPassBase.prototype._getFragmentCode = function (registerCache, sharedRegisters) {
        return "";
    };
    GL_MaterialPassBase.prototype._getPostAnimationFragmentCode = function (registerCache, sharedRegisters) {
        return "";
    };
    GL_MaterialPassBase.prototype._getNormalVertexCode = function (registerCache, sharedRegisters) {
        return "";
    };
    GL_MaterialPassBase.prototype._getNormalFragmentCode = function (registerCache, sharedRegisters) {
        return "";
    };
    return GL_MaterialPassBase;
}(GL_MaterialBase));

/**
 * @class away.pool.RenderablePool
 */
var RenderablePool = (function () {
    /**
     * //TODO
     *
     * @param materialClassGL
     */
    function RenderablePool(entity, materialGroup) {
        this._abstractionPool = new Object();
        this._entity = entity;
        this._materialGroup = materialGroup;
    }
    Object.defineProperty(RenderablePool.prototype, "entity", {
        /**
         *
         * @returns {IEntity}
         */
        get: function () {
            return this._entity;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(RenderablePool.prototype, "materialGroup", {
        /**
         *
         * @returns {MaterialGroupBase}
         */
        get: function () {
            return this._materialGroup;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * //TODO
     *
     * @param renderable
     * @returns GL_RenderableBase
     */
    RenderablePool.prototype.getAbstraction = function (renderable) {
        return this._abstractionPool[renderable.id] || (this._abstractionPool[renderable.id] = new RenderablePool._abstractionClassPool[renderable.assetType](renderable, this));
    };
    /**
     *
     * @param renderable
     */
    RenderablePool.prototype.clearAbstraction = function (renderable) {
        this._abstractionPool[renderable.id] = null;
    };
    /**
     *
     * @param imageObjectClass
     */
    RenderablePool.registerAbstraction = function (renderableClass, assetClass) {
        RenderablePool._abstractionClassPool[assetClass.assetType] = renderableClass;
    };
    return RenderablePool;
}());
RenderablePool._abstractionClassPool = new Object();

/**
 * @class away.pool.MaterialPool
 */
var MaterialPool = (function () {
    /**
     * //TODO
     *
     * @param materialClassGL
     */
    function MaterialPool(elementsClass, materialGroup) {
        this._abstractionPool = new Object();
        this._elementsClass = elementsClass;
        this._materialGroup = materialGroup;
        this._abstractionClassPool = materialGroup.abstractionClassPool;
    }
    Object.defineProperty(MaterialPool.prototype, "elementsClass", {
        get: function () {
            return this._elementsClass;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialPool.prototype, "materialGroup", {
        get: function () {
            return this._materialGroup;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * //TODO
     *
     * @param elementsOwner
     * @returns IElements
     */
    MaterialPool.prototype.getAbstraction = function (material) {
        return (this._abstractionPool[material.id] || (this._abstractionPool[material.id] = new this._abstractionClassPool[material.assetType](material, this)));
    };
    /**
     * //TODO
     *
     * @param elementsOwner
     */
    MaterialPool.prototype.clearAbstraction = function (material) {
        delete this._abstractionPool[material.id];
    };
    return MaterialPool;
}());

/**
 * @class away.pool.MaterialGroupBase
 */
var MaterialGroupBase = (function () {
    /**
     * //TODO
     *
     * @param materialClassGL
     */
    function MaterialGroupBase(stage, abstractionClassPool) {
        this._abstractionClassPool = new Object();
        this._materialPools = new Object();
        this._renderablePools = new Object();
        this._stage = stage;
        this._abstractionClassPool = abstractionClassPool;
    }
    Object.defineProperty(MaterialGroupBase.prototype, "stage", {
        get: function () {
            return this._stage;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MaterialGroupBase.prototype, "abstractionClassPool", {
        get: function () {
            return this._abstractionClassPool;
        },
        enumerable: true,
        configurable: true
    });
    MaterialGroupBase.prototype.getMaterialPool = function (elements) {
        return this._materialPools[elements.elementsType] || (this._materialPools[elements.elementsType] = new MaterialPool(elements.elementsClass, this));
    };
    MaterialGroupBase.prototype.getRenderablePool = function (entity) {
        return this._renderablePools[entity.id] || (this._renderablePools[entity.id] = new RenderablePool(entity, this));
    };
    return MaterialGroupBase;
}());

/**
 * @class RenderableListItem
 */
var GL_RenderableBase = (function (_super) {
    __extends(GL_RenderableBase, _super);
    /**
     *
     * @param renderable
     * @param sourceEntity
     * @param surface
     * @param renderer
     */
    function GL_RenderableBase(renderable, renderablePool) {
        var _this = _super.call(this, renderable, renderablePool) || this;
        _this._count = 0;
        _this._offset = 0;
        _this._elementsDirty = true;
        _this._materialDirty = true;
        /**
         *
         */
        _this.images = new Array();
        /**
         *
         */
        _this.samplers = new Array();
        _this._onInvalidateMaterialDelegate = function (event) { return _this._onInvalidateMaterial(event); };
        _this._onInvalidateElementsDelegate = function (event) { return _this.onInvalidateElements(event); };
        //store references
        _this.sourceEntity = renderablePool.entity;
        _this._materialGroup = renderablePool.materialGroup;
        _this._stage = _this._materialGroup.stage;
        _this.renderable = renderable;
        _this.renderable.addEventListener(_awayjs_graphics.RenderableEvent.INVALIDATE_MATERIAL, _this._onInvalidateMaterialDelegate);
        _this.renderable.addEventListener(_awayjs_graphics.RenderableEvent.INVALIDATE_ELEMENTS, _this._onInvalidateElementsDelegate);
        return _this;
    }
    Object.defineProperty(GL_RenderableBase.prototype, "elementsGL", {
        /**
         *
         * @returns {GL_ElementsBase}
         */
        get: function () {
            if (this._elementsDirty)
                this._updateElements();
            return this._elementsGL;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_RenderableBase.prototype, "materialGL", {
        /**
         *
         * @returns {GL_MaterialBase}
         */
        get: function () {
            if (this._materialDirty)
                this._updateMaterial();
            return this._materialGL;
        },
        enumerable: true,
        configurable: true
    });
    GL_RenderableBase.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this.next = null;
        this.masksConfig = null;
        this.renderSceneTransform = null;
        this.sourceEntity = null;
        this._materialGroup = null;
        this._stage = null;
        this.renderable.removeEventListener(_awayjs_graphics.RenderableEvent.INVALIDATE_MATERIAL, this._onInvalidateMaterialDelegate);
        this.renderable.removeEventListener(_awayjs_graphics.RenderableEvent.INVALIDATE_ELEMENTS, this._onInvalidateElementsDelegate);
        this.renderable = null;
        this._materialGL.usages--;
        if (!this._materialGL.usages)
            this._materialGL.onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, this._materialGL.material));
        this._materialGL = null;
        this._elementsGL = null;
    };
    GL_RenderableBase.prototype.onInvalidateElements = function (event) {
        this._elementsDirty = true;
    };
    GL_RenderableBase.prototype._onInvalidateMaterial = function (event) {
        this._materialDirty = true;
    };
    GL_RenderableBase.prototype._getElements = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    GL_RenderableBase.prototype._getMaterial = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * Renders an object to the current render target.
     *
     * @private
     */
    GL_RenderableBase.prototype._iRender = function (pass, projection) {
        this._setRenderState(pass, projection);
        this._elementsGL.draw(this, pass.shader, projection, this._count, this._offset);
    };
    GL_RenderableBase.prototype._setRenderState = function (pass, projection) {
        if (this._elementsDirty)
            this._updateElements();
        pass._setRenderState(this, projection);
        if (pass.shader.activeElements != this._elementsGL) {
            pass.shader.activeElements = this._elementsGL;
            this._elementsGL._setRenderState(this, pass.shader, projection);
        }
    };
    /**
     * //TODO
     *
     * @private
     */
    GL_RenderableBase.prototype._updateElements = function () {
        this._elementsGL = this._getElements();
        this._elementsDirty = false;
    };
    GL_RenderableBase.prototype._updateMaterial = function () {
        var materialGL = this._getMaterial();
        if (this._materialGL != materialGL) {
            if (this._materialGL) {
                this._materialGL.usages--;
                //dispose current materialGL object
                if (!this._materialGL.usages)
                    this._materialGL.onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, this._materialGL.material));
            }
            this._materialGL = materialGL;
            this._materialGL.usages++;
        }
        //create a cache of image & sampler objects for the renderable
        var numImages = materialGL.numImages;
        var style = this.renderable.style || this.sourceEntity.style;
        var material = this._materialGL.material;
        this.images.length = numImages;
        this.samplers.length = numImages;
        this.uvMatrix = style ? style.uvMatrix : material.style ? material.style.uvMatrix : null;
        var numTextures = this._materialGL.material.getNumTextures();
        var texture;
        var numImages;
        var image;
        var sampler;
        var index;
        for (var i = 0; i < numTextures; i++) {
            texture = material.getTextureAt(i);
            numImages = texture.getNumImages();
            for (var j = 0; j < numImages; j++) {
                index = materialGL.getImageIndex(texture, j);
                image = style ? style.getImageAt(texture, j) : null;
                this.images[index] = image ? this._stage.getAbstraction(image) : null;
                sampler = style ? style.getSamplerAt(texture, j) : null;
                this.samplers[index] = sampler ? this._stage.getAbstraction(sampler) : null;
            }
        }
        this._materialDirty = false;
    };
    return GL_RenderableBase;
}(_awayjs_core.AbstractionBase));

/**
 * @class away.pool.GL_ShapeRenderable
 */
var GL_ShapeRenderable = (function (_super) {
    __extends(GL_ShapeRenderable, _super);
    /**
     * //TODO
     *
     * @param renderablePool
     * @param shape
     * @param level
     * @param indexOffset
     */
    function GL_ShapeRenderable(shape, renderablePool) {
        var _this = _super.call(this, shape, renderablePool) || this;
        _this.shape = shape;
        return _this;
    }
    GL_ShapeRenderable.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this.shape = null;
    };
    /**
     *
     * @returns {ElementsBase}
     * @protected
     */
    GL_ShapeRenderable.prototype._getElements = function () {
        this._offset = this.shape.offset;
        this._count = this.shape.count;
        return this._stage.getAbstraction((this.sourceEntity.animator) ? this.sourceEntity.animator.getRenderableElements(this, this.shape.elements) : this.shape.elements);
    };
    GL_ShapeRenderable.prototype._getMaterial = function () {
        return this._materialGroup.getMaterialPool(this.elementsGL).getAbstraction(this.shape.material || this.sourceEntity.material || _awayjs_graphics.DefaultMaterialManager.getDefaultMaterial(this.renderable));
    };
    return GL_ShapeRenderable;
}(GL_RenderableBase));

/**
 *
 * @class away.pool.GL_TextureBaseBase
 */
var GL_TextureBase = (function (_super) {
    __extends(GL_TextureBase, _super);
    function GL_TextureBase(texture, shader) {
        var _this = _super.call(this, texture, shader) || this;
        _this._texture = texture;
        _this._shader = shader;
        _this._stage = shader._stage;
        return _this;
    }
    /**
     *
     */
    GL_TextureBase.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._texture = null;
        this._shader = null;
        this._stage = null;
    };
    GL_TextureBase.prototype._getFragmentCode = function (targetReg, regCache, sharedReg, inputReg) {
        if (inputReg === void 0) { inputReg = null; }
        throw new _awayjs_core.AbstractMethodError();
    };
    GL_TextureBase.prototype._setRenderState = function (renderable) {
        //overidden for state logic
    };
    GL_TextureBase.prototype.activate = function () {
        //overridden for activation logic
    };
    GL_TextureBase.prototype.getTextureReg = function (imageIndex, regCache, sharedReg) {
        var index = this._shader.imageIndices.indexOf(imageIndex); //todo: collapse the index based on duplicate image objects to save registrations
        if (index == -1) {
            var textureReg = regCache.getFreeTextureReg();
            sharedReg.textures.push(textureReg);
            this._shader.imageIndices.push(imageIndex);
            return textureReg;
        }
        return sharedReg.textures[index];
    };
    return GL_TextureBase;
}(_awayjs_core.AbstractionBase));

/**
 *
 * @class away.pool.GL_Single2DTexture
 */
var GL_Single2DTexture = (function (_super) {
    __extends(GL_Single2DTexture, _super);
    function GL_Single2DTexture(single2DTexture, shader) {
        var _this = _super.call(this, single2DTexture, shader) || this;
        _this._single2DTexture = single2DTexture;
        return _this;
    }
    GL_Single2DTexture.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._single2DTexture = null;
    };
    /**
     *
     * @param shader
     * @param regCache
     * @param targetReg The register in which to store the sampled colour.
     * @param uvReg The uv coordinate vector with which to sample the texture map.
     * @returns {string}
     * @private
     */
    GL_Single2DTexture.prototype._getFragmentCode = function (targetReg, regCache, sharedReg, inputReg) {
        var code = "";
        var wrap = "wrap";
        var format = ""; //this.getFormatString(this._single2DTexture.image2D);
        var filter = "linear,miplinear";
        var temp;
        //modify depending on mapping mode
        if (this._single2DTexture.mappingMode == _awayjs_graphics.MappingMode.RADIAL) {
            temp = regCache.getFreeFragmentVectorTemp();
            code += "mul " + temp + ".xy, " + inputReg + ", " + inputReg + "\n";
            code += "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n";
            code += "sub " + temp + ".y, " + temp + ".y, " + temp + ".y\n";
            code += "sqt " + temp + ".x, " + temp + ".x, " + temp + ".x\n";
            inputReg = temp;
        }
        //handles texture atlasing
        if (this._shader.useImageRect) {
            var samplerReg = regCache.getFreeFragmentConstant();
            this._samplerIndex = samplerReg.index * 4;
            temp = regCache.getFreeFragmentVectorTemp();
            code += "mul " + temp + ", " + inputReg + ", " + samplerReg + ".xy\n";
            code += "add " + temp + ", " + temp + ", " + samplerReg + ".zw\n";
            inputReg = temp;
        }
        this._imageIndex = this._shader.getImageIndex(this._single2DTexture, 0);
        var textureReg = this.getTextureReg(this._imageIndex, regCache, sharedReg);
        this._textureIndex = textureReg.index;
        code += "tex " + targetReg + ", " + inputReg + ", " + textureReg + " <2d," + filter + "," + format + wrap + ">\n";
        return code;
    };
    GL_Single2DTexture.prototype.activate = function () {
        var sampler = this._shader.pass.samplers[this._imageIndex];
        sampler.activate(this._textureIndex);
        var image = this._shader.pass.images[this._imageIndex];
        image.activate(this._textureIndex, sampler._sampler.mipmap);
        if (this._shader.useImageRect) {
            var index = this._samplerIndex;
            var data = this._shader.fragmentConstantData;
            if (!sampler._sampler.imageRect) {
                data[index] = 1;
                data[index + 1] = 1;
                data[index + 2] = 0;
                data[index + 3] = 0;
            }
            else {
                data[index] = sampler._sampler.imageRect.width;
                data[index + 1] = sampler._sampler.imageRect.height;
                data[index + 2] = sampler._sampler.imageRect.x;
                data[index + 3] = sampler._sampler.imageRect.y;
            }
        }
    };
    GL_Single2DTexture.prototype._setRenderState = function (renderable) {
        var sampler = renderable.samplers[this._imageIndex];
        if (sampler)
            sampler.activate(this._textureIndex);
        var image = renderable.images[this._imageIndex];
        if (image)
            image.activate(this._textureIndex, sampler._sampler.mipmap);
        if (this._shader.useImageRect && sampler) {
            var index = this._samplerIndex;
            var data = this._shader.fragmentConstantData;
            if (!sampler._sampler.imageRect) {
                data[index] = 1;
                data[index + 1] = 1;
                data[index + 2] = 0;
                data[index + 3] = 0;
            }
            else {
                data[index] = sampler._sampler.imageRect.width;
                data[index + 1] = sampler._sampler.imageRect.height;
                data[index + 2] = sampler._sampler.imageRect.x;
                data[index + 3] = sampler._sampler.imageRect.y;
            }
        }
    };
    return GL_Single2DTexture;
}(GL_TextureBase));

/**
 *
 * @class away.pool.TextureDataBase
 */
var GL_SingleCubeTexture = (function (_super) {
    __extends(GL_SingleCubeTexture, _super);
    function GL_SingleCubeTexture(singleCubeTexture, shader) {
        var _this = _super.call(this, singleCubeTexture, shader) || this;
        _this._singleCubeTexture = singleCubeTexture;
        return _this;
    }
    GL_SingleCubeTexture.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._singleCubeTexture = null;
    };
    GL_SingleCubeTexture.prototype._includeDependencies = function (includeInput) {
        if (includeInput === void 0) { includeInput = true; }
        if (includeInput)
            this._shader.usesPositionFragment = true;
    };
    /**
     *
     * @param shader
     * @param regCache
     * @param targetReg The register in which to store the sampled colour.
     * @param uvReg The direction vector with which to sample the cube map.
     * @returns {string}
     * @private
     */
    GL_SingleCubeTexture.prototype._getFragmentCode = function (targetReg, regCache, sharedReg, inputReg) {
        var format = ""; //this.getFormatString(this._singleCubeTexture.imageCube);
        var filter = "linear,miplinear";
        this._imageIndex = this._shader.getImageIndex(this._singleCubeTexture, 0);
        var textureReg = this.getTextureReg(this._imageIndex, regCache, sharedReg);
        this._textureIndex = textureReg.index;
        return "tex " + targetReg + ", " + inputReg + ", " + textureReg + " <cube," + format + filter + ">\n";
    };
    GL_SingleCubeTexture.prototype.activate = function () {
        var sampler = this._shader.pass.samplers[this._imageIndex];
        if (sampler)
            sampler.activate(this._textureIndex);
        if (this._shader.pass.images[this._imageIndex])
            this._shader.pass.images[this._imageIndex].activate(this._textureIndex, sampler._sampler.mipmap);
    };
    GL_SingleCubeTexture.prototype._setRenderState = function (renderable) {
        var sampler = renderable.samplers[this._imageIndex];
        if (sampler)
            sampler.activate(this._textureIndex);
        if (renderable.images[this._imageIndex] && sampler)
            renderable.images[this._imageIndex].activate(this._textureIndex, sampler._sampler.mipmap);
    };
    return GL_SingleCubeTexture;
}(GL_TextureBase));

exports.AGALMiniAssembler = AGALMiniAssembler;
exports.Flags = Flags;
exports.FS = FS;
exports.Opcode = Opcode;
exports.OpcodeMap = OpcodeMap;
exports.Part = Part;
exports.RegMap = RegMap;
exports.Sampler = Sampler;
exports.SamplerMap = SamplerMap;
exports.AGALTokenizer = AGALTokenizer;
exports.AGLSLParser = AGLSLParser;
exports.Description = Description;
exports.Destination = Destination;
exports.Header = Header;
exports.Mapping = Mapping;
exports.OpLUT = OpLUT;
exports.Token = Token;
exports.AnimationRegisterData = AnimationRegisterData;
exports.AnimationSetBase = AnimationSetBase;
exports.AnimatorBase = AnimatorBase;
exports.GL_AttributesBuffer = GL_AttributesBuffer;
exports.SamplerState = SamplerState;
exports.GL_ElementsBase = GL_ElementsBase;
exports.GL_TriangleElements = GL_TriangleElements;
exports.AnimationSetError = AnimationSetError;
exports.StageEvent = StageEvent;
exports.AnimatorEvent = AnimatorEvent;
exports.PassEvent = PassEvent;
exports.ContextFlash = ContextFlash;
exports.CubeTextureFlash = CubeTextureFlash;
exports.IndexBufferFlash = IndexBufferFlash;
exports.OpCodes = OpCodes;
exports.ProgramFlash = ProgramFlash;
exports.ResourceBaseFlash = ResourceBaseFlash;
exports.TextureFlash = TextureFlash;
exports.VertexBufferFlash = VertexBufferFlash;
exports.ContextGLES = ContextGLES;
exports.GLESConnector = GLESConnector;
exports.GLESAssetBase = GLESAssetBase;
exports.CubeTextureGLES = CubeTextureGLES;
exports.IndexBufferGLES = IndexBufferGLES;
exports.ProgramGLES = ProgramGLES;
exports.TextureBaseGLES = TextureBaseGLES;
exports.TextureGLES = TextureGLES;
exports.VertexBufferGLES = VertexBufferGLES;
exports.GL_BitmapImage2D = GL_BitmapImage2D;
exports.GL_ExternalImage2D = GL_ExternalImage2D;
exports.GL_BitmapImageCube = GL_BitmapImageCube;
exports.GL_Image2D = GL_Image2D;
exports.GL_ImageBase = GL_ImageBase;
exports.GL_ImageCube = GL_ImageCube;
exports.GL_RenderImage2D = GL_RenderImage2D;
exports.GL_RenderImageCube = GL_RenderImageCube;
exports.GL_Sampler2D = GL_Sampler2D;
exports.GL_SamplerBase = GL_SamplerBase;
exports.GL_SamplerCube = GL_SamplerCube;
exports.ProgramData = ProgramData;
exports.ProgramDataPool = ProgramDataPool;
exports.StageManager = StageManager;
exports.BasicMaterialPass = BasicMaterialPass;
exports.PassBase = PassBase;
exports.GL_BasicMaterial = GL_BasicMaterial;
exports.GL_MaterialBase = GL_MaterialBase;
exports.GL_MaterialPassBase = GL_MaterialPassBase;
exports.MaterialGroupBase = MaterialGroupBase;
exports.MaterialPool = MaterialPool;
exports.GL_ShapeRenderable = GL_ShapeRenderable;
exports.GL_RenderableBase = GL_RenderableBase;
exports.RenderablePool = RenderablePool;
exports.CompilerBase = CompilerBase;
exports.RegisterPool = RegisterPool;
exports.ShaderBase = ShaderBase;
exports.ShaderRegisterCache = ShaderRegisterCache;
exports.ShaderRegisterData = ShaderRegisterData;
exports.ShaderRegisterElement = ShaderRegisterElement;
exports.ContextSoftware = ContextSoftware;
exports.IndexBufferSoftware = IndexBufferSoftware;
exports.ProgramSoftware = ProgramSoftware;
exports.ProgramVOSoftware = ProgramVOSoftware;
exports.SoftwareSamplerState = SoftwareSamplerState;
exports.TextureSoftware = TextureSoftware;
exports.VertexBufferSoftware = VertexBufferSoftware;
exports.GL_Single2DTexture = GL_Single2DTexture;
exports.GL_SingleCubeTexture = GL_SingleCubeTexture;
exports.GL_TextureBase = GL_TextureBase;
exports.ContextWebGL = ContextWebGL;
exports.CubeTextureWebGL = CubeTextureWebGL;
exports.IndexBufferWebGL = IndexBufferWebGL;
exports.ProgramWebGL = ProgramWebGL;
exports.TextureBaseWebGL = TextureBaseWebGL;
exports.TextureWebGL = TextureWebGL;
exports.VertexBufferWebGL = VertexBufferWebGL;
exports.Stage = Stage;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(7), __webpack_require__(9), __webpack_require__(13), __webpack_require__(12), __webpack_require__(10)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/core', '@awayjs/graphics', '@awayjs/stage', '@awayjs/renderer', '@awayjs/scene'], factory) :
    (factory((global.AwayjsMaterials = global.AwayjsMaterials || {}),global.AwayjsCore,global.AwayjsGraphics,global.AwayjsStage,global.AwayjsRenderer,global.AwayjsScene));
}(this, (function (exports,_awayjs_core,_awayjs_graphics,_awayjs_stage,_awayjs_renderer,_awayjs_scene) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

/**
 * ShadingMethodBase provides an abstract base method for shading methods, used by compiled passes to compile
 * the final shading program.
 */
var ShadingMethodBase = (function (_super) {
    __extends(ShadingMethodBase, _super);
    /**
     * Create a new ShadingMethodBase object.
     */
    function ShadingMethodBase() {
        var _this = _super.call(this) || this;
        _this._textures = new Array();
        _this._owners = new Array();
        _this._counts = new Array();
        return _this;
    }
    /**
     * Cleans up any resources used by the current object.
     */
    ShadingMethodBase.prototype.dispose = function () {
    };
    ShadingMethodBase.prototype.iAddOwner = function (owner) {
        //a method can be used more than once in the same material, so we check for this
        var index = this._owners.indexOf(owner);
        if (index != -1) {
            this._counts[index]++;
        }
        else {
            this._owners.push(owner);
            this._counts.push(1);
            //add textures
            var len = this._textures.length;
            for (var i = 0; i < len; i++)
                owner.addTexture(this._textures[i]);
        }
    };
    ShadingMethodBase.prototype.iRemoveOwner = function (owner) {
        var index = this._owners.indexOf(owner);
        if (this._counts[index] != 1) {
            this._counts[index]--;
        }
        else {
            this._owners.splice(index, 1);
            this._counts.splice(index, 1);
            //remove textures
            var len = this._textures.length;
            for (var i = 0; i < len; i++)
                owner.removeTexture(this._textures[i]);
        }
    };
    /**
     *
     */
    ShadingMethodBase.prototype.iAddTexture = function (texture) {
        this._textures.push(texture);
        var len = this._owners.length;
        for (var i = 0; i < len; i++)
            this._owners[i].addTexture(texture);
    };
    /**
     *
     */
    ShadingMethodBase.prototype.iRemoveTexture = function (texture) {
        this._textures.splice(this._textures.indexOf(texture), 1);
        var len = this._owners.length;
        for (var i = 0; i < len; i++)
            this._owners[i].removeTexture(texture);
    };
    /**
     * Marks the shader program as invalid, so it will be recompiled before the next render.
     *
     * @internal
     */
    ShadingMethodBase.prototype.invalidateShaderProgram = function () {
        this.invalidate();
        this.dispatchEvent(new _awayjs_renderer.ShadingMethodEvent(_awayjs_renderer.ShadingMethodEvent.SHADER_INVALIDATED));
    };
    /**
     * Copies the state from a ShadingMethodBase object into the current object.
     */
    ShadingMethodBase.prototype.copyFrom = function (method) {
    };
    return ShadingMethodBase;
}(_awayjs_core.AssetBase));

/**
 * AmbientBasicMethod provides the default shading method for uniform ambient lighting.
 */
var AmbientBasicMethod = (function (_super) {
    __extends(AmbientBasicMethod, _super);
    /**
     * Creates a new AmbientBasicMethod object.
     */
    function AmbientBasicMethod() {
        var _this = _super.call(this) || this;
        _this._alpha = 1;
        _this._strength = 1;
        return _this;
    }
    Object.defineProperty(AmbientBasicMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AmbientBasicMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmbientBasicMethod.prototype, "strength", {
        /**
         * The strength of the ambient reflection of the surface.
         */
        get: function () {
            return this._strength;
        },
        set: function (value) {
            if (this._strength == value)
                return;
            this._strength = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmbientBasicMethod.prototype, "alpha", {
        /**
         * The alpha component of the surface.
         */
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            if (this._alpha == value)
                return;
            this._alpha = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmbientBasicMethod.prototype, "texture", {
        /**
         * The texture to use to define the diffuse reflection color per texel.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture == value)
                return;
            if (this._texture)
                this.iRemoveTexture(this._texture);
            this._texture = value;
            if (this._texture)
                this.iAddTexture(this._texture);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    AmbientBasicMethod.prototype.copyFrom = function (method) {
        var m = method;
        var b = m;
    };
    return AmbientBasicMethod;
}(ShadingMethodBase));
AmbientBasicMethod.assetType = "[asset AmbientBasicMethod]";

/**
 * DiffuseBasicMethod provides the default shading method for Lambert (dot3) diffuse lighting.
 */
var DiffuseBasicMethod = (function (_super) {
    __extends(DiffuseBasicMethod, _super);
    /**
     * Creates a new DiffuseBasicMethod object.
     */
    function DiffuseBasicMethod() {
        var _this = _super.call(this) || this;
        _this._multiply = true;
        _this._ambientColorR = 1;
        _this._ambientColorG = 1;
        _this._ambientColorB = 1;
        _this._color = 0xffffff;
        _this._colorR = 1;
        _this._colorG = 1;
        _this._colorB = 1;
        return _this;
    }
    Object.defineProperty(DiffuseBasicMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return DiffuseBasicMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseBasicMethod.prototype, "multiply", {
        /**
         * Set internally if diffuse color component multiplies or replaces the ambient color
         */
        get: function () {
            return this._multiply;
        },
        set: function (value) {
            if (this._multiply == value)
                return;
            this._multiply = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseBasicMethod.prototype, "color", {
        /**
         * The color of the diffuse reflection when not using a texture.
         */
        get: function () {
            return this._color;
        },
        set: function (value) {
            if (this._color == value)
                return;
            this._color = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseBasicMethod.prototype, "texture", {
        /**
         * The texture to use to define the diffuse reflection color per texel.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture == value)
                return;
            if (this._texture)
                this.iRemoveTexture(this._texture);
            this._texture = value;
            if (this._texture)
                this.iAddTexture(this._texture);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.dispose = function () {
        this._texture = null;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicMethod.prototype.copyFrom = function (method) {
        var diff = method;
        this.texture = diff.texture;
        this.multiply = diff.multiply;
        this.color = diff.color;
    };
    return DiffuseBasicMethod;
}(ShadingMethodBase));
DiffuseBasicMethod.assetType = "[asset DiffuseBasicMethod]";

/**
 * NormalBasicMethod is the default method for standard tangent-space normal mapping.
 */
var NormalBasicMethod = (function (_super) {
    __extends(NormalBasicMethod, _super);
    /**
     * Creates a new NormalBasicMethod object.
     */
    function NormalBasicMethod(texture) {
        if (texture === void 0) { texture = null; }
        var _this = _super.call(this) || this;
        _this._texture = texture;
        if (_this._texture)
            _this.iAddTexture(_this._texture);
        return _this;
    }
    Object.defineProperty(NormalBasicMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return NormalBasicMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalBasicMethod.prototype, "texture", {
        /**
         * A texture to modulate the direction of the surface for each texel (normal map). The default normal method expects
         * tangent-space normal maps, but others could expect object-space maps.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture == value)
                return;
            if (this._texture)
                this.iRemoveTexture(this._texture);
            this._texture = value;
            if (this._texture)
                this.iAddTexture(this._texture);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.copyFrom = function (method) {
        var s = method;
        var bnm = method;
        if (bnm.texture != null)
            this.texture = bnm.texture;
    };
    /**
     * @inheritDoc
     */
    NormalBasicMethod.prototype.dispose = function () {
        if (this._texture)
            this._texture = null;
    };
    return NormalBasicMethod;
}(ShadingMethodBase));
NormalBasicMethod.assetType = "[asset NormalBasicMethod]";

/**
 * SpecularBasicMethod provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
 * version of Phong specularity).
 */
var SpecularBasicMethod = (function (_super) {
    __extends(SpecularBasicMethod, _super);
    /**
     * Creates a new SpecularBasicMethod object.
     */
    function SpecularBasicMethod() {
        var _this = _super.call(this) || this;
        _this._gloss = 50;
        _this._strength = 1;
        _this._color = 0xffffff;
        return _this;
    }
    Object.defineProperty(SpecularBasicMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return SpecularBasicMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularBasicMethod.prototype, "gloss", {
        /**
         * The glossiness of the material (sharpness of the specular highlight).
         */
        get: function () {
            return this._gloss;
        },
        set: function (value) {
            if (this._gloss == value)
                return;
            this._gloss = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularBasicMethod.prototype, "strength", {
        /**
         * The overall strength of the specular highlights.
         */
        get: function () {
            return this._strength;
        },
        set: function (value) {
            if (this._strength == value)
                return;
            this._strength = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularBasicMethod.prototype, "color", {
        /**
         * The colour of the specular reflection of the surface.
         */
        get: function () {
            return this._color;
        },
        set: function (value) {
            if (this._color == value)
                return;
            this._color = value;
            // specular is now either enabled or disabled
            if (this._color == 0 || value == 0)
                this.invalidateShaderProgram();
            else
                this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularBasicMethod.prototype, "texture", {
        /**
         * A texture that defines the strength of specular reflections for each texel in the red channel,
         * and the gloss factor (sharpness) in the green channel. You can use Specular2DTexture if you want to easily set
         * specular and gloss maps from grayscale images, but correctly authored images are preferred.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture == value)
                return;
            if (this._texture)
                this.iRemoveTexture(this._texture);
            this._texture = value;
            if (this._texture)
                this.iAddTexture(this._texture);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.dispose = function () {
        this._texture = null;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicMethod.prototype.copyFrom = function (method) {
        var m = method;
        var bsm = method;
        var spec = bsm; //SpecularBasicMethod(method);
        this.texture = spec.texture;
        this.strength = spec.strength;
        this.color = spec.color;
        this.gloss = spec.gloss;
    };
    return SpecularBasicMethod;
}(ShadingMethodBase));
SpecularBasicMethod.assetType = "[asset SpecularBasicMethod]";

var MethodMaterialMode = (function () {
    function MethodMaterialMode() {
    }
    return MethodMaterialMode;
}());
/**
 *
 */
MethodMaterialMode.SINGLE_PASS = "singlePass";
/**
 *
 */
MethodMaterialMode.MULTI_PASS = "multiPass";

/**
 * MethodMaterial forms an abstract base class for the default shaded materials provided by Stage,
 * using material methods to define their appearance.
 */
var MethodMaterial = (function (_super) {
    __extends(MethodMaterial, _super);
    function MethodMaterial(imageColor, alpha) {
        if (imageColor === void 0) { imageColor = null; }
        if (alpha === void 0) { alpha = 1; }
        var _this = _super.call(this, imageColor, alpha) || this;
        _this._effectMethods = new Array();
        _this._enableLightFallOff = true;
        _this._specularLightSources = 0x01;
        _this._diffuseLightSources = 0x03;
        _this._ambientMethod = new AmbientBasicMethod();
        _this._diffuseMethod = new DiffuseBasicMethod();
        _this._normalMethod = new NormalBasicMethod();
        _this._specularMethod = new SpecularBasicMethod();
        _this._depthCompareMode = _awayjs_stage.ContextGLCompareMode.LESS_EQUAL;
        _this._mode = MethodMaterialMode.SINGLE_PASS;
        //add default methods owners
        _this._ambientMethod.iAddOwner(_this);
        _this._diffuseMethod.iAddOwner(_this);
        _this._normalMethod.iAddOwner(_this);
        _this._specularMethod.iAddOwner(_this);
        _this._onLightChangeDelegate = function (event) { return _this.onLightsChange(event); };
        //set a texture if an image is present
        if (imageColor instanceof _awayjs_graphics.Image2D)
            _this._ambientMethod.texture = new _awayjs_graphics.Single2DTexture();
        return _this;
    }
    Object.defineProperty(MethodMaterial.prototype, "assetType", {
        /**
         *
         */
        get: function () {
            return MethodMaterial.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "lightPicker", {
        /**
         * The light picker used by the material to provide lights to the material if it supports lighting.
         *
         * @see LightPickerBase
         * @see StaticLightPicker
         */
        get: function () {
            return this._pLightPicker;
        },
        set: function (value) {
            if (this._pLightPicker == value)
                return;
            if (this._pLightPicker)
                this._pLightPicker.removeEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onLightChangeDelegate);
            this._pLightPicker = value;
            if (this._pLightPicker)
                this._pLightPicker.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onLightChangeDelegate);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "enableLightFallOff", {
        /**
         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
         * compatibility for constrained mode.
         */
        get: function () {
            return this._enableLightFallOff;
        },
        set: function (value) {
            if (this._enableLightFallOff == value)
                return;
            this._enableLightFallOff = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "diffuseLightSources", {
        /**
         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
         * and/or light probes for diffuse reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._diffuseLightSources;
        },
        set: function (value) {
            if (this._diffuseLightSources == value)
                return;
            this._diffuseLightSources = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "specularLightSources", {
        /**
         * Define which light source types to use for specular reflections. This allows choosing between regular lights
         * and/or light probes for specular reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._specularLightSources;
        },
        set: function (value) {
            if (this._specularLightSources == value)
                return;
            this._specularLightSources = value;
            this.invalidatePasses();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "mode", {
        get: function () {
            return this._mode;
        },
        set: function (value) {
            if (this._mode == value)
                return;
            this._mode = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "depthCompareMode", {
        /**
         * The depth compare mode used to render the renderables using this material.
         *
         * @see away.stagegl.ContextGLCompareMode
         */
        get: function () {
            return this._depthCompareMode;
        },
        set: function (value) {
            if (this._depthCompareMode == value)
                return;
            this._depthCompareMode = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "ambientMethod", {
        /**
         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
         */
        get: function () {
            return this._ambientMethod;
        },
        set: function (value) {
            if (this._ambientMethod == value)
                return;
            if (this._ambientMethod)
                this._ambientMethod.iRemoveOwner(this);
            this._ambientMethod = value;
            if (this._ambientMethod)
                this._ambientMethod.iAddOwner(this);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "shadowMethod", {
        /**
         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
         */
        get: function () {
            return this._shadowMethod;
        },
        set: function (value) {
            if (this._shadowMethod == value)
                return;
            if (this._shadowMethod)
                this._shadowMethod.iRemoveOwner(this);
            this._shadowMethod = value;
            if (this._shadowMethod)
                this._shadowMethod.iAddOwner(this);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "diffuseMethod", {
        /**
         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
         */
        get: function () {
            return this._diffuseMethod;
        },
        set: function (value) {
            if (this._diffuseMethod == value)
                return;
            if (this._diffuseMethod)
                this._diffuseMethod.iRemoveOwner(this);
            this._diffuseMethod = value;
            if (this._diffuseMethod)
                this._diffuseMethod.iAddOwner(this);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "specularMethod", {
        /**
         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
         */
        get: function () {
            return this._specularMethod;
        },
        set: function (value) {
            if (this._specularMethod == value)
                return;
            if (this._specularMethod)
                this._specularMethod.iRemoveOwner(this);
            this._specularMethod = value;
            if (this._specularMethod)
                this._specularMethod.iAddOwner(this);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "normalMethod", {
        /**
         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
         */
        get: function () {
            return this._normalMethod;
        },
        set: function (value) {
            if (this._normalMethod == value)
                return;
            if (this._normalMethod)
                this._normalMethod.iRemoveOwner(this);
            this._normalMethod = value;
            if (this._normalMethod)
                this._normalMethod.iAddOwner(this);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodMaterial.prototype, "numEffectMethods", {
        get: function () {
            return this._effectMethods.length;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
     * methods added prior.
     */
    MethodMaterial.prototype.addEffectMethod = function (method) {
        method.iAddOwner(this);
        this._effectMethods.push(method);
        this.invalidate();
    };
    /**
     * Returns the method added at the given index.
     * @param index The index of the method to retrieve.
     * @return The method at the given index.
     */
    MethodMaterial.prototype.getEffectMethodAt = function (index) {
        return this._effectMethods[index];
    };
    /**
     * Adds an effect method at the specified index amongst the methods already added to the material. Effect
     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
     * etc. The method will be applied to the result of the methods with a lower index.
     */
    MethodMaterial.prototype.addEffectMethodAt = function (method, index) {
        method.iAddOwner(this);
        this._effectMethods.splice(index, 0, method);
        this.invalidate();
    };
    /**
     * Removes an effect method from the material.
     * @param method The method to be removed.
     */
    MethodMaterial.prototype.removeEffectMethod = function (method) {
        method.iRemoveOwner(this);
        this._effectMethods.splice(this._effectMethods.indexOf(method), 1);
        this.invalidate();
    };
    /**
     * Called when the light picker's configuration changed.
     */
    MethodMaterial.prototype.onLightsChange = function (event) {
        this.invalidate();
    };
    return MethodMaterial;
}(_awayjs_graphics.MaterialBase));
MethodMaterial.assetType = "[materials MethodMaterial]";

/**
 * MethodVO contains data for a given shader object for the use within a single material.
 * This allows shader methods to be shared across materials while their non-public state differs.
 */
var ChunkVO = (function () {
    function ChunkVO() {
    }
    return ChunkVO;
}());

/**
 * CompositeChunkBase provides a base class for diffuse methods that wrap a diffuse method to alter the
 * calculated diffuse reflection strength.
 */
var CompositeChunkBase = (function (_super) {
    __extends(CompositeChunkBase, _super);
    /**
     * Creates a new <code>CompositeChunkBase</code> object.
     *
     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.
     * @param baseMethod The base diffuse method on which this method's shading is based.
     */
    function CompositeChunkBase(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this.chunkVO = new ChunkVO();
        _this._baseChunk = shader.getAbstraction(method.baseMethod);
        return _this;
    }
    CompositeChunkBase.prototype._isUsed = function () {
        return true;
    };
    CompositeChunkBase.prototype._usesTangentSpace = function () {
        return this._baseChunk._usesTangentSpace();
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._initVO = function (chunkVO) {
        this._baseChunk._initVO(chunkVO);
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._initConstants = function () {
        this._baseChunk._initConstants();
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._activate = function () {
        this._baseChunk._activate();
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._setRenderState = function (renderable, projection) {
        this._baseChunk._setRenderState(renderable, projection);
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._deactivate = function () {
        this._baseChunk._deactivate();
        this._invalid = false;
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._getVertexCode = function (registerCache, sharedRegisters) {
        return this._baseChunk._getVertexCode(registerCache, sharedRegisters);
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        return this._baseChunk._getFragmentCode(targetReg, registerCache, sharedRegisters);
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._reset = function (chunkVO) {
        this._baseChunk._reset(chunkVO);
        this._invalid = true;
        this._cleanCompilationData();
    };
    /**
     * @inheritDoc
     */
    CompositeChunkBase.prototype._cleanCompilationData = function () {
        this._baseChunk._cleanCompilationData();
    };
    return CompositeChunkBase;
}(_awayjs_core.AbstractionBase));

/**
 * LightingCompositeBase provides a base class for diffuse methods that wrap a diffuse method to alter the
 * calculated diffuse reflection strength.
 */
var LightingCompositeChunk = (function (_super) {
    __extends(LightingCompositeChunk, _super);
    function LightingCompositeChunk() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    LightingCompositeChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        return this._baseChunk._getFragmentPreLightingCode(registerCache, sharedRegisters);
    };
    /**
     * @inheritDoc
     */
    LightingCompositeChunk.prototype._getFragmentCodePerLight = function (lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = this._baseChunk._getFragmentCodePerLight(lightDirReg, lightColReg, registerCache, sharedRegisters);
        this._totalLightColorReg = this._baseChunk._totalLightColorReg;
        return code;
    };
    /**
     * @inheritDoc
     */
    LightingCompositeChunk.prototype._getFragmentCodePerProbe = function (cubeMapReg, weightRegister, registerCache, sharedRegisters) {
        var code = this._baseChunk._getFragmentCodePerProbe(cubeMapReg, weightRegister, registerCache, sharedRegisters);
        this._totalLightColorReg = this._baseChunk._totalLightColorReg;
        return code;
    };
    return LightingCompositeChunk;
}(CompositeChunkBase));

/**
 * AmbientDepthMethod provides a debug method to visualise depth maps
 */
var AmbientDepthMethod = (function (_super) {
    __extends(AmbientDepthMethod, _super);
    /**
     * Creates a new AmbientDepthMethod object.
     */
    function AmbientDepthMethod(castingLight) {
        var _this = _super.call(this) || this;
        _this._castingLight = castingLight;
        castingLight.shadowsEnabled = true;
        _this._shadowMapper = castingLight.shadowMapper;
        _this.iAddTexture(castingLight.shadowMapper.depthMap);
        return _this;
    }
    Object.defineProperty(AmbientDepthMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return AmbientDepthMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AmbientDepthMethod.prototype, "castingLight", {
        /**
         * The light casting the shadows.
         */
        get: function () {
            return this._castingLight;
        },
        enumerable: true,
        configurable: true
    });
    return AmbientDepthMethod;
}(AmbientBasicMethod));
AmbientDepthMethod.assetType = "[asset AmbientDepthMethod]";

/**
 * CompositeMethodBase provides a base class for diffuse methods that wrap a diffuse method to alter the
 * calculated diffuse reflection strength.
 */
var CompositeMethodBase = (function (_super) {
    __extends(CompositeMethodBase, _super);
    /**
     * Creates a new <code>CompositeMethodBase</code> object.
     *
     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.
     * @param baseMethod The base diffuse method on which this method's shading is based.
     */
    function CompositeMethodBase(baseMethod) {
        if (baseMethod === void 0) { baseMethod = null; }
        var _this = _super.call(this) || this;
        _this._onShaderInvalidatedDelegate = function (event) { return _this.onShaderInvalidated(event); };
        _this._baseMethod = baseMethod || _this.createBaseMethod();
        _this._baseMethod.addEventListener(_awayjs_renderer.ShadingMethodEvent.SHADER_INVALIDATED, _this._onShaderInvalidatedDelegate);
        return _this;
    }
    Object.defineProperty(CompositeMethodBase.prototype, "baseMethod", {
        /**
         * The base diffuse method on which this method's shading is based.
         */
        get: function () {
            return this._baseMethod;
        },
        set: function (value) {
            if (this._baseMethod == value)
                return;
            this._baseMethod.removeEventListener(_awayjs_renderer.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            this._baseMethod = value;
            this._baseMethod.addEventListener(_awayjs_renderer.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    CompositeMethodBase.prototype.createBaseMethod = function () {
        throw new _awayjs_core.AbstractMethodError();
    };
    CompositeMethodBase.prototype.iAddOwner = function (owner) {
        _super.prototype.iAddOwner.call(this, owner);
        this._baseMethod.iAddOwner(owner);
    };
    CompositeMethodBase.prototype.iRemoveOwner = function (owner) {
        _super.prototype.iRemoveOwner.call(this, owner);
        this._baseMethod.iRemoveOwner(owner);
    };
    /**
     * @inheritDoc
     */
    CompositeMethodBase.prototype.dispose = function () {
        this._baseMethod.removeEventListener(_awayjs_renderer.ShadingMethodEvent.SHADER_INVALIDATED, this._onShaderInvalidatedDelegate);
    };
    /**
     * Called when the base method's shader code is invalidated.
     */
    CompositeMethodBase.prototype.onShaderInvalidated = function (event) {
        this.invalidateShaderProgram();
    };
    return CompositeMethodBase;
}(ShadingMethodBase));

/**
 * DiffuseCompositeMethod provides a base class for diffuse methods that wrap a diffuse method to alter the
 * calculated diffuse reflection strength.
 */
var DiffuseCompositeMethod = (function (_super) {
    __extends(DiffuseCompositeMethod, _super);
    /**
     * Creates a new <code>DiffuseCompositeMethod</code> object.
     *
     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.
     * @param baseMethod The base diffuse method on which this method's shading is based.
     */
    function DiffuseCompositeMethod(baseMethod) {
        if (baseMethod === void 0) { baseMethod = null; }
        return _super.call(this, baseMethod) || this;
    }
    DiffuseCompositeMethod.prototype.createBaseMethod = function () {
        return new DiffuseBasicMethod();
    };
    Object.defineProperty(DiffuseCompositeMethod.prototype, "texture", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._baseMethod.texture;
        },
        set: function (value) {
            this._baseMethod.texture = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseCompositeMethod.prototype, "color", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._baseMethod.color;
        },
        set: function (value) {
            this._baseMethod.color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseCompositeMethod.prototype, "multiply", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._baseMethod.multiply;
        },
        set: function (value) {
            this._baseMethod.multiply = value;
        },
        enumerable: true,
        configurable: true
    });
    return DiffuseCompositeMethod;
}(CompositeMethodBase));

/**
 * DiffuseCelMethod provides a shading method to add diffuse cel (cartoon) shading.
 */
var DiffuseCelMethod = (function (_super) {
    __extends(DiffuseCelMethod, _super);
    /**
     * Creates a new DiffuseCelMethod object.
     * @param levels The amount of shadow gradations.
     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.
     */
    function DiffuseCelMethod(levels, smoothness, baseMethod) {
        if (levels === void 0) { levels = 3; }
        if (smoothness === void 0) { smoothness = 0.1; }
        if (baseMethod === void 0) { baseMethod = null; }
        var _this = _super.call(this, baseMethod) || this;
        _this._levels = levels;
        _this._smoothness = smoothness;
        return _this;
    }
    Object.defineProperty(DiffuseCelMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return DiffuseCelMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseCelMethod.prototype, "levels", {
        /**
         * The amount of shadow gradations.
         */
        get: function () {
            return this._levels;
        },
        set: function (value) {
            this._levels = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseCelMethod.prototype, "smoothness", {
        /**
         * The smoothness of the edge between 2 shading levels.
         */
        get: function () {
            return this._smoothness;
        },
        set: function (value) {
            this._smoothness = value;
        },
        enumerable: true,
        configurable: true
    });
    return DiffuseCelMethod;
}(DiffuseCompositeMethod));
DiffuseCelMethod.assetType = "[asset DiffuseCelMethod]";

/**
 * DiffuseGradientMethod is an alternative to DiffuseBasicMethod in which the shading can be modulated with a gradient
 * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude
 * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate
 * scattered light within the skin attributing to the final colour)
 */
var DiffuseGradientMethod = (function (_super) {
    __extends(DiffuseGradientMethod, _super);
    /**
     * Creates a new DiffuseGradientMethod object.
     * @param gradient A texture that contains the light colour based on the angle. This can be used to change
     * the light colour due to subsurface scattering when the surface faces away from the light.
     */
    function DiffuseGradientMethod(gradient) {
        var _this = _super.call(this) || this;
        _this._gradient = gradient;
        _this.iAddTexture(_this._gradient);
        return _this;
    }
    Object.defineProperty(DiffuseGradientMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return DiffuseGradientMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseGradientMethod.prototype, "gradient", {
        /**
         * A texture that contains the light colour based on the angle. This can be used to change the light colour
         * due to subsurface scattering when the surface faces away from the light.
         */
        get: function () {
            return this._gradient;
        },
        set: function (value) {
            if (this._gradient == value)
                return;
            if (this._gradient)
                this.iRemoveTexture(this._gradient);
            this._gradient = value;
            if (this._gradient)
                this.iAddTexture(this._gradient);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    return DiffuseGradientMethod;
}(DiffuseBasicMethod));
DiffuseGradientMethod.assetType = "[asset DiffuseGradientMethod]";

/**
 * DiffuseLightMapMethod provides a diffuse shading method that uses a light map to modulate the calculated diffuse
 * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather
 * than only the diffuse lighting value.
 */
var DiffuseLightMapMethod = (function (_super) {
    __extends(DiffuseLightMapMethod, _super);
    /**
     * Creates a new DiffuseLightMapMethod method.
     *
     * @param lightMap The texture containing the light map.
     * @param blendMode The blend mode with which the light map should be applied to the lighting result.
     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
     * @param baseMethod The diffuse method used to calculate the regular diffuse-based lighting.
     */
    function DiffuseLightMapMethod(lightMap, blendMode, useSecondaryUV, baseMethod) {
        if (blendMode === void 0) { blendMode = "multiply"; }
        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
        if (baseMethod === void 0) { baseMethod = null; }
        var _this = _super.call(this, baseMethod) || this;
        _this._lightMap = lightMap;
        _this.blendMode = blendMode;
        _this._useSecondaryUV = useSecondaryUV;
        if (_this._lightMap)
            _this.iAddTexture(_this._lightMap);
        return _this;
    }
    Object.defineProperty(DiffuseLightMapMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return DiffuseLightMapMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseLightMapMethod.prototype, "blendMode", {
        /**
         * The blend mode with which the light map should be applied to the lighting result.
         *
         * @see DiffuseLightMapMethod.ADD
         * @see DiffuseLightMapMethod.MULTIPLY
         */
        get: function () {
            return this._blendMode;
        },
        set: function (value) {
            if (value != DiffuseLightMapMethod.ADD && value != DiffuseLightMapMethod.MULTIPLY)
                throw new Error("Unknown blendmode!");
            if (this._blendMode == value)
                return;
            this._blendMode = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseLightMapMethod.prototype, "lightMap", {
        /**
         * The texture containing the light map data.
         */
        get: function () {
            return this._lightMap;
        },
        set: function (value) {
            if (this._lightMap == value)
                return;
            if (this._lightMap)
                this.iRemoveTexture(this._lightMap);
            this._lightMap = value;
            if (this._lightMap)
                this.iAddTexture(this._lightMap);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseLightMapMethod.prototype, "useSecondaryUV", {
        /**
         * Indicates whether the secondary UV set should be used to map the light map.
         */
        get: function () {
            return this._useSecondaryUV;
        },
        set: function (value) {
            if (this._useSecondaryUV == value)
                return;
            this._useSecondaryUV = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    return DiffuseLightMapMethod;
}(DiffuseCompositeMethod));
/**
 * Indicates the light map should be multiplied with the calculated shading result.
 * This can be used to add pre-calculated shadows or occlusion.
 */
DiffuseLightMapMethod.MULTIPLY = "multiply";
/**
 * Indicates the light map should be added into the calculated shading result.
 * This can be used to add pre-calculated lighting or global illumination.
 */
DiffuseLightMapMethod.ADD = "add";
DiffuseLightMapMethod.assetType = "[asset DiffuseLightMapMethod]";

/**
 * DiffuseWrapMethod is an alternative to DiffuseBasicMethod in which the light is allowed to be "wrapped around" the normally dark area, to some extent.
 * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.
 */
var DiffuseWrapMethod = (function (_super) {
    __extends(DiffuseWrapMethod, _super);
    /**
     * Creates a new DiffuseWrapMethod object.
     * @param wrapFactor A factor to indicate the amount by which the light is allowed to wrap
     */
    function DiffuseWrapMethod(wrapFactor) {
        if (wrapFactor === void 0) { wrapFactor = .5; }
        var _this = _super.call(this) || this;
        _this.wrapFactor = wrapFactor;
        return _this;
    }
    Object.defineProperty(DiffuseWrapMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return DiffuseWrapMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DiffuseWrapMethod.prototype, "wrapFactor", {
        /**
         * A factor to indicate the amount by which the light is allowed to wrap.
         */
        get: function () {
            return this._wrapFactor;
        },
        set: function (value) {
            this._wrapFactor = value;
            this._wrapFactor = 1 / (value + 1);
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return DiffuseWrapMethod;
}(DiffuseBasicMethod));
DiffuseWrapMethod.assetType = "[asset DiffuseWrapMethod]";

/**
 * EffectAlphaMaskMethod allows the use of an additional texture to specify the alpha value of the material. When used
 * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water
 * etc).
 */
var EffectAlphaMaskMethod = (function (_super) {
    __extends(EffectAlphaMaskMethod, _super);
    /**
     * Creates a new EffectAlphaMaskMethod object.
     *
     * @param texture The texture to use as the alpha mask.
     * @param useSecondaryUV Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently.
     */
    function EffectAlphaMaskMethod(texture, useSecondaryUV) {
        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
        var _this = _super.call(this) || this;
        _this._texture = texture;
        _this._useSecondaryUV = useSecondaryUV;
        if (_this._texture)
            _this.iAddTexture(_this._texture);
        return _this;
    }
    Object.defineProperty(EffectAlphaMaskMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectAlphaMaskMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectAlphaMaskMethod.prototype, "texture", {
        /**
         * The texture to use as the alpha mask.
         */
        get: function () {
            return this._texture;
        },
        set: function (value) {
            if (this._texture == value)
                return;
            if (this._texture)
                this.iRemoveTexture(this._texture);
            this._texture = value;
            if (this._texture)
                this.iAddTexture(this._texture);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectAlphaMaskMethod.prototype, "useSecondaryUV", {
        /**
         * Indicated whether or not the secondary uv set for the mask. This allows mapping alpha independently, for
         * instance to tile the main texture and normal map while providing untiled alpha, for example to define the
         * transparency over a tiled water surface.
         */
        get: function () {
            return this._useSecondaryUV;
        },
        set: function (value) {
            if (this._useSecondaryUV == value)
                return;
            this._useSecondaryUV = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    return EffectAlphaMaskMethod;
}(ShadingMethodBase));
EffectAlphaMaskMethod.assetType = "[asset EffectAlphaMaskMethod]";

/**
 * EffectColorMatrixMethod provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.
 */
var EffectColorMatrixMethod = (function (_super) {
    __extends(EffectColorMatrixMethod, _super);
    /**
     * Creates a new EffectColorTransformMethod.
     *
     * @param matrix An array of 20 items for 4 x 5 color transform.
     */
    function EffectColorMatrixMethod(matrix) {
        var _this = _super.call(this) || this;
        if (matrix.length != 20)
            throw new Error("Matrix length must be 20!");
        _this._matrix = matrix;
        return _this;
    }
    Object.defineProperty(EffectColorMatrixMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectColorMatrixMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectColorMatrixMethod.prototype, "matrix", {
        /**
         * The 4 x 5 matrix to transform the color of the material.
         */
        get: function () {
            return this._matrix;
        },
        set: function (value) {
            if (value.length != 20)
                throw new Error("Matrix length must be 20!");
            this._matrix = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return EffectColorMatrixMethod;
}(ShadingMethodBase));
EffectColorMatrixMethod.assetType = "[asset EffectColorMatrixMethod]";

/**
 * EffectColorTransformMethod provides a shading method that changes the colour of a material analogous to a
 * ColorTransform object.
 */
var EffectColorTransformMethod = (function (_super) {
    __extends(EffectColorTransformMethod, _super);
    /**
     * Creates a new EffectColorTransformMethod.
     */
    function EffectColorTransformMethod(colorTransform) {
        if (colorTransform === void 0) { colorTransform = null; }
        var _this = _super.call(this) || this;
        _this._colorTransform = colorTransform;
        return _this;
    }
    Object.defineProperty(EffectColorTransformMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectColorTransformMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectColorTransformMethod.prototype, "colorTransform", {
        /**
         * The ColorTransform object to transform the colour of the material with.
         */
        get: function () {
            return this._colorTransform;
        },
        set: function (value) {
            this._colorTransform = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return EffectColorTransformMethod;
}(ShadingMethodBase));
EffectColorTransformMethod.assetType = "[asset EffectColorTransformMethod]";

/**
 * EffectEnvMapMethod provides a material method to perform reflection mapping using cube maps.
 */
var EffectEnvMapMethod = (function (_super) {
    __extends(EffectEnvMapMethod, _super);
    /**
     * Creates an EffectEnvMapMethod object.
     * @param envMap The environment map containing the reflected scene.
     * @param alpha The reflectivity of the surface.
     */
    function EffectEnvMapMethod(envMap, alpha) {
        if (alpha === void 0) { alpha = 1; }
        var _this = _super.call(this) || this;
        _this._envMap = envMap;
        _this._alpha = alpha;
        _this.iAddTexture(_this._envMap);
        return _this;
    }
    Object.defineProperty(EffectEnvMapMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectEnvMapMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectEnvMapMethod.prototype, "envMap", {
        /**
         * The cubic environment map containing the reflected scene.
         */
        get: function () {
            return this._envMap;
        },
        set: function (value) {
            if (this._envMap == value)
                return;
            if (this._envMap)
                this.iRemoveTexture(this._envMap);
            this._envMap = value;
            if (this._envMap)
                this.iAddTexture(this._envMap);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectEnvMapMethod.prototype, "mask", {
        /**
         * An optional texture to modulate the reflectivity of the surface.
         */
        get: function () {
            return this._mask;
        },
        set: function (value) {
            if (value == this._mask)
                return;
            if (this._mask)
                this.iRemoveTexture(this._mask);
            this._mask = value;
            if (this._mask)
                this.iAddTexture(this._mask);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectEnvMapMethod.prototype, "alpha", {
        /**
         * The reflectivity of the surface.
         */
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            this._alpha = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    EffectEnvMapMethod.prototype.dispose = function () {
    };
    return EffectEnvMapMethod;
}(ShadingMethodBase));
EffectEnvMapMethod.assetType = "[asset EffectEnvMapMethod]";

/**
 * EffectFogMethod provides a method to add distance-based fog to a material.
 */
var EffectFogMethod = (function (_super) {
    __extends(EffectFogMethod, _super);
    /**
     * Creates a new EffectFogMethod object.
     * @param minDistance The distance from which the fog starts appearing.
     * @param maxDistance The distance at which the fog is densest.
     * @param fogColor The colour of the fog.
     */
    function EffectFogMethod(minDistance, maxDistance, fogColor) {
        if (minDistance === void 0) { minDistance = 0; }
        if (maxDistance === void 0) { maxDistance = 1000; }
        if (fogColor === void 0) { fogColor = 0x808080; }
        var _this = _super.call(this) || this;
        _this._minDistance = minDistance;
        _this._maxDistance = maxDistance;
        _this._fogColor = fogColor;
        return _this;
    }
    Object.defineProperty(EffectFogMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectFogMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectFogMethod.prototype, "minDistance", {
        /**
         * The distance from which the fog starts appearing.
         */
        get: function () {
            return this._minDistance;
        },
        set: function (value) {
            this._minDistance = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectFogMethod.prototype, "maxDistance", {
        /**
         * The distance at which the fog is densest.
         */
        get: function () {
            return this._maxDistance;
        },
        set: function (value) {
            this._maxDistance = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectFogMethod.prototype, "fogColor", {
        /**
         * The colour of the fog.
         */
        get: function () {
            return this._fogColor;
        },
        set: function (value) {
            this._fogColor = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return EffectFogMethod;
}(ShadingMethodBase));
EffectFogMethod.assetType = "[asset EffectFogMethod]";

/**
 * EffectFresnelEnvMapMethod provides a method to add fresnel-based reflectivity to an object using cube maps, which gets
 * stronger as the viewing angle becomes more grazing.
 */
var EffectFresnelEnvMapMethod = (function (_super) {
    __extends(EffectFresnelEnvMapMethod, _super);
    /**
     * Creates a new <code>EffectFresnelEnvMapMethod</code> object.
     *
     * @param envMap The environment map containing the reflected scene.
     * @param alpha The reflectivity of the material.
     */
    function EffectFresnelEnvMapMethod(envMap, alpha, fresnelPower, normalReflectance) {
        if (alpha === void 0) { alpha = 1; }
        if (fresnelPower === void 0) { fresnelPower = 5; }
        if (normalReflectance === void 0) { normalReflectance = 0; }
        var _this = _super.call(this, envMap, alpha) || this;
        _this._fresnelPower = fresnelPower;
        _this._normalReflectance = normalReflectance;
        return _this;
    }
    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectFresnelEnvMapMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "fresnelPower", {
        /**
         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
         */
        get: function () {
            return this._fresnelPower;
        },
        set: function (value) {
            this._fresnelPower = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectFresnelEnvMapMethod.prototype, "normalReflectance", {
        /**
         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
         */
        get: function () {
            return this._normalReflectance;
        },
        set: function (value) {
            if (this._normalReflectance == value)
                return;
            this._normalReflectance = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return EffectFresnelEnvMapMethod;
}(EffectEnvMapMethod));
EffectFresnelEnvMapMethod.assetType = "[asset EffectFresnelEnvMapMethod]";

/**
 * EffectLightMapMethod provides a method that allows applying a light map texture to the calculated pixel colour.
 * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather
 * than the whole pixel colour.
 */
var EffectLightMapMethod = (function (_super) {
    __extends(EffectLightMapMethod, _super);
    /**
     * Creates a new EffectLightMapMethod object.
     *
     * @param lightMap The texture containing the light map.
     * @param blendMode The blend mode with which the light map should be applied to the lighting result.
     * @param useSecondaryUV Indicates whether the secondary UV set should be used to map the light map.
     */
    function EffectLightMapMethod(lightMap, blendMode, useSecondaryUV) {
        if (blendMode === void 0) { blendMode = "multiply"; }
        if (useSecondaryUV === void 0) { useSecondaryUV = false; }
        var _this = _super.call(this) || this;
        if (blendMode != EffectLightMapMethod.ADD && blendMode != EffectLightMapMethod.MULTIPLY)
            throw new Error("Unknown blendmode!");
        _this._lightMap = lightMap;
        _this._blendMode = blendMode;
        _this._useSecondaryUV = useSecondaryUV;
        if (_this._lightMap)
            _this.iAddTexture(_this._lightMap);
        return _this;
    }
    Object.defineProperty(EffectLightMapMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectLightMapMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectLightMapMethod.prototype, "blendMode", {
        /**
         * The blend mode with which the light map should be applied to the lighting result.
         *
         * @see EffectLightMapMethod.ADD
         * @see EffectLightMapMethod.MULTIPLY
         */
        get: function () {
            return this._blendMode;
        },
        set: function (value) {
            if (this._blendMode == value)
                return;
            if (value != EffectLightMapMethod.ADD && value != EffectLightMapMethod.MULTIPLY)
                throw new Error("Unknown blendmode!");
            this._blendMode = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectLightMapMethod.prototype, "lightMap", {
        /**
         * The lightMap containing the light map.
         */
        get: function () {
            return this._lightMap;
        },
        set: function (value) {
            if (this._lightMap == value)
                return;
            if (this._lightMap)
                this.iRemoveTexture(this._lightMap);
            this._lightMap = value;
            if (this._lightMap)
                this.iAddTexture(this._lightMap);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectLightMapMethod.prototype, "useSecondaryUV", {
        /**
         * Indicates whether the secondary UV set should be used to map the light map.
         */
        get: function () {
            return this._useSecondaryUV;
        },
        set: function (value) {
            if (this._useSecondaryUV == value)
                return;
            this._useSecondaryUV = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    return EffectLightMapMethod;
}(ShadingMethodBase));
/**
 * Indicates the light map should be multiplied with the calculated shading result.
 */
EffectLightMapMethod.MULTIPLY = "multiply";
/**
 * Indicates the light map should be added into the calculated shading result.
 */
EffectLightMapMethod.ADD = "add";
EffectLightMapMethod.assetType = "[asset EffectLightMapMethod]";

/**
 * ProjectiveTextureMethod is a material method used to project a texture unto the surface of an object.
 * This can be used for various effects apart from acting like a normal projector, such as projecting fake shadows
 * unto a surface, the impact of light coming through a stained glass window, ...
 */
var EffectProjectiveTextureMethod = (function (_super) {
    __extends(EffectProjectiveTextureMethod, _super);
    /**
     * Creates a new ProjectiveTextureMethod object.
     *
     * @param projector The TextureProjector object that defines the projection properties as well as the texture.
     * @param mode The blend mode with which the texture is blended unto the surface.
     *
     * @see away3d.entities.TextureProjector
     */
    function EffectProjectiveTextureMethod(projector, mode, exposure) {
        if (mode === void 0) { mode = "multiply"; }
        if (exposure === void 0) { exposure = 1; }
        var _this = _super.call(this) || this;
        _this._onTextureChangedDelegate = function (event) { return _this._onTextureChanged(event); };
        _this._projector = projector;
        _this._exposure = exposure;
        _this._mode = mode;
        _this._projector.addEventListener(_awayjs_scene.TextureProjectorEvent.TEXTURE_CHANGE, _this._onTextureChangedDelegate);
        return _this;
    }
    Object.defineProperty(EffectProjectiveTextureMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectProjectiveTextureMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectProjectiveTextureMethod.prototype, "exposure", {
        /**
         *
         */
        get: function () {
            return this._exposure;
        },
        set: function (value) {
            if (this._exposure == value)
                return;
            this._exposure = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectProjectiveTextureMethod.prototype, "mode", {
        /**
         * The blend mode with which the texture is blended unto the object.
         * ProjectiveTextureMethod.MULTIPLY can be used to project shadows. To prevent clamping, the texture's alpha should be white!
         * ProjectiveTextureMethod.ADD can be used to project light, such as a slide projector or light coming through stained glass. To prevent clamping, the texture's alpha should be black!
         * ProjectiveTextureMethod.MIX provides normal alpha blending. To prevent clamping, the texture's alpha should be transparent!
         */
        get: function () {
            return this._mode;
        },
        set: function (value) {
            if (this._mode == value)
                return;
            this._mode = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectProjectiveTextureMethod.prototype, "projector", {
        /**
         * The TextureProjector object that defines the projection properties as well as the texture.
         *
         * @see away3d.entities.TextureProjector
         */
        get: function () {
            return this._projector;
        },
        set: function (value) {
            if (this._projector == value)
                return;
            if (this._projector)
                this._projector.removeEventListener(_awayjs_scene.TextureProjectorEvent.TEXTURE_CHANGE, this._onTextureChangedDelegate);
            this._projector = value;
            if (this._projector)
                this._projector.addEventListener(_awayjs_scene.TextureProjectorEvent.TEXTURE_CHANGE, this._onTextureChangedDelegate);
            this.updateTexture();
        },
        enumerable: true,
        configurable: true
    });
    EffectProjectiveTextureMethod.prototype._onTextureChanged = function (event) {
        this.updateTexture();
    };
    EffectProjectiveTextureMethod.prototype.updateTexture = function () {
        if (this._texture)
            this.iRemoveTexture(this._texture);
        this._texture = (this._projector) ? this._projector.texture : null;
        if (this._texture)
            this.iAddTexture(this._texture);
        this.invalidateShaderProgram();
    };
    return EffectProjectiveTextureMethod;
}(ShadingMethodBase));
EffectProjectiveTextureMethod.OVERLAY = "overlay";
EffectProjectiveTextureMethod.MULTIPLY = "multiply";
EffectProjectiveTextureMethod.ADD = "add";
EffectProjectiveTextureMethod.MIX = "mix";
EffectProjectiveTextureMethod.assetType = "[asset EffectProjectiveTextureMethod]";

/**
 * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.
 */
var EffectRefractionEnvMapMethod = (function (_super) {
    __extends(EffectRefractionEnvMapMethod, _super);
    /**
     * Creates a new EffectRefractionEnvMapMethod object. Example values for dispersion are: dispersionR: -0.03, dispersionG: -0.01, dispersionB: = .0015
     *
     * @param envMap The environment map containing the refracted scene.
     * @param refractionIndex The refractive index of the material.
     * @param dispersionR The amount of chromatic dispersion of the red channel. Defaults to 0 (none).
     * @param dispersionG The amount of chromatic dispersion of the green channel. Defaults to 0 (none).
     * @param dispersionB The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).
     */
    function EffectRefractionEnvMapMethod(envMap, alpha, refractionIndex, dispersionR, dispersionG, dispersionB) {
        if (alpha === void 0) { alpha = 1; }
        if (refractionIndex === void 0) { refractionIndex = .1; }
        if (dispersionR === void 0) { dispersionR = 0; }
        if (dispersionG === void 0) { dispersionG = 0; }
        if (dispersionB === void 0) { dispersionB = 0; }
        var _this = _super.call(this, envMap, alpha) || this;
        _this._dispersionR = 0;
        _this._dispersionG = 0;
        _this._dispersionB = 0;
        _this._refractionIndex = refractionIndex;
        _this._dispersionR = dispersionR;
        _this._dispersionG = dispersionG;
        _this._dispersionB = dispersionB;
        return _this;
    }
    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectRefractionEnvMapMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "refractionIndex", {
        /**
         * The refractive index of the material.
         */
        get: function () {
            return this._refractionIndex;
        },
        set: function (value) {
            this._refractionIndex = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionR", {
        /**
         * The amount of chromatic dispersion of the red channel. Defaults to 0 (none).
         */
        get: function () {
            return this._dispersionR;
        },
        set: function (value) {
            if (this._dispersionR == value)
                return;
            this._dispersionR = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionG", {
        /**
         * The amount of chromatic dispersion of the green channel. Defaults to 0 (none).
         */
        get: function () {
            return this._dispersionG;
        },
        set: function (value) {
            if (this._dispersionG == value)
                return;
            this._dispersionG = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRefractionEnvMapMethod.prototype, "dispersionB", {
        /**
         * The amount of chromatic dispersion of the blue channel. Defaults to 0 (none).
         */
        get: function () {
            return this._dispersionB;
        },
        set: function (value) {
            if (this._dispersionB == value)
                return;
            this._dispersionB = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    return EffectRefractionEnvMapMethod;
}(EffectEnvMapMethod));
EffectRefractionEnvMapMethod.assetType = "[asset EffectRefractionEnvMapMethod]";

/**
 * EffectRimLightMethod provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.
 */
var EffectRimLightMethod = (function (_super) {
    __extends(EffectRimLightMethod, _super);
    /**
     * Creates a new <code>EffectRimLightMethod</code> object.
     *
     * @param color The colour of the rim light.
     * @param strength The strength of the rim light.
     * @param power The power of the rim light. Higher values will result in a higher edge fall-off.
     * @param blend The blend mode with which to add the light to the object.
     */
    function EffectRimLightMethod(color, strength, power, blend) {
        if (color === void 0) { color = 0xffffff; }
        if (strength === void 0) { strength = .4; }
        if (power === void 0) { power = 2; }
        if (blend === void 0) { blend = "mix"; }
        var _this = _super.call(this) || this;
        _this._blendMode = blend;
        _this._strength = strength;
        _this._power = power;
        _this._color = color;
        return _this;
    }
    Object.defineProperty(EffectRimLightMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return EffectRimLightMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRimLightMethod.prototype, "color", {
        /**
         * The color of the rim light.
         */
        get: function () {
            return this._color;
        },
        set: function (value /*uint*/) {
            if (this._power == value)
                return;
            this._color = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRimLightMethod.prototype, "strength", {
        /**
         * The strength of the rim light.
         */
        get: function () {
            return this._strength;
        },
        set: function (value) {
            if (this._strength == value)
                return;
            this._strength = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRimLightMethod.prototype, "power", {
        /**
         * The power of the rim light. Higher values will result in a higher edge fall-off.
         */
        get: function () {
            return this._power;
        },
        set: function (value) {
            if (this._power == value)
                return;
            this._power = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(EffectRimLightMethod.prototype, "blendMode", {
        /**
         * The blend mode with which to add the light to the object.
         *
         * EffectRimLightMethod.MULTIPLY multiplies the rim light with the material's colour.
         * EffectRimLightMethod.ADD adds the rim light with the material's colour.
         * EffectRimLightMethod.MIX provides normal alpha blending.
         */
        get: function () {
            return this._blendMode;
        },
        set: function (value) {
            if (this._blendMode == value)
                return;
            this._blendMode = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    return EffectRimLightMethod;
}(ShadingMethodBase));
EffectRimLightMethod.ADD = "add";
EffectRimLightMethod.MULTIPLY = "multiply";
EffectRimLightMethod.MIX = "mix";
EffectRimLightMethod.assetType = "[asset EffectRimLightMethod]";

/**
 * NormalHeightMapMethod provides a normal map method that uses a height map to calculate the normals.
 */
var NormalHeightMapMethod = (function (_super) {
    __extends(NormalHeightMapMethod, _super);
    /**
     * Creates a new NormalHeightMapMethod method.
     *
     * @param heightMap The texture containing the height data. 0 means low, 1 means high.
     * @param worldWidth The width of the 'world'. This is used to map uv coordinates' u component to scene dimensions.
     * @param worldHeight The height of the 'world'. This is used to map the height map values to scene dimensions.
     * @param worldDepth The depth of the 'world'. This is used to map uv coordinates' v component to scene dimensions.
     */
    function NormalHeightMapMethod(heightMap, worldWidth, worldHeight, worldDepth) {
        var _this = _super.call(this) || this;
        _this.texture = heightMap;
        _this._worldXYRatio = worldWidth / worldHeight;
        _this._worldXZRatio = worldDepth / worldHeight;
        return _this;
    }
    Object.defineProperty(NormalHeightMapMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return NormalHeightMapMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalHeightMapMethod.prototype, "worldXYRatio", {
        get: function () {
            return this._worldXYRatio;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalHeightMapMethod.prototype, "worldXZRatio", {
        get: function () {
            return this._worldXZRatio;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    NormalHeightMapMethod.prototype.copyFrom = function (method) {
        _super.prototype.copyFrom.call(this, method);
        this._worldXYRatio = method._worldXYRatio;
        this._worldXZRatio = method._worldXZRatio;
    };
    return NormalHeightMapMethod;
}(NormalBasicMethod));
NormalHeightMapMethod.assetType = "[asset NormalHeightMapMethod]";

/**
 * NormalSimpleWaterMethod provides a basic normal map method to create water ripples by translating two wave normal maps.
 */
var NormalSimpleWaterMethod = (function (_super) {
    __extends(NormalSimpleWaterMethod, _super);
    /**
     * Creates a new NormalSimpleWaterMethod object.
     * @param waveMap1 A normal map containing one layer of a wave structure.
     * @param waveMap2 A normal map containing a second layer of a wave structure.
     */
    function NormalSimpleWaterMethod(normalMap, secondaryNormalMap) {
        if (normalMap === void 0) { normalMap = null; }
        if (secondaryNormalMap === void 0) { secondaryNormalMap = null; }
        var _this = _super.call(this, normalMap) || this;
        _this._water1OffsetX = 0;
        _this._water1OffsetY = 0;
        _this._water2OffsetX = 0;
        _this._water2OffsetY = 0;
        _this._secondaryNormalMap = secondaryNormalMap;
        if (_this._secondaryNormalMap)
            _this.iAddTexture(_this._secondaryNormalMap);
        return _this;
    }
    Object.defineProperty(NormalSimpleWaterMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return NormalSimpleWaterMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetX", {
        /**
         * The translation of the first wave layer along the X-axis.
         */
        get: function () {
            return this._water1OffsetX;
        },
        set: function (value) {
            this._water1OffsetX = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water1OffsetY", {
        /**
         * The translation of the first wave layer along the Y-axis.
         */
        get: function () {
            return this._water1OffsetY;
        },
        set: function (value) {
            this._water1OffsetY = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetX", {
        /**
         * The translation of the second wave layer along the X-axis.
         */
        get: function () {
            return this._water2OffsetX;
        },
        set: function (value) {
            this._water2OffsetX = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalSimpleWaterMethod.prototype, "water2OffsetY", {
        /**
         * The translation of the second wave layer along the Y-axis.
         */
        get: function () {
            return this._water2OffsetY;
        },
        set: function (value) {
            this._water2OffsetY = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NormalSimpleWaterMethod.prototype, "secondaryNormalMap", {
        /**
         * A second normal map that will be combined with the first to create a wave-like animation pattern.
         */
        get: function () {
            return this._secondaryNormalMap;
        },
        set: function (value) {
            if (this._secondaryNormalMap == value)
                return;
            if (this._secondaryNormalMap)
                this.iRemoveTexture(this._secondaryNormalMap);
            this._secondaryNormalMap = value;
            if (this._secondaryNormalMap)
                this.iAddTexture(this._secondaryNormalMap);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    NormalSimpleWaterMethod.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this._secondaryNormalMap = null;
    };
    return NormalSimpleWaterMethod;
}(NormalBasicMethod));
NormalSimpleWaterMethod.assetType = "[asset NormalSimpleWaterMethod]";

/**
 * ShadowMethodBase provides an abstract base method for shadow map methods.
 */
var ShadowMethodBase = (function (_super) {
    __extends(ShadowMethodBase, _super);
    /**
     * Creates a new ShadowMethodBase object.
     * @param castingLight The light used to cast shadows.
     */
    function ShadowMethodBase(castingLight) {
        var _this = _super.call(this) || this;
        _this._epsilon = .02;
        _this._alpha = 1;
        castingLight.shadowsEnabled = true;
        _this._castingLight = castingLight;
        _this.iAddTexture(castingLight.shadowMapper.depthMap);
        return _this;
    }
    Object.defineProperty(ShadowMethodBase.prototype, "alpha", {
        /**
         * The "transparency" of the shadows. This allows making shadows less strong.
         */
        get: function () {
            return this._alpha;
        },
        set: function (value) {
            this._alpha = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowMethodBase.prototype, "castingLight", {
        /**
         * The light casting the shadows.
         */
        get: function () {
            return this._castingLight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowMethodBase.prototype, "epsilon", {
        /**
         * A small value to counter floating point precision errors when comparing values in the shadow map with the
         * calculated depth value. Increase this if shadow banding occurs, decrease it if the shadow seems to be too detached.
         */
        get: function () {
            return this._epsilon;
        },
        set: function (value) {
            this._epsilon = value;
        },
        enumerable: true,
        configurable: true
    });
    return ShadowMethodBase;
}(ShadingMethodBase));

/**
 * ShadowHardMethod provides the cheapest shadow map method by using a single tap without any filtering.
 */
var ShadowHardMethod = (function (_super) {
    __extends(ShadowHardMethod, _super);
    function ShadowHardMethod() {
        return _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ShadowHardMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return ShadowHardMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return ShadowHardMethod;
}(ShadowMethodBase));
ShadowHardMethod.assetType = "[asset ShadowHardMethod]";

/**
 * ShadowCompositeMethod is a shadow map method to apply cascade shadow mapping on materials.
 * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.
 *
 * @see away.lights.CascadeShadowMapper
 */
var ShadowCompositeMethod = (function (_super) {
    __extends(ShadowCompositeMethod, _super);
    /**
     * Creates a new ShadowCompositeMethod object.
     *
     * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
     */
    function ShadowCompositeMethod(baseMethod) {
        var _this = _super.call(this, baseMethod) || this;
        if (!(baseMethod.castingLight instanceof _awayjs_scene.DirectionalLight))
            throw new Error("ShadowCompositeMethod is only compatible with DirectionalLight");
        baseMethod.castingLight.shadowMapper.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, function (event) { return _this.onShadowMapperInvalidate(event); });
        return _this;
    }
    Object.defineProperty(ShadowCompositeMethod.prototype, "castingLight", {
        /**
         * The light casting the shadows.
         */
        get: function () {
            return this._baseMethod.castingLight;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowCompositeMethod.prototype, "alpha", {
        /**
         *
         */
        get: function () {
            return this._baseMethod.alpha;
        },
        set: function (value) {
            this._baseMethod.alpha = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowCompositeMethod.prototype, "epsilon", {
        /**
         *
         */
        get: function () {
            return this._baseMethod.epsilon;
        },
        set: function (value) {
            this._baseMethod.epsilon = value;
        },
        enumerable: true,
        configurable: true
    });
    ShadowCompositeMethod.prototype.createBaseMethod = function () {
        return new ShadowHardMethod(new _awayjs_scene.DirectionalLight());
    };
    /**
     * Called when the shadow mappers cascade configuration changes.
     */
    ShadowCompositeMethod.prototype.onShadowMapperInvalidate = function (event) {
        this.invalidateShaderProgram();
    };
    return ShadowCompositeMethod;
}(CompositeMethodBase));

/**
 * ShadowCascadeMethod is a shadow map method to apply cascade shadow mapping on materials.
 * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.
 *
 * @see away.lights.CascadeShadowMapper
 */
var ShadowCascadeMethod = (function (_super) {
    __extends(ShadowCascadeMethod, _super);
    /**
     * Creates a new ShadowCascadeMethod object.
     *
     * @param shadowMethodBase The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
     */
    function ShadowCascadeMethod(baseMethod) {
        var _this = _super.call(this, baseMethod) || this;
        if (!(baseMethod.castingLight.shadowMapper instanceof _awayjs_scene.CascadeShadowMapper))
            throw new Error("ShadowCascadeMethod requires a light that has a CascadeShadowMapper instance assigned to shadowMapper.");
        return _this;
    }
    Object.defineProperty(ShadowCascadeMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return ShadowCascadeMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowCascadeMethod.prototype, "cascadeShadowMapper", {
        get: function () {
            return this._baseMethod.castingLight.shadowMapper;
        },
        enumerable: true,
        configurable: true
    });
    return ShadowCascadeMethod;
}(ShadowCompositeMethod));
ShadowCascadeMethod.assetType = "[asset ShadowCascadeMethod]";

/**
 * ShadowDitheredMethod provides a soft shadowing technique by randomly distributing sample points differently for each fragment.
 */
var ShadowDitheredMethod = (function (_super) {
    __extends(ShadowDitheredMethod, _super);
    /**
     * Creates a new ShadowDitheredMethod object.
     * @param castingLight The light casting the shadows
     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 24.
     */
    function ShadowDitheredMethod(castingLight, numSamples, range) {
        if (numSamples === void 0) { numSamples = 4; }
        if (range === void 0) { range = 1; }
        var _this = _super.call(this, castingLight) || this;
        _this._depthMapSize = _this._castingLight.shadowMapper.depthMapSize;
        _this.numSamples = numSamples;
        _this.range = range;
        ++ShadowDitheredMethod._grainUsages;
        if (!ShadowDitheredMethod._grainTexture)
            _this.initGrainTexture();
        return _this;
    }
    Object.defineProperty(ShadowDitheredMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return ShadowDitheredMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowDitheredMethod.prototype, "numSamples", {
        /**
         * The amount of samples to take for dithering. Minimum 1, maximum 24. The actual maximum may depend on the
         * complexity of the shader.
         */
        get: function () {
            return this._numSamples;
        },
        set: function (value) {
            if (value < 1)
                value = 1;
            else if (value > 24)
                value = 24;
            if (this._numSamples == value)
                return;
            this._numSamples = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowDitheredMethod.prototype, "range", {
        /**
         * The range in the shadow map in which to distribute the samples.
         */
        get: function () {
            return this._range * 2;
        },
        set: function (value) {
            this._range = value / 2;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Creates a texture containing the dithering noise texture.
     */
    ShadowDitheredMethod.prototype.initGrainTexture = function () {
        ShadowDitheredMethod._grainBitmapImage2D = new _awayjs_graphics.BitmapImage2D(64, 64, false);
        var vec = new Array();
        var len = 4096;
        var step = 1 / (this._depthMapSize * this._range);
        var r, g;
        for (var i = 0; i < len; ++i) {
            r = 2 * (Math.random() - .5);
            g = 2 * (Math.random() - .5);
            if (r < 0)
                r -= step;
            else
                r += step;
            if (g < 0)
                g -= step;
            else
                g += step;
            if (r > 1)
                r = 1;
            else if (r < -1)
                r = -1;
            if (g > 1)
                g = 1;
            else if (g < -1)
                g = -1;
            vec[i] = (Math.floor((r * .5 + .5) * 0xff) << 16) | (Math.floor((g * .5 + .5) * 0xff) << 8);
        }
        ShadowDitheredMethod._grainBitmapImage2D.setArray(ShadowDitheredMethod._grainBitmapImage2D.rect, vec);
        ShadowDitheredMethod._grainTexture = new _awayjs_graphics.Single2DTexture(ShadowDitheredMethod._grainBitmapImage2D);
    };
    /**
     * @inheritDoc
     */
    ShadowDitheredMethod.prototype.dispose = function () {
        if (--ShadowDitheredMethod._grainUsages == 0) {
            ShadowDitheredMethod._grainTexture.dispose();
            ShadowDitheredMethod._grainBitmapImage2D.dispose();
            ShadowDitheredMethod._grainTexture = null;
        }
    };
    return ShadowDitheredMethod;
}(ShadowMethodBase));
ShadowDitheredMethod.assetType = "[asset ShadowDitheredMethod]";

/**
 * ShadowFilteredMethod provides a softened shadowing technique by bilinearly interpolating shadow comparison
 * results of neighbouring pixels.
 */
var ShadowFilteredMethod = (function (_super) {
    __extends(ShadowFilteredMethod, _super);
    function ShadowFilteredMethod() {
        return _super.apply(this, arguments) || this;
    }
    Object.defineProperty(ShadowFilteredMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return ShadowFilteredMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return ShadowFilteredMethod;
}(ShadowMethodBase));
ShadowFilteredMethod.assetType = "[asset ShadowFilteredMethod]";

// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work
/**
 * ShadowNearMethod provides a shadow map method that restricts the shadowed area near the camera to optimize
 * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.
 *
 * @see away.lights.NearDirectionalShadowMapper
 */
var ShadowNearMethod = (function (_super) {
    __extends(ShadowNearMethod, _super);
    /**
     * Creates a new ShadowNearMethod object.
     * @param baseMethod The shadow map sampling method used to sample individual cascades (fe: ShadowHardMethod, ShadowSoftMethod)
     * @param fadeRatio The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
     */
    function ShadowNearMethod(baseMethod, fadeRatio) {
        if (baseMethod === void 0) { baseMethod = null; }
        if (fadeRatio === void 0) { fadeRatio = .1; }
        var _this = _super.call(this, baseMethod) || this;
        _this._fadeRatio = fadeRatio;
        if (!(baseMethod.castingLight.shadowMapper instanceof _awayjs_scene.NearDirectionalShadowMapper))
            throw new Error("ShadowNearMethod requires a light that has a NearDirectionalShadowMapper instance assigned to shadowMapper.");
        return _this;
    }
    Object.defineProperty(ShadowNearMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return ShadowNearMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowNearMethod.prototype, "fadeRatio", {
        /**
         * The amount of shadow fading to the outer shadow area. A value of 1 would mean the shadows start fading from the camera's near plane.
         */
        get: function () {
            return this._fadeRatio;
        },
        set: function (value) {
            this._fadeRatio = value;
        },
        enumerable: true,
        configurable: true
    });
    return ShadowNearMethod;
}(ShadowCompositeMethod));
ShadowNearMethod.assetType = "[asset ShadowNearMethod]";

/**
 * ShadowSoftMethod provides a soft shadowing technique by randomly distributing sample points.
 */
var ShadowSoftMethod = (function (_super) {
    __extends(ShadowSoftMethod, _super);
    /**
     * Creates a new DiffuseBasicMethod object.
     *
     * @param castingLight The light casting the shadows
     * @param numSamples The amount of samples to take for dithering. Minimum 1, maximum 32.
     */
    function ShadowSoftMethod(castingLight, numSamples, range) {
        if (numSamples === void 0) { numSamples = 5; }
        if (range === void 0) { range = 1; }
        var _this = _super.call(this, castingLight) || this;
        _this.numSamples = numSamples;
        _this.range = range;
        return _this;
    }
    Object.defineProperty(ShadowSoftMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return ShadowSoftMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowSoftMethod.prototype, "offsets", {
        get: function () {
            return this._offsets;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowSoftMethod.prototype, "numSamples", {
        /**
         * The amount of samples to take for dithering. Minimum 1, maximum 32. The actual maximum may depend on the
         * complexity of the shader.
         */
        get: function () {
            return this._numSamples;
        },
        set: function (value) {
            this._numSamples = value;
            if (this._numSamples < 1)
                this._numSamples = 1;
            else if (this._numSamples > 32)
                this._numSamples = 32;
            this._offsets = _awayjs_core.PoissonLookup.getDistribution(this._numSamples);
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(ShadowSoftMethod.prototype, "range", {
        /**
         * The range in the shadow map in which to distribute the samples.
         */
        get: function () {
            return this._range;
        },
        set: function (value) {
            this._range = value;
        },
        enumerable: true,
        configurable: true
    });
    return ShadowSoftMethod;
}(ShadowMethodBase));
ShadowSoftMethod.assetType = "[asset ShadowSoftMethod]";

/**
 * SpecularAnisotropicMethod provides a specular method resulting in anisotropic highlights. These are typical for
 * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.
 * The tangent vectors are used as the surface groove directions.
 */
var SpecularAnisotropicMethod = (function (_super) {
    __extends(SpecularAnisotropicMethod, _super);
    /**
     * Creates a new SpecularAnisotropicMethod object.
     */
    function SpecularAnisotropicMethod() {
        return _super.call(this) || this;
    }
    Object.defineProperty(SpecularAnisotropicMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return SpecularAnisotropicMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return SpecularAnisotropicMethod;
}(SpecularBasicMethod));
SpecularAnisotropicMethod.assetType = "[asset SpecularAnisotropicMethod]";

/**
 * SpecularCompositeMethod provides a base class for specular methods that wrap a specular method to alter the
 * calculated specular reflection strength.
 */
var SpecularCompositeMethod = (function (_super) {
    __extends(SpecularCompositeMethod, _super);
    /**
     * Creates a new <code>SpecularCompositeMethod</code> object.
     *
     * @param modulateMethod The method which will add the code to alter the base method's strength. It needs to have the signature clampDiffuse(t:ShaderRegisterElement, regCache:ShaderRegisterCache):string, in which t.w will contain the diffuse strength.
     * @param baseMethod The base specular method on which this method's shading is based.
     */
    function SpecularCompositeMethod(baseMethod) {
        if (baseMethod === void 0) { baseMethod = null; }
        return _super.call(this, baseMethod) || this;
    }
    SpecularCompositeMethod.prototype.createBaseMethod = function () {
        return new SpecularBasicMethod();
    };
    Object.defineProperty(SpecularCompositeMethod.prototype, "gloss", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._baseMethod.gloss;
        },
        set: function (value) {
            this._baseMethod.gloss = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularCompositeMethod.prototype, "strength", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._baseMethod.strength;
        },
        set: function (value) {
            this._baseMethod.strength = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularCompositeMethod.prototype, "color", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._baseMethod.color;
        },
        /**
         * @inheritDoc
         */
        set: function (value) {
            this._baseMethod.color = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularCompositeMethod.prototype, "texture", {
        /**
         * @inheritDoc
         */
        get: function () {
            return this._baseMethod.texture;
        },
        set: function (value) {
            this._baseMethod.texture = value;
        },
        enumerable: true,
        configurable: true
    });
    return SpecularCompositeMethod;
}(CompositeMethodBase));

/**
 * SpecularCelMethod provides a shading method to add specular cel (cartoon) shading.
 */
var SpecularCelMethod = (function (_super) {
    __extends(SpecularCelMethod, _super);
    /**
     * Creates a new SpecularCelMethod object.
     * @param specularCutOff The threshold at which the specular highlight should be shown.
     * @param smoothness The smoothness of the highlight edge.
     * @param baseMethod An optional specular method on which the cartoon shading is based. If ommitted, SpecularBasicMethod is used.
     */
    function SpecularCelMethod(specularCutOff, smoothness, baseMethod) {
        if (specularCutOff === void 0) { specularCutOff = 0.5; }
        if (smoothness === void 0) { smoothness = 0.1; }
        if (baseMethod === void 0) { baseMethod = null; }
        var _this = _super.call(this, baseMethod) || this;
        _this._specularCutOff = specularCutOff;
        _this._smoothness = smoothness;
        return _this;
    }
    Object.defineProperty(SpecularCelMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return SpecularCelMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularCelMethod.prototype, "smoothness", {
        /**
         * The smoothness of the highlight edge.
         */
        get: function () {
            return this._smoothness;
        },
        set: function (value) {
            if (this._smoothness == value)
                return;
            this._smoothness = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularCelMethod.prototype, "specularCutOff", {
        /**
         * The threshold at which the specular highlight should be shown.
         */
        get: function () {
            return this._specularCutOff;
        },
        set: function (value) {
            if (this._specularCutOff == value)
                return;
            this._specularCutOff = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return SpecularCelMethod;
}(SpecularCompositeMethod));
SpecularCelMethod.assetType = "[asset SpecularCelMethod]";

/**
 * SpecularFresnelMethod provides a specular shading method that causes stronger highlights on grazing view angles.
 */
var SpecularFresnelMethod = (function (_super) {
    __extends(SpecularFresnelMethod, _super);
    /**
     * Creates a new SpecularFresnelMethod object.
     * @param basedOnSurface Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
     * @param baseMethod The specular method to which the fresnel equation. Defaults to SpecularBasicMethod.
     */
    function SpecularFresnelMethod(basedOnSurface, fresnelPower, normalReflectance, baseMethod) {
        if (basedOnSurface === void 0) { basedOnSurface = true; }
        if (fresnelPower === void 0) { fresnelPower = 5; }
        if (normalReflectance === void 0) { normalReflectance = 0.028; }
        if (baseMethod === void 0) { baseMethod = null; }
        var _this = _super.call(this, baseMethod) || this;
        _this._basedOnSurface = basedOnSurface;
        _this._fresnelPower = fresnelPower;
        _this._normalReflectance = normalReflectance;
        return _this;
    }
    Object.defineProperty(SpecularFresnelMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return SpecularFresnelMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularFresnelMethod.prototype, "basedOnSurface", {
        /**
         * Defines whether the fresnel effect should be based on the view angle on the surface (if true), or on the angle between the light and the view.
         */
        get: function () {
            return this._basedOnSurface;
        },
        set: function (value) {
            if (this._basedOnSurface == value)
                return;
            this._basedOnSurface = value;
            this.invalidateShaderProgram();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularFresnelMethod.prototype, "fresnelPower", {
        /**
         * The power used in the Fresnel equation. Higher values make the fresnel effect more pronounced. Defaults to 5.
         */
        get: function () {
            return this._fresnelPower;
        },
        set: function (value) {
            if (this._fresnelPower == value)
                return;
            this._fresnelPower = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(SpecularFresnelMethod.prototype, "normalReflectance", {
        /**
         * The minimum amount of reflectance, ie the reflectance when the view direction is normal to the surface or light direction.
         */
        get: function () {
            return this._normalReflectance;
        },
        set: function (value) {
            if (this._normalReflectance == value)
                return;
            this._normalReflectance = value;
            this.invalidate();
        },
        enumerable: true,
        configurable: true
    });
    return SpecularFresnelMethod;
}(SpecularCompositeMethod));
SpecularFresnelMethod.assetType = "[asset SpecularFresnelMethod]";

/**
 * SpecularPhongMethod provides a specular method that provides Phong highlights.
 */
var SpecularPhongMethod = (function (_super) {
    __extends(SpecularPhongMethod, _super);
    /**
     * Creates a new SpecularPhongMethod object.
     */
    function SpecularPhongMethod() {
        return _super.call(this) || this;
    }
    Object.defineProperty(SpecularPhongMethod.prototype, "assetType", {
        /**
         * @inheritDoc
         */
        get: function () {
            return SpecularPhongMethod.assetType;
        },
        enumerable: true,
        configurable: true
    });
    return SpecularPhongMethod;
}(SpecularBasicMethod));
SpecularPhongMethod.assetType = "[asset SpecularPhongMethod]";

/**
 * ShaderChunkBase provides an abstract base method for shading methods, used by compiled passes to compile
 * the final shading program.
 */
var ShaderChunkBase = (function (_super) {
    __extends(ShaderChunkBase, _super);
    /**
     * Create a new ShaderChunkBase object.
     */
    function ShaderChunkBase(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this.chunkVO = new ChunkVO();
        _this._stage = shader._stage;
        return _this;
    }
    /**
     *
     */
    ShaderChunkBase.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._stage = null;
    };
    ShaderChunkBase.prototype._isUsed = function () {
        return true;
    };
    ShaderChunkBase.prototype._usesTangentSpace = function () {
        return true;
    };
    /**
     * Initializes the properties for a MethodVO, including register and texture indices.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     *
     * @internal
     */
    ShaderChunkBase.prototype._initVO = function (chunkVO) {
    };
    /**
     * Initializes unchanging shader constants using the data from a MethodVO.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     *
     * @internal
     */
    ShaderChunkBase.prototype._initConstants = function () {
    };
    /**
     * Resets the compilation state of the method.
     *
     * @internal
     */
    ShaderChunkBase.prototype._reset = function (chunkVO) {
        this._invalid = true;
        chunkVO.useChunk = false;
        chunkVO.needsProjection = false;
        chunkVO.needsView = false;
        chunkVO.needsNormals = false;
        chunkVO.needsTangents = false;
        chunkVO.needsGlobalVertexPos = false;
        chunkVO.needsGlobalFragmentPos = false;
        this._cleanCompilationData();
    };
    /**
     * Resets the method's state for compilation.
     *
     * @internal
     */
    ShaderChunkBase.prototype._cleanCompilationData = function () {
    };
    /**
     * Get the vertex shader code for this method.
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     *
     * @internal
     */
    ShaderChunkBase.prototype._getVertexCode = function (registerCache, sharedRegisters) {
        return "";
    };
    /**
     * @inheritDoc
     */
    ShaderChunkBase.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        return "";
    };
    /**
     * Sets the render state for this method.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param stage The Stage object currently used for rendering.
     *
     * @internal
     */
    ShaderChunkBase.prototype._activate = function () {
    };
    /**
     * Sets the render state for a single renderable.
     *
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param renderable The renderable currently being rendered.
     * @param stage The Stage object currently used for rendering.
     * @param camera The camera from which the scene is currently rendered.
     *
     * @internal
     */
    ShaderChunkBase.prototype._setRenderState = function (renderable, projection) {
    };
    /**
     * Clears the render state for this method.
     * @param vo The MethodVO object linking this method with the pass currently being compiled.
     * @param stage The Stage object currently used for rendering.
     *
     * @internal
     */
    ShaderChunkBase.prototype._deactivate = function () {
        this._invalid = false;
    };
    return ShaderChunkBase;
}(_awayjs_core.AbstractionBase));

/**
 * AmbientBasicChunk provides the default shading method for uniform ambient lighting.
 */
var AmbientBasicChunk = (function (_super) {
    __extends(AmbientBasicChunk, _super);
    /**
     * Creates a new AmbientBasicChunk object.
     */
    function AmbientBasicChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     *
     */
    AmbientBasicChunk.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._method = null;
        this._shader = null;
        if (this._texture) {
            this._texture.onClear(new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.CLEAR, this._method.texture));
            this._texture = null;
        }
    };
    /**
     * @inheritDoc
     */
    AmbientBasicChunk.prototype._initVO = function (chunkVO) {
        if (this._method.texture) {
            this._texture = this._shader.getAbstraction(this._method.texture);
            if (this._method.texture.mappingMode == _awayjs_graphics.MappingMode.CUBE)
                chunkVO.needsNormals = true;
            else
                this._shader.uvDependencies++;
        }
        else if (this._texture) {
            this._texture = null;
        }
    };
    /**
     * @inheritDoc
     */
    AmbientBasicChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        if (this._texture) {
            code += this._texture._getFragmentCode(targetReg, registerCache, sharedRegisters, (this._method.texture.mappingMode == _awayjs_graphics.MappingMode.CUBE) ? sharedRegisters.normalFragment : sharedRegisters.uvVarying);
            if (this._shader.alphaThreshold > 0) {
                var cutOffReg = registerCache.getFreeFragmentConstant();
                this._colorIndex = cutOffReg.index * 4;
                code += "sub " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n" +
                    "kil " + targetReg + ".w\n" +
                    "add " + targetReg + ".w, " + targetReg + ".w, " + cutOffReg + ".x\n";
            }
        }
        else {
            var ambientInputRegister = registerCache.getFreeFragmentConstant();
            this._colorIndex = ambientInputRegister.index * 4;
            code += "mov " + targetReg + ", " + ambientInputRegister + "\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    AmbientBasicChunk.prototype._activate = function () {
        if (this._texture) {
            this._texture.activate();
            if (this._invalid && this._shader.alphaThreshold > 0)
                this._shader.fragmentConstantData[this._colorIndex] = this._shader.alphaThreshold;
        }
        else if (this._invalid) {
            var index = this._colorIndex;
            var data = this._shader.fragmentConstantData;
            var color = this._shader.numLights ? 0xFFFFFF : this._shader.pass.style.color;
            data[index] = ((color >> 16) & 0xff) / 0xff * this._method.strength;
            data[index + 1] = ((color >> 8) & 0xff) / 0xff * this._method.strength;
            data[index + 2] = (color & 0xff) / 0xff * this._method.strength;
            data[index + 3] = this._method.alpha;
        }
    };
    AmbientBasicChunk.prototype._setRenderState = function (renderable, projection) {
        if (this._texture)
            this._texture._setRenderState(renderable);
    };
    return AmbientBasicChunk;
}(ShaderChunkBase));

/**
 * AmbientDepthChunk provides a debug method to visualise depth maps
 */
var AmbientDepthChunk = (function (_super) {
    __extends(AmbientDepthChunk, _super);
    /**
     * Creates a new AmbientBasicChunk object.
     */
    function AmbientDepthChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._shadowTexture = shader.getAbstraction(method.castingLight.shadowMapper.depthMap);
        return _this;
    }
    /**
     * @inheritDoc
     */
    AmbientDepthChunk.prototype._initConstants = function () {
        var data = this._shader.fragmentConstantData;
        var index = this._decRegIndex;
        data[index] = 1.0;
        data[index + 1] = 1 / 255.0;
        data[index + 2] = 1 / 65025.0;
        data[index + 3] = 1 / 16581375.0;
    };
    AmbientDepthChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        var decReg;
        var decReg = registerCache.getFreeFragmentConstant();
        this._decRegIndex = decReg.index * 4;
        code += this._shadowTexture._getFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
            "dp4 " + targetReg + ".x, " + targetReg + ", " + decReg + "\n" +
            "mov " + targetReg + ".yz, " + targetReg + ".xx			\n" +
            "mov " + targetReg + ".w, " + decReg + ".x\n" +
            "sub " + targetReg + ".xyz, " + decReg + ".xxx, " + targetReg + ".xyz\n";
        return code;
    };
    return AmbientDepthChunk;
}(AmbientBasicChunk));

/**
 * DiffuseBasicChunk provides the default shading method for Lambert (dot3) diffuse lighting.
 */
var DiffuseBasicChunk = (function (_super) {
    __extends(DiffuseBasicChunk, _super);
    /**
     * Creates a new DiffuseBasicChunk object.
     */
    function DiffuseBasicChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._ambientColorR = 1;
        _this._ambientColorG = 1;
        _this._ambientColorB = 1;
        _this._color = 0xffffff;
        _this._colorR = 1;
        _this._colorG = 1;
        _this._colorB = 1;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     *
     */
    DiffuseBasicChunk.prototype.onInvalidate = function (event) {
        _super.prototype.onInvalidate.call(this, event);
        this._updateProperties();
    };
    DiffuseBasicChunk.prototype._isUsed = function () {
        return Boolean(this._shader.numLights);
    };
    DiffuseBasicChunk.prototype._initVO = function (chunkVO) {
        if (this._method.texture) {
            this._texture = this._shader.getAbstraction(this._method.texture);
            if (this._method.texture.mappingMode == _awayjs_graphics.MappingMode.CUBE)
                chunkVO.needsNormals = true;
            else
                this._shader.uvDependencies++;
        }
        else if (this._texture) {
            this._texture = null;
        }
        if (this._shader.numLights) {
            this._shader.usesCommonData = true;
            chunkVO.needsNormals = true;
        }
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._initConstants = function () {
        this._updateProperties();
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._totalLightColorReg = null;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        var code = "";
        this._pIsFirstLight = true;
        registerCache.addFragmentTempUsages(this._totalLightColorReg = registerCache.getFreeFragmentVectorTemp(), 1);
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._getFragmentCodePerLight = function (lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight) {
            t = this._totalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        code += "dp3 " + t + ".x, " + lightDirReg + ", " + sharedRegisters.normalFragment + "\n" +
            "max " + t + ".w, " + t + ".x, " + sharedRegisters.commons + ".y\n";
        if (this._shader.usesLightFallOff)
            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(t, registerCache, sharedRegisters);
        code += "mul " + t + ", " + t + ".w, " + lightColReg + "\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._getFragmentCodePerProbe = function (cubeMapReg, weightRegister, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight) {
            t = this._totalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        code += "tex " + t + ", " + sharedRegisters.normalFragment + ", " + cubeMapReg + " <cube,linear,miplinear>\n" +
            "mul " + t + ".xyz, " + t + ".xyz, " + weightRegister + "\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(t, registerCache, sharedRegisters);
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        var diffuseColor;
        var cutOffReg;
        // incorporate input from ambient
        if (sharedRegisters.shadowTarget)
            code += this._applyShadow(registerCache, sharedRegisters);
        registerCache.addFragmentTempUsages(diffuseColor = registerCache.getFreeFragmentVectorTemp(), 1);
        var ambientColorRegister = registerCache.getFreeFragmentConstant();
        this._ambientColorRegister = ambientColorRegister.index * 4;
        if (this._texture) {
            code += this._texture._getFragmentCode(diffuseColor, registerCache, sharedRegisters, (this._method.texture.mappingMode == _awayjs_graphics.MappingMode.CUBE) ? sharedRegisters.normalFragment : sharedRegisters.uvVarying);
        }
        else {
            var diffuseColorRegister = registerCache.getFreeFragmentConstant();
            this._diffuseColorRegister = diffuseColorRegister.index * 4;
            code += "mov " + diffuseColor + ", " + diffuseColorRegister + "\n";
        }
        code += "sat " + this._totalLightColorReg + ", " + this._totalLightColorReg + "\n" +
            "mul " + diffuseColor + ".xyz, " + diffuseColor + ", " + this._totalLightColorReg + "\n";
        if (this._method.multiply) {
            code += "add " + diffuseColor + ".xyz, " + diffuseColor + ", " + ambientColorRegister + "\n" +
                "mul " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n";
        }
        else if (this._texture) {
            code += "mul " + targetReg + ".xyz, " + targetReg + ", " + ambientColorRegister + "\n" +
                "mul " + this._totalLightColorReg + ".xyz, " + targetReg + ", " + this._totalLightColorReg + "\n" +
                "sub " + targetReg + ".xyz, " + targetReg + ", " + this._totalLightColorReg + "\n" +
                "add " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n"; //add diffuse color and ambient color
        }
        else {
            code += "mul " + this._totalLightColorReg + ".xyz, " + ambientColorRegister + ", " + this._totalLightColorReg + "\n" +
                "sub " + this._totalLightColorReg + ".xyz, " + ambientColorRegister + ", " + this._totalLightColorReg + "\n" +
                "add " + diffuseColor + ".xyz, " + diffuseColor + ", " + this._totalLightColorReg + "\n" +
                "mul " + targetReg + ".xyz, " + targetReg + ", " + diffuseColor + "\n"; // multiply by target which could be texture or white
        }
        registerCache.removeFragmentTempUsage(this._totalLightColorReg);
        registerCache.removeFragmentTempUsage(diffuseColor);
        return code;
    };
    /**
     * Generate the code that applies the calculated shadow to the diffuse light
     * @param methodVO The MethodVO object for which the compilation is currently happening.
     * @param regCache The register cache the compiler is currently using for the register management.
     */
    DiffuseBasicChunk.prototype._applyShadow = function (regCache, sharedRegisters) {
        return "mul " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._activate = function () {
        if (this._texture) {
            this._texture.activate();
        }
        else {
            var index = this._diffuseColorRegister;
            var data = this._shader.fragmentConstantData;
            if (this._method.multiply) {
                data[index] = this._colorR * this._ambientColorR;
                data[index + 1] = this._colorG * this._ambientColorG;
                data[index + 2] = this._colorB * this._ambientColorB;
            }
            else {
                data[index] = this._colorR;
                data[index + 1] = this._colorG;
                data[index + 2] = this._colorB;
            }
            data[index + 3] = 1;
        }
    };
    /**
     * Updates the diffuse and ambient color data used by the render state.
     */
    DiffuseBasicChunk.prototype._updateProperties = function () {
        this._ambientColor = this._shader.pass.style.color;
        this._ambientColorR = ((this._ambientColor >> 16) & 0xff) / 0xff;
        this._ambientColorG = ((this._ambientColor >> 8) & 0xff) / 0xff;
        this._ambientColorB = (this._ambientColor & 0xff) / 0xff;
        this._color = this._method.color;
        this._colorR = ((this._color >> 16) & 0xff) / 0xff;
        this._colorG = ((this._color >> 8) & 0xff) / 0xff;
        this._colorB = (this._color & 0xff) / 0xff;
    };
    /**
     * @inheritDoc
     */
    DiffuseBasicChunk.prototype._setRenderState = function (renderable, projection) {
        if (this._texture)
            this._texture._setRenderState(renderable);
        //TODO move this to Activate (ambientR/G/B currently calc'd in render state)
        var index = this._ambientColorRegister;
        var data = this._shader.fragmentConstantData;
        data[index] = this._shader.ambientR * this._ambientColorR;
        data[index + 1] = this._shader.ambientG * this._ambientColorG;
        data[index + 2] = this._shader.ambientB * this._ambientColorB;
        data[index + 3] = 1;
    };
    return DiffuseBasicChunk;
}(ShaderChunkBase));

/**
 * DiffuseCelChunk provides a shading method to add diffuse cel (cartoon) shading.
 */
var DiffuseCelChunk = (function (_super) {
    __extends(DiffuseCelChunk, _super);
    /**
     * Creates a new DiffuseCelChunk object.
     * @param levels The amount of shadow gradations.
     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.
     */
    function DiffuseCelChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        _this._baseChunk._modulateFunction = function (targetReg, registerCache, sharedRegisters) { return _this.clampDiffuse(targetReg, registerCache, sharedRegisters); };
        return _this;
    }
    /**
     * @inheritDoc
     */
    DiffuseCelChunk.prototype._initConstants = function () {
        _super.prototype._initConstants.call(this);
        var data = this._shader.fragmentConstantData;
        var index = this._clampDataIndex;
        data[index + 1] = 1;
        data[index + 2] = 0;
    };
    /**
     * @inheritDoc
     */
    DiffuseCelChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._clampDataRegister = null;
    };
    /**
     * @inheritDoc
     */
    DiffuseCelChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        this._clampDataRegister = registerCache.getFreeFragmentConstant();
        this._clampDataIndex = this._clampDataRegister.index * 4;
        return _super.prototype._getFragmentPreLightingCode.call(this, registerCache, sharedRegisters);
    };
    /**
     * @inheritDoc
     */
    DiffuseCelChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        if (this._invalid) {
            var data = this._shader.fragmentConstantData;
            var index = this._clampDataIndex;
            data[index] = this._method.levels;
            data[index + 3] = this._method.smoothness;
        }
    };
    /**
     * Snaps the diffuse shading of the wrapped method to one of the levels.
     * @param vo The MethodVO used to compile the current shader.
     * @param t The register containing the diffuse strength in the "w" component.
     * @param regCache The register cache used for the shader compilation.
     * @param sharedRegisters The shared register data for this shader.
     * @return The AGAL fragment code for the method.
     */
    DiffuseCelChunk.prototype.clampDiffuse = function (targetReg, registerCache, sharedRegisters) {
        return "mul " + targetReg + ".w, " + targetReg + ".w, " + this._clampDataRegister + ".x\n" +
            "frc " + targetReg + ".z, " + targetReg + ".w\n" +
            "sub " + targetReg + ".y, " + targetReg + ".w, " + targetReg + ".z\n" +
            "mov " + targetReg + ".x, " + this._clampDataRegister + ".x\n" +
            "sub " + targetReg + ".x, " + targetReg + ".x, " + this._clampDataRegister + ".y\n" +
            "rcp " + targetReg + ".x," + targetReg + ".x\n" +
            "mul " + targetReg + ".w, " + targetReg + ".y, " + targetReg + ".x\n" +
            // previous clamped strength
            "sub " + targetReg + ".y, " + targetReg + ".w, " + targetReg + ".x\n" +
            // fract/epsilon (so 0 - epsilon will become 0 - 1)
            "div " + targetReg + ".z, " + targetReg + ".z, " + this._clampDataRegister + ".w\n" +
            "sat " + targetReg + ".z, " + targetReg + ".z\n" +
            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".z\n" +
            // 1-z
            "sub " + targetReg + ".z, " + this._clampDataRegister + ".y, " + targetReg + ".z\n" +
            "mul " + targetReg + ".y, " + targetReg + ".y, " + targetReg + ".z\n" +
            "add " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n" +
            "sat " + targetReg + ".w, " + targetReg + ".w\n";
    };
    return DiffuseCelChunk;
}(LightingCompositeChunk));

/**
 * DiffuseGradientChunk is an alternative to DiffuseBasicChunk in which the shading can be modulated with a gradient
 * to introduce color-tinted shading as opposed to the single-channel diffuse strength. This can be used as a crude
 * approximation to subsurface scattering (for instance, the mid-range shading for skin can be tinted red to similate
 * scattered light within the skin attributing to the final colour)
 */
var DiffuseGradientChunk = (function (_super) {
    __extends(DiffuseGradientChunk, _super);
    /**
     * Creates a new DiffuseGradientChunk object.
     * @param gradient A texture that contains the light colour based on the angle. This can be used to change
     * the light colour due to subsurface scattering when the surface faces away from the light.
     */
    function DiffuseGradientChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    DiffuseGradientChunk.prototype._initVO = function (chunkVO) {
        _super.prototype._initVO.call(this, chunkVO);
        this._gradient = this._shader.getAbstraction(this._method.gradient || _awayjs_graphics.DefaultMaterialManager.getDefaultTexture());
    };
    /**
     * @inheritDoc
     */
    DiffuseGradientChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        var code = _super.prototype._getFragmentPreLightingCode.call(this, registerCache, sharedRegisters);
        this._pIsFirstLight = true;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseGradientChunk.prototype._getFragmentCodePerLight = function (lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight)
            t = this._totalLightColorReg;
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        code += "dp3 " + t + ".w, " + lightDirReg + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
            "mul " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".x\n" +
            "add " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".x\n" +
            "mul " + t + ".xyz, " + t + ".w, " + lightDirReg + ".w\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(t, registerCache, sharedRegisters);
        code += this._gradient._getFragmentCode(t, registerCache, sharedRegisters, t) +
            //					"mul " + t + ".xyz, " + t + ".xyz, " + t + ".w\n" +
            "mul " + t + ".xyz, " + t + ".xyz, " + lightColReg + ".xyz\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ".xyz, " + t + ".xyz\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseGradientChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        this._gradient.activate();
    };
    /**
     * @inheritDoc
     */
    DiffuseGradientChunk.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        this._gradient._setRenderState(renderable);
    };
    return DiffuseGradientChunk;
}(DiffuseBasicChunk));

/**
 * DiffuseLightMapChunk provides a diffuse shading method that uses a light map to modulate the calculated diffuse
 * lighting. It is different from EffectLightMapMethod in that the latter modulates the entire calculated pixel color, rather
 * than only the diffuse lighting value.
 */
var DiffuseLightMapChunk = (function (_super) {
    __extends(DiffuseLightMapChunk, _super);
    /**
     * Creates a new DiffuseLightMapChunk method.
     */
    function DiffuseLightMapChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    DiffuseLightMapChunk.prototype._initVO = function (chunkVO) {
        this._lightMap = this._shader.getAbstraction(this._method.lightMap || _awayjs_graphics.DefaultMaterialManager.getDefaultTexture());
        if (this._method.useSecondaryUV)
            this._shader.secondaryUVDependencies++;
        else
            this._shader.uvDependencies++;
    };
    /**
     * @inheritDoc
     */
    DiffuseLightMapChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code;
        var temp = registerCache.getFreeFragmentVectorTemp();
        code = this._lightMap._getFragmentCode(temp, registerCache, sharedRegisters, this._method.useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);
        switch (this._method.blendMode) {
            case DiffuseLightMapMethod.MULTIPLY:
                code += "mul " + this._totalLightColorReg + ", " + this._totalLightColorReg + ", " + temp + "\n";
                break;
            case DiffuseLightMapMethod.ADD:
                code += "add " + this._totalLightColorReg + ", " + this._totalLightColorReg + ", " + temp + "\n";
                break;
        }
        code += _super.prototype._getFragmentCode.call(this, targetReg, registerCache, sharedRegisters);
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseLightMapChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        this._lightMap.activate();
    };
    /**
     * @inheritDoc
     */
    DiffuseLightMapChunk.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        this._lightMap._setRenderState(renderable);
    };
    return DiffuseLightMapChunk;
}(LightingCompositeChunk));

/**
 * DiffuseWrapChunk is an alternative to DiffuseBasicChunk in which the light is allowed to be "wrapped around" the normally dark area, to some extent.
 * It can be used as a crude approximation to Oren-Nayar or simple subsurface scattering.
 */
var DiffuseWrapChunk = (function (_super) {
    __extends(DiffuseWrapChunk, _super);
    /**
     * Creates a new DiffuseWrapChunk object.
     */
    function DiffuseWrapChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    DiffuseWrapChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._wrapDataRegister = null;
    };
    /**
     * @inheritDoc
     */
    DiffuseWrapChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        var code = _super.prototype._getFragmentPreLightingCode.call(this, registerCache, sharedRegisters);
        this._pIsFirstLight = true;
        this._wrapDataRegister = registerCache.getFreeFragmentConstant();
        this._wrapDataIndex = this._wrapDataRegister.index * 4;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseWrapChunk.prototype._getFragmentCodePerLight = function (lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight) {
            t = this._totalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        code += "dp3 " + t + ".x, " + lightDirReg + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
            "add " + t + ".y, " + t + ".x, " + this._wrapDataRegister + ".x\n" +
            "mul " + t + ".y, " + t + ".y, " + this._wrapDataRegister + ".y\n" +
            "sat " + t + ".w, " + t + ".y\n" +
            "mul " + t + ".xz, " + t + ".w, " + lightDirReg + ".wz\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(lightDirReg, registerCache, sharedRegisters);
        code += "mul " + t + ", " + t + ".x, " + lightColReg + "\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ".xyz, " + t + ".xyz\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    DiffuseWrapChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        if (this._invalid) {
            var index = this._wrapDataIndex;
            var data = this._shader.fragmentConstantData;
            data[index] = this._method.wrapFactor;
            data[index + 1] = 1 / (this._method.wrapFactor + 1);
        }
    };
    return DiffuseWrapChunk;
}(DiffuseBasicChunk));

/**
 * EffectAlphaMaskChunk allows the use of an additional texture to specify the alpha value of the material. When used
 * with the secondary uv set, it allows for a tiled main texture with independently varying alpha (useful for water
 * etc).
 */
var EffectAlphaMaskChunk = (function (_super) {
    __extends(EffectAlphaMaskChunk, _super);
    /**
     * Creates a new EffectAlphaMaskChunk object.
     */
    function EffectAlphaMaskChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    EffectAlphaMaskChunk.prototype._initVO = function (chunkVO) {
        this._alphaMask = this._shader.getAbstraction(this._method.texture || _awayjs_graphics.DefaultMaterialManager.getDefaultTexture());
        if (this._method.useSecondaryUV)
            this._shader.secondaryUVDependencies++;
        else
            this._shader.uvDependencies++;
    };
    /**
     * @inheritDoc
     */
    EffectAlphaMaskChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var temp = registerCache.getFreeFragmentVectorTemp();
        return this._alphaMask._getFragmentCode(temp, registerCache, sharedRegisters, this._method.useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying) +
            "mul " + targetReg + ", " + targetReg + ", " + temp + ".x\n";
    };
    /**
     * @inheritDoc
     */
    EffectAlphaMaskChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        this._alphaMask.activate();
    };
    EffectAlphaMaskChunk.prototype._setRenderState = function (renderable, projection) {
        this._alphaMask._setRenderState(renderable);
    };
    return EffectAlphaMaskChunk;
}(ShaderChunkBase));

/**
 * EffectColorMatrixChunk provides a shading method that changes the colour of a material analogous to a ColorMatrixFilter.
 */
var EffectColorMatrixChunk = (function (_super) {
    __extends(EffectColorMatrixChunk, _super);
    /**
     * Creates a new EffectColorMatrixChunk
     *
     * @param method
     * @param shader
     */
    function EffectColorMatrixChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    EffectColorMatrixChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        var colorMultReg = registerCache.getFreeFragmentConstant();
        registerCache.getFreeFragmentConstant();
        registerCache.getFreeFragmentConstant();
        registerCache.getFreeFragmentConstant();
        var colorOffsetReg = registerCache.getFreeFragmentConstant();
        this._colorMatrixIndex = colorMultReg.index * 4;
        var temp = registerCache.getFreeFragmentVectorTemp();
        code += "m44 " + temp + ", " + targetReg + ", " + colorMultReg + "\n" +
            "add " + targetReg + ", " + temp + ", " + colorOffsetReg + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    EffectColorMatrixChunk.prototype._activate = function () {
        if (this._invalid) {
            var matrix = this._method.matrix;
            var index = this._colorMatrixIndex;
            var data = this._shader.fragmentConstantData;
            // r
            data[index] = matrix[0];
            data[index + 1] = matrix[1];
            data[index + 2] = matrix[2];
            data[index + 3] = matrix[3];
            // g
            data[index + 4] = matrix[5];
            data[index + 5] = matrix[6];
            data[index + 6] = matrix[7];
            data[index + 7] = matrix[8];
            // b
            data[index + 8] = matrix[10];
            data[index + 9] = matrix[11];
            data[index + 10] = matrix[12];
            data[index + 11] = matrix[13];
            // a
            data[index + 12] = matrix[15];
            data[index + 13] = matrix[16];
            data[index + 14] = matrix[17];
            data[index + 15] = matrix[18];
            // rgba offset
            data[index + 16] = matrix[4];
            data[index + 17] = matrix[9];
            data[index + 18] = matrix[14];
            data[index + 19] = matrix[19];
        }
    };
    return EffectColorMatrixChunk;
}(ShaderChunkBase));

/**
 * EffectColorTransformChumk provides a shading method that changes the colour of a material analogous to a
 * ColorTransform object.
 */
var EffectColorTransformChunk = (function (_super) {
    __extends(EffectColorTransformChunk, _super);
    /**
     * Creates a new EffectColorTransformChumk.
     */
    function EffectColorTransformChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    EffectColorTransformChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        var colorMultReg = registerCache.getFreeFragmentConstant();
        var colorOffsReg = registerCache.getFreeFragmentConstant();
        this._colorTransformIndex = colorMultReg.index * 4;
        //TODO: AGAL <> GLSL
        code += "mul " + targetReg + ", " + targetReg + ", " + colorMultReg + "\n" +
            "add " + targetReg + ", " + targetReg + ", " + colorOffsReg + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    EffectColorTransformChunk.prototype._activate = function () {
        if (this._invalid) {
            var index = this._colorTransformIndex;
            var data = this._shader.fragmentConstantData;
            var rawData = this._method.colorTransform._rawData;
            data[index] = rawData[0];
            data[index + 1] = rawData[1];
            data[index + 2] = rawData[2];
            data[index + 3] = rawData[3];
            data[index + 4] = rawData[4];
            data[index + 5] = rawData[5];
            data[index + 6] = rawData[6];
            data[index + 7] = rawData[7];
        }
    };
    return EffectColorTransformChunk;
}(ShaderChunkBase));

/**
 * EffectEnvMapChunk provides a material method to perform reflection mapping using cube maps.
 */
var EffectEnvMapChunk = (function (_super) {
    __extends(EffectEnvMapChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function EffectEnvMapChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    EffectEnvMapChunk.prototype._initVO = function (chunkVO) {
        chunkVO.needsNormals = true;
        chunkVO.needsView = true;
        this._envMap = this._shader.getAbstraction(this._method.envMap);
        if (this._method.mask) {
            this._maskMap = this._shader.getAbstraction(this._method.mask);
            this._shader.uvDependencies++;
        }
        else if (this._maskMap) {
            this._maskMap = null;
        }
    };
    /**
     * @inheritDoc
     */
    EffectEnvMapChunk.prototype.dispose = function () {
        this._envMap = null;
        this._maskMap = null;
    };
    /**
     * @inheritDoc
     */
    EffectEnvMapChunk.prototype._activate = function () {
        this._envMap.activate();
        if (this._maskMap)
            this._maskMap.activate();
        if (this._invalid)
            this._updateProperties();
    };
    EffectEnvMapChunk.prototype._setRenderState = function (renderable, projection) {
        this._envMap._setRenderState(renderable);
        if (this._maskMap)
            this._maskMap._setRenderState(renderable);
    };
    /**
     * @inheritDoc
     */
    EffectEnvMapChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var alphaRegister = registerCache.getFreeFragmentConstant();
        var code = "";
        this._fragmentIndex = alphaRegister.index * 4;
        var temp = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp, 1);
        var temp2 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp2, 1);
        // r = I - 2(I.N)*N
        code += "dp3 " + temp + ".w, " + sharedRegisters.viewDirFragment + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
            "add " + temp + ".w, " + temp + ".w, " + temp + ".w\n" +
            "mul " + temp + ".xyz, " + sharedRegisters.normalFragment + ".xyz, " + temp + ".w\n" +
            "sub " + temp + ".xyz, " + temp + ".xyz, " + sharedRegisters.viewDirFragment + ".xyz\n" +
            this._envMap._getFragmentCode(temp, registerCache, sharedRegisters, temp) +
            "sub " + temp2 + ".w, " + temp + ".w, fc0.x\n" +
            "kil " + temp2 + ".w\n" +
            "sub " + temp + ", " + temp + ", " + targetReg + "\n";
        if (this._maskMap) {
            code += this._maskMap._getFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
                "mul " + temp + ", " + temp2 + ", " + temp + "\n";
        }
        code += "mul " + temp + ", " + temp + ", " + alphaRegister + ".x\n" +
            "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
        registerCache.removeFragmentTempUsage(temp);
        registerCache.removeFragmentTempUsage(temp2);
        return code;
    };
    EffectEnvMapChunk.prototype._updateProperties = function () {
        this._shader.fragmentConstantData[this._fragmentIndex] = this._method.alpha;
    };
    return EffectEnvMapChunk;
}(ShaderChunkBase));

/**
 * EffectFogChunk provides a method to add distance-based fog to a material.
 */
var EffectFogChunk = (function (_super) {
    __extends(EffectFogChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function EffectFogChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    EffectFogChunk.prototype._initVO = function (chunkVO) {
        chunkVO.needsProjection = true;
    };
    /**
     * @inheritDoc
     */
    EffectFogChunk.prototype._activate = function () {
        if (this._invalid) {
            var data = this._shader.fragmentConstantData;
            var index = this._fogColorIndex;
            var color = this._method.fogColor;
            data[index] = ((color >> 16) & 0xff) / 0xff;
            data[index + 1] = ((color >> 8) & 0xff) / 0xff;
            data[index + 2] = (color & 0xff) / 0xff;
            data[index + 3] = 1;
            data[index + 4] = this._method.minDistance;
            data[index + 5] = 1 / (this._method.maxDistance - this._method.minDistance);
            data[index + 6] = 0;
            data[index + 7] = 0;
        }
    };
    /**
     * @inheritDoc
     */
    EffectFogChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var fogColor = registerCache.getFreeFragmentConstant();
        var fogData = registerCache.getFreeFragmentConstant();
        var temp = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp, 1);
        var temp2 = registerCache.getFreeFragmentVectorTemp();
        var code = "";
        this._fogColorIndex = fogColor.index * 4;
        code += "sub " + temp2 + ".w, " + sharedRegisters.projectionFragment + ".z, " + fogData + ".x\n" +
            "mul " + temp2 + ".w, " + temp2 + ".w, " + fogData + ".y\n" +
            "sat " + temp2 + ".w, " + temp2 + ".w\n" +
            "sub " + temp + ", " + fogColor + ", " + targetReg + "\n" +
            "mul " + temp + ", " + temp + ", " + temp2 + ".w\n" +
            "add " + targetReg + ", " + targetReg + ", " + temp + "\n"; // fogRatio*(fogColor- col) + col
        registerCache.removeFragmentTempUsage(temp);
        return code;
    };
    return EffectFogChunk;
}(ShaderChunkBase));

/**
 * EffectFresnelEnvMapChunk provides a method to add fresnel-based reflectivity to an object using cube maps, which gets
 * stronger as the viewing angle becomes more grazing.
 */
var EffectFresnelEnvMapChunk = (function (_super) {
    __extends(EffectFresnelEnvMapChunk, _super);
    function EffectFresnelEnvMapChunk() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    EffectFresnelEnvMapChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var dataRegister = registerCache.getFreeFragmentConstant();
        var code = "";
        var viewDirReg = sharedRegisters.viewDirFragment;
        var normalReg = sharedRegisters.normalFragment;
        this._fragmentIndex = dataRegister.index * 4;
        var temp = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp, 1);
        var temp2 = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp2, 1);
        // r = V - 2(V.N)*N
        code += "dp3 " + temp + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
            "add " + temp + ".w, " + temp + ".w, " + temp + ".w\n" +
            "mul " + temp + ".xyz, " + normalReg + ".xyz, " + temp + ".w\n" +
            "sub " + temp + ".xyz, " + temp + ".xyz, " + viewDirReg + ".xyz\n" +
            this._envMap._getFragmentCode(temp, registerCache, sharedRegisters, temp) +
            "sub " + temp2 + ".w, " + temp + ".w, fc0.x\n" +
            "kil " + temp2 + ".w\n" +
            "sub " + temp + ", " + temp + ", " + targetReg + "\n";
        // calculate fresnel term
        code += "dp3 " + viewDirReg + ".w, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
            "sub " + viewDirReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" +
            "pow " + viewDirReg + ".w, " + viewDirReg + ".w, " + dataRegister + ".z\n" +
            "sub " + normalReg + ".w, " + dataRegister + ".w, " + viewDirReg + ".w\n" +
            "mul " + normalReg + ".w, " + dataRegister + ".y, " + normalReg + ".w\n" +
            "add " + viewDirReg + ".w, " + viewDirReg + ".w, " + normalReg + ".w\n" +
            // total alpha
            "mul " + viewDirReg + ".w, " + dataRegister + ".x, " + viewDirReg + ".w\n";
        if (this._maskMap) {
            code += this._maskMap._getFragmentCode(temp2, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
                "mul " + viewDirReg + ".w, " + temp2 + ".x, " + viewDirReg + ".w\n";
        }
        // blend
        code += "mul " + temp + ", " + temp + ", " + viewDirReg + ".w\n" +
            "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
        registerCache.removeFragmentTempUsage(temp);
        registerCache.removeFragmentTempUsage(temp2);
        return code;
    };
    EffectFresnelEnvMapChunk.prototype._updateProperties = function () {
        var index = this._fragmentIndex;
        var data = this._shader.fragmentConstantData;
        data[index] = this._method.alpha;
        data[index + 1] = this._method.normalReflectance;
        data[index + 2] = this._method.fresnelPower;
    };
    return EffectFresnelEnvMapChunk;
}(EffectEnvMapChunk));

/**
 * EffectLightMapChunk provides a method that allows applying a light map texture to the calculated pixel colour.
 * It is different from DiffuseLightMapMethod in that the latter only modulates the diffuse shading value rather
 * than the whole pixel colour.
 */
var EffectLightMapChunk = (function (_super) {
    __extends(EffectLightMapChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function EffectLightMapChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    EffectLightMapChunk.prototype._initVO = function (chunkVO) {
        this._lightMap = this._shader.getAbstraction(this._method.lightMap);
        if (this._method.useSecondaryUV)
            this._shader.secondaryUVDependencies++;
        else
            this._shader.uvDependencies++;
    };
    /**
     * @inheritDoc
     */
    EffectLightMapChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code;
        var temp = registerCache.getFreeFragmentVectorTemp();
        code = this._lightMap._getFragmentCode(temp, registerCache, sharedRegisters, this._method.useSecondaryUV ? sharedRegisters.secondaryUVVarying : sharedRegisters.uvVarying);
        switch (this._method.blendMode) {
            case EffectLightMapMethod.MULTIPLY:
                code += "mul " + targetReg + ", " + targetReg + ", " + temp + "\n";
                break;
            case EffectLightMapMethod.ADD:
                code += "add " + targetReg + ", " + targetReg + ", " + temp + "\n";
                break;
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    EffectLightMapChunk.prototype._activate = function () {
        this._lightMap.activate();
    };
    EffectLightMapChunk.prototype._setRenderState = function (renderable, projection) {
        this._lightMap._setRenderState(renderable);
    };
    return EffectLightMapChunk;
}(ShaderChunkBase));

/**
 * ProjectiveTextureMethod is a material method used to project a texture unto the surface of an object.
 * This can be used for various effects apart from acting like a normal projector, such as projecting fake shadows
 * unto a surface, the impact of light coming through a stained glass window, ...
 */
var EffectProjectiveTextureChunk = (function (_super) {
    __extends(EffectProjectiveTextureChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function EffectProjectiveTextureChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    EffectProjectiveTextureChunk.prototype._initVO = function (chunkVO) {
        this._texture = this._shader.getAbstraction(this._method.projector.texture);
    };
    /**
     * @inheritDoc
     */
    EffectProjectiveTextureChunk.prototype._initConstants = function () {
        var index = this._exposureIndex;
        var data = this._shader.fragmentConstantData;
        data[index] = this._method.exposure;
        data[index + 1] = 0.5;
        data[index + 2] = 4;
        data[index + 3] = -1;
        this._projectionMatrix = new _awayjs_core.Matrix3D(new Float32Array(this._shader.vertexConstantData.buffer, this._projectionIndex * 4, 16));
    };
    /**
     * @inheritDoc
     */
    EffectProjectiveTextureChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._uvVarying = null;
        this._projectionMatrix = null;
    };
    /**
     * @inheritDoc
     */
    EffectProjectiveTextureChunk.prototype._getVertexCode = function (registerCache, sharedRegisters) {
        var code = "";
        var projReg = registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        registerCache.getFreeVertexConstant();
        this._projectionIndex = projReg.index * 4;
        this._uvVarying = registerCache.getFreeVarying();
        code += "m44 " + this._uvVarying + ", " + sharedRegisters.animatedPosition + ", " + projReg + "\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    EffectProjectiveTextureChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        var col = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(col, 1);
        var temp = registerCache.getFreeFragmentVectorTemp();
        //var toTexReg:ShaderRegisterElement = registerCache.getFreeFragmentConstant();
        //methodVO.fragmentConstantsIndex = toTexReg.index*4;
        var exposure = registerCache.getFreeFragmentConstant();
        this._exposureIndex = exposure.index * 4;
        // code += "mul " + col + ".xy, " + this._uvVarying + ".xy, " + toTexReg + ".xy	\n" +
        // 	"add " + col + ".xy, " + col + ".xy, " + toTexReg + ".xx	\n";
        code += this._texture._getFragmentCode(col, registerCache, sharedRegisters, this._uvVarying);
        code += "mul " + col + ", " + col + ", " + exposure + ".xxx\n" +
            "add " + col + ", " + col + ", " + exposure + ".xxx\n";
        if (this._method.mode == EffectProjectiveTextureMethod.MULTIPLY)
            code += "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + col + ".xyz			\n";
        else if (this._method.mode == EffectProjectiveTextureMethod.ADD)
            code += "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + col + ".xyz			\n";
        else if (this._method.mode == EffectProjectiveTextureMethod.MIX) {
            code += "sub " + col + ".xyz, " + col + ".xyz, " + targetReg + ".xyz				\n" +
                "mul " + col + ".xyz, " + col + ".xyz, " + col + ".w						\n" +
                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + col + ".xyz			\n";
        }
        else if (this._method.mode == EffectProjectiveTextureMethod.OVERLAY) {
            code += "sge " + temp + ", " + targetReg + ", " + exposure + ".yyy\n"; // temp = (base >= 0.5)? 1 : 0
            code += "sub " + targetReg + ", " + targetReg + ", " + temp + "\n"; // base = temp? (base - 1 : base)
            code += "sub " + col + ", " + col + ", " + temp + "\n"; // blend = temp? (blend - 1 : blend)
            code += "mul " + col + ", " + col + ", " + targetReg + "\n"; // blend = blend * base
            code += "sub " + targetReg + ", " + exposure + ".yyy, " + temp + "\n"; // base = temp? -0.5 : 0.5
            code += "mul " + targetReg + ", " + exposure + ".zzz, " + targetReg + "\n"; // base = temp? -2 : 2
            code += "mul " + col + ", " + col + ", " + targetReg + "\n"; // blend = blend * ( -2 : 2)
            code += "add " + targetReg + ", " + col + ", " + temp + "\n"; //blend = temp? (blend + 1 : blend)
        }
        else
            throw new _awayjs_core.ErrorBase("Unknown mode \"" + this._method.mode + "\"");
        registerCache.removeFragmentTempUsage(col);
        return code;
    };
    /**
     * @inheritDoc
     */
    EffectProjectiveTextureChunk.prototype._setRenderState = function (renderable, projection) {
        var matrix3D = _awayjs_core.Matrix3D.CALCULATION_MATRIX;
        matrix3D.copyFrom(this._method.projector.projection.viewMatrix3D);
        matrix3D.prepend(renderable.renderSceneTransform);
        this._projectionMatrix.copyFrom(matrix3D, true);
        this._texture._setRenderState(renderable);
    };
    /**
     * @inheritDoc
     */
    EffectProjectiveTextureChunk.prototype._activate = function () {
        this._texture.activate();
        if (this._invalid)
            this._shader.fragmentConstantData[this._exposureIndex] = this._method.exposure;
    };
    return EffectProjectiveTextureChunk;
}(ShaderChunkBase));

/**
 * EffectRefractionEnvMapMethod provides a method to add refracted transparency based on cube maps.
 */
var EffectRefractionEnvMapChunk = (function (_super) {
    __extends(EffectRefractionEnvMapChunk, _super);
    function EffectRefractionEnvMapChunk() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    EffectRefractionEnvMapChunk.prototype._initVO = function (chunkVO) {
        _super.prototype._initVO.call(this, chunkVO);
        this._useDispersion = !(this._method.dispersionR == this._method.dispersionB && this._method.dispersionR == this._method.dispersionG);
    };
    /**
     * @inheritDoc
     */
    EffectRefractionEnvMapChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        // todo: data2.x could use common reg, so only 1 reg is used
        var data = registerCache.getFreeFragmentConstant();
        var data2 = registerCache.getFreeFragmentConstant();
        var code = "";
        var refractionDir;
        var refractionColor;
        var temp;
        this._fragmentIndex = data.index * 4;
        refractionDir = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(refractionDir, 1);
        refractionColor = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(refractionColor, 1);
        temp = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp, 1);
        var viewDirReg = sharedRegisters.viewDirFragment;
        var normalReg = sharedRegisters.normalFragment;
        code += "neg " + viewDirReg + ".xyz, " + viewDirReg + ".xyz\n";
        code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
            "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" +
            "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
            "mul " + temp + ".w, " + data + ".x, " + temp + ".w\n" +
            "mul " + temp + ".w, " + data + ".x, " + temp + ".w\n" +
            "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
            "sqt " + temp + ".y, " + temp + ".w\n" +
            "mul " + temp + ".x, " + data + ".x, " + temp + ".x\n" +
            "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" +
            "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" +
            "mul " + refractionDir + ", " + data + ".x, " + viewDirReg + "\n" +
            "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" +
            "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n" +
            this._envMap._getFragmentCode(refractionColor, registerCache, sharedRegisters, refractionDir) +
            "sub " + refractionColor + ".w, " + refractionColor + ".w, fc0.x	\n" +
            "kil " + refractionColor + ".w\n";
        if (this._useDispersion) {
            // GREEN
            code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
                "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" +
                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
                "mul " + temp + ".w, " + data + ".y, " + temp + ".w\n" +
                "mul " + temp + ".w, " + data + ".y, " + temp + ".w\n" +
                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
                "sqt " + temp + ".y, " + temp + ".w\n" +
                "mul " + temp + ".x, " + data + ".y, " + temp + ".x\n" +
                "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" +
                "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" +
                "mul " + refractionDir + ", " + data + ".y, " + viewDirReg + "\n" +
                "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" +
                "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n" +
                this._envMap._getFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +
                "mov " + refractionColor + ".y, " + temp + ".y\n";
            // BLUE
            code += "dp3 " + temp + ".x, " + viewDirReg + ".xyz, " + normalReg + ".xyz\n" +
                "mul " + temp + ".w, " + temp + ".x, " + temp + ".x\n" +
                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
                "mul " + temp + ".w, " + data + ".z, " + temp + ".w\n" +
                "mul " + temp + ".w, " + data + ".z, " + temp + ".w\n" +
                "sub " + temp + ".w, " + data2 + ".x, " + temp + ".w\n" +
                "sqt " + temp + ".y, " + temp + ".w\n" +
                "mul " + temp + ".x, " + data + ".z, " + temp + ".x\n" +
                "add " + temp + ".x, " + temp + ".x, " + temp + ".y\n" +
                "mul " + temp + ".xyz, " + temp + ".x, " + normalReg + ".xyz\n" +
                "mul " + refractionDir + ", " + data + ".z, " + viewDirReg + "\n" +
                "sub " + refractionDir + ".xyz, " + refractionDir + ".xyz, " + temp + ".xyz\n" +
                "nrm " + refractionDir + ".xyz, " + refractionDir + ".xyz\n" +
                this._envMap._getFragmentCode(temp, registerCache, sharedRegisters, refractionDir) +
                "mov " + refractionColor + ".z, " + temp + ".z\n";
        }
        code += "sub " + refractionColor + ".xyz, " + refractionColor + ".xyz, " + targetReg + ".xyz\n" +
            "mul " + refractionColor + ".xyz, " + refractionColor + ".xyz, " + data + ".w\n" +
            "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + refractionColor + ".xyz\n";
        registerCache.removeFragmentTempUsage(temp);
        registerCache.removeFragmentTempUsage(refractionDir);
        registerCache.removeFragmentTempUsage(refractionColor);
        // restore
        code += "neg " + viewDirReg + ".xyz, " + viewDirReg + ".xyz\n";
        return code;
    };
    EffectRefractionEnvMapChunk.prototype._updateProperties = function () {
        var index = this._fragmentIndex;
        var data = this._shader.fragmentConstantData;
        var refractionIndex = this._method.refractionIndex;
        data[index] = this._method.dispersionR + refractionIndex;
        if (this._useDispersion) {
            data[index + 1] = this._method.dispersionG + refractionIndex;
            data[index + 2] = this._method.dispersionB + refractionIndex;
        }
        data[index + 3] = this._method.alpha;
    };
    return EffectRefractionEnvMapChunk;
}(EffectEnvMapChunk));

/**
 * EffectRimLightChunk provides a method to add rim lighting to a material. This adds a glow-like effect to edges of objects.
 */
var EffectRimLightChunk = (function (_super) {
    __extends(EffectRimLightChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function EffectRimLightChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    EffectRimLightChunk.prototype._initVO = function (chunkVO) {
        chunkVO.needsNormals = true;
        chunkVO.needsView = true;
    };
    /**
     * @inheritDoc
     */
    EffectRimLightChunk.prototype._activate = function () {
        if (this._invalid) {
            var index = this._rimColorIndex;
            var data = this._shader.fragmentConstantData;
            var color = this._method.color;
            data[index] = ((color >> 16) & 0xff) / 0xff;
            data[index + 1] = ((color >> 8) & 0xff) / 0xff;
            data[index + 2] = (color & 0xff) / 0xff;
            data[index + 3] = 1;
            data[index + 4] = this._method.strength;
            data[index + 5] = this._method.power;
        }
    };
    /**
     * @inheritDoc
     */
    EffectRimLightChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var dataRegister = registerCache.getFreeFragmentConstant();
        var dataRegister2 = registerCache.getFreeFragmentConstant();
        var temp = registerCache.getFreeFragmentVectorTemp();
        var code = "";
        this._rimColorIndex = dataRegister.index * 4;
        code += "dp3 " + temp + ".x, " + sharedRegisters.viewDirFragment + ".xyz, " + sharedRegisters.normalFragment + ".xyz\n" +
            "sat " + temp + ".x, " + temp + ".x\n" +
            "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x\n" +
            "pow " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".y\n" +
            "mul " + temp + ".x, " + temp + ".x, " + dataRegister2 + ".x\n" +
            "sub " + temp + ".x, " + dataRegister + ".w, " + temp + ".x\n" +
            "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".x\n" +
            "sub " + temp + ".w, " + dataRegister + ".w, " + temp + ".x\n";
        if (this._method.blendMode == EffectRimLightMethod.ADD) {
            code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz\n" +
                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
        }
        else if (this._method.blendMode == EffectRimLightMethod.MULTIPLY) {
            code += "mul " + temp + ".xyz, " + temp + ".w, " + dataRegister + ".xyz\n" +
                "mul " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
        }
        else {
            code += "sub " + temp + ".xyz, " + dataRegister + ".xyz, " + targetReg + ".xyz\n" +
                "mul " + temp + ".xyz, " + temp + ".xyz, " + temp + ".w\n" +
                "add " + targetReg + ".xyz, " + targetReg + ".xyz, " + temp + ".xyz\n";
        }
        return code;
    };
    return EffectRimLightChunk;
}(ShaderChunkBase));

/**
 * NormalBasicChunk is the default method for standard tangent-space normal mapping.
 */
var NormalBasicChunk = (function (_super) {
    __extends(NormalBasicChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function NormalBasicChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    NormalBasicChunk.prototype._isUsed = function () {
        if (this._texture && this._shader.normalDependencies)
            return true;
        return false;
    };
    /**
     * @inheritDoc
     */
    NormalBasicChunk.prototype._initVO = function (chunkVO) {
        if (this._method.texture) {
            this._texture = this._shader.getAbstraction(this._method.texture);
            this._shader.uvDependencies++;
        }
    };
    /**
     * Indicates whether or not this method outputs normals in tangent space. Override for object-space normals.
     */
    NormalBasicChunk.prototype._outputsTangentNormals = function () {
        return true;
    };
    /**
     * @inheritDoc
     */
    NormalBasicChunk.prototype._activate = function () {
        if (this._texture)
            this._texture.activate();
    };
    NormalBasicChunk.prototype._setRenderState = function (renderable, projection) {
        if (this._texture)
            this._texture._setRenderState(renderable);
    };
    /**
     * @inheritDoc
     */
    NormalBasicChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        if (this._texture)
            code += this._texture._getFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying);
        code += "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + sharedRegisters.commons + ".xxx\n" +
            "nrm " + targetReg + ".xyz, " + targetReg + "\n";
        return code;
    };
    return NormalBasicChunk;
}(ShaderChunkBase));

/**
 * NormalHeightMapChunk provides a normal map method that uses a height map to calculate the normals.
 */
var NormalHeightMapChunk = (function (_super) {
    __extends(NormalHeightMapChunk, _super);
    /**
     * Creates a new NormalHeightMapChunk.
     */
    function NormalHeightMapChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    NormalHeightMapChunk.prototype._initConstants = function () {
        var index = this._fragmentConstantsIndex;
        var data = this._shader.fragmentConstantData;
        data[index] = 1 / this._method.texture.image2D.width;
        data[index + 1] = 1 / this._method.texture.image2D.height;
        data[index + 2] = 0;
        data[index + 3] = 1;
        data[index + 4] = this._method.worldXYRatio;
        data[index + 5] = this._method.worldXZRatio;
    };
    Object.defineProperty(NormalHeightMapChunk.prototype, "tangentSpace", {
        /**
         * @inheritDoc
         */
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    NormalHeightMapChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        var temp = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp, 1);
        var dataReg = registerCache.getFreeFragmentConstant();
        var dataReg2 = registerCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = dataReg.index * 4;
        code += this._texture._getFragmentCode(targetReg, registerCache, sharedRegisters, sharedRegisters.uvVarying) +
            "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg + ".xzzz\n" +
            this._texture._getFragmentCode(temp, registerCache, sharedRegisters, temp) +
            "sub " + targetReg + ".x, " + targetReg + ".x, " + temp + ".x\n" +
            "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg + ".zyzz\n" +
            this._texture._getFragmentCode(temp, registerCache, sharedRegisters, temp) +
            "sub " + targetReg + ".z, " + targetReg + ".z, " + temp + ".x\n" +
            "mov " + targetReg + ".y, " + dataReg + ".w\n" +
            "mul " + targetReg + ".xz, " + targetReg + ".xz, " + dataReg2 + ".xy\n" +
            "nrm " + targetReg + ".xyz, " + targetReg + ".xyz\n";
        registerCache.removeFragmentTempUsage(temp);
        return code;
    };
    return NormalHeightMapChunk;
}(NormalBasicChunk));

/**
 * NormalSimpleWaterChunk provides a basic normal map method to create water ripples by translating two wave normal maps.
 */
var NormalSimpleWaterChunk = (function (_super) {
    __extends(NormalSimpleWaterChunk, _super);
    /**
     * Creates a new NormalHeightMapChunk.
     */
    function NormalSimpleWaterChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    NormalSimpleWaterChunk.prototype._initConstants = function () {
        var index = this._fragmentConstantsIndex;
        var data = this._shader.fragmentConstantData;
        data[index] = .5;
        data[index + 1] = 0;
        data[index + 2] = 0;
        data[index + 3] = 1;
    };
    /**
     * @inheritDoc
     */
    NormalSimpleWaterChunk.prototype._initVO = function (chunkVO) {
        _super.prototype._initVO.call(this, chunkVO);
        if (this._method.secondaryNormalMap) {
            this._secondaryNormalMap = this._shader.getAbstraction(this._method.secondaryNormalMap);
            this._shader.uvDependencies++;
        }
    };
    /**
     * @inheritDoc
     */
    NormalSimpleWaterChunk.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._secondaryNormalMap = null;
    };
    /**
     * @inheritDoc
     */
    NormalSimpleWaterChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        if (this._invalid) {
            var data = this._shader.fragmentConstantData;
            var index = this._fragmentConstantsIndex;
            data[index + 4] = this._method.water1OffsetX;
            data[index + 5] = this._method.water1OffsetY;
            data[index + 6] = this._method.water2OffsetX;
            data[index + 7] = this._method.water2OffsetY;
        }
        if (this._secondaryNormalMap)
            this._secondaryNormalMap.activate();
    };
    /**
     * @inheritDoc
     */
    NormalSimpleWaterChunk.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        if (this._secondaryNormalMap)
            this._secondaryNormalMap._setRenderState(renderable);
    };
    /**
     * @inheritDoc
     */
    NormalSimpleWaterChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        var temp = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp, 1);
        var dataReg = registerCache.getFreeFragmentConstant();
        var dataReg2 = registerCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = dataReg.index * 4;
        code += "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg2 + ".xyxy\n";
        if (this._texture)
            code += this._texture._getFragmentCode(targetReg, registerCache, sharedRegisters, temp);
        code += "add " + temp + ", " + sharedRegisters.uvVarying + ", " + dataReg2 + ".zwzw\n";
        if (this._secondaryNormalMap)
            code += this._secondaryNormalMap._getFragmentCode(temp, registerCache, sharedRegisters, temp);
        code += "add " + targetReg + ", " + targetReg + ", " + temp + "		\n" +
            "mul " + targetReg + ", " + targetReg + ", " + dataReg + ".x	\n" +
            "sub " + targetReg + ".xyz, " + targetReg + ".xyz, " + sharedRegisters.commons + ".xxx	\n" +
            "nrm " + targetReg + ".xyz, " + targetReg + ".xyz							\n";
        return code;
    };
    return NormalSimpleWaterChunk;
}(NormalBasicChunk));

/**
 * ShadowCascadeChunk is a shadow map method to apply cascade shadow mapping on materials.
 * Must be used with a DirectionalLight with a CascadeShadowMapper assigned to its shadowMapper property.
 *
 * @see away.lights.CascadeShadowMapper
 */
var ShadowCascadeChunk = (function (_super) {
    __extends(ShadowCascadeChunk, _super);
    /**
     * Creates a new ShadowCascadeChunk.
     */
    function ShadowCascadeChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ShadowCascadeChunk.prototype._initVO = function (chunkVO) {
        _super.prototype._initVO.call(this, chunkVO);
        chunkVO.needsProjection = true;
    };
    /**
     * @inheritDoc
     */
    ShadowCascadeChunk.prototype._initConstants = function () {
        _super.prototype._initConstants.call(this);
        var fragmentData = this._shader.fragmentConstantData;
        var vertexData = this._shader.vertexConstantData;
        var index = this._fragmentConstantsIndex;
        fragmentData[index] = 1.0;
        fragmentData[index + 1] = 1 / 255.0;
        fragmentData[index + 2] = 1 / 65025.0;
        fragmentData[index + 3] = 1 / 16581375.0;
        fragmentData[index + 6] = .5;
        fragmentData[index + 7] = -.5;
        index = this._vertexConstantsIndex;
        vertexData[index] = .5;
        vertexData[index + 1] = -.5;
        vertexData[index + 2] = 0;
        var numCascades = this._method.cascadeShadowMapper.numCascades;
        this._projectionMatrices = new Array(numCascades);
        for (var k = 0; k < numCascades; ++k)
            this._projectionMatrices[k] = new _awayjs_core.Matrix3D(new Float32Array(this._shader.vertexConstantData.buffer, (this._vertexConstantsIndex + 4 + k * 16) * 4, 16));
    };
    /**
     * @inheritDoc
     */
    ShadowCascadeChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._cascadeProjections = null;
        this._depthMapCoordVaryings = null;
        this._projectionMatrices = null;
    };
    /**
     * @inheritDoc
     */
    ShadowCascadeChunk.prototype._getVertexCode = function (registerCache, sharedRegisters) {
        var code = "";
        var dataReg = registerCache.getFreeVertexConstant();
        this._vertexConstantsIndex = dataReg.index * 4;
        //Create the registers for the cascades' projection coordinates.
        this._cascadeProjections = new Array(this._method.cascadeShadowMapper.numCascades);
        this._depthMapCoordVaryings = new Array(this._method.cascadeShadowMapper.numCascades);
        for (var i = 0; i < this._method.cascadeShadowMapper.numCascades; ++i) {
            this._depthMapCoordVaryings[i] = registerCache.getFreeVarying();
            this._cascadeProjections[i] = registerCache.getFreeVertexConstant();
            registerCache.getFreeVertexConstant();
            registerCache.getFreeVertexConstant();
            registerCache.getFreeVertexConstant();
        }
        var temp = registerCache.getFreeVertexVectorTemp();
        for (var i = 0; i < this._method.cascadeShadowMapper.numCascades; ++i) {
            code += "m44 " + temp + ", " + sharedRegisters.globalPositionVertex + ", " + this._cascadeProjections[i] + "\n" +
                "add " + this._depthMapCoordVaryings[i] + ", " + temp + ", " + dataReg + ".zzwz\n";
        }
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowCascadeChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var numCascades = this._method.cascadeShadowMapper.numCascades;
        var decReg = registerCache.getFreeFragmentConstant();
        var dataReg = registerCache.getFreeFragmentConstant();
        var planeDistanceReg = registerCache.getFreeFragmentConstant();
        var planeDistances = Array(planeDistanceReg + ".x", planeDistanceReg + ".y", planeDistanceReg + ".z", planeDistanceReg + ".w");
        var code;
        this._fragmentConstantsIndex = decReg.index * 4;
        var inQuad = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(inQuad, 1);
        var uvCoord = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(uvCoord, 1);
        // assume lowest partition is selected, will be overwritten later otherwise
        code = "mov " + uvCoord + ", " + this._depthMapCoordVaryings[numCascades - 1] + "\n";
        for (var i = numCascades - 2; i >= 0; --i) {
            var uvProjection = this._depthMapCoordVaryings[i];
            // calculate if in texturemap (result == 0 or 1, only 1 for a single partition)
            code += "slt " + inQuad + ".z, " + sharedRegisters.projectionFragment + ".z, " + planeDistances[i] + "\n"; // z = x > minX, w = y > minY
            var temp = registerCache.getFreeFragmentVectorTemp();
            // linearly interpolate between old and new uv coords using predicate value == conditional toggle to new value if predicate == 1 (true)
            code += "sub " + temp + ", " + uvProjection + ", " + uvCoord + "\n" +
                "mul " + temp + ", " + temp + ", " + inQuad + ".z\n" +
                "add " + uvCoord + ", " + uvCoord + ", " + temp + "\n";
        }
        registerCache.removeFragmentTempUsage(inQuad);
        code += "div " + uvCoord + ", " + uvCoord + ", " + uvCoord + ".w\n" +
            "mul " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zw\n" +
            "add " + uvCoord + ".xy, " + uvCoord + ".xy, " + dataReg + ".zz\n";
        code += this._baseChunk._getCascadeFragmentCode(decReg, uvCoord, targetReg, registerCache, sharedRegisters) +
            "add " + targetReg + ".w, " + targetReg + ".w, " + dataReg + ".y\n";
        registerCache.removeFragmentTempUsage(uvCoord);
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowCascadeChunk.prototype._activate = function () {
        this._baseChunk.depthMap.activate();
        this._shader.vertexConstantData[this._vertexConstantsIndex + 3] = -1 / (this._method.cascadeShadowMapper.depth * this._method.epsilon);
        var numCascades = this._method.cascadeShadowMapper.numCascades;
        for (var k = 0; k < numCascades; ++k)
            this._projectionMatrices[k].copyFrom(this._method.cascadeShadowMapper.getDepthProjections(k), true);
        var fragmentData = this._shader.fragmentConstantData;
        var fragmentIndex = this._fragmentConstantsIndex;
        fragmentData[fragmentIndex + 5] = 1 - this._method.alpha;
        var nearPlaneDistances = this._method.cascadeShadowMapper._iNearPlaneDistances;
        fragmentIndex += 8;
        for (var i = 0; i < numCascades; ++i)
            fragmentData[fragmentIndex + i] = nearPlaneDistances[i];
        this._baseChunk._activateForCascade();
    };
    /**
     * @inheritDoc
     */
    ShadowCascadeChunk.prototype._setRenderState = function (renderable, projection) {
    };
    return ShadowCascadeChunk;
}(CompositeChunkBase));

/**
 * ShadowChunkBase provides an abstract method for simple (non-wrapping) shadow map methods.
 */
var ShadowChunkBase = (function (_super) {
    __extends(ShadowChunkBase, _super);
    /**
     * Creates a new ShadowChunkBase object.
     */
    function ShadowChunkBase(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        _this._usePoint = (method.castingLight instanceof _awayjs_scene.PointLight);
        return _this;
    }
    Object.defineProperty(ShadowChunkBase.prototype, "depthMap", {
        get: function () {
            return this._depthMap;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ShadowChunkBase.prototype._initVO = function (chunkVO) {
        chunkVO.needsView = true;
        chunkVO.needsGlobalVertexPos = true;
        chunkVO.needsGlobalFragmentPos = this._usePoint;
        chunkVO.needsNormals = this._shader.numLights > 0;
        this._depthMap = this._shader.getAbstraction(this._method.castingLight.shadowMapper.depthMap);
    };
    /**
     * @inheritDoc
     */
    ShadowChunkBase.prototype._initConstants = function () {
        var fragmentData = this._shader.fragmentConstantData;
        var vertexData = this._shader.vertexConstantData;
        var index = this._fragmentConstantsIndex;
        fragmentData[index] = 1.0;
        fragmentData[index + 1] = 1 / 255.0;
        fragmentData[index + 2] = 1 / 65025.0;
        fragmentData[index + 3] = 1 / 16581375.0;
        fragmentData[index + 6] = 0;
        fragmentData[index + 7] = 1;
        if (this._usePoint) {
            fragmentData[index + 8] = 0;
            fragmentData[index + 9] = 0;
            fragmentData[index + 10] = 0;
            fragmentData[index + 11] = 1;
        }
        index = this._vertexConstantsIndex;
        if (index != -1) {
            vertexData[index] = .5;
            vertexData[index + 1] = .5;
            vertexData[index + 2] = 0.0;
            vertexData[index + 3] = 1.0;
        }
        this._depthProjectionMatrix = new _awayjs_core.Matrix3D(new Float32Array(this._shader.vertexConstantData.buffer, (this._vertexConstantsIndex + 4) * 4, 16));
    };
    Object.defineProperty(ShadowChunkBase.prototype, "_iDepthMapCoordReg", {
        /**
         * Wrappers that override the vertex shader need to set this explicitly
         */
        get: function () {
            return this._depthMapCoordReg;
        },
        set: function (value) {
            this._depthMapCoordReg = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    ShadowChunkBase.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._depthMapCoordReg = null;
    };
    /**
     * @inheritDoc
     */
    ShadowChunkBase.prototype._getVertexCode = function (regCache, sharedRegisters) {
        return this._usePoint ? this._getPointVertexCode(regCache, sharedRegisters) : this._getPlanarVertexCode(regCache, sharedRegisters);
    };
    /**
     * @inheritDoc
     */
    ShadowChunkBase.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = this._usePoint ? this._getPointFragmentCode(targetReg, registerCache, sharedRegisters) : this._getPlanarFragmentCode(targetReg, registerCache, sharedRegisters);
        code += "add " + targetReg + ".w, " + targetReg + ".w, fc" + (this._fragmentConstantsIndex / 4 + 1) + ".y\n" +
            "sat " + targetReg + ".w, " + targetReg + ".w\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowChunkBase.prototype._setRenderState = function (renderable, projection) {
        if (!this._usePoint)
            this._depthProjectionMatrix.copyFrom(this._method.castingLight.shadowMapper.iDepthProjection, true);
        this._depthMap._setRenderState(renderable);
    };
    /**
     * Gets the fragment code for combining this method with a cascaded shadow map method.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param decodeRegister The register containing the data to decode the shadow map depth value.
     * @param depthTexture The texture containing the shadow map.
     * @param depthProjection The projection of the fragment relative to the light.
     * @param targetRegister The register to contain the shadow coverage
     * @return
     */
    ShadowChunkBase.prototype._getCascadeFragmentCode = function (decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
        throw new Error("This shadow method is incompatible with cascade shadows");
    };
    /**
     * @inheritDoc
     */
    ShadowChunkBase.prototype._activate = function () {
        var fragmentData = this._shader.fragmentConstantData;
        var index = this._fragmentConstantsIndex;
        if (this._usePoint)
            fragmentData[index + 4] = -Math.pow(1 / (this._method.castingLight.fallOff * this._method.epsilon), 2);
        else
            this._shader.vertexConstantData[this._vertexConstantsIndex + 3] = -1 / (this._method.castingLight.shadowMapper.depth * this._method.epsilon);
        fragmentData[index + 5] = 1 - this._method.alpha;
        if (this._usePoint) {
            var pos = this._method.castingLight.scenePosition;
            fragmentData[index + 8] = pos.x;
            fragmentData[index + 9] = pos.y;
            fragmentData[index + 10] = pos.z;
            // used to decompress distance
            var f = this._method.castingLight.fallOff;
            fragmentData[index + 11] = 1 / (2 * f * f);
        }
        this._depthMap.activate();
    };
    /**
     * Sets the method state for cascade shadow mapping.
     */
    ShadowChunkBase.prototype._activateForCascade = function () {
        throw new Error("This shadow method is incompatible with cascade shadows");
    };
    /**
     * Gets the vertex code for shadow mapping with a point light.
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     */
    ShadowChunkBase.prototype._getPointVertexCode = function (regCache, sharedRegisters) {
        this._vertexConstantsIndex = -1;
        return "";
    };
    /**
     * Gets the vertex code for shadow mapping with a planar shadow map (fe: directional lights).
     *
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     */
    ShadowChunkBase.prototype._getPlanarVertexCode = function (regCache, sharedRegisters) {
        var code = "";
        var temp = regCache.getFreeVertexVectorTemp();
        var dataReg = regCache.getFreeVertexConstant();
        this._vertexConstantsIndex = dataReg.index * 4;
        var depthMapProj = regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        regCache.getFreeVertexConstant();
        this._depthMapCoordReg = regCache.getFreeVarying();
        // todo: can epsilon be applied here instead of fragment shader?
        code += "m44 " + temp + ", " + sharedRegisters.globalPositionVertex + ", " + depthMapProj + "\n" +
            "div " + temp + ", " + temp + ", " + temp + ".w\n" +
            "mul " + temp + ".xy, " + temp + ".xy, " + dataReg + ".xy\n" +
            "add " + this._depthMapCoordReg + ", " + temp + ", " + dataReg + ".xxwz\n";
        //"sub " + this._depthMapCoordReg + ".z, " + this._depthMapCoordReg + ".z, " + this._depthMapCoordReg + ".w\n";
        return code;
    };
    /**
     * Gets the fragment code for shadow mapping with a planar shadow map.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register to contain the shadow coverage
     * @return
     */
    ShadowChunkBase.prototype._getPlanarFragmentCode = function (targetReg, regCache, sharedRegisters) {
        throw new _awayjs_core.AbstractMethodError();
    };
    /**
     * Gets the fragment code for shadow mapping with a point light.
     * @param methodVO The MethodVO object linking this method with the pass currently being compiled.
     * @param regCache The register cache used during the compilation.
     * @param targetReg The register to contain the shadow coverage
     * @return
     */
    ShadowChunkBase.prototype._getPointFragmentCode = function (targetReg, regCache, sharedRegisters) {
        throw new _awayjs_core.AbstractMethodError();
    };
    return ShadowChunkBase;
}(ShaderChunkBase));

/**
 * ShadowDitheredChunk provides a soft shadowing technique by randomly distributing sample points differently for each fragment.
 */
var ShadowDitheredChunk = (function (_super) {
    __extends(ShadowDitheredChunk, _super);
    /**
     * Creates a new ShadowDitheredChunk.
     */
    function ShadowDitheredChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    ShadowDitheredChunk.prototype._initVO = function (chunkVO) {
        _super.prototype._initVO.call(this, chunkVO);
        chunkVO.needsProjection = true;
        this._grainMap = this._shader.getAbstraction(ShadowDitheredMethod._grainTexture);
    };
    /**
     * @inheritDoc
     */
    ShadowDitheredChunk.prototype._initConstants = function () {
        _super.prototype._initConstants.call(this);
        var data = this._shader.fragmentConstantData;
        var index = this._fragmentConstantsIndex;
        data[index + 8] = 1 / this._method.numSamples;
    };
    /**
     * @inheritDoc
     */
    ShadowDitheredChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        var data = this._shader.fragmentConstantData;
        var index = this._fragmentConstantsIndex;
        data[index + 9] = (this._stage.width - 1) / 63;
        data[index + 10] = (this._stage.height - 1) / 63;
        data[index + 11] = 2 * this._method.range / this._method.castingLight.shadowMapper.depthMapSize;
        this._grainMap.activate();
    };
    /**
     * @inheritDoc
     */
    ShadowDitheredChunk.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        this._grainMap._setRenderState(renderable);
    };
    /**
     * Adds the code for another tap to the shader code.
     * @param uvReg The uv register for the tap.
     * @param depthMapRegister The texture register containing the depth map.
     * @param decReg The register containing the depth map decoding data.
     * @param targetReg The target register to add the tap comparison result.
     * @param regCache The register cache managing the registers.
     * @return
     */
    ShadowDitheredChunk.prototype._addSample = function (uvReg, decReg, targetReg, regCache, sharedRegisters) {
        var temp = regCache.getFreeFragmentVectorTemp();
        return this._depthMap._getFragmentCode(temp, regCache, sharedRegisters, uvReg) +
            "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" +
            "slt " + temp + ".z, " + this._depthMapCoordReg + ".z, " + temp + ".z\n" +
            "add " + targetReg + ".w, " + targetReg + ".w, " + temp + ".z\n";
    };
    /**
     * @inheritDoc
     */
    ShadowDitheredChunk.prototype._activateForCascade = function () {
        var data = this._shader.fragmentConstantData;
        var index = this._cascadeFragmentConstantsIndex;
        data[index] = 1 / this._method.numSamples;
        data[index + 1] = (this._stage.width - 1) / 63;
        data[index + 2] = (this._stage.height - 1) / 63;
        data[index + 3] = 2 * this._method.range / this._method.castingLight.shadowMapper.depthMapSize;
        this._grainMap.activate();
    };
    /**
     * @inheritDoc
     */
    ShadowDitheredChunk.prototype._getCascadeFragmentCode = function (decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
        this._depthMapCoordReg = depthProjection;
        var dataReg = registerCache.getFreeFragmentConstant();
        this._cascadeFragmentConstantsIndex = dataReg.index * 4;
        return this.getSampleCode(dataReg, decodeRegister, targetRegister, registerCache, sharedRegisters);
    };
    /**
     * @inheritDoc
     */
    ShadowDitheredChunk.prototype._getPlanarFragmentCode = function (targetReg, regCache, sharedRegisters) {
        var decReg = regCache.getFreeFragmentConstant();
        var dataReg = regCache.getFreeFragmentConstant();
        var customDataReg = regCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = decReg.index * 4;
        return this.getSampleCode(customDataReg, decReg, targetReg, regCache, sharedRegisters);
    };
    /**
     * Get the actual shader code for shadow mapping
     * @param regCache The register cache managing the registers.
     * @param depthMapRegister The texture register containing the depth map.
     * @param decReg The register containing the depth map decoding data.
     * @param targetReg The target register to add the shadow coverage.
     */
    ShadowDitheredChunk.prototype.getSampleCode = function (customDataReg, decReg, targetReg, regCache, sharedRegisters) {
        var code = "";
        var numSamples = this._method.numSamples;
        var uvReg = regCache.getFreeFragmentVectorTemp();
        regCache.addFragmentTempUsages(uvReg, 1);
        var temp = regCache.getFreeFragmentVectorTemp();
        regCache.addFragmentTempUsages(temp, 1);
        var projectionReg = sharedRegisters.projectionFragment;
        code += "div " + uvReg + ", " + projectionReg + ", " + projectionReg + ".w\n" +
            "mul " + uvReg + ".xy, " + uvReg + ".xy, " + customDataReg + ".yz\n";
        var index = numSamples;
        while (index > 0) {
            if (index == numSamples) {
                code += this._grainMap._getFragmentCode(uvReg, regCache, sharedRegisters, uvReg);
            }
            else {
                code += "mov " + temp + ", " + uvReg + ".zwxy \n" +
                    this._grainMap._getFragmentCode(uvReg, regCache, sharedRegisters, temp);
            }
            // keep grain in uvReg.zw
            code += "sub " + uvReg + ".zw, " + uvReg + ".xy, fc0.xx\n" +
                "mul " + uvReg + ".zw, " + uvReg + ".zw, " + customDataReg + ".w\n"; // (tex unpack scale and tex scale in one)
            if (index == numSamples) {
                // first sample
                code += "add " + uvReg + ".xy, " + uvReg + ".zw, " + this._depthMapCoordReg + ".xy\n" +
                    this._depthMap._getFragmentCode(temp, regCache, sharedRegisters, uvReg) +
                    "dp4 " + temp + ".z, " + temp + ", " + decReg + "\n" +
                    "slt " + targetReg + ".w, " + this._depthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow
            }
            else {
                code += this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            }
            if (index > 4)
                code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            if (index > 1)
                code += "sub " + uvReg + ".xy, " + this._depthMapCoordReg + ".xy, " + uvReg + ".zw\n" + this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            if (index > 5)
                code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".zw\n" + this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            if (index > 2) {
                code += "neg " + uvReg + ".w, " + uvReg + ".w\n"; // will be rotated 90 degrees when being accessed as wz
                code += "add " + uvReg + ".xy, " + uvReg + ".wz, " + this._depthMapCoordReg + ".xy\n" + this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            }
            if (index > 6)
                code += "add " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            if (index > 3)
                code += "sub " + uvReg + ".xy, " + this._depthMapCoordReg + ".xy, " + uvReg + ".wz\n" + this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            if (index > 7)
                code += "sub " + uvReg + ".xy, " + uvReg + ".xy, " + uvReg + ".wz\n" + this._addSample(uvReg, decReg, targetReg, regCache, sharedRegisters);
            index -= 8;
        }
        regCache.removeFragmentTempUsage(temp);
        regCache.removeFragmentTempUsage(uvReg);
        code += "mul " + targetReg + ".w, " + targetReg + ".w, " + customDataReg + ".x\n"; // average
        return code;
    };
    return ShadowDitheredChunk;
}(ShadowChunkBase));

/**
 * ShadowFilteredChunk provides a softened shadowing technique by bilinearly interpolating shadow comparison
 * results of neighbouring pixels.
 */
var ShadowFilteredChunk = (function (_super) {
    __extends(ShadowFilteredChunk, _super);
    /**
     * Creates a new ShadowFilteredChunk.
     */
    function ShadowFilteredChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    ShadowFilteredChunk.prototype._initConstants = function () {
        _super.prototype._initConstants.call(this);
        var fragmentData = this._shader.fragmentConstantData;
        var index = this._fragmentConstantsIndex;
        fragmentData[index + 8] = .5;
        var size = this._method.castingLight.shadowMapper.depthMapSize;
        fragmentData[index + 9] = size;
        fragmentData[index + 10] = 1 / size;
    };
    /**
     * @inheritDoc
     */
    ShadowFilteredChunk.prototype._getPlanarFragmentCode = function (targetReg, regCache, sharedRegisters) {
        var code = "";
        var decReg = regCache.getFreeFragmentConstant();
        regCache.getFreeFragmentConstant();
        var customDataReg = regCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = decReg.index * 4;
        var depthCol = regCache.getFreeFragmentVectorTemp();
        regCache.addFragmentTempUsages(depthCol, 1);
        var uvReg = regCache.getFreeFragmentVectorTemp();
        regCache.addFragmentTempUsages(uvReg, 1);
        code += "mov " + uvReg + ", " + this._depthMapCoordReg + "\n" +
            this._depthMap._getFragmentCode(depthCol, regCache, sharedRegisters, this._depthMapCoordReg) +
            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
            "slt " + uvReg + ".z, " + this._depthMapCoordReg + ".z, " + depthCol + ".z\n" +
            "add " + uvReg + ".x, " + this._depthMapCoordReg + ".x, " + customDataReg + ".z\n" +
            this._depthMap._getFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
            "slt " + uvReg + ".w, " + this._depthMapCoordReg + ".z, " + depthCol + ".z\n" +
            "mul " + depthCol + ".x, " + this._depthMapCoordReg + ".x, " + customDataReg + ".y\n" +
            "frc " + depthCol + ".x, " + depthCol + ".x\n" +
            "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" +
            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
            "add " + targetReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" +
            "mov " + uvReg + ".x, " + this._depthMapCoordReg + ".x\n" +
            "add " + uvReg + ".y, " + this._depthMapCoordReg + ".y, " + customDataReg + ".z\n" +
            this._depthMap._getFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
            "slt " + uvReg + ".z, " + this._depthMapCoordReg + ".z, " + depthCol + ".z\n" +
            "add " + uvReg + ".x, " + this._depthMapCoordReg + ".x, " + customDataReg + ".z\n" +
            this._depthMap._getFragmentCode(depthCol, regCache, sharedRegisters, uvReg) +
            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
            "slt " + uvReg + ".w, " + this._depthMapCoordReg + ".z, " + depthCol + ".z\n" +
            // recalculate fraction, since we ran out of registers :(
            "mul " + depthCol + ".x, " + this._depthMapCoordReg + ".x, " + customDataReg + ".y\n" +
            "frc " + depthCol + ".x, " + depthCol + ".x\n" + "sub " + uvReg + ".w, " + uvReg + ".w, " + uvReg + ".z\n" +
            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
            "add " + uvReg + ".w, " + uvReg + ".z, " + uvReg + ".w\n" +
            "mul " + depthCol + ".x, " + this._depthMapCoordReg + ".y, " + customDataReg + ".y\n" +
            "frc " + depthCol + ".x, " + depthCol + ".x\n" +
            "sub " + uvReg + ".w, " + uvReg + ".w, " + targetReg + ".w\n" +
            "mul " + uvReg + ".w, " + uvReg + ".w, " + depthCol + ".x\n" +
            "add " + targetReg + ".w, " + targetReg + ".w, " + uvReg + ".w\n";
        regCache.removeFragmentTempUsage(depthCol);
        regCache.removeFragmentTempUsage(uvReg);
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowFilteredChunk.prototype._activateForCascade = function () {
        var size = this._method.castingLight.shadowMapper.depthMapSize;
        var index = this._cascadeFragmentConstantsIndex;
        var data = this._shader.fragmentConstantData;
        data[index] = size;
        data[index + 1] = 1 / size;
    };
    /**
     * @inheritDoc
     */
    ShadowFilteredChunk.prototype._getCascadeFragmentCode = function (decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
        var code;
        var dataReg = registerCache.getFreeFragmentConstant();
        this._cascadeFragmentConstantsIndex = dataReg.index * 4;
        var temp = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(temp, 1);
        var predicate = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(predicate, 1);
        code = this._depthMap._getFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
            "slt " + predicate + ".x, " + depthProjection + ".z, " + temp + ".z\n" +
            "add " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" +
            this._depthMap._getFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
            "slt " + predicate + ".z, " + depthProjection + ".z, " + temp + ".z\n" +
            "add " + depthProjection + ".y, " + depthProjection + ".y, " + dataReg + ".y\n" +
            this._depthMap._getFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
            "slt " + predicate + ".w, " + depthProjection + ".z, " + temp + ".z\n" +
            "sub " + depthProjection + ".x, " + depthProjection + ".x, " + dataReg + ".y\n" +
            this._depthMap._getFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
            "slt " + predicate + ".y, " + depthProjection + ".z, " + temp + ".z\n" +
            "mul " + temp + ".xy, " + depthProjection + ".xy, " + dataReg + ".x\n" +
            "frc " + temp + ".xy, " + temp + ".xy\n" +
            // some strange register juggling to prevent agal bugging out
            "sub " + depthProjection + ", " + predicate + ".xyzw, " + predicate + ".zwxy\n" +
            "mul " + depthProjection + ", " + depthProjection + ", " + temp + ".x\n" +
            "add " + predicate + ".xy, " + predicate + ".xy, " + depthProjection + ".zw\n" +
            "sub " + predicate + ".y, " + predicate + ".y, " + predicate + ".x\n" +
            "mul " + predicate + ".y, " + predicate + ".y, " + temp + ".y\n" +
            "add " + targetRegister + ".w, " + predicate + ".x, " + predicate + ".y\n";
        registerCache.removeFragmentTempUsage(temp);
        registerCache.removeFragmentTempUsage(predicate);
        return code;
    };
    return ShadowFilteredChunk;
}(ShadowChunkBase));

/**
 * ShadowHardChunk provides the cheapest shadow map method by using a single tap without any filtering.
 */
var ShadowHardChunk = (function (_super) {
    __extends(ShadowHardChunk, _super);
    /**
     * Creates a new ShadowHardChunk.
     */
    function ShadowHardChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    ShadowHardChunk.prototype._getPlanarFragmentCode = function (targetReg, regCache, sharedRegisters) {
        var code = "";
        var decReg = regCache.getFreeFragmentConstant();
        regCache.getFreeFragmentConstant();
        var depthCol = regCache.getFreeFragmentVectorTemp();
        this._fragmentConstantsIndex = decReg.index * 4;
        code += this._depthMap._getFragmentCode(depthCol, regCache, sharedRegisters, this._depthMapCoordReg) +
            "dp4 " + depthCol + ".z, " + depthCol + ", " + decReg + "\n" +
            "slt " + targetReg + ".w, " + this._depthMapCoordReg + ".z, " + depthCol + ".z\n"; // 0 if in shadow
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowHardChunk.prototype._getPointFragmentCode = function (targetReg, regCache, sharedRegisters) {
        var code = "";
        var decReg = regCache.getFreeFragmentConstant();
        var epsReg = regCache.getFreeFragmentConstant();
        var posReg = regCache.getFreeFragmentConstant();
        var depthSampleCol = regCache.getFreeFragmentVectorTemp();
        regCache.addFragmentTempUsages(depthSampleCol, 1);
        var lightDir = regCache.getFreeFragmentVectorTemp();
        regCache.addFragmentTempUsages(lightDir, 1);
        this._fragmentConstantsIndex = decReg.index * 4;
        code += "sub " + lightDir + ", " + sharedRegisters.globalPositionVarying + ", " + posReg + "\n" +
            "dp3 " + lightDir + ".w, " + lightDir + ".xyz, " + lightDir + ".xyz\n" +
            "mul " + lightDir + ".w, " + lightDir + ".w, " + posReg + ".w\n" +
            "nrm " + lightDir + ".xyz, " + lightDir + ".xyz\n" +
            this._depthMap._getFragmentCode(depthSampleCol, regCache, sharedRegisters, lightDir) +
            "dp4 " + depthSampleCol + ".z, " + depthSampleCol + ", " + decReg + "\n" +
            "add " + targetReg + ".w, " + lightDir + ".w, " + epsReg + ".x\n" +
            "slt " + targetReg + ".w, " + targetReg + ".w, " + depthSampleCol + ".z\n"; // 0 if in shadow
        regCache.removeFragmentTempUsage(lightDir);
        regCache.removeFragmentTempUsage(depthSampleCol);
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowHardChunk.prototype._getCascadeFragmentCode = function (decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
        var temp = registerCache.getFreeFragmentVectorTemp();
        return this._depthMap._getFragmentCode(temp, registerCache, sharedRegisters, depthProjection) +
            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
            "slt " + targetRegister + ".w, " + depthProjection + ".z, " + temp + ".z\n"; // 0 if in shadow
    };
    /**
     * @inheritDoc
     */
    ShadowHardChunk.prototype._activateForCascade = function () {
    };
    return ShadowHardChunk;
}(ShadowChunkBase));

// TODO: shadow mappers references in materials should be an interface so that this class should NOT extend ShadowMapMethodBase just for some delegation work
/**
 * ShadowNearChunk provides a shadow map method that restricts the shadowed area near the camera to optimize
 * shadow map usage. This method needs to be used in conjunction with a NearDirectionalShadowMapper.
 *
 * @see away.lights.NearDirectionalShadowMapper
 */
var ShadowNearChunk = (function (_super) {
    __extends(ShadowNearChunk, _super);
    /**
     * Creates a new ShadowNearChunk.
     */
    function ShadowNearChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    /**
     * @inheritDoc
     */
    ShadowNearChunk.prototype._initConstants = function () {
        _super.prototype._initConstants.call(this);
        var fragmentData = this._shader.fragmentConstantData;
        var index = this._fragmentConstantsIndex;
        fragmentData[index + 2] = 0;
        fragmentData[index + 3] = 1;
    };
    /**
     * @inheritDoc
     */
    ShadowNearChunk.prototype._initVO = function (chunkVO) {
        _super.prototype._initVO.call(this, chunkVO);
        chunkVO.needsProjection = true;
    };
    /**
     * @inheritDoc
     */
    ShadowNearChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = _super.prototype._getFragmentCode.call(this, targetReg, registerCache, sharedRegisters);
        var dataReg = registerCache.getFreeFragmentConstant();
        var temp = registerCache.getFreeFragmentSingleTemp();
        this._fragmentConstantsIndex = dataReg.index * 4;
        code += "abs " + temp + ", " + sharedRegisters.projectionFragment + ".w\n" +
            "sub " + temp + ", " + temp + ", " + dataReg + ".x\n" +
            "mul " + temp + ", " + temp + ", " + dataReg + ".y\n" +
            "sat " + temp + ", " + temp + "\n" +
            "sub " + temp + ", " + dataReg + ".w," + temp + "\n" +
            "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n" +
            "mul " + targetReg + ".w, " + targetReg + ".w, " + temp + "\n" +
            "sub " + targetReg + ".w, " + dataReg + ".w," + targetReg + ".w\n";
        return code;
    };
    /**
     * @inheritDoc
     */
    ShadowNearChunk.prototype._setRenderState = function (renderable, projection) {
        // todo: move this to activate (needs camera)
        var near = projection.near;
        var d = projection.far - near;
        var maxDistance = this._method.castingLight.shadowMapper.coverageRatio;
        var minDistance = maxDistance * (1 - this._fadeRatio);
        maxDistance = near + maxDistance * d;
        minDistance = near + minDistance * d;
        var fragmentData = this._shader.fragmentConstantData;
        var index = this._fragmentConstantsIndex;
        fragmentData[index] = minDistance;
        fragmentData[index + 1] = 1 / (maxDistance - minDistance);
        _super.prototype._setRenderState.call(this, renderable, projection);
    };
    return ShadowNearChunk;
}(CompositeChunkBase));

/**
 * ShadowSoftChunk provides a soft shadowing technique by randomly distributing sample points.
 */
var ShadowSoftChunk = (function (_super) {
    __extends(ShadowSoftChunk, _super);
    /**
     * Creates a new ShadowHardChunk.
     */
    function ShadowSoftChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    ShadowSoftChunk.prototype._initConstants = function () {
        _super.prototype._initConstants.call(this);
        this._shader.fragmentConstantData[this._fragmentConstantsIndex + 8] = 1 / this._method.numSamples;
        this._shader.fragmentConstantData[this._fragmentConstantsIndex + 9] = 0;
    };
    /**
     * @inheritDoc
     */
    ShadowSoftChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        var texRange = .5 * this._method.range / this._method.castingLight.shadowMapper.depthMapSize;
        var data = this._shader.fragmentConstantData;
        var index = this._fragmentConstantsIndex + 10;
        var len = this._method.numSamples << 1;
        for (var i = 0; i < len; ++i)
            data[index + i] = this._method.offsets[i] * texRange;
    };
    /**
     * @inheritDoc
     */
    ShadowSoftChunk.prototype._getPlanarFragmentCode = function (targetReg, regCache, sharedRegisters) {
        // todo: move some things to super
        var decReg = regCache.getFreeFragmentConstant();
        regCache.getFreeFragmentConstant();
        var dataReg = regCache.getFreeFragmentConstant();
        this._fragmentConstantsIndex = decReg.index * 4;
        return this.getSampleCode(decReg, targetReg, regCache, sharedRegisters, dataReg);
    };
    /**
     * Adds the code for another tap to the shader code.
     * @param uv The uv register for the tap.
     * @param texture The texture register containing the depth map.
     * @param decode The register containing the depth map decoding data.
     * @param target The target register to add the tap comparison result.
     * @param regCache The register cache managing the registers.
     * @return
     */
    ShadowSoftChunk.prototype.addSample = function (decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg) {
        var temp = registerCache.getFreeFragmentVectorTemp();
        return this._depthMap._getFragmentCode(temp, registerCache, sharedRegisters, uvReg) +
            "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
            "slt " + uvReg + ".w, " + this._depthMapCoordReg + ".z, " + temp + ".z\n" +
            "add " + targetRegister + ".w, " + targetRegister + ".w, " + uvReg + ".w\n";
    };
    /**
     * @inheritDoc
     */
    ShadowSoftChunk.prototype._activateForCascade = function () {
        _super.prototype._activate.call(this);
        var texRange = this._method.range / this._method.castingLight.shadowMapper.depthMapSize;
        var data = this._shader.fragmentConstantData;
        var index = this._secondaryFragmentConstantsIndex;
        var len = this._method.numSamples << 1;
        data[index] = 1 / this._method.numSamples;
        data[index + 1] = 0;
        index += 2;
        for (var i = 0; i < len; ++i)
            data[index + i] = this._method.offsets[i] * texRange;
        if (len % 4 == 0) {
            data[index + len] = 0;
            data[index + len + 1] = 0;
        }
    };
    /**
     * @inheritDoc
     */
    ShadowSoftChunk.prototype._getCascadeFragmentCode = function (decodeRegister, depthProjection, targetRegister, registerCache, sharedRegisters) {
        this._depthMapCoordReg = depthProjection;
        var dataReg = registerCache.getFreeFragmentConstant();
        this._secondaryFragmentConstantsIndex = dataReg.index * 4;
        return this.getSampleCode(decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg);
    };
    /**
     * Get the actual shader code for shadow mapping
     * @param regCache The register cache managing the registers.
     * @param depthTexture The texture register containing the depth map.
     * @param decodeRegister The register containing the depth map decoding data.
     * @param targetReg The target register to add the shadow coverage.
     * @param dataReg The register containing additional data.
     */
    ShadowSoftChunk.prototype.getSampleCode = function (decodeRegister, targetRegister, registerCache, sharedRegisters, dataReg) {
        var code;
        var uvReg = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(uvReg, 1);
        var offsets = new Array(dataReg + ".zw");
        var numRegs = this._method.numSamples >> 1;
        for (var i = 0; i < numRegs; ++i) {
            var reg = registerCache.getFreeFragmentConstant();
            offsets.push(reg + ".xy");
            offsets.push(reg + ".zw");
        }
        for (i = 0; i < this._method.numSamples; ++i) {
            if (i == 0) {
                var temp = registerCache.getFreeFragmentVectorTemp();
                code = "add " + uvReg + ", " + this._depthMapCoordReg + ", " + dataReg + ".zwyy\n" +
                    this._depthMap._getFragmentCode(temp, registerCache, sharedRegisters, uvReg) +
                    "dp4 " + temp + ".z, " + temp + ", " + decodeRegister + "\n" +
                    "slt " + targetRegister + ".w, " + this._depthMapCoordReg + ".z, " + temp + ".z\n"; // 0 if in shadow;
            }
            else {
                code += "add " + uvReg + ".xy, " + this._depthMapCoordReg + ".xy, " + offsets[i] + "\n" +
                    this.addSample(decodeRegister, targetRegister, registerCache, sharedRegisters, uvReg);
            }
        }
        registerCache.removeFragmentTempUsage(uvReg);
        code += "mul " + targetRegister + ".w, " + targetRegister + ".w, " + dataReg + ".x\n"; // average
        return code;
    };
    return ShadowSoftChunk;
}(ShadowChunkBase));

/**
 * SpecularBasicChunk provides the default shading method for Blinn-Phong specular highlights (an optimized but approximated
 * version of Phong specularity).
 */
var SpecularBasicChunk = (function (_super) {
    __extends(SpecularBasicChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function SpecularBasicChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        return _this;
    }
    SpecularBasicChunk.prototype._isUsed = function () {
        if (!this._shader.numLights)
            return false;
        return true;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicChunk.prototype._initVO = function (chunkVO) {
        chunkVO.needsNormals = this._shader.numLights > 0;
        chunkVO.needsView = this._shader.numLights > 0;
        if (this._method.texture) {
            this._texture = this._shader.getAbstraction(this._method.texture);
            this._shader.uvDependencies++;
        }
        else if (this._texture) {
            this._texture = null;
        }
    };
    /**
     * @inheritDoc
     */
    SpecularBasicChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._totalLightColorReg = null;
        this._specularTexData = null;
        this._specularDataRegister = null;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        var code = "";
        this._pIsFirstLight = true;
        this._specularDataRegister = registerCache.getFreeFragmentConstant();
        this._specularDataIndex = this._specularDataRegister.index * 4;
        if (this._texture) {
            this._specularTexData = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(this._specularTexData, 1);
            code += this._texture._getFragmentCode(this._specularTexData, registerCache, sharedRegisters, sharedRegisters.uvVarying);
        }
        this._totalLightColorReg = registerCache.getFreeFragmentVectorTemp();
        registerCache.addFragmentTempUsages(this._totalLightColorReg, 1);
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicChunk.prototype._getFragmentCodePerLight = function (lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        if (this._pIsFirstLight) {
            t = this._totalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        var viewDirReg = sharedRegisters.viewDirFragment;
        var normalReg = sharedRegisters.normalFragment;
        // blinn-phong half vector model
        code += "add " + t + ", " + lightDirReg + ", " + viewDirReg + "\n" +
            "nrm " + t + ".xyz, " + t + "\n" +
            "dp3 " + t + ".w, " + normalReg + ", " + t + "\n" +
            "sat " + t + ".w, " + t + ".w\n";
        if (this._texture) {
            // apply gloss modulation from texture
            code += "mul " + this._specularTexData + ".w, " + this._specularTexData + ".y, " + this._specularDataRegister + ".w\n" +
                "pow " + t + ".w, " + t + ".w, " + this._specularTexData + ".w\n";
        }
        else {
            code += "pow " + t + ".w, " + t + ".w, " + this._specularDataRegister + ".w\n";
        }
        // attenuate
        if (this._shader.usesLightFallOff)
            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(t, registerCache, sharedRegisters);
        code += "mul " + t + ".xyz, " + lightColReg + ", " + t + ".w\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicChunk.prototype._getFragmentCodePerProbe = function (cubeMapReg, weightRegister, registerCache, sharedRegisters) {
        var code = "";
        var t;
        // write in temporary if not first light, so we can add to total diffuse colour
        if (this._pIsFirstLight) {
            t = this._totalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        var normalReg = sharedRegisters.normalFragment;
        var viewDirReg = sharedRegisters.viewDirFragment;
        code += "dp3 " + t + ".w, " + normalReg + ", " + viewDirReg + "\n" +
            "add " + t + ".w, " + t + ".w, " + t + ".w\n" +
            "mul " + t + ", " + t + ".w, " + normalReg + "\n" +
            "sub " + t + ", " + t + ", " + viewDirReg + "\n" +
            "tex " + t + ", " + t + ", " + cubeMapReg + " <cube," + "linear" + ",miplinear>\n" +
            "mul " + t + ".xyz, " + t + ", " + weightRegister + "\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(t, registerCache, sharedRegisters);
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + t + "\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicChunk.prototype._getFragmentCode = function (targetReg, registerCache, sharedRegisters) {
        var code = "";
        if (sharedRegisters.shadowTarget)
            code += "mul " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + sharedRegisters.shadowTarget + ".w\n";
        if (this._texture) {
            // apply strength modulation from texture
            code += "mul " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + this._specularTexData + ".x\n";
            registerCache.removeFragmentTempUsage(this._specularTexData);
        }
        // apply material's specular reflection
        code += "mul " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ", " + this._specularDataRegister + "\n" +
            "add " + targetReg + ".xyz, " + targetReg + ", " + this._totalLightColorReg + "\n";
        registerCache.removeFragmentTempUsage(this._totalLightColorReg);
        return code;
    };
    /**
     * @inheritDoc
     */
    SpecularBasicChunk.prototype._activate = function () {
        if (this._texture)
            this._texture.activate();
        if (this._invalid) {
            var index = this._specularDataIndex;
            var data = this._shader.fragmentConstantData;
            data[index] = ((this._method.color >> 16) & 0xff) / 0xff * this._method.strength;
            data[index + 1] = ((this._method.color >> 8) & 0xff) / 0xff * this._method.strength;
            data[index + 2] = (this._method.color & 0xff) / 0xff * this._method.strength;
            data[index + 3] = this._method.gloss;
        }
    };
    SpecularBasicChunk.prototype.iSetRenderState = function (renderable, projection) {
        if (this._texture)
            this._texture._setRenderState(renderable);
    };
    return SpecularBasicChunk;
}(ShaderChunkBase));

/**
 * SpecularAnisotropicChunk provides a specular method resulting in anisotropic highlights. These are typical for
 * surfaces with microfacet details such as tiny grooves. In particular, this uses the Heidrich-Seidel distrubution.
 * The tangent vectors are used as the surface groove directions.
 */
var SpecularAnisotropicChunk = (function (_super) {
    __extends(SpecularAnisotropicChunk, _super);
    /**
     * Creates a new EffectEnvMapChunk.
     */
    function SpecularAnisotropicChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    SpecularAnisotropicChunk.prototype._initVO = function (chunkVO) {
        _super.prototype._initVO.call(this, chunkVO);
        chunkVO.needsTangents = this._shader.numLights > 0;
    };
    /**
     * @inheritDoc
     */
    SpecularAnisotropicChunk.prototype._getFragmentCodePerLight = function (lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        if (this._pIsFirstLight)
            t = this._totalLightColorReg;
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        // (sin(l,t) * sin(v,t) - cos(l,t)*cos(v,t)) ^ k
        code += "nrm " + t + ".xyz, " + sharedRegisters.tangentVarying + ".xyz\n" +
            "dp3 " + t + ".w, " + t + ".xyz, " + lightDirReg + ".xyz\n" +
            "dp3 " + t + ".z, " + t + ".xyz, " + sharedRegisters.viewDirFragment + ".xyz\n";
        // (sin(t.w) * sin(t.z) - cos(t.w)*cos(t.z)) ^ k
        code += "sin " + t + ".x, " + t + ".w\n" +
            "sin " + t + ".y, " + t + ".z\n" +
            // (t.x * t.y - cos(t.w)*cos(t.z)) ^ k
            "mul " + t + ".x, " + t + ".x, " + t + ".y\n" +
            // (t.x - cos(t.w)*cos(t.z)) ^ k
            "cos " + t + ".z, " + t + ".z\n" +
            "cos " + t + ".w, " + t + ".w\n" +
            // (t.x - t.w*t.z) ^ k
            "mul " + t + ".w, " + t + ".w, " + t + ".z\n" +
            // (t.x - t.w) ^ k
            "sub " + t + ".w, " + t + ".x, " + t + ".w\n";
        if (this._texture) {
            // apply gloss modulation from texture
            code += "mul " + this._specularTexData + ".w, " + this._specularTexData + ".y, " + this._specularDataRegister + ".w\n" +
                "pow " + t + ".w, " + t + ".w, " + this._specularTexData + ".w\n";
        }
        else
            code += "pow " + t + ".w, " + t + ".w, " + this._specularDataRegister + ".w\n";
        // attenuate
        code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(t, registerCache, sharedRegisters);
        code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ".xyz, " + t + ".xyz\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    return SpecularAnisotropicChunk;
}(SpecularBasicChunk));

/**
 * SpecularCelChunk provides a shading method to add specular cel (cartoon) shading.
 */
var SpecularCelChunk = (function (_super) {
    __extends(SpecularCelChunk, _super);
    /**
     * Creates a new DiffuseCelChunk object.
     * @param levels The amount of shadow gradations.
     * @param baseMethod An optional diffuse method on which the cartoon shading is based. If omitted, DiffuseBasicMethod is used.
     */
    function SpecularCelChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        _this._baseChunk._modulateFunction = function (targetReg, registerCache, sharedRegisters) { return _this.clampSpecular(targetReg, registerCache, sharedRegisters); };
        return _this;
    }
    /**
     * @inheritDoc
     */
    SpecularCelChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        if (this._invalid) {
            var index = this._cutoffDataIndex;
            var data = this._shader.fragmentConstantData;
            data[index] = this._method.smoothness;
            data[index + 1] = this._method.specularCutOff;
        }
    };
    /**
     * @inheritDoc
     */
    SpecularCelChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._cutoffDataRegister = null;
    };
    /**
     * Snaps the specular shading strength of the wrapped method to zero or one, depending on whether or not it exceeds the specularCutOff
     * @param vo The MethodVO used to compile the current shader.
     * @param t The register containing the specular strength in the "w" component, and either the half-vector or the reflection vector in "xyz".
     * @param regCache The register cache used for the shader compilation.
     * @param sharedRegisters The shared register data for this shader.
     * @return The AGAL fragment code for the method.
     */
    SpecularCelChunk.prototype.clampSpecular = function (targetReg, registerCache, sharedRegisters) {
        return "sub " + targetReg + ".y, " + targetReg + ".w, " + this._cutoffDataRegister + ".y\n" +
            "div " + targetReg + ".y, " + targetReg + ".y, " + this._cutoffDataRegister + ".x\n" +
            "sat " + targetReg + ".y, " + targetReg + ".y\n" +
            "sge " + targetReg + ".w, " + targetReg + ".w, " + this._cutoffDataRegister + ".y\n" +
            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";
    };
    /**
     * @inheritDoc
     */
    SpecularCelChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        this._cutoffDataRegister = registerCache.getFreeFragmentConstant();
        this._cutoffDataIndex = this._cutoffDataRegister.index * 4;
        return _super.prototype._getFragmentPreLightingCode.call(this, registerCache, sharedRegisters);
    };
    return SpecularCelChunk;
}(LightingCompositeChunk));

/**
 * SpecularFresnelChunk provides a specular shading method that causes stronger highlights on grazing view angles.
 */
var SpecularFresnelChunk = (function (_super) {
    __extends(SpecularFresnelChunk, _super);
    /**
     * Creates a new SpecularFresnelChunk object.
     */
    function SpecularFresnelChunk(method, shader) {
        var _this = _super.call(this, method, shader) || this;
        _this._method = method;
        _this._shader = shader;
        _this._baseChunk._modulateFunction = function (targetReg, registerCache, sharedRegisters) { return _this.modulateSpecular(targetReg, registerCache, sharedRegisters); };
        return _this;
    }
    /**
     * @inheritDoc
     */
    SpecularFresnelChunk.prototype._cleanCompilationData = function () {
        _super.prototype._cleanCompilationData.call(this);
        this._fresnelDataRegister = null;
    };
    /**
     * @inheritDoc
     */
    SpecularFresnelChunk.prototype._activate = function () {
        _super.prototype._activate.call(this);
        if (this._invalid) {
            var data = this._shader.fragmentConstantData;
            var index = this._fresnelDataIndex;
            data[index] = this._method.normalReflectance;
            data[index + 1] = this._method.fresnelPower;
            data[index + 2] = 1;
            data[index + 3] = 0;
        }
    };
    /**
     * @inheritDoc
     */
    SpecularFresnelChunk.prototype._getFragmentPreLightingCode = function (registerCache, sharedRegisters) {
        this._fresnelDataRegister = registerCache.getFreeFragmentConstant();
        this._fresnelDataIndex = this._fresnelDataRegister.index * 4;
        return _super.prototype._getFragmentPreLightingCode.call(this, registerCache, sharedRegisters);
    };
    /**
     * Applies the fresnel effect to the specular strength.
     *
     * @param vo The MethodVO object containing the method data for the currently compiled material pass.
     * @param target The register containing the specular strength in the "w" component, and the half-vector/reflection vector in "xyz".
     * @param regCache The register cache used for the shader compilation.
     * @param sharedRegisters The shared registers created by the compiler.
     * @return The AGAL fragment code for the method.
     */
    SpecularFresnelChunk.prototype.modulateSpecular = function (targetReg, registerCache, sharedRegisters) {
        var code;
        code = "dp3 " + targetReg + ".y, " + sharedRegisters.viewDirFragment + ".xyz, " + (this._method.basedOnSurface ? sharedRegisters.normalFragment : targetReg) + ".xyz\n" +
            "sub " + targetReg + ".y, " + this._fresnelDataRegister + ".z, " + targetReg + ".y\n" +
            "pow " + targetReg + ".x, " + targetReg + ".y, " + this._fresnelDataRegister + ".y\n" +
            "sub " + targetReg + ".y, " + this._fresnelDataRegister + ".z, " + targetReg + ".y\n" +
            "mul " + targetReg + ".y, " + this._fresnelDataRegister + ".x, " + targetReg + ".y\n" +
            "add " + targetReg + ".y, " + targetReg + ".x, " + targetReg + ".y\n" +
            "mul " + targetReg + ".w, " + targetReg + ".w, " + targetReg + ".y\n";
        return code;
    };
    return SpecularFresnelChunk;
}(LightingCompositeChunk));

/**
 * SpecularPhongChunk provides a specular method that provides Phong highlights.
 */
var SpecularPhongChunk = (function (_super) {
    __extends(SpecularPhongChunk, _super);
    /**
     * Creates a new SpecularPhongChunk object.
     */
    function SpecularPhongChunk(method, shader) {
        return _super.call(this, method, shader) || this;
    }
    /**
     * @inheritDoc
     */
    SpecularPhongChunk.prototype._getFragmentCodePerLight = function (lightDirReg, lightColReg, registerCache, sharedRegisters) {
        var code = "";
        var t;
        if (this._pIsFirstLight) {
            t = this._totalLightColorReg;
        }
        else {
            t = registerCache.getFreeFragmentVectorTemp();
            registerCache.addFragmentTempUsages(t, 1);
        }
        var viewDirReg = sharedRegisters.viewDirFragment;
        var normalReg = sharedRegisters.normalFragment;
        // phong model
        code += "dp3 " + t + ".w, " + lightDirReg + ", " + normalReg + "\n" +
            //find the reflected light vector R
            "add " + t + ".w, " + t + ".w, " + t + ".w\n" +
            "mul " + t + ".xyz, " + normalReg + ", " + t + ".w\n" +
            "sub " + t + ".xyz, " + t + ", " + lightDirReg + "\n" +
            //smooth the edge as incidence angle approaches 90
            "add " + t + ".w, " + t + ".w, " + sharedRegisters.commons + ".w\n" +
            "sat " + t + ".w, " + t + ".w\n" +
            "mul " + t + ".xyz, " + t + ", " + t + ".w\n" +
            //find the dot product between R and V
            "dp3 " + t + ".w, " + t + ", " + viewDirReg + "\n" +
            "sat " + t + ".w, " + t + ".w\n";
        if (this._texture) {
            // apply gloss modulation from texture
            code += "mul " + this._specularTexData + ".w, " + this._specularTexData + ".y, " + this._specularDataRegister + ".w\n" +
                "pow " + t + ".w, " + t + ".w, " + this._specularTexData + ".w\n";
        }
        else
            code += "pow " + t + ".w, " + t + ".w, " + this._specularDataRegister + ".w\n";
        // attenuate
        if (this._shader.usesLightFallOff)
            code += "mul " + t + ".w, " + t + ".w, " + lightDirReg + ".w\n";
        if (this._modulateFunction != null)
            code += this._modulateFunction(t, registerCache, sharedRegisters);
        code += "mul " + t + ".xyz, " + lightColReg + ".xyz, " + t + ".w\n";
        if (!this._pIsFirstLight) {
            code += "add " + this._totalLightColorReg + ".xyz, " + this._totalLightColorReg + ".xyz, " + t + ".xyz\n";
            registerCache.removeFragmentTempUsage(t);
        }
        this._pIsFirstLight = false;
        return code;
    };
    return SpecularPhongChunk;
}(SpecularBasicChunk));

var MethodPassMode = (function () {
    function MethodPassMode() {
    }
    return MethodPassMode;
}());
/**
 *
 */
MethodPassMode.EFFECTS = 0x01;
/**
 *
 */
MethodPassMode.LIGHTING = 0x02;
/**
 *
 */
MethodPassMode.SUPER_SHADER = 0x03;

_awayjs_stage.ShaderBase.registerAbstraction(AmbientBasicChunk, AmbientBasicMethod);
_awayjs_stage.ShaderBase.registerAbstraction(AmbientDepthChunk, AmbientDepthMethod);
_awayjs_stage.ShaderBase.registerAbstraction(DiffuseBasicChunk, DiffuseBasicMethod);
_awayjs_stage.ShaderBase.registerAbstraction(DiffuseCelChunk, DiffuseCelMethod);
_awayjs_stage.ShaderBase.registerAbstraction(DiffuseGradientChunk, DiffuseGradientMethod);
_awayjs_stage.ShaderBase.registerAbstraction(DiffuseLightMapChunk, DiffuseLightMapMethod);
_awayjs_stage.ShaderBase.registerAbstraction(DiffuseWrapChunk, DiffuseWrapMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectAlphaMaskChunk, EffectAlphaMaskMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectColorMatrixChunk, EffectColorMatrixMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectColorTransformChunk, EffectColorTransformMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectEnvMapChunk, EffectEnvMapMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectFogChunk, EffectFogMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectFresnelEnvMapChunk, EffectFresnelEnvMapMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectLightMapChunk, EffectLightMapMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectProjectiveTextureChunk, EffectProjectiveTextureMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectRefractionEnvMapChunk, EffectRefractionEnvMapMethod);
_awayjs_stage.ShaderBase.registerAbstraction(EffectRimLightChunk, EffectRimLightMethod);
_awayjs_stage.ShaderBase.registerAbstraction(NormalBasicChunk, NormalBasicMethod);
_awayjs_stage.ShaderBase.registerAbstraction(NormalHeightMapChunk, NormalHeightMapMethod);
_awayjs_stage.ShaderBase.registerAbstraction(NormalSimpleWaterChunk, NormalSimpleWaterMethod);
_awayjs_stage.ShaderBase.registerAbstraction(ShadowCascadeChunk, ShadowCascadeMethod);
_awayjs_stage.ShaderBase.registerAbstraction(ShadowDitheredChunk, ShadowDitheredMethod);
_awayjs_stage.ShaderBase.registerAbstraction(ShadowFilteredChunk, ShadowFilteredMethod);
_awayjs_stage.ShaderBase.registerAbstraction(ShadowHardChunk, ShadowHardMethod);
_awayjs_stage.ShaderBase.registerAbstraction(ShadowNearChunk, ShadowNearMethod);
_awayjs_stage.ShaderBase.registerAbstraction(ShadowSoftChunk, ShadowSoftMethod);
_awayjs_stage.ShaderBase.registerAbstraction(SpecularAnisotropicChunk, SpecularAnisotropicMethod);
_awayjs_stage.ShaderBase.registerAbstraction(SpecularBasicChunk, SpecularBasicMethod);
_awayjs_stage.ShaderBase.registerAbstraction(SpecularCelChunk, SpecularCelMethod);
_awayjs_stage.ShaderBase.registerAbstraction(SpecularFresnelChunk, SpecularFresnelMethod);
_awayjs_stage.ShaderBase.registerAbstraction(SpecularPhongChunk, SpecularPhongMethod);
/**
 * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
 * using material methods to define their appearance.
 */
var MethodPass = (function (_super) {
    __extends(MethodPass, _super);
    /**
     * Creates a new CompiledPass object.
     *
     * @param material The material to which this pass belongs.
     */
    function MethodPass(mode, material, materialPool) {
        var _this = _super.call(this, material, materialPool) || this;
        _this._maxLights = 3;
        _this._mode = 0x03;
        _this._includeCasters = true;
        _this._chunks = new Array();
        _this._methods = new Array();
        _this._numEffectDependencies = 0;
        _this.numDirectionalLights = 0;
        _this.numPointLights = 0;
        _this.numLightProbes = 0;
        _this.pointLightsOffset = 0;
        _this.directionalLightsOffset = 0;
        _this.lightProbesOffset = 0;
        _this._mode = mode;
        _this._onLightsChangeDelegate = function (event) { return _this.onLightsChange(event); };
        _this._onMethodInvalidatedDelegate = function (event) { return _this.onMethodInvalidated(event); };
        _this.lightPicker = material.lightPicker;
        if (_this._shader == null)
            _this._updateShader();
        return _this;
    }
    Object.defineProperty(MethodPass.prototype, "mode", {
        /**
         *
         */
        get: function () {
            return this._mode;
        },
        set: function (value) {
            if (this._mode == value)
                return;
            this._mode = value;
            this._updateLights();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "includeCasters", {
        /**
         * Indicates whether or not shadow casting lights need to be included.
         */
        get: function () {
            return this._includeCasters;
        },
        set: function (value) {
            if (this._includeCasters == value)
                return;
            this._includeCasters = value;
            this._updateLights();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "lightPicker", {
        /**
         *
         * @returns {LightPickerBase}
         */
        get: function () {
            return this._lightPicker;
        },
        set: function (value) {
            //if (this._lightPicker == value)
            //	return;
            if (this._lightPicker)
                this._lightPicker.removeEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);
            this._lightPicker = value;
            if (this._lightPicker)
                this._lightPicker.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);
            this._updateLights();
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "enableLightFallOff", {
        /**
         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
         * compatibility for constrained mode.
         */
        get: function () {
            return this._material.enableLightFallOff;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "diffuseLightSources", {
        /**
         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
         * and/or light probes for diffuse reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._material.diffuseLightSources;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "specularLightSources", {
        /**
         * Define which light source types to use for specular reflections. This allows choosing between regular lights
         * and/or light probes for specular reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._material.specularLightSources;
        },
        enumerable: true,
        configurable: true
    });
    MethodPass.prototype._updateShader = function () {
        if ((this.numDirectionalLights || this.numPointLights || this.numLightProbes) && !(this._shader instanceof _awayjs_renderer.LightingShader)) {
            if (this._shader != null) {
                this._shader.dispose();
                this._shader = null;
            }
            this._shader = new _awayjs_renderer.LightingShader(this._elementsClass, this, this._stage);
        }
        else if (this._shader == null) {
            if (this._shader != null) {
                this._shader.dispose();
                this._shader = null;
            }
            this._shader = new _awayjs_stage.ShaderBase(this._elementsClass, this, this._stage);
        }
    };
    /**
     * Initializes the unchanging constant data for this material.
     */
    MethodPass.prototype._initConstantData = function (shader) {
        _super.prototype._initConstantData.call(this, shader);
        //Updates method constants if they have changed.
        var len = this._chunks.length;
        for (var i = 0; i < len; ++i)
            this._chunks[i]._initConstants();
    };
    Object.defineProperty(MethodPass.prototype, "colorTransform", {
        /**
         * The ColorTransform object to transform the colour of the material with. Defaults to null.
         */
        get: function () {
            return this.colorTransformMethod ? this.colorTransformMethod.colorTransform : null;
        },
        set: function (value) {
            if (value) {
                if (this.colorTransformMethod == null)
                    this.colorTransformMethod = new EffectColorTransformMethod();
                this.colorTransformMethod.colorTransform = value;
            }
            else if (!value) {
                if (this.colorTransformMethod)
                    this.colorTransformMethod = null;
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "colorTransformMethod", {
        /**
         * The EffectColorTransformMethod object to transform the colour of the material with. Defaults to null.
         */
        get: function () {
            return this._colorTransformMethod;
        },
        set: function (value) {
            if (this._colorTransformMethod == value)
                return;
            if (this._colorTransformMethod) {
                this._removeDependency(this._colorTransformMethod);
                this._colorTransformChunk = null;
            }
            this._colorTransformMethod = value;
            if (value) {
                this._colorTransformChunk = this._shader.getAbstraction(value);
                this._addDependency(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    MethodPass.prototype._removeDependency = function (method, effectsDependency) {
        if (effectsDependency === void 0) { effectsDependency = false; }
        var index = this._methods.indexOf(method);
        if (index == -1)
            return;
        if (!effectsDependency)
            this._numEffectDependencies--;
        method.removeEventListener(_awayjs_renderer.ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);
        this._methods.splice(index, 1);
        this._chunks.splice(index, 1);
        this.invalidate();
    };
    MethodPass.prototype._addDependency = function (method, effectsDependency, index) {
        if (effectsDependency === void 0) { effectsDependency = false; }
        if (index === void 0) { index = -1; }
        method.addEventListener(_awayjs_renderer.ShadingMethodEvent.SHADER_INVALIDATED, this._onMethodInvalidatedDelegate);
        var chunk = this._shader.getAbstraction(method);
        if (effectsDependency) {
            if (index != -1) {
                this._methods.splice(index + this._methods.length - this._numEffectDependencies, 0, method);
                this._chunks.splice(index + this._chunks.length - this._numEffectDependencies, 0, chunk);
            }
            else {
                this._methods.push(method);
                this._chunks.push(chunk);
            }
            this._numEffectDependencies++;
        }
        else {
            this._methods.splice(this._methods.length - this._numEffectDependencies, 0, method);
            this._chunks.splice(this._chunks.length - this._numEffectDependencies, 0, chunk);
        }
        this.invalidate();
    };
    /**
     * Appends an "effect" shading method to the shader. Effect methods are those that do not influence the lighting
     * but modulate the shaded colour, used for fog, outlines, etc. The method will be applied to the result of the
     * methods added prior.
     */
    MethodPass.prototype.addEffectMethod = function (method) {
        this._addDependency(method, true);
    };
    Object.defineProperty(MethodPass.prototype, "numEffectMethods", {
        /**
         * The number of "effect" methods added to the material.
         */
        get: function () {
            return this._numEffectDependencies;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Queries whether a given effects method was added to the material.
     *
     * @param method The method to be queried.
     * @return true if the method was added to the material, false otherwise.
     */
    MethodPass.prototype.hasEffectMethod = function (method) {
        return this._methods.indexOf(method) != -1;
    };
    /**
     * Returns the method added at the given index.
     * @param index The index of the method to retrieve.
     * @return The method at the given index.
     */
    MethodPass.prototype.getEffectMethodAt = function (index) {
        if (index < 0 || index > this._numEffectDependencies - 1)
            return null;
        return this._methods[index + this._methods.length - this._numEffectDependencies];
    };
    /**
     * Adds an effect method at the specified index amongst the methods already added to the material. Effect
     * methods are those that do not influence the lighting but modulate the shaded colour, used for fog, outlines,
     * etc. The method will be applied to the result of the methods with a lower index.
     */
    MethodPass.prototype.addEffectMethodAt = function (method, index) {
        this._addDependency(method, true, index);
    };
    /**
     * Removes an effect method from the material.
     * @param method The method to be removed.
     */
    MethodPass.prototype.removeEffectMethod = function (method) {
        this._removeDependency(method, true);
    };
    /**
     * remove an effect method at the specified index from the material.
     */
    MethodPass.prototype.removeEffectMethodAt = function (index) {
        var method = this.getEffectMethodAt(index);
        if (method != null)
            this._removeDependency(method, true);
    };
    Object.defineProperty(MethodPass.prototype, "normalMethod", {
        /**
         * The method used to generate the per-pixel normals. Defaults to NormalBasicMethod.
         */
        get: function () {
            return this._normalMethod;
        },
        set: function (value) {
            if (this._normalMethod == value)
                return;
            if (this._normalMethod) {
                this._removeDependency(this._normalMethod);
                this._normalChunk = null;
            }
            this._normalMethod = value;
            if (value) {
                this._normalChunk = this._shader.getAbstraction(value);
                this._addDependency(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "ambientMethod", {
        /**
         * The method that provides the ambient lighting contribution. Defaults to AmbientBasicMethod.
         */
        get: function () {
            return this._ambientMethod;
        },
        set: function (value) {
            if (this._ambientMethod == value)
                return;
            if (this._ambientMethod) {
                this._removeDependency(this._ambientMethod);
                this._ambientChunk = null;
            }
            this._ambientMethod = value;
            if (value) {
                this._ambientChunk = this._shader.getAbstraction(value);
                this._addDependency(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "shadowMethod", {
        /**
         * The method used to render shadows cast on this surface, or null if no shadows are to be rendered. Defaults to null.
         */
        get: function () {
            return this._shadowMethod;
        },
        set: function (value) {
            if (this._shadowMethod == value)
                return;
            if (this._shadowMethod) {
                this._removeDependency(this._shadowMethod);
                this._shadowChunk = null;
            }
            this._shadowMethod = value;
            if (value) {
                this._shadowChunk = this._shader.getAbstraction(value);
                this._addDependency(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "diffuseMethod", {
        /**
         * The method that provides the diffuse lighting contribution. Defaults to DiffuseBasicMethod.
         */
        get: function () {
            return this._diffuseMethod;
        },
        set: function (value) {
            if (this._diffuseMethod == value)
                return;
            if (this._diffuseMethod) {
                this._removeDependency(this._diffuseMethod);
                this._diffuseChunk = null;
            }
            if (value) {
                this._diffuseChunk = this._shader.getAbstraction(value);
                this._addDependency(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(MethodPass.prototype, "specularMethod", {
        /**
         * The method that provides the specular lighting contribution. Defaults to SpecularBasicMethod.
         */
        get: function () {
            return this._specularMethod;
        },
        set: function (value) {
            if (this._specularMethod == value)
                return;
            if (this._specularMethod) {
                this._removeDependency(this._specularMethod);
                this._specularChunk = null;
            }
            if (value) {
                this._specularChunk = this._shader.getAbstraction(value);
                this._addDependency(value);
            }
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    MethodPass.prototype.dispose = function () {
        if (this._lightPicker)
            this._lightPicker.removeEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onLightsChangeDelegate);
        while (this._methods.length)
            this._removeDependency(this._methods[0]);
        _super.prototype.dispose.call(this);
        this._chunks = null;
        this._methods = null;
    };
    /**
     * Called when any method's shader code is invalidated.
     */
    MethodPass.prototype.onMethodInvalidated = function (event) {
        this.invalidate();
    };
    // RENDER LOOP
    /**
     * @inheritDoc
     */
    MethodPass.prototype._activate = function (projection) {
        _super.prototype._activate.call(this, projection);
        var chunk;
        var len = this._chunks.length;
        for (var i = 0; i < len; ++i) {
            chunk = this._chunks[i];
            if (chunk.chunkVO.useChunk)
                chunk._activate();
        }
    };
    /**
     *
     *
     * @param renderable
     * @param stage
     * @param camera
     */
    MethodPass.prototype._setRenderState = function (renderable, projection) {
        _super.prototype._setRenderState.call(this, renderable, projection);
        var chunk;
        var len = this._chunks.length;
        for (var i = 0; i < len; ++i) {
            chunk = this._chunks[i];
            if (chunk.chunkVO.useChunk)
                chunk._setRenderState(renderable, projection);
        }
    };
    /**
     * @inheritDoc
     */
    MethodPass.prototype._deactivate = function () {
        _super.prototype._deactivate.call(this);
        var chunk;
        var len = this._chunks.length;
        for (var i = 0; i < len; ++i) {
            chunk = this._chunks[i];
            if (chunk.chunkVO.useChunk)
                chunk._deactivate();
        }
    };
    MethodPass.prototype._includeDependencies = function (shader) {
        _super.prototype._includeDependencies.call(this, shader);
        //TODO: fragment animtion should be compatible with lighting pass
        shader.usesFragmentAnimation = Boolean(this._mode == MethodPassMode.SUPER_SHADER);
        if (shader.useAlphaPremultiplied && shader.usesBlending)
            shader.usesCommonData = true;
        var i;
        var len = this._chunks.length;
        for (i = 0; i < len; ++i)
            this.setupAndCountDependencies(shader, this._chunks[i]);
        var usesTangentSpace = true;
        var chunk;
        for (i = 0; i < len; ++i) {
            chunk = this._chunks[i];
            if ((chunk.chunkVO.useChunk = chunk._isUsed()) && !chunk._usesTangentSpace())
                usesTangentSpace = false;
        }
        shader.outputsNormals = this._normalChunk && this._normalChunk.chunkVO.useChunk;
        shader.outputsTangentNormals = shader.outputsNormals && this._normalChunk._outputsTangentNormals();
        shader.usesTangentSpace = shader.outputsTangentNormals && !shader.usesProbes && usesTangentSpace;
        if (!shader.usesTangentSpace) {
            if (shader.viewDirDependencies > 0) {
                shader.globalPosDependencies++;
            }
            else if (this.numPointLights > 0 && shader.usesLights) {
                shader.globalPosDependencies++;
                if (Boolean(this._mode & MethodPassMode.EFFECTS))
                    shader.usesGlobalPosFragment = true;
            }
        }
    };
    /**
     * Counts the dependencies for a given method.
     * @param method The method to count the dependencies for.
     * @param chunk The method's data for this material.
     */
    MethodPass.prototype.setupAndCountDependencies = function (shader, chunk) {
        var chunkVO = chunk.chunkVO;
        chunk._reset(chunkVO);
        chunk._initVO(chunkVO);
        if (chunkVO.needsProjection)
            shader.projectionDependencies++;
        if (chunkVO.needsGlobalVertexPos || chunkVO.needsGlobalFragmentPos) {
            shader.globalPosDependencies++;
            if (chunkVO.needsGlobalFragmentPos)
                shader.usesGlobalPosFragment = true;
        }
        if (chunkVO.needsNormals)
            shader.normalDependencies++;
        if (chunkVO.needsTangents)
            shader.tangentDependencies++;
        if (chunkVO.needsView)
            shader.viewDirDependencies++;
    };
    MethodPass.prototype._getPreLightingVertexCode = function (registerCache, sharedRegisters) {
        var code = "";
        return code;
    };
    MethodPass.prototype._getPreLightingFragmentCode = function (registerCache, sharedRegisters) {
        var code = "";
        if (this._diffuseChunk && this._diffuseChunk.chunkVO.useChunk)
            code += this._diffuseChunk._getFragmentPreLightingCode(registerCache, sharedRegisters);
        if (this._specularChunk && this._specularChunk.chunkVO.useChunk)
            code += this._specularChunk._getFragmentPreLightingCode(registerCache, sharedRegisters);
        return code;
    };
    MethodPass.prototype._getPerLightDiffuseFragmentCode = function (lightDirReg, diffuseColorReg, registerCache, sharedRegisters) {
        return this._diffuseChunk._getFragmentCodePerLight(lightDirReg, diffuseColorReg, registerCache, sharedRegisters);
    };
    MethodPass.prototype._getPerLightSpecularFragmentCode = function (lightDirReg, specularColorReg, registerCache, sharedRegisters) {
        return this._specularChunk._getFragmentCodePerLight(lightDirReg, specularColorReg, registerCache, sharedRegisters);
    };
    MethodPass.prototype._getPerProbeDiffuseFragmentCode = function (texReg, weightReg, registerCache, sharedRegisters) {
        return this._diffuseChunk._getFragmentCodePerProbe(texReg, weightReg, registerCache, sharedRegisters);
    };
    MethodPass.prototype._getPerProbeSpecularFragmentCode = function (texReg, weightReg, registerCache, sharedRegisters) {
        return this._specularChunk._getFragmentCodePerProbe(texReg, weightReg, registerCache, sharedRegisters);
    };
    MethodPass.prototype._getNormalVertexCode = function (registerCache, sharedRegisters) {
        return this._normalChunk._getVertexCode(registerCache, sharedRegisters);
    };
    MethodPass.prototype._getNormalFragmentCode = function (registerCache, sharedRegisters) {
        var code = this._normalChunk._getFragmentCode(sharedRegisters.normalFragment, registerCache, sharedRegisters);
        if (this._normalChunk.chunkVO.needsView)
            registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        if (this._normalChunk.chunkVO.needsGlobalFragmentPos || this._normalChunk.chunkVO.needsGlobalVertexPos)
            registerCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);
        return code;
    };
    /**
     * @inheritDoc
     */
    MethodPass.prototype._getVertexCode = function (registerCache, sharedRegisters) {
        var code = "";
        if (this._ambientChunk && this._ambientChunk.chunkVO.useChunk)
            code += this._ambientChunk._getVertexCode(registerCache, sharedRegisters);
        if (this._shadowChunk)
            code += this._shadowChunk._getVertexCode(registerCache, sharedRegisters);
        if (this._diffuseChunk && this._diffuseChunk.chunkVO.useChunk)
            code += this._diffuseChunk._getVertexCode(registerCache, sharedRegisters);
        if (this._specularChunk && this._specularChunk.chunkVO.useChunk)
            code += this._specularChunk._getVertexCode(registerCache, sharedRegisters);
        var chunk;
        var len = this._chunks.length;
        for (var i = len - this._numEffectDependencies; i < len; i++) {
            chunk = this._chunks[i];
            if (chunk.chunkVO.useChunk) {
                code += chunk._getVertexCode(registerCache, sharedRegisters);
                if (chunk.chunkVO.needsGlobalVertexPos || chunk.chunkVO.needsGlobalFragmentPos)
                    registerCache.removeVertexTempUsage(sharedRegisters.globalPositionVertex);
            }
        }
        if (this._colorTransformChunk && this._colorTransformChunk.chunkVO.useChunk)
            code += this._colorTransformChunk._getVertexCode(registerCache, sharedRegisters);
        return code;
    };
    /**
     * @inheritDoc
     */
    MethodPass.prototype._getFragmentCode = function (registerCache, sharedRegisters) {
        var code = "";
        if (this._ambientChunk && this._ambientChunk.chunkVO.useChunk) {
            code += this._ambientChunk._getFragmentCode(sharedRegisters.shadedTarget, registerCache, sharedRegisters);
            if (this._ambientChunk.chunkVO.needsNormals)
                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
            if (this._ambientChunk.chunkVO.needsView)
                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        }
        return code;
    };
    MethodPass.prototype._getPostAnimationFragmentCode = function (registerCache, sharedRegisters) {
        var code = "";
        //if blending with premultiplied alpha, make sure ambient color is correctly multiplied
        if (this._shader.useAlphaPremultiplied && this._shader.usesBlending) {
            code += "add " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.commons + ".z\n" +
                "div " + sharedRegisters.shadedTarget + ".xyz, " + sharedRegisters.shadedTarget + ", " + sharedRegisters.shadedTarget + ".w\n" +
                "sub " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.shadedTarget + ".w, " + sharedRegisters.commons + ".z\n" +
                "sat " + sharedRegisters.shadedTarget + ".xyz, " + sharedRegisters.shadedTarget + "\n";
        }
        ///////////////begin lighting shading
        if (this._shadowChunk)
            code += this._shadowChunk._getFragmentCode(sharedRegisters.shadowTarget, registerCache, sharedRegisters);
        if (this._diffuseChunk && this._diffuseChunk.chunkVO.useChunk) {
            code += this._diffuseChunk._getFragmentCode(sharedRegisters.shadedTarget, registerCache, sharedRegisters);
            // resolve other dependencies as well?
            if (this._diffuseChunk.chunkVO.needsNormals)
                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
            if (this._diffuseChunk.chunkVO.needsView)
                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        }
        if (this._specularChunk && this._specularChunk.chunkVO.useChunk) {
            code += this._specularChunk._getFragmentCode(sharedRegisters.shadedTarget, registerCache, sharedRegisters);
            if (this._specularChunk.chunkVO.needsNormals)
                registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
            if (this._specularChunk.chunkVO.needsView)
                registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
        }
        if (this._shadowChunk)
            registerCache.removeFragmentTempUsage(sharedRegisters.shadowTarget);
        ///////////////end lighting shading
        var alphaReg;
        //check if alpha is preserved while performing effects shading and store value
        if (this.preserveAlpha && this._numEffectDependencies > 0) {
            alphaReg = registerCache.getFreeFragmentSingleTemp();
            registerCache.addFragmentTempUsages(alphaReg, 1);
            code += "mov " + alphaReg + ", " + sharedRegisters.shadedTarget + ".w\n";
        }
        //perform effects shading
        var chunk;
        var len = this._chunks.length;
        for (var i = len - this._numEffectDependencies; i < len; i++) {
            chunk = this._chunks[i];
            if (chunk.chunkVO.useChunk) {
                code += chunk._getFragmentCode(sharedRegisters.shadedTarget, registerCache, sharedRegisters);
                if (chunk.chunkVO.needsNormals)
                    registerCache.removeFragmentTempUsage(sharedRegisters.normalFragment);
                if (chunk.chunkVO.needsView)
                    registerCache.removeFragmentTempUsage(sharedRegisters.viewDirFragment);
            }
        }
        //check if alpha is preserved while performing effects shading and restore value
        if (this.preserveAlpha && this._numEffectDependencies > 0) {
            code += "mov " + sharedRegisters.shadedTarget + ".w, " + alphaReg + "\n";
            registerCache.removeFragmentTempUsage(alphaReg);
        }
        //peform final colortransform chunk if it exists
        if (this._colorTransformChunk && this._colorTransformChunk.chunkVO.useChunk)
            code += this._colorTransformChunk._getFragmentCode(sharedRegisters.shadedTarget, registerCache, sharedRegisters);
        return code;
    };
    /**
     * Indicates whether the shader uses any shadows.
     */
    MethodPass.prototype._iUsesShadows = function (shader) {
        return Boolean(this._shadowChunk && (this._lightPicker.castingDirectionalLights.length > 0 || this._lightPicker.castingPointLights.length > 0));
    };
    /**
     * Indicates whether the shader uses any specular component.
     */
    MethodPass.prototype._iUsesSpecular = function (shader) {
        return Boolean(this._specularChunk);
    };
    /**
     * Indicates whether the shader uses any specular component.
     */
    MethodPass.prototype._iUsesDiffuse = function (shader) {
        return Boolean(this._diffuseChunk);
    };
    MethodPass.prototype.onLightsChange = function (event) {
        this._updateLights();
    };
    MethodPass.prototype._updateLights = function () {
        var numDirectionalLightsOld = this.numDirectionalLights;
        var numPointLightsOld = this.numPointLights;
        var numLightProbesOld = this.numLightProbes;
        if (this._lightPicker && (this._mode & MethodPassMode.LIGHTING)) {
            this.numDirectionalLights = this.calculateNumDirectionalLights(this._lightPicker.numDirectionalLights);
            this.numPointLights = this.calculateNumPointLights(this._lightPicker.numPointLights);
            this.numLightProbes = this.calculateNumProbes(this._lightPicker.numLightProbes);
            if (this._includeCasters) {
                this.numDirectionalLights += this._lightPicker.numCastingDirectionalLights;
                this.numPointLights += this._lightPicker.numCastingPointLights;
            }
        }
        else {
            this.numDirectionalLights = 0;
            this.numPointLights = 0;
            this.numLightProbes = 0;
        }
        if (numDirectionalLightsOld != this.numDirectionalLights || numPointLightsOld != this.numPointLights || numLightProbesOld != this.numLightProbes) {
            this._updateShader();
            this.invalidate();
        }
    };
    /**
     * Calculates the amount of directional lights this material will support.
     * @param numDirectionalLights The maximum amount of directional lights to support.
     * @return The amount of directional lights this material will support, bounded by the amount necessary.
     */
    MethodPass.prototype.calculateNumDirectionalLights = function (numDirectionalLights) {
        return Math.min(numDirectionalLights - this.directionalLightsOffset, this._maxLights);
    };
    /**
     * Calculates the amount of point lights this material will support.
     * @param numDirectionalLights The maximum amount of point lights to support.
     * @return The amount of point lights this material will support, bounded by the amount necessary.
     */
    MethodPass.prototype.calculateNumPointLights = function (numPointLights) {
        var numFree = this._maxLights - this.numDirectionalLights;
        return Math.min(numPointLights - this.pointLightsOffset, numFree);
    };
    /**
     * Calculates the amount of light probes this material will support.
     * @param numDirectionalLights The maximum amount of light probes to support.
     * @return The amount of light probes this material will support, bounded by the amount necessary.
     */
    MethodPass.prototype.calculateNumProbes = function (numLightProbes) {
        var numChannels = 0;
        if ((this._material.specularLightSources & _awayjs_scene.LightSources.PROBES) != 0)
            ++numChannels;
        if ((this._material.diffuseLightSources & _awayjs_scene.LightSources.PROBES) != 0)
            ++numChannels;
        // 4 channels available
        return Math.min(numLightProbes - this.lightProbesOffset, (4 / numChannels) | 0);
    };
    return MethodPass;
}(_awayjs_stage.PassBase));

/**
 * CompiledPass forms an abstract base class for the default compiled pass materials provided by Away3D,
 * using material methods to define their appearance.
 */
var GL_MethodMaterial = (function (_super) {
    __extends(GL_MethodMaterial, _super);
    /**
     * Creates a new CompiledPass object.
     *
     * @param material The material to which this pass belongs.
     */
    function GL_MethodMaterial(material, materialPool) {
        var _this = _super.call(this, material, materialPool) || this;
        _this._methodMaterial = material;
        _this._materialPool = materialPool;
        return _this;
    }
    Object.defineProperty(GL_MethodMaterial.prototype, "numLights", {
        /**
         * The maximum total number of lights provided by the light picker.
         */
        get: function () {
            return this._methodMaterial.lightPicker ? this._methodMaterial.lightPicker.numLightProbes + this._methodMaterial.lightPicker.numDirectionalLights + this._methodMaterial.lightPicker.numPointLights + this._methodMaterial.lightPicker.numCastingDirectionalLights + this._methodMaterial.lightPicker.numCastingPointLights : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MethodMaterial.prototype, "numNonCasters", {
        /**
         * The amount of lights that don't cast shadows.
         */
        get: function () {
            return this._methodMaterial.lightPicker ? this._methodMaterial.lightPicker.numLightProbes + this._methodMaterial.lightPicker.numDirectionalLights + this._methodMaterial.lightPicker.numPointLights : 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MethodMaterial.prototype, "lightPicker", {
        get: function () {
            return this._methodMaterial.lightPicker;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MethodMaterial.prototype, "enableLightFallOff", {
        /**
         * Whether or not to use fallOff and radius properties for lights. This can be used to improve performance and
         * compatibility for constrained mode.
         */
        get: function () {
            return this._methodMaterial.enableLightFallOff;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MethodMaterial.prototype, "diffuseLightSources", {
        /**
         * Define which light source types to use for diffuse reflections. This allows choosing between regular lights
         * and/or light probes for diffuse reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._methodMaterial.diffuseLightSources;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(GL_MethodMaterial.prototype, "specularLightSources", {
        /**
         * Define which light source types to use for specular reflections. This allows choosing between regular lights
         * and/or light probes for specular reflections.
         *
         * @see away3d.materials.LightSources
         */
        get: function () {
            return this._methodMaterial.specularLightSources;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * @inheritDoc
     */
    GL_MethodMaterial.prototype._pUpdateRender = function () {
        _super.prototype._pUpdateRender.call(this);
        this.initPasses();
        this.setBlendAndCompareModes();
        this._pClearPasses();
        if (this._methodMaterial.mode == MethodMaterialMode.MULTI_PASS) {
            if (this._casterLightPass)
                this._pAddPass(this._casterLightPass);
            if (this._nonCasterLightPasses)
                for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
                    this._pAddPass(this._nonCasterLightPasses[i]);
        }
        if (this._pass)
            this._pAddPass(this._pass);
    };
    /**
     * Initializes all the passes and their dependent passes.
     */
    GL_MethodMaterial.prototype.initPasses = function () {
        // let the effects pass handle everything if there are no lights, when there are effect methods applied
        // after shading, or when the material mode is single pass.
        if (this.numLights == 0 || this._methodMaterial.numEffectMethods > 0 || this._methodMaterial.mode == MethodMaterialMode.SINGLE_PASS)
            this.initEffectPass();
        else if (this._pass)
            this.removeEffectPass();
        // only use a caster light pass if shadows need to be rendered
        if (this._methodMaterial.shadowMethod && this._methodMaterial.mode == MethodMaterialMode.MULTI_PASS)
            this.initCasterLightPass();
        else if (this._casterLightPass)
            this.removeCasterLightPass();
        // only use non caster light passes if there are lights that don't cast
        if (this.numNonCasters > 0 && this._methodMaterial.mode == MethodMaterialMode.MULTI_PASS)
            this.initNonCasterLightPasses();
        else if (this._nonCasterLightPasses)
            this.removeNonCasterLightPasses();
    };
    /**
     * Sets up the various blending modes for all screen passes, based on whether or not there are previous passes.
     */
    GL_MethodMaterial.prototype.setBlendAndCompareModes = function () {
        var forceSeparateMVP = Boolean(this._casterLightPass || this._pass);
        // caster light pass is always first if it exists, hence it uses normal blending
        if (this._casterLightPass) {
            this._casterLightPass.forceSeparateMVP = forceSeparateMVP;
            this._casterLightPass.shader.setBlendMode(_awayjs_graphics.BlendMode.NORMAL);
            this._casterLightPass.shader.depthCompareMode = this._methodMaterial.depthCompareMode;
        }
        if (this._nonCasterLightPasses) {
            var firstAdditiveIndex = 0;
            // if there's no caster light pass, the first non caster light pass will be the first
            // and should use normal blending
            if (!this._casterLightPass) {
                this._nonCasterLightPasses[0].forceSeparateMVP = forceSeparateMVP;
                this._nonCasterLightPasses[0].shader.setBlendMode(_awayjs_graphics.BlendMode.NORMAL);
                this._nonCasterLightPasses[0].shader.depthCompareMode = this._methodMaterial.depthCompareMode;
                firstAdditiveIndex = 1;
            }
            // all lighting passes following the first light pass should use additive blending
            for (var i = firstAdditiveIndex; i < this._nonCasterLightPasses.length; ++i) {
                this._nonCasterLightPasses[i].forceSeparateMVP = forceSeparateMVP;
                this._nonCasterLightPasses[i].shader.setBlendMode(_awayjs_graphics.BlendMode.ADD);
                this._nonCasterLightPasses[i].shader.depthCompareMode = _awayjs_stage.ContextGLCompareMode.LESS_EQUAL;
            }
        }
        if (this._casterLightPass || this._nonCasterLightPasses) {
            //cannot be blended by blendmode property if multipass enabled
            this._pRequiresBlending = false;
            // there are light passes, so this should be blended in
            if (this._pass) {
                this._pass.mode = MethodPassMode.EFFECTS;
                this._pass.forceSeparateMVP = forceSeparateMVP;
                this._pass.shader.depthCompareMode = _awayjs_stage.ContextGLCompareMode.LESS_EQUAL;
                this._pass.shader.setBlendMode(_awayjs_graphics.BlendMode.LAYER);
            }
        }
        else if (this._pass) {
            this._pRequiresBlending = (this._methodMaterial.blendMode != _awayjs_graphics.BlendMode.NORMAL || this._methodMaterial.alphaBlending || (this._methodMaterial.colorTransform && this._methodMaterial.colorTransform.alphaMultiplier < 1));
            // effects pass is the only pass, so it should just blend normally
            this._pass.mode = MethodPassMode.SUPER_SHADER;
            this._pass.preserveAlpha = this._pRequiresBlending;
            this._pass.forceSeparateMVP = false;
            this._pass.colorTransform = this._methodMaterial.colorTransform;
            this._pass.shader.setBlendMode((this._methodMaterial.blendMode == _awayjs_graphics.BlendMode.NORMAL && this._pRequiresBlending) ? _awayjs_graphics.BlendMode.LAYER : this._methodMaterial.blendMode);
            this._pass.shader.depthCompareMode = this._methodMaterial.depthCompareMode;
        }
    };
    GL_MethodMaterial.prototype.initCasterLightPass = function () {
        if (this._casterLightPass == null)
            this._casterLightPass = new MethodPass(MethodPassMode.LIGHTING, this, this._materialPool);
        this._casterLightPass.lightPicker = new _awayjs_scene.StaticLightPicker([this._methodMaterial.shadowMethod.castingLight]);
        this._casterLightPass.shadowMethod = this._methodMaterial.shadowMethod;
        this._casterLightPass.diffuseMethod = this._methodMaterial.diffuseMethod;
        this._casterLightPass.ambientMethod = this._methodMaterial.ambientMethod;
        this._casterLightPass.normalMethod = this._methodMaterial.normalMethod;
        this._casterLightPass.specularMethod = this._methodMaterial.specularMethod;
    };
    GL_MethodMaterial.prototype.removeCasterLightPass = function () {
        this._casterLightPass.dispose();
        this._pRemovePass(this._casterLightPass);
        this._casterLightPass = null;
    };
    GL_MethodMaterial.prototype.initNonCasterLightPasses = function () {
        this.removeNonCasterLightPasses();
        var pass;
        var numDirLights = this._methodMaterial.lightPicker.numDirectionalLights;
        var numPointLights = this._methodMaterial.lightPicker.numPointLights;
        var numLightProbes = this._methodMaterial.lightPicker.numLightProbes;
        var dirLightOffset = 0;
        var pointLightOffset = 0;
        var probeOffset = 0;
        if (!this._casterLightPass) {
            numDirLights += this._methodMaterial.lightPicker.numCastingDirectionalLights;
            numPointLights += this._methodMaterial.lightPicker.numCastingPointLights;
        }
        this._nonCasterLightPasses = new Array();
        while (dirLightOffset < numDirLights || pointLightOffset < numPointLights || probeOffset < numLightProbes) {
            pass = new MethodPass(MethodPassMode.LIGHTING, this, this._materialPool);
            pass.includeCasters = this._methodMaterial.shadowMethod == null;
            pass.directionalLightsOffset = dirLightOffset;
            pass.pointLightsOffset = pointLightOffset;
            pass.lightProbesOffset = probeOffset;
            pass.lightPicker = this._methodMaterial.lightPicker;
            pass.diffuseMethod = this._methodMaterial.diffuseMethod;
            pass.ambientMethod = this._methodMaterial.ambientMethod;
            pass.normalMethod = this._methodMaterial.normalMethod;
            pass.specularMethod = this._methodMaterial.specularMethod;
            this._nonCasterLightPasses.push(pass);
            dirLightOffset += pass.numDirectionalLights;
            pointLightOffset += pass.numPointLights;
            probeOffset += pass.numLightProbes;
        }
    };
    GL_MethodMaterial.prototype.removeNonCasterLightPasses = function () {
        if (!this._nonCasterLightPasses)
            return;
        for (var i = 0; i < this._nonCasterLightPasses.length; ++i)
            this._pRemovePass(this._nonCasterLightPasses[i]);
        this._nonCasterLightPasses = null;
    };
    GL_MethodMaterial.prototype.removeEffectPass = function () {
        if (this._pass.ambientMethod != this._methodMaterial.ambientMethod)
            this._pass.ambientMethod.dispose();
        if (this._pass.diffuseMethod != this._methodMaterial.diffuseMethod)
            this._pass.diffuseMethod.dispose();
        if (this._pass.specularMethod != this._methodMaterial.specularMethod)
            this._pass.specularMethod.dispose();
        if (this._pass.normalMethod != this._methodMaterial.normalMethod)
            this._pass.normalMethod.dispose();
        this._pRemovePass(this._pass);
        this._pass = null;
    };
    GL_MethodMaterial.prototype.initEffectPass = function () {
        if (this._pass == null)
            this._pass = new MethodPass(MethodPassMode.SUPER_SHADER, this, this._materialPool);
        if (this._methodMaterial.mode == MethodMaterialMode.SINGLE_PASS) {
            this._pass.ambientMethod = this._methodMaterial.ambientMethod;
            this._pass.diffuseMethod = this._methodMaterial.diffuseMethod;
            this._pass.specularMethod = this._methodMaterial.specularMethod;
            this._pass.normalMethod = this._methodMaterial.normalMethod;
            this._pass.shadowMethod = this._methodMaterial.shadowMethod;
        }
        else if (this._methodMaterial.mode == MethodMaterialMode.MULTI_PASS) {
            if (this.numLights == 0) {
                this._pass.ambientMethod = this._methodMaterial.ambientMethod;
            }
            else {
                this._pass.ambientMethod = null;
            }
            this._pass.preserveAlpha = false;
            this._pass.normalMethod = this._methodMaterial.normalMethod;
        }
        //update effect methods
        var i = 0;
        var effectMethod;
        var len = Math.max(this._methodMaterial.numEffectMethods, this._pass.numEffectMethods);
        while (i < len) {
            effectMethod = this._methodMaterial.getEffectMethodAt(i);
            if (effectMethod != this._pass.getEffectMethodAt(i)) {
                this._pass.removeEffectMethodAt(i);
                if (effectMethod != null) {
                    if (i < this._pass.numEffectMethods)
                        this._pass.addEffectMethodAt(effectMethod, i);
                    else
                        this._pass.addEffectMethod(effectMethod);
                }
            }
            i++;
        }
    };
    /**
     * @inheritDoc
     */
    GL_MethodMaterial.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        //TODO
    };
    return GL_MethodMaterial;
}(_awayjs_stage.GL_MaterialBase));

exports.MethodMaterial = MethodMaterial;
exports.MethodMaterialMode = MethodMaterialMode;
exports.LightingCompositeChunk = LightingCompositeChunk;
exports.AmbientBasicMethod = AmbientBasicMethod;
exports.AmbientDepthMethod = AmbientDepthMethod;
exports.CompositeMethodBase = CompositeMethodBase;
exports.DiffuseBasicMethod = DiffuseBasicMethod;
exports.DiffuseCelMethod = DiffuseCelMethod;
exports.DiffuseCompositeMethod = DiffuseCompositeMethod;
exports.DiffuseGradientMethod = DiffuseGradientMethod;
exports.DiffuseLightMapMethod = DiffuseLightMapMethod;
exports.DiffuseWrapMethod = DiffuseWrapMethod;
exports.EffectAlphaMaskMethod = EffectAlphaMaskMethod;
exports.EffectColorMatrixMethod = EffectColorMatrixMethod;
exports.EffectColorTransformMethod = EffectColorTransformMethod;
exports.EffectEnvMapMethod = EffectEnvMapMethod;
exports.EffectFogMethod = EffectFogMethod;
exports.EffectFresnelEnvMapMethod = EffectFresnelEnvMapMethod;
exports.EffectLightMapMethod = EffectLightMapMethod;
exports.EffectProjectiveTextureMethod = EffectProjectiveTextureMethod;
exports.EffectRefractionEnvMapMethod = EffectRefractionEnvMapMethod;
exports.EffectRimLightMethod = EffectRimLightMethod;
exports.NormalBasicMethod = NormalBasicMethod;
exports.NormalHeightMapMethod = NormalHeightMapMethod;
exports.NormalSimpleWaterMethod = NormalSimpleWaterMethod;
exports.ShadingMethodBase = ShadingMethodBase;
exports.ShadowCascadeMethod = ShadowCascadeMethod;
exports.ShadowCompositeMethod = ShadowCompositeMethod;
exports.ShadowDitheredMethod = ShadowDitheredMethod;
exports.ShadowFilteredMethod = ShadowFilteredMethod;
exports.ShadowHardMethod = ShadowHardMethod;
exports.ShadowMethodBase = ShadowMethodBase;
exports.ShadowNearMethod = ShadowNearMethod;
exports.ShadowSoftMethod = ShadowSoftMethod;
exports.SpecularAnisotropicMethod = SpecularAnisotropicMethod;
exports.SpecularBasicMethod = SpecularBasicMethod;
exports.SpecularCelMethod = SpecularCelMethod;
exports.SpecularCompositeMethod = SpecularCompositeMethod;
exports.SpecularFresnelMethod = SpecularFresnelMethod;
exports.SpecularPhongMethod = SpecularPhongMethod;
exports.MethodPass = MethodPass;
exports.MethodPassMode = MethodPassMode;
exports.GL_MethodMaterial = GL_MethodMaterial;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(9), __webpack_require__(10), __webpack_require__(14), __webpack_require__(7), __webpack_require__(12)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/graphics', '@awayjs/scene', '@awayjs/materials', '@awayjs/core', '@awayjs/renderer'], factory) :
    (factory((global.AwayjsParsers = global.AwayjsParsers || {}),global.AwayjsGraphics,global.AwayjsScene,global.AwayjsMaterials,global.AwayjsCore,global.AwayjsRenderer));
}(this, (function (exports,_awayjs_graphics,_awayjs_scene,_awayjs_materials,_awayjs_core,_awayjs_renderer) { 'use strict';

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

var DefaultSceneGraphFactory = (function (_super) {
    __extends(DefaultSceneGraphFactory, _super);
    function DefaultSceneGraphFactory() {
        return _super.apply(this, arguments) || this;
    }
    DefaultSceneGraphFactory.prototype.createMovieClip = function (timeline) {
        if (timeline === void 0) { timeline = null; }
        return new _awayjs_scene.MovieClip(timeline);
    };
    DefaultSceneGraphFactory.prototype.createSprite = function (prefab) {
        if (prefab === void 0) { prefab = null; }
        if (prefab)
            return prefab.getNewObject();
        return new _awayjs_scene.Sprite();
    };
    DefaultSceneGraphFactory.prototype.createDisplayObjectContainer = function () {
        return new _awayjs_scene.DisplayObjectContainer();
    };
    DefaultSceneGraphFactory.prototype.createTextField = function () {
        return new _awayjs_scene.TextField();
    };
    DefaultSceneGraphFactory.prototype.createBillboard = function (material) {
        return new _awayjs_scene.Billboard(material);
    };
    DefaultSceneGraphFactory.prototype.createMaterial = function (imageColor, alpha) {
        return new _awayjs_materials.MethodMaterial(imageColor, alpha);
    };
    return DefaultSceneGraphFactory;
}(_awayjs_graphics.DefaultGraphicsFactory));

var AWD3Utils = (function () {
    function AWD3Utils() {
    }
    return AWD3Utils;
}());
AWD3Utils.BLOCKSTATE_FINALIZE = 0;
AWD3Utils.BLOCKSTATE_INVALID = 1;
AWD3Utils.BLOCKSTATE_LOAD_DEPENDENICES = 2;
AWD3Utils.BLOCKSTATE_NO_ASSET = 3;
AWD3Utils.COMPRESSIONMODE_LZMA = "lzma";
AWD3Utils.UNCOMPRESSED = 0;
AWD3Utils.DEFLATE = 1;
AWD3Utils.LZMA = 2;
AWD3Utils.INT8 = 1;
AWD3Utils.INT16 = 2;
AWD3Utils.INT32 = 3;
AWD3Utils.UINT8 = 4;
AWD3Utils.UINT16 = 5;
AWD3Utils.UINT32 = 6;
AWD3Utils.FLOAT32 = 7;
AWD3Utils.FLOAT64 = 8;
AWD3Utils.BOOL = 21;
AWD3Utils.COLOR = 22;
AWD3Utils.BADDR = 23;
AWD3Utils.AWDSTRING = 31;
AWD3Utils.AWDBYTEARRAY = 32;
AWD3Utils.VECTOR2x1 = 41;
AWD3Utils.VECTOR3x1 = 42;
AWD3Utils.VECTOR4x1 = 43;
AWD3Utils.MTX3x2 = 44;
AWD3Utils.MTX3x3 = 45;
AWD3Utils.MTX4x3 = 46;
AWD3Utils.MTX4x4 = 47;

var AWDBlock = (function () {
    function AWDBlock(this_id, this_type) {
        this.type = this_type;
        this.id = this_id;
        this.state = AWD3Utils.BLOCKSTATE_FINALIZE;
        this.dependencies_data = Array();
        this.dependencies_urls = Array();
        if (this_type == 83) {
            this.loaded_dependencies = Array(6);
        }
        this.loaded_dependencies_cnt = 0;
    }
    AWDBlock.prototype.dispose = function () {
        this.id = null;
        this.bytes = null;
        this.errorMessages = null;
        this.uvsForVertexAnimation = null;
    };
    AWDBlock.prototype.addError = function (errorMsg) {
        if (!this.errorMessages)
            this.errorMessages = new Array();
        this.errorMessages.push(errorMsg);
    };
    return AWDBlock;
}());

/**
 * AWDParser provides a parser for the AWD data type.
 */
var AWDParser = (function (_super) {
    __extends(AWDParser, _super);
    /**
     * Creates a new AWD3Parserutils object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function AWDParser(factory) {
        if (factory === void 0) { factory = null; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.ARRAY_BUFFER) || this;
        //set to "true" to have some console.logs in the Console
        _this._debug = false;
        _this._debugTimers = true;
        _this._startedParsing = false;
        _this._texture_users = {};
        _this._parsed_header = false;
        _this._time_all = 0;
        _this._time_graphics = 0;
        _this._time_graphics_bytes = 0;
        _this._time_timeline = 0;
        _this._time_fonts = 0;
        _this._time_textfields = 0;
        _this._time_sounds = 0;
        _this._time_textures = 0;
        _this._time_materials = 0;
        _this._time_sprites = 0;
        _this._num_graphics = 0;
        _this._num_timeline = 0;
        _this._num_fonts = 0;
        _this._num_textfields = 0;
        _this._num_sounds = 0;
        _this._num_textures = 0;
        _this._num_materials = 0;
        _this._num_sprites = 0;
        //--Parser UTILS---------------------------------------------------------------------------
        _this.shadowMethodListProperties = {
            1: AWDParser.BADDR,
            2: AWDParser.BADDR,
            3: AWDParser.BADDR,
            101: AWDParser.PROPERTY_NUMBER,
            102: AWDParser.PROPERTY_NUMBER,
            103: AWDParser.PROPERTY_NUMBER,
            201: AWDParser.UINT32,
            202: AWDParser.UINT32,
            301: AWDParser.UINT16,
            302: AWDParser.UINT16,
            401: AWDParser.UINT8,
            402: AWDParser.UINT8,
            601: AWDParser.COLOR,
            602: AWDParser.COLOR,
            701: AWDParser.BOOL,
            702: AWDParser.BOOL,
            801: AWDParser.MTX4x4
        };
        _this.spritePoseAnimationProperties = {
            1: AWDParser.BOOL,
            2: AWDParser.BOOL
        };
        _this.sharedMethodListProperties = {
            1: AWDParser.BADDR,
            2: AWDParser.BADDR,
            3: AWDParser.BADDR,
            101: AWDParser.PROPERTY_NUMBER,
            102: AWDParser.PROPERTY_NUMBER,
            103: AWDParser.PROPERTY_NUMBER,
            104: AWDParser.PROPERTY_NUMBER,
            105: AWDParser.PROPERTY_NUMBER,
            106: AWDParser.PROPERTY_NUMBER,
            107: AWDParser.PROPERTY_NUMBER,
            201: AWDParser.UINT32,
            202: AWDParser.UINT32,
            301: AWDParser.UINT16,
            302: AWDParser.UINT16,
            401: AWDParser.UINT8,
            402: AWDParser.UINT8,
            601: AWDParser.COLOR,
            602: AWDParser.COLOR,
            701: AWDParser.BOOL,
            702: AWDParser.BOOL
        };
        _this._factory = factory || new DefaultSceneGraphFactory();
        _this._blocks = new Array();
        _this._blocks[0] = new AWDBlock(0, 255);
        _this._blocks[0].data = null; // Zero address means null in AWD
        _this.blendModeDic = new Array(); // used to translate ints to blendMode-strings
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.NORMAL);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.ADD);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.ALPHA);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.DARKEN);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.DIFFERENCE);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.ERASE);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.HARDLIGHT);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.INVERT);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.LAYER);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.LIGHTEN);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.MULTIPLY);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.NORMAL);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.OVERLAY);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.SCREEN);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.SHADER);
        _this.blendModeDic.push(_awayjs_graphics.BlendMode.OVERLAY);
        _this._depthSizeDic = new Array(); // used to translate ints to depthSize-values
        _this._depthSizeDic.push(256);
        _this._depthSizeDic.push(512);
        _this._depthSizeDic.push(2048);
        _this._depthSizeDic.push(1024);
        _this._version = Array(); // will contain 2 int (major-version, minor-version) for awd-version-check
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    AWDParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "awd";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    AWDParser.supportsData = function (data) {
        return (_awayjs_core.ParserUtils.toString(data, 3) == 'AWD');
    };
    /**
     * @inheritDoc
     */
    AWDParser.prototype._iResolveDependency = function (resourceDependency) {
        // this will be called when Dependency has finished loading.
        // the ressource dependecniy has a id that point to the awd_block waiting for it.
        //console.log("AWDParser resolve dependencies";
        if (resourceDependency.assets.length == 1) {
            var this_block = this._blocks[parseInt(resourceDependency.id)];
            if (this_block.type == 82) {
                var image_asset = resourceDependency.assets[0];
                this_block.data = image_asset; // Store finished asset
                // Finalize texture asset to dispatch texture event, which was
                // previously suppressed while the dependency was loaded.
                this._pFinalizeAsset(image_asset, this_block.name);
                if (this._debug)
                    console.log("Parsed Texture: Name = " + this_block.name);
            }
            else if (this_block.type == 44) {
                var audio_asset = resourceDependency.assets[0];
                this_block.data = audio_asset; // Store finished asset
                // Finalize texture asset to dispatch texture event, which was
                // previously suppressed while the dependency was loaded.
                //console.log("Parsing audio " + this_block.name);
                this._pFinalizeAsset(audio_asset, this_block.name);
                if (this._debug)
                    console.log("Parsed WaveAudio: Name = " + this_block.name);
            }
            else if (this_block.type == 83) {
                this_block.loaded_dependencies[resourceDependency.sub_id] = resourceDependency.assets[0];
                this_block.loaded_dependencies_cnt++;
                if (this._debug)
                    console.log("Successfully loaded Bitmap " + resourceDependency.sub_id + " / 6 for Cubetexture");
                if (this_block.loaded_dependencies_cnt == 6) {
                    var cube_image_asset = new _awayjs_graphics.BitmapImageCube(this_block.loaded_dependencies[0].width);
                    for (var i = 0; i < 6; i++)
                        cube_image_asset.draw(i, this_block.loaded_dependencies[i]);
                    this_block.data = cube_image_asset; // Store finished asset
                    this._pFinalizeAsset(cube_image_asset, this_block.name);
                    if (this._debug)
                        console.log("Parsed CubeTexture: Name = " + this_block.name);
                }
            }
            if (this._debugTimers && !this._isParsing)
                this.updateTimers(this_block.type);
        }
    };
    /**
     * @inheritDoc
     */
    AWDParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
        //not used - if a dependcy fails, the awaiting Texture or CubeTexture will never be finalized, and the default-bitmaps will be used.
        // this means, that if one Bitmap of a CubeTexture fails, the CubeTexture will have the DefaultTexture applied for all six Bitmaps.
    };
    /**
     * Resolve a dependency name
     *
     * @param resourceDependency The dependency to be resolved.
     */
    AWDParser.prototype._iResolveDependencyName = function (resourceDependency, asset) {
        var oldName = asset.name;
        if (asset) {
            var block = this._blocks[parseInt(resourceDependency.id)];
            // Reset name of texture to the one defined in the AWD file,
            // as opposed to whatever the image parser came up with.
            asset.resetAssetPath(block.name, null, true);
        }
        var newName = asset.name;
        asset.name = oldName;
        return newName;
    };
    /**
     * @inheritDoc
     */
    AWDParser.prototype._pProceedParsing = function () {
        if (!this._startedParsing) {
            this._byteData = this._pGetByteData(); //getByteData();
            this._startedParsing = true;
        }
        if (!this._parsed_header) {
            //----------------------------------------------------------------------------
            // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
            //----------------------------------------------------------------------------
            //this._byteData.endian = Endian.LITTLE_ENDIAN;
            //----------------------------------------------------------------------------
            //----------------------------------------------------------------------------
            // Parse header and decompress body if needed
            this.parseHeader();
            switch (this._compression) {
                case AWDParser.DEFLATE:
                case AWDParser.LZMA:
                    this._pDieWithError('Compressed AWD formats not yet supported');
                    break;
                case AWDParser.UNCOMPRESSED:
                    this._body = this._byteData;
                    break;
            }
            this._parsed_header = true;
        }
        if (this._body) {
            while (this._body.getBytesAvailable() > 0 && !this.parsingPaused)
                this.parseNextBlock();
            //----------------------------------------------------------------------------
            // Return complete status
            if (this._body.getBytesAvailable() == 0) {
                this.dispose();
                if (this._debugTimers)
                    console.log("Parsing total: " + (this._time_all | 0) + "ms", " | graphics: " + this._num_graphics + ", " + (this._time_graphics | 0) + "ms", " | graphics bytes: " + this._num_graphics + ", " + (this._time_graphics_bytes | 0) + "ms", " | timelines: " + this._num_timeline + ", " + (this._time_timeline | 0) + "ms", " | fonts: " + this._num_fonts + ", " + (this._time_fonts | 0) + "ms", " | sounds: " + this._num_sounds + ", " + (this._time_sounds | 0) + "ms", " | mats: " + this._num_materials + ", " + (this._time_materials | 0) + "ms", " | textures: " + this._num_textures + ", " + (this._time_textures | 0) + "ms", " | sprites: " + this._num_sprites + ", " + (this._time_sprites | 0) + "ms");
                return _awayjs_core.ParserBase.PARSING_DONE;
            }
            else {
                return _awayjs_core.ParserBase.MORE_TO_PARSE;
            }
        }
        else {
            switch (this._compression) {
                case AWDParser.DEFLATE:
                case AWDParser.LZMA:
                    if (this._debug)
                        console.log("(!) AWDParser Error: Compressed AWD formats not yet supported (!)");
                    break;
            }
            // Error - most likely _body not set because we do not support compression.
            return _awayjs_core.ParserBase.PARSING_DONE;
        }
    };
    AWDParser.prototype._pStartParsing = function (frameLimit) {
        //create a content object for Loaders
        this._pContent = this._factory.createDisplayObjectContainer();
        _super.prototype._pStartParsing.call(this, frameLimit);
    };
    AWDParser.prototype.dispose = function () {
        for (var c in this._blocks) {
            var b = this._blocks[c];
            b.dispose();
        }
    };
    AWDParser.prototype.parseNextBlock = function () {
        var block;
        var isParsed = false;
        var ns;
        var type;
        var flags;
        var len;
        //*
        if (this._debugTimers)
            this.start_timeing = performance.now();
        //*/
        this._cur_block_id = this._body.readUnsignedInt();
        ns = this._body.readUnsignedByte();
        type = this._body.readUnsignedByte();
        flags = this._body.readUnsignedByte();
        len = this._body.readUnsignedInt();
        var blockCompression = BitFlags.test(flags, BitFlags.FLAG4);
        var blockCompressionLZMA = BitFlags.test(flags, BitFlags.FLAG5);
        if (this._accuracyOnBlocks) {
            this._accuracyMatrix = BitFlags.test(flags, BitFlags.FLAG1);
            this._accuracyGeo = BitFlags.test(flags, BitFlags.FLAG2);
            this._accuracyProps = BitFlags.test(flags, BitFlags.FLAG3);
        }
        var blockEndAll = this._body.position + len;
        if (len > this._body.getBytesAvailable()) {
            this._pDieWithError('AWD2 block length is bigger than the bytes that are available!');
            this._body.position += this._body.getBytesAvailable();
            return;
        }
        //----------------------------------------------------------------------------
        // Compressed AWD Formats not yet supported
        if (blockCompression) {
            this._pDieWithError('Compressed AWD formats not yet supported');
            this._newBlockBytes = new _awayjs_core.ByteArray();
            this._body.readBytes(this._newBlockBytes, 0, len);
            this._newBlockBytes.position = 0;
        }
        else {
            this._newBlockBytes = this._body;
        }
        //----------------------------------------------------------------------------
        // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
        //----------------------------------------------------------------------------
        //this._newBlockBytes.endian = Endian.LITTLE_ENDIAN;
        //----------------------------------------------------------------------------
        block = new AWDBlock(this._cur_block_id, type);
        block.len = len;
        var blockEndBlock = this._newBlockBytes.position + len;
        if (blockCompression) {
            this._pDieWithError('Compressed AWD formats not yet supported');
        }
        if (this._debug)
            console.log("AWDBlock:  ID = " + this._cur_block_id + " | TypeID = " + type + " | Compression = " + blockCompression + " | Matrix-Precision = " + this._accuracyMatrix + " | Graphics-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
        this._blocks[this._cur_block_id] = block;
        if ((this._version[0] == 3) && (this._version[1] == 0)) {
            // probably should contain some info about the type of animation;
            switch (type) {
                case 24:
                    this.parseSpriteLibraryBlock(this._cur_block_id);
                    isParsed = true;
                    break;
                case 25:
                    this.parseBillBoardLibraryBlock(this._cur_block_id);
                    isParsed = true;
                    break;
                case 44:
                    this.parseAudioBlock(this._cur_block_id);
                    isParsed = true;
                    break;
                case 133:
                    this.parseMovieClip(this._cur_block_id);
                    isParsed = true;
                    break;
                case 134:
                    this.parseTextField(this._cur_block_id);
                    isParsed = true;
                    break;
                case 135:
                    this.parseTesselatedFont(this._cur_block_id);
                    isParsed = true;
                    break;
                case 136:
                    this.parseTextFormat(this._cur_block_id);
                    isParsed = true;
                    break;
            }
        }
        if ((this._version[0] > 2) || ((this._version[0] >= 2) && (this._version[1] >= 1))) {
            switch (type) {
                case 11:
                    this.parsePrimitves(this._cur_block_id);
                    isParsed = true;
                    break;
                case 31:
                    this.parseSkyboxInstance(this._cur_block_id);
                    isParsed = true;
                    break;
                case 41:
                    this.parseLight(this._cur_block_id);
                    isParsed = true;
                    break;
                case 42:
                    this.parseCamera(this._cur_block_id);
                    isParsed = true;
                    break;
                //  case 43:
                //      parseTextureProjector(_cur_block_id);
                //      isParsed = true;
                //      break;
                case 51:
                    this.parseLightPicker(this._cur_block_id);
                    isParsed = true;
                    break;
                case 81:
                    this.parseMaterial_v1(this._cur_block_id);
                    isParsed = true;
                    break;
                case 83:
                    this.parseCubeTexture(this._cur_block_id);
                    isParsed = true;
                    break;
                case 91:
                    this.parseSharedMethodBlock(this._cur_block_id);
                    isParsed = true;
                    break;
                case 92:
                    this.parseShadowMethodBlock(this._cur_block_id);
                    isParsed = true;
                    break;
                case 111:
                    this.parseSpritePoseAnimation(this._cur_block_id, true);
                    isParsed = true;
                    break;
                case 112:
                    this.parseSpritePoseAnimation(this._cur_block_id);
                    isParsed = true;
                    break;
                case 113:
                    this.parseVertexAnimationSet(this._cur_block_id);
                    isParsed = true;
                    break;
                case 122:
                    this.parseAnimatorSet(this._cur_block_id);
                    isParsed = true;
                    break;
                case 253:
                    this.parseCommand(this._cur_block_id);
                    isParsed = true;
                    break;
            }
        }
        if (isParsed == false) {
            switch (type) {
                case 1:
                    this.parseGraphics(this._cur_block_id);
                    break;
                case 22:
                    this.parseContainer(this._cur_block_id);
                    break;
                case 23:
                    this.parseSpriteInstance(this._cur_block_id);
                    break;
                case 81:
                    this.parseMaterial(this._cur_block_id);
                    break;
                case 82:
                    this.parseTexture(this._cur_block_id);
                    break;
                case 101:
                    this.parseSkeleton(this._cur_block_id);
                    break;
                case 102:
                    this.parseSkeletonPose(this._cur_block_id);
                    break;
                case 103:
                    this.parseSkeletonAnimation(this._cur_block_id);
                    break;
                case 121:
                //this.parseUVAnimation(this._cur_block_id);
                //break;
                case 254:
                    this.parseNameSpace(this._cur_block_id);
                    break;
                case 255:
                    this.parseMetaData(this._cur_block_id);
                    break;
                default:
                    if (this._debug)
                        console.log("AWDBlock:   Unknown BlockType  (BlockID = " + this._cur_block_id + ") - Skip " + len + " bytes");
                    this._newBlockBytes.position += len;
                    break;
            }
        }
        if (this._debug) {
            if (this._newBlockBytes.position != blockEndBlock)
                console.log("  (!)(!)(!) Error while reading AWDBlock ID " + this._cur_block_id + " = skip to next block");
            if (block.errorMessages) {
                var len = block.errorMessages.length;
                for (var msgCnt = 0; msgCnt < len; msgCnt++)
                    console.log("        (!) Error: " + block.errorMessages[msgCnt] + " (!)");
            }
            console.log("\n");
        }
        if (this._debugTimers && !this.parsingPaused)
            this.updateTimers(type);
        this._body.position = blockEndAll;
        this._newBlockBytes = null;
    };
    AWDParser.prototype.updateTimers = function (type) {
        var end_timing = performance.now();
        var time_delta = end_timing - this.start_timeing;
        this._time_all += time_delta;
        if (type == 1) {
            this._time_graphics += time_delta;
            this._num_graphics++;
        }
        else if (type == 133) {
            this._time_timeline += time_delta;
            this._num_timeline++;
        }
        else if (type == 135) {
            this._time_fonts += time_delta;
            this._num_fonts++;
        }
        else if (type == 134) {
            this._time_textfields += time_delta;
            this._num_textfields++;
        }
        else if (type == 44) {
            this._time_sounds += time_delta;
            this._num_sounds++;
        }
        else if (type == 82) {
            this._time_textures += time_delta;
            this._num_textures++;
        }
        else if (type == 81) {
            this._time_materials += time_delta;
            this._num_materials++;
        }
        else if (type == 24) {
            this._time_sprites += time_delta;
            this._num_sprites++;
        }
    };
    //--Parser Blocks---------------------------------------------------------------------------
    AWDParser.prototype.parseTesselatedFont = function (blockID) {
        var name = this.parseVarStr();
        this._blocks[blockID].name = name;
        var new_font = _awayjs_core.AssetLibrary.getAsset(this._blocks[blockID].name);
        var newfont = false;
        if (new_font == undefined) {
            new_font = new _awayjs_scene.Font();
            newfont = true;
        }
        var font_style_cnt = this._newBlockBytes.readUnsignedInt();
        var font_style_char_cnt;
        var font_style_name;
        var new_font_style;
        var font_style_char;
        var attr_count = 0;
        var sm_len;
        var sm_end;
        var str_ftype, str_type, str_len, str_end;
        for (var i = 0; i < font_style_cnt; ++i) {
            font_style_name = this.parseVarStr();
            // dirty hack for icycle, when using Tessellated fonts (for FNT fonts we do not need this anymore)
            // we use bold chars for non-latin chars, but we use regular for � sign,
            // so the dirty hack is to merge the regular and the bold style
            //if((this._blocks[blockID].name=="Tahoma") && (font_style_name=="RegularStyle")){
            //	font_style_name="BoldStyle";
            //}
            new_font_style = new_font.get_font_table(font_style_name, _awayjs_scene.TesselatedFontTable.assetType);
            new_font_style.set_font_em_size(this._newBlockBytes.readUnsignedInt());
            new_font_style.set_whitespace_width(this._newBlockBytes.readUnsignedInt());
            new_font_style.ascent = this._newBlockBytes.readFloat();
            new_font_style.descent = this._newBlockBytes.readFloat();
            //console.log(new_font_style.get_whitespace_width());
            font_style_char_cnt = this._newBlockBytes.readUnsignedInt();
            for (var j = 0; j < font_style_char_cnt; ++j) {
                // todo: this is basically a simplified version of the elements-parsing done in parseGraphics. Make a parseElements() instead (?)
                font_style_char = this._newBlockBytes.readUnsignedInt();
                var char_width = this._newBlockBytes.readFloat();
                sm_len = this._newBlockBytes.readUnsignedInt();
                sm_end = this._newBlockBytes.position + sm_len;
                // Loop through data streams
                while (this._newBlockBytes.position < sm_end) {
                    // Type, field type, length
                    str_type = this._newBlockBytes.readUnsignedByte();
                    str_ftype = this._newBlockBytes.readUnsignedByte();
                    str_len = this._newBlockBytes.readUnsignedInt();
                    str_end = this._newBlockBytes.position + str_len;
                    /*
                    //todo: right now we only support 2 types of vert data for glyphs (curves vs non-curves)
                    if (str_type == 2) {//face indices positions
                        var indices:Array<number> = new Array<number>();
                        for(var idx:number = 0; this._newBlockBytes.position < str_end; idx++)
                            indices[idx] = this._newBlockBytes.readUnsignedShort();
                    } else if (str_type == 11) {// combined vertex2D stream 5 x float32 (position + curvedata)
                        attr_count = 20;
                        var curveData:ByteArray = new ByteArray(str_len);
                        this._newBlockBytes.readBytes(curveData, 0, str_len);
                    } else if (str_type == 10) {// combined vertex2D stream 7 x float32 (position + curvedata + uv)
                     attr_count = 28;
                     var curveData:ByteArray = new ByteArray(str_len);
                     this._newBlockBytes.readBytes(curveData, 0, str_len);
                     }*/
                    if (str_type == 12) {
                        attr_count = 12;
                        var curveData = new _awayjs_core.ByteArray(str_len);
                        this._newBlockBytes.readBytes(curveData, 0, str_len);
                    }
                    else if (str_type == 16) {
                        attr_count = 8;
                        var curveData = new _awayjs_core.ByteArray(str_len);
                        this._newBlockBytes.readBytes(curveData, 0, str_len);
                    }
                    else {
                        this._newBlockBytes.position = str_end;
                    }
                }
                if (curveData) {
                    var vertexBuffer = new _awayjs_core.AttributesBuffer(attr_count, str_len / attr_count);
                    vertexBuffer.bufferView = new Uint8Array(curveData.arraybytes);
                    //console.log("allchars[cnt1++] = ['"+font_style_char.toString()+"',["+vertexBuffer.bufferView.toString()+"]]");
                    new_font_style.setChar(font_style_char.toString(), char_width, vertexBuffer, null, (attr_count != 8));
                }
            }
        }
        this.parseProperties(null);
        this.parseUserAttributes();
        if (newfont) {
            this._pFinalizeAsset(new_font, name);
        }
        this._blocks[blockID].data = new_font;
        if (this._debug)
            console.log("Parsed a font: Name = '" + name);
    };
    AWDParser.prototype.parseTextFormat = function (blockID) {
        var name = this.parseVarStr();
        this._blocks[blockID].name = name;
        var font = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        var font_style_name = this.parseVarStr();
        var newTextFormat = new _awayjs_scene.TextFormat();
        newTextFormat.font_name = font.name;
        // todo:  atm in awd this will always default to get a TesselatedFontTable. need to find a way to request the correct type here
        var font_table = font.get_font_table(font_style_name);
        if (font_table != null) {
            newTextFormat.font_style = font_style_name;
            newTextFormat.font_table = font_table;
        }
        var mat = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        mat.bothSides = true;
        //mat.curves = true;
        var num_uv_values = this._newBlockBytes.readUnsignedByte();
        var uv_values = [];
        for (var uvcnt = 0; uvcnt < num_uv_values; uvcnt++)
            uv_values[uvcnt] = this._newBlockBytes.readFloat();
        newTextFormat.uv_values = uv_values;
        var format_props = this.parseProperties(AWDParser.textFormatProperties);
        newTextFormat.size = format_props.get(1, 12);
        newTextFormat.letterSpacing = format_props.get(2, 0);
        //newTextFormat.rotated = format_props.get(3,false);
        newTextFormat.kerning = format_props.get(4, true);
        //newTextFormat.baseline_shift = format_props.get(5,1);
        var tf_align_int = format_props.get(6, 0);
        if (tf_align_int == 1) {
            newTextFormat.align = "right";
        }
        else if (tf_align_int == 2) {
            newTextFormat.align = "center";
        }
        else if (tf_align_int == 3) {
            newTextFormat.align = "justify";
        }
        newTextFormat.indent = format_props.get(7, 0);
        newTextFormat.leftMargin = format_props.get(8, 0);
        newTextFormat.rightMargin = format_props.get(9, 0);
        newTextFormat.leading = format_props.get(10, 0);
        newTextFormat.color = format_props.get(11, 0);
        newTextFormat.material = mat;
        this.parseUserAttributes(); // textformat has no extra-properties
        //newTextFormat.extra =
        this._pFinalizeAsset(newTextFormat, name);
        this._blocks[blockID].data = newTextFormat;
        if (this._debug)
            console.log("Parsed a TextFormat: Name = '" + name + " font: " + font.name);
    };
    AWDParser.prototype.parseTextField = function (blockID) {
        var name = this.parseVarStr();
        this._blocks[blockID].name = name;
        var newTextField = this._factory.createTextField();
        var text_field_type = this._newBlockBytes.readUnsignedByte();
        newTextField.type = AWDParser.textFieldTypes[text_field_type];
        if (text_field_type == 3)
            newTextField.displayAsPassword = true;
        //
        newTextField.width = Math.abs(this._newBlockBytes.readFloat());
        newTextField.height = Math.abs(this._newBlockBytes.readFloat());
        var num_paragraphs = this._newBlockBytes.readUnsignedInt();
        var complete_text = "";
        //console.log("num_paragraphs  '" + num_paragraphs);
        for (var paracnt = 0; paracnt < num_paragraphs; paracnt++) {
            var num_textruns = this._newBlockBytes.readUnsignedInt();
            //console.log("num_textruns  '" + num_textruns);
            for (var textrun_cnt = 0; textrun_cnt < num_textruns; textrun_cnt++) {
                var text_format = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
                var txt_length = this._newBlockBytes.readUnsignedInt();
                //console.log("txt_length  '" + txt_length);
                if (txt_length > 0) {
                    var this_txt = this._newBlockBytes.readUTFBytes(txt_length);
                    //newTextField.appendText(this_txt, text_format);
                    complete_text += this_txt;
                }
            }
        }
        newTextField.textFormat = text_format;
        newTextField.text = complete_text;
        //newTextField.construct_graphics();
        // todo: optional matrix etc can be put in properties.
        var props = this.parseProperties(AWDParser.textFieldProperties);
        newTextField.selectable = props.get(1, false);
        newTextField.border = props.get(3, false);
        //newTextField.renderHTML =  props.get(4, false);
        //newTextField.scrollable =  props.get(5, false);
        //newTextField.text_flow =  props.get(7, 0);
        //newTextField.orientationMode =  props.get(8, 0);
        //newTextField.line_mode =  props.get(9, 0);
        newTextField.extra = this.parseUserAttributes();
        //console.log("Parsed a TextField: Name = '" + name + "| text  = " + complete_text);
        this._pFinalizeAsset(newTextField, name);
        this._blocks[blockID].data = newTextField;
        if (this._debug)
            console.log("Parsed a TextField: Name = '" + name + "| text  = " + complete_text);
    };
    // Block ID = 25
    AWDParser.prototype.parseBillBoardLibraryBlock = function (blockID) {
        var name = this.parseVarStr();
        var mat = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        mat.bothSides = true;
        var billboard = this._factory.createBillboard(mat);
        // todo: optional matrix etc can be put in properties.
        this.parseProperties(null);
        billboard.extra = this.parseUserAttributes();
        this._pFinalizeAsset(billboard, name);
        this._blocks[blockID].data = billboard;
        if (this._debug)
            console.log("Parsed a Library-Billboard: Name = '" + name + "| Material-Name = " + mat.name);
    };
    // Block ID = 24
    AWDParser.prototype.parseSpriteLibraryBlock = function (blockID) {
        var name = this.parseVarStr();
        var data_id = this._newBlockBytes.readUnsignedInt();
        var graphics = this._blocks[data_id].data;
        this._blocks[blockID].geoID = data_id;
        var num_materials = this._newBlockBytes.readUnsignedShort();
        var materials = new Array();
        var materialNames = new Array();
        var mat;
        for (var materials_parsed = 0; materials_parsed < num_materials; materials_parsed++) {
            mat = (this._blocks[this._newBlockBytes.readUnsignedInt()].data || _awayjs_graphics.DefaultMaterialManager.getDefaultMaterial());
            //mat.preserveAlpha = true;
            //mat.alphaBlending = true;
            mat.useColorTransform = true;
            materials[materials_parsed] = mat;
            materialNames[materials_parsed] = mat.name;
        }
        var start_timeing = performance.now();
        var sprite = this._factory.createSprite();
        sprite.mouseEnabled = false;
        graphics.copyTo(sprite.graphics);
        var end_timing = performance.now();
        var time_delta = end_timing - start_timeing;
        this._time_graphics_bytes += time_delta;
        if (materials.length >= 1 && sprite.graphics.count == 1) {
            sprite.material = materials[0];
        }
        else if (materials.length >= 1) {
            // Assign each sub-sprite in the sprite a material from the list. If more sub-sprites
            // than materials, repeat the last material for all remaining sub-sprites.
            for (var i = 0; i < sprite.graphics.count; i++) {
                if (!sprite.graphics.getShapeAt(i).isStroke) {
                    sprite.graphics.getShapeAt(i).material = materials[Math.min(materials.length - 1, i)];
                }
            }
        }
        var sampler;
        var shape;
        var material;
        var count = this._newBlockBytes.readUnsignedShort();
        //if(count != sprite.graphics.count)
        //	throw new Error("num elements does not match num subsprites";
        for (var i = 0; i < count; i++) {
            var type = this._newBlockBytes.readUnsignedByte();
            sampler = new _awayjs_graphics.Sampler2D();
            shape = sprite.graphics.getShapeAt(i);
            material = shape.material || sprite.material;
            if (!material) {
                shape = null;
            }
            if (shape) {
                shape.style = new _awayjs_graphics.Style();
                shape.style.addSamplerAt(sampler, material.getTextureAt(0));
            }
            if (type == 3) {
                var tx = this._newBlockBytes.readFloat();
                var ty = this._newBlockBytes.readFloat();
                if (shape) {
                    material.animateUVs = true;
                    shape.style.uvMatrix = new _awayjs_core.Matrix(0, 0, 0, 0, tx, ty);
                }
            }
            else if (type == 4) {
                var matrix = this.parseMatrix32RawData();
                if (shape) {
                    material.animateUVs = true;
                    shape.style.uvMatrix = new _awayjs_core.Matrix(matrix);
                }
            }
            else if (type == 5) {
                var newMatrix = new _awayjs_core.Matrix(this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat(), 0, 0, this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat());
                if (shape) {
                    material.animateUVs = true;
                    shape.style.uvMatrix = newMatrix;
                }
            }
            else if (type == 6) {
                var x = this._newBlockBytes.readFloat();
                var y = this._newBlockBytes.readFloat();
                var width = this._newBlockBytes.readFloat();
                var height = this._newBlockBytes.readFloat();
                var matrix = this.parseMatrix32RawData();
                if (shape) {
                    sampler.imageRect = new _awayjs_core.Rectangle(x, y, width, height);
                    material.imageRect = true;
                    material.animateUVs = true;
                    shape.style.uvMatrix = new _awayjs_core.Matrix(matrix);
                }
            }
            if (shape) {
                //check if curves are needed
                if (shape.elements.getCustomAtributes("curves"))
                    material.curves = true;
            }
            // todo: finish optional properties (spreadmode + focalpoint)
            this._newBlockBytes.readUnsignedInt();
        }
        var props = this.parseProperties(AWDParser.spriteLibraryProperties);
        sprite.registrationPoint = new _awayjs_core.Vector3D(props.get(1, 0.0), props.get(2, 0.0), 0.0);
        sprite.registrationScale = new _awayjs_core.Vector3D(props.get(3, 1.0), props.get(4, 1.0), 1.0);
        sprite.extra = this.parseUserAttributes();
        this._pFinalizeAsset(sprite, name);
        this._blocks[blockID].data = sprite;
        if (this._debug)
            console.log("Parsed a Library-Sprite: Name = '" + name + "| Graphics-Name = " + graphics.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
    };
    AWDParser.prototype.parseAudioBlock = function (blockID) {
        //var asset:Audio;todo create asset for audio
        this._blocks[blockID].name = this.parseVarStr();
        var type = this._newBlockBytes.readUnsignedByte();
        var data_len;
        // External
        if (type == 0) {
            data_len = this._newBlockBytes.readUnsignedInt();
            var url;
            url = this._newBlockBytes.readUTFBytes(data_len);
            // todo parser needs to be able to handle mp3 and wav files if we trigger the loading of external ressource
            this._pAddDependency(this._cur_block_id.toString(), new _awayjs_core.URLRequest(url), null, null, false, true);
        }
        else {
            // todo: exporter does not export embed sounds yet
            data_len = this._newBlockBytes.readUnsignedInt();
            var data = new _awayjs_core.ByteArray(data_len);
            this._newBlockBytes.readBytes(data, 0, data_len);
            // todo parse sound from bytes
            // this._pAddDependency(this._cur_block_id.toString(), null, false, ParserUtils.by(data), true);
            this._pAddDependency(this._cur_block_id.toString(), null, null, data, false, true);
        }
        // Ignore for now
        this.parseProperties(null);
        this._blocks[blockID].extras = this.parseUserAttributes();
        this._pPauseAndRetrieveDependencies();
        //this._blocks[blockID].data = asset;todo
        if (this._debug)
            console.log("Start parsing a " + ["external", "embed"][type] + " Audio file");
    };
    //Block ID = 4
    AWDParser.prototype.parseMovieClip = function (blockID) {
        var i;
        var j;
        var cmd_asset;
        var new_timeline = new _awayjs_scene.Timeline();
        var new_mc = this._factory.createMovieClip(new_timeline);
        var name = this.parseVarStr();
        // register list of potential childs
        // a potential child can be reused on a timeline (added / removed / added)
        // However, for each potential child, we need to register the max-number of instances that a frame contains
        // we parse 2 lists of potential-childs:
        // -	the first list contains potential-childs that are only ever instanced once per frame.
        // -	the second list contains potential-childs that are instanced multiple times on some frames.
        // on registering a child, the child gets a incremental-id assigned. This is the id, that the commands are using to access the childs.
        // hence we need to be careful to register all objects in correct order.
        var num_potential_childs = this._newBlockBytes.readUnsignedShort();
        for (i = 0; i < num_potential_childs; i++) {
            cmd_asset = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
            if (cmd_asset != null) {
                new_timeline.registerPotentialChild(cmd_asset);
            }
            else {
                //todo: register a default display object on timeline, so we do not mess up the incremental obj-id
                //new_mc.registerPotentialChild(cmd_asset);
                console.log("ERROR when collecting objects for timeline");
            }
        }
        var num_all_display_instances = num_potential_childs;
        var num_potential_childs_multi_instanced = this._newBlockBytes.readUnsignedShort();
        for (i = 0; i < num_potential_childs_multi_instanced; i++) {
            cmd_asset = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
            var num_instances = this._newBlockBytes.readUnsignedShort();
            num_all_display_instances += num_instances;
            if (cmd_asset != null) {
                for (j = 0; j < num_instances; j++)
                    new_timeline.registerPotentialChild(cmd_asset);
            }
            else {
                for (j = 0; j < num_instances; j++) {
                    //todo: register a default display object on timeline, so we do not mess up the incremental obj-id
                    //new_mc.registerPotentialChild(cmd_asset);
                    console.log("ERROR when collecting objects for timeline");
                }
            }
        }
        if (this._debug)
            console.log("Parsed " + (num_potential_childs + num_potential_childs_multi_instanced) + " potential childs. They will be used by " + num_all_display_instances + " instances.");
        // register list of potential sounds - for now we always have 0 sounds
        var num_potential_sounds = this._newBlockBytes.readUnsignedShort();
        var str_cnt = this._newBlockBytes.readUnsignedByte();
        var str_len = 0;
        var str_data_type = 0;
        var str_type = 0;
        var str_counter = 0;
        for (i = 0; i < str_cnt; i++) {
            // the first 6 lists are not optional and always in same order
            // hence we can get type by incremental counter instead of stored uint8
            if (str_counter < 6)
                str_type = str_counter;
            else
                str_type = this._newBlockBytes.readUnsignedByte();
            // get the data type for this stream (1:UINT8 - 2:UINT16 - 3:UINT32)
            str_data_type = this._newBlockBytes.readUnsignedByte();
            // size of this stream in byte
            str_len = this._newBlockBytes.readUnsignedInt();
            if (str_len > 0) {
                var keyframes_start_indices_data = new _awayjs_core.ByteArray(str_len);
                this._newBlockBytes.readBytes(keyframes_start_indices_data, 0, str_len);
                var new_buffer;
                //console.log("str_data_type = "+str_type);
                switch (str_data_type) {
                    case 1:
                        new_buffer = new Uint8Array(keyframes_start_indices_data.arraybytes);
                        break;
                    case 2:
                        new_buffer = new Uint16Array(keyframes_start_indices_data.arraybytes);
                        break;
                    case 4:
                        new_buffer = new Uint32Array(keyframes_start_indices_data.arraybytes);
                        break;
                }
                switch (str_type) {
                    case 0:
                        new_timeline.keyframe_durations = new_buffer;
                        new_timeline.numKeyFrames = str_len / str_data_type;
                        break;
                    case 1:
                        new_timeline.frame_command_indices = new_buffer;
                        break;
                    case 2:
                        new_timeline.frame_recipe = new_buffer;
                        break;
                    case 3:
                        new_timeline.command_length_stream = new_buffer;
                        break;
                    case 4:
                        new_timeline.command_index_stream = new_buffer;
                        break;
                    case 5:
                        new_timeline.add_child_stream = new_buffer;
                        break;
                    case 6:
                        new_timeline.remove_child_stream = new_buffer;
                        break;
                    case 7:
                        new_timeline.update_child_stream = new_buffer;
                        break;
                    case 8:
                        new_timeline.update_child_props_indices_stream = new_buffer;
                        break;
                    case 9:
                        new_timeline.update_child_props_length_stream = new_buffer;
                        break;
                    case 10:
                        new_timeline.property_type_stream = new_buffer;
                        break;
                    case 11:
                        new_timeline.property_index_stream = new_buffer;
                        break;
                    case 12:
                        new_timeline.properties_stream_int = new_buffer;
                        break;
                }
            }
            str_counter++;
        }
        var lc = 0;
        var float_array_data;
        str_cnt = this._newBlockBytes.readUnsignedByte();
        for (i = 0; i < str_cnt; i++) {
            str_type = this._newBlockBytes.readUnsignedByte();
            str_len = this._newBlockBytes.readUnsignedInt();
            switch (str_type) {
                case 0:
                    float_array_data = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
                    new_timeline.properties_stream_f32_mtx_scale_rot = new Float32Array(float_array_data.arraybytes);
                    break;
                case 1:
                    float_array_data = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
                    new_timeline.properties_stream_f32_mtx_pos = new Float32Array(float_array_data.arraybytes);
                    break;
                case 2:
                    float_array_data = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
                    new_timeline.properties_stream_f32_mtx_all = new Float32Array(float_array_data.arraybytes);
                    break;
                case 3:
                    float_array_data = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(float_array_data, 0, str_len);
                    new_timeline.properties_stream_f32_ct = new Float32Array(float_array_data.arraybytes);
                    break;
                case 4:
                    str_len = this._newBlockBytes.readUnsignedShort();
                    //console.log("start reading labels "+str_len);
                    for (lc = 0; lc < str_len; lc++) {
                        new_timeline._labels[this.parseVarStr()] = this._newBlockBytes.readUnsignedShort();
                    }
                    break;
                case 5:
                    str_len = this._newBlockBytes.readUnsignedShort();
                    var string_props_array = [];
                    for (lc = 0; lc < str_len; lc++) {
                        string_props_array.push(this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedShort()));
                    }
                    new_timeline.properties_stream_strings = string_props_array;
                    break;
                case 6:
                    str_len = this._newBlockBytes.readUnsignedShort();
                    for (lc = 0; lc < str_len; lc++) {
                        var frame_index = this._newBlockBytes.readUnsignedShort();
                        var one_str_len = this._newBlockBytes.readUnsignedInt();
                        //this._newBlockBytes.readUTFBytes(one_str_len);
                        new_timeline.add_framescript(this._newBlockBytes.readUTFBytes(one_str_len), frame_index);
                    }
                    break;
            }
        }
        new_timeline.init();
        var sceneID = 0;
        var fps = 25;
        var props = this.parseProperties(AWDParser.movieClipProperties);
        new_mc.isSlice9ScaledMC = props.get(4, false);
        this.parseUserAttributes();
        this._pFinalizeAsset(new_mc, name);
        this._blocks[blockID].data = new_mc;
        if (this._debug)
            console.log("Parsed a TIMELINE: Name = " + name + "| sceneID = " + sceneID + "| numFrames = " + new_mc.timeline.numFrames);
    };
    //Block ID = 1
    AWDParser.prototype.parseGraphics = function (blockID) {
        var graphics = new _awayjs_graphics.Graphics();
        // Read name and sub count
        var name = this.parseVarStr();
        var numElements = this._newBlockBytes.readUnsignedShort();
        // Read optional properties
        var props = this.parseProperties(AWDParser.graphicsProperties);
        var geoScaleU = props.get(1, 1);
        var geoScaleV = props.get(2, 1);
        var target_start_idx = 0;
        var target_vert_cnt = 0;
        var element_type = ElementType.STANDART_STREAMS;
        var target_element = null;
        // Loop through sub sprites
        target_element = null;
        for (var elements_parsed = 0; elements_parsed < numElements; elements_parsed++) {
            var attr_count = 0;
            var sm_len, sm_end;
            var w_indices;
            var weights;
            var slice9Indices;
            target_start_idx = 0;
            target_vert_cnt = 0;
            element_type = ElementType.STANDART_STREAMS;
            sm_len = this._newBlockBytes.readUnsignedInt();
            sm_end = this._newBlockBytes.position + sm_len;
            var elementsProps = this.parseProperties(AWDParser.elementsProperties);
            // Loop through data streams
            while (this._newBlockBytes.position < sm_end) {
                var idx = 0;
                var str_ftype, str_type, str_len, str_end;
                // Type, field type, length
                str_type = this._newBlockBytes.readUnsignedByte();
                str_ftype = this._newBlockBytes.readUnsignedByte();
                str_len = this._newBlockBytes.readUnsignedInt();
                str_end = this._newBlockBytes.position + str_len;
                var x, y, z;
                if (str_type == 1) {
                    var verts = [];
                    while (this._newBlockBytes.position < str_end) {
                        x = this.readNumber(this._accuracyGeo);
                        y = this.readNumber(this._accuracyGeo);
                        z = this.readNumber(this._accuracyGeo);
                        verts[idx++] = x;
                        verts[idx++] = y;
                        verts[idx++] = z;
                    }
                }
                else if (str_type == 2) {
                    var indices = [];
                    while (this._newBlockBytes.position < str_end)
                        indices[idx++] = this._newBlockBytes.readUnsignedShort();
                }
                else if (str_type == 3) {
                    var uvs = [];
                    while (this._newBlockBytes.position < str_end)
                        uvs[idx++] = this.readNumber(this._accuracyGeo);
                }
                else if (str_type == 4) {
                    var normals = [];
                    while (this._newBlockBytes.position < str_end)
                        normals[idx++] = this.readNumber(this._accuracyGeo);
                }
                else if (str_type == 6) {
                    w_indices = Array();
                    while (this._newBlockBytes.position < str_end)
                        w_indices[idx++] = this._newBlockBytes.readUnsignedShort() * 3;
                }
                else if (str_type == 7) {
                    weights = [];
                    while (this._newBlockBytes.position < str_end)
                        weights[idx++] = this.readNumber(this._accuracyGeo);
                }
                else if (str_type == 8) {
                    this._newBlockBytes.position = str_end;
                }
                else if (str_type == 9) {
                    this._newBlockBytes.position = str_end;
                }
                else if (str_type == 10) {
                    element_type = ElementType.CONCENATED_STREAMS;
                    attr_count = 28;
                    var curveData = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(curveData, 0, str_len);
                }
                else if (str_type == 11) {
                    element_type = ElementType.CONCENATED_STREAMS;
                    attr_count = 20;
                    var curveData = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(curveData, 0, str_len);
                }
                else if (str_type == 12) {
                    element_type = ElementType.CONCENATED_STREAMS;
                    attr_count = 12;
                    var curveData = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(curveData, 0, str_len);
                }
                else if (str_type == 13) {
                    element_type = ElementType.SHARED_BUFFER;
                    var targetGraphic = (this._blocks[this._newBlockBytes.readUnsignedInt()].data);
                    var element_idx = this._newBlockBytes.readUnsignedByte();
                    target_element = targetGraphic.getShapeAt(element_idx).elements;
                    target_start_idx = this._newBlockBytes.readUnsignedInt();
                    target_vert_cnt = this._newBlockBytes.readUnsignedInt();
                }
                else if (str_type == 14) {
                    element_type = ElementType.CONCATENATED_SUBGEO;
                    //var verts:Array<number> = [];
                    attr_count = 8;
                    var vertData = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(vertData, 0, str_len);
                }
                else if (str_type == 15) {
                    element_type = ElementType.SHARED_INDEXBUFFER;
                    target_start_idx = this._newBlockBytes.readUnsignedInt();
                    target_vert_cnt = this._newBlockBytes.readUnsignedInt();
                }
                else if (str_type == 16) {
                    element_type = ElementType.CONCENATED_STREAMS;
                    attr_count = 8;
                    var curveData = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(curveData, 0, str_len);
                }
                else if (str_type == 17) {
                    element_type = ElementType.CONCENATED_STREAMS_UINT16;
                    attr_count = 4;
                    var curveData = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(curveData, 0, str_len);
                }
                else if (str_type == 18) {
                    element_type = ElementType.CONCENATED_STREAMS_UINT16;
                    attr_count = 8;
                    var curveData = new _awayjs_core.ByteArray(str_len);
                    this._newBlockBytes.readBytes(curveData, 0, str_len);
                }
                else if (str_type == 23) {
                    slice9Indices = [];
                    var cnt = 0;
                    var cnt2 = 0;
                    graphics.slice9Rectangle = new _awayjs_core.Rectangle();
                    graphics.originalSlice9Size = new _awayjs_core.Rectangle();
                    while (this._newBlockBytes.position < str_end) {
                        if (cnt == 0)
                            graphics.slice9Rectangle.x = (this._newBlockBytes.readInt() / 20);
                        else if (cnt == 1)
                            graphics.slice9Rectangle.y = (this._newBlockBytes.readInt() / 20);
                        else if (cnt == 2)
                            graphics.slice9Rectangle.width = (this._newBlockBytes.readInt() / 20);
                        else if (cnt == 3)
                            graphics.slice9Rectangle.height = (this._newBlockBytes.readInt() / 20);
                        else if (cnt == 4)
                            graphics.originalSlice9Size.x = (this._newBlockBytes.readInt() / 20);
                        else if (cnt == 5)
                            graphics.originalSlice9Size.y = (this._newBlockBytes.readInt() / 20);
                        else if (cnt == 6)
                            graphics.originalSlice9Size.width = (this._newBlockBytes.readInt() / 20);
                        else if (cnt == 7)
                            graphics.originalSlice9Size.height = (this._newBlockBytes.readInt() / 20);
                        else
                            slice9Indices[cnt2++] = this._newBlockBytes.readInt();
                        cnt++;
                    }
                }
                else if (str_type == 24) {
                    element_type = ElementType.STROKE_DATA;
                    // todo: store the lineStyle as optional props on subgeom-properties ?
                    var color = this._newBlockBytes.readInt();
                    var thickness = this._newBlockBytes.readFloat();
                    var capStyle = this._newBlockBytes.readUnsignedByte(); //todo
                    var jointStyle = this._newBlockBytes.readUnsignedByte(); //todo
                    var mitter = this._newBlockBytes.readFloat(); //todo
                    graphics.lineStyle(thickness, color);
                    var seg_type;
                    while (this._newBlockBytes.position < str_end) {
                        seg_type = this._newBlockBytes.readFloat();
                        if (seg_type == 1.0) {
                            graphics.moveTo(this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat());
                        }
                        else if (seg_type == 2.0) {
                            graphics.lineTo(this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat());
                        }
                        else if (seg_type == 3.0) {
                            graphics.curveTo(this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat(), this._newBlockBytes.readFloat());
                        }
                    }
                    graphics.endFill();
                    graphics.scaleStrokes = _awayjs_graphics.LineScaleMode.NONE;
                }
                else {
                    console.log("skipping unknown subgeom stream");
                    this._newBlockBytes.position = str_end;
                }
            }
            this.parseUserAttributes(); // Ignore sub-sprite attributes for now
            if (element_type == ElementType.CONCENATED_STREAMS) {
                //console.log("str_len/attr_count = "+str_len/attr_count)
                var vertexBuffer = new _awayjs_core.AttributesBuffer(attr_count, str_len / attr_count);
                vertexBuffer.bufferView = new Uint8Array(curveData.arraybytes);
                var curve_elements = new _awayjs_graphics.TriangleElements(vertexBuffer);
                if (graphics.slice9Rectangle) {
                    curve_elements.slice9Indices = slice9Indices;
                    curve_elements.slice9offsets = new _awayjs_core.Rectangle();
                    curve_elements.slice9offsets.copyFrom(graphics.slice9Rectangle);
                    curve_elements.originalSlice9Size = new _awayjs_core.Rectangle();
                    curve_elements.originalSlice9Size.copyFrom(graphics.originalSlice9Size);
                    graphics.slice9Rectangle.copyFrom(graphics.originalSlice9Size);
                    curve_elements.setPositions(new _awayjs_core.Float2Attributes(vertexBuffer));
                    _awayjs_graphics.ElementsUtils.updateTriangleGraphicsSlice9(curve_elements, curve_elements.originalSlice9Size, 1, 1, true);
                }
                else {
                    curve_elements.setPositions(new _awayjs_core.Float2Attributes(vertexBuffer));
                    if (attr_count == 20) {
                        curve_elements.setCustomAttributes("curves", new _awayjs_core.Float3Attributes(vertexBuffer));
                    }
                    else if (attr_count == 12) {
                        curve_elements.setCustomAttributes("curves", new _awayjs_core.Byte4Attributes(vertexBuffer, false));
                    }
                    if (attr_count == 28)
                        curve_elements.setUVs(new _awayjs_core.Float2Attributes(vertexBuffer));
                }
                graphics.addShape(new _awayjs_graphics.Shape(curve_elements));
                if (this._debug)
                    console.log("Parsed a TriangleElements with curves");
            }
            else if (element_type == ElementType.CONCENATED_STREAMS_UINT16) {
                var vertexBuffer = new _awayjs_core.AttributesBuffer(attr_count, str_len / attr_count);
                vertexBuffer.bufferView = new Uint8Array(curveData.arraybytes);
                var curve_elements = new _awayjs_graphics.TriangleElements(vertexBuffer);
                curve_elements.setPositions(new _awayjs_core.Short2Attributes(vertexBuffer, true));
                if (attr_count == 8) {
                    curve_elements.setCustomAttributes("curves", new _awayjs_core.Byte4Attributes(vertexBuffer, false));
                }
                graphics.addShape(new _awayjs_graphics.Shape(curve_elements));
                if (this._debug)
                    console.log("Parsed a TriangleElements uint16");
            }
            else if (element_type == ElementType.STANDART_STREAMS) {
                var triangle_elements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
                if (weights)
                    triangle_elements.jointsPerVertex = weights.length / (verts.length / 3);
                if (normals)
                    triangle_elements.autoDeriveNormals = false;
                triangle_elements.autoDeriveTangents = true;
                triangle_elements.setIndices(indices);
                triangle_elements.setPositions(verts);
                triangle_elements.setNormals(normals);
                triangle_elements.setUVs(uvs);
                triangle_elements.setJointWeights(weights);
                triangle_elements.setJointIndices(w_indices);
                var scaleU = elementsProps.get(1, 1);
                var scaleV = elementsProps.get(2, 1);
                var setSubUVs = false; //this should remain false atm, because in AwayBuilder the uv is only scaled by the graphics
                if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
                    setSubUVs = true;
                    scaleU = geoScaleU / scaleU;
                    scaleV = geoScaleV / scaleV;
                }
                if (setSubUVs)
                    triangle_elements.scaleUV(scaleU, scaleV);
                graphics.addShape(new _awayjs_graphics.Shape(triangle_elements));
                if (this._debug)
                    console.log("Parsed a TriangleElements");
            }
            else if (element_type == ElementType.CONCATENATED_SUBGEO) {
                var vertexBuffer = new _awayjs_core.AttributesBuffer(attr_count, str_len / attr_count);
                vertexBuffer.bufferView = new Uint8Array(vertData.arraybytes);
                var triangle_elements = new _awayjs_graphics.TriangleElements(vertexBuffer);
                triangle_elements.setPositions(new _awayjs_core.Float2Attributes(vertexBuffer));
                //if (weights)
                //	triangle_elements.jointsPerVertex = weights.length / (verts.length / 3);
                //if (normals)
                //	triangle_elements.autoDeriveNormals = false;
                //triangle_elements.autoDeriveTangents = true;
                triangle_elements.setIndices(indices);
                //triangle_elements.setPositions(verts);
                //triangle_elements.setNormals(normals);
                //triangle_elements.setUVs(uvs);
                //triangle_elements.setJointWeights(weights);
                //triangle_elements.setJointIndices(w_indices);
                var scaleU = elementsProps.get(1, 1);
                var scaleV = elementsProps.get(2, 1);
                var setSubUVs = false; //this should remain false atm, because in AwayBuilder the uv is only scaled by the graphics
                if ((geoScaleU != scaleU) || (geoScaleV != scaleV)) {
                    setSubUVs = true;
                    scaleU = geoScaleU / scaleU;
                    scaleV = geoScaleV / scaleV;
                }
                if (setSubUVs)
                    triangle_elements.scaleUV(scaleU, scaleV);
                target_element = triangle_elements;
            }
            else if (element_type == ElementType.SHARED_INDEXBUFFER) {
                var shape = graphics.addShape(new _awayjs_graphics.Shape(target_element));
                shape.offset = target_start_idx / 3; //todo: move this calc to exporter
                shape.count = target_vert_cnt / 3; //todo: move this calc to exporter
            }
            else if (element_type == ElementType.SHARED_BUFFER) {
                var shape = graphics.addShape(new _awayjs_graphics.Shape(target_element));
                shape.offset = target_start_idx;
                shape.count = target_vert_cnt;
                if (this._debug)
                    console.log("Parsed a TriangleElements that shares index buffer from target geom");
            }
        }
        if ((geoScaleU != 1) || (geoScaleV != 1))
            graphics.scaleUV(geoScaleU, geoScaleV);
        this.parseUserAttributes();
        this._pFinalizeAsset(graphics, name);
        this._blocks[blockID].data = graphics;
        if (this._debug)
            console.log("Parsed Graphics: Name = " + name);
    };
    //Block ID = 11
    AWDParser.prototype.parsePrimitves = function (blockID) {
        var name;
        var prefab;
        var primType;
        var elements_parsed;
        var props;
        var bsm;
        // Read name and sub count
        name = this.parseVarStr();
        primType = this._newBlockBytes.readUnsignedByte();
        props = this.parseProperties(AWDParser.primitiveProperties);
        // to do, not all properties are set on all primitives
        switch (primType) {
            case 1:
                prefab = new _awayjs_scene.PrimitivePlanePrefab(null, _awayjs_graphics.ElementsType.TRIANGLE, props.get(101, 100), props.get(102, 100), props.get(301, 1), props.get(302, 1), props.get(701, true), props.get(702, false));
                break;
            case 2:
                prefab = new _awayjs_scene.PrimitiveCubePrefab(null, _awayjs_graphics.ElementsType.TRIANGLE, props.get(101, 100), props.get(102, 100), props.get(103, 100), props.get(301, 1), props.get(302, 1), props.get(303, 1), props.get(701, true));
                break;
            case 3:
                prefab = new _awayjs_scene.PrimitiveSpherePrefab(null, _awayjs_graphics.ElementsType.TRIANGLE, props.get(101, 50), props.get(301, 16), props.get(302, 12), props.get(701, true));
                break;
            case 4:
                prefab = new _awayjs_scene.PrimitiveCylinderPrefab(null, _awayjs_graphics.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 50), props.get(103, 100), props.get(301, 16), props.get(302, 1), true, true, true); // bool701, bool702, bool703, bool704);
                if (!props.get(701, true))
                    prefab.topClosed = false;
                if (!props.get(702, true))
                    prefab.bottomClosed = false;
                if (!props.get(703, true))
                    prefab.yUp = false;
                break;
            case 5:
                prefab = new _awayjs_scene.PrimitiveConePrefab(null, _awayjs_graphics.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 1), props.get(701, true), props.get(702, true));
                break;
            case 6:
                prefab = new _awayjs_scene.PrimitiveCapsulePrefab(null, _awayjs_graphics.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 100), props.get(301, 16), props.get(302, 15), props.get(701, true));
                break;
            case 7:
                prefab = new _awayjs_scene.PrimitiveTorusPrefab(null, _awayjs_graphics.ElementsType.TRIANGLE, props.get(101, 50), props.get(102, 50), props.get(301, 16), props.get(302, 8), props.get(701, true));
                break;
            default:
                prefab = new _awayjs_scene.PrefabBase();
                console.log("ERROR: UNSUPPORTED PREFAB_TYPE");
                break;
        }
        if ((props.get(110, 1) != 1) || (props.get(111, 1) != 1)) {
        }
        this.parseUserAttributes();
        prefab.name = name;
        this._pFinalizeAsset(prefab, name);
        this._blocks[blockID].data = prefab;
        if (this._debug) {
            if ((primType < 0) || (primType > 7))
                primType = 0;
            console.log("Parsed a Primivite: Name = " + name + "| type = " + AWDParser.primitiveTypes[primType]);
        }
    };
    // Block ID = 22
    AWDParser.prototype.parseContainer = function (blockID) {
        var name;
        var mtx;
        var ctr;
        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        mtx = this.parseMatrix3D();
        name = this.parseVarStr();
        var parentName = "Root (TopLevel)";
        ctr = this._factory.createDisplayObjectContainer();
        ctr.transform.matrix3D = mtx;
        if (parent) {
            parent.addChild(ctr);
            parentName = parent.name;
        }
        else {
            //add to the content property
            this._pContent.addChild(ctr);
        }
        // in AWD version 2.1 we read the Container properties
        if ((this._version[0] == 2) && (this._version[1] == 1)) {
            var props = this.parseProperties(AWDParser.containerProperties);
            ctr.registrationPoint = new _awayjs_core.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
        }
        else {
            this.parseProperties(null);
        }
        // the extraProperties should only be set for AWD2.1-Files, but is read for both versions
        ctr.extra = this.parseUserAttributes();
        this._pFinalizeAsset(ctr, name);
        this._blocks[blockID].data = ctr;
        if (this._debug)
            console.log("Parsed a Container: Name = '" + name + "' | Parent-Name = " + parentName);
    };
    // Block ID = 23
    AWDParser.prototype.parseSpriteInstance = function (blockID) {
        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        var mtx = this.parseMatrix3D();
        var name = this.parseVarStr();
        var data_id = this._newBlockBytes.readUnsignedInt();
        var asset = this._blocks[data_id].data;
        var graphics;
        var prefab;
        var isPrefab = false;
        if (asset.isAsset(_awayjs_graphics.Graphics)) {
            graphics = asset;
        }
        else {
            isPrefab = true;
            prefab = asset;
        }
        this._blocks[blockID].geoID = data_id;
        var num_materials = this._newBlockBytes.readUnsignedShort();
        var materials = new Array();
        var materialNames = new Array();
        var mat;
        for (var materials_parsed = 0; materials_parsed < num_materials; materials_parsed++) {
            mat = (this._blocks[this._newBlockBytes.readUnsignedInt()].data || _awayjs_graphics.DefaultMaterialManager.getDefaultMaterial());
            materials[materials_parsed] = mat;
            materialNames[materials_parsed] = mat.name;
        }
        var sprite;
        if (isPrefab) {
            sprite = this._factory.createSprite(prefab);
        }
        else {
            sprite = this._factory.createSprite();
            graphics.copyTo(sprite.graphics);
        }
        sprite.transform.matrix3D = mtx;
        var parentName = "Root (TopLevel)";
        if (parent) {
            parent.addChild(sprite);
            parentName = parent.name;
        }
        else {
            //add to the content property
            this._pContent.addChild(sprite);
        }
        if (materials.length >= 1 && sprite.graphics.count == 1) {
            sprite.material = materials[0];
        }
        else if (materials.length > 1) {
            // Assign each sub-sprite in the sprite a material from the list. If more sub-sprites
            // than materials, repeat the last material for all remaining sub-sprites.
            for (var i = 0; i < sprite.graphics.count; i++)
                sprite.graphics.getShapeAt(i).material = materials[Math.min(materials.length - 1, i)];
        }
        if ((this._version[0] == 2) && (this._version[1] == 1)) {
            var props = this.parseProperties(AWDParser.spriteInstanceProperties);
            sprite.registrationPoint = new _awayjs_core.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
            sprite.castsShadows = props.get(5, true);
        }
        else {
            this.parseProperties(null);
        }
        sprite.extra = this.parseUserAttributes();
        this._pFinalizeAsset(sprite, name);
        this._blocks[blockID].data = sprite;
        if (this._debug) {
            if (isPrefab)
                console.log("Parsed a Sprite for Prefab: Name = '" + name + "' | Parent-Name = " + parentName + "| Prefab-Name = " + prefab.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
            else
                console.log("Parsed a Sprite for Graphics: Name = '" + name + "' | Parent-Name = " + parentName + "| Graphics-Name = " + graphics.name + " | Graphics-Count = " + sprite.graphics.count + " | Mat-Names = " + materialNames);
        }
    };
    //Block ID 31
    AWDParser.prototype.parseSkyboxInstance = function (blockID) {
        var name = this.parseVarStr();
        var asset = new _awayjs_scene.Skybox();
        var tex = new _awayjs_graphics.SingleCubeTexture(this._blocks[this._newBlockBytes.readUnsignedInt()].data || _awayjs_graphics.DefaultMaterialManager.getDefaultImageCube());
        asset.texture = tex;
        this.parseProperties(null);
        asset.extra = this.parseUserAttributes();
        this._pFinalizeAsset(asset, name);
        this._blocks[blockID].data = asset;
        if (this._debug)
            console.log("Parsed a Skybox: Name = '" + name + "' | CubeTexture-Name = " + tex.name);
    };
    //Block ID = 41
    AWDParser.prototype.parseLight = function (blockID) {
        var light;
        var newShadowMapper;
        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        var mtx = this.parseMatrix3D();
        var name = this.parseVarStr();
        var lightType = this._newBlockBytes.readUnsignedByte();
        var props = this.parseProperties(AWDParser.lightProperties);
        var shadowMapperType = props.get(9, 0);
        var lightTypes = ["Unsupported LightType", "PointLight", "DirectionalLight"];
        var shadowMapperTypes = ["No ShadowMapper", "DirectionalShadowMapper", "NearDirectionalShadowMapper", "CascadeShadowMapper", "CubeMapShadowMapper"];
        if (lightType == 1) {
            light = new _awayjs_scene.PointLight();
            light.radius = props.get(1, 90000);
            light.fallOff = props.get(2, 100000);
            if (shadowMapperType > 0) {
                if (shadowMapperType == 4) {
                    newShadowMapper = new _awayjs_scene.CubeMapShadowMapper();
                }
            }
            light.transform.matrix3D = mtx;
        }
        if (lightType == 2) {
            light = new _awayjs_scene.DirectionalLight(props.get(21, 0), props.get(22, -1), props.get(23, 1));
            if (shadowMapperType > 0) {
                if (shadowMapperType == 1) {
                    newShadowMapper = new _awayjs_scene.DirectionalShadowMapper();
                }
            }
        }
        light.color = props.get(3, 0xffffff);
        light.specular = props.get(4, 1.0);
        light.diffuse = props.get(5, 1.0);
        light.ambientColor = props.get(7, 0xffffff);
        light.ambient = props.get(8, 0.0);
        // if a shadowMapper has been created, adjust the depthMapSize if needed, assign to light and set castShadows to true
        if (newShadowMapper) {
            if (newShadowMapper instanceof _awayjs_scene.CubeMapShadowMapper) {
                if (props.get(10, 1) != 1)
                    newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 1)];
            }
            else {
                if (props.get(10, 2) != 2)
                    newShadowMapper.depthMapSize = this._depthSizeDic[props.get(10, 2)];
            }
            light.shadowMapper = newShadowMapper;
            light.castsShadows = true;
        }
        var parentName = "Root (TopLevel)";
        if (parent) {
            parent.addChild(light);
            parentName = parent.name;
        }
        else {
            //add to the content property
            this._pContent.addChild(light);
        }
        this.parseUserAttributes();
        this._pFinalizeAsset(light, name);
        this._blocks[blockID].data = light;
        if (this._debug)
            console.log("Parsed a Light: Name = '" + name + "' | Type = " + lightTypes[lightType] + " | Parent-Name = " + parentName + " | ShadowMapper-Type = " + shadowMapperTypes[shadowMapperType]);
    };
    //Block ID = 43
    AWDParser.prototype.parseCamera = function (blockID) {
        var parent = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        var mtx = this.parseMatrix3D();
        var name = this.parseVarStr();
        var projection;
        this._newBlockBytes.readUnsignedByte(); //set as active camera
        this._newBlockBytes.readShort(); //lengthof lenses - not used yet
        var projectiontype = this._newBlockBytes.readShort();
        var props = this.parseProperties(AWDParser.cameraProperties);
        switch (projectiontype) {
            case 5001:
                projection = new _awayjs_core.PerspectiveProjection(props.get(101, 60));
                break;
            case 5002:
                projection = new _awayjs_core.OrthographicProjection(props.get(101, 500));
                break;
            case 5003:
                projection = new _awayjs_core.OrthographicOffCenterProjection(props.get(101, -400), props.get(102, 400), props.get(103, -300), props.get(104, 300));
                break;
            default:
                console.log("unsupportedLenstype");
                return;
        }
        var camera = new _awayjs_scene.Camera(projection);
        camera.transform.matrix3D = mtx;
        var parentName = "Root (TopLevel)";
        if (parent) {
            parent.addChild(camera);
            parentName = parent.name;
        }
        else {
            //add to the content property
            this._pContent.addChild(camera);
        }
        camera.name = name;
        props = this.parseProperties(AWDParser.cameraPivotProperties);
        camera.registrationPoint = new _awayjs_core.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
        camera.extra = this.parseUserAttributes();
        this._pFinalizeAsset(camera, name);
        this._blocks[blockID].data = camera;
        if (this._debug)
            console.log("Parsed a Camera: Name = '" + name + "' | Projectiontype = " + projection + " | Parent-Name = " + parentName);
    };
    //Block ID = 51
    AWDParser.prototype.parseLightPicker = function (blockID) {
        var name = this.parseVarStr();
        var numLights = this._newBlockBytes.readUnsignedShort();
        var lightsArray = new Array();
        var lightsArrayNames = new Array();
        for (var k = 0; k < numLights; k++) {
            var light = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
            lightsArray.push(light);
            lightsArrayNames.push(light.name);
        }
        if (lightsArray.length == 0) {
            this._blocks[blockID].addError("Could not create this LightPicker, cause no Light was found.");
            this.parseUserAttributes();
            return; //return without any more parsing for this block
        }
        var lightPick = new _awayjs_scene.StaticLightPicker(lightsArray);
        lightPick.name = name;
        this.parseUserAttributes();
        this._pFinalizeAsset(lightPick, name);
        this._blocks[blockID].data = lightPick;
        if (this._debug)
            console.log("Parsed a StaticLightPicker: Name = '" + name + "' | Texture-Name = " + lightsArrayNames);
    };
    //Block ID = 81
    AWDParser.prototype.parseMaterial = function (blockID) {
        // TODO: not used
        ////blockLength = block.len;
        var name;
        var type;
        var props;
        var mat;
        var finalize;
        var num_methods;
        var methods_parsed;
        var returnedArray;
        name = this.parseVarStr();
        type = this._newBlockBytes.readUnsignedByte();
        num_methods = this._newBlockBytes.readUnsignedByte();
        // Read material numerical properties
        props = this.parseProperties(AWDParser.materialProperties);
        methods_parsed = 0;
        while (methods_parsed < num_methods) {
            var method_type;
            method_type = this._newBlockBytes.readUnsignedShort();
            this.parseProperties(null);
            this.parseUserAttributes();
            methods_parsed += 1;
        }
        var debugString = "";
        if (type === 1) {
            debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
            var color = props.get(1, 0xffffff);
            if (this.materialMode < 2) {
                mat = this._factory.createMaterial(color, props.get(10, 1.0));
            }
            else {
                mat = this._factory.createMaterial(color);
                mat.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
            }
        }
        else if (type === 2) {
            var texture = new _awayjs_graphics.Single2DTexture(this._blocks[props.get(2, 0)].data);
            mat = this._factory.createMaterial();
            mat.ambientMethod.texture = texture;
            if (this.materialMode < 2) {
                mat.alphaBlending = props.get(11, false);
                mat.alpha = props.get(10, 1.0);
                debugString += "Parsed a MethodMaterial(SinglePass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
            }
            else {
                mat.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
                debugString += "Parsed a MethodMaterial(MultiPass): Name = '" + name + "'" + (texture ? " | Texture-Name = " + texture.name : "");
            }
        }
        mat.extra = this.parseUserAttributes();
        mat.alphaThreshold = props.get(12, 0.0);
        mat.style.sampler = new _awayjs_graphics.Sampler2D(props.get(13, false));
        this._pFinalizeAsset(mat, name);
        this._blocks[blockID].data = mat;
        if (this._debug)
            console.log(debugString);
    };
    // Block ID = 81 AWD2.1
    AWDParser.prototype.parseMaterial_v1 = function (blockID) {
        var mat;
        var diffuseImage;
        var normalImage;
        var specImage;
        var name = this.parseVarStr();
        var type = this._newBlockBytes.readUnsignedByte();
        var num_methods = this._newBlockBytes.readUnsignedByte();
        var props = this.parseProperties(AWDParser.material_v1Properties);
        var spezialType = props.get(4, 0);
        var debugString = "Parsed Material ";
        if (spezialType >= 2) {
            this._blocks[blockID].addError("Material-spezialType '" + spezialType + "' is not supported, can only be 0:singlePass, 1:MultiPass !");
            return;
        }
        if (type <= 2) {
            if (this.materialMode == 1)
                spezialType = 0;
            else if (this.materialMode == 2)
                spezialType = 1;
            if (spezialType < 2) {
                if (type == 1) {
                    var color = props.get(1, 0xcccccc); //TODO temporarily swapped so that diffuse color goes to ambient
                    if (spezialType == 1) {
                        mat = this._factory.createMaterial(color);
                        mat.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
                        debugString += "Parsed a ColorMaterial(MultiPass): Name = '" + name + "' | ";
                    }
                    else {
                        mat = this._factory.createMaterial(color, props.get(10, 1.0));
                        mat.alphaBlending = props.get(11, false);
                        debugString += "Parsed a ColorMaterial(SinglePass): Name = '" + name + "' | ";
                    }
                }
                else if (type == 2) {
                    mat = this._factory.createMaterial(this._blocks[props.get(2, 0)].data);
                    if (spezialType == 1) {
                        mat.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
                        debugString += "Parsed a MethodMaterial(MultiPass): Name = '" + name + "'" + (mat.ambientMethod.texture ? " | Texture-Name = " + mat.ambientMethod.texture.name : "");
                    }
                    else {
                        mat.alpha = props.get(10, 1.0);
                        mat.alphaBlending = props.get(11, false);
                        debugString += "Parsed a MethodMaterial(SinglePass): Name = '" + name + "'" + (mat.ambientMethod.texture ? " | Texture-Name = " + mat.ambientMethod.texture.name : "");
                    }
                }
                diffuseImage = this._blocks[props.get(17, 0)].data;
                normalImage = this._blocks[props.get(3, 0)].data;
                specImage = this._blocks[props.get(21, 0)].data;
                mat.lightPicker = this._blocks[props.get(22, 0)].data;
                mat.style.sampler = new _awayjs_graphics.Sampler2D(props.get(13, false), props.get(5, true), props.get(6, true));
                mat.bothSides = props.get(7, false);
                mat.alphaPremultiplied = props.get(8, false);
                mat.blendMode = this.blendModeDic[props.get(9, 0)];
                if (diffuseImage) {
                    mat.diffuseMethod.texture = new _awayjs_graphics.Single2DTexture(diffuseImage);
                    debugString += " | DiffuseTexture-Name = " + diffuseImage.name;
                }
                if (normalImage) {
                    mat.normalMethod.texture = new _awayjs_graphics.Single2DTexture(normalImage);
                    debugString += " | NormalTexture-Name = " + normalImage.name;
                }
                if (specImage) {
                    mat.specularMethod.texture = new _awayjs_graphics.Single2DTexture(specImage);
                    debugString += " | SpecularTexture-Name = " + specImage.name;
                }
                mat.alphaThreshold = props.get(12, 0.0);
                mat.ambientMethod.strength = props.get(15, 1.0);
                mat.diffuseMethod.color = props.get(16, 0xffffff);
                mat.specularMethod.strength = props.get(18, 1.0);
                mat.specularMethod.gloss = props.get(19, 50);
                mat.specularMethod.color = props.get(20, 0xffffff);
                for (var methods_parsed = 0; methods_parsed < num_methods; methods_parsed++) {
                    var method_type;
                    method_type = this._newBlockBytes.readUnsignedShort();
                    props = this.parseProperties(AWDParser.method_v1Properties);
                    switch (method_type) {
                        case 999:
                            var effectMethod = this._blocks[props.get(1, 0)].data;
                            mat.addEffectMethod(effectMethod);
                            debugString += " | EffectMethod-Name = " + effectMethod.name;
                            break;
                        case 998:
                            var shadowMethod = this._blocks[props.get(1, 0)].data;
                            mat.shadowMethod = shadowMethod;
                            debugString += " | ShadowMethod-Name = " + shadowMethod.name;
                            break;
                        case 1:
                            var cubeTexture = new _awayjs_graphics.SingleCubeTexture(this._blocks[props.get(1, 0)].data);
                            //mat.ambientMethod.mappingMode = 
                            mat.ambientMethod.texture = cubeTexture;
                            debugString += " | AmbientEnvMapMethod | EnvMap-Name =" + cubeTexture.name;
                            break;
                        // case 51: //AmbientDepthMethod
                        // 	mat.diffuseMethod = new AmbientDepthMethod();
                        // 	debugString += " | AmbientDepthMethod";
                        // 	break;
                        case 52:
                            var texture = new _awayjs_graphics.Single2DTexture(this._blocks[props.get(1, 0)].data);
                            mat.diffuseMethod = new _awayjs_materials.DiffuseGradientMethod(texture);
                            debugString += " | DiffuseGradientMethod | GradientDiffuseTexture-Name =" + texture.name;
                            break;
                        case 53:
                            mat.diffuseMethod = new _awayjs_materials.DiffuseWrapMethod(props.get(101, 5));
                            debugString += " | DiffuseWrapMethod";
                            break;
                        case 54:
                            var texture = new _awayjs_graphics.Single2DTexture(this._blocks[props.get(1, 0)].data);
                            mat.diffuseMethod = new _awayjs_materials.DiffuseLightMapMethod(texture, this.blendModeDic[props.get(401, 10)], false, mat.diffuseMethod);
                            debugString += " | DiffuseLightMapMethod | LightMapTexture-Name =" + texture.name;
                            break;
                        case 55:
                            mat.diffuseMethod = new _awayjs_materials.DiffuseCelMethod(props.get(401, 3), props.get(101, 0.1), mat.diffuseMethod);
                            debugString += " | DiffuseCelMethod";
                            break;
                        case 56:
                            //							mat.diffuseMethod = new DiffuseSubSurfaceMethod(); //depthMapSize and depthMapOffset ?
                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).scattering = props.get(101, 0.2);
                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).translucency = props.get(102, 1);
                            //							(<DiffuseSubSurfaceMethod> mat.diffuseMethod).scatterColor = props.get(601, 0xffffff);
                            //							debugString += " | DiffuseSubSurfaceMethod";
                            break;
                        case 101:
                            mat.specularMethod = new _awayjs_materials.SpecularAnisotropicMethod();
                            debugString += " | SpecularAnisotropicMethod";
                            break;
                        case 102:
                            mat.specularMethod = new _awayjs_materials.SpecularPhongMethod();
                            debugString += " | SpecularPhongMethod";
                            break;
                        case 103:
                            mat.specularMethod = new _awayjs_materials.SpecularCelMethod(props.get(101, 0.5), props.get(102, 0.1), mat.specularMethod);
                            debugString += " | SpecularCelMethod";
                            break;
                        case 104:
                            mat.specularMethod = new _awayjs_materials.SpecularFresnelMethod(props.get(701, true), props.get(101, 5), props.get(102, 0.1), mat.specularMethod);
                            debugString += " | SpecularFresnelMethod";
                            break;
                        case 151:
                            break;
                        case 152:
                            var texture = new _awayjs_graphics.Single2DTexture(this._blocks[props.get(1, 0)].data);
                            mat.normalMethod = new _awayjs_materials.NormalSimpleWaterMethod(mat.normalMethod.texture || texture, texture);
                            debugString += " | NormalSimpleWaterMethod | Second-NormalTexture-Name = " + texture.name;
                            break;
                    }
                    this.parseUserAttributes();
                }
            }
        }
        else if ((type >= 3) && (type <= 7)) {
            // if this is a basic material, we create it, finalize it, assign it to block-cache and return.
            var color = props.get(1, 0xcccccc);
            debugString += color;
            var diffuseTexture = new _awayjs_graphics.Single2DTexture(this._blocks[props.get(2, 0)].data);
            if (type == 5) {
                diffuseTexture.mappingMode = _awayjs_graphics.MappingMode.LINEAR;
            }
            else if (type == 6) {
                diffuseTexture.mappingMode = _awayjs_graphics.MappingMode.RADIAL;
            }
            var basic_mat = this._factory.createMaterial();
            basic_mat.ambientMethod.texture = diffuseTexture;
            basic_mat.bothSides = true;
            basic_mat.alphaBlending = props.get(11, false);
            //basic_mat.preserveAlpha = basic_mat.alphaBlending;
            //basic_mat.alphaBlending = true;
            basic_mat.extra = this.parseUserAttributes();
            this._pFinalizeAsset(basic_mat, name);
            this._blocks[blockID].data = basic_mat;
            if (this._debug)
                console.log(debugString);
            return;
        }
        mat.extra = this.parseUserAttributes();
        this._pFinalizeAsset(mat, name);
        this._blocks[blockID].data = mat;
        if (this._debug)
            console.log(debugString);
    };
    //Block ID = 82
    AWDParser.prototype.parseTexture = function (blockID) {
        this._blocks[blockID].name = this.parseVarStr();
        var type = this._newBlockBytes.readUnsignedByte();
        this._texture_users[this._cur_block_id] = [];
        // External
        if (type == 0) {
            var url = this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedInt());
            this._pAddDependency(this._cur_block_id.toString(), new _awayjs_core.URLRequest(url), new _awayjs_graphics.Image2DParser(this._factory), null, false, true);
        }
        else {
            var data_len = this._newBlockBytes.readUnsignedInt();
            var data = new _awayjs_core.ByteArray(data_len);
            this._newBlockBytes.readBytes(data, 0, data_len);
            //
            // AWD3Parserutils - Fix for FireFox Bug: https://bugzilla.mozilla.org/show_bug.cgi?id=715075 .
            //
            // Converting data to image here instead of parser - fix FireFox bug where image width / height is 0 when created from data
            // This gives the browser time to initialise image width / height.
            this._pAddDependency(this._cur_block_id.toString(), null, new _awayjs_graphics.Image2DParser(this._factory), data, false, true);
        }
        // Ignore for now
        this.parseProperties(null);
        this._blocks[blockID].extras = this.parseUserAttributes();
        this._pPauseAndRetrieveDependencies();
        if (this._debug)
            console.log("Start parsing a " + ["external", "embed"][type] + " Bitmap for Texture");
    };
    //Block ID = 83
    AWDParser.prototype.parseCubeTexture = function (blockID) {
        //blockLength = block.len;
        var data_len;
        var i;
        this._texture_users[this._cur_block_id] = [];
        var type = this._newBlockBytes.readUnsignedByte();
        this._blocks[blockID].name = this.parseVarStr();
        for (i = 0; i < 6; i++) {
            this._texture_users[this._cur_block_id] = [];
            // External
            if (type == 0) {
                data_len = this._newBlockBytes.readUnsignedInt();
                var url;
                url = this._newBlockBytes.readUTFBytes(data_len);
                this._pAddDependency(this._cur_block_id.toString(), new _awayjs_core.URLRequest(url), null, null, false, true, i);
            }
            else {
                data_len = this._newBlockBytes.readUnsignedInt();
                var data = new _awayjs_core.ByteArray(data_len);
                this._newBlockBytes.readBytes(data, 0, data_len);
                this._pAddDependency(this._cur_block_id.toString(), null, null, _awayjs_core.ParserUtils.byteArrayToImage(data), false, true, i);
            }
        }
        // Ignore for now
        this.parseProperties(null);
        this._blocks[blockID].extras = this.parseUserAttributes();
        this._pPauseAndRetrieveDependencies();
        if (this._debug)
            console.log("Start parsing 6 " + ["external", "embed"][type] + " Bitmaps for CubeTexture");
    };
    //Block ID = 91
    AWDParser.prototype.parseSharedMethodBlock = function (blockID) {
        var asset;
        this._blocks[blockID].name = this.parseVarStr();
        asset = this.parseSharedMethodList(blockID);
        this.parseUserAttributes();
        this._blocks[blockID].data = asset;
        this._pFinalizeAsset(asset, this._blocks[blockID].name);
        this._blocks[blockID].data = asset;
        if (this._debug)
            console.log("Parsed a EffectMethod: Name = " + asset.name + " Type = " + asset);
    };
    //Block ID = 92
    AWDParser.prototype.parseShadowMethodBlock = function (blockID) {
        this._blocks[blockID].name = this.parseVarStr();
        var light = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        var asset = this.parseShadowMethodList(light, blockID);
        if (!asset)
            return;
        this.parseUserAttributes(); // Ignore for now
        this._pFinalizeAsset(asset, this._blocks[blockID].name);
        this._blocks[blockID].data = asset;
        if (this._debug)
            console.log("Parsed a ShadowMapMethodMethod: Name = " + asset.name + " | Type = " + asset + " | Light-Name = ", light.name);
    };
    //Block ID = 253
    AWDParser.prototype.parseCommand = function (blockID) {
        var hasBlocks = (this._newBlockBytes.readUnsignedByte() == 1);
        var parentObject = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        var targetObject;
        var mtx = this.parseMatrix3D();
        var name = this.parseVarStr();
        var numCommands = this._newBlockBytes.readShort();
        var typeCommand = this._newBlockBytes.readShort();
        var props = this.parseProperties(AWDParser.commandProperties);
        switch (typeCommand) {
            case 1:
                targetObject = this._blocks[props.get(1, 0)].data;
                targetObject.transform.matrix3D = mtx;
                if (parentObject)
                    parentObject.addChild(targetObject);
                break;
        }
        if (targetObject) {
            props = this.parseProperties(AWDParser.targetProperties);
            targetObject.registrationPoint = new _awayjs_core.Vector3D(props.get(1, 0), props.get(2, 0), props.get(3, 0));
            targetObject.extra = this.parseUserAttributes();
        }
        this._blocks[blockID].data = targetObject;
        if (this._debug)
            console.log("Parsed a CommandBlock: Name = '" + name);
    };
    //blockID 255
    AWDParser.prototype.parseMetaData = function (blockID) {
        var props = this.parseProperties(AWDParser.metaDataProperties);
        if (this._debug) {
            console.log("Parsed a MetaDataBlock: TimeStamp         = " + props.get(1, 0));
            console.log("                        EncoderName       = " + props.get(2, "unknown"));
            console.log("                        EncoderVersion    = " + props.get(3, "unknown"));
            console.log("                        GeneratorName     = " + props.get(4, "unknown"));
            console.log("                        GeneratorVersion  = " + props.get(5, "unknown"));
        }
    };
    //blockID 254
    AWDParser.prototype.parseNameSpace = function (blockID) {
        var id = this._newBlockBytes.readUnsignedByte();
        var nameSpaceString = this.parseVarStr();
        if (this._debug)
            console.log("Parsed a NameSpaceBlock: ID = " + id + " | String = " + nameSpaceString);
    };
    // this functions reads and creates a ShadowMethodMethod
    AWDParser.prototype.parseShadowMethodList = function (light, blockID) {
        var methodType = this._newBlockBytes.readUnsignedShort();
        var shadowMethod;
        var props = this.parseProperties(this.shadowMethodListProperties);
        var targetID;
        var returnedArray;
        switch (methodType) {
            //				case 1001: //CascadeShadowMapMethod
            //					targetID = props.get(1, 0);
            //					returnedArray = getAssetByID(targetID, [ShadowMapMethodBase.assetType]);
            //					if (!returnedArray[0]) {
            //						_blocks[blockID].addError("Could not find the ShadowBaseMethod (ID = " + targetID + " ) for this CascadeShadowMapMethod - ShadowMethod not created");
            //						return shadowMethod;
            //					}
            //					shadowMethod = new CascadeShadowMapMethod(returnedArray[1]);
            //					break;
            case 1002:
                shadowMethod = new _awayjs_materials.ShadowNearMethod(this._blocks[props.get(1, 0)].data);
                break;
            // case 1101: //ShadowFilteredMethod
            // 	shadowMethod = new ShadowFilteredMethod(<DirectionalLight> light);
            // 	(<ShadowFilteredMethod> shadowMethod).alpha = props.get(101, 1);
            // 	(<ShadowFilteredMethod> shadowMethod).epsilon = props.get(102, 0.002);
            // 	break;
            case 1102:
                shadowMethod = new _awayjs_materials.ShadowDitheredMethod(light, props.get(201, 5));
                shadowMethod.alpha = props.get(101, 1);
                shadowMethod.epsilon = props.get(102, 0.002);
                shadowMethod.range = props.get(103, 1);
                break;
            case 1103:
                shadowMethod = new _awayjs_materials.ShadowSoftMethod(light, props.get(201, 5));
                shadowMethod.alpha = props.get(101, 1);
                shadowMethod.epsilon = props.get(102, 0.002);
                shadowMethod.range = props.get(103, 1);
                break;
            case 1104:
                shadowMethod = new _awayjs_materials.ShadowHardMethod(light);
                shadowMethod.alpha = props.get(101, 1);
                shadowMethod.epsilon = props.get(102, 0.002);
                break;
        }
        this.parseUserAttributes();
        return shadowMethod;
    };
    //Block ID 101
    AWDParser.prototype.parseSkeleton = function (blockID /*uint*/) {
        var name = this.parseVarStr();
        var num_joints = this._newBlockBytes.readUnsignedShort();
        var skeleton = new _awayjs_renderer.Skeleton();
        this.parseProperties(null); // Discard properties for now
        for (var joints_parsed = 0; joints_parsed < num_joints; joints_parsed++) {
            var joint;
            var ibp;
            // Ignore joint id
            this._newBlockBytes.readUnsignedShort();
            joint = new _awayjs_renderer.SkeletonJoint();
            joint.parentIndex = this._newBlockBytes.readUnsignedShort() - 1; // 0=null in AWD
            joint.name = this.parseVarStr();
            ibp = this.parseMatrix3D();
            joint.inverseBindPose = ibp._rawData;
            // Ignore joint props/attributes for now
            this.parseProperties(null);
            this.parseUserAttributes();
            skeleton.joints.push(joint);
        }
        // Discard attributes for now
        this.parseUserAttributes();
        this._pFinalizeAsset(skeleton, name);
        this._blocks[blockID].data = skeleton;
        if (this._debug)
            console.log("Parsed a Skeleton: Name = " + skeleton.name + " | Number of Joints = " + joints_parsed);
    };
    //Block ID = 102
    AWDParser.prototype.parseSkeletonPose = function (blockID /*uint*/) {
        var name = this.parseVarStr();
        var num_joints = this._newBlockBytes.readUnsignedShort();
        this.parseProperties(null); // Ignore properties for now
        var pose = new _awayjs_renderer.SkeletonPose();
        for (var joints_parsed = 0; joints_parsed < num_joints; joints_parsed++) {
            var joint_pose;
            var has_transform;
            joint_pose = new _awayjs_renderer.JointPose();
            has_transform = this._newBlockBytes.readUnsignedByte();
            if (has_transform == 1) {
                var mtx_data = this.parseMatrix43RawData();
                var mtx = new _awayjs_core.Matrix3D(mtx_data);
                joint_pose.orientation.fromMatrix(mtx);
                joint_pose.translation.copyFrom(mtx.position);
                pose.jointPoses[joints_parsed] = joint_pose;
            }
        }
        // Skip attributes for now
        this.parseUserAttributes();
        this._pFinalizeAsset(pose, name);
        this._blocks[blockID].data = pose;
        if (this._debug)
            console.log("Parsed a SkeletonPose: Name = " + pose.name + " | Number of Joints = " + joints_parsed);
    };
    //blockID 103
    AWDParser.prototype.parseSkeletonAnimation = function (blockID /*uint*/) {
        var frame_dur;
        var pose_id;
        var name = this.parseVarStr();
        var clip = new _awayjs_renderer.SkeletonClipNode();
        var num_frames = this._newBlockBytes.readUnsignedShort();
        this.parseProperties(null); // Ignore properties for now
        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
            pose_id = this._newBlockBytes.readUnsignedInt();
            frame_dur = this._newBlockBytes.readUnsignedShort();
            clip.addFrame(this._blocks[pose_id].data, frame_dur);
        }
        if (clip.frames.length == 0) {
            this._blocks[blockID].addError("Could not this SkeletonClipNode, because no Frames where set.");
            return;
        }
        // Ignore attributes for now
        this.parseUserAttributes();
        this._pFinalizeAsset(clip, name);
        this._blocks[blockID].data = clip;
        if (this._debug)
            console.log("Parsed a SkeletonClipNode: Name = " + clip.name + " | Number of Frames = " + clip.frames.length);
    };
    //Block ID = 111 /  Block ID = 112
    AWDParser.prototype.parseSpritePoseAnimation = function (blockID /*uint*/, poseOnly) {
        if (poseOnly === void 0) { poseOnly = false; }
        var subSpriteParsed;
        var x;
        var y;
        var z;
        var str_len;
        var str_end;
        var elements;
        var idx = 0;
        var clip = new _awayjs_renderer.VertexClipNode();
        var indices;
        var verts;
        var streamtypes = new Array();
        var props;
        var name = this.parseVarStr();
        var geo_id = this._newBlockBytes.readUnsignedInt();
        var graphics = this._blocks[geo_id].data;
        var uvs = this.getUVForVertexAnimation(geo_id);
        var num_frames = (!poseOnly) ? this._newBlockBytes.readUnsignedShort() : 1;
        var num_subsprites = this._newBlockBytes.readUnsignedShort();
        var num_Streams = this._newBlockBytes.readUnsignedShort();
        for (var streamsParsed = 0; streamsParsed < num_Streams; streamsParsed++)
            streamtypes.push(this._newBlockBytes.readUnsignedShort());
        props = this.parseProperties(this.spritePoseAnimationProperties);
        clip.looping = props.get(1, true);
        clip.stitchFinalFrame = props.get(2, false);
        var frame_dur;
        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
            frame_dur = this._newBlockBytes.readUnsignedShort();
            graphics = new _awayjs_graphics.Graphics();
            subSpriteParsed = 0;
            while (subSpriteParsed < num_subsprites) {
                streamsParsed = 0;
                str_len = this._newBlockBytes.readUnsignedInt();
                str_end = this._newBlockBytes.position + str_len;
                while (streamsParsed < num_Streams) {
                    if (streamtypes[streamsParsed] == 1) {
                        indices = graphics.getShapeAt(subSpriteParsed).elements.indices;
                        verts = new Array();
                        idx = 0;
                        while (this._newBlockBytes.position < str_end) {
                            x = this.readNumber(this._accuracyGeo);
                            y = this.readNumber(this._accuracyGeo);
                            z = this.readNumber(this._accuracyGeo);
                            verts[idx++] = x;
                            verts[idx++] = y;
                            verts[idx++] = z;
                        }
                        elements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
                        elements.setIndices(indices);
                        elements.setPositions(verts);
                        elements.setUVs(uvs[subSpriteParsed]);
                        elements.setNormals(null);
                        elements.setTangents(null);
                        elements.autoDeriveNormals = false;
                        elements.autoDeriveTangents = false;
                        subSpriteParsed++;
                        graphics.addShape(new _awayjs_graphics.Shape(elements));
                    }
                    else
                        this._newBlockBytes.position = str_end;
                    streamsParsed++;
                }
            }
            clip.addFrame(graphics, frame_dur);
        }
        this.parseUserAttributes();
        this._pFinalizeAsset(clip, name);
        this._blocks[blockID].data = clip;
        if (this._debug)
            console.log("Parsed a VertexClipNode: Name = " + clip.name + " | Target-Graphics-Name = " + graphics.name + " | Number of Frames = " + clip.frames.length);
    };
    //BlockID 113
    AWDParser.prototype.parseVertexAnimationSet = function (blockID /*uint*/) {
        var name = this.parseVarStr();
        var num_frames = this._newBlockBytes.readUnsignedShort();
        var props = this.parseProperties(AWDParser.vertexAnimationSetProperties);
        var skeletonFrames = new Array();
        var vertexFrames = new Array();
        var clipNode;
        for (var frames_parsed = 0; frames_parsed < num_frames; frames_parsed++) {
            clipNode = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
            if (clipNode instanceof _awayjs_renderer.VertexClipNode)
                vertexFrames.push(clipNode);
            else if (clipNode instanceof _awayjs_renderer.SkeletonClipNode)
                skeletonFrames.push(clipNode);
        }
        if ((vertexFrames.length == 0) && (skeletonFrames.length == 0)) {
            this._blocks[blockID].addError("Could not create this AnimationSet, because it contains no animations");
            return;
        }
        this.parseUserAttributes();
        if (vertexFrames.length > 0) {
            var newVertexAnimationSet = new _awayjs_renderer.VertexAnimationSet();
            for (var i = 0; i < vertexFrames.length; i++)
                newVertexAnimationSet.addAnimation(vertexFrames[i]);
            this._pFinalizeAsset(newVertexAnimationSet, name);
            this._blocks[blockID].data = newVertexAnimationSet;
            if (this._debug)
                console.log("Parsed a VertexAnimationSet: Name = " + name + " | Animations = " + newVertexAnimationSet.animations.length + " | Animation-Names = " + newVertexAnimationSet.animationNames);
        }
        else if (skeletonFrames.length > 0) {
            var newSkeletonAnimationSet = new _awayjs_renderer.SkeletonAnimationSet(props.get(1, 4)); //props.get(1,4));
            for (var i = 0; i < skeletonFrames.length; i++)
                newSkeletonAnimationSet.addAnimation(skeletonFrames[i]);
            this._pFinalizeAsset(newSkeletonAnimationSet, name);
            this._blocks[blockID].data = newSkeletonAnimationSet;
            if (this._debug)
                console.log("Parsed a SkeletonAnimationSet: Name = " + name + " | Animations = " + newSkeletonAnimationSet.animations.length + " | Animation-Names = " + newSkeletonAnimationSet.animationNames);
        }
    };
    //BlockID 122
    AWDParser.prototype.parseAnimatorSet = function (blockID /*uint*/) {
        var name = this.parseVarStr();
        var type = this._newBlockBytes.readUnsignedShort();
        var props = this.parseProperties(AWDParser.animatorSetProperties);
        var targetAnimationSet = this._blocks[this._newBlockBytes.readUnsignedInt()].data;
        var targetSpritees = new Array();
        var targetSpriteLength = this._newBlockBytes.readUnsignedShort();
        for (var i = 0; i < targetSpriteLength; i++)
            targetSpritees.push(this._blocks[this._newBlockBytes.readUnsignedInt()].data);
        var activeState = this._newBlockBytes.readUnsignedShort();
        var autoplay = (this._newBlockBytes.readUnsignedByte() == 1);
        this.parseUserAttributes();
        this.parseUserAttributes();
        var thisAnimator;
        if (type == 1)
            thisAnimator = new _awayjs_renderer.SkeletonAnimator(targetAnimationSet, this._blocks[props.get(1, 0)].data);
        else if (type == 2)
            thisAnimator = new _awayjs_renderer.VertexAnimator(targetAnimationSet);
        this._pFinalizeAsset(thisAnimator, name);
        this._blocks[blockID].data = thisAnimator;
        for (i = 0; i < targetSpritees.length; i++) {
            if (type == 1)
                targetSpritees[i].animator = thisAnimator;
            else if (type == 2)
                targetSpritees[i].animator = thisAnimator;
        }
        if (this._debug)
            console.log("Parsed a Animator: Name = " + name);
    };
    // this functions reads and creates a EffectMethod
    AWDParser.prototype.parseSharedMethodList = function (blockID) {
        var methodType = this._newBlockBytes.readUnsignedShort();
        var effectMethodReturn;
        var props = this.parseProperties(this.sharedMethodListProperties);
        switch (methodType) {
            // Effect Methods
            case 401:
                effectMethodReturn = new _awayjs_materials.EffectColorMatrixMethod(props.get(101, new Array(0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)));
                break;
            case 402:
                effectMethodReturn = new _awayjs_materials.EffectColorTransformMethod();
                var offCol = props.get(601, 0x00000000);
                effectMethodReturn.colorTransform = new _awayjs_core.ColorTransform(props.get(102, 1), props.get(103, 1), props.get(104, 1), props.get(101, 1), ((offCol >> 16) & 0xFF), ((offCol >> 8) & 0xFF), (offCol & 0xFF), ((offCol >> 24) & 0xFF));
                break;
            case 403:
                effectMethodReturn = new _awayjs_materials.EffectEnvMapMethod(new _awayjs_graphics.SingleCubeTexture(this._blocks[props.get(1, 0)].data), props.get(101, 1));
                var targetID = props.get(2, 0);
                if (targetID > 0) {
                }
                break;
            case 404:
                effectMethodReturn = new _awayjs_materials.EffectLightMapMethod(this._blocks[props.get(1, 0)].data, this.blendModeDic[props.get(401, 10)]); //usesecondaryUV not set
                break;
            //				case 405: //ProjectiveTextureMethod
            //					targetID = props.get(1, 0);
            //					returnedArray = getAssetByID(targetID, [TextureProjector.assetType]);
            //					if (!returnedArray[0])
            //						_blocks[blockID].addError("Could not find the TextureProjector (ID = " + targetID + " ) for this ProjectiveTextureMethod");
            //					effectMethodReturn = new ProjectiveTextureMethod(returnedArray[1], blendModeDic[props.get(401, 10)]);
            //					break;
            case 406:
                effectMethodReturn = new _awayjs_materials.EffectRimLightMethod(props.get(601, 0xffffff), props.get(101, 0.4), props.get(101, 2)); //blendMode
                break;
            case 407:
                effectMethodReturn = new _awayjs_materials.EffectAlphaMaskMethod(this._blocks[props.get(1, 0)].data, props.get(701, false));
                break;
            //				case 408: //RefractionEnvMapMethod
            //					targetID = props.get(1, 0);
            //					returnedArray = getAssetByID(targetID, [TextureBase.assetType], "CubeTexture");
            //					if (!returnedArray[0])
            //						_blocks[blockID].addError("Could not find the EnvMap (ID = " + targetID + " ) for this RefractionEnvMapMethod");
            //					effectMethodReturn = new RefractionEnvMapMethod(returnedArray[1], props.get(101, 0.1), props.get(102, 0.01), props.get(103, 0.01), props.get(104, 0.01));
            //					RefractionEnvMapMethod(effectMethodReturn).alpha = props.get(104, 1);
            //					break;
            //				case 409: //OutlineMethod
            //					effectMethodReturn = new OutlineMethod(props.get(601, 0x00000000), props.get(101, 1), props.get(701, true), props.get(702, false));
            //					break;
            case 410:
                effectMethodReturn = new _awayjs_materials.EffectFresnelEnvMapMethod(this._blocks[props.get(1, 0)].data, props.get(101, 1));
                break;
            case 411:
                effectMethodReturn = new _awayjs_materials.EffectFogMethod(props.get(101, 0), props.get(102, 1000), props.get(601, 0x808080));
                break;
        }
        this.parseUserAttributes();
        return effectMethodReturn;
    };
    AWDParser.prototype.parseUserAttributes = function () {
        var list_len = this._newBlockBytes.readUnsignedInt();
        if (list_len > 0) {
            var list_end = this._newBlockBytes.position + list_len;
            var attributes = {};
            for (var attibuteCnt = 0; this._newBlockBytes.position < list_end; attibuteCnt++) {
                var ns_id;
                var attr_key;
                var attr_type;
                var attr_len;
                var attr_val;
                // TODO: Properly tend to namespaces in attributes
                ns_id = this._newBlockBytes.readUnsignedByte();
                attr_key = this.parseVarStr();
                attr_type = this._newBlockBytes.readUnsignedByte();
                attr_len = this._newBlockBytes.readUnsignedInt();
                if ((this._newBlockBytes.position + attr_len) > list_end) {
                    console.log("           Error in reading attribute # " + attibuteCnt + " = skipped to end of attribute-list");
                    this._newBlockBytes.position = list_end;
                    return attributes;
                }
                switch (attr_type) {
                    case AWDParser.AWDSTRING:
                        attr_val = this._newBlockBytes.readUTFBytes(attr_len);
                        break;
                    case AWDParser.INT8:
                        attr_val = this._newBlockBytes.readByte();
                        break;
                    case AWDParser.INT16:
                        attr_val = this._newBlockBytes.readShort();
                        break;
                    case AWDParser.INT32:
                        attr_val = this._newBlockBytes.readInt();
                        break;
                    case AWDParser.BOOL:
                    case AWDParser.UINT8:
                        attr_val = this._newBlockBytes.readUnsignedByte();
                        break;
                    case AWDParser.UINT16:
                        attr_val = this._newBlockBytes.readUnsignedShort();
                        break;
                    case AWDParser.UINT32:
                    case AWDParser.BADDR:
                        attr_val = this._newBlockBytes.readUnsignedInt();
                        break;
                    case AWDParser.FLOAT32:
                        attr_val = this._newBlockBytes.readFloat();
                        break;
                    case AWDParser.FLOAT64:
                        attr_val = this._newBlockBytes.readDouble();
                        break;
                    default:
                        attr_val = 'unimplemented attribute type ' + attr_type;
                        this._newBlockBytes.position += attr_len;
                        break;
                }
                attributes[attr_key] = attr_val;
                if (this._debug)
                    console.log("attribute = name: " + attr_key + "  / value = " + attr_val);
            }
        }
        return attributes;
    };
    AWDParser.prototype.parseProperties = function (expected) {
        var list_len = this._newBlockBytes.readUnsignedInt();
        var props = new AWDProperties();
        var list_end = this._newBlockBytes.position + list_len;
        if (expected) {
            var len;
            var key;
            var type;
            for (var propertyCnt = 0; this._newBlockBytes.position < list_end; propertyCnt++) {
                key = this._newBlockBytes.readUnsignedShort();
                len = this._newBlockBytes.readUnsignedInt();
                if ((this._newBlockBytes.position + len) > list_end) {
                    console.log("           Error in reading property # " + propertyCnt + " = skipped to end of propertie-list");
                    this._newBlockBytes.position = list_end;
                    return props;
                }
                if (expected[key]) {
                    type = expected[key];
                    props.set(key, this.parseAttrValue(type, len));
                }
                else {
                    this._newBlockBytes.position += len;
                }
            }
        }
        else {
            this._newBlockBytes.position = list_end;
        }
        return props;
    };
    AWDParser.prototype.parseAttrValue = function (type, len) {
        var elem_len;
        var read_func;
        var accuracy;
        switch (type) {
            case AWDParser.BOOL:
            case AWDParser.INT8:
                elem_len = 1;
                read_func = this._newBlockBytes.readByte;
                break;
            case AWDParser.INT16:
                elem_len = 2;
                read_func = this._newBlockBytes.readShort;
                break;
            case AWDParser.INT32:
                elem_len = 4;
                read_func = this._newBlockBytes.readInt;
                break;
            case AWDParser.UINT8:
                elem_len = 1;
                read_func = this._newBlockBytes.readUnsignedByte;
                break;
            case AWDParser.UINT16:
                elem_len = 2;
                read_func = this._newBlockBytes.readUnsignedShort;
                break;
            case AWDParser.UINT32:
            case AWDParser.COLOR:
            case AWDParser.BADDR:
                elem_len = 4;
                read_func = this._newBlockBytes.readUnsignedInt;
                break;
            case AWDParser.FLOAT32:
                elem_len = 4;
                read_func = this._newBlockBytes.readFloat;
                break;
            case AWDParser.FLOAT64:
                elem_len = 8;
                read_func = this._newBlockBytes.readDouble;
                break;
            case AWDParser.AWDSTRING:
                return this._newBlockBytes.readUTFBytes(len);
            case AWDParser.VECTOR2x1:
            case AWDParser.VECTOR3x1:
            case AWDParser.VECTOR4x1:
            case AWDParser.MTX3x2:
            case AWDParser.MTX3x3:
            case AWDParser.MTX4x3:
            case AWDParser.MTX4x4:
                elem_len = 8;
                read_func = this._newBlockBytes.readDouble;
                break;
            case AWDParser.GEO_NUMBER:
                accuracy = this._accuracyGeo;
            case AWDParser.MATRIX_NUMBER:
                accuracy = this._accuracyMatrix;
            case AWDParser.PROPERTY_NUMBER:
                accuracy = this._accuracyProps;
            default:
                if (accuracy) {
                    elem_len = 8;
                    read_func = this._newBlockBytes.readDouble;
                }
                else {
                    elem_len = 4;
                    read_func = this._newBlockBytes.readFloat;
                }
        }
        if (elem_len < len) {
            var list = [];
            var num_elems = len / elem_len;
            for (var num_read = 0; num_read < num_elems; num_read++)
                list[num_read] = read_func.call(this._newBlockBytes);
            return list;
        }
        else if (type == AWDParser.BOOL) {
            return Boolean(read_func.call(this._newBlockBytes));
        }
        else {
            return read_func.call(this._newBlockBytes);
        }
    };
    AWDParser.prototype.parseHeader = function () {
        this._byteData.position = 3; // Skip magic string and parse version
        this._version[0] = this._byteData.readUnsignedByte();
        this._version[1] = this._byteData.readUnsignedByte();
        var flags = this._byteData.readUnsignedShort(); // Parse bit flags
        this._streaming = BitFlags.test(flags, BitFlags.FLAG1);
        // if we set _accuracyOnBlocks, the precision-values are read from each block-header.
        if ((this._version[0] == 2) && (this._version[1] == 1)) {
            this._accuracyMatrix = BitFlags.test(flags, BitFlags.FLAG2);
            this._accuracyGeo = BitFlags.test(flags, BitFlags.FLAG3);
            this._accuracyProps = BitFlags.test(flags, BitFlags.FLAG4);
        }
        this._compression = this._byteData.readUnsignedByte(); // compression
        if (this._debug) {
            console.log("Import AWDFile of version = " + this._version[0] + " - " + this._version[1]);
            console.log("Global Settings = Compression = " + this._compression + " | Streaming = " + this._streaming + " | Matrix-Precision = " + this._accuracyMatrix + " | Graphics-Precision = " + this._accuracyGeo + " | Properties-Precision = " + this._accuracyProps);
        }
        // Check file integrity
        var body_len = this._byteData.readUnsignedInt();
        if (!this._streaming && body_len != this._byteData.getBytesAvailable())
            this._pDieWithError('AWD2 body length does not match header integrity field');
    };
    // Helper - functions
    AWDParser.prototype.getUVForVertexAnimation = function (spriteID /*uint*/) {
        if (this._blocks[spriteID].data instanceof _awayjs_scene.Sprite)
            spriteID = this._blocks[spriteID].geoID;
        if (this._blocks[spriteID].uvsForVertexAnimation)
            return this._blocks[spriteID].uvsForVertexAnimation;
        var graphics = this._blocks[spriteID].data;
        var elements;
        var uvsForVertexAnimation = this._blocks[spriteID].uvsForVertexAnimation = new Array();
        var len = graphics.count;
        for (var geoCnt = 0; geoCnt < len; geoCnt++) {
            elements = graphics.getShapeAt(geoCnt).elements;
            uvsForVertexAnimation[geoCnt] = elements.uvs.get(elements.numVertices);
        }
        return this._blocks[spriteID].uvsForVertexAnimation;
    };
    AWDParser.prototype.parseVarStr = function () {
        return this._newBlockBytes.readUTFBytes(this._newBlockBytes.readUnsignedShort());
    };
    AWDParser.prototype.readNumber = function (precision) {
        if (precision === void 0) { precision = false; }
        if (precision)
            return this._newBlockBytes.readDouble();
        return this._newBlockBytes.readFloat();
    };
    AWDParser.prototype.parseMatrix3D = function () {
        return new _awayjs_core.Matrix3D(this.parseMatrix43RawData());
    };
    AWDParser.prototype.parseMatrix32RawData = function () {
        var mtx_raw = new Float32Array(6);
        for (var i = 0; i < 6; i++)
            mtx_raw[i] = this._newBlockBytes.readFloat();
        return mtx_raw;
    };
    AWDParser.prototype.parseMatrix43RawData = function () {
        var mtx_raw = new Float32Array(16);
        mtx_raw[0] = this.readNumber(this._accuracyMatrix);
        mtx_raw[1] = this.readNumber(this._accuracyMatrix);
        mtx_raw[2] = this.readNumber(this._accuracyMatrix);
        mtx_raw[3] = 0.0;
        mtx_raw[4] = this.readNumber(this._accuracyMatrix);
        mtx_raw[5] = this.readNumber(this._accuracyMatrix);
        mtx_raw[6] = this.readNumber(this._accuracyMatrix);
        mtx_raw[7] = 0.0;
        mtx_raw[8] = this.readNumber(this._accuracyMatrix);
        mtx_raw[9] = this.readNumber(this._accuracyMatrix);
        mtx_raw[10] = this.readNumber(this._accuracyMatrix);
        mtx_raw[11] = 0.0;
        mtx_raw[12] = this.readNumber(this._accuracyMatrix);
        mtx_raw[13] = this.readNumber(this._accuracyMatrix);
        mtx_raw[14] = this.readNumber(this._accuracyMatrix);
        mtx_raw[15] = 1.0;
        //TODO: fix max exporter to remove NaN values in joint 0 inverse bind pose
        if (isNaN(mtx_raw[0])) {
            mtx_raw[0] = 1;
            mtx_raw[1] = 0;
            mtx_raw[2] = 0;
            mtx_raw[4] = 0;
            mtx_raw[5] = 1;
            mtx_raw[6] = 0;
            mtx_raw[8] = 0;
            mtx_raw[9] = 0;
            mtx_raw[10] = 1;
            mtx_raw[12] = 0;
            mtx_raw[13] = 0;
            mtx_raw[14] = 0;
        }
        return mtx_raw;
    };
    return AWDParser;
}(_awayjs_core.ParserBase));
AWDParser.COMPRESSIONMODE_LZMA = "lzma";
AWDParser.UNCOMPRESSED = 0;
AWDParser.DEFLATE = 1;
AWDParser.LZMA = 2;
AWDParser.INT8 = 1;
AWDParser.INT16 = 2;
AWDParser.INT32 = 3;
AWDParser.UINT8 = 4;
AWDParser.UINT16 = 5;
AWDParser.UINT32 = 6;
AWDParser.FLOAT32 = 7;
AWDParser.FLOAT64 = 8;
AWDParser.BOOL = 21;
AWDParser.COLOR = 22;
AWDParser.BADDR = 23;
AWDParser.AWDSTRING = 31;
AWDParser.AWDBYTEARRAY = 32;
AWDParser.VECTOR2x1 = 41;
AWDParser.VECTOR3x1 = 42;
AWDParser.VECTOR4x1 = 43;
AWDParser.MTX3x2 = 44;
AWDParser.MTX3x3 = 45;
AWDParser.MTX4x3 = 46;
AWDParser.MTX4x4 = 47;
AWDParser.GEO_NUMBER = 48;
AWDParser.MATRIX_NUMBER = 49;
AWDParser.PROPERTY_NUMBER = 50;
AWDParser.textFormatProperties = {
    1: AWDParser.UINT16,
    2: AWDParser.FLOAT32,
    3: AWDParser.UINT8,
    4: AWDParser.UINT8,
    5: AWDParser.UINT8,
    6: AWDParser.UINT8,
    7: AWDParser.FLOAT32,
    8: AWDParser.FLOAT32,
    9: AWDParser.FLOAT32,
    10: AWDParser.FLOAT32,
    11: AWDParser.COLOR
}; //line spacing
AWDParser.textFieldProperties = {
    1: AWDParser.BOOL,
    3: AWDParser.BOOL,
    4: AWDParser.BOOL,
    5: AWDParser.BOOL,
    7: AWDParser.UINT8,
    8: AWDParser.UINT8,
    9: AWDParser.UINT8
};
AWDParser.textFieldTypes = ["static", "dynamic", "input", "input"];
AWDParser.spriteLibraryProperties = {
    1: AWDParser.FLOAT32,
    2: AWDParser.FLOAT32,
    3: AWDParser.FLOAT32,
    4: AWDParser.FLOAT32
};
AWDParser.movieClipProperties = {
    1: AWDParser.FLOAT32,
    2: AWDParser.UINT16,
    3: AWDParser.UINT8,
    4: AWDParser.UINT8 // isScale9SliceMC
};
AWDParser.graphicsProperties = {
    1: AWDParser.GEO_NUMBER,
    2: AWDParser.GEO_NUMBER
};
AWDParser.elementsProperties = {
    1: AWDParser.GEO_NUMBER,
    2: AWDParser.GEO_NUMBER
};
AWDParser.primitiveProperties = {
    101: AWDParser.GEO_NUMBER,
    102: AWDParser.GEO_NUMBER,
    103: AWDParser.GEO_NUMBER,
    110: AWDParser.GEO_NUMBER,
    111: AWDParser.GEO_NUMBER,
    301: AWDParser.UINT16,
    302: AWDParser.UINT16,
    303: AWDParser.UINT16,
    701: AWDParser.BOOL,
    702: AWDParser.BOOL,
    703: AWDParser.BOOL,
    704: AWDParser.BOOL
};
AWDParser.primitiveTypes = ["Unsupported Type-ID", "PrimitivePlanePrefab", "PrimitiveCubePrefab", "PrimitiveSpherePrefab", "PrimitiveCylinderPrefab", "PrimitivesConePrefab", "PrimitivesCapsulePrefab", "PrimitivesTorusPrefab"];
AWDParser.containerProperties = {
    1: AWDParser.MATRIX_NUMBER,
    2: AWDParser.MATRIX_NUMBER,
    3: AWDParser.MATRIX_NUMBER,
    4: AWDParser.UINT8
};
AWDParser.spriteInstanceProperties = {
    1: AWDParser.MATRIX_NUMBER,
    2: AWDParser.MATRIX_NUMBER,
    3: AWDParser.MATRIX_NUMBER,
    4: AWDParser.UINT8,
    5: AWDParser.BOOL
};
AWDParser.lightProperties = {
    1: AWDParser.PROPERTY_NUMBER,
    2: AWDParser.PROPERTY_NUMBER,
    3: AWDParser.COLOR,
    4: AWDParser.PROPERTY_NUMBER,
    5: AWDParser.PROPERTY_NUMBER,
    6: AWDParser.BOOL,
    7: AWDParser.COLOR,
    8: AWDParser.PROPERTY_NUMBER,
    9: AWDParser.UINT8,
    10: AWDParser.UINT8,
    11: AWDParser.PROPERTY_NUMBER,
    12: AWDParser.UINT16,
    21: AWDParser.MATRIX_NUMBER,
    22: AWDParser.MATRIX_NUMBER,
    23: AWDParser.MATRIX_NUMBER
};
AWDParser.cameraProperties = {
    101: AWDParser.PROPERTY_NUMBER,
    102: AWDParser.PROPERTY_NUMBER,
    103: AWDParser.PROPERTY_NUMBER,
    104: AWDParser.PROPERTY_NUMBER
};
AWDParser.cameraPivotProperties = {
    1: AWDParser.MATRIX_NUMBER,
    2: AWDParser.MATRIX_NUMBER,
    3: AWDParser.MATRIX_NUMBER,
    4: AWDParser.UINT8
};
// (1=color, 2=bitmap url, 10=alpha, 11=alpha_blending, 12=alpha_threshold, 13=repeat)
AWDParser.materialProperties = {
    1: AWDParser.INT32,
    2: AWDParser.BADDR,
    10: AWDParser.PROPERTY_NUMBER,
    11: AWDParser.BOOL,
    12: AWDParser.PROPERTY_NUMBER,
    13: AWDParser.BOOL
};
AWDParser.material_v1Properties = { 1: AWDParser.UINT32,
    2: AWDParser.BADDR,
    3: AWDParser.BADDR,
    4: AWDParser.UINT8,
    5: AWDParser.BOOL,
    6: AWDParser.BOOL,
    7: AWDParser.BOOL,
    8: AWDParser.BOOL,
    9: AWDParser.UINT8,
    10: AWDParser.PROPERTY_NUMBER,
    11: AWDParser.BOOL,
    12: AWDParser.PROPERTY_NUMBER,
    13: AWDParser.BOOL,
    15: AWDParser.PROPERTY_NUMBER,
    16: AWDParser.UINT32,
    17: AWDParser.BADDR,
    18: AWDParser.PROPERTY_NUMBER,
    19: AWDParser.PROPERTY_NUMBER,
    20: AWDParser.UINT32,
    21: AWDParser.BADDR,
    22: AWDParser.BADDR };
AWDParser.method_v1Properties = {
    1: AWDParser.BADDR,
    2: AWDParser.BADDR,
    3: AWDParser.BADDR,
    101: AWDParser.PROPERTY_NUMBER,
    102: AWDParser.PROPERTY_NUMBER,
    103: AWDParser.PROPERTY_NUMBER,
    201: AWDParser.UINT32,
    202: AWDParser.UINT32,
    301: AWDParser.UINT16,
    302: AWDParser.UINT16,
    401: AWDParser.UINT8,
    402: AWDParser.UINT8,
    601: AWDParser.COLOR,
    602: AWDParser.COLOR,
    701: AWDParser.BOOL,
    702: AWDParser.BOOL,
    801: AWDParser.MTX4x4
};
AWDParser.commandProperties = {
    1: AWDParser.BADDR
};
AWDParser.targetProperties = {
    1: AWDParser.MATRIX_NUMBER,
    2: AWDParser.MATRIX_NUMBER,
    3: AWDParser.MATRIX_NUMBER,
    4: AWDParser.UINT8
};
AWDParser.metaDataProperties = {
    1: AWDParser.UINT32,
    2: AWDParser.AWDSTRING,
    3: AWDParser.AWDSTRING,
    4: AWDParser.AWDSTRING,
    5: AWDParser.AWDSTRING
};
AWDParser.vertexAnimationSetProperties = {
    1: AWDParser.UINT16
};
AWDParser.animatorSetProperties = { 1: AWDParser.BADDR };
var ElementType = (function () {
    function ElementType() {
    }
    return ElementType;
}());
ElementType.STANDART_STREAMS = 0;
ElementType.CONCENATED_STREAMS = 1;
ElementType.SHARED_BUFFER = 2;
ElementType.CONCATENATED_SUBGEO = 3;
ElementType.SHARED_INDEXBUFFER = 4;
ElementType.CONCENATED_STREAMS_UINT16 = 5;
ElementType.STROKE_DATA = 6;
var AWDProperties = (function () {
    function AWDProperties() {
    }
    AWDProperties.prototype.set = function (key, value) {
        this[key] = value;
    };
    AWDProperties.prototype.get = function (key, fallback) {
        return this.hasOwnProperty(key.toString()) ? this[key] : fallback;
    };
    return AWDProperties;
}());
/**
 *
 */
var BitFlags = (function () {
    function BitFlags() {
    }
    BitFlags.test = function (flags, testFlag) {
        return (flags & testFlag) == testFlag;
    };
    return BitFlags;
}());
BitFlags.FLAG1 = 1;
BitFlags.FLAG2 = 2;
BitFlags.FLAG3 = 4;
BitFlags.FLAG4 = 8;
BitFlags.FLAG5 = 16;
BitFlags.FLAG6 = 32;
BitFlags.FLAG7 = 64;
BitFlags.FLAG8 = 128;
BitFlags.FLAG9 = 256;
BitFlags.FLAG10 = 512;
BitFlags.FLAG11 = 1024;
BitFlags.FLAG12 = 2048;
BitFlags.FLAG13 = 4096;
BitFlags.FLAG14 = 8192;
BitFlags.FLAG15 = 16384;
BitFlags.FLAG16 = 32768;

/**
 * Max3DSParser provides a parser for the 3ds data type.
 */
var Max3DSParser = (function (_super) {
    __extends(Max3DSParser, _super);
    /**
     * Creates a new <code>Max3DSParser</code> object.
     *
     * @param useSmoothingGroups Determines whether the parser looks for smoothing groups in the 3ds file or assumes uniform smoothing. Defaults to true.
     */
    function Max3DSParser(useSmoothingGroups) {
        if (useSmoothingGroups === void 0) { useSmoothingGroups = true; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.ARRAY_BUFFER) || this;
        _this._useSmoothingGroups = useSmoothingGroups;
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    Max3DSParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "3ds";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    Max3DSParser.supportsData = function (data) {
        var ba;
        try {
            //TODO!!!: crashes when trying to check against AudioData
            ba = _awayjs_core.ParserUtils.toByteArray(data);
            if (ba) {
                ba.position = 0;
                if (ba.readShort() == 0x4d4d)
                    return true;
            }
        }
        catch (err) {
            return false;
        }
        return false;
    };
    /**
     * @inheritDoc
     */
    Max3DSParser.prototype._iResolveDependency = function (resourceDependency) {
        if (resourceDependency.assets.length == 1) {
            var asset;
            asset = resourceDependency.assets[0];
            if (asset.isAsset(_awayjs_graphics.BitmapImage2D)) {
                var tex;
                tex = this._textures[resourceDependency.id];
                tex.texture = new _awayjs_graphics.Single2DTexture(asset);
            }
        }
    };
    /**
     * @inheritDoc
     */
    Max3DSParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
        // TODO: Implement
    };
    /**
     * @inheritDoc
     */
    Max3DSParser.prototype._pProceedParsing = function () {
        if (!this._byteData) {
            this._byteData = this._pGetByteData();
            this._byteData.position = 0;
            //----------------------------------------------------------------------------
            // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
            //----------------------------------------------------------------------------
            //this._byteData.endian = Endian.LITTLE_ENDIAN;// Should be default
            //----------------------------------------------------------------------------
            this._textures = {};
            this._materials = {};
            this._unfinalized_objects = {};
        }
        // TODO: With this construct, the loop will run no-op for as long
        // as there is time once file has finished reading. Consider a nice
        // way to stop loop when byte array is empty, without putting it in
        // the while-conditional, which will prevent finalizations from
        // happening after the last chunk.
        while (this._pHasTime()) {
            // If we are currently working on an object, and the most recent chunk was
            // the last one in that object, finalize the current object.
            if (this._cur_mat && this._byteData.position >= this._cur_mat_end)
                this.finalizeCurrentMaterial();
            else if (this._cur_obj && this._byteData.position >= this._cur_obj_end) {
                // Can't finalize at this point, because we have to wait until the full
                // animation section has been parsed for any potential pivot definitions
                this._unfinalized_objects[this._cur_obj.name] = this._cur_obj;
                this._cur_obj_end = Number.MAX_VALUE /*uint*/;
                this._cur_obj = null;
            }
            if (this._byteData.getBytesAvailable() > 0) {
                var cid;
                var len;
                var end;
                cid = this._byteData.readUnsignedShort();
                len = this._byteData.readUnsignedInt();
                end = this._byteData.position + (len - 6);
                switch (cid) {
                    case 0x4D4D: // MAIN3DS
                    case 0x3D3D: // EDIT3DS
                    case 0xB000:
                        // This types are "container chunks" and contain only
                        // sub-chunks (no data on their own.) This means that
                        // there is nothing more to parse at this point, and
                        // instead we should progress to the next chunk, which
                        // will be the first sub-chunk of this one.
                        continue;
                    case 0xAFFF:
                        this._cur_mat_end = end;
                        this._cur_mat = this.parseMaterial();
                        break;
                    case 0x4000:
                        this._cur_obj_end = end;
                        this._cur_obj = new ObjectVO();
                        this._cur_obj.name = this.readNulTermstring();
                        this._cur_obj.materials = new Array();
                        this._cur_obj.materialFaces = {};
                        break;
                    case 0x4100:
                        this._cur_obj.type = _awayjs_scene.Sprite.assetType;
                        break;
                    case 0x4110:
                        this.parseVertexList();
                        break;
                    case 0x4120:
                        this.parseFaceList();
                        break;
                    case 0x4140:
                        this.parseUVList();
                        break;
                    case 0x4130:
                        this.parseFaceMaterialList();
                        break;
                    case 0x4160:
                        this._cur_obj.transform = this.readTransform();
                        break;
                    case 0xB002:
                        this.parseObjectAnimation(end);
                        break;
                    case 0x4150:
                        this.parseSmoothingGroups();
                        break;
                    default:
                        // Skip this (unknown) chunk
                        this._byteData.position += (len - 6);
                        break;
                }
                // Pause parsing if there were any dependencies found during this
                // iteration (i.e. if there are any dependencies that need to be
                // retrieved at this time.)
                if (this.dependencies.length) {
                    this._pPauseAndRetrieveDependencies();
                    break;
                }
            }
        }
        // More parsing is required if the entire byte array has not yet
        // been read, or if there is a currently non-finalized object in
        // the pipeline.
        if (this._byteData.getBytesAvailable() || this._cur_obj || this._cur_mat) {
            return _awayjs_core.ParserBase.MORE_TO_PARSE;
        }
        else {
            var name;
            // Finalize any remaining objects before ending.
            for (name in this._unfinalized_objects) {
                var obj;
                obj = this.constructObject(this._unfinalized_objects[name]);
                if (obj) {
                    //add to the content property
                    this._pContent.addChild(obj);
                    this._pFinalizeAsset(obj, name);
                }
            }
            return _awayjs_core.ParserBase.PARSING_DONE;
        }
    };
    Max3DSParser.prototype._pStartParsing = function (frameLimit) {
        //create a content object for Loaders
        this._pContent = new _awayjs_scene.DisplayObjectContainer();
        _super.prototype._pStartParsing.call(this, frameLimit);
    };
    Max3DSParser.prototype.parseMaterial = function () {
        var mat;
        mat = new MaterialVO();
        while (this._byteData.position < this._cur_mat_end) {
            var cid;
            var len;
            var end;
            cid = this._byteData.readUnsignedShort();
            len = this._byteData.readUnsignedInt();
            end = this._byteData.position + (len - 6);
            switch (cid) {
                case 0xA000:
                    mat.name = this.readNulTermstring();
                    break;
                case 0xA010:
                    mat.ambientColor = this.readColor();
                    break;
                case 0xA020:
                    mat.diffuseColor = this.readColor();
                    break;
                case 0xA030:
                    mat.specularColor = this.readColor();
                    break;
                case 0xA081:
                    mat.twoSided = true;
                    break;
                case 0xA200:
                    mat.colorMap = this.parseTexture(end);
                    break;
                case 0xA204:
                    mat.specularMap = this.parseTexture(end);
                    break;
                default:
                    this._byteData.position = end;
                    break;
            }
        }
        return mat;
    };
    Max3DSParser.prototype.parseTexture = function (end /*uint*/) {
        var tex;
        tex = new TextureVO();
        while (this._byteData.position < end) {
            var cid;
            var len;
            cid = this._byteData.readUnsignedShort();
            len = this._byteData.readUnsignedInt();
            switch (cid) {
                case 0xA300:
                    tex.url = this.readNulTermstring();
                    break;
                default:
                    // Skip this unknown texture sub-chunk
                    this._byteData.position += (len - 6);
                    break;
            }
        }
        this._textures[tex.url] = tex;
        this._pAddDependency(tex.url, new _awayjs_core.URLRequest(tex.url));
        return tex;
    };
    Max3DSParser.prototype.parseVertexList = function () {
        var i;
        var len;
        var count;
        count = this._byteData.readUnsignedShort();
        this._cur_obj.verts = new Array(count * 3);
        i = 0;
        len = this._cur_obj.verts.length;
        while (i < len) {
            var x, y, z;
            x = this._byteData.readFloat();
            y = this._byteData.readFloat();
            z = this._byteData.readFloat();
            this._cur_obj.verts[i++] = x;
            this._cur_obj.verts[i++] = z;
            this._cur_obj.verts[i++] = y;
        }
    };
    Max3DSParser.prototype.parseFaceList = function () {
        var i;
        var len;
        var count;
        count = this._byteData.readUnsignedShort();
        this._cur_obj.indices = new Array(count * 3) /*uint*/;
        i = 0;
        len = this._cur_obj.indices.length;
        while (i < len) {
            var i0 /*uint*/, i1 /*uint*/, i2;
            i0 = this._byteData.readUnsignedShort();
            i1 = this._byteData.readUnsignedShort();
            i2 = this._byteData.readUnsignedShort();
            this._cur_obj.indices[i++] = i0;
            this._cur_obj.indices[i++] = i2;
            this._cur_obj.indices[i++] = i1;
            // Skip "face info", irrelevant in Away3D
            this._byteData.position += 2;
        }
        this._cur_obj.smoothingGroups = new Array(count) /*uint*/;
    };
    Max3DSParser.prototype.parseSmoothingGroups = function () {
        var len = this._cur_obj.indices.length / 3;
        var i = 0;
        while (i < len) {
            this._cur_obj.smoothingGroups[i] = this._byteData.readUnsignedInt();
            i++;
        }
    };
    Max3DSParser.prototype.parseUVList = function () {
        var i;
        var len;
        var count;
        count = this._byteData.readUnsignedShort();
        this._cur_obj.uvs = new Array(count * 2);
        i = 0;
        len = this._cur_obj.uvs.length;
        while (i < len) {
            this._cur_obj.uvs[i++] = this._byteData.readFloat();
            this._cur_obj.uvs[i++] = 1.0 - this._byteData.readFloat();
        }
    };
    Max3DSParser.prototype.parseFaceMaterialList = function () {
        var mat;
        var count;
        var i;
        var faces;
        mat = this.readNulTermstring();
        count = this._byteData.readUnsignedShort();
        faces = new Array(count) /*uint*/;
        i = 0;
        while (i < faces.length)
            faces[i++] = this._byteData.readUnsignedShort();
        this._cur_obj.materials.push(mat);
        this._cur_obj.materialFaces[mat] = faces;
    };
    Max3DSParser.prototype.parseObjectAnimation = function (end) {
        var vo;
        var obj;
        var pivot;
        var name;
        var hier;
        // Pivot defaults to origin
        pivot = new _awayjs_core.Vector3D;
        while (this._byteData.position < end) {
            var cid;
            var len;
            cid = this._byteData.readUnsignedShort();
            len = this._byteData.readUnsignedInt();
            switch (cid) {
                case 0xb010:
                    name = this.readNulTermstring();
                    this._byteData.position += 4;
                    hier = this._byteData.readShort();
                    break;
                case 0xb013:
                    pivot.x = this._byteData.readFloat();
                    pivot.z = this._byteData.readFloat();
                    pivot.y = this._byteData.readFloat();
                    break;
                default:
                    this._byteData.position += (len - 6);
                    break;
            }
        }
        // If name is "$$$DUMMY" this is an empty object (e.g. a container)
        // and will be ignored in this version of the parser
        // TODO: Implement containers in 3DS parser.
        if (name != '$$$DUMMY' && this._unfinalized_objects.hasOwnProperty(name)) {
            vo = this._unfinalized_objects[name];
            obj = this.constructObject(vo, pivot);
            if (obj) {
                //add to the content property
                this._pContent.addChild(obj);
                this._pFinalizeAsset(obj, vo.name);
            }
            delete this._unfinalized_objects[name];
        }
    };
    Max3DSParser.prototype.constructObject = function (obj, pivot) {
        if (pivot === void 0) { pivot = null; }
        if (obj.type == _awayjs_scene.Sprite.assetType) {
            var i;
            var sub;
            var graphics;
            var mat;
            var sprite;
            var mtx;
            var vertices;
            var faces;
            if (obj.materials.length > 1)
                console.log("The Away3D 3DS parser does not support multiple materials per sprite at this point.");
            // Ignore empty objects
            if (!obj.indices || obj.indices.length == 0)
                return null;
            vertices = new Array(obj.verts.length / 3);
            faces = new Array(obj.indices.length / 3);
            this.prepareData(vertices, faces, obj);
            if (this._useSmoothingGroups)
                this.applySmoothGroups(vertices, faces);
            obj.verts = new Array(vertices.length * 3);
            for (i = 0; i < vertices.length; i++) {
                obj.verts[i * 3] = vertices[i].x;
                obj.verts[i * 3 + 1] = vertices[i].y;
                obj.verts[i * 3 + 2] = vertices[i].z;
            }
            obj.indices = new Array(faces.length * 3) /*uint*/;
            for (i = 0; i < faces.length; i++) {
                obj.indices[i * 3] = faces[i].a;
                obj.indices[i * 3 + 1] = faces[i].b;
                obj.indices[i * 3 + 2] = faces[i].c;
            }
            if (obj.uvs) {
                // If the object had UVs to start with, use UVs generated by
                // smoothing group splitting algorithm. Otherwise those UVs
                // will be nonsense and should be skipped.
                obj.uvs = new Array(vertices.length * 2);
                for (i = 0; i < vertices.length; i++) {
                    obj.uvs[i * 2] = vertices[i].u;
                    obj.uvs[i * 2 + 1] = vertices[i].v;
                }
            }
            if (obj.materials.length > 0) {
                var mname;
                mname = obj.materials[0];
                mat = this._materials[mname].material;
            }
            // Build sprite and return it
            sprite = new _awayjs_scene.Sprite(mat);
            sprite.transform.matrix3D = new _awayjs_core.Matrix3D(obj.transform);
            graphics = sprite.graphics;
            // Construct elements (potentially splitting buffers)
            // and add them to graphics.
            sub = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
            sub.setIndices(obj.indices);
            sub.setPositions(obj.verts);
            sub.setUVs(obj.uvs);
            graphics.addShape(new _awayjs_graphics.Shape(sub));
            // Apply pivot translation to graphics if a pivot was
            // found while parsing the keyframe chunk earlier.
            if (pivot) {
                if (obj.transform) {
                    // If a transform was found while parsing the
                    // object chunk, use it to find the local pivot vector
                    mtx = new _awayjs_core.Matrix3D();
                    mtx.copyRawDataFrom(obj.transform);
                    mtx._rawData[12] = 0;
                    mtx._rawData[13] = 0;
                    mtx._rawData[14] = 0;
                    pivot = mtx.transformVector(pivot);
                }
                pivot.scaleBy(-1);
                mtx = new _awayjs_core.Matrix3D();
                mtx.appendTranslation(pivot.x, pivot.y, pivot.z);
                graphics.applyTransformation(mtx);
            }
            // Apply transformation to graphics if a transformation
            // was found while parsing the object chunk earlier.
            if (obj.transform) {
                mtx = new _awayjs_core.Matrix3D();
                mtx.copyRawDataFrom(obj.transform);
                mtx.invert();
                graphics.applyTransformation(mtx);
            }
            // Final transform applied to graphics. Finalize the graphics,
            // which will no longer be modified after this point.
            this._pFinalizeAsset(graphics, obj.name.concat('_graphics'));
            return sprite;
        }
        // If reached, unknown
        return null;
    };
    Max3DSParser.prototype.prepareData = function (vertices, faces, obj) {
        // convert raw ObjectVO's data to structured VertexVO and FaceVO
        var i;
        var j;
        var k;
        var len = obj.verts.length;
        for (i = 0, j = 0, k = 0; i < len;) {
            var v = new VertexVO;
            v.x = obj.verts[i++];
            v.y = obj.verts[i++];
            v.z = obj.verts[i++];
            if (obj.uvs) {
                v.u = obj.uvs[j++];
                v.v = obj.uvs[j++];
            }
            vertices[k++] = v;
        }
        len = obj.indices.length;
        for (i = 0, k = 0; i < len;) {
            var f = new FaceVO();
            f.a = obj.indices[i++];
            f.b = obj.indices[i++];
            f.c = obj.indices[i++];
            f.smoothGroup = obj.smoothingGroups[k] || 0;
            faces[k++] = f;
        }
    };
    Max3DSParser.prototype.applySmoothGroups = function (vertices, faces) {
        // clone vertices according to following rule:
        // clone if vertex's in faces from groups 1+2 and 3
        // don't clone if vertex's in faces from groups 1+2, 3 and 1+3
        var i;
        var j;
        var k;
        var l;
        var len;
        var numVerts = vertices.length;
        var numFaces = faces.length;
        // extract groups data for vertices
        var vGroups = new Array(numVerts);
        for (i = 0; i < numVerts; i++)
            vGroups[i] = new Array() /*uint*/;
        for (i = 0; i < numFaces; i++) {
            var face = faces[i];
            for (j = 0; j < 3; j++) {
                var groups = vGroups[(j == 0) ? face.a : ((j == 1) ? face.b : face.c)];
                var group = face.smoothGroup;
                for (k = groups.length - 1; k >= 0; k--) {
                    if ((group & groups[k]) > 0) {
                        group |= groups[k];
                        groups.splice(k, 1);
                        k = groups.length - 1;
                    }
                }
                groups.push(group);
            }
        }
        // clone vertices
        var vClones = new Array(numVerts);
        for (i = 0; i < numVerts; i++) {
            if ((len = vGroups[i].length) < 1)
                continue;
            var clones = new Array(len);
            vClones[i] = clones;
            clones[0] = i;
            var v0 = vertices[i];
            for (j = 1; j < len; j++) {
                var v1 = new VertexVO;
                v1.x = v0.x;
                v1.y = v0.y;
                v1.z = v0.z;
                v1.u = v0.u;
                v1.v = v0.v;
                clones[j] = vertices.length;
                vertices.push(v1);
            }
        }
        numVerts = vertices.length;
        for (i = 0; i < numFaces; i++) {
            face = faces[i];
            group = face.smoothGroup;
            for (j = 0; j < 3; j++) {
                k = (j == 0) ? face.a : ((j == 1) ? face.b : face.c);
                groups = vGroups[k];
                len = groups.length;
                clones = vClones[k];
                for (l = 0; l < len; l++) {
                    if (((group == 0) && (groups[l] == 0)) || ((group & groups[l]) > 0)) {
                        var index = clones[l];
                        if (group == 0) {
                            // vertex is unique if no smoothGroup found
                            groups.splice(l, 1);
                            clones.splice(l, 1);
                        }
                        if (j == 0)
                            face.a = index;
                        else if (j == 1)
                            face.b = index;
                        else
                            face.c = index;
                        l = len;
                    }
                }
            }
        }
    };
    Max3DSParser.prototype.finalizeCurrentMaterial = function () {
        var mat;
        mat = new _awayjs_materials.MethodMaterial(this._cur_mat.ambientColor);
        if (this._cur_mat.colorMap)
            mat.ambientMethod.texture = this._cur_mat.colorMap.texture || _awayjs_graphics.DefaultMaterialManager.getDefaultTexture();
        mat.diffuseMethod.color = this._cur_mat.diffuseColor;
        mat.specularMethod.color = this._cur_mat.specularColor;
        if (this.materialMode >= 2)
            mat.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
        mat.bothSides = this._cur_mat.twoSided;
        this._pFinalizeAsset(mat, this._cur_mat.name);
        this._materials[this._cur_mat.name] = this._cur_mat;
        this._cur_mat.material = mat;
        this._cur_mat = null;
    };
    Max3DSParser.prototype.readNulTermstring = function () {
        var chr;
        var str = "";
        while ((chr = this._byteData.readUnsignedByte()) > 0)
            str += String.fromCharCode(chr);
        return str;
    };
    Max3DSParser.prototype.readTransform = function () {
        var data = new Float32Array(16);
        // X axis
        data[0] = this._byteData.readFloat(); // X
        data[2] = this._byteData.readFloat(); // Z
        data[1] = this._byteData.readFloat(); // Y
        data[3] = 0;
        // Z axis
        data[8] = this._byteData.readFloat(); // X
        data[10] = this._byteData.readFloat(); // Z
        data[9] = this._byteData.readFloat(); // Y
        data[11] = 0;
        // Y Axis
        data[4] = this._byteData.readFloat(); // X
        data[6] = this._byteData.readFloat(); // Z
        data[5] = this._byteData.readFloat(); // Y
        data[7] = 0;
        // Translation
        data[12] = this._byteData.readFloat(); // X
        data[14] = this._byteData.readFloat(); // Z
        data[13] = this._byteData.readFloat(); // Y
        data[15] = 1;
        return data;
    };
    Max3DSParser.prototype.readColor = function () {
        var cid;
        var len;
        var r /*int*/, g /*int*/, b;
        cid = this._byteData.readUnsignedShort();
        len = this._byteData.readUnsignedInt();
        switch (cid) {
            case 0x0010:
                r = this._byteData.readFloat() * 255;
                g = this._byteData.readFloat() * 255;
                b = this._byteData.readFloat() * 255;
                break;
            case 0x0011:
                r = this._byteData.readUnsignedByte();
                g = this._byteData.readUnsignedByte();
                b = this._byteData.readUnsignedByte();
                break;
            default:
                this._byteData.position += (len - 6);
                break;
        }
        return (r << 16) | (g << 8) | b;
    };
    return Max3DSParser;
}(_awayjs_core.ParserBase));
/**
 *
 */
var FaceVO = (function () {
    function FaceVO() {
    }
    return FaceVO;
}());
/**
 *
 */
var MaterialVO = (function () {
    function MaterialVO() {
    }
    return MaterialVO;
}());
/**
 *
 */
var ObjectVO = (function () {
    function ObjectVO() {
    }
    return ObjectVO;
}());
/**
 *
 */
var TextureVO = (function () {
    function TextureVO() {
    }
    return TextureVO;
}());
/**
 *
 */
var VertexVO = (function () {
    function VertexVO() {
    }
    return VertexVO;
}());

/**
 * TextureAtlasParser provides a "parser" for natively supported image types (jpg, png). While it simply loads bytes into
 * a loader object, it wraps it in a BitmapImage2DResource so resource management can happen consistently without
 * exception cases.
 */
var FNTParser = (function (_super) {
    __extends(FNTParser, _super);
    /**
     * Creates a new TextureAtlasParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function FNTParser() {
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.TEXT) || this;
        _this._parseState = 0;
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    FNTParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "fnt";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    FNTParser.supportsData = function (data) {
        try {
            var content = _awayjs_core.ParserUtils.toString(data);
            if (content.indexOf("font") != -1 || content.indexOf("Font") != -1) {
                //console.log("supportsData fnt");
                return true;
            }
            return false;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * @inheritDoc
     */
    FNTParser.prototype._iResolveDependency = function (resourceDependency) {
        if (resourceDependency.assets.length) {
            var asset = resourceDependency.assets[0];
            asset.width = this._bitmapFontTable.texture_width;
            asset.height = this._bitmapFontTable.texture_height;
            var mat = new _awayjs_materials.MethodMaterial(asset);
            mat.bothSides = true;
            mat.alphaBlending = true;
            mat.useColorTransform = true;
            mat.style.sampler = new _awayjs_graphics.Sampler2D(false, true, true);
            this._bitmapFontTable.addMaterial(mat);
            this._pFinalizeAsset(resourceDependency.assets[0]);
            this._pFinalizeAsset(mat);
            this._parseState = FNTParserState.PARSE_CHARS;
        }
        else {
            this._parseState = FNTParserState.PARSE_COMPLETE;
        }
    };
    /**
     * @inheritDoc
     */
    FNTParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
        this._parseState = FNTParserState.PARSE_COMPLETE;
    };
    /**
     * @inheritDoc
     */
    FNTParser.prototype._pProceedParsing = function () {
        var nodes;
        switch (this._parseState) {
            case FNTParserState.PARSE_XML:
                try {
                    this._doc = _awayjs_core.XmlUtils.getChildrenWithTag(_awayjs_core.XmlUtils.strToXml(this._pGetTextData()), "font")[0];
                    var page_node = _awayjs_core.XmlUtils.getChildrenWithTag(this._doc, "pages")[0];
                    var all_pages = _awayjs_core.XmlUtils.getChildrenWithTag(page_node, "page");
                    var len = all_pages.length;
                    // todo: correctly support multiple pages
                    for (var i = 0; i < len; i++) {
                        this._imagePath = _awayjs_core.XmlUtils.readAttributeValue(all_pages[i], "file");
                    }
                    var char_node = _awayjs_core.XmlUtils.getChildrenWithTag(this._doc, "chars")[0];
                    this._chars = _awayjs_core.XmlUtils.getChildrenWithTag(char_node, "char");
                    this._parseState = FNTParserState.PARSE_IMAGE;
                    var info_node = _awayjs_core.XmlUtils.getChildrenWithTag(this._doc, "info")[0];
                    var common_node = _awayjs_core.XmlUtils.getChildrenWithTag(this._doc, "common")[0];
                    var font_name = _awayjs_core.XmlUtils.readAttributeValue(info_node, "face");
                    //this._font = <Font>AssetLibrary.getAsset(font_name);
                    //if(this._font==undefined){
                    this._font = new _awayjs_scene.Font();
                    this._font.name = font_name;
                    //}
                    var bold = _awayjs_core.XmlUtils.readAttributeValue(info_node, "bold");
                    if (bold != "0")
                        font_name += "_bold";
                    var italic = _awayjs_core.XmlUtils.readAttributeValue(info_node, "italic");
                    if (italic != "0")
                        font_name += "_italic";
                    this._bitmapFontTable = this._font.get_font_table(font_name, _awayjs_scene.BitmapFontTable.assetType);
                    var size = _awayjs_core.XmlUtils.readAttributeValue(info_node, "size");
                    this._bitmapFontTable._init_size = parseInt(size);
                    var scaleH = _awayjs_core.XmlUtils.readAttributeValue(common_node, "scaleH");
                    this._bitmapFontTable.texture_height = parseInt(scaleH);
                    var scaleW = _awayjs_core.XmlUtils.readAttributeValue(common_node, "scaleW");
                    this._bitmapFontTable.texture_width = parseInt(scaleW);
                    var adjustSize = _awayjs_core.XmlUtils.readAttributeValue(common_node, "adjustSize");
                    if (adjustSize != "")
                        this._bitmapFontTable._adjust_size = parseFloat(adjustSize);
                }
                catch (Error) {
                    return _awayjs_core.ParserBase.PARSING_DONE;
                }
                break;
            case FNTParserState.PARSE_IMAGE:
                if (this._imagePath) {
                    this._pAddDependency(this._imagePath, new _awayjs_core.URLRequest(this._imagePath));
                    this._pPauseAndRetrieveDependencies();
                }
                else {
                    return _awayjs_core.ParserBase.PARSING_DONE;
                }
                break;
            case FNTParserState.PARSE_CHARS:
                var element;
                var x, y, width, height, xoff, yoff, xadv, page, chnl;
                var id;
                var len = this._chars.length;
                for (var i = 0; i < len; i++) {
                    element = this._chars[i];
                    x = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "x"));
                    y = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "y"));
                    width = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "width"));
                    height = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "height"));
                    xoff = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "xoffset"));
                    yoff = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "yoffset"));
                    xadv = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "xadvance"));
                    page = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "page"));
                    chnl = parseInt(_awayjs_core.XmlUtils.readAttributeValue(element, "chnl"));
                    id = _awayjs_core.XmlUtils.readAttributeValue(element, "id");
                    this._bitmapFontTable.setChar(id, x, y, width, height, xoff, yoff, xadv, page, chnl);
                }
                this._pFinalizeAsset(this._font, this._font.name);
                this._parseState = FNTParserState.PARSE_COMPLETE;
                break;
            case FNTParserState.PARSE_COMPLETE:
                return _awayjs_core.ParserBase.PARSING_DONE;
        }
        return _awayjs_core.ParserBase.MORE_TO_PARSE;
    };
    return FNTParser;
}(_awayjs_core.ParserBase));
var FNTParserState = (function () {
    function FNTParserState() {
    }
    return FNTParserState;
}());
FNTParserState.PARSE_XML = 0;
FNTParserState.PARSE_IMAGE = 1;
FNTParserState.PARSE_CHARS = 2;
FNTParserState.PARSE_COMPLETE = 3;

var opentype;
/**
 * FontParser should parse Fonts into TesselatedFontTable for usage with webGL, or just load the Font as css class for usage with canvas and no webGL
 */
var FontParser = (function (_super) {
    __extends(FontParser, _super);
    /**
     * Creates a new TextureAtlasParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function FontParser(useWebGL) {
        if (useWebGL === void 0) { useWebGL = true; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.ARRAY_BUFFER) || this;
        _this._useWebGL = false;
        _this._useWebGL = useWebGL;
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    FontParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        var supports = ((extension == "ttf") || (extension == "otf"));
        if (supports) {
            console.log("FontParse encountered file with supported extension: = " + extension);
        }
        return ((extension == "ttf") || (extension == "otf"));
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    FontParser.supportsData = function (data) {
        console.log("ParserFont = " + _awayjs_core.ParserUtils.toString(data, 20));
        try {
            /*
            var content:string = ParserUtils.toString(data);
            if(content.indexOf("font") != -1 || content.indexOf("Font") != -1){
                console.log("supportsData fnt");
                return true;

            }
            */
            return true;
        }
        catch (e) {
            return false;
        }
    };
    /**
     * @inheritDoc
     */
    FontParser.prototype._iResolveDependency = function (resourceDependency) {
    };
    /**
     * @inheritDoc
     */
    FontParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
    };
    FontParser.prototype.sortKeys = function (dict) {
        var keys = [];
        for (var key in dict) {
            keys.push(key);
        }
        keys.sort();
        return keys;
    };
    /**
     * @inheritDoc
     */
    FontParser.prototype._pProceedParsing = function () {
        //console.log("proceed parsing = "+this._iFileName);
        opentype = window["opentype"];
        if (opentype) {
            //console.log("parsing font = "+this._iFileName+" / bytelength = "+this._pGetByteData().getBytesAvailable());
            var font_name = "";
            var font_style_name = "";
            var font = opentype.parse(this.data);
            var tablename, table, property, value, fontname;
            var head = font.tables.head;
            /*
            */
            for (tablename in font.tables) {
                table = font.tables[tablename];
                if (tablename == 'name') {
                    var properties = this.sortKeys(table);
                    for (var i = 0; i < properties.length; i++) {
                        var property = properties[i];
                        var translations = table[property];
                        var langs = this.sortKeys(translations);
                        for (var j = 0; j < langs.length; j++) {
                            var lang = langs[j];
                            if (property == "fontFamily") {
                                font_name = translations[lang];
                            }
                            else if (property == "fontSubfamily") {
                                font_style_name = translations[lang];
                            }
                            console.log("    " + property + ": " + lang + " : " + translations[lang]);
                        }
                    }
                }
            }
            if (font_name == "") {
                console.log("FontParser.ts '" + this._iFileName + "': Could not read fontname !!!");
            }
            if (font_style_name == "") {
                console.log("FontParser.ts '" + this._iFileName + "': Could not read font_style_name !!!");
            }
            var new_font = _awayjs_core.AssetLibrary.getAsset(font_name);
            var newfont = false;
            if (new_font == undefined) {
                new_font = new _awayjs_scene.Font();
                newfont = true;
            }
            new_font.name = font_name;
            var new_font_style = new_font.get_font_table(font_style_name, _awayjs_scene.TesselatedFontTable.assetType, font);
        }
        if (document) {
            var s = document.createElement('style');
            s.type = "text/css";
            document.getElementsByTagName('head')[0].appendChild(s);
            s.style.cssText = "@font-face {\
					font-family: ''" + this._iFileName + "';\
					src: url('" + this._iFileName + "');\
					};";
        }
        this._pFinalizeAsset(new_font, new_font.name);
        return _awayjs_core.ParserBase.PARSING_DONE;
    };
    return FontParser;
}(_awayjs_core.ParserBase));

/**
 * MD2Parser provides a parser for the MD2 data type.
 */
var MD2Parser = (function (_super) {
    __extends(MD2Parser, _super);
    /**
     * Creates a new MD2Parser object.
     * @param textureType The extension of the texture (e.g. jpg/png/...)
     * @param ignoreTexturePath If true, the path of the texture is ignored
     */
    function MD2Parser(textureType, ignoreTexturePath) {
        if (textureType === void 0) { textureType = "jpg"; }
        if (ignoreTexturePath === void 0) { ignoreTexturePath = true; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.ARRAY_BUFFER) || this;
        _this._clipNodes = new Object();
        // the current elements being built
        _this._animationSet = new _awayjs_renderer.VertexAnimationSet();
        _this.materialFinal = false;
        _this.graphicsCreated = false;
        _this._textureType = textureType;
        _this._ignoreTexturePath = ignoreTexturePath;
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    MD2Parser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "md2";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    MD2Parser.supportsData = function (data) {
        return (_awayjs_core.ParserUtils.toString(data, 4) == 'IDP2');
    };
    /**
     * @inheritDoc
     */
    MD2Parser.prototype._iResolveDependency = function (resourceDependency) {
        if (resourceDependency.assets.length != 1)
            return;
        var material = new _awayjs_materials.MethodMaterial(resourceDependency.assets[0]);
        if (this.materialMode >= 2)
            material.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
        //add to the content property
        this._pContent.addChild(this._sprite);
        material.name = this._sprite.material.name;
        this._sprite.material = material;
        this._pFinalizeAsset(material);
        this._pFinalizeAsset(this._sprite.graphics);
        this._pFinalizeAsset(this._sprite);
        this.materialFinal = true;
    };
    /**
     * @inheritDoc
     */
    MD2Parser.prototype._iResolveDependencyFailure = function (resourceDependency) {
        // apply system default
        if (this.materialMode < 2) {
            this._sprite.material = _awayjs_graphics.DefaultMaterialManager.getDefaultMaterial();
        }
        else {
            this._sprite.material = new _awayjs_materials.MethodMaterial(_awayjs_graphics.DefaultMaterialManager.getDefaultImage2D());
            this._sprite.material.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
        }
        //add to the content property
        this._pContent.addChild(this._sprite);
        this._pFinalizeAsset(this._sprite.graphics);
        this._pFinalizeAsset(this._sprite);
        this.materialFinal = true;
    };
    /**
     * @inheritDoc
     */
    MD2Parser.prototype._pProceedParsing = function () {
        if (!this._startedParsing) {
            this._byteData = this._pGetByteData();
            this._startedParsing = true;
            // Reset bytearray read position (which may have been
            // moved forward by the supportsData() function.)
            this._byteData.position = 0;
        }
        while (this._pHasTime()) {
            if (!this._parsedHeader) {
                //----------------------------------------------------------------------------
                // LITTLE_ENDIAN - Default for ArrayBuffer / Not implemented in ByteArray
                //----------------------------------------------------------------------------
                //this._byteData.endian = Endian.LITTLE_ENDIAN;
                // TODO: Create a sprite only when encountered (if it makes sense
                // for this file format) and return it using this._pFinalizeAsset()
                this._sprite = new _awayjs_scene.Sprite();
                this._graphics = this._sprite.graphics;
                if (this.materialMode < 2) {
                    this._sprite.material = _awayjs_graphics.DefaultMaterialManager.getDefaultMaterial();
                }
                else {
                    this._sprite.material = new _awayjs_materials.MethodMaterial(_awayjs_graphics.DefaultMaterialManager.getDefaultImage2D());
                    this._sprite.material.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
                }
                //_graphics.animation = new VertexAnimation(2, VertexAnimationMode.ABSOLUTE);
                //_animator = new VertexAnimator(VertexAnimationState(_sprite.animationState));
                // Parse header and decompress body
                this.parseHeader();
                this.parseMaterialNames();
            }
            else if (!this._parsedUV) {
                this.parseUV();
            }
            else if (!this._parsedFaces) {
                this.parseFaces();
            }
            else if (!this._parsedFrames) {
                this.parseFrames();
            }
            else if ((this.graphicsCreated) && (this.materialFinal)) {
                return _awayjs_core.ParserBase.PARSING_DONE;
            }
            else if (!this.graphicsCreated) {
                this.graphicsCreated = true;
                //create default subgraphics
                this._graphics.addShape(new _awayjs_graphics.Shape(this._firstElements.clone()));
                // Force name to be chosen by this._pFinalizeAsset()
                this._sprite.name = "";
                if (this.materialFinal) {
                    //add to the content property
                    this._pContent.addChild(this._sprite);
                    this._pFinalizeAsset(this._sprite.graphics);
                    this._pFinalizeAsset(this._sprite);
                }
                this._pPauseAndRetrieveDependencies();
            }
        }
        return _awayjs_core.ParserBase.MORE_TO_PARSE;
    };
    MD2Parser.prototype._pStartParsing = function (frameLimit) {
        //create a content object for Loaders
        this._pContent = new _awayjs_scene.DisplayObjectContainer();
        _super.prototype._pStartParsing.call(this, frameLimit);
    };
    /**
     * Reads in all that MD2 Header data that is declared as private variables.
     * I know its a lot, and it looks ugly, but only way to do it in Flash
     */
    MD2Parser.prototype.parseHeader = function () {
        this._ident = this._byteData.readInt();
        this._version = this._byteData.readInt();
        this._skinWidth = this._byteData.readInt();
        this._skinHeight = this._byteData.readInt();
        //skip this._frameSize
        this._byteData.readInt();
        this._numSkins = this._byteData.readInt();
        this._numVertices = this._byteData.readInt();
        this._numST = this._byteData.readInt();
        this._numTris = this._byteData.readInt();
        //skip this._numGlCmds
        this._byteData.readInt();
        this._numFrames = this._byteData.readInt();
        this._offsetSkins = this._byteData.readInt();
        this._offsetST = this._byteData.readInt();
        this._offsetTris = this._byteData.readInt();
        this._offsetFrames = this._byteData.readInt();
        //skip this._offsetGlCmds
        this._byteData.readInt();
        this._offsetEnd = this._byteData.readInt();
        this._parsedHeader = true;
    };
    /**
     * Parses the file names for the materials.
     */
    MD2Parser.prototype.parseMaterialNames = function () {
        var url;
        var name;
        var extIndex;
        var slashIndex;
        this._materialNames = new Array();
        this._byteData.position = this._offsetSkins;
        var regExp = new RegExp("[^a-zA-Z0-9\\_\/.]", "g");
        for (var i = 0; i < this._numSkins; ++i) {
            name = this._byteData.readUTFBytes(64);
            name = name.replace(regExp, "");
            extIndex = name.lastIndexOf(".");
            if (this._ignoreTexturePath)
                slashIndex = name.lastIndexOf("/");
            if (name.toLowerCase().indexOf(".jpg") == -1 && name.toLowerCase().indexOf(".png") == -1) {
                name = name.substring(slashIndex + 1, extIndex);
                url = name + "." + this._textureType;
            }
            else {
                url = name;
            }
            this._materialNames[i] = name;
            // only support 1 skin TODO: really?
            if (this.dependencies.length == 0)
                this._pAddDependency(name, new _awayjs_core.URLRequest(url));
        }
        if (this._materialNames.length > 0)
            this._sprite.material.name = this._materialNames[0];
        else
            this.materialFinal = true;
    };
    /**
     * Parses the uv data for the sprite.
     */
    MD2Parser.prototype.parseUV = function () {
        var j = 0;
        this._uvs = new Array(this._numST * 2);
        this._byteData.position = this._offsetST;
        for (var i = 0; i < this._numST; i++) {
            this._uvs[j++] = this._byteData.readShort() / this._skinWidth;
            this._uvs[j++] = this._byteData.readShort() / this._skinHeight;
        }
        this._parsedUV = true;
    };
    /**
     * Parses unique indices for the faces.
     */
    MD2Parser.prototype.parseFaces = function () {
        var a /*uint*/, b /*uint*/, c /*uint*/, ta /*uint*/, tb /*uint*/, tc;
        var i;
        this._vertIndices = new Array();
        this._uvIndices = new Array();
        this._indices = new Array() /*uint*/;
        this._byteData.position = this._offsetTris;
        for (i = 0; i < this._numTris; i++) {
            //collect vertex indices
            a = this._byteData.readUnsignedShort();
            b = this._byteData.readUnsignedShort();
            c = this._byteData.readUnsignedShort();
            //collect uv indices
            ta = this._byteData.readUnsignedShort();
            tb = this._byteData.readUnsignedShort();
            tc = this._byteData.readUnsignedShort();
            this.addIndex(a, ta);
            this.addIndex(b, tb);
            this.addIndex(c, tc);
        }
        var len = this._uvIndices.length;
        this._finalUV = new Array(len * 2);
        for (i = 0; i < len; ++i) {
            this._finalUV[i << 1] = this._uvs[this._uvIndices[i] << 1];
            this._finalUV[(i << 1) + 1] = this._uvs[(this._uvIndices[i] << 1) + 1];
        }
        this._parsedFaces = true;
    };
    /**
     * Adds a face index to the list if it doesn't exist yet, based on vertexIndex and uvIndex, and adds the
     * corresponding vertex and uv data in the correct location.
     * @param vertexIndex The original index in the vertex list.
     * @param uvIndex The original index in the uv list.
     */
    MD2Parser.prototype.addIndex = function (vertexIndex /*uint*/, uvIndex /*uint*/) {
        var index = this.findIndex(vertexIndex, uvIndex);
        if (index == -1) {
            this._indices.push(this._vertIndices.length);
            this._vertIndices.push(vertexIndex);
            this._uvIndices.push(uvIndex);
        }
        else
            this._indices.push(index);
    };
    /**
     * Finds the final index corresponding to the original MD2's vertex and uv indices. Returns -1 if it wasn't added yet.
     * @param vertexIndex The original index in the vertex list.
     * @param uvIndex The original index in the uv list.
     * @return The index of the final sprite corresponding to the original vertex and uv index. -1 if it doesn't exist yet.
     */
    MD2Parser.prototype.findIndex = function (vertexIndex /*uint*/, uvIndex /*uint*/) {
        var len = this._vertIndices.length;
        for (var i = 0; i < len; ++i) {
            if (this._vertIndices[i] == vertexIndex && this._uvIndices[i] == uvIndex)
                return i;
        }
        return -1;
    };
    /**
     * Parses all the frame elements.
     */
    MD2Parser.prototype.parseFrames = function () {
        var sx, sy, sz;
        var tx, ty, tz;
        var graphics;
        var elements;
        var vertLen = this._vertIndices.length;
        var fvertices;
        var tvertices;
        var i /*uint*/, j /*int*/, k;
        //var ch : number /*uint*/;
        var name = "";
        var prevClip = null;
        this._byteData.position = this._offsetFrames;
        for (i = 0; i < this._numFrames; i++) {
            tvertices = new Array();
            fvertices = new Array(vertLen * 3);
            sx = this._byteData.readFloat();
            sy = this._byteData.readFloat();
            sz = this._byteData.readFloat();
            tx = this._byteData.readFloat();
            ty = this._byteData.readFloat();
            tz = this._byteData.readFloat();
            name = this.readFrameName();
            // Note, the extra data.position++ in the for loop is there
            // to skip over a byte that holds the "vertex normal index"
            for (j = 0; j < this._numVertices; j++, this._byteData.position++)
                tvertices.push(sx * this._byteData.readUnsignedByte() + tx, sy * this._byteData.readUnsignedByte() + ty, sz * this._byteData.readUnsignedByte() + tz);
            k = 0;
            for (j = 0; j < vertLen; j++) {
                fvertices[k++] = tvertices[this._vertIndices[j] * 3];
                fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 2];
                fvertices[k++] = tvertices[this._vertIndices[j] * 3 + 1];
            }
            elements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
            elements.setIndices(this._indices);
            elements.setPositions(fvertices);
            elements.setUVs(this._finalUV);
            // cause explicit updates
            elements.setNormals(null);
            elements.setTangents(null);
            // turn auto updates off because they may be animated and set explicitly
            elements.autoDeriveNormals = false;
            elements.autoDeriveTangents = false;
            if (this._firstElements == null)
                this._firstElements = elements;
            graphics = new _awayjs_graphics.Graphics();
            graphics.addShape(new _awayjs_graphics.Shape(elements));
            var clip = this._clipNodes[name];
            if (!clip) {
                // If another sequence was parsed before this one, starting
                // a new state means the previous one is complete and can
                // hence be finalized.
                if (prevClip) {
                    this._pFinalizeAsset(prevClip);
                    this._animationSet.addAnimation(prevClip);
                }
                clip = new _awayjs_renderer.VertexClipNode();
                clip.name = name;
                clip.stitchFinalFrame = true;
                this._clipNodes[name] = clip;
                prevClip = clip;
            }
            clip.addFrame(graphics, 1000 / MD2Parser.FPS);
        }
        // Finalize the last state
        if (prevClip) {
            this._pFinalizeAsset(prevClip);
            this._animationSet.addAnimation(prevClip);
        }
        // Force this._pFinalizeAsset() to decide name
        this._pFinalizeAsset(this._animationSet);
        this._parsedFrames = true;
    };
    MD2Parser.prototype.readFrameName = function () {
        var name = "";
        var k = 0;
        for (var j = 0; j < 16; j++) {
            var ch = this._byteData.readUnsignedByte();
            if (Math.floor(ch) > 0x39 && Math.floor(ch) <= 0x7A && k == 0)
                name += String.fromCharCode(ch);
            if (Math.floor(ch) >= 0x30 && Math.floor(ch) <= 0x39)
                k++;
        }
        return name;
    };
    return MD2Parser;
}(_awayjs_core.ParserBase));
MD2Parser.FPS = 6;

/**
 * MD5AnimParser provides a parser for the md5anim data type, providing an animation sequence for the md5 format.
 *
 * todo: optimize
 */
var MD5AnimParser = (function (_super) {
    __extends(MD5AnimParser, _super);
    /**
     * Creates a new MD5AnimParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function MD5AnimParser(additionalRotationAxis, additionalRotationRadians) {
        if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
        if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.TEXT) || this;
        _this._parseIndex = 0;
        _this._line = 0;
        _this._charLineIndex = 0;
        _this._rotationQuat = new _awayjs_core.Quaternion();
        var t1 = new _awayjs_core.Quaternion();
        var t2 = new _awayjs_core.Quaternion();
        t1.fromAxisAngle(_awayjs_core.Vector3D.X_AXIS, -Math.PI * .5);
        t2.fromAxisAngle(_awayjs_core.Vector3D.Y_AXIS, -Math.PI * .5);
        _this._rotationQuat.multiply(t2, t1);
        if (additionalRotationAxis) {
            _this._rotationQuat.multiply(t2, t1);
            t1.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
            _this._rotationQuat.multiply(t1, _this._rotationQuat);
        }
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    MD5AnimParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "md5anim";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    MD5AnimParser.supportsData = function (data) {
        return false;
    };
    /**
     * @inheritDoc
     */
    MD5AnimParser.prototype._pProceedParsing = function () {
        var token;
        if (!this._startedParsing) {
            this._textData = this._pGetTextData();
            this._startedParsing = true;
        }
        while (this._pHasTime()) {
            token = this.getNextToken();
            switch (token) {
                case MD5AnimParser.COMMENT_TOKEN:
                    this.ignoreLine();
                    break;
                case "":
                    // can occur at the end of a file
                    break;
                case MD5AnimParser.VERSION_TOKEN:
                    this._version = this.getNextInt();
                    if (this._version != 10)
                        throw new Error("Unknown version number encountered!");
                    break;
                case MD5AnimParser.COMMAND_LINE_TOKEN:
                    this.parseCMD();
                    break;
                case MD5AnimParser.NUM_FRAMES_TOKEN:
                    this._numFrames = this.getNextInt();
                    this._bounds = new Array();
                    this._frameData = new Array();
                    break;
                case MD5AnimParser.NUM_JOINTS_TOKEN:
                    this._numJoints = this.getNextInt();
                    this._hierarchy = new Array(this._numJoints);
                    this._baseFrameData = new Array(this._numJoints);
                    break;
                case MD5AnimParser.FRAME_RATE_TOKEN:
                    this._frameRate = this.getNextInt();
                    break;
                case MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN:
                    this._numAnimatedComponents = this.getNextInt();
                    break;
                case MD5AnimParser.HIERARCHY_TOKEN:
                    this.parseHierarchy();
                    break;
                case MD5AnimParser.BOUNDS_TOKEN:
                    this.parseBounds();
                    break;
                case MD5AnimParser.BASE_FRAME_TOKEN:
                    this.parseBaseFrame();
                    break;
                case MD5AnimParser.FRAME_TOKEN:
                    this.parseFrame();
                    break;
                default:
                    if (!this._reachedEOF)
                        this.sendUnknownKeywordError();
            }
            if (this._reachedEOF) {
                this._clip = new _awayjs_renderer.SkeletonClipNode();
                this.translateClip();
                this._pFinalizeAsset(this._clip);
                return _awayjs_core.ParserBase.PARSING_DONE;
            }
        }
        return _awayjs_core.ParserBase.MORE_TO_PARSE;
    };
    /**
     * Converts all key frame data to an SkinnedAnimationSequence.
     */
    MD5AnimParser.prototype.translateClip = function () {
        for (var i = 0; i < this._numFrames; ++i)
            this._clip.addFrame(this.translatePose(this._frameData[i]), 1000 / this._frameRate);
    };
    /**
     * Converts a single key frame data to a SkeletonPose.
     * @param frameData The actual frame data.
     * @return A SkeletonPose containing the frame data's pose.
     */
    MD5AnimParser.prototype.translatePose = function (frameData) {
        var hierarchy;
        var pose;
        var base;
        var flags;
        var j;
        var translate = new _awayjs_core.Vector3D();
        var orientation = new _awayjs_core.Quaternion();
        var components = frameData.components;
        var skelPose = new _awayjs_renderer.SkeletonPose();
        var jointPoses = skelPose.jointPoses;
        for (var i = 0; i < this._numJoints; ++i) {
            j = 0;
            pose = new _awayjs_renderer.JointPose();
            hierarchy = this._hierarchy[i];
            base = this._baseFrameData[i];
            flags = hierarchy.flags;
            translate.x = base.position.x;
            translate.y = base.position.y;
            translate.z = base.position.z;
            orientation.x = base.orientation.x;
            orientation.y = base.orientation.y;
            orientation.z = base.orientation.z;
            if (flags & 1)
                translate.x = components[hierarchy.startIndex + (j++)];
            if (flags & 2)
                translate.y = components[hierarchy.startIndex + (j++)];
            if (flags & 4)
                translate.z = components[hierarchy.startIndex + (j++)];
            if (flags & 8)
                orientation.x = components[hierarchy.startIndex + (j++)];
            if (flags & 16)
                orientation.y = components[hierarchy.startIndex + (j++)];
            if (flags & 32)
                orientation.z = components[hierarchy.startIndex + (j++)];
            var w = 1 - orientation.x * orientation.x - orientation.y * orientation.y - orientation.z * orientation.z;
            orientation.w = w < 0 ? 0 : -Math.sqrt(w);
            if (hierarchy.parentIndex < 0) {
                pose.orientation.multiply(this._rotationQuat, orientation);
                pose.translation = this._rotationQuat.rotatePoint(translate);
            }
            else {
                pose.orientation.copyFrom(orientation);
                pose.translation.x = translate.x;
                pose.translation.y = translate.y;
                pose.translation.z = translate.z;
            }
            pose.orientation.y = -pose.orientation.y;
            pose.orientation.z = -pose.orientation.z;
            pose.translation.x = -pose.translation.x;
            jointPoses[i] = pose;
        }
        return skelPose;
    };
    /**
     * Parses the skeleton's hierarchy data.
     */
    MD5AnimParser.prototype.parseHierarchy = function () {
        var ch;
        var data;
        var token = this.getNextToken();
        var i = 0;
        if (token != "{")
            this.sendUnknownKeywordError();
        do {
            if (this._reachedEOF)
                this.sendEOFError();
            data = new HierarchyData();
            data.name = this.parseLiteralstring();
            data.parentIndex = this.getNextInt();
            data.flags = this.getNextInt();
            data.startIndex = this.getNextInt();
            this._hierarchy[i++] = data;
            ch = this.getNextChar();
            if (ch == "/") {
                this.putBack();
                ch = this.getNextToken();
                if (ch == MD5AnimParser.COMMENT_TOKEN)
                    this.ignoreLine();
                ch = this.getNextChar();
            }
            if (ch != "}")
                this.putBack();
        } while (ch != "}");
    };
    /**
     * Parses frame bounds.
     */
    MD5AnimParser.prototype.parseBounds = function () {
        var ch;
        var data;
        var token = this.getNextToken();
        var i = 0;
        if (token != "{")
            this.sendUnknownKeywordError();
        do {
            if (this._reachedEOF)
                this.sendEOFError();
            data = new BoundsData();
            data.min = this.parseVector3D();
            data.max = this.parseVector3D();
            this._bounds[i++] = data;
            ch = this.getNextChar();
            if (ch == "/") {
                this.putBack();
                ch = this.getNextToken();
                if (ch == MD5AnimParser.COMMENT_TOKEN)
                    this.ignoreLine();
                ch = this.getNextChar();
            }
            if (ch != "}")
                this.putBack();
        } while (ch != "}");
    };
    /**
     * Parses the base frame.
     */
    MD5AnimParser.prototype.parseBaseFrame = function () {
        var ch;
        var data;
        var token = this.getNextToken();
        var i = 0;
        if (token != "{")
            this.sendUnknownKeywordError();
        do {
            if (this._reachedEOF)
                this.sendEOFError();
            data = new BaseFrameData();
            data.position = this.parseVector3D();
            data.orientation = this.parseQuaternion();
            this._baseFrameData[i++] = data;
            ch = this.getNextChar();
            if (ch == "/") {
                this.putBack();
                ch = this.getNextToken();
                if (ch == MD5AnimParser.COMMENT_TOKEN)
                    this.ignoreLine();
                ch = this.getNextChar();
            }
            if (ch != "}")
                this.putBack();
        } while (ch != "}");
    };
    /**
     * Parses a single frame.
     */
    MD5AnimParser.prototype.parseFrame = function () {
        var ch;
        var data;
        var token;
        var frameIndex;
        frameIndex = this.getNextInt();
        token = this.getNextToken();
        if (token != "{")
            this.sendUnknownKeywordError();
        do {
            if (this._reachedEOF)
                this.sendEOFError();
            data = new FrameData();
            data.components = new Array(this._numAnimatedComponents);
            for (var i = 0; i < this._numAnimatedComponents; ++i)
                data.components[i] = this.getNextNumber();
            this._frameData[frameIndex] = data;
            ch = this.getNextChar();
            if (ch == "/") {
                this.putBack();
                ch = this.getNextToken();
                if (ch == MD5AnimParser.COMMENT_TOKEN)
                    this.ignoreLine();
                ch = this.getNextChar();
            }
            if (ch != "}")
                this.putBack();
        } while (ch != "}");
    };
    /**
     * Puts back the last read character into the data stream.
     */
    MD5AnimParser.prototype.putBack = function () {
        this._parseIndex--;
        this._charLineIndex--;
        this._reachedEOF = this._parseIndex >= this._textData.length;
    };
    /**
     * Gets the next token in the data stream.
     */
    MD5AnimParser.prototype.getNextToken = function () {
        var ch;
        var token = "";
        while (!this._reachedEOF) {
            ch = this.getNextChar();
            if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                if (token != MD5AnimParser.COMMENT_TOKEN)
                    this.skipWhiteSpace();
                if (token != "")
                    return token;
            }
            else
                token += ch;
            if (token == MD5AnimParser.COMMENT_TOKEN)
                return token;
        }
        return token;
    };
    /**
     * Skips all whitespace in the data stream.
     */
    MD5AnimParser.prototype.skipWhiteSpace = function () {
        var ch;
        do
            ch = this.getNextChar();
        while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
        this.putBack();
    };
    /**
     * Skips to the next line.
     */
    MD5AnimParser.prototype.ignoreLine = function () {
        var ch;
        while (!this._reachedEOF && ch != "\n")
            ch = this.getNextChar();
    };
    /**
     * Retrieves the next single character in the data stream.
     */
    MD5AnimParser.prototype.getNextChar = function () {
        var ch = this._textData.charAt(this._parseIndex++);
        if (ch == "\n") {
            ++this._line;
            this._charLineIndex = 0;
        }
        else if (ch != "\r")
            ++this._charLineIndex;
        if (this._parseIndex == this._textData.length)
            this._reachedEOF = true;
        return ch;
    };
    /**
     * Retrieves the next integer in the data stream.
     */
    MD5AnimParser.prototype.getNextInt = function () {
        var i = parseInt(this.getNextToken());
        if (isNaN(i))
            this.sendParseError("int type");
        return i;
    };
    /**
     * Retrieves the next floating point number in the data stream.
     */
    MD5AnimParser.prototype.getNextNumber = function () {
        var f = parseFloat(this.getNextToken());
        if (isNaN(f))
            this.sendParseError("float type");
        return f;
    };
    /**
     * Retrieves the next 3d vector in the data stream.
     */
    MD5AnimParser.prototype.parseVector3D = function () {
        var vec = new _awayjs_core.Vector3D();
        var ch = this.getNextToken();
        if (ch != "(")
            this.sendParseError("(");
        vec.x = this.getNextNumber();
        vec.y = this.getNextNumber();
        vec.z = this.getNextNumber();
        if (this.getNextToken() != ")")
            this.sendParseError(")");
        return vec;
    };
    /**
     * Retrieves the next quaternion in the data stream.
     */
    MD5AnimParser.prototype.parseQuaternion = function () {
        var quat = new _awayjs_core.Quaternion();
        var ch = this.getNextToken();
        if (ch != "(")
            this.sendParseError("(");
        quat.x = this.getNextNumber();
        quat.y = this.getNextNumber();
        quat.z = this.getNextNumber();
        // quat supposed to be unit length
        var t = 1 - (quat.x * quat.x) - (quat.y * quat.y) - (quat.z * quat.z);
        quat.w = t < 0 ? 0 : -Math.sqrt(t);
        if (this.getNextToken() != ")")
            this.sendParseError(")");
        return quat;
    };
    /**
     * Parses the command line data.
     */
    MD5AnimParser.prototype.parseCMD = function () {
        // just ignore the command line property
        this.parseLiteralstring();
    };
    /**
     * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
     * by double quotes.
     */
    MD5AnimParser.prototype.parseLiteralstring = function () {
        this.skipWhiteSpace();
        var ch = this.getNextChar();
        var str = "";
        if (ch != "\"")
            this.sendParseError("\"");
        do {
            if (this._reachedEOF)
                this.sendEOFError();
            ch = this.getNextChar();
            if (ch != "\"")
                str += ch;
        } while (ch != "\"");
        return str;
    };
    /**
     * Throws an end-of-file error when a premature end of file was encountered.
     */
    MD5AnimParser.prototype.sendEOFError = function () {
        throw new Error("Unexpected end of file");
    };
    /**
     * Throws an error when an unexpected token was encountered.
     * @param expected The token type that was actually expected.
     */
    MD5AnimParser.prototype.sendParseError = function (expected) {
        throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
    };
    /**
     * Throws an error when an unknown keyword was encountered.
     */
    MD5AnimParser.prototype.sendUnknownKeywordError = function () {
        throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
    };
    return MD5AnimParser;
}(_awayjs_core.ParserBase));
MD5AnimParser.VERSION_TOKEN = "MD5Version";
MD5AnimParser.COMMAND_LINE_TOKEN = "commandline";
MD5AnimParser.NUM_FRAMES_TOKEN = "numFrames";
MD5AnimParser.NUM_JOINTS_TOKEN = "numJoints";
MD5AnimParser.FRAME_RATE_TOKEN = "frameRate";
MD5AnimParser.NUM_ANIMATED_COMPONENTS_TOKEN = "numAnimatedComponents";
MD5AnimParser.HIERARCHY_TOKEN = "hierarchy";
MD5AnimParser.BOUNDS_TOKEN = "bounds";
MD5AnimParser.BASE_FRAME_TOKEN = "baseframe";
MD5AnimParser.FRAME_TOKEN = "frame";
MD5AnimParser.COMMENT_TOKEN = "//";
/**
 *
 */
var BaseFrameData = (function () {
    function BaseFrameData() {
    }
    return BaseFrameData;
}());
/**
 *
 */
var BoundsData = (function () {
    function BoundsData() {
    }
    return BoundsData;
}());
/**
 *
 */
var FrameData = (function () {
    function FrameData() {
    }
    return FrameData;
}());
/**
 *
 */
var HierarchyData = (function () {
    function HierarchyData() {
    }
    return HierarchyData;
}());

// todo: create animation system, parse skeleton
/**
 * MD5MeshParser provides a parser for the md5mesh data type, providing the graphics of the md5 format.
 *
 * todo: optimize
 */
var MD5MeshParser = (function (_super) {
    __extends(MD5MeshParser, _super);
    /**
     * Creates a new MD5MeshParser object.
     */
    function MD5MeshParser(additionalRotationAxis, additionalRotationRadians) {
        if (additionalRotationAxis === void 0) { additionalRotationAxis = null; }
        if (additionalRotationRadians === void 0) { additionalRotationRadians = 0; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.TEXT) || this;
        _this._parseIndex = 0;
        _this._line = 0;
        _this._charLineIndex = 0;
        _this._rotationQuat = new _awayjs_core.Quaternion();
        _this._rotationQuat.fromAxisAngle(_awayjs_core.Vector3D.X_AXIS, -Math.PI * .5);
        if (additionalRotationAxis) {
            var quat = new _awayjs_core.Quaternion();
            quat.fromAxisAngle(additionalRotationAxis, additionalRotationRadians);
            _this._rotationQuat.multiply(_this._rotationQuat, quat);
        }
        return _this;
    }
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    MD5MeshParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "md5sprite";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    MD5MeshParser.supportsData = function (data) {
        return false;
    };
    /**
     * @inheritDoc
     */
    MD5MeshParser.prototype._pProceedParsing = function () {
        var token;
        if (!this._startedParsing) {
            this._textData = this._pGetTextData();
            this._startedParsing = true;
        }
        while (this._pHasTime()) {
            token = this.getNextToken();
            switch (token) {
                case MD5MeshParser.COMMENT_TOKEN:
                    this.ignoreLine();
                    break;
                case MD5MeshParser.VERSION_TOKEN:
                    this._version = this.getNextInt();
                    if (this._version != 10)
                        throw new Error("Unknown version number encountered!");
                    break;
                case MD5MeshParser.COMMAND_LINE_TOKEN:
                    this.parseCMD();
                    break;
                case MD5MeshParser.NUM_JOINTS_TOKEN:
                    this._numJoints = this.getNextInt();
                    this._bindPoses = new Array(this._numJoints);
                    break;
                case MD5MeshParser.NUM_MESHES_TOKEN:
                    this._numMeshes = this.getNextInt();
                    break;
                case MD5MeshParser.JOINTS_TOKEN:
                    this.parseJoints();
                    break;
                case MD5MeshParser.MESH_TOKEN:
                    this.parseMesh();
                    break;
                default:
                    if (!this._reachedEOF)
                        this.sendUnknownKeywordError();
            }
            if (this._reachedEOF) {
                this.calculateMaxJointCount();
                this._animationSet = new _awayjs_renderer.SkeletonAnimationSet(this._maxJointCount);
                this._sprite = new _awayjs_scene.Sprite();
                this._graphics = this._sprite.graphics;
                for (var i = 0; i < this._elementsData.length; ++i)
                    this._graphics.addShape(new _awayjs_graphics.Shape(this.translateElements(this._elementsData[i].positionData, this._elementsData[i].weightData, this._elementsData[i].indices)));
                //_graphics.animation = _animation;
                //					_sprite.animationController = _animationController;
                //add to the content property
                this._pContent.addChild(this._sprite);
                this._pFinalizeAsset(this._graphics);
                this._pFinalizeAsset(this._sprite);
                this._pFinalizeAsset(this._skeleton);
                this._pFinalizeAsset(this._animationSet);
                return _awayjs_core.ParserBase.PARSING_DONE;
            }
        }
        return _awayjs_core.ParserBase.MORE_TO_PARSE;
    };
    MD5MeshParser.prototype._pStartParsing = function (frameLimit) {
        //create a content object for Loaders
        this._pContent = new _awayjs_scene.DisplayObjectContainer();
        _super.prototype._pStartParsing.call(this, frameLimit);
    };
    MD5MeshParser.prototype.calculateMaxJointCount = function () {
        this._maxJointCount = 0;
        var numElementsData = this._elementsData.length;
        for (var i = 0; i < numElementsData; ++i) {
            var elementsData = this._elementsData[i];
            var positionData = elementsData.positionData;
            var numVerts = positionData.length;
            for (var j = 0; j < numVerts; ++j) {
                var zeroWeights = this.countZeroWeightJoints(positionData[j], elementsData.weightData);
                var totalJoints = positionData[j].countWeight - zeroWeights;
                if (totalJoints > this._maxJointCount)
                    this._maxJointCount = totalJoints;
            }
        }
    };
    MD5MeshParser.prototype.countZeroWeightJoints = function (position, weights) {
        var start = position.startWeight;
        var end = position.startWeight + position.countWeight;
        var count = 0;
        var weight;
        for (var i = start; i < end; ++i) {
            weight = weights[i].bias;
            if (weight == 0)
                ++count;
        }
        return count;
    };
    /**
     * Parses the skeleton's joints.
     */
    MD5MeshParser.prototype.parseJoints = function () {
        var ch;
        var joint;
        var pos;
        var quat;
        var i = 0;
        var token = this.getNextToken();
        if (token != "{")
            this.sendUnknownKeywordError();
        this._skeleton = new _awayjs_renderer.Skeleton();
        do {
            if (this._reachedEOF)
                this.sendEOFError();
            joint = new _awayjs_renderer.SkeletonJoint();
            joint.name = this.parseLiteralstring();
            joint.parentIndex = this.getNextInt();
            pos = this.parseVector3D();
            pos = this._rotationQuat.rotatePoint(pos);
            quat = this.parseQuaternion();
            // todo: check if this is correct, or maybe we want to actually store it as quats?
            this._bindPoses[i] = quat.toMatrix3D();
            this._bindPoses[i].appendTranslation(pos.x, pos.y, pos.z);
            var inv = this._bindPoses[i].clone();
            inv.invert();
            joint.inverseBindPose = inv._rawData;
            this._skeleton.joints[i++] = joint;
            ch = this.getNextChar();
            if (ch == "/") {
                this.putBack();
                ch = this.getNextToken();
                if (ch == MD5MeshParser.COMMENT_TOKEN)
                    this.ignoreLine();
                ch = this.getNextChar();
            }
            if (ch != "}")
                this.putBack();
        } while (ch != "}");
    };
    /**
     * Puts back the last read character into the data stream.
     */
    MD5MeshParser.prototype.putBack = function () {
        this._parseIndex--;
        this._charLineIndex--;
        this._reachedEOF = this._parseIndex >= this._textData.length;
    };
    /**
     * Parses the mesh graphics.
     */
    MD5MeshParser.prototype.parseMesh = function () {
        var token = this.getNextToken();
        var ch;
        var positionData;
        var weights;
        var indices;
        if (token != "{")
            this.sendUnknownKeywordError();
        if (this._shaders == null)
            this._shaders = new Array();
        while (ch != "}") {
            ch = this.getNextToken();
            switch (ch) {
                case MD5MeshParser.COMMENT_TOKEN:
                    this.ignoreLine();
                    break;
                case MD5MeshParser.MESH_SHADER_TOKEN:
                    this._shaders.push(this.parseLiteralstring());
                    break;
                case MD5MeshParser.MESH_NUM_VERTS_TOKEN:
                    positionData = new Array(this.getNextInt());
                    break;
                case MD5MeshParser.MESH_NUM_TRIS_TOKEN:
                    indices = new Array(this.getNextInt() * 3) /*uint*/;
                    break;
                case MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN:
                    weights = new Array(this.getNextInt());
                    break;
                case MD5MeshParser.MESH_VERT_TOKEN:
                    this.parseVertex(positionData);
                    break;
                case MD5MeshParser.MESH_TRI_TOKEN:
                    this.parseTri(indices);
                    break;
                case MD5MeshParser.MESH_WEIGHT_TOKEN:
                    this.parseJoint(weights);
                    break;
            }
        }
        if (this._elementsData == null)
            this._elementsData = new Array();
        var i = this._elementsData.length;
        this._elementsData[i] = new ElementsData();
        this._elementsData[i].positionData = positionData;
        this._elementsData[i].weightData = weights;
        this._elementsData[i].indices = indices;
    };
    /**
     * Converts the sprite data to a SkinnedSub instance.
     * @param positionData The sprite's positions.
     * @param weights The joint weights per position.
     * @param indices The indices for the faces.
     * @return A TriangleElements instance containing all elements data for the current sprite.
     */
    MD5MeshParser.prototype.translateElements = function (positionData, weights, indices /*uint*/) {
        var len = positionData.length;
        var v1 /*int*/, v2 /*int*/, v3;
        var position;
        var weight;
        var bindPose;
        var pos;
        var elements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
        var uvs = new Array(len * 2);
        var positions = new Array(len * 3);
        var jointIndices = new Array(len * this._maxJointCount);
        var jointWeights = new Array(len * this._maxJointCount);
        var l = 0;
        var nonZeroWeights;
        for (var i = 0; i < len; ++i) {
            position = positionData[i];
            v1 = position.index * 3;
            v2 = v1 + 1;
            v3 = v1 + 2;
            positions[v1] = positions[v2] = positions[v3] = 0;
            nonZeroWeights = 0;
            for (var j = 0; j < position.countWeight; ++j) {
                weight = weights[position.startWeight + j];
                if (weight.bias > 0) {
                    bindPose = this._bindPoses[weight.joint];
                    pos = bindPose.transformVector(weight.pos);
                    positions[v1] += pos.x * weight.bias;
                    positions[v2] += pos.y * weight.bias;
                    positions[v3] += pos.z * weight.bias;
                    // indices need to be multiplied by 3 (amount of matrix registers)
                    jointIndices[l] = weight.joint * 3;
                    jointWeights[l++] = weight.bias;
                    ++nonZeroWeights;
                }
            }
            for (j = nonZeroWeights; j < this._maxJointCount; ++j) {
                jointIndices[l] = 0;
                jointWeights[l++] = 0;
            }
            v1 = position.index << 1;
            uvs[v1++] = position.s;
            uvs[v1] = position.t;
        }
        elements.jointsPerVertex = this._maxJointCount;
        elements.setIndices(indices);
        elements.setPositions(positions);
        elements.setUVs(uvs);
        elements.setJointIndices(jointIndices);
        elements.setJointWeights(jointWeights);
        // cause explicit updates
        elements.setNormals(null);
        elements.setTangents(null);
        // turn auto updates off because they may be animated and set explicitly
        elements.autoDeriveTangents = false;
        elements.autoDeriveNormals = false;
        return elements;
    };
    /**
     * Retrieve the next triplet of position indices that form a face.
     * @param indices The index list in which to store the read data.
     */
    MD5MeshParser.prototype.parseTri = function (indices /*uint*/) {
        var index = this.getNextInt() * 3;
        indices[index] = this.getNextInt();
        indices[index + 1] = this.getNextInt();
        indices[index + 2] = this.getNextInt();
    };
    /**
     * Reads a new joint data set for a single joint.
     * @param weights the target list to contain the weight data.
     */
    MD5MeshParser.prototype.parseJoint = function (weights) {
        var weight = new JointData();
        weight.index = this.getNextInt();
        weight.joint = this.getNextInt();
        weight.bias = this.getNextNumber();
        weight.pos = this.parseVector3D();
        weights[weight.index] = weight;
    };
    /**
     * Reads the data for a single position.
     * @param positionData The list to contain the position data.
     */
    MD5MeshParser.prototype.parseVertex = function (positionData) {
        var position = new PositionData();
        position.index = this.getNextInt();
        this.parseUV(position);
        position.startWeight = this.getNextInt();
        position.countWeight = this.getNextInt();
        //			if (position.countWeight > _maxJointCount) _maxJointCount = position.countWeight;
        positionData[position.index] = position;
    };
    /**
     * Reads the next uv coordinate.
     * @param positionData The positionData to contain the UV coordinates.
     */
    MD5MeshParser.prototype.parseUV = function (positionData) {
        var ch = this.getNextToken();
        if (ch != "(")
            this.sendParseError("(");
        positionData.s = this.getNextNumber();
        positionData.t = this.getNextNumber();
        if (this.getNextToken() != ")")
            this.sendParseError(")");
    };
    /**
     * Gets the next token in the data stream.
     */
    MD5MeshParser.prototype.getNextToken = function () {
        var ch;
        var token = "";
        while (!this._reachedEOF) {
            ch = this.getNextChar();
            if (ch == " " || ch == "\r" || ch == "\n" || ch == "\t") {
                if (token != MD5MeshParser.COMMENT_TOKEN)
                    this.skipWhiteSpace();
                if (token != "")
                    return token;
            }
            else
                token += ch;
            if (token == MD5MeshParser.COMMENT_TOKEN)
                return token;
        }
        return token;
    };
    /**
     * Skips all whitespace in the data stream.
     */
    MD5MeshParser.prototype.skipWhiteSpace = function () {
        var ch;
        do
            ch = this.getNextChar();
        while (ch == "\n" || ch == " " || ch == "\r" || ch == "\t");
        this.putBack();
    };
    /**
     * Skips to the next line.
     */
    MD5MeshParser.prototype.ignoreLine = function () {
        var ch;
        while (!this._reachedEOF && ch != "\n")
            ch = this.getNextChar();
    };
    /**
     * Retrieves the next single character in the data stream.
     */
    MD5MeshParser.prototype.getNextChar = function () {
        var ch = this._textData.charAt(this._parseIndex++);
        if (ch == "\n") {
            ++this._line;
            this._charLineIndex = 0;
        }
        else if (ch != "\r")
            ++this._charLineIndex;
        if (this._parseIndex >= this._textData.length)
            this._reachedEOF = true;
        return ch;
    };
    /**
     * Retrieves the next integer in the data stream.
     */
    MD5MeshParser.prototype.getNextInt = function () {
        var i = parseInt(this.getNextToken());
        if (isNaN(i))
            this.sendParseError("int type");
        return i;
    };
    /**
     * Retrieves the next floating point number in the data stream.
     */
    MD5MeshParser.prototype.getNextNumber = function () {
        var f = parseFloat(this.getNextToken());
        if (isNaN(f))
            this.sendParseError("float type");
        return f;
    };
    /**
     * Retrieves the next 3d vector in the data stream.
     */
    MD5MeshParser.prototype.parseVector3D = function () {
        var vec = new _awayjs_core.Vector3D();
        var ch = this.getNextToken();
        if (ch != "(")
            this.sendParseError("(");
        vec.x = -this.getNextNumber();
        vec.y = this.getNextNumber();
        vec.z = this.getNextNumber();
        if (this.getNextToken() != ")")
            this.sendParseError(")");
        return vec;
    };
    /**
     * Retrieves the next quaternion in the data stream.
     */
    MD5MeshParser.prototype.parseQuaternion = function () {
        var quat = new _awayjs_core.Quaternion();
        var ch = this.getNextToken();
        if (ch != "(")
            this.sendParseError("(");
        quat.x = this.getNextNumber();
        quat.y = -this.getNextNumber();
        quat.z = -this.getNextNumber();
        // quat supposed to be unit length
        var t = 1 - quat.x * quat.x - quat.y * quat.y - quat.z * quat.z;
        quat.w = t < 0 ? 0 : -Math.sqrt(t);
        if (this.getNextToken() != ")")
            this.sendParseError(")");
        var rotQuat = new _awayjs_core.Quaternion();
        rotQuat.multiply(this._rotationQuat, quat);
        return rotQuat;
    };
    /**
     * Parses the command line data.
     */
    MD5MeshParser.prototype.parseCMD = function () {
        // just ignore the command line property
        this.parseLiteralstring();
    };
    /**
     * Retrieves the next literal string in the data stream. A literal string is a sequence of characters bounded
     * by double quotes.
     */
    MD5MeshParser.prototype.parseLiteralstring = function () {
        this.skipWhiteSpace();
        var ch = this.getNextChar();
        var str = "";
        if (ch != "\"")
            this.sendParseError("\"");
        do {
            if (this._reachedEOF)
                this.sendEOFError();
            ch = this.getNextChar();
            if (ch != "\"")
                str += ch;
        } while (ch != "\"");
        return str;
    };
    /**
     * Throws an end-of-file error when a premature end of file was encountered.
     */
    MD5MeshParser.prototype.sendEOFError = function () {
        throw new Error("Unexpected end of file");
    };
    /**
     * Throws an error when an unexpected token was encountered.
     * @param expected The token type that was actually expected.
     */
    MD5MeshParser.prototype.sendParseError = function (expected) {
        throw new Error("Unexpected token at line " + (this._line + 1) + ", character " + this._charLineIndex + ". " + expected + " expected, but " + this._textData.charAt(this._parseIndex - 1) + " encountered");
    };
    /**
     * Throws an error when an unknown keyword was encountered.
     */
    MD5MeshParser.prototype.sendUnknownKeywordError = function () {
        throw new Error("Unknown keyword at line " + (this._line + 1) + ", character " + this._charLineIndex + ". ");
    };
    return MD5MeshParser;
}(_awayjs_core.ParserBase));
MD5MeshParser.VERSION_TOKEN = "MD5Version";
MD5MeshParser.COMMAND_LINE_TOKEN = "commandline";
MD5MeshParser.NUM_JOINTS_TOKEN = "numJoints";
MD5MeshParser.NUM_MESHES_TOKEN = "numMeshes";
MD5MeshParser.COMMENT_TOKEN = "//";
MD5MeshParser.JOINTS_TOKEN = "joints";
MD5MeshParser.MESH_TOKEN = "mesh";
MD5MeshParser.MESH_SHADER_TOKEN = "shader";
MD5MeshParser.MESH_NUM_VERTS_TOKEN = "numverts";
MD5MeshParser.MESH_VERT_TOKEN = "vert";
MD5MeshParser.MESH_NUM_TRIS_TOKEN = "numtris";
MD5MeshParser.MESH_TRI_TOKEN = "tri";
MD5MeshParser.MESH_NUM_WEIGHTS_TOKEN = "numweights";
MD5MeshParser.MESH_WEIGHT_TOKEN = "weight";
var PositionData = (function () {
    function PositionData() {
    }
    return PositionData;
}());
var JointData = (function () {
    function JointData() {
    }
    return JointData;
}());
var ElementsData = (function () {
    function ElementsData() {
    }
    return ElementsData;
}());

/**
 * OBJParser provides a parser for the OBJ data type.
 */
var OBJParser = (function (_super) {
    __extends(OBJParser, _super);
    /**
     * Creates a new OBJParser object.
     * @param uri The url or id of the data or file to be parsed.
     * @param extra The holder for extra contextual data that the parser might need.
     */
    function OBJParser(scale) {
        if (scale === void 0) { scale = 1; }
        var _this = _super.call(this, _awayjs_core.URLLoaderDataFormat.TEXT) || this;
        _this._mtlLibLoaded = true;
        _this._activeMaterialID = "";
        _this._scale = scale;
        return _this;
    }
    Object.defineProperty(OBJParser.prototype, "scale", {
        /**
         * Scaling factor applied directly to vertices data
         * @param value The scaling factor.
         */
        set: function (value) {
            this._scale = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Indicates whether or not a given file extension is supported by the parser.
     * @param extension The file extension of a potential file to be parsed.
     * @return Whether or not the given file type is supported.
     */
    OBJParser.supportsType = function (extension) {
        extension = extension.toLowerCase();
        return extension == "obj";
    };
    /**
     * Tests whether a data block can be parsed by the parser.
     * @param data The data block to potentially be parsed.
     * @return Whether or not the given data is supported.
     */
    OBJParser.supportsData = function (data) {
        var content = _awayjs_core.ParserUtils.toString(data);
        var hasV = false;
        var hasF = false;
        if (content) {
            hasV = content.indexOf("\nv ") != -1;
            hasF = content.indexOf("\nf ") != -1;
        }
        return hasV && hasF;
    };
    /**
     * @inheritDoc
     */
    OBJParser.prototype._iResolveDependency = function (resourceDependency) {
        if (resourceDependency.id == 'mtl') {
            var str = _awayjs_core.ParserUtils.toString(resourceDependency.data);
            this.parseMtl(str);
        }
        else {
            var asset;
            if (resourceDependency.assets.length != 1) {
                return;
            }
            asset = resourceDependency.assets[0];
            if (asset.isAsset(_awayjs_graphics.BitmapImage2D)) {
                var lm = new LoadedMaterial();
                lm.materialID = resourceDependency.id;
                lm.texture = new _awayjs_graphics.Single2DTexture(asset);
                this._materialLoaded.push(lm);
                if (this._sprites.length > 0) {
                    this.applyMaterial(lm);
                }
            }
        }
    };
    /**
     * @inheritDoc
     */
    OBJParser.prototype._iResolveDependencyFailure = function (resourceDependency) {
        if (resourceDependency.id == "mtl") {
            this._mtlLib = false;
            this._mtlLibLoaded = false;
        }
        else {
            var lm = new LoadedMaterial();
            lm.materialID = resourceDependency.id;
            this._materialLoaded.push(lm);
        }
        if (this._sprites.length > 0)
            this.applyMaterial(lm);
    };
    /**
     * @inheritDoc
     */
    OBJParser.prototype._pProceedParsing = function () {
        var line;
        var creturn = String.fromCharCode(10);
        var trunk;
        if (!this._startedParsing) {
            this._textData = this._pGetTextData();
            // Merge linebreaks that are immediately preceeded by
            // the "escape" backward slash into single lines.
            this._textData = this._textData.replace(/\\[\r\n]+\s*/gm, ' ');
        }
        if (this._textData.indexOf(creturn) == -1)
            creturn = String.fromCharCode(13);
        if (!this._startedParsing) {
            this._startedParsing = true;
            this._vertices = new Array();
            this._vertexNormals = new Array();
            this._materialIDs = new Array();
            this._materialLoaded = new Array();
            this._sprites = new Array();
            this._uvs = new Array();
            this._stringLength = this._textData.length;
            this._charIndex = this._textData.indexOf(creturn, 0);
            this._oldIndex = 0;
            this._objects = new Array();
            this._objectIndex = 0;
        }
        while (this._charIndex < this._stringLength && this._pHasTime()) {
            this._charIndex = this._textData.indexOf(creturn, this._oldIndex);
            if (this._charIndex == -1)
                this._charIndex = this._stringLength;
            line = this._textData.substring(this._oldIndex, this._charIndex);
            line = line.split('\r').join("");
            line = line.replace("  ", " ");
            trunk = line.split(" ");
            this._oldIndex = this._charIndex + 1;
            this.parseLine(trunk);
            // If whatever was parsed on this line resulted in the
            // parsing being paused to retrieve dependencies, break
            // here and do not continue parsing until un-paused.
            if (this.parsingPaused) {
                return _awayjs_core.ParserBase.MORE_TO_PARSE;
            }
        }
        if (this._charIndex >= this._stringLength) {
            if (this._mtlLib && !this._mtlLibLoaded) {
                return _awayjs_core.ParserBase.MORE_TO_PARSE;
            }
            this.translate();
            this.applyMaterials();
            return _awayjs_core.ParserBase.PARSING_DONE;
        }
        return _awayjs_core.ParserBase.MORE_TO_PARSE;
    };
    OBJParser.prototype._pStartParsing = function (frameLimit) {
        //create a content object for Loaders
        this._pContent = new _awayjs_scene.DisplayObjectContainer();
        _super.prototype._pStartParsing.call(this, frameLimit);
    };
    /**
     * Parses a single line in the OBJ file.
     */
    OBJParser.prototype.parseLine = function (trunk) {
        switch (trunk[0]) {
            case "mtllib":
                this._mtlLib = true;
                this._mtlLibLoaded = false;
                this.loadMtl(trunk[1]);
                break;
            case "g":
                this.createGroup(trunk);
                break;
            case "o":
                this.createObject(trunk);
                break;
            case "usemtl":
                if (this._mtlLib) {
                    if (!trunk[1])
                        trunk[1] = "def000";
                    this._materialIDs.push(trunk[1]);
                    this._activeMaterialID = trunk[1];
                    if (this._currentGroup)
                        this._currentGroup.materialID = this._activeMaterialID;
                }
                break;
            case "v":
                this.parseVertex(trunk);
                break;
            case "vt":
                this.parseUV(trunk);
                break;
            case "vn":
                this.parseVertexNormal(trunk);
                break;
            case "f":
                this.parseFace(trunk);
        }
    };
    /**
     * Converts the parsed data into an Away3D scenegraph structure
     */
    OBJParser.prototype.translate = function () {
        for (var objIndex = 0; objIndex < this._objects.length; ++objIndex) {
            var groups = this._objects[objIndex].groups;
            var numGroups = groups.length;
            var materialGroups;
            var numMaterialGroups;
            var graphics;
            var sprite;
            var m;
            var sm;
            var bmMaterial;
            for (var g = 0; g < numGroups; ++g) {
                bmMaterial = new _awayjs_materials.MethodMaterial(_awayjs_graphics.DefaultMaterialManager.getDefaultImage2D());
                //check for multipass
                if (this.materialMode >= 2)
                    bmMaterial.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
                sprite = new _awayjs_scene.Sprite(bmMaterial);
                graphics = sprite.graphics;
                materialGroups = groups[g].materialGroups;
                numMaterialGroups = materialGroups.length;
                for (m = 0; m < numMaterialGroups; ++m)
                    this.translateMaterialGroup(materialGroups[m], graphics);
                if (graphics.count == 0)
                    continue;
                // Finalize and force type-based name
                this._pFinalizeAsset(graphics); //, "");
                if (this._objects[objIndex].name) {
                    // this is a full independent object ('o' tag in OBJ file)
                    sprite.name = this._objects[objIndex].name;
                }
                else if (groups[g].name) {
                    // this is a group so the sub groups contain the actual sprite object names ('g' tag in OBJ file)
                    sprite.name = groups[g].name;
                }
                else {
                    // No name stored. Use empty string which will force it
                    // to be overridden by finalizeAsset() to type default.
                    sprite.name = "";
                }
                this._sprites.push(sprite);
                if (groups[g].materialID != "")
                    bmMaterial.name = groups[g].materialID + "~" + sprite.name;
                else
                    bmMaterial.name = this._lastMtlID + "~" + sprite.name;
                if (sprite.graphics.count > 1) {
                    for (sm = 1; sm < sprite.graphics.count; ++sm)
                        sprite.graphics.getShapeAt(sm).material = bmMaterial;
                }
                //add to the content property
                this._pContent.addChild(sprite);
                this._pFinalizeAsset(sprite);
            }
        }
    };
    /**
     * Translates an obj's material group to a subgraphics.
     * @param materialGroup The material group data to convert.
     * @param graphics The Graphics to contain the converted Elements.
     */
    OBJParser.prototype.translateMaterialGroup = function (materialGroup, graphics) {
        var faces = materialGroup.faces;
        var face;
        var numFaces = faces.length;
        var numVerts;
        var elements;
        var vertices = new Array();
        var uvs = new Array();
        var normals = new Array();
        var indices = new Array();
        this._realIndices = [];
        this._vertexIndex = 0;
        var j;
        for (var i = 0; i < numFaces; ++i) {
            face = faces[i];
            numVerts = face.indexIds.length - 1;
            for (j = 1; j < numVerts; ++j) {
                this.translateVertexData(face, j, vertices, uvs, indices, normals);
                this.translateVertexData(face, 0, vertices, uvs, indices, normals);
                this.translateVertexData(face, j + 1, vertices, uvs, indices, normals);
            }
        }
        if (vertices.length > 0) {
            elements = new _awayjs_graphics.TriangleElements(new _awayjs_core.AttributesBuffer());
            elements.autoDeriveNormals = normals.length ? false : true;
            elements.setIndices(indices);
            elements.setPositions(vertices);
            elements.setNormals(normals);
            elements.setUVs(uvs);
            graphics.addShape(new _awayjs_graphics.Shape(elements));
        }
    };
    OBJParser.prototype.translateVertexData = function (face, vertexIndex, vertices, uvs, indices /*uint*/, normals) {
        var index;
        var vertex;
        var vertexNormal;
        var uv;
        if (!this._realIndices[face.indexIds[vertexIndex]]) {
            index = this._vertexIndex;
            this._realIndices[face.indexIds[vertexIndex]] = ++this._vertexIndex;
            vertex = this._vertices[face.vertexIndices[vertexIndex] - 1];
            vertices.push(vertex.x * this._scale, vertex.y * this._scale, vertex.z * this._scale);
            if (face.normalIndices.length > 0) {
                vertexNormal = this._vertexNormals[face.normalIndices[vertexIndex] - 1];
                normals.push(vertexNormal.x, vertexNormal.y, vertexNormal.z);
            }
            if (face.uvIndices.length > 0) {
                try {
                    uv = this._uvs[face.uvIndices[vertexIndex] - 1];
                    uvs.push(uv.u, uv.v);
                }
                catch (e) {
                    switch (vertexIndex) {
                        case 0:
                            uvs.push(0, 1);
                            break;
                        case 1:
                            uvs.push(.5, 0);
                            break;
                        case 2:
                            uvs.push(1, 1);
                    }
                }
            }
        }
        else {
            index = this._realIndices[face.indexIds[vertexIndex]] - 1;
        }
        indices.push(index);
    };
    /**
     * Creates a new object group.
     * @param trunk The data block containing the object tag and its parameters
     */
    OBJParser.prototype.createObject = function (trunk) {
        this._currentGroup = null;
        this._currentMaterialGroup = null;
        this._objects.push(this._currentObject = new ObjectGroup());
        if (trunk)
            this._currentObject.name = trunk[1];
    };
    /**
     * Creates a new group.
     * @param trunk The data block containing the group tag and its parameters
     */
    OBJParser.prototype.createGroup = function (trunk) {
        if (!this._currentObject)
            this.createObject(null);
        this._currentGroup = new Group();
        this._currentGroup.materialID = this._activeMaterialID;
        if (trunk)
            this._currentGroup.name = trunk[1];
        this._currentObject.groups.push(this._currentGroup);
        this.createMaterialGroup(null);
    };
    /**
     * Creates a new material group.
     * @param trunk The data block containing the material tag and its parameters
     */
    OBJParser.prototype.createMaterialGroup = function (trunk) {
        this._currentMaterialGroup = new MaterialGroup();
        if (trunk)
            this._currentMaterialGroup.url = trunk[1];
        this._currentGroup.materialGroups.push(this._currentMaterialGroup);
    };
    /**
     * Reads the next vertex coordinates.
     * @param trunk The data block containing the vertex tag and its parameters
     */
    OBJParser.prototype.parseVertex = function (trunk) {
        //for the very rare cases of other delimiters/charcodes seen in some obj files
        var v1, v2, v3;
        if (trunk.length > 4) {
            var nTrunk = [];
            var val;
            for (var i = 1; i < trunk.length; ++i) {
                val = parseFloat(trunk[i]);
                if (!isNaN(val))
                    nTrunk.push(val);
            }
            v1 = nTrunk[0];
            v2 = nTrunk[1];
            v3 = -nTrunk[2];
            this._vertices.push(new Vertex(v1, v2, v3));
        }
        else {
            v1 = parseFloat(trunk[1]);
            v2 = parseFloat(trunk[2]);
            v3 = -parseFloat(trunk[3]);
            this._vertices.push(new Vertex(v1, v2, v3));
        }
    };
    /**
     * Reads the next uv coordinates.
     * @param trunk The data block containing the uv tag and its parameters
     */
    OBJParser.prototype.parseUV = function (trunk) {
        if (trunk.length > 3) {
            var nTrunk = [];
            var val;
            for (var i = 1; i < trunk.length; ++i) {
                val = parseFloat(trunk[i]);
                if (!isNaN(val))
                    nTrunk.push(val);
            }
            this._uvs.push(new UV(nTrunk[0], 1 - nTrunk[1]));
        }
        else {
            this._uvs.push(new UV(parseFloat(trunk[1]), 1 - parseFloat(trunk[2])));
        }
    };
    /**
     * Reads the next vertex normal coordinates.
     * @param trunk The data block containing the vertex normal tag and its parameters
     */
    OBJParser.prototype.parseVertexNormal = function (trunk) {
        if (trunk.length > 4) {
            var nTrunk = [];
            var val;
            for (var i = 1; i < trunk.length; ++i) {
                val = parseFloat(trunk[i]);
                if (!isNaN(val))
                    nTrunk.push(val);
            }
            this._vertexNormals.push(new Vertex(nTrunk[0], nTrunk[1], -nTrunk[2]));
        }
        else {
            this._vertexNormals.push(new Vertex(parseFloat(trunk[1]), parseFloat(trunk[2]), -parseFloat(trunk[3])));
        }
    };
    /**
     * Reads the next face's indices.
     * @param trunk The data block containing the face tag and its parameters
     */
    OBJParser.prototype.parseFace = function (trunk) {
        var len = trunk.length;
        var face = new FaceData();
        if (!this._currentGroup) {
            this.createGroup(null);
        }
        var indices;
        for (var i = 1; i < len; ++i) {
            if (trunk[i] == "") {
                continue;
            }
            indices = trunk[i].split("/");
            face.vertexIndices.push(this.parseIndex(parseInt(indices[0]), this._vertices.length));
            if (indices[1] && String(indices[1]).length > 0)
                face.uvIndices.push(this.parseIndex(parseInt(indices[1]), this._uvs.length));
            if (indices[2] && String(indices[2]).length > 0)
                face.normalIndices.push(this.parseIndex(parseInt(indices[2]), this._vertexNormals.length));
            face.indexIds.push(trunk[i]);
        }
        this._currentMaterialGroup.faces.push(face);
    };
    /**
     * This is a hack around negative face coords
     */
    OBJParser.prototype.parseIndex = function (index, length) {
        if (index < 0)
            return index + length + 1;
        else
            return index;
    };
    OBJParser.prototype.parseMtl = function (data) {
        var materialDefinitions = data.split('newmtl');
        var lines;
        var trunk;
        var j;
        var basicSpecularMethod;
        var useSpecular;
        var useColor;
        var diffuseColor;
        var color;
        var specularColor;
        var specular;
        var alpha;
        var mapkd;
        for (var i = 0; i < materialDefinitions.length; ++i) {
            lines = (materialDefinitions[i].split('\r')).join("").split('\n');
            //lines = (materialDefinitions[i].split('\r') as Array).join("").split('\n');
            if (lines.length == 1)
                lines = materialDefinitions[i].split(String.fromCharCode(13));
            diffuseColor = color = specularColor = 0xFFFFFF;
            specular = 0;
            useSpecular = false;
            useColor = false;
            alpha = 1;
            mapkd = "";
            for (j = 0; j < lines.length; ++j) {
                lines[j] = lines[j].replace(/\s+$/, "");
                if (lines[j].substring(0, 1) != "#" && (j == 0 || lines[j] != "")) {
                    trunk = lines[j].split(" ");
                    if (String(trunk[0]).charCodeAt(0) == 9 || String(trunk[0]).charCodeAt(0) == 32)
                        trunk[0] = trunk[0].substring(1, trunk[0].length);
                    if (j == 0) {
                        this._lastMtlID = trunk.join("");
                        this._lastMtlID = (this._lastMtlID == "") ? "def000" : this._lastMtlID;
                    }
                    else {
                        switch (trunk[0]) {
                            case "Ka":
                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3])))
                                    color = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                break;
                            case "Ks":
                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                    specularColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                    useSpecular = true;
                                }
                                break;
                            case "Ns":
                                if (trunk[1] && !isNaN(Number(trunk[1])))
                                    specular = Number(trunk[1]) * 0.001;
                                if (specular == 0)
                                    useSpecular = false;
                                break;
                            case "Kd":
                                if (trunk[1] && !isNaN(Number(trunk[1])) && trunk[2] && !isNaN(Number(trunk[2])) && trunk[3] && !isNaN(Number(trunk[3]))) {
                                    diffuseColor = trunk[1] * 255 << 16 | trunk[2] * 255 << 8 | trunk[3] * 255;
                                    useColor = true;
                                }
                                break;
                            case "tr":
                            case "d":
                                if (trunk[1] && !isNaN(Number(trunk[1])))
                                    alpha = Number(trunk[1]);
                                break;
                            case "map_Kd":
                                mapkd = this.parseMapKdString(trunk);
                                mapkd = mapkd.replace(/\\/g, "/");
                        }
                    }
                }
            }
            if (mapkd != "") {
                if (useSpecular) {
                    basicSpecularMethod = new _awayjs_materials.SpecularBasicMethod();
                    basicSpecularMethod.color = specularColor;
                    basicSpecularMethod.strength = specular;
                    var specularData = new SpecularData();
                    specularData.alpha = alpha;
                    specularData.basicSpecularMethod = basicSpecularMethod;
                    specularData.materialID = this._lastMtlID;
                    if (!this._materialSpecularData)
                        this._materialSpecularData = new Array();
                    this._materialSpecularData.push(specularData);
                }
                this._pAddDependency(this._lastMtlID, new _awayjs_core.URLRequest(mapkd));
            }
            else if (useColor && !isNaN(color)) {
                var lm = new LoadedMaterial();
                lm.materialID = this._lastMtlID;
                if (alpha == 0)
                    console.log("Warning: an alpha value of 0 was found in mtl color tag (Tr or d) ref:" + this._lastMtlID + ", sprite(es) using it will be invisible!");
                var cm = new _awayjs_materials.MethodMaterial(color);
                if (this.materialMode < 2) {
                    cm.alpha = alpha;
                }
                else {
                    cm.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
                }
                cm.diffuseMethod.color = diffuseColor;
                if (useSpecular) {
                    cm.specularMethod.color = specularColor;
                    cm.specularMethod.strength = specular;
                }
                lm.cm = cm;
                this._materialLoaded.push(lm);
                if (this._sprites.length > 0)
                    this.applyMaterial(lm);
            }
        }
        this._mtlLibLoaded = true;
    };
    OBJParser.prototype.parseMapKdString = function (trunk) {
        var url = "";
        var i;
        var breakflag;
        for (i = 1; i < trunk.length;) {
            switch (trunk[i]) {
                case "-blendu":
                case "-blendv":
                case "-cc":
                case "-clamp":
                case "-texres":
                    i += 2; //Skip ahead 1 attribute
                    break;
                case "-mm":
                    i += 3; //Skip ahead 2 attributes
                    break;
                case "-o":
                case "-s":
                case "-t":
                    i += 4; //Skip ahead 3 attributes
                    continue;
                default:
                    breakflag = true;
                    break;
            }
            if (breakflag)
                break;
        }
        //Reconstruct URL/filename
        for (i; i < trunk.length; i++) {
            url += trunk[i];
            url += " ";
        }
        //Remove the extraneous space and/or newline from the right side
        url = url.replace(/\s+$/, "");
        return url;
    };
    OBJParser.prototype.loadMtl = function (mtlurl) {
        // Add raw-data dependency to queue and load dependencies now,
        // which will pause the parsing in the meantime.
        this._pAddDependency('mtl', new _awayjs_core.URLRequest(mtlurl), null, null, true);
        this._pPauseAndRetrieveDependencies(); //
    };
    OBJParser.prototype.applyMaterial = function (lm) {
        var decomposeID;
        var sprite;
        var tm;
        var j;
        var specularData;
        for (var i = 0; i < this._sprites.length; ++i) {
            sprite = this._sprites[i];
            decomposeID = sprite.material.name.split("~");
            if (decomposeID[0] == lm.materialID) {
                if (lm.cm) {
                    if (sprite.material)
                        sprite.material = null;
                    sprite.material = lm.cm;
                }
                else if (lm.texture) {
                    tm = sprite.material;
                    tm.ambientMethod.texture = lm.texture;
                    tm.style.color = lm.color;
                    tm.alpha = lm.alpha;
                    tm.style.sampler = new _awayjs_graphics.Sampler2D(true);
                    if (this.materialMode < 2)
                        tm.alpha = lm.alpha;
                    else
                        tm.mode = _awayjs_materials.MethodMaterialMode.MULTI_PASS;
                    if (lm.specularMethod) {
                        // By setting the specularMethod property to null before assigning
                        // the actual method instance, we avoid having the properties of
                        // the new method being overridden with the settings from the old
                        // one, which is default behavior of the setter.
                        tm.specularMethod = null;
                        tm.specularMethod = lm.specularMethod;
                    }
                    else if (this._materialSpecularData) {
                        for (j = 0; j < this._materialSpecularData.length; ++j) {
                            specularData = this._materialSpecularData[j];
                            if (specularData.materialID == lm.materialID) {
                                tm.specularMethod = null; // Prevent property overwrite (see above)
                                tm.specularMethod = specularData.basicSpecularMethod;
                                tm.specularMethod.color = specularData.color;
                                tm.specularMethod.strength = specularData.alpha;
                                break;
                            }
                        }
                    }
                }
                sprite.material.name = decomposeID[1] ? decomposeID[1] : decomposeID[0];
                this._sprites.splice(i, 1);
                --i;
            }
        }
        if (lm.cm || tm)
            this._pFinalizeAsset(lm.cm || tm);
    };
    OBJParser.prototype.applyMaterials = function () {
        if (this._materialLoaded.length == 0)
            return;
        for (var i = 0; i < this._materialLoaded.length; ++i)
            this.applyMaterial(this._materialLoaded[i]);
    };
    return OBJParser;
}(_awayjs_core.ParserBase));
var ObjectGroup = (function () {
    function ObjectGroup() {
        this.groups = new Array();
    }
    return ObjectGroup;
}());
var Group = (function () {
    function Group() {
        this.materialGroups = new Array();
    }
    return Group;
}());
var MaterialGroup = (function () {
    function MaterialGroup() {
        this.faces = new Array();
    }
    return MaterialGroup;
}());
var SpecularData = (function () {
    function SpecularData() {
        this.color = 0xFFFFFF;
        this.alpha = 1;
    }
    return SpecularData;
}());
var LoadedMaterial = (function () {
    function LoadedMaterial() {
        this.color = 0xFFFFFF;
        this.alpha = 1;
    }
    return LoadedMaterial;
}());
var FaceData = (function () {
    function FaceData() {
        this.vertexIndices = new Array();
        this.uvIndices = new Array();
        this.normalIndices = new Array();
        this.indexIds = new Array(); // used for real index lookups
    }
    return FaceData;
}());
/**
* Texture coordinates value object.
*/
var UV = (function () {
    /**
     * Creates a new <code>UV</code> object.
     *
     * @param    u        [optional]    The horizontal coordinate of the texture value. Defaults to 0.
     * @param    v        [optional]    The vertical coordinate of the texture value. Defaults to 0.
     */
    function UV(u, v) {
        if (u === void 0) { u = 0; }
        if (v === void 0) { v = 0; }
        this._u = u;
        this._v = v;
    }
    Object.defineProperty(UV.prototype, "v", {
        /**
         * Defines the vertical coordinate of the texture value.
         */
        get: function () {
            return this._v;
        },
        set: function (value) {
            this._v = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(UV.prototype, "u", {
        /**
         * Defines the horizontal coordinate of the texture value.
         */
        get: function () {
            return this._u;
        },
        set: function (value) {
            this._u = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * returns a new UV value Object
     */
    UV.prototype.clone = function () {
        return new UV(this._u, this._v);
    };
    /**
     * returns the value object as a string for trace/debug purpose
     */
    UV.prototype.toString = function () {
        return this._u + "," + this._v;
    };
    return UV;
}());
var Vertex = (function () {
    /**
     * Creates a new <code>Vertex</code> value object.
     *
     * @param    x            [optional]    The x value. Defaults to 0.
     * @param    y            [optional]    The y value. Defaults to 0.
     * @param    z            [optional]    The z value. Defaults to 0.
     * @param    index        [optional]    The index value. Defaults is NaN.
     */
    function Vertex(x, y, z, index) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        if (z === void 0) { z = 0; }
        if (index === void 0) { index = 0; }
        this._x = x;
        this._y = y;
        this._z = z;
        this._index = index;
    }
    Object.defineProperty(Vertex.prototype, "index", {
        get: function () {
            return this._index;
        },
        /**
         * To define/store the index of value object
         * @param    ind        The index
         */
        set: function (ind) {
            this._index = ind;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "x", {
        /**
         * To define/store the x value of the value object
         * @param    value        The x value
         */
        get: function () {
            return this._x;
        },
        set: function (value) {
            this._x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "y", {
        /**
         * To define/store the y value of the value object
         * @param    value        The y value
         */
        get: function () {
            return this._y;
        },
        set: function (value) {
            this._y = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Vertex.prototype, "z", {
        /**
         * To define/store the z value of the value object
         * @param    value        The z value
         */
        get: function () {
            return this._z;
        },
        set: function (value) {
            this._z = value;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * returns a new Vertex value Object
     */
    Vertex.prototype.clone = function () {
        return new Vertex(this._x, this._y, this._z);
    };
    return Vertex;
}());

/**
 *
 */
var Parsers = (function () {
    function Parsers() {
    }
    /**
     * Short-hand function to enable all bundled parsers for auto-detection. In practice,
     * this is the same as invoking enableParsers(Parsers.ALL_BUNDLED) on any of the
     * loader classes SingleFileLoader, LoaderSession, AssetLibrary or Loader3D.
     *
     * See notes about file size in the documentation for the ALL_BUNDLED constant.
     *
     * @see away.parsers.Parsers.ALL_BUNDLED
     */
    Parsers.enableAllBundled = function () {
        _awayjs_core.Loader.enableParsers(Parsers.ALL_BUNDLED);
    };
    return Parsers;
}());
/**
 * A list of all parsers that come bundled with Away3D. Use this to quickly
 * enable support for all bundled parsers to the file format auto-detection
 * feature, using any of the enableParsers() methods on loaders, e.g.:
 *
 * <code>AssetLibrary.enableParsers(Parsers.ALL_BUNDLED);</code>
 *
 * Beware however that this requires all parser classes to be included in the
 * SWF file, which will add 50-100 kb to the file. When only a limited set of
 * file formats are used, SWF file size can be saved by adding the parsers
 * individually using AssetLibrary.enableParser()
 *
 * A third way is to specify a parser for each loaded file, thereby bypassing
 * the auto-detection mechanisms altogether, while at the same time allowing
 * any properties that are unique to that parser to be set for that load.
 *
 * The bundled parsers are:
 *
 * <ul>
 * <li>AC3D (.ac)</li>
 * <li>Away Data version 1 ASCII and version 2 binary (.awd). AWD1 BSP unsupported</li>
 * <li>3DMax (.3ds)</li>
 * <li>DXF (.dxf)</li>
 * <li>Quake 2 MD2 models (.md2)</li>
 * <li>Doom 3 MD5 animation clips (.md5anim)</li>
 * <li>Doom 3 MD5 sprites (.md5sprite)</li>
 * <li>Wavefront OBJ (.obj)</li>
 * <li>Collada (.dae)</li>
 * <li>Images (.jpg, .png)</li>
 * </ul>
 *
 * @see away.library.AssetLibrary.enableParser
 */
Parsers.ALL_BUNDLED = Array(AWDParser, Max3DSParser, MD2Parser, OBJParser, FNTParser);

exports.DefaultSceneGraphFactory = DefaultSceneGraphFactory;
exports.AWDParser = AWDParser;
exports.Max3DSParser = Max3DSParser;
exports.FNTParser = FNTParser;
exports.FontParser = FontParser;
exports.MD2Parser = MD2Parser;
exports.MD5AnimParser = MD5AnimParser;
exports.MD5MeshParser = MD5MeshParser;
exports.OBJParser = OBJParser;
exports.Parsers = Parsers;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(7), __webpack_require__(10), __webpack_require__(12), __webpack_require__(9)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/core', '@awayjs/scene', '@awayjs/renderer', '@awayjs/graphics'], factory) :
    (factory((global.AwayjsView = global.AwayjsView || {}),global.AwayjsCore,global.AwayjsScene,global.AwayjsRenderer,global.AwayjsGraphics));
}(this, (function (exports,_awayjs_core,_awayjs_scene,_awayjs_renderer,_awayjs_graphics) { 'use strict';

/**
 * MouseManager enforces a singleton pattern and is not intended to be instanced.
 * it provides a manager class for detecting mouse hits on scene objects and sending out mouse events.
 */
var MouseManager = (function () {
    /**
     * Creates a new <code>MouseManager</code> object.
     */
    function MouseManager() {
        var _this = this;
        this._viewLookup = new Array();
        this._containerLookup = new Array();
        this._nullVector = new _awayjs_core.Vector3D();
        this._queuedEvents = new Array();
        this._mouseUp = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.MOUSE_UP);
        this._mouseClick = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.CLICK);
        this._mouseOut = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.MOUSE_OUT);
        this._mouseDown = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.MOUSE_DOWN);
        this._mouseMove = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.MOUSE_MOVE);
        this._mouseOver = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.MOUSE_OVER);
        this._mouseWheel = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.MOUSE_WHEEL);
        this._mouseDoubleClick = new _awayjs_scene.MouseEvent(_awayjs_scene.MouseEvent.DOUBLE_CLICK);
        this.onClickDelegate = function (event) { return _this.onClick(event); };
        this.onDoubleClickDelegate = function (event) { return _this.onDoubleClick(event); };
        this.onMouseDownDelegate = function (event) { return _this.onMouseDown(event); };
        this.onMouseMoveDelegate = function (event) { return _this.onMouseMove(event); };
        this.onMouseUpDelegate = function (event) { return _this.onMouseUp(event); };
        this.onMouseWheelDelegate = function (event) { return _this.onMouseWheel(event); };
        this.onMouseOverDelegate = function (event) { return _this.onMouseOver(event); };
        this.onMouseOutDelegate = function (event) { return _this.onMouseOut(event); };
    }
    MouseManager.prototype.registerContainer = function (container) {
        if (container && this._containerLookup.indexOf(container) == -1) {
            container.addEventListener("click", this.onClickDelegate);
            container.addEventListener("dblclick", this.onDoubleClickDelegate);
            container.addEventListener("touchstart", this.onMouseDownDelegate);
            container.addEventListener("mousedown", this.onMouseDownDelegate);
            container.addEventListener("touchmove", this.onMouseMoveDelegate);
            container.addEventListener("mousemove", this.onMouseMoveDelegate);
            container.addEventListener("mouseup", this.onMouseUpDelegate);
            container.addEventListener("touchend", this.onMouseUpDelegate);
            container.addEventListener("mousewheel", this.onMouseWheelDelegate);
            container.addEventListener("mouseover", this.onMouseOverDelegate);
            container.addEventListener("mouseout", this.onMouseOutDelegate);
            this._containerLookup.push(container);
        }
    };
    MouseManager.prototype.unregisterContainer = function (container) {
        if (container && this._containerLookup.indexOf(container) != -1) {
            container.removeEventListener("click", this.onClickDelegate);
            container.removeEventListener("dblclick", this.onDoubleClickDelegate);
            container.removeEventListener("touchstart", this.onMouseDownDelegate);
            container.removeEventListener("mousedown", this.onMouseDownDelegate);
            container.removeEventListener("touchmove", this.onMouseMoveDelegate);
            container.removeEventListener("mousemove", this.onMouseMoveDelegate);
            container.removeEventListener("touchend", this.onMouseUpDelegate);
            container.removeEventListener("mouseup", this.onMouseUpDelegate);
            container.removeEventListener("mousewheel", this.onMouseWheelDelegate);
            container.removeEventListener("mouseover", this.onMouseOverDelegate);
            container.removeEventListener("mouseout", this.onMouseOutDelegate);
            this._containerLookup.slice(this._containerLookup.indexOf(container), 1);
        }
    };
    MouseManager.getInstance = function () {
        if (this._instance)
            return this._instance;
        return (this._instance = new MouseManager());
    };
    MouseManager.prototype.fireMouseEvents = function (forceMouseMove) {
        // If colliding object has changed, queue over/out events.
        if (this._iCollision != this._previousCollidingObject) {
            if (this._previousCollidingObject)
                this.queueDispatch(this._mouseOut, this._mouseMoveEvent, this._previousCollidingObject);
            if (this._iCollision)
                this.queueDispatch(this._mouseOver, this._mouseMoveEvent);
        }
        // Fire mouse move events here if forceMouseMove is on.
        if (forceMouseMove && this._iCollision)
            this.queueDispatch(this._mouseMove, this._mouseMoveEvent);
        var event;
        var dispatcher;
        // Dispatch all queued events.
        var len = this._queuedEvents.length;
        for (var i = 0; i < len; ++i) {
            event = this._queuedEvents[i];
            dispatcher = event.entity;
            // bubble event up the heirarchy until the top level parent is reached
            while (dispatcher) {
                //console.log("dispatcher", dispatcher, dispatcher.adapter.constructor.name);
                if (dispatcher._iIsMouseEnabled()) {
                    dispatcher.dispatchEvent(event);
                }
                dispatcher = dispatcher.parent;
            }
            // not totally sure, but i think just calling it is easier and cheaper than any options for that
            // if nothing is queued, the function will return directly anyway
            _awayjs_scene.FrameScriptManager.execute_queue();
        }
        this._queuedEvents.length = 0;
        this._previousCollidingObject = this._iCollision;
        this._iUpdateDirty = false;
    };
    //		public addViewLayer(view:View)
    //		{
    //			var stg:Stage = view.stage;
    //
    //			// Add instance to mouse3dmanager to fire mouse events for multiple views
    //			if (!view.stageGL.mouse3DManager)
    //				view.stageGL.mouse3DManager = this;
    //
    //			if (!hasKey(view))
    //				_view3Ds[view] = 0;
    //
    //			_childDepth = 0;
    //			traverseDisplayObjects(stg);
    //			_viewCount = _childDepth;
    //		}
    MouseManager.prototype.registerView = function (view) {
        if (view)
            this._viewLookup.push(view);
    };
    MouseManager.prototype.unregisterView = function (view) {
        if (view)
            this._viewLookup.slice(this._viewLookup.indexOf(view), 1);
    };
    MouseManager.prototype.addEventsForViewBinary = function (touchMessage, viewIdx) {
        if (viewIdx === void 0) { viewIdx = 0; }
        var newTouchEvent = {};
        newTouchEvent.clientX = null; // we get the x position from the active touch
        newTouchEvent.clientY = null; // we get the y position from the active touch
        newTouchEvent.touches = [];
        newTouchEvent.changedTouches = [];
        newTouchEvent.preventDefault = function () { };
        var messageView = new Float32Array(touchMessage);
        // transfer touches to event
        var i = 0;
        var cnt = 0;
        var touchCnt = 0;
        cnt++; //we temporary added 1 float to transfer fps from java to js. skip this
        var numTouches = messageView[cnt++];
        var touchtype = messageView[cnt++];
        var activeTouchID = messageView[cnt++];
        var x = 0;
        var y = 0;
        if ((touchtype != 1) && (touchtype != 6) && (touchtype != 12) && (touchtype != 262) && (touchtype != 518)) {
            // if this is not a UP command, we add all touches
            for (i = 0; i < numTouches; i++) {
                var newTouch = {};
                newTouch.identifier = messageView[cnt++];
                newTouch.clientX = messageView[cnt++];
                newTouch.clientY = messageView[cnt++];
                newTouchEvent.touches[i] = newTouch;
            }
            newTouchEvent.changedTouches[0] = newTouchEvent.touches[activeTouchID];
            x = newTouchEvent.changedTouches[0].clientX;
            y = newTouchEvent.changedTouches[0].clientY;
        }
        else {
            // if this is a UP command, we add all touches, except the active one
            if (numTouches == 1) {
                var newTouch = {};
                newTouch.identifier = messageView[cnt++];
                newTouch.clientX = messageView[cnt++];
                newTouch.clientY = messageView[cnt++];
                newTouchEvent.clientX = newTouch.clientX;
                newTouchEvent.clientY = newTouch.clientY;
                x = newTouchEvent.clientX;
                y = newTouchEvent.clientY;
            }
            else {
                for (i = 0; i < numTouches; i++) {
                    var newTouch = {};
                    newTouch.identifier = messageView[cnt++];
                    newTouch.clientX = messageView[cnt++];
                    newTouch.clientY = messageView[cnt++];
                    if (i != activeTouchID) {
                        newTouchEvent.touches[touchCnt] = newTouch;
                    }
                    else {
                        newTouchEvent.clientX = newTouch.clientX;
                        newTouchEvent.clientY = newTouch.clientY;
                        x = newTouchEvent.clientX;
                        y = newTouchEvent.clientY;
                    }
                }
            }
        }
        //console.log("Touch ID:"+touchtype+" activeTouchID "+activeTouchID+" numTouches "+numTouches+" x"+x+" y"+y);
        /*
         public static final int ACTION_DOWN = 0;
         public static final int ACTION_POINTER_1_DOWN = 5;
         public static final int ACTION_POINTER_DOWN = 5;
         public static final int ACTION_BUTTON_PRESS = 11;
         public static final int ACTION_POINTER_2_DOWN = 261;
         public static final int ACTION_POINTER_3_DOWN = 517;


         public static final int ACTION_UP = 1;
         public static final int ACTION_POINTER_1_UP = 6;
         public static final int ACTION_POINTER_UP = 6;
         public static final int ACTION_BUTTON_RELEASE = 12;
         public static final int ACTION_POINTER_2_UP = 262;
         public static final int ACTION_POINTER_3_UP = 518;

         public static final int ACTION_MOVE = 2;


         */
        if ((touchtype == 0) || (touchtype == 5) || (touchtype == 11) || (touchtype == 261) || (touchtype == 517)) {
            this.onMouseDown(newTouchEvent);
        }
        else if ((touchtype == 1) || (touchtype == 6) || (touchtype == 12) || (touchtype == 262) || (touchtype == 518)) {
            this.onMouseUp(newTouchEvent);
        }
        else if (touchtype == 2) {
            this.onMouseMove(newTouchEvent);
        }
        else {
            console.log("recieved unknown touch event-type: " + touchtype);
        }
    };
    MouseManager.prototype.fireEventsForViewFromString = function (touchMessage, viewIdx) {
        if (viewIdx === void 0) { viewIdx = 0; }
        var newTouchEvent = {};
        newTouchEvent.clientX = null; // set the x position from the active touch
        newTouchEvent.clientY = null; // set the y position from the active touch
        newTouchEvent.preventDefault = function () { };
        var touchesFromMessage = touchMessage.split(",");
        // transfer touches to event
        var i = 0;
        var cnt = 0;
        var numTouches = parseInt(touchesFromMessage[cnt++]);
        var touchtype = parseInt(touchesFromMessage[cnt++]);
        var activeTouch = parseInt(touchesFromMessage[cnt++]);
        newTouchEvent.touches = [];
        newTouchEvent.changedTouches = [];
        if ((touchtype != 1) && (touchtype != 6)) {
            for (i = 0; i < numTouches; i++) {
                var newTouch = {};
                newTouch.identifier = touchesFromMessage[cnt++];
                newTouch.clientX = touchesFromMessage[cnt++];
                newTouch.clientY = touchesFromMessage[cnt++];
                newTouchEvent.touches[i] = newTouch;
                newTouchEvent.changedTouches[i] = newTouch;
            }
            
            newTouchEvent.changedTouches[i] = newTouchEvent.touches[activeTouch];
        }
        else {
            for (i = 0; i < numTouches; i++) {
                if (i != activeTouch) {
                    var newTouch = {};
                    newTouch.identifier = touchesFromMessage[cnt++];
                    newTouch.clientX = touchesFromMessage[cnt++];
                    newTouch.clientY = touchesFromMessage[cnt++];
                    newTouchEvent.touches[i] = newTouch;
                    newTouchEvent.changedTouches[i] = newTouch;
                }
                else {
                    newTouchEvent.clientX = touchesFromMessage[cnt++];
                    newTouchEvent.clientY = touchesFromMessage[cnt++];
                    cnt++;
                }
            }
            
        }
        if (touchtype == 0) {
            this.onMouseDown(newTouchEvent);
        }
        else if (touchtype == 1) {
            this.onMouseUp(newTouchEvent);
        }
        else if (touchtype == 2) {
            this.onMouseMove(newTouchEvent);
        }
        else if (touchtype == 261) {
            this.onMouseDown(newTouchEvent);
        }
        else if (touchtype == 6) {
            this.onMouseUp(newTouchEvent);
        }
    };
    // ---------------------------------------------------------------------
    // Private.
    // ---------------------------------------------------------------------
    MouseManager.prototype.queueDispatch = function (event, sourceEvent, collision) {
        if (collision === void 0) { collision = null; }
        // 2D properties.
        if (sourceEvent) {
            event.delta = sourceEvent.wheelDelta;
            event.ctrlKey = sourceEvent.ctrlKey;
            event.altKey = sourceEvent.altKey;
            event.shiftKey = sourceEvent.shiftKey;
            event.screenX = (sourceEvent.clientX != null) ? sourceEvent.clientX : sourceEvent.changedTouches[0].clientX;
            event.screenY = (sourceEvent.clientY != null) ? sourceEvent.clientY : sourceEvent.changedTouches[0].clientY;
        }
        if (collision == null)
            collision = this._iCollision;
        // 3D properties.
        if (collision) {
            // Object.
            event.entity = collision.entity;
            event.renderable = collision.renderable;
            // UV.
            event.uv = collision.uv;
            // Position.
            event.position = collision.position ? collision.position.clone() : null;
            // Normal.
            event.normal = collision.normal ? collision.normal.clone() : null;
            // Face index.
            event.elementIndex = collision.elementIndex;
        }
        else {
            // Set all to null.
            event.uv = null;
            event.entity = null;
            event.position = this._nullVector;
            event.normal = this._nullVector;
            event.elementIndex = 0;
        }
        // Store event to be dispatched later.
        this._queuedEvents.push(event);
    };
    // ---------------------------------------------------------------------
    // Listeners.
    // ---------------------------------------------------------------------
    MouseManager.prototype.onMouseMove = function (event) {
        event.preventDefault();
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseMove, this._mouseMoveEvent = event);
    };
    MouseManager.prototype.onMouseOut = function (event) {
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseOut, event);
    };
    MouseManager.prototype.onMouseOver = function (event) {
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseOver, event);
    };
    MouseManager.prototype.onClick = function (event) {
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseClick, event);
    };
    MouseManager.prototype.onDoubleClick = function (event) {
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseDoubleClick, event);
    };
    MouseManager.prototype.onMouseDown = function (event) {
        event.preventDefault();
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseDown, event);
    };
    MouseManager.prototype.onMouseUp = function (event) {
        event.preventDefault();
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseUp, event);
    };
    MouseManager.prototype.onMouseWheel = function (event) {
        this.updateColliders(event);
        if (this._iCollision)
            this.queueDispatch(this._mouseWheel, event);
    };
    MouseManager.prototype.updateColliders = function (event) {
        var view;
        var mouseX = (event.clientX != null) ? event.clientX : event.changedTouches[0].clientX;
        var mouseY = (event.clientY != null) ? event.clientY : event.changedTouches[0].clientY;
        var len = this._viewLookup.length;
        for (var i = 0; i < len; i++) {
            view = this._viewLookup[i];
            view._pTouchPoints.length = 0;
            if (event.touches) {
                var touch;
                var len = event.touches.length;
                for (var i = 0; i < len; i++) {
                    touch = event.touches[i];
                    view._pTouchPoints.push(new _awayjs_scene.TouchPoint(touch.clientX + view.x, touch.clientY + view.y, touch.identifier));
                }
            }
            if (this._iUpdateDirty)
                continue;
            if (mouseX < view.x || mouseX > view.x + view.width || mouseY < view.y || mouseY > view.y + view.height) {
                view._pMouseX = null;
                view._pMouseY = null;
            }
            else {
                view._pMouseX = mouseX + view.x;
                view._pMouseY = mouseY + view.y;
                view.updateCollider();
                if (view.layeredView && this._iCollision)
                    break;
            }
        }
        this._iUpdateDirty = true;
    };
    return MouseManager;
}());

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

/**
 * @class away.partition.EntityNode
 */
var DisplayObjectNode = (function (_super) {
    __extends(DisplayObjectNode, _super);
    function DisplayObjectNode(entity, pool) {
        var _this = _super.call(this, entity, pool) || this;
        _this.numEntities = 0;
        _this.isSceneGraphNode = false;
        _this._boundsDirty = true;
        _this._onInvalidatePartitionBoundsDelegate = function (event) { return _this._onInvalidatePartitionBounds(event); };
        _this._entity = entity;
        _this._entity.addEventListener(_awayjs_scene.DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS, _this._onInvalidatePartitionBoundsDelegate);
        _this._boundsType = _this._entity.boundsType;
        return _this;
    }
    Object.defineProperty(DisplayObjectNode.prototype, "debugVisible", {
        get: function () {
            return this._entity.debugVisible;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(DisplayObjectNode.prototype, "bounds", {
        /**
         * @internal
         */
        get: function () {
            if (this._boundsDirty)
                this._updateBounds();
            return this._bounds;
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @returns {boolean}
     */
    DisplayObjectNode.prototype.isCastingShadow = function () {
        return this._entity.castsShadows;
    };
    /**
     *
     * @returns {boolean}
     */
    DisplayObjectNode.prototype.isMask = function () {
        return this._entity.maskMode;
    };
    DisplayObjectNode.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._entity.removeEventListener(_awayjs_scene.DisplayObjectEvent.INVALIDATE_PARTITION_BOUNDS, this._onInvalidatePartitionBoundsDelegate);
        this._entity = null;
        if (this._bounds)
            this._bounds.dispose();
        this._bounds = null;
    };
    DisplayObjectNode.prototype.onInvalidate = function (event) {
        _super.prototype.onInvalidate.call(this, event);
        if (this._boundsType != this._entity.boundsType) {
            this._boundsType = this._entity.boundsType;
            this._boundsDirty = true;
        }
    };
    /**
     *
     * @param planes
     * @param numPlanes
     * @returns {boolean}
     */
    DisplayObjectNode.prototype.isInFrustum = function (planes, numPlanes) {
        return true;
    };
    /**
     * @inheritDoc
     */
    DisplayObjectNode.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
        return true;
    };
    /**
     *
     * @returns {boolean}
     */
    DisplayObjectNode.prototype.isRenderable = function () {
        return true;
    };
    DisplayObjectNode.prototype.renderBounds = function (traverser) {
        traverser.applyEntity(this.bounds.boundsPrimitive);
    };
    /**
     * @inheritDoc
     */
    DisplayObjectNode.prototype.acceptTraverser = function (traverser) {
        // do nothing here
    };
    DisplayObjectNode.prototype._onInvalidatePartitionBounds = function (event) {
        // do nothing here
    };
    DisplayObjectNode.prototype._updateBounds = function () {
        if (this._bounds)
            this._bounds.dispose();
        if (this._boundsType == _awayjs_scene.BoundsType.AXIS_ALIGNED_BOX)
            this._bounds = new _awayjs_scene.AxisAlignedBoundingBox(this._entity);
        else if (this._boundsType == _awayjs_scene.BoundsType.SPHERE)
            this._bounds = new _awayjs_scene.BoundingSphere(this._entity);
        else if (this._boundsType == _awayjs_scene.BoundsType.NULL)
            this._bounds = new _awayjs_scene.NullBounds();
        this._boundsDirty = false;
    };
    return DisplayObjectNode;
}(_awayjs_core.AbstractionBase));

/**
 * Maintains scenegraph heirarchy when collecting nodes
 */
var SceneGraphNode = (function (_super) {
    __extends(SceneGraphNode, _super);
    function SceneGraphNode() {
        var _this = _super.apply(this, arguments) || this;
        _this.isSceneGraphNode = true;
        _this._numNodes = 0;
        _this._pChildNodes = new Array();
        _this._childDepths = new Array();
        _this._numMasks = 0;
        _this._childMasks = new Array();
        return _this;
    }
    /**
     *
     * @param traverser
     */
    SceneGraphNode.prototype.acceptTraverser = function (traverser) {
        //containers nodes are for ordering only, no need to check enterNode or debugVisible
        if (this.numEntities == 0)
            return;
        var i;
        for (i = this._numNodes - 1; i >= 0; i--)
            this._pChildNodes[i].acceptTraverser(traverser);
        for (i = this._numMasks - 1; i >= 0; i--)
            this._childMasks[i].acceptTraverser(traverser);
    };
    /**
     *
     * @param node
     * @internal
     */
    SceneGraphNode.prototype.iAddNode = function (node) {
        node.parent = this;
        if (node._entity.maskMode) {
            this._childMasks.push(node);
            this._numMasks++;
        }
        else {
            var depth = (this._entity != node._entity) ? node._entity._depthID : -16384;
            var len = this._childDepths.length;
            var index = len;
            while (index--)
                if (this._childDepths[index] < depth)
                    break;
            index++;
            if (index < len) {
                this._pChildNodes.splice(index, 0, node);
                this._childDepths.splice(index, 0, depth);
            }
            else {
                this._pChildNodes.push(node);
                this._childDepths.push(depth);
            }
            this._numNodes++;
        }
        var numEntities = node.isSceneGraphNode ? node.numEntities : 1;
        node = this;
        do {
            node.numEntities += numEntities;
        } while ((node = node.parent) != null);
    };
    /**
     *
     * @param node
     * @internal
     */
    SceneGraphNode.prototype.iRemoveNode = function (node) {
        if (node._entity.maskMode) {
            this._childMasks.splice(this._childMasks.indexOf(node), 1);
            this._numMasks--;
        }
        else {
            var index = this._pChildNodes.indexOf(node);
            this._pChildNodes.splice(index, 1);
            this._childDepths.splice(index, 1);
            this._numNodes--;
        }
        var numEntities = node.numEntities;
        node = this;
        do {
            node.numEntities -= numEntities;
        } while ((node = node.parent) != null);
    };
    return SceneGraphNode;
}(DisplayObjectNode));

/**
 * @class away.partition.Partition
 */
var PartitionBase = (function () {
    function PartitionBase(root) {
        this._abstractionPool = new Object();
        this._updateQueue = {};
        this._root = root;
    }
    Object.defineProperty(PartitionBase.prototype, "root", {
        get: function () {
            return this._root;
        },
        enumerable: true,
        configurable: true
    });
    PartitionBase.prototype.getAbstraction = function (entity) {
        return (this._abstractionPool[entity.id] || (this._abstractionPool[entity.id] = new PartitionBase._abstractionClassPool[entity.assetType](entity, this)));
    };
    /**
     *
     * @param image
     */
    PartitionBase.prototype.clearAbstraction = function (entity) {
        this._abstractionPool[entity.id] = null;
    };
    PartitionBase.prototype.traverse = function (traverser) {
        this.updateEntities();
        if (this._rootNode)
            this._rootNode.acceptTraverser(traverser);
    };
    PartitionBase.prototype.invalidateEntity = function (entity) {
        this._updateQueue[entity.id] = entity;
    };
    PartitionBase.prototype.updateEntity = function (entity) {
        entity._iInternalUpdate();
        if (entity.isEntity)
            this.updateNode(this.getAbstraction(entity));
    };
    PartitionBase.prototype.updateNode = function (node) {
        var targetNode = this.findParentForNode(node);
        if (node.parent != targetNode) {
            if (node.parent)
                node.parent.iRemoveNode(node);
            targetNode.iAddNode(node);
        }
    };
    PartitionBase.prototype.clearEntity = function (entity) {
        delete this._updateQueue[entity.id];
        if (entity.isEntity)
            this.clearNode(this.getAbstraction(entity));
    };
    PartitionBase.prototype.clearNode = function (node) {
        if (node.parent) {
            node.parent.iRemoveNode(node);
            node.parent = null;
        }
    };
    /**
     *
     * @param entity
     * @returns {away.partition.NodeBase}
     */
    PartitionBase.prototype.findParentForNode = function (node) {
        return this._rootNode;
    };
    PartitionBase.prototype.updateEntities = function () {
        var entity;
        //required for controllers with autoUpdate set to true and queued events
        for (var key in this._updateQueue)
            this.updateEntity(this._updateQueue[key]);
        //clear updateQueue
        this._updateQueue = {};
    };
    PartitionBase.prototype.dispose = function () {
        //TODO
    };
    /**
     *
     * @param imageObjectClass
     */
    PartitionBase.registerAbstraction = function (entityNodeClass, assetClass) {
        PartitionBase._abstractionClassPool[assetClass.assetType] = entityNodeClass;
    };
    return PartitionBase;
}());
PartitionBase._abstractionClassPool = new Object();

/**
 * @class away.partition.Partition
 */
var SceneGraphPartition = (function (_super) {
    __extends(SceneGraphPartition, _super);
    function SceneGraphPartition(root) {
        var _this = _super.call(this, root) || this;
        _this._sceneGraphNodePool = new SceneGraphNodePool();
        return _this;
    }
    SceneGraphPartition.prototype.traverse = function (traverser) {
        _super.prototype.traverse.call(this, traverser);
    };
    /**
     *
     * @param entity
     * @returns {away.partition.NodeBase}
     */
    SceneGraphPartition.prototype.findParentForNode = function (node) {
        if (this._root == node._entity && node.isSceneGraphNode) {
            this._rootNode = node;
            return null;
        }
        if (!node.isSceneGraphNode && node._entity.isContainer)
            return this._sceneGraphNodePool.getAbstraction(node._entity);
        return this._sceneGraphNodePool.getAbstraction(node._entity.parent);
    };
    SceneGraphPartition.prototype.updateEntity = function (entity) {
        _super.prototype.updateEntity.call(this, entity);
        if (entity.isContainer)
            this.updateNode(this._sceneGraphNodePool.getAbstraction(entity));
    };
    SceneGraphPartition.prototype.clearEntity = function (entity) {
        _super.prototype.clearEntity.call(this, entity);
        if (entity.isContainer)
            this.clearNode(this._sceneGraphNodePool.getAbstraction(entity));
    };
    return SceneGraphPartition;
}(PartitionBase));
/**
 * @class away.pool.SceneGraphNodePool
 */
var SceneGraphNodePool = (function () {
    function SceneGraphNodePool() {
        this._abstractionPool = new Object();
    }
    /**
     * //TODO
     *
     * @param entity
     * @returns EntityNode
     */
    SceneGraphNodePool.prototype.getAbstraction = function (entity) {
        return (this._abstractionPool[entity.id] || (this._abstractionPool[entity.id] = new SceneGraphNode(entity, this)));
    };
    /**
     * //TODO
     *
     * @param entity
     */
    SceneGraphNodePool.prototype.clearAbstraction = function (entity) {
        delete this._abstractionPool[entity.id];
    };
    return SceneGraphNodePool;
}());

/**
 * Picks a 3d object from a view or scene by 3D raycast calculations.
 * Performs an initial coarse boundary calculation to return a subset of entities whose bounding volumes intersect with the specified ray,
 * then triggers an optional picking collider on individual renderable objects to further determine the precise values of the picking ray collision.
 *
 * @class away.pick.RaycastPicker
 */
var RaycastPicker = (function (_super) {
    __extends(RaycastPicker, _super);
    /**
     * Creates a new <code>RaycastPicker</code> object.
     *
     * @param findClosestCollision Determines whether the picker searches for the closest bounds collision along the ray,
     * or simply returns the first collision encountered. Defaults to false.
     */
    function RaycastPicker(findClosestCollision) {
        if (findClosestCollision === void 0) { findClosestCollision = false; }
        var _this = _super.call(this) || this;
        _this._entities = new Array();
        /**
         * @inheritDoc
         */
        _this.onlyMouseEnabled = true;
        _this._findClosestCollision = findClosestCollision;
        return _this;
    }
    /**
     * Returns true if the current node is at least partly in the frustum. If so, the partition node knows to pass on the traverser to its children.
     *
     * @param node The Partition3DNode object to frustum-test.
     */
    RaycastPicker.prototype.enterNode = function (node) {
        return node.isIntersectingRay(this._rayPosition, this._rayDirection) && !node.isMask();
    };
    /**
     * @inheritDoc
     */
    RaycastPicker.prototype.getCollision = function (rayPosition, rayDirection, view) {
        this._rayPosition = rayPosition;
        this._rayDirection = rayDirection;
        // collect entities to test
        view.traversePartitions(this);
        //early out if no collisions detected
        if (!this._entities.length)
            return null;
        //console.log("entities: ", this._entities)
        var collision = this.getPickingCollision(view);
        //discard entities
        this._entities.length = 0;
        return collision;
    };
    //		public getEntityCollision(position:Vector3D, direction:Vector3D, entities:Array<IEntity>):PickingCollision
    //		{
    //			this._numRenderables = 0;
    //
    //			var renderable:IEntity;
    //			var l:number = entities.length;
    //
    //			for (var c:number = 0; c < l; c++) {
    //				renderable = entities[c];
    //
    //				if (renderable.isIntersectingRay(position, direction))
    //					this._renderables[this._numRenderables++] = renderable;
    //			}
    //
    //			return this.getPickingCollision(this._raycastCollector);
    //		}
    RaycastPicker.prototype.setIgnoreList = function (entities) {
        this._ignoredEntities = entities;
    };
    RaycastPicker.prototype.isIgnored = function (entity) {
        if (this.onlyMouseEnabled && !entity._iIsMouseEnabled())
            return true;
        if (this._ignoredEntities) {
            var len = this._ignoredEntities.length;
            for (var i = 0; i < len; i++)
                if (this._ignoredEntities[i] == entity)
                    return true;
        }
        return false;
    };
    RaycastPicker.prototype.sortOnNearT = function (entity1, entity2) {
        return entity1._iPickingCollision.rayEntryDistance > entity2._iPickingCollision.rayEntryDistance ? 1 : -1; //entity1._iPickingCollision.rayEntryDistance < entity2._iPickingCollision.rayEntryDistance?-1:0;
    };
    RaycastPicker.prototype.getPickingCollision = function (view) {
        // Sort entities from closest to furthest to reduce tests.
        this._entities = this._entities.sort(this.sortOnNearT); // TODO - test sort filter in JS
        // ---------------------------------------------------------------------
        // Evaluate triangle collisions when needed.
        // Replaces collision data provided by bounds collider with more precise data.
        // ---------------------------------------------------------------------
        this._bestCollision = null;
        var len = this._entities.length;
        for (var i = 0; i < len; i++) {
            this._entity = this._entities[i];
            this._testCollision = this._entity._iPickingCollision;
            if (this._bestCollision == null || this._testCollision.rayEntryDistance < this._bestCollision.rayEntryDistance) {
                this._testCollider = view.getPartition(this._entity).getAbstraction(this._entity).pickingCollider;
                if (this._testCollider) {
                    this._testCollision.rayEntryDistance = Number.MAX_VALUE;
                    this._entity._acceptTraverser(this);
                    // If a collision exists, update the collision data and stop all checks.
                    if (this._bestCollision && !this._findClosestCollision)
                        break;
                }
                else if (!this._testCollision.rayOriginIsInsideBounds) {
                    // A bounds collision with no picking collider stops all checks.
                    // Note: a bounds collision with a ray origin inside its bounds is ONLY ever used
                    // to enable the detection of a corresponsding triangle collision.
                    // Therefore, bounds collisions with a ray origin inside its bounds can be ignored
                    // if it has been established that there is NO triangle collider to test
                    this._bestCollision = this._testCollision;
                    break;
                }
            }
        }
        if (this._bestCollision)
            this.updatePosition(this._bestCollision);
        return this._bestCollision;
    };
    RaycastPicker.prototype.updatePosition = function (pickingCollision) {
        var collisionPos = pickingCollision.position || (pickingCollision.position = new _awayjs_core.Vector3D());
        var rayDir = pickingCollision.rayDirection;
        var rayPos = pickingCollision.rayPosition;
        var t = pickingCollision.rayEntryDistance;
        collisionPos.x = rayPos.x + t * rayDir.x;
        collisionPos.y = rayPos.y + t * rayDir.y;
        collisionPos.z = rayPos.z + t * rayDir.z;
    };
    RaycastPicker.prototype.dispose = function () {
        //TODO
    };
    /**
     *
     * @param entity
     */
    RaycastPicker.prototype.applyEntity = function (entity) {
        if (!this.isIgnored(entity))
            this._entities.push(entity);
    };
    RaycastPicker.prototype.applyBillboard = function (billboard) {
        if (this._testCollider.testBillboardCollision(billboard, billboard.material, this._testCollision))
            this._bestCollision = this._testCollision;
    };
    RaycastPicker.prototype.applyLineShape = function (shape) {
        if (this._testCollider.testLineCollision(shape.elements, shape.material || this._entity.material, this._testCollision, shape.count || shape.elements.numVertices, shape.offset))
            this._bestCollision = this._testCollision;
    };
    RaycastPicker.prototype.applyTriangleShape = function (shape) {
        if (this._testCollider.testTriangleCollision(shape.elements, shape.material || this._entity.material, this._testCollision, shape.count || shape.elements.numVertices, shape.offset))
            this._bestCollision = this._testCollision;
    };
    /**
     *
     * @param entity
     */
    RaycastPicker.prototype.applyDirectionalLight = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    RaycastPicker.prototype.applyLightProbe = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    RaycastPicker.prototype.applyPointLight = function (entity) {
        //don't do anything here
    };
    /**
     *
     * @param entity
     */
    RaycastPicker.prototype.applySkybox = function (entity) {
        //don't do anything here
    };
    return RaycastPicker;
}(_awayjs_graphics.TraverserBase));

/**
 * @class away.partition.NodeBase
 */
var NodeBase = (function () {
    /**
     *
     */
    function NodeBase() {
        this._bounds = new _awayjs_scene.NullBounds();
        this._pChildNodes = new Array();
        this._pNumChildNodes = 0;
        this.numEntities = 0;
    }
    Object.defineProperty(NodeBase.prototype, "debugVisible", {
        get: function () {
            return false;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(NodeBase.prototype, "bounds", {
        /**
         * @internal
         */
        get: function () {
            return this._bounds; //TODO
        },
        enumerable: true,
        configurable: true
    });
    /**
     *
     * @param planes
     * @param numPlanes
     * @returns {boolean}
     * @internal
     */
    NodeBase.prototype.isInFrustum = function (planes, numPlanes) {
        return true;
    };
    /**
     *
     * @param rayPosition
     * @param rayDirection
     * @returns {boolean}
     */
    NodeBase.prototype.isIntersectingRay = function (rayPosition, rayDirection) {
        return true;
    };
    /**
     *
     * @returns {boolean}
     */
    NodeBase.prototype.isRenderable = function () {
        return true;
    };
    /**
     *
     * @returns {boolean}
     */
    NodeBase.prototype.isCastingShadow = function () {
        return true;
    };
    NodeBase.prototype.renderBounds = function (traverser) {
        //nothing to do here
    };
    /**
     *
     * @returns {boolean}
     */
    NodeBase.prototype.isMask = function () {
        return false;
    };
    NodeBase.prototype.dispose = function () {
        this.parent = null;
        this._pChildNodes = null;
    };
    /**
     *
     * @param traverser
     */
    NodeBase.prototype.acceptTraverser = function (traverser) {
        if (this.numEntities == 0)
            return;
        if (traverser.enterNode(this)) {
            for (var i = 0; i < this._pNumChildNodes; i++)
                this._pChildNodes[i].acceptTraverser(traverser);
        }
    };
    /**
     *
     * @param node
     * @internal
     */
    NodeBase.prototype.iAddNode = function (node) {
        node.parent = this;
        this.numEntities += node.numEntities;
        this._pChildNodes[this._pNumChildNodes++] = node;
        var numEntities = node.numEntities;
        node = this;
        do {
            node.numEntities += numEntities;
        } while ((node = node.parent) != null);
    };
    /**
     *
     * @param node
     * @internal
     */
    NodeBase.prototype.iRemoveNode = function (node) {
        var index = this._pChildNodes.indexOf(node);
        this._pChildNodes[index] = this._pChildNodes[--this._pNumChildNodes];
        this._pChildNodes.pop();
        var numEntities = node.numEntities;
        node = this;
        do {
            node.numEntities -= numEntities;
        } while ((node = node.parent) != null);
    };
    return NodeBase;
}());

/**
 * @class away.partition.Partition
 */
var BasicPartition = (function (_super) {
    __extends(BasicPartition, _super);
    function BasicPartition(root) {
        var _this = _super.call(this, root) || this;
        _this._rootNode = new NodeBase();
        return _this;
    }
    return BasicPartition;
}(PartitionBase));

var View = (function () {
    /*
     ***********************************************************************
     * Disabled / Not yet implemented
     ***********************************************************************
     *
     * private _background:away.textures.Texture2DBase;
     *
     * public _pTouch3DManager:away.managers.Touch3DManager;
     *
     */
    function View(renderer, scene, camera) {
        if (renderer === void 0) { renderer = null; }
        if (scene === void 0) { scene = null; }
        if (camera === void 0) { camera = null; }
        var _this = this;
        this._time = 0;
        this._deltaTime = 0;
        this._backgroundColor = 0x000000;
        this._backgroundAlpha = 1;
        this._viewportDirty = true;
        this._scissorDirty = true;
        this._mousePicker = new RaycastPicker();
        this._partitions = new Object();
        this._pTouchPoints = new Array();
        this._onProjectionChangedDelegate = function (event) { return _this._onProjectionChanged(event); };
        this._onViewportUpdatedDelegate = function (event) { return _this._onViewportUpdated(event); };
        this._onScissorUpdatedDelegate = function (event) { return _this._onScissorUpdated(event); };
        this._mouseManager = MouseManager.getInstance();
        this._mouseManager.registerView(this);
        this.scene = scene || new _awayjs_scene.Scene();
        this.camera = camera || new _awayjs_scene.Camera();
        this.renderer = renderer || new _awayjs_renderer.DefaultRenderer();
        //			if (this._shareContext)
        //				this._mouse3DManager.addViewLayer(this);
    }
    View.prototype.getPartition = function (entity) {
        //use registered partition for the displayobject or fallback for scene
        return this._partitions[entity.partition.id] || this._partitions[this._pScene.id];
    };
    View.prototype.setPartition = function (entity, partition) {
        var oldPartition = this._partitions[entity.id];
        if (oldPartition == partition)
            return;
        //clears all existing entities on the partition
        entity.isPartition = false;
        if (oldPartition) {
            oldPartition.dispose();
            delete this._partitions[entity.id];
        }
        if (partition) {
            this._partitions[entity.id] = partition;
            entity.isPartition = true;
        }
    };
    View.prototype.getCollider = function (entity) {
        return this.getPartition(entity).getAbstraction(entity).pickingCollider;
    };
    View.prototype.setCollider = function (entity, collider) {
        this.getPartition(entity).getAbstraction(entity).pickingCollider = collider;
    };
    Object.defineProperty(View.prototype, "mouseX", {
        get: function () {
            return this._pMouseX;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "mouseY", {
        get: function () {
            return this._pMouseY;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "touchPoints", {
        get: function () {
            return this._pTouchPoints;
        },
        enumerable: true,
        configurable: true
    });
    View.prototype.getLocalMouseX = function (displayObject) {
        return displayObject.transform.inverseConcatenatedMatrix3D.transformVector(this.unproject(this._pMouseX, this._pMouseY, 1000)).x;
    };
    View.prototype.getLocalMouseY = function (displayObject) {
        return displayObject.transform.inverseConcatenatedMatrix3D.transformVector(this.unproject(this._pMouseX, this._pMouseY, 1000)).y;
    };
    View.prototype.getLocalTouchPoints = function (displayObject) {
        var localPosition;
        var localTouchPoints = new Array();
        var len = this._pTouchPoints.length;
        for (var i = 0; i < len; i++) {
            localPosition = displayObject.transform.inverseConcatenatedMatrix3D.transformVector(this.unproject(this._pTouchPoints[i].x, this._pTouchPoints[i].y, 1000));
            localTouchPoints.push(new _awayjs_scene.TouchPoint(localPosition.x, localPosition.y, this._pTouchPoints[i].id));
        }
        return localTouchPoints;
    };
    Object.defineProperty(View.prototype, "renderer", {
        /**
         *
         */
        get: function () {
            return this._pRenderer;
        },
        set: function (value) {
            if (this._pRenderer == value)
                return;
            if (this._pRenderer) {
                //swap the old renderer width and height to the new renderer
                value.width = this._pRenderer.width;
                value.height = this._pRenderer.height;
                this._pRenderer.dispose();
                this._pRenderer.removeEventListener(_awayjs_renderer.RendererEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
                this._pRenderer.removeEventListener(_awayjs_renderer.RendererEvent.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
                this._mouseManager.unregisterContainer(this._pRenderer.stage.container);
            }
            this._pRenderer = value;
            this._pRenderer.addEventListener(_awayjs_renderer.RendererEvent.VIEWPORT_UPDATED, this._onViewportUpdatedDelegate);
            this._pRenderer.addEventListener(_awayjs_renderer.RendererEvent.SCISSOR_UPDATED, this._onScissorUpdatedDelegate);
            this._mouseManager.registerContainer(this._pRenderer.stage.container);
            //reset back buffer
            this._pRenderer._iBackgroundR = ((this._backgroundColor >> 16) & 0xff) / 0xff;
            this._pRenderer._iBackgroundG = ((this._backgroundColor >> 8) & 0xff) / 0xff;
            this._pRenderer._iBackgroundB = (this._backgroundColor & 0xff) / 0xff;
            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "backgroundColor", {
        /**
         *
         */
        get: function () {
            return this._backgroundColor;
        },
        set: function (value) {
            if (this._backgroundColor == value)
                return;
            this._backgroundColor = value;
            this._pRenderer._iBackgroundR = ((value >> 16) & 0xff) / 0xff;
            this._pRenderer._iBackgroundG = ((value >> 8) & 0xff) / 0xff;
            this._pRenderer._iBackgroundB = (value & 0xff) / 0xff;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "backgroundAlpha", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._backgroundAlpha;
        },
        /**
         *
         * @param value
         */
        set: function (value) {
            if (value > 1)
                value = 1;
            else if (value < 0)
                value = 0;
            if (this._backgroundAlpha == value)
                return;
            this._pRenderer._iBackgroundAlpha = this._backgroundAlpha = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "camera", {
        /**
         *
         * @returns {Camera3D}
         */
        get: function () {
            return this._pCamera;
        },
        /**
         * Set camera that's used to render the scene for this viewport
         */
        set: function (value) {
            if (this._pCamera == value)
                return;
            if (this._pCamera)
                this._pCamera.removeEventListener(_awayjs_scene.CameraEvent.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
            this._pCamera = value;
            if (this._pScene)
                this._partitions[this._pScene.id].invalidateEntity(this._pCamera);
            this._pCamera.addEventListener(_awayjs_scene.CameraEvent.PROJECTION_CHANGED, this._onProjectionChangedDelegate);
            this._scissorDirty = true;
            this._viewportDirty = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "scene", {
        /**
         *
         * @returns {away.containers.Scene3D}
         */
        get: function () {
            return this._pScene;
        },
        /**
         * Set the scene that's used to render for this viewport
         */
        set: function (value) {
            if (this._pScene == value)
                return;
            if (this._pScene) {
                this._pScene._iUnregisterView(this);
                this._partitions[this._pScene.id].dispose();
            }
            this._pScene = value;
            this._partitions[this._pScene.id] = new BasicPartition(this._pScene);
            this._pScene._iRegisterView(this);
            if (this._pCamera)
                this._partitions[this._pScene.id].invalidateEntity(this._pCamera);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "deltaTime", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return this._deltaTime;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "width", {
        /**
         *
         */
        get: function () {
            return this._pRenderer.width;
        },
        set: function (value) {
            this._pRenderer.width = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "height", {
        /**
         *
         */
        get: function () {
            return this._pRenderer.height;
        },
        set: function (value) {
            this._pRenderer.height = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "mousePicker", {
        /**
         *
         */
        get: function () {
            return this._mousePicker;
        },
        set: function (value) {
            if (this._mousePicker == value)
                return;
            if (value == null)
                this._mousePicker = new RaycastPicker();
            else
                this._mousePicker = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "x", {
        /**
         *
         */
        get: function () {
            return this._pRenderer.x;
        },
        set: function (value) {
            this._pRenderer.x = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "y", {
        /**
         *
         */
        get: function () {
            return this._pRenderer.y;
        },
        set: function (value) {
            this._pRenderer.y = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(View.prototype, "renderedFacesCount", {
        /**
         *
         * @returns {number}
         */
        get: function () {
            return 0; //TODO
            //return this._pEntityCollector._pNumTriangles;//numTriangles;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Renders the view.
     */
    View.prototype.render = function () {
        this.pUpdateTime();
        //update view and size data
        if (this._scissorDirty) {
            this._scissorDirty = false;
            this._pCamera.projection.setViewRect(this._pRenderer.scissorRect.x, this._pRenderer.scissorRect.y, this._pRenderer.scissorRect.width, this._pRenderer.scissorRect.height);
        }
        if (this._viewportDirty) {
            this._viewportDirty = false;
            this._pCamera.projection.setStageRect(this._pRenderer.viewPort.x, this._pRenderer.viewPort.y, this._pRenderer.viewPort.width, this._pRenderer.viewPort.height);
        }
        // update picking
        if (!this.disableMouseEvents) {
            if (this.forceMouseMove && !this._mouseManager._iUpdateDirty)
                this._mouseManager._iCollision = this.getViewCollision(this._pMouseX, this._pMouseY, this);
            this._mouseManager.fireMouseEvents(this.forceMouseMove);
        }
        //_touch3DManager.updateCollider();
        //render the contents of the scene
        this._pRenderer.render(this);
    };
    /**
     *
     */
    View.prototype.pUpdateTime = function () {
        var time = _awayjs_core.getTimer();
        if (this._time == 0)
            this._time = time;
        this._deltaTime = time - this._time;
        this._time = time;
    };
    /**
     *
     */
    View.prototype.dispose = function () {
        this._pRenderer.dispose();
        // TODO: imeplement mouseManager / touch3DManager
        this._mouseManager.unregisterView(this);
        //this._touch3DManager.disableTouchListeners(this);
        //this._touch3DManager.dispose();
        this._mouseManager = null;
        //this._touch3DManager = null;
        this._pRenderer = null;
    };
    /**
     *
     */
    View.prototype._onProjectionChanged = function (event) {
        this._scissorDirty = true;
        this._viewportDirty = true;
    };
    /**
     *
     */
    View.prototype._onViewportUpdated = function (event) {
        this._viewportDirty = true;
    };
    /**
     *
     */
    View.prototype._onScissorUpdated = function (event) {
        this._scissorDirty = true;
    };
    View.prototype.project = function (point3d) {
        var v = this._pCamera.project(point3d);
        v.x = (v.x * this._pRenderer.viewPort.width + this._pRenderer.viewPort.width) / 2;
        v.y = (v.y * this._pRenderer.viewPort.height + this._pRenderer.viewPort.height) / 2;
        return v;
    };
    View.prototype.unproject = function (sX, sY, sZ, target) {
        if (target === void 0) { target = null; }
        return this._pCamera.unproject((2 * sX - this._pRenderer.viewPort.width) / this._pRenderer.viewPort.width, (2 * sY - this._pRenderer.viewPort.height) / this._pRenderer.viewPort.height, sZ, target);
    };
    /*TODO: implement Background
     public get background():away.textures.Texture2DBase
     {
     return this._background;
     }
     */
    /*TODO: implement Background
     public set background( value:away.textures.Texture2DBase )
     {
     this._background = value;
     this._renderer.background = _background;
     }
     */
    // TODO: required dependency stageGL
    View.prototype.updateCollider = function () {
        if (!this.disableMouseEvents) {
            // if (!this._pRenderer.shareContext) {
            this._mouseManager._iCollision = this.getViewCollision(this._pMouseX, this._pMouseY, this);
        }
    };
    View.prototype.getViewCollision = function (x, y, view) {
        //update ray
        var rayPosition = view.unproject(x, y, 0);
        var rayDirection = view.unproject(x, y, 1).subtract(rayPosition);
        return this._mousePicker.getCollision(rayPosition, rayDirection, this);
    };
    View.prototype.traversePartitions = function (traverser) {
        for (var key in this._partitions)
            this._partitions[key].traverse(traverser);
    };
    View.prototype.registerObject = function (displayObject) {
        this.getPartition(displayObject).invalidateEntity(displayObject);
    };
    View.prototype.unRegisterObject = function (displayObject) {
        this.getPartition(displayObject).clearEntity(displayObject);
    };
    return View;
}());

/**
 *
 */
var ViewImage2D = (function (_super) {
    __extends(ViewImage2D, _super);
    /**
     * Creates a BitmapImage2D object with a specified width and height. If you
     * specify a value for the <code>fillColor</code> parameter, every pixel in
     * the bitmap is set to that color.
     *
     * <p>By default, the bitmap is created as transparent, unless you pass
     * the value <code>false</code> for the transparent parameter. After you
     * create an opaque bitmap, you cannot change it to a transparent bitmap.
     * Every pixel in an opaque bitmap uses only 24 bits of color channel
     * information. If you define the bitmap as transparent, every pixel uses 32
     * bits of color channel information, including an alpha transparency
     * channel.</p>
     *
     * @param width       The width of the bitmap image in pixels.
     * @param height      The height of the bitmap image in pixels.
     * @param transparent Specifies whether the bitmap image supports per-pixel
     *                    transparency. The default value is <code>true</code>
     *                    (transparent). To create a fully transparent bitmap,
     *                    set the value of the <code>transparent</code>
     *                    parameter to <code>true</code> and the value of the
     *                    <code>fillColor</code> parameter to 0x00000000(or to
     *                    0). Setting the <code>transparent</code> property to
     *                    <code>false</code> can result in minor improvements
     *                    in rendering performance.
     * @param fillColor   A 32-bit ARGB color value that you use to fill the
     *                    bitmap image area. The default value is
     *                    0xFFFFFFFF(solid white).
     */
    function ViewImage2D(width, height, transparent, fillColor, powerOfTwo, stage) {
        if (transparent === void 0) { transparent = true; }
        if (fillColor === void 0) { fillColor = 0xffffffff; }
        if (powerOfTwo === void 0) { powerOfTwo = true; }
        if (stage === void 0) { stage = null; }
        var _this = _super.call(this, width, height, transparent, fillColor, powerOfTwo) || this;
        _this._fillColor = fillColor;
        _this._stage = stage;
        return _this;
    }
    Object.defineProperty(ViewImage2D.prototype, "assetType", {
        /**
         *
         * @returns {string}
         */
        get: function () {
            return ViewImage2D.assetType;
        },
        enumerable: true,
        configurable: true
    });
    ViewImage2D.prototype.createView = function () {
        //create the view
        this._view = new View(new _awayjs_renderer.DefaultRenderer(this._stage));
        this._view.disableMouseEvents = true;
        this._view.width = this._rect.width;
        this._view.height = this._rect.height;
        this._fillColor = this._fillColor;
        this._view.backgroundAlpha = this._transparent ? (this._fillColor & 0xff000000) >>> 24 : 1;
        this._view.backgroundColor = this._fillColor & 0xffffff;
        this._view.renderer.renderableSorter = null; //new RenderableSort2D();
        //create the projection
        var projection = new _awayjs_core.PerspectiveProjection();
        projection.coordinateSystem = _awayjs_core.CoordinateSystem.RIGHT_HANDED;
        projection.originX = 0;
        projection.originY = 0;
        projection.preserveFocalLength = true;
        projection.setViewRect(0, 0, this._rect.width, this._rect.height);
        projection.setStageRect(0, 0, this._rect.width, this._rect.height);
        this._view.camera.projection = projection;
    };
    /**
     * Frees memory that is used to store the BitmapImage2D object.
     *
     * <p>When the <code>dispose()</code> method is called on an image, the width
     * and height of the image are set to 0. All subsequent calls to methods or
     * properties of this BitmapImage2D instance fail, and an exception is thrown.
     * </p>
     *
     * <p><code>BitmapImage2D.dispose()</code> releases the memory occupied by the
     * actual bitmap data, immediately(a bitmap can consume up to 64 MB of
     * memory). After using <code>BitmapImage2D.dispose()</code>, the BitmapImage2D
     * object is no longer usable and an exception may be thrown if
     * you call functions on the BitmapImage2D object. However,
     * <code>BitmapImage2D.dispose()</code> does not garbage collect the BitmapImage2D
     * object(approximately 128 bytes); the memory occupied by the actual
     * BitmapImage2D object is released at the time the BitmapImage2D object is
     * collected by the garbage collector.</p>
     *
     */
    ViewImage2D.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        //todo
    };
    ViewImage2D.prototype.draw = function (source, matrix, colorTransform, blendMode, clipRect, smoothing) {
        if (source instanceof _awayjs_scene.DisplayObject) {
            var root = new _awayjs_scene.DisplayObjectContainer();
            root.addChild(source);
            if (matrix) {
                root.transform.scaleTo(matrix.a, -matrix.d, 1);
                root.transform.moveTo(matrix.tx, matrix.ty, 0);
            }
            root.transform.colorTransform = colorTransform;
            if (!this._view)
                this.createView();
            this._view.scene = new _awayjs_scene.Scene();
            this._view.scene.addChild(root);
            this._view.setPartition(root, new SceneGraphPartition(root));
            //save snapshot if unlocked
            if (!this._locked)
                this._view.renderer.queueSnapshot(this);
            this._view.renderer.disableClear = !this._locked;
            //render
            this._view.renderer._iRender(this._view.camera.projection, this._view, this);
            return;
        }
        _super.prototype.draw.call(this, source, matrix, colorTransform, blendMode, clipRect, smoothing);
    };
    /**
     *
     * @param width
     * @param height
     * @private
     */
    ViewImage2D.prototype._setSize = function (width, height) {
        _super.prototype._setSize.call(this, width, height);
        if (this._view) {
            this._view.width = this._rect.width;
            this._view.height = this._rect.height;
            this._view.camera.projection.setViewRect(0, 0, this._rect.width, this._rect.height);
            this._view.camera.projection.setStageRect(0, 0, this._rect.width, this._rect.height);
        }
    };
    return ViewImage2D;
}(_awayjs_graphics.BitmapImage2D));
ViewImage2D.assetType = "[image ViewImage2D]";

/**
 * @class away.partition.EntityNode
 */
var EntityNode = (function (_super) {
    __extends(EntityNode, _super);
    function EntityNode(displayObject, partition) {
        var _this = _super.call(this, displayObject, partition) || this;
        _this.numEntities = 1;
        _this._maskPosition = new _awayjs_core.Vector3D();
        _this._partition = partition;
        return _this;
    }
    EntityNode.prototype.onClear = function (event) {
        _super.prototype.onClear.call(this, event);
        this._partition = null;
    };
    /**
     *
     * @param planes
     * @param numPlanes
     * @returns {boolean}
     */
    EntityNode.prototype.isInFrustum = function (planes, numPlanes) {
        if (!this._entity._iIsVisible())
            return false;
        return true; // todo: hack for 2d. attention. might break stuff in 3d.
        //return this._bounds.isInFrustum(planes, numPlanes);
    };
    /**
     * @inheritDoc
     */
    EntityNode.prototype.isIntersectingRay = function (globalRayPosition, globalRayDirection) {
        if (!this._entity._iIsVisible() || !this.isIntersectingMasks(globalRayPosition, globalRayDirection, this._entity._iAssignedMasks()))
            return false;
        var pickingCollision = this._entity._iPickingCollision;
        pickingCollision.rayPosition = this._entity.transform.inverseConcatenatedMatrix3D.transformVector(globalRayPosition);
        pickingCollision.rayDirection = this._entity.transform.inverseConcatenatedMatrix3D.deltaTransformVector(globalRayDirection);
        if (!pickingCollision.normal)
            pickingCollision.normal = new _awayjs_core.Vector3D();
        var rayEntryDistance = this.bounds.rayIntersection(pickingCollision.rayPosition, pickingCollision.rayDirection, pickingCollision.normal);
        if (rayEntryDistance < 0)
            return false;
        pickingCollision.rayEntryDistance = rayEntryDistance;
        pickingCollision.globalRayPosition = globalRayPosition;
        pickingCollision.globalRayDirection = globalRayDirection;
        pickingCollision.rayOriginIsInsideBounds = rayEntryDistance == 0;
        return true;
    };
    /**
     *
     * @returns {boolean}
     */
    EntityNode.prototype.isRenderable = function () {
        return this._entity._iAssignedColorTransform()._isRenderable();
    };
    /**
     * @inheritDoc
     */
    EntityNode.prototype.acceptTraverser = function (traverser) {
        if (traverser.enterNode(this))
            traverser[this._entity.traverseName](this._entity);
    };
    EntityNode.prototype._onInvalidatePartitionBounds = function (event) {
        this.bounds.invalidate();
        this._partition.invalidateEntity(this._entity);
    };
    EntityNode.prototype.isIntersectingMasks = function (globalRayPosition, globalRayDirection, masks) {
        //horrible hack for 2d masks
        if (masks != null) {
            this._maskPosition.x = globalRayPosition.x + globalRayDirection.x * 1000;
            this._maskPosition.y = globalRayPosition.y + globalRayDirection.y * 1000;
            var numLayers = masks.length;
            var children;
            var numChildren;
            var layerHit;
            for (var i = 0; i < numLayers; i++) {
                children = masks[i];
                numChildren = children.length;
                layerHit = false;
                for (var j = 0; j < numChildren; j++) {
                    if (children[j].hitTestPoint(this._maskPosition.x, this._maskPosition.y, true, true)) {
                        layerHit = true;
                        break;
                    }
                }
                if (!layerHit)
                    return false;
            }
        }
        return true;
    };
    return EntityNode;
}(DisplayObjectNode));

/**
 * @class away.partition.CameraNode
 */
var CameraNode = (function (_super) {
    __extends(CameraNode, _super);
    function CameraNode() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * @inheritDoc
     */
    CameraNode.prototype.acceptTraverser = function (traverser) {
        // todo: dead end for now, if it has a debug sprite, then sure accept that
    };
    return CameraNode;
}(EntityNode));

/**
 * SkyboxNode is a space partitioning leaf node that contains a Skybox object.
 *
 * @class away.partition.SkyboxNode
 */
var SkyboxNode = (function (_super) {
    __extends(SkyboxNode, _super);
    function SkyboxNode() {
        return _super.apply(this, arguments) || this;
    }
    /**
     *
     * @param planes
     * @param numPlanes
     * @returns {boolean}
     */
    SkyboxNode.prototype.isInFrustum = function (planes, numPlanes) {
        if (!this._entity._iIsVisible)
            return false;
        //a skybox is always in view unless its visibility is set to false
        return true;
    };
    /**
     *
     * @returns {boolean}
     */
    SkyboxNode.prototype.isCastingShadow = function () {
        return false; //skybox never casts shadows
    };
    return SkyboxNode;
}(EntityNode));

/**
 * Pure JS picking collider for display objects. Used with the <code>RaycastPicker</code> picking object.
 *
 * @see away.base.DisplayObject#pickingCollider
 * @see away.pick.RaycastPicker
 *
 * @class away.pick.JSPickingCollider
 */
var JSPickingCollider = (function () {
    /**
     * Creates a new <code>JSPickingCollider</code> object.
     *
     * @param findClosestCollision Determines whether the picking collider searches for the closest collision along the ray. Defaults to false.
     */
    function JSPickingCollider(findClosestCollision) {
        if (findClosestCollision === void 0) { findClosestCollision = false; }
        this._findClosestCollision = findClosestCollision;
    }
    /**
     * Tests a <code>Billboard</code> object for a collision with the picking ray.
     *
     * @param billboard The billboard instance to be tested.
     * @param pickingCollision The collision object used to store the collision results
     * @param findClosest
     */
    JSPickingCollider.prototype.testBillboardCollision = function (billboard, material, pickingCollision) {
        pickingCollision.renderable = null;
        //if (this._testGraphicCollision(<RenderableBase> this._renderablePool.getItem(billboard), pickingCollision, shortestCollisionDistance)) {
        //	shortestCollisionDistance = pickingCollision.rayEntryDistance;
        //
        //	pickingCollision.renderable = billboard;
        //
        //	return true;
        //}
        return false;
    };
    /**
     * Tests a <code>TriangleElements</code> object for a collision with the picking ray.
     *
     * @param triangleElements
     * @param material
     * @param pickingCollision
     * @returns {boolean}
     */
    JSPickingCollider.prototype.testTriangleCollision = function (triangleElements, material, pickingCollision, count, offset) {
        if (offset === void 0) { offset = 0; }
        var rayPosition = pickingCollision.rayPosition;
        var rayDirection = pickingCollision.rayDirection;
        var t;
        var i0, i1, i2;
        var rx, ry, rz;
        var nx, ny, nz;
        var cx, cy, cz;
        var coeff, u, v, w;
        var p0x, p0y, p0z;
        var p1x, p1y, p1z;
        var p2x, p2y, p2z;
        var s0x, s0y, s0z;
        var s1x, s1y, s1z;
        var nl, nDotV, D, disToPlane;
        var Q1Q2, Q1Q1, Q2Q2, RQ1, RQ2;
        var collisionTriangleIndex = -1;
        var bothSides = material.bothSides;
        var positions = triangleElements.positions.get(count, offset);
        var posDim = triangleElements.positions.dimensions;
        var posStride = triangleElements.positions.stride;
        var indices;
        if (triangleElements.indices) {
            indices = triangleElements.indices.get(triangleElements.numElements);
            count = indices.length;
        }
        for (var index = 0; index < count; index += 3) {
            // evaluate triangle indices
            if (indices) {
                i0 = indices[index] * posStride;
                i1 = indices[index + 1] * posStride;
                i2 = indices[index + 2] * posStride;
            }
            else {
                i0 = index * posStride;
                i1 = (index + 1) * posStride;
                i2 = (index + 2) * posStride;
            }
            // evaluate triangle positions
            p0x = positions[i0];
            p1x = positions[i1];
            p2x = positions[i2];
            s0x = p1x - p0x; // s0 = p1 - p0
            s1x = p2x - p0x; // s1 = p2 - p0
            p0y = positions[i0 + 1];
            p1y = positions[i1 + 1];
            p2y = positions[i2 + 1];
            s0y = p1y - p0y;
            s1y = p2y - p0y;
            if (posDim == 3) {
                p0z = positions[i0 + 2];
                p1z = positions[i1 + 2];
                p2z = positions[i2 + 2];
                s0z = p1z - p0z;
                s1z = p2z - p0z;
                // evaluate sides and triangle normal
                nx = s0y * s1z - s0z * s1y; // n = s0 x s1
                ny = s0z * s1x - s0x * s1z;
                nz = s0x * s1y - s0y * s1x;
                nl = 1 / Math.sqrt(nx * nx + ny * ny + nz * nz); // normalize n
                nx *= nl;
                ny *= nl;
                nz *= nl;
            }
            else {
                nx = 0;
                ny = 0;
                nz = 1;
            }
            // -- plane intersection test --
            nDotV = nx * rayDirection.x + ny * +rayDirection.y + nz * rayDirection.z; // rayDirection . normal
            if ((!bothSides && nDotV < 0.0) || (bothSides && nDotV != 0.0)) {
                // find collision t
                D = -(nx * p0x + ny * p0y + nz * p0z);
                disToPlane = -(nx * rayPosition.x + ny * rayPosition.y + nz * rayPosition.z + D);
                t = disToPlane / nDotV;
                // find collision point
                cx = rayPosition.x + t * rayDirection.x;
                cy = rayPosition.y + t * rayDirection.y;
                cz = rayPosition.z + t * rayDirection.z;
                // collision point inside triangle? ( using barycentric coordinates )
                Q1Q2 = s0x * s1x + s0y * s1y + s0z * s1z;
                Q1Q1 = s0x * s0x + s0y * s0y + s0z * s0z;
                Q2Q2 = s1x * s1x + s1y * s1y + s1z * s1z;
                rx = cx - p0x;
                ry = cy - p0y;
                rz = cz - p0z;
                RQ1 = rx * s0x + ry * s0y + rz * s0z;
                RQ2 = rx * s1x + ry * s1y + rz * s1z;
                coeff = 1 / (Q1Q1 * Q2Q2 - Q1Q2 * Q1Q2);
                v = coeff * (Q2Q2 * RQ1 - Q1Q2 * RQ2);
                w = coeff * (-Q1Q2 * RQ1 + Q1Q1 * RQ2);
                if (v < 0)
                    continue;
                if (w < 0)
                    continue;
                u = 1 - v - w;
                if (!(u < 0) && t > 0 && t < pickingCollision.rayEntryDistance) {
                    collisionTriangleIndex = index / 3;
                    pickingCollision.rayEntryDistance = t;
                    pickingCollision.position = new _awayjs_core.Vector3D(cx, cy, cz);
                    pickingCollision.normal = new _awayjs_core.Vector3D(nx, ny, nz);
                    if (triangleElements.uvs) {
                        var uvs = triangleElements.uvs.get(triangleElements.numVertices);
                        var uvStride = triangleElements.uvs.stride;
                        var uIndex = indices[index] * uvStride;
                        var uv0 = new _awayjs_core.Vector3D(uvs[uIndex], uvs[uIndex + 1]);
                        uIndex = indices[index + 1] * uvStride;
                        var uv1 = new _awayjs_core.Vector3D(uvs[uIndex], uvs[uIndex + 1]);
                        uIndex = indices[index + 2] * uvStride;
                        var uv2 = new _awayjs_core.Vector3D(uvs[uIndex], uvs[uIndex + 1]);
                        pickingCollision.uv = new _awayjs_core.Point(u * uv0.x + v * uv1.x + w * uv2.x, u * uv0.y + v * uv1.y + w * uv2.y);
                    }
                    pickingCollision.elementIndex = collisionTriangleIndex;
                    // if not looking for best hit, first found will do...
                    if (!this._findClosestCollision)
                        return true;
                }
            }
        }
        if (collisionTriangleIndex >= 0)
            return true;
        return false;
    };
    //
    ///**
    // * Tests a <code>CurveElements</code> object for a collision with the picking ray.
    // *
    // * @param triangleElements
    // * @param material
    // * @param pickingCollision
    // * @returns {boolean}
    // */
    //public testCurveCollision(curveElements:CurveElements, material:MaterialBase, pickingCollision:PickingCollision, shortestCollisionDistance:number):boolean
    //{
    //	var rayPosition:Vector3D = pickingCollision.localRayPosition;
    //	var rayDirection:Vector3D = pickingCollision.localRayDirection;
    //
    //	//project ray onto x/y plane to generate useful test points from mouse coordinates
    //	//this will only work while all points lie on the x/y plane
    //	var plane:Vector3D = new Vector3D(0,0,-1,0);
    //
    //	var result:Vector3D = new Vector3D();
    //	var distance:number = plane.x * rayPosition.x + plane.y * rayPosition.y + plane.z * rayPosition.z + plane.w;//distance(position);
    //	result.x = rayPosition.x - ( plane.x*distance);
    //	result.y = rayPosition.y - ( plane.y*distance);
    //	result.z = rayPosition.z - ( plane.z*distance);
    //	var normal:Vector3D = new Vector3D(plane.x,plane.y,plane.z);
    //	var t:number = -(rayPosition.dotProduct(normal))/(rayDirection.dotProduct(normal));
    //	rayDirection.scaleBy(t);
    //	var p:Vector3D = rayPosition.add(rayDirection);
    //
    //	var indices:Uint16Array = curveElements.indices.get(curveElements.numElements);
    //	var collisionCurveIndex:number = -1;
    //	var bothSides:boolean = material.bothSides;
    //
    //
    //	var positions:Float32Array = curveElements.positions.get(curveElements.numVertices);
    //	var posDim:number = curveElements.positions.dimensions;
    //	var curves:Float32Array = curveElements.curves.get(curveElements.numVertices);
    //	var curveDim:number = curveElements.curves.dimensions;
    //	var uvs:ArrayBufferView = curveElements.uvs.get(curveElements.numVertices);
    //	var uvDim:number = curveElements.uvs.dimensions;
    //	var numIndices:number = indices.length;
    //
    //
    //	for(var index:number = 0; index < numIndices; index+=3)
    //	{
    //		var id0:number = indices[index];
    //		var id1:number = indices[index + 1] * posDim;
    //		var id2:number = indices[index + 2] * posDim;
    //
    //		var ax:number = positions[id0 * posDim];
    //		var ay:number = positions[id0 * posDim + 1];
    //		var bx:number = positions[id1];
    //		var by:number = positions[id1 + 1];
    //		var cx:number = positions[id2];
    //		var cy:number = positions[id2 + 1];
    //
    //		var curvex:number = curves[id0 * curveDim];
    //		var az:number = positions[id0 * posDim + 2];
    //
    //		//console.log(ax, ay, bx, by, cx, cy);
    //
    //		//from a to p
    //		var dx:number = ax - p.x;
    //		var dy:number = ay - p.y;
    //
    //		//edge normal (a-b)
    //		var nx:number = by - ay;
    //		var ny:number = -(bx - ax);
    //
    //		//console.log(ax,ay,bx,by,cx,cy);
    //
    //		var dot:number = (dx * nx) + (dy * ny);
    //		//console.log("dot a",dot);
    //		if (dot > 0)
    //			continue;
    //
    //		dx = bx - p.x;
    //		dy = by - p.y;
    //		nx = cy - by;
    //		ny = -(cx - bx);
    //
    //		dot = (dx * nx) + (dy * ny);
    //		//console.log("dot b",dot);
    //		if (dot > 0)
    //			continue;
    //
    //		dx = cx - p.x;
    //		dy = cy - p.y;
    //		nx = ay - cy;
    //		ny = -(ax - cx);
    //
    //		dot = (dx * nx) + (dy * ny);
    //		//console.log("dot c",dot);
    //		if (dot > 0)
    //			continue;
    //
    //		//check if not solid
    //		if (curvex != 2) {
    //
    //			var v0x:number = bx - ax;
    //			var v0y:number = by - ay;
    //			var v1x:number = cx - ax;
    //			var v1y:number = cy - ay;
    //			var v2x:number = p.x - ax;
    //			var v2y:number = p.y - ay;
    //
    //			var den:number = v0x * v1y - v1x * v0y;
    //			var v:number = (v2x * v1y - v1x * v2y) / den;
    //			var w:number = (v0x * v2y - v2x * v0y) / den;
    //			var u:number = 1 - v - w;
    //
    //			var uu:number = 0.5 * v + w;// (0 * u) + (0.5 * v) + (1 * w);// (lerp(0, 0.5, v) + lerp(0.5, 1, w) + lerp(1, 0, u)) / 1.5;
    //			var vv:number = w;// (0 * u) + (0 * v) + (1 * w);// (lerp(0, 1, w) + lerp(1, 0, u)) / 1;
    //
    //			var d:number = uu * uu - vv;
    //
    //			if ((d > 0 && az == -1) || (d < 0 && az == 1))
    //				continue;
    //		}
    //		//TODO optimize away this pointless check as the distance is always the same
    //		//also this stuff should only be calculated right before the return and not for each hit
    //		if (distance < shortestCollisionDistance) {
    //			shortestCollisionDistance = distance;
    //			collisionCurveIndex = index/3;
    //			pickingCollision.rayEntryDistance = distance;
    //			pickingCollision.localPosition = p;
    //			pickingCollision.localNormal = new Vector3D(0, 0, 1);
    //			pickingCollision.uv = this._getCollisionUV(indices, uvs, index, v, w, u, uvDim);
    //			pickingCollision.index = index;
    //			//						pickingCollision.elementIndex = this.pGetSpriteGraphicIndex(renderable);
    //
    //			// if not looking for best hit, first found will do...
    //			if (!this._findClosestCollision)
    //				return true;
    //		}
    //	}
    //
    //	if (collisionCurveIndex >= 0)
    //		return true;
    //
    //	return false;
    //}
    /**
     * Tests a <code>LineElements</code> object for a collision with the picking ray.
     *
     * @param triangleElements
     * @param material
     * @param pickingCollision
     * @returns {boolean}
     */
    JSPickingCollider.prototype.testLineCollision = function (lineElements, material, pickingCollision, count, offset) {
        if (offset === void 0) { offset = 0; }
        return false;
    };
    return JSPickingCollider;
}());

exports.MouseManager = MouseManager;
exports.ViewImage2D = ViewImage2D;
exports.BasicPartition = BasicPartition;
exports.CameraNode = CameraNode;
exports.DisplayObjectNode = DisplayObjectNode;
exports.EntityNode = EntityNode;
exports.NodeBase = NodeBase;
exports.PartitionBase = PartitionBase;
exports.SceneGraphNode = SceneGraphNode;
exports.SceneGraphPartition = SceneGraphPartition;
exports.SkyboxNode = SkyboxNode;
exports.JSPickingCollider = JSPickingCollider;
exports.RaycastPicker = RaycastPicker;
exports.View = View;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__lib_core__ = __webpack_require__(0);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__lib_graphics__ = __webpack_require__(3);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__lib_materials__ = __webpack_require__(4);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_3__lib_parsers__ = __webpack_require__(5);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_4__lib_player__ = __webpack_require__(11);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_5__lib_renderer__ = __webpack_require__(6);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_6__lib_scene__ = __webpack_require__(1);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_7__lib_stage__ = __webpack_require__(8);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_8__lib_view__ = __webpack_require__(2);
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_0__lib_core__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_0__lib_core__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_1__lib_graphics__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_1__lib_graphics__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_2__lib_materials__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_2__lib_materials__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_3__lib_parsers__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_3__lib_parsers__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_4__lib_player__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_4__lib_player__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_5__lib_renderer__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_5__lib_renderer__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_6__lib_scene__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_6__lib_scene__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_7__lib_stage__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_7__lib_stage__[key]; }) }(__WEBPACK_IMPORT_KEY__));
/* harmony namespace reexport (unknown) */ for(var __WEBPACK_IMPORT_KEY__ in __WEBPACK_IMPORTED_MODULE_8__lib_view__) if(__WEBPACK_IMPORT_KEY__ !== 'default') (function(key) { __webpack_require__.d(exports, key, function() { return __WEBPACK_IMPORTED_MODULE_8__lib_view__[key]; }) }(__WEBPACK_IMPORT_KEY__));











/***/ },
/* 18 */
/***/ function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(19);

/***/ },
/* 19 */
/***/ function(module, exports) {

"use strict";
/*
** SGI FREE SOFTWARE LICENSE B (Version 2.0, Sept. 18, 2008) 
** Copyright (C) [dates of first publication] Silicon Graphics, Inc.
** All Rights Reserved.
**
** Permission is hereby granted, free of charge, to any person obtaining a copy
** of this software and associated documentation files (the "Software"), to deal
** in the Software without restriction, including without limitation the rights
** to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
** of the Software, and to permit persons to whom the Software is furnished to do so,
** subject to the following conditions:
** 
** The above copyright notice including the dates of first publication and either this
** permission notice or a reference to http://oss.sgi.com/projects/FreeB/ shall be
** included in all copies or substantial portions of the Software. 
**
** THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED,
** INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A
** PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL SILICON GRAPHICS, INC.
** BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT,
** TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE
** OR OTHER DEALINGS IN THE SOFTWARE.
** 
** Except as contained in this notice, the name of Silicon Graphics, Inc. shall not
** be used in advertising or otherwise to promote the sale, use or other dealings in
** this Software without prior written authorization from Silicon Graphics, Inc.
*/
/*
** Author: Mikko Mononen, Aug 2013.
** The code is based on GLU libtess by Eric Veach, July 1994
*/

	"use strict";

	/* Public API */

	var Tess2 = {};

	module.exports = Tess2;
	
	Tess2.WINDING_ODD = 0;
	Tess2.WINDING_NONZERO = 1;
	Tess2.WINDING_POSITIVE = 2;
	Tess2.WINDING_NEGATIVE = 3;
	Tess2.WINDING_ABS_GEQ_TWO = 4;

	Tess2.POLYGONS = 0;
	Tess2.CONNECTED_POLYGONS = 1;
	Tess2.BOUNDARY_CONTOURS = 2;

	Tess2.tesselate = function(opts) {
		var debug =  opts.debug || false;
		var tess = new Tesselator();
		for (var i = 0; i < opts.contours.length; i++) {
			tess.addContour(opts.vertexSize || 2, opts.contours[i]);
		}
		tess.tesselate(opts.windingRule || Tess2.WINDING_ODD,
					   opts.elementType || Tess2.POLYGONS,
					   opts.polySize || 3,
					   opts.vertexSize || 2,
					   opts.normal || [0,0,1]);
		return {
			vertices: tess.vertices,
			vertexIndices: tess.vertexIndices,
			vertexCount: tess.vertexCount,
			elements: tess.elements,
			elementCount: tess.elementCount,
			mesh: debug ? tess.mesh : undefined
		};
	};

	/* Internal */

	var assert = function(cond) {
		if (!cond) {
			throw "Assertion Failed!";
		}
	}

	/* The mesh structure is similar in spirit, notation, and operations
	* to the "quad-edge" structure (see L. Guibas and J. Stolfi, Primitives
	* for the manipulation of general subdivisions and the computation of
	* Voronoi diagrams, ACM Transactions on Graphics, 4(2):74-123, April 1985).
	* For a simplified description, see the course notes for CS348a,
	* "Mathematical Foundations of Computer Graphics", available at the
	* Stanford bookstore (and taught during the fall quarter).
	* The implementation also borrows a tiny subset of the graph-based approach
	* use in Mantyla's Geometric Work Bench (see M. Mantyla, An Introduction
	* to Sold Modeling, Computer Science Press, Rockville, Maryland, 1988).
	*
	* The fundamental data structure is the "half-edge".  Two half-edges
	* go together to make an edge, but they point in opposite directions.
	* Each half-edge has a pointer to its mate (the "symmetric" half-edge Sym),
	* its origin vertex (Org), the face on its left side (Lface), and the
	* adjacent half-edges in the CCW direction around the origin vertex
	* (Onext) and around the left face (Lnext).  There is also a "next"
	* pointer for the global edge list (see below).
	*
	* The notation used for mesh navigation:
	*  Sym   = the mate of a half-edge (same edge, but opposite direction)
	*  Onext = edge CCW around origin vertex (keep same origin)
	*  Dnext = edge CCW around destination vertex (keep same dest)
	*  Lnext = edge CCW around left face (dest becomes new origin)
	*  Rnext = edge CCW around right face (origin becomes new dest)
	*
	* "prev" means to substitute CW for CCW in the definitions above.
	*
	* The mesh keeps global lists of all vertices, faces, and edges,
	* stored as doubly-linked circular lists with a dummy header node.
	* The mesh stores pointers to these dummy headers (vHead, fHead, eHead).
	*
	* The circular edge list is special; since half-edges always occur
	* in pairs (e and e->Sym), each half-edge stores a pointer in only
	* one direction.  Starting at eHead and following the e->next pointers
	* will visit each *edge* once (ie. e or e->Sym, but not both).
	* e->Sym stores a pointer in the opposite direction, thus it is
	* always true that e->Sym->next->Sym->next == e.
	*
	* Each vertex has a pointer to next and previous vertices in the
	* circular list, and a pointer to a half-edge with this vertex as
	* the origin (NULL if this is the dummy header).  There is also a
	* field "data" for client data.
	*
	* Each face has a pointer to the next and previous faces in the
	* circular list, and a pointer to a half-edge with this face as
	* the left face (NULL if this is the dummy header).  There is also
	* a field "data" for client data.
	*
	* Note that what we call a "face" is really a loop; faces may consist
	* of more than one loop (ie. not simply connected), but there is no
	* record of this in the data structure.  The mesh may consist of
	* several disconnected regions, so it may not be possible to visit
	* the entire mesh by starting at a half-edge and traversing the edge
	* structure.
	*
	* The mesh does NOT support isolated vertices; a vertex is deleted along
	* with its last edge.  Similarly when two faces are merged, one of the
	* faces is deleted (see tessMeshDelete below).  For mesh operations,
	* all face (loop) and vertex pointers must not be NULL.  However, once
	* mesh manipulation is finished, TESSmeshZapFace can be used to delete
	* faces of the mesh, one at a time.  All external faces can be "zapped"
	* before the mesh is returned to the client; then a NULL face indicates
	* a region which is not part of the output polygon.
	*/

	function TESSvertex() {
		this.next = null;	/* next vertex (never NULL) */
		this.prev = null;	/* previous vertex (never NULL) */
		this.anEdge = null;	/* a half-edge with this origin */

		/* Internal data (keep hidden) */
		this.coords = [0,0,0];	/* vertex location in 3D */
		this.s = 0.0;
		this.t = 0.0;			/* projection onto the sweep plane */
		this.pqHandle = 0;		/* to allow deletion from priority queue */
		this.n = 0;				/* to allow identify unique vertices */
		this.idx = 0;			/* to allow map result to original verts */
	} 

	function TESSface() {
		this.next = null;		/* next face (never NULL) */
		this.prev = null;		/* previous face (never NULL) */
		this.anEdge = null;		/* a half edge with this left face */

		/* Internal data (keep hidden) */
		this.trail = null;		/* "stack" for conversion to strips */
		this.n = 0;				/* to allow identiy unique faces */
		this.marked = false;	/* flag for conversion to strips */
		this.inside = false;	/* this face is in the polygon interior */
	};

	function TESShalfEdge(side) {
		this.next = null;		/* doubly-linked list (prev==Sym->next) */
		this.Sym = null;		/* same edge, opposite direction */
		this.Onext = null;		/* next edge CCW around origin */
		this.Lnext = null;		/* next edge CCW around left face */
		this.Org = null;		/* origin vertex (Overtex too long) */
		this.Lface = null;		/* left face */

		/* Internal data (keep hidden) */
		this.activeRegion = null;	/* a region with this upper edge (sweep.c) */
		this.winding = 0;			/* change in winding number when crossing
									   from the right face to the left face */
		this.side = side;
	};

	TESShalfEdge.prototype = {
		get Rface() { return this.Sym.Lface; },
		set Rface(v) { this.Sym.Lface = v; },
		get Dst() { return this.Sym.Org; },
		set Dst(v) { this.Sym.Org = v; },
		get Oprev() { return this.Sym.Lnext; },
		set Oprev(v) { this.Sym.Lnext = v; },
		get Lprev() { return this.Onext.Sym; },
		set Lprev(v) { this.Onext.Sym = v; },
		get Dprev() { return this.Lnext.Sym; },
		set Dprev(v) { this.Lnext.Sym = v; },
		get Rprev() { return this.Sym.Onext; },
		set Rprev(v) { this.Sym.Onext = v; },
		get Dnext() { return /*this.Rprev*/this.Sym.Onext.Sym; },  /* 3 pointers */
		set Dnext(v) { /*this.Rprev*/this.Sym.Onext.Sym = v; },  /* 3 pointers */
		get Rnext() { return /*this.Oprev*/this.Sym.Lnext.Sym; },  /* 3 pointers */
		set Rnext(v) { /*this.Oprev*/this.Sym.Lnext.Sym = v; },  /* 3 pointers */
	};



	function TESSmesh() {
		var v = new TESSvertex();
		var f = new TESSface();
		var e = new TESShalfEdge(0);
		var eSym = new TESShalfEdge(1);

		v.next = v.prev = v;
		v.anEdge = null;

		f.next = f.prev = f;
		f.anEdge = null;
		f.trail = null;
		f.marked = false;
		f.inside = false;

		e.next = e;
		e.Sym = eSym;
		e.Onext = null;
		e.Lnext = null;
		e.Org = null;
		e.Lface = null;
		e.winding = 0;
		e.activeRegion = null;

		eSym.next = eSym;
		eSym.Sym = e;
		eSym.Onext = null;
		eSym.Lnext = null;
		eSym.Org = null;
		eSym.Lface = null;
		eSym.winding = 0;
		eSym.activeRegion = null;

		this.vHead = v;		/* dummy header for vertex list */
		this.fHead = f;		/* dummy header for face list */
		this.eHead = e;		/* dummy header for edge list */
		this.eHeadSym = eSym;	/* and its symmetric counterpart */
	};

	/* The mesh operations below have three motivations: completeness,
	* convenience, and efficiency.  The basic mesh operations are MakeEdge,
	* Splice, and Delete.  All the other edge operations can be implemented
	* in terms of these.  The other operations are provided for convenience
	* and/or efficiency.
	*
	* When a face is split or a vertex is added, they are inserted into the
	* global list *before* the existing vertex or face (ie. e->Org or e->Lface).
	* This makes it easier to process all vertices or faces in the global lists
	* without worrying about processing the same data twice.  As a convenience,
	* when a face is split, the "inside" flag is copied from the old face.
	* Other internal data (v->data, v->activeRegion, f->data, f->marked,
	* f->trail, e->winding) is set to zero.
	*
	* ********************** Basic Edge Operations **************************
	*
	* tessMeshMakeEdge( mesh ) creates one edge, two vertices, and a loop.
	* The loop (face) consists of the two new half-edges.
	*
	* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
	* mesh connectivity and topology.  It changes the mesh so that
	*  eOrg->Onext <- OLD( eDst->Onext )
	*  eDst->Onext <- OLD( eOrg->Onext )
	* where OLD(...) means the value before the meshSplice operation.
	*
	* This can have two effects on the vertex structure:
	*  - if eOrg->Org != eDst->Org, the two vertices are merged together
	*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
	* In both cases, eDst->Org is changed and eOrg->Org is untouched.
	*
	* Similarly (and independently) for the face structure,
	*  - if eOrg->Lface == eDst->Lface, one loop is split into two
	*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
	* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
	*
	* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
	* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
	* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
	* the newly created loop will contain eDel->Dst.  If the deletion of eDel
	* would create isolated vertices, those are deleted as well.
	*
	* ********************** Other Edge Operations **************************
	*
	* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
	* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
	* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
	* eOrg and eNew will have the same left face.
	*
	* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
	* to eDst->Org, and returns the corresponding half-edge eNew.
	* If eOrg->Lface == eDst->Lface, this splits one loop into two,
	* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
	* loops are merged into one, and the loop eDst->Lface is destroyed.
	*
	* ************************ Other Operations *****************************
	*
	* tessMeshNewMesh() creates a new mesh with no edges, no vertices,
	* and no loops (what we usually call a "face").
	*
	* tessMeshUnion( mesh1, mesh2 ) forms the union of all structures in
	* both meshes, and returns the new mesh (the old meshes are destroyed).
	*
	* tessMeshDeleteMesh( mesh ) will free all storage for any valid mesh.
	*
	* tessMeshZapFace( fZap ) destroys a face and removes it from the
	* global face list.  All edges of fZap will have a NULL pointer as their
	* left face.  Any edges which also have a NULL pointer as their right face
	* are deleted entirely (along with any isolated vertices this produces).
	* An entire mesh can be deleted by zapping its faces, one at a time,
	* in any order.  Zapped faces cannot be used in further mesh operations!
	*
	* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
	*/

	TESSmesh.prototype = {

		/* MakeEdge creates a new pair of half-edges which form their own loop.
		* No vertex or face structures are allocated, but these must be assigned
		* before the current edge operation is completed.
		*/
		//static TESShalfEdge *MakeEdge( TESSmesh* mesh, TESShalfEdge *eNext )
		makeEdge_: function(eNext) {
			var e = new TESShalfEdge(0);
			var eSym = new TESShalfEdge(1);

			/* Make sure eNext points to the first edge of the edge pair */
			if( eNext.Sym.side < eNext.side ) { eNext = eNext.Sym; }

			/* Insert in circular doubly-linked list before eNext.
			* Note that the prev pointer is stored in Sym->next.
			*/
			var ePrev = eNext.Sym.next;
			eSym.next = ePrev;
			ePrev.Sym.next = e;
			e.next = eNext;
			eNext.Sym.next = eSym;

			e.Sym = eSym;
			e.Onext = e;
			e.Lnext = eSym;
			e.Org = null;
			e.Lface = null;
			e.winding = 0;
			e.activeRegion = null;

			eSym.Sym = e;
			eSym.Onext = eSym;
			eSym.Lnext = e;
			eSym.Org = null;
			eSym.Lface = null;
			eSym.winding = 0;
			eSym.activeRegion = null;

			return e;
		},

		/* Splice( a, b ) is best described by the Guibas/Stolfi paper or the
		* CS348a notes (see mesh.h).  Basically it modifies the mesh so that
		* a->Onext and b->Onext are exchanged.  This can have various effects
		* depending on whether a and b belong to different face or vertex rings.
		* For more explanation see tessMeshSplice() below.
		*/
		// static void Splice( TESShalfEdge *a, TESShalfEdge *b )
		splice_: function(a, b) {
			var aOnext = a.Onext;
			var bOnext = b.Onext;
			aOnext.Sym.Lnext = b;
			bOnext.Sym.Lnext = a;
			a.Onext = bOnext;
			b.Onext = aOnext;
		},

		/* MakeVertex( newVertex, eOrig, vNext ) attaches a new vertex and makes it the
		* origin of all edges in the vertex loop to which eOrig belongs. "vNext" gives
		* a place to insert the new vertex in the global vertex list.  We insert
		* the new vertex *before* vNext so that algorithms which walk the vertex
		* list will not see the newly created vertices.
		*/
		//static void MakeVertex( TESSvertex *newVertex, TESShalfEdge *eOrig, TESSvertex *vNext )
		makeVertex_: function(newVertex, eOrig, vNext) {
			var vNew = newVertex;
			assert(vNew !== null);

			/* insert in circular doubly-linked list before vNext */
			var vPrev = vNext.prev;
			vNew.prev = vPrev;
			vPrev.next = vNew;
			vNew.next = vNext;
			vNext.prev = vNew;

			vNew.anEdge = eOrig;
			/* leave coords, s, t undefined */

			/* fix other edges on this vertex loop */
			var e = eOrig;
			do {
				e.Org = vNew;
				e = e.Onext;
			} while(e !== eOrig);
		},

		/* MakeFace( newFace, eOrig, fNext ) attaches a new face and makes it the left
		* face of all edges in the face loop to which eOrig belongs.  "fNext" gives
		* a place to insert the new face in the global face list.  We insert
		* the new face *before* fNext so that algorithms which walk the face
		* list will not see the newly created faces.
		*/
		// static void MakeFace( TESSface *newFace, TESShalfEdge *eOrig, TESSface *fNext )
		makeFace_: function(newFace, eOrig, fNext) {
			var fNew = newFace;
			assert(fNew !== null); 

			/* insert in circular doubly-linked list before fNext */
			var fPrev = fNext.prev;
			fNew.prev = fPrev;
			fPrev.next = fNew;
			fNew.next = fNext;
			fNext.prev = fNew;

			fNew.anEdge = eOrig;
			fNew.trail = null;
			fNew.marked = false;

			/* The new face is marked "inside" if the old one was.  This is a
			* convenience for the common case where a face has been split in two.
			*/
			fNew.inside = fNext.inside;

			/* fix other edges on this face loop */
			var e = eOrig;
			do {
				e.Lface = fNew;
				e = e.Lnext;
			} while(e !== eOrig);
		},

		/* KillEdge( eDel ) destroys an edge (the half-edges eDel and eDel->Sym),
		* and removes from the global edge list.
		*/
		//static void KillEdge( TESSmesh *mesh, TESShalfEdge *eDel )
		killEdge_: function(eDel) {
			/* Half-edges are allocated in pairs, see EdgePair above */
			if( eDel.Sym.side < eDel.side ) { eDel = eDel.Sym; }

			/* delete from circular doubly-linked list */
			var eNext = eDel.next;
			var ePrev = eDel.Sym.next;
			eNext.Sym.next = ePrev;
			ePrev.Sym.next = eNext;
		},


		/* KillVertex( vDel ) destroys a vertex and removes it from the global
		* vertex list.  It updates the vertex loop to point to a given new vertex.
		*/
		//static void KillVertex( TESSmesh *mesh, TESSvertex *vDel, TESSvertex *newOrg )
		killVertex_: function(vDel, newOrg) {
			var eStart = vDel.anEdge;
			/* change the origin of all affected edges */
			var e = eStart;
			do {
				e.Org = newOrg;
				e = e.Onext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var vPrev = vDel.prev;
			var vNext = vDel.next;
			vNext.prev = vPrev;
			vPrev.next = vNext;
		},

		/* KillFace( fDel ) destroys a face and removes it from the global face
		* list.  It updates the face loop to point to a given new face.
		*/
		//static void KillFace( TESSmesh *mesh, TESSface *fDel, TESSface *newLface )
		killFace_: function(fDel, newLface) {
			var eStart = fDel.anEdge;

			/* change the left face of all affected edges */
			var e = eStart;
			do {
				e.Lface = newLface;
				e = e.Lnext;
			} while(e !== eStart);

			/* delete from circular doubly-linked list */
			var fPrev = fDel.prev;
			var fNext = fDel.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		/****************** Basic Edge Operations **********************/

		/* tessMeshMakeEdge creates one edge, two vertices, and a loop (face).
		* The loop consists of the two new half-edges.
		*/
		//TESShalfEdge *tessMeshMakeEdge( TESSmesh *mesh )
		makeEdge: function() {
			var newVertex1 = new TESSvertex();
			var newVertex2 = new TESSvertex();
			var newFace = new TESSface();
			var e = this.makeEdge_( this.eHead);
			this.makeVertex_( newVertex1, e, this.vHead );
			this.makeVertex_( newVertex2, e.Sym, this.vHead );
			this.makeFace_( newFace, e, this.fHead );
			return e;
		},

		/* tessMeshSplice( eOrg, eDst ) is the basic operation for changing the
		* mesh connectivity and topology.  It changes the mesh so that
		*	eOrg->Onext <- OLD( eDst->Onext )
		*	eDst->Onext <- OLD( eOrg->Onext )
		* where OLD(...) means the value before the meshSplice operation.
		*
		* This can have two effects on the vertex structure:
		*  - if eOrg->Org != eDst->Org, the two vertices are merged together
		*  - if eOrg->Org == eDst->Org, the origin is split into two vertices
		* In both cases, eDst->Org is changed and eOrg->Org is untouched.
		*
		* Similarly (and independently) for the face structure,
		*  - if eOrg->Lface == eDst->Lface, one loop is split into two
		*  - if eOrg->Lface != eDst->Lface, two distinct loops are joined into one
		* In both cases, eDst->Lface is changed and eOrg->Lface is unaffected.
		*
		* Some special cases:
		* If eDst == eOrg, the operation has no effect.
		* If eDst == eOrg->Lnext, the new face will have a single edge.
		* If eDst == eOrg->Lprev, the old face will have a single edge.
		* If eDst == eOrg->Onext, the new vertex will have a single edge.
		* If eDst == eOrg->Oprev, the old vertex will have a single edge.
		*/
		//int tessMeshSplice( TESSmesh* mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst )
		splice: function(eOrg, eDst) {
			var joiningLoops = false;
			var joiningVertices = false;

			if( eOrg === eDst ) return;

			if( eDst.Org !== eOrg.Org ) {
				/* We are merging two disjoint vertices -- destroy eDst->Org */
				joiningVertices = true;
				this.killVertex_( eDst.Org, eOrg.Org );
			}
			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Change the edge structure */
			this.splice_( eDst, eOrg );

			if( ! joiningVertices ) {
				var newVertex = new TESSvertex();

				/* We split one vertex into two -- the new vertex is eDst->Org.
				* Make sure the old vertex points to a valid half-edge.
				*/
				this.makeVertex_( newVertex, eDst, eOrg.Org );
				eOrg.Org.anEdge = eOrg;
			}
			if( ! joiningLoops ) {
				var newFace = new TESSface();  

				/* We split one loop into two -- the new loop is eDst->Lface.
				* Make sure the old face points to a valid half-edge.
				*/
				this.makeFace_( newFace, eDst, eOrg.Lface );
				eOrg.Lface.anEdge = eOrg;
			}
		},

		/* tessMeshDelete( eDel ) removes the edge eDel.  There are several cases:
		* if (eDel->Lface != eDel->Rface), we join two loops into one; the loop
		* eDel->Lface is deleted.  Otherwise, we are splitting one loop into two;
		* the newly created loop will contain eDel->Dst.  If the deletion of eDel
		* would create isolated vertices, those are deleted as well.
		*
		* This function could be implemented as two calls to tessMeshSplice
		* plus a few calls to memFree, but this would allocate and delete
		* unnecessary vertices and faces.
		*/
		//int tessMeshDelete( TESSmesh *mesh, TESShalfEdge *eDel )
		delete: function(eDel) {
			var eDelSym = eDel.Sym;
			var joiningLoops = false;

			/* First step: disconnect the origin vertex eDel->Org.  We make all
			* changes to get a consistent mesh in this "intermediate" state.
			*/
			if( eDel.Lface !== eDel.Rface ) {
				/* We are joining two loops into one -- remove the left face */
				joiningLoops = true;
				this.killFace_( eDel.Lface, eDel.Rface );
			}

			if( eDel.Onext === eDel ) {
				this.killVertex_( eDel.Org, null );
			} else {
				/* Make sure that eDel->Org and eDel->Rface point to valid half-edges */
				eDel.Rface.anEdge = eDel.Oprev;
				eDel.Org.anEdge = eDel.Onext;

				this.splice_( eDel, eDel.Oprev );
				if( ! joiningLoops ) {
					var newFace = new TESSface();

					/* We are splitting one loop into two -- create a new loop for eDel. */
					this.makeFace_( newFace, eDel, eDel.Lface );
				}
			}

			/* Claim: the mesh is now in a consistent state, except that eDel->Org
			* may have been deleted.  Now we disconnect eDel->Dst.
			*/
			if( eDelSym.Onext === eDelSym ) {
				this.killVertex_( eDelSym.Org, null );
				this.killFace_( eDelSym.Lface, null );
			} else {
				/* Make sure that eDel->Dst and eDel->Lface point to valid half-edges */
				eDel.Lface.anEdge = eDelSym.Oprev;
				eDelSym.Org.anEdge = eDelSym.Onext;
				this.splice_( eDelSym, eDelSym.Oprev );
			}

			/* Any isolated vertices or faces have already been freed. */
			this.killEdge_( eDel );
		},

		/******************** Other Edge Operations **********************/

		/* All these routines can be implemented with the basic edge
		* operations above.  They are provided for convenience and efficiency.
		*/


		/* tessMeshAddEdgeVertex( eOrg ) creates a new edge eNew such that
		* eNew == eOrg->Lnext, and eNew->Dst is a newly created vertex.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshAddEdgeVertex( TESSmesh *mesh, TESShalfEdge *eOrg );
		addEdgeVertex: function(eOrg) {
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;

			var newVertex = new TESSvertex();
			this.makeVertex_( newVertex, eNewSym, eNew.Org );

			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			return eNew;
		},


		/* tessMeshSplitEdge( eOrg ) splits eOrg into two edges eOrg and eNew,
		* such that eNew == eOrg->Lnext.  The new vertex is eOrg->Dst == eNew->Org.
		* eOrg and eNew will have the same left face.
		*/
		// TESShalfEdge *tessMeshSplitEdge( TESSmesh *mesh, TESShalfEdge *eOrg );
		splitEdge: function(eOrg, eDst) {
			var tempHalfEdge = this.addEdgeVertex( eOrg );
			var eNew = tempHalfEdge.Sym;

			/* Disconnect eOrg from eOrg->Dst and connect it to eNew->Org */
			this.splice_( eOrg.Sym, eOrg.Sym.Oprev );
			this.splice_( eOrg.Sym, eNew );

			/* Set the vertex and face information */
			eOrg.Dst = eNew.Org;
			eNew.Dst.anEdge = eNew.Sym;	/* may have pointed to eOrg->Sym */
			eNew.Rface = eOrg.Rface;
			eNew.winding = eOrg.winding;	/* copy old winding information */
			eNew.Sym.winding = eOrg.Sym.winding;

			return eNew;
		},


		/* tessMeshConnect( eOrg, eDst ) creates a new edge from eOrg->Dst
		* to eDst->Org, and returns the corresponding half-edge eNew.
		* If eOrg->Lface == eDst->Lface, this splits one loop into two,
		* and the newly created loop is eNew->Lface.  Otherwise, two disjoint
		* loops are merged into one, and the loop eDst->Lface is destroyed.
		*
		* If (eOrg == eDst), the new face will have only two edges.
		* If (eOrg->Lnext == eDst), the old face is reduced to a single edge.
		* If (eOrg->Lnext->Lnext == eDst), the old face is reduced to two edges.
		*/

		// TESShalfEdge *tessMeshConnect( TESSmesh *mesh, TESShalfEdge *eOrg, TESShalfEdge *eDst );
		connect: function(eOrg, eDst) {
			var joiningLoops = false;  
			var eNew = this.makeEdge_( eOrg );
			var eNewSym = eNew.Sym;

			if( eDst.Lface !== eOrg.Lface ) {
				/* We are connecting two disjoint loops -- destroy eDst->Lface */
				joiningLoops = true;
				this.killFace_( eDst.Lface, eOrg.Lface );
			}

			/* Connect the new edge appropriately */
			this.splice_( eNew, eOrg.Lnext );
			this.splice_( eNewSym, eDst );

			/* Set the vertex and face information */
			eNew.Org = eOrg.Dst;
			eNewSym.Org = eDst.Org;
			eNew.Lface = eNewSym.Lface = eOrg.Lface;

			/* Make sure the old face points to a valid half-edge */
			eOrg.Lface.anEdge = eNewSym;

			if( ! joiningLoops ) {
				var newFace = new TESSface();
				/* We split one loop into two -- the new loop is eNew->Lface */
				this.makeFace_( newFace, eNew, eOrg.Lface );
			}
			return eNew;
		},

		/* tessMeshZapFace( fZap ) destroys a face and removes it from the
		* global face list.  All edges of fZap will have a NULL pointer as their
		* left face.  Any edges which also have a NULL pointer as their right face
		* are deleted entirely (along with any isolated vertices this produces).
		* An entire mesh can be deleted by zapping its faces, one at a time,
		* in any order.  Zapped faces cannot be used in further mesh operations!
		*/
		zapFace: function( fZap )
		{
			var eStart = fZap.anEdge;
			var e, eNext, eSym;
			var fPrev, fNext;

			/* walk around face, deleting edges whose right face is also NULL */
			eNext = eStart.Lnext;
			do {
				e = eNext;
				eNext = e.Lnext;

				e.Lface = null;
				if( e.Rface === null ) {
					/* delete the edge -- see TESSmeshDelete above */

					if( e.Onext === e ) {
						this.killVertex_( e.Org, null );
					} else {
						/* Make sure that e->Org points to a valid half-edge */
						e.Org.anEdge = e.Onext;
						this.splice_( e, e.Oprev );
					}
					eSym = e.Sym;
					if( eSym.Onext === eSym ) {
						this.killVertex_( eSym.Org, null );
					} else {
						/* Make sure that eSym->Org points to a valid half-edge */
						eSym.Org.anEdge = eSym.Onext;
						this.splice_( eSym, eSym.Oprev );
					}
					this.killEdge_( e );
				}
			} while( e != eStart );

			/* delete from circular doubly-linked list */
			fPrev = fZap.prev;
			fNext = fZap.next;
			fNext.prev = fPrev;
			fPrev.next = fNext;
		},

		countFaceVerts_: function(f) {
			var eCur = f.anEdge;
			var n = 0;
			do
			{
				n++;
				eCur = eCur.Lnext;
			}
			while (eCur !== f.anEdge);
			return n;
		},

		//int tessMeshMergeConvexFaces( TESSmesh *mesh, int maxVertsPerFace )
		mergeConvexFaces: function(maxVertsPerFace) {
			var f;
			var eCur, eNext, eSym;
			var vStart;
			var curNv, symNv;

			for( f = this.fHead.next; f !== this.fHead; f = f.next )
			{
				// Skip faces which are outside the result.
				if( !f.inside )
					continue;

				eCur = f.anEdge;
				vStart = eCur.Org;
					
				while (true)
				{
					eNext = eCur.Lnext;
					eSym = eCur.Sym;

					// Try to merge if the neighbour face is valid.
					if( eSym && eSym.Lface && eSym.Lface.inside )
					{
						// Try to merge the neighbour faces if the resulting polygons
						// does not exceed maximum number of vertices.
						curNv = this.countFaceVerts_( f );
						symNv = this.countFaceVerts_( eSym.Lface );
						if( (curNv+symNv-2) <= maxVertsPerFace )
						{
							// Merge if the resulting poly is convex.
							if( Geom.vertCCW( eCur.Lprev.Org, eCur.Org, eSym.Lnext.Lnext.Org ) &&
								Geom.vertCCW( eSym.Lprev.Org, eSym.Org, eCur.Lnext.Lnext.Org ) )
							{
								eNext = eSym.Lnext;
								this.delete( eSym );
								eCur = null;
								eSym = null;
							}
						}
					}
					
					if( eCur && eCur.Lnext.Org === vStart )
						break;
						
					// Continue to next edge.
					eCur = eNext;
				}
			}
			
			return true;
		},

		/* tessMeshCheckMesh( mesh ) checks a mesh for self-consistency.
		*/
		check: function() {
			var fHead = this.fHead;
			var vHead = this.vHead;
			var eHead = this.eHead;
			var f, fPrev, v, vPrev, e, ePrev;

			fPrev = fHead;
			for( fPrev = fHead ; (f = fPrev.next) !== fHead; fPrev = f) {
				assert( f.prev === fPrev );
				e = f.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Lface === f );
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			assert( f.prev === fPrev && f.anEdge === null );

			vPrev = vHead;
			for( vPrev = vHead ; (v = vPrev.next) !== vHead; vPrev = v) {
				assert( v.prev === vPrev );
				e = v.anEdge;
				do {
					assert( e.Sym !== e );
					assert( e.Sym.Sym === e );
					assert( e.Lnext.Onext.Sym === e );
					assert( e.Onext.Sym.Lnext === e );
					assert( e.Org === v );
					e = e.Onext;
				} while( e !== v.anEdge );
			}
			assert( v.prev === vPrev && v.anEdge === null );

			ePrev = eHead;
			for( ePrev = eHead ; (e = ePrev.next) !== eHead; ePrev = e) {
				assert( e.Sym.next === ePrev.Sym );
				assert( e.Sym !== e );
				assert( e.Sym.Sym === e );
				assert( e.Org !== null );
				assert( e.Dst !== null );
				assert( e.Lnext.Onext.Sym === e );
				assert( e.Onext.Sym.Lnext === e );
			}
			assert( e.Sym.next === ePrev.Sym
				&& e.Sym === this.eHeadSym
				&& e.Sym.Sym === e
				&& e.Org === null && e.Dst === null
				&& e.Lface === null && e.Rface === null );
		}

	};

	var Geom = {};

	Geom.vertEq = function(u,v) {
		return (u.s === v.s && u.t === v.t);
	};

	/* Returns TRUE if u is lexicographically <= v. */
	Geom.vertLeq = function(u,v) {
		return ((u.s < v.s) || (u.s === v.s && u.t <= v.t));
	};

	/* Versions of VertLeq, EdgeSign, EdgeEval with s and t transposed. */
	Geom.transLeq = function(u,v) {
		return ((u.t < v.t) || (u.t === v.t && u.s <= v.s));
	};

	Geom.edgeGoesLeft = function(e) {
		return Geom.vertLeq( e.Dst, e.Org );
	};

	Geom.edgeGoesRight = function(e) {
		return Geom.vertLeq( e.Org, e.Dst );
	};

	Geom.vertL1dist = function(u,v) {
		return (Math.abs(u.s - v.s) + Math.abs(u.t - v.t));
	};

	//TESSreal tesedgeEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that VertLeq(u,v) && VertLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->t - (uw)(v->s), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->t = 0 and
		* let r be the negated result (this evaluates (uw)(v->s)), then
		* r is guaranteed to satisfy MIN(u->t,w->t) <= r <= MAX(u->t,w->t).
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.t - u.t) + (u.t - w.t) * (gapL / (gapL + gapR));
			} else {
				return (v.t - w.t) + (w.t - u.t) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal tesedgeSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.edgeSign = function( u, v, w ) {
		/* Returns a number whose sign matches EdgeEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.vertLeq( u, v ) && Geom.vertLeq( v, w ));

		var gapL = v.s - u.s;
		var gapR = w.s - v.s;

		if( gapL + gapR > 0.0 ) {
			return (v.t - w.t) * gapL + (v.t - u.t) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	/***********************************************************************
	* Define versions of EdgeSign, EdgeEval with s and t transposed.
	*/

	//TESSreal testransEval( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transEval = function( u, v, w ) {
		/* Given three vertices u,v,w such that TransLeq(u,v) && TransLeq(v,w),
		* evaluates the t-coord of the edge uw at the s-coord of the vertex v.
		* Returns v->s - (uw)(v->t), ie. the signed distance from uw to v.
		* If uw is vertical (and thus passes thru v), the result is zero.
		*
		* The calculation is extremely accurate and stable, even when v
		* is very close to u or w.  In particular if we set v->s = 0 and
		* let r be the negated result (this evaluates (uw)(v->t)), then
		* r is guaranteed to satisfy MIN(u->s,w->s) <= r <= MAX(u->s,w->s).
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			if( gapL < gapR ) {
				return (v.s - u.s) + (u.s - w.s) * (gapL / (gapL + gapR));
			} else {
				return (v.s - w.s) + (w.s - u.s) * (gapR / (gapL + gapR));
			}
		}
		/* vertical line */
		return 0.0;
	};

	//TESSreal testransSign( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.transSign = function( u, v, w ) {
		/* Returns a number whose sign matches TransEval(u,v,w) but which
		* is cheaper to evaluate.  Returns > 0, == 0 , or < 0
		* as v is above, on, or below the edge uw.
		*/
		assert( Geom.transLeq( u, v ) && Geom.transLeq( v, w ));

		var gapL = v.t - u.t;
		var gapR = w.t - v.t;

		if( gapL + gapR > 0.0 ) {
			return (v.s - w.s) * gapL + (v.s - u.s) * gapR;
		}
		/* vertical line */
		return 0.0;
	};


	//int tesvertCCW( TESSvertex *u, TESSvertex *v, TESSvertex *w )
	Geom.vertCCW = function( u, v, w ) {
		/* For almost-degenerate situations, the results are not reliable.
		* Unless the floating-point arithmetic can be performed without
		* rounding errors, *any* implementation will give incorrect results
		* on some degenerate inputs, so the client must have some way to
		* handle this situation.
		*/
		return (u.s*(v.t - w.t) + v.s*(w.t - u.t) + w.s*(u.t - v.t)) >= 0.0;
	};

	/* Given parameters a,x,b,y returns the value (b*x+a*y)/(a+b),
	* or (x+y)/2 if a==b==0.  It requires that a,b >= 0, and enforces
	* this in the rare case that one argument is slightly negative.
	* The implementation is extremely stable numerically.
	* In particular it guarantees that the result r satisfies
	* MIN(x,y) <= r <= MAX(x,y), and the results are very accurate
	* even when a and b differ greatly in magnitude.
	*/
	Geom.interpolate = function(a,x,b,y) {
		return (a = (a < 0) ? 0 : a, b = (b < 0) ? 0 : b, ((a <= b) ? ((b == 0) ? ((x+y) / 2) : (x + (y-x) * (a/(a+b)))) : (y + (x-y) * (b/(a+b)))));
	};

	/*
	#ifndef FOR_TRITE_TEST_PROGRAM
	#define Interpolate(a,x,b,y)	RealInterpolate(a,x,b,y)
	#else

	// Claim: the ONLY property the sweep algorithm relies on is that
	// MIN(x,y) <= r <= MAX(x,y).  This is a nasty way to test that.
	#include <stdlib.h>
	extern int RandomInterpolate;

	double Interpolate( double a, double x, double b, double y)
	{
		printf("*********************%d\n",RandomInterpolate);
		if( RandomInterpolate ) {
			a = 1.2 * drand48() - 0.1;
			a = (a < 0) ? 0 : ((a > 1) ? 1 : a);
			b = 1.0 - a;
		}
		return RealInterpolate(a,x,b,y);
	}
	#endif*/

	Geom.intersect = function( o1, d1, o2, d2, v ) {
		/* Given edges (o1,d1) and (o2,d2), compute their point of intersection.
		* The computed point is guaranteed to lie in the intersection of the
		* bounding rectangles defined by each edge.
		*/
		var z1, z2;
		var t;

		/* This is certainly not the most efficient way to find the intersection
		* of two line segments, but it is very numerically stable.
		*
		* Strategy: find the two middle vertices in the VertLeq ordering,
		* and interpolate the intersection s-value from these.  Then repeat
		* using the TransLeq ordering to find the intersection t-value.
		*/

		if( ! Geom.vertLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.vertLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.vertLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; }//swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.vertLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.s = (o2.s + d1.s) / 2;
		} else if( Geom.vertLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.edgeEval( o1, o2, d1 );
			z2 = Geom.edgeEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d1.s );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.edgeSign( o1, o2, d1 );
			z2 = -Geom.edgeSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.s = Geom.interpolate( z1, o2.s, z2, d2.s );
		}

		/* Now repeat the process for t */

		if( ! Geom.transLeq( o1, d1 )) { t = o1; o1 = d1; d1 = t; } //swap( o1, d1 ); }
		if( ! Geom.transLeq( o2, d2 )) { t = o2; o2 = d2; d2 = t; } //swap( o2, d2 ); }
		if( ! Geom.transLeq( o1, o2 )) { t = o1; o1 = o2; o2 = t; t = d1; d1 = d2; d2 = t; } //swap( o1, o2 ); swap( d1, d2 ); }

		if( ! Geom.transLeq( o2, d1 )) {
			/* Technically, no intersection -- do our best */
			v.t = (o2.t + d1.t) / 2;
		} else if( Geom.transLeq( d1, d2 )) {
			/* Interpolate between o2 and d1 */
			z1 = Geom.transEval( o1, o2, d1 );
			z2 = Geom.transEval( o2, d1, d2 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d1.t );
		} else {
			/* Interpolate between o2 and d2 */
			z1 = Geom.transSign( o1, o2, d1 );
			z2 = -Geom.transSign( o1, d2, d1 );
			if( z1+z2 < 0 ) { z1 = -z1; z2 = -z2; }
			v.t = Geom.interpolate( z1, o2.t, z2, d2.t );
		}
	};



	function DictNode() {
		this.key = null;
		this.next = null;
		this.prev = null;
	};

	function Dict(frame, leq) {
		this.head = new DictNode();
		this.head.next = this.head;
		this.head.prev = this.head;
		this.frame = frame;
		this.leq = leq;
	};

	Dict.prototype = {
		min: function() {
			return this.head.next;
		},

		max: function() {
			return this.head.prev;
		},

		insert: function(k) {
			return this.insertBefore(this.head, k);
		},

		search: function(key) {
			/* Search returns the node with the smallest key greater than or equal
			* to the given key.  If there is no such key, returns a node whose
			* key is NULL.  Similarly, Succ(Max(d)) has a NULL key, etc.
			*/
			var node = this.head;
			do {
				node = node.next;
			} while( node.key !== null && ! this.leq(this.frame, key, node.key));

			return node;
		},

		insertBefore: function(node, key) {
			do {
				node = node.prev;
			} while( node.key !== null && ! this.leq(this.frame, node.key, key));

			var newNode = new DictNode();
			newNode.key = key;
			newNode.next = node.next;
			node.next.prev = newNode;
			newNode.prev = node;
			node.next = newNode;

			return newNode;
		},

		delete: function(node) {
			node.next.prev = node.prev;
			node.prev.next = node.next;
		}
	};


	function PQnode() {
		this.handle = null;
	}

	function PQhandleElem() {
		this.key = null;
		this.node = null;
	}

	function PriorityQ(size, leq) {
		this.size = 0;
		this.max = size;

		this.nodes = [];
		this.nodes.length = size+1;
		for (var i = 0; i < this.nodes.length; i++)
			this.nodes[i] = new PQnode();

		this.handles = [];
		this.handles.length = size+1;
		for (var i = 0; i < this.handles.length; i++)
			this.handles[i] = new PQhandleElem();

		this.initialized = false;
		this.freeList = 0;
		this.leq = leq;

		this.nodes[1].handle = 1;	/* so that Minimum() returns NULL */
		this.handles[1].key = null;
	};

	PriorityQ.prototype = {

		floatDown_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hChild;
			var child;

			hCurr = n[curr].handle;
			for( ;; ) {
				child = curr << 1;
				if( child < this.size && this.leq( h[n[child+1].handle].key, h[n[child].handle].key )) {
					++child;
				}

				assert(child <= this.max);

				hChild = n[child].handle;
				if( child > this.size || this.leq( h[hCurr].key, h[hChild].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hChild;
				h[hChild].node = curr;
				curr = child;
			}
		},

		floatUp_: function( curr )
		{
			var n = this.nodes;
			var h = this.handles;
			var hCurr, hParent;
			var parent;

			hCurr = n[curr].handle;
			for( ;; ) {
				parent = curr >> 1;
				hParent = n[parent].handle;
				if( parent == 0 || this.leq( h[hParent].key, h[hCurr].key )) {
					n[curr].handle = hCurr;
					h[hCurr].node = curr;
					break;
				}
				n[curr].handle = hParent;
				h[hParent].node = curr;
				curr = parent;
			}
		},

		init: function() {
			/* This method of building a heap is O(n), rather than O(n lg n). */
			for( var i = this.size; i >= 1; --i ) {
				this.floatDown_( i );
			}
			this.initialized = true;
		},

		min: function() {
			return this.handles[this.nodes[1].handle].key;
		},

		isEmpty: function() {
			this.size === 0;
		},

		/* really pqHeapInsert */
		/* returns INV_HANDLE iff out of memory */
		//PQhandle pqHeapInsert( TESSalloc* alloc, PriorityQHeap *pq, PQkey keyNew )
		insert: function(keyNew)
		{
			var curr;
			var free;

			curr = ++this.size;
			if( (curr*2) > this.max ) {
				this.max *= 2;
				var s;
				s = this.nodes.length;
				this.nodes.length = this.max+1;
				for (var i = s; i < this.nodes.length; i++)
					this.nodes[i] = new PQnode();

				s = this.handles.length;
				this.handles.length = this.max+1;
				for (var i = s; i < this.handles.length; i++)
					this.handles[i] = new PQhandleElem();
			}

			if( this.freeList === 0 ) {
				free = curr;
			} else {
				free = this.freeList;
				this.freeList = this.handles[free].node;
			}

			this.nodes[curr].handle = free;
			this.handles[free].node = curr;
			this.handles[free].key = keyNew;

			if( this.initialized ) {
				this.floatUp_( curr );
			}
			return free;
		},

		//PQkey pqHeapExtractMin( PriorityQHeap *pq )
		extractMin: function() {
			var n = this.nodes;
			var h = this.handles;
			var hMin = n[1].handle;
			var min = h[hMin].key;

			if( this.size > 0 ) {
				n[1].handle = n[this.size].handle;
				h[n[1].handle].node = 1;

				h[hMin].key = null;
				h[hMin].node = this.freeList;
				this.freeList = hMin;

				--this.size;
				if( this.size > 0 ) {
					this.floatDown_( 1 );
				}
			}
			return min;
		},

		delete: function( hCurr ) {
			var n = this.nodes;
			var h = this.handles;
			var curr;

			assert( hCurr >= 1 && hCurr <= this.max && h[hCurr].key !== null );

			curr = h[hCurr].node;
			n[curr].handle = n[this.size].handle;
			h[n[curr].handle].node = curr;

			--this.size;
			if( curr <= this.size ) {
				if( curr <= 1 || this.leq( h[n[curr>>1].handle].key, h[n[curr].handle].key )) {
					this.floatDown_( curr );
				} else {
					this.floatUp_( curr );
				}
			}
			h[hCurr].key = null;
			h[hCurr].node = this.freeList;
			this.freeList = hCurr;
		}
	};


	/* For each pair of adjacent edges crossing the sweep line, there is
	* an ActiveRegion to represent the region between them.  The active
	* regions are kept in sorted order in a dynamic dictionary.  As the
	* sweep line crosses each vertex, we update the affected regions.
	*/

	function ActiveRegion() {
		this.eUp = null;		/* upper edge, directed right to left */
		this.nodeUp = null;	/* dictionary node corresponding to eUp */
		this.windingNumber = 0;	/* used to determine which regions are
								* inside the polygon */
		this.inside = false;		/* is this region inside the polygon? */
		this.sentinel = false;	/* marks fake edges at t = +/-infinity */
		this.dirty = false;		/* marks regions where the upper or lower
						* edge has changed, but we haven't checked
						* whether they intersect yet */
		this.fixUpperEdge = false;	/* marks temporary edges introduced when
							* we process a "right vertex" (one without
							* any edges leaving to the right) */
	};

	var Sweep = {};

	Sweep.regionBelow = function(r) {
		return r.nodeUp.prev.key;
	}

	Sweep.regionAbove = function(r) {
		return r.nodeUp.next.key;
	}

	Sweep.debugEvent = function( tess ) {
		// empty
	}


	/*
	* Invariants for the Edge Dictionary.
	* - each pair of adjacent edges e2=Succ(e1) satisfies EdgeLeq(e1,e2)
	*   at any valid location of the sweep event
	* - if EdgeLeq(e2,e1) as well (at any valid sweep event), then e1 and e2
	*   share a common endpoint
	* - for each e, e->Dst has been processed, but not e->Org
	* - each edge e satisfies VertLeq(e->Dst,event) && VertLeq(event,e->Org)
	*   where "event" is the current sweep line event.
	* - no edge e has zero length
	*
	* Invariants for the Mesh (the processed portion).
	* - the portion of the mesh left of the sweep line is a planar graph,
	*   ie. there is *some* way to embed it in the plane
	* - no processed edge has zero length
	* - no two processed vertices have identical coordinates
	* - each "inside" region is monotone, ie. can be broken into two chains
	*   of monotonically increasing vertices according to VertLeq(v1,v2)
	*   - a non-invariant: these chains may intersect (very slightly)
	*
	* Invariants for the Sweep.
	* - if none of the edges incident to the event vertex have an activeRegion
	*   (ie. none of these edges are in the edge dictionary), then the vertex
	*   has only right-going edges.
	* - if an edge is marked "fixUpperEdge" (it is a temporary edge introduced
	*   by ConnectRightVertex), then it is the only right-going edge from
	*   its associated vertex.  (This says that these edges exist only
	*   when it is necessary.)
	*/

	/* When we merge two edges into one, we need to compute the combined
	* winding of the new edge.
	*/
	Sweep.addWinding = function(eDst,eSrc) {
		eDst.winding += eSrc.winding;
		eDst.Sym.winding += eSrc.Sym.winding;
	}


	//static int EdgeLeq( TESStesselator *tess, ActiveRegion *reg1, ActiveRegion *reg2 )
	Sweep.edgeLeq = function( tess, reg1, reg2 ) {
		/*
		* Both edges must be directed from right to left (this is the canonical
		* direction for the upper edge of each region).
		*
		* The strategy is to evaluate a "t" value for each edge at the
		* current sweep line position, given by tess->event.  The calculations
		* are designed to be very stable, but of course they are not perfect.
		*
		* Special case: if both edge destinations are at the sweep event,
		* we sort the edges by slope (they would otherwise compare equally).
		*/
		var ev = tess.event;
		var t1, t2;

		var e1 = reg1.eUp;
		var e2 = reg2.eUp;

		if( e1.Dst === ev ) {
			if( e2.Dst === ev ) {
				/* Two edges right of the sweep line which meet at the sweep event.
				* Sort them by slope.
				*/
				if( Geom.vertLeq( e1.Org, e2.Org )) {
					return Geom.edgeSign( e2.Dst, e1.Org, e2.Org ) <= 0;
				}
				return Geom.edgeSign( e1.Dst, e2.Org, e1.Org ) >= 0;
			}
			return Geom.edgeSign( e2.Dst, ev, e2.Org ) <= 0;
		}
		if( e2.Dst === ev ) {
			return Geom.edgeSign( e1.Dst, ev, e1.Org ) >= 0;
		}

		/* General case - compute signed distance *from* e1, e2 to event */
		var t1 = Geom.edgeEval( e1.Dst, ev, e1.Org );
		var t2 = Geom.edgeEval( e2.Dst, ev, e2.Org );
		return (t1 >= t2);
	}


	//static void DeleteRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.deleteRegion = function( tess, reg ) {
		if( reg.fixUpperEdge ) {
			/* It was created with zero winding number, so it better be
			* deleted with zero winding number (ie. it better not get merged
			* with a real edge).
			*/
			assert( reg.eUp.winding === 0 );
		}
		reg.eUp.activeRegion = null;
		tess.dict.delete( reg.nodeUp );
	}

	//static int FixUpperEdge( TESStesselator *tess, ActiveRegion *reg, TESShalfEdge *newEdge )
	Sweep.fixUpperEdge = function( tess, reg, newEdge ) {
		/*
		* Replace an upper edge which needs fixing (see ConnectRightVertex).
		*/
		assert( reg.fixUpperEdge );
		tess.mesh.delete( reg.eUp );
		reg.fixUpperEdge = false;
		reg.eUp = newEdge;
		newEdge.activeRegion = reg;
	}

	//static ActiveRegion *TopLeftRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.topLeftRegion = function( tess, reg ) {
		var org = reg.eUp.Org;
		var e;

		/* Find the region above the uppermost edge with the same origin */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Org === org );

		/* If the edge above was a temporary edge introduced by ConnectRightVertex,
		* now is the time to fix it.
		*/
		if( reg.fixUpperEdge ) {
			e = tess.mesh.connect( Sweep.regionBelow(reg).eUp.Sym, reg.eUp.Lnext );
			if (e === null) return null;
			Sweep.fixUpperEdge( tess, reg, e );
			reg = Sweep.regionAbove( reg );
		}
		return reg;
	}

	//static ActiveRegion *TopRightRegion( ActiveRegion *reg )
	Sweep.topRightRegion = function( reg )
	{
		var dst = reg.eUp.Dst;
		var reg = null;
		/* Find the region above the uppermost edge with the same destination */
		do {
			reg = Sweep.regionAbove( reg );
		} while( reg.eUp.Dst === dst );
		return reg;
	}

	//static ActiveRegion *AddRegionBelow( TESStesselator *tess, ActiveRegion *regAbove, TESShalfEdge *eNewUp )
	Sweep.addRegionBelow = function( tess, regAbove, eNewUp ) {
		/*
		* Add a new active region to the sweep line, *somewhere* below "regAbove"
		* (according to where the new edge belongs in the sweep-line dictionary).
		* The upper edge of the new region will be "eNewUp".
		* Winding number and "inside" flag are not updated.
		*/
		var regNew = new ActiveRegion();
		regNew.eUp = eNewUp;
		regNew.nodeUp = tess.dict.insertBefore( regAbove.nodeUp, regNew );
	//	if (regNew->nodeUp == NULL) longjmp(tess->env,1);
		regNew.fixUpperEdge = false;
		regNew.sentinel = false;
		regNew.dirty = false;

		eNewUp.activeRegion = regNew;
		return regNew;
	}

	//static int IsWindingInside( TESStesselator *tess, int n )
	Sweep.isWindingInside = function( tess, n ) {
		switch( tess.windingRule ) {
			case Tess2.WINDING_ODD:
				return (n & 1) != 0;
			case Tess2.WINDING_NONZERO:
				return (n != 0);
			case Tess2.WINDING_POSITIVE:
				return (n > 0);
			case Tess2.WINDING_NEGATIVE:
				return (n < 0);
			case Tess2.WINDING_ABS_GEQ_TWO:
				return (n >= 2) || (n <= -2);
		}
		assert( false );
		return false;
	}

	//static void ComputeWinding( TESStesselator *tess, ActiveRegion *reg )
	Sweep.computeWinding = function( tess, reg ) {
		reg.windingNumber = Sweep.regionAbove(reg).windingNumber + reg.eUp.winding;
		reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );
	}


	//static void FinishRegion( TESStesselator *tess, ActiveRegion *reg )
	Sweep.finishRegion = function( tess, reg ) {
		/*
		* Delete a region from the sweep line.  This happens when the upper
		* and lower chains of a region meet (at a vertex on the sweep line).
		* The "inside" flag is copied to the appropriate mesh face (we could
		* not do this before -- since the structure of the mesh is always
		* changing, this face may not have even existed until now).
		*/
		var e = reg.eUp;
		var f = e.Lface;

		f.inside = reg.inside;
		f.anEdge = e;   /* optimization for tessMeshTessellateMonoRegion() */
		Sweep.deleteRegion( tess, reg );
	}


	//static TESShalfEdge *FinishLeftRegions( TESStesselator *tess, ActiveRegion *regFirst, ActiveRegion *regLast )
	Sweep.finishLeftRegions = function( tess, regFirst, regLast ) {
		/*
		* We are given a vertex with one or more left-going edges.  All affected
		* edges should be in the edge dictionary.  Starting at regFirst->eUp,
		* we walk down deleting all regions where both edges have the same
		* origin vOrg.  At the same time we copy the "inside" flag from the
		* active region to the face, since at this point each face will belong
		* to at most one region (this was not necessarily true until this point
		* in the sweep).  The walk stops at the region above regLast; if regLast
		* is NULL we walk as far as possible.  At the same time we relink the
		* mesh if necessary, so that the ordering of edges around vOrg is the
		* same as in the dictionary.
		*/
		var e, ePrev;
		var reg = null;
		var regPrev = regFirst;
		var ePrev = regFirst.eUp;
		while( regPrev !== regLast ) {
			regPrev.fixUpperEdge = false;	/* placement was OK */
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp;
			if( e.Org != ePrev.Org ) {
				if( ! reg.fixUpperEdge ) {
					/* Remove the last left-going edge.  Even though there are no further
					* edges in the dictionary with this origin, there may be further
					* such edges in the mesh (if we are adding left edges to a vertex
					* that has already been processed).  Thus it is important to call
					* FinishRegion rather than just DeleteRegion.
					*/
					Sweep.finishRegion( tess, regPrev );
					break;
				}
				/* If the edge below was a temporary edge introduced by
				* ConnectRightVertex, now is the time to fix it.
				*/
				e = tess.mesh.connect( ePrev.Lprev, e.Sym );
	//			if (e == NULL) longjmp(tess->env,1);
				Sweep.fixUpperEdge( tess, reg, e );
			}

			/* Relink edges so that ePrev->Onext == e */
			if( ePrev.Onext !== e ) {
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev, e );
			}
			Sweep.finishRegion( tess, regPrev );	/* may change reg->eUp */
			ePrev = reg.eUp;
			regPrev = reg;
		}
		return ePrev;
	}


	//static void AddRightEdges( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eFirst, TESShalfEdge *eLast, TESShalfEdge *eTopLeft, int cleanUp )
	Sweep.addRightEdges = function( tess, regUp, eFirst, eLast, eTopLeft, cleanUp ) {
		/*
		* Purpose: insert right-going edges into the edge dictionary, and update
		* winding numbers and mesh connectivity appropriately.  All right-going
		* edges share a common origin vOrg.  Edges are inserted CCW starting at
		* eFirst; the last edge inserted is eLast->Oprev.  If vOrg has any
		* left-going edges already processed, then eTopLeft must be the edge
		* such that an imaginary upward vertical segment from vOrg would be
		* contained between eTopLeft->Oprev and eTopLeft; otherwise eTopLeft
		* should be NULL.
		*/
		var reg, regPrev;
		var e, ePrev;
		var firstTime = true;

		/* Insert the new right-going edges in the dictionary */
		e = eFirst;
		do {
			assert( Geom.vertLeq( e.Org, e.Dst ));
			Sweep.addRegionBelow( tess, regUp, e.Sym );
			e = e.Onext;
		} while ( e !== eLast );

		/* Walk *all* right-going edges from e->Org, in the dictionary order,
		* updating the winding numbers of each region, and re-linking the mesh
		* edges to match the dictionary ordering (if necessary).
		*/
		if( eTopLeft === null ) {
			eTopLeft = Sweep.regionBelow( regUp ).eUp.Rprev;
		}
		regPrev = regUp;
		ePrev = eTopLeft;
		for( ;; ) {
			reg = Sweep.regionBelow( regPrev );
			e = reg.eUp.Sym;
			if( e.Org !== ePrev.Org ) break;

			if( e.Onext !== ePrev ) {
				/* Unlink e from its current position, and relink below ePrev */
				tess.mesh.splice( e.Oprev, e );
				tess.mesh.splice( ePrev.Oprev, e );
			}
			/* Compute the winding number and "inside" flag for the new regions */
			reg.windingNumber = regPrev.windingNumber - e.winding;
			reg.inside = Sweep.isWindingInside( tess, reg.windingNumber );

			/* Check for two outgoing edges with same slope -- process these
			* before any intersection tests (see example in tessComputeInterior).
			*/
			regPrev.dirty = true;
			if( ! firstTime && Sweep.checkForRightSplice( tess, regPrev )) {
				Sweep.addWinding( e, ePrev );
				Sweep.deleteRegion( tess, regPrev );
				tess.mesh.delete( ePrev );
			}
			firstTime = false;
			regPrev = reg;
			ePrev = e;
		}
		regPrev.dirty = true;
		assert( regPrev.windingNumber - e.winding === reg.windingNumber );

		if( cleanUp ) {
			/* Check for intersections between newly adjacent edges. */
			Sweep.walkDirtyRegions( tess, regPrev );
		}
	}


	//static void SpliceMergeVertices( TESStesselator *tess, TESShalfEdge *e1, TESShalfEdge *e2 )
	Sweep.spliceMergeVertices = function( tess, e1, e2 ) {
		/*
		* Two vertices with idential coordinates are combined into one.
		* e1->Org is kept, while e2->Org is discarded.
		*/
		tess.mesh.splice( e1, e2 ); 
	}

	//static void VertexWeights( TESSvertex *isect, TESSvertex *org, TESSvertex *dst, TESSreal *weights )
	Sweep.vertexWeights = function( isect, org, dst ) {
		/*
		* Find some weights which describe how the intersection vertex is
		* a linear combination of "org" and "dest".  Each of the two edges
		* which generated "isect" is allocated 50% of the weight; each edge
		* splits the weight between its org and dst according to the
		* relative distance to "isect".
		*/
		var t1 = Geom.vertL1dist( org, isect );
		var t2 = Geom.vertL1dist( dst, isect );
		var w0 = 0.5 * t2 / (t1 + t2);
		var w1 = 0.5 * t1 / (t1 + t2);
		isect.coords[0] += w0*org.coords[0] + w1*dst.coords[0];
		isect.coords[1] += w0*org.coords[1] + w1*dst.coords[1];
		isect.coords[2] += w0*org.coords[2] + w1*dst.coords[2];
	}


	//static void GetIntersectData( TESStesselator *tess, TESSvertex *isect, TESSvertex *orgUp, TESSvertex *dstUp, TESSvertex *orgLo, TESSvertex *dstLo )
	Sweep.getIntersectData = function( tess, isect, orgUp, dstUp, orgLo, dstLo ) {
		 /*
		 * We've computed a new intersection point, now we need a "data" pointer
		 * from the user so that we can refer to this new vertex in the
		 * rendering callbacks.
		 */
		isect.coords[0] = isect.coords[1] = isect.coords[2] = 0;
		isect.idx = -1;
		Sweep.vertexWeights( isect, orgUp, dstUp );
		Sweep.vertexWeights( isect, orgLo, dstLo );
	}

	//static int CheckForRightSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForRightSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Org is above eLo, or eLo->Org is below eUp (depending on which
		* origin is leftmost).
		*
		* The main purpose is to splice right-going edges with the same
		* dest vertex and nearly identical slopes (ie. we can't distinguish
		* the slopes numerically).  However the splicing can also help us
		* to recover from numerical errors.  For example, suppose at one
		* point we checked eUp and eLo, and decided that eUp->Org is barely
		* above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* our test so that now eUp->Org is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants.
		*
		* One possibility is to check these edges for intersection again
		* (ie. CheckForIntersect).  This is what we do if possible.  However
		* CheckForIntersect requires that tess->event lies between eUp and eLo,
		* so that it has something to fall back on when the intersection
		* calculation gives us an unusable answer.  So, for those cases where
		* we can't check for intersection, this routine fixes the problem
		* by just splicing the offending vertex into the other edge.
		* This is a guaranteed solution, no matter how degenerate things get.
		* Basically this is a combinatorial solution to a numerical problem.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;

		if( Geom.vertLeq( eUp.Org, eLo.Org )) {
			if( Geom.edgeSign( eLo.Dst, eUp.Org, eLo.Org ) > 0 ) return false;

			/* eUp->Org appears to be below eLo */
			if( ! Geom.vertEq( eUp.Org, eLo.Org )) {
				/* Splice eUp->Org into eLo */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp, eLo.Oprev );
				regUp.dirty = regLo.dirty = true;

			} else if( eUp.Org !== eLo.Org ) {
				/* merge the two vertices, discarding eUp->Org */
				tess.pq.delete( eUp.Org.pqHandle );
				Sweep.spliceMergeVertices( tess, eLo.Oprev, eUp );
			}
		} else {
			if( Geom.edgeSign( eUp.Dst, eLo.Org, eUp.Org ) < 0 ) return false;

			/* eLo->Org appears to be above eUp, so splice eLo->Org into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			tess.mesh.splitEdge( eUp.Sym );
			tess.mesh.splice( eLo.Oprev, eUp );
		}
		return true;
	}

	//static int CheckForLeftSplice( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForLeftSplice = function( tess, regUp ) {
		/*
		* Check the upper and lower edge of "regUp", to make sure that the
		* eUp->Dst is above eLo, or eLo->Dst is below eUp (depending on which
		* destination is rightmost).
		*
		* Theoretically, this should always be true.  However, splitting an edge
		* into two pieces can change the results of previous tests.  For example,
		* suppose at one point we checked eUp and eLo, and decided that eUp->Dst
		* is barely above eLo.  Then later, we split eLo into two edges (eg. from
		* a splice operation like this one).  This can change the result of
		* the test so that now eUp->Dst is incident to eLo, or barely below it.
		* We must correct this condition to maintain the dictionary invariants
		* (otherwise new edges might get inserted in the wrong place in the
		* dictionary, and bad stuff will happen).
		*
		* We fix the problem by just splicing the offending vertex into the
		* other edge.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var e;

		assert( ! Geom.vertEq( eUp.Dst, eLo.Dst ));

		if( Geom.vertLeq( eUp.Dst, eLo.Dst )) {
			if( Geom.edgeSign( eUp.Dst, eLo.Dst, eUp.Org ) < 0 ) return false;

			/* eLo->Dst is above eUp, so splice eLo->Dst into eUp */
			Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
			e = tess.mesh.splitEdge( eUp );
			tess.mesh.splice( eLo.Sym, e );
			e.Lface.inside = regUp.inside;
		} else {
			if( Geom.edgeSign( eLo.Dst, eUp.Dst, eLo.Org ) > 0 ) return false;

			/* eUp->Dst is below eLo, so splice eUp->Dst into eLo */
			regUp.dirty = regLo.dirty = true;
			e = tess.mesh.splitEdge( eLo );
			tess.mesh.splice( eUp.Lnext, eLo.Sym );
			e.Rface.inside = regUp.inside;
		}
		return true;
	}


	//static int CheckForIntersect( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.checkForIntersect = function( tess, regUp ) {
		/*
		* Check the upper and lower edges of the given region to see if
		* they intersect.  If so, create the intersection and add it
		* to the data structures.
		*
		* Returns TRUE if adding the new intersection resulted in a recursive
		* call to AddRightEdges(); in this case all "dirty" regions have been
		* checked for intersections, and possibly regUp has been deleted.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var orgUp = eUp.Org;
		var orgLo = eLo.Org;
		var dstUp = eUp.Dst;
		var dstLo = eLo.Dst;
		var tMinUp, tMaxLo;
		var isect = new TESSvertex, orgMin;
		var e;

		assert( ! Geom.vertEq( dstLo, dstUp ));
		assert( Geom.edgeSign( dstUp, tess.event, orgUp ) <= 0 );
		assert( Geom.edgeSign( dstLo, tess.event, orgLo ) >= 0 );
		assert( orgUp !== tess.event && orgLo !== tess.event );
		assert( ! regUp.fixUpperEdge && ! regLo.fixUpperEdge );

		if( orgUp === orgLo ) return false;	/* right endpoints are the same */

		tMinUp = Math.min( orgUp.t, dstUp.t );
		tMaxLo = Math.max( orgLo.t, dstLo.t );
		if( tMinUp > tMaxLo ) return false;	/* t ranges do not overlap */

		if( Geom.vertLeq( orgUp, orgLo )) {
			if( Geom.edgeSign( dstLo, orgUp, orgLo ) > 0 ) return false;
		} else {
			if( Geom.edgeSign( dstUp, orgLo, orgUp ) < 0 ) return false;
		}

		/* At this point the edges intersect, at least marginally */
		Sweep.debugEvent( tess );

		Geom.intersect( dstUp, orgUp, dstLo, orgLo, isect );
		/* The following properties are guaranteed: */
		assert( Math.min( orgUp.t, dstUp.t ) <= isect.t );
		assert( isect.t <= Math.max( orgLo.t, dstLo.t ));
		assert( Math.min( dstLo.s, dstUp.s ) <= isect.s );
		assert( isect.s <= Math.max( orgLo.s, orgUp.s ));

		if( Geom.vertLeq( isect, tess.event )) {
			/* The intersection point lies slightly to the left of the sweep line,
			* so move it until it''s slightly to the right of the sweep line.
			* (If we had perfect numerical precision, this would never happen
			* in the first place).  The easiest and safest thing to do is
			* replace the intersection by tess->event.
			*/
			isect.s = tess.event.s;
			isect.t = tess.event.t;
		}
		/* Similarly, if the computed intersection lies to the right of the
		* rightmost origin (which should rarely happen), it can cause
		* unbelievable inefficiency on sufficiently degenerate inputs.
		* (If you have the test program, try running test54.d with the
		* "X zoom" option turned on).
		*/
		orgMin = Geom.vertLeq( orgUp, orgLo ) ? orgUp : orgLo;
		if( Geom.vertLeq( orgMin, isect )) {
			isect.s = orgMin.s;
			isect.t = orgMin.t;
		}

		if( Geom.vertEq( isect, orgUp ) || Geom.vertEq( isect, orgLo )) {
			/* Easy case -- intersection at one of the right endpoints */
			Sweep.checkForRightSplice( tess, regUp );
			return false;
		}

		if(    (! Geom.vertEq( dstUp, tess.event )
			&& Geom.edgeSign( dstUp, tess.event, isect ) >= 0)
			|| (! Geom.vertEq( dstLo, tess.event )
			&& Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ))
		{
			/* Very unusual -- the new upper or lower edge would pass on the
			* wrong side of the sweep event, or through it.  This can happen
			* due to very small numerical errors in the intersection calculation.
			*/
			if( dstLo === tess.event ) {
				/* Splice dstLo into eUp, and process the new region(s) */
				tess.mesh.splitEdge( eUp.Sym );
				tess.mesh.splice( eLo.Sym, eUp );
				regUp = Sweep.topLeftRegion( tess, regUp );
	//			if (regUp == NULL) longjmp(tess->env,1);
				eUp = Sweep.regionBelow(regUp).eUp;
				Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
				Sweep.addRightEdges( tess, regUp, eUp.Oprev, eUp, eUp, true );
				return TRUE;
			}
			if( dstUp === tess.event ) {
				/* Splice dstUp into eLo, and process the new region(s) */
				tess.mesh.splitEdge( eLo.Sym );
				tess.mesh.splice( eUp.Lnext, eLo.Oprev ); 
				regLo = regUp;
				regUp = Sweep.topRightRegion( regUp );
				e = Sweep.regionBelow(regUp).eUp.Rprev;
				regLo.eUp = eLo.Oprev;
				eLo = Sweep.finishLeftRegions( tess, regLo, null );
				Sweep.addRightEdges( tess, regUp, eLo.Onext, eUp.Rprev, e, true );
				return true;
			}
			/* Special case: called from ConnectRightVertex.  If either
			* edge passes on the wrong side of tess->event, split it
			* (and wait for ConnectRightVertex to splice it appropriately).
			*/
			if( Geom.edgeSign( dstUp, tess.event, isect ) >= 0 ) {
				Sweep.regionAbove(regUp).dirty = regUp.dirty = true;
				tess.mesh.splitEdge( eUp.Sym );
				eUp.Org.s = tess.event.s;
				eUp.Org.t = tess.event.t;
			}
			if( Geom.edgeSign( dstLo, tess.event, isect ) <= 0 ) {
				regUp.dirty = regLo.dirty = true;
				tess.mesh.splitEdge( eLo.Sym );
				eLo.Org.s = tess.event.s;
				eLo.Org.t = tess.event.t;
			}
			/* leave the rest for ConnectRightVertex */
			return false;
		}

		/* General case -- split both edges, splice into new vertex.
		* When we do the splice operation, the order of the arguments is
		* arbitrary as far as correctness goes.  However, when the operation
		* creates a new face, the work done is proportional to the size of
		* the new face.  We expect the faces in the processed part of
		* the mesh (ie. eUp->Lface) to be smaller than the faces in the
		* unprocessed original contours (which will be eLo->Oprev->Lface).
		*/
		tess.mesh.splitEdge( eUp.Sym );
		tess.mesh.splitEdge( eLo.Sym );
		tess.mesh.splice( eLo.Oprev, eUp );
		eUp.Org.s = isect.s;
		eUp.Org.t = isect.t;
		eUp.Org.pqHandle = tess.pq.insert( eUp.Org );
		Sweep.getIntersectData( tess, eUp.Org, orgUp, dstUp, orgLo, dstLo );
		Sweep.regionAbove(regUp).dirty = regUp.dirty = regLo.dirty = true;
		return false;
	}

	//static void WalkDirtyRegions( TESStesselator *tess, ActiveRegion *regUp )
	Sweep.walkDirtyRegions = function( tess, regUp ) {
		/*
		* When the upper or lower edge of any region changes, the region is
		* marked "dirty".  This routine walks through all the dirty regions
		* and makes sure that the dictionary invariants are satisfied
		* (see the comments at the beginning of this file).  Of course
		* new dirty regions can be created as we make changes to restore
		* the invariants.
		*/
		var regLo = Sweep.regionBelow(regUp);
		var eUp, eLo;

		for( ;; ) {
			/* Find the lowest dirty region (we walk from the bottom up). */
			while( regLo.dirty ) {
				regUp = regLo;
				regLo = Sweep.regionBelow(regLo);
			}
			if( ! regUp.dirty ) {
				regLo = regUp;
				regUp = Sweep.regionAbove( regUp );
				if( regUp == null || ! regUp.dirty ) {
					/* We've walked all the dirty regions */
					return;
				}
			}
			regUp.dirty = false;
			eUp = regUp.eUp;
			eLo = regLo.eUp;

			if( eUp.Dst !== eLo.Dst ) {
				/* Check that the edge ordering is obeyed at the Dst vertices. */
				if( Sweep.checkForLeftSplice( tess, regUp )) {

					/* If the upper or lower edge was marked fixUpperEdge, then
					* we no longer need it (since these edges are needed only for
					* vertices which otherwise have no right-going edges).
					*/
					if( regLo.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regLo );
						tess.mesh.delete( eLo );
						regLo = Sweep.regionBelow( regUp );
						eLo = regLo.eUp;
					} else if( regUp.fixUpperEdge ) {
						Sweep.deleteRegion( tess, regUp );
						tess.mesh.delete( eUp );
						regUp = Sweep.regionAbove( regLo );
						eUp = regUp.eUp;
					}
				}
			}
			if( eUp.Org !== eLo.Org ) {
				if(    eUp.Dst !== eLo.Dst
					&& ! regUp.fixUpperEdge && ! regLo.fixUpperEdge
					&& (eUp.Dst === tess.event || eLo.Dst === tess.event) )
				{
					/* When all else fails in CheckForIntersect(), it uses tess->event
					* as the intersection location.  To make this possible, it requires
					* that tess->event lie between the upper and lower edges, and also
					* that neither of these is marked fixUpperEdge (since in the worst
					* case it might splice one of these edges into tess->event, and
					* violate the invariant that fixable edges are the only right-going
					* edge from their associated vertex).
					*/
					if( Sweep.checkForIntersect( tess, regUp )) {
						/* WalkDirtyRegions() was called recursively; we're done */
						return;
					}
				} else {
					/* Even though we can't use CheckForIntersect(), the Org vertices
					* may violate the dictionary edge ordering.  Check and correct this.
					*/
					Sweep.checkForRightSplice( tess, regUp );
				}
			}
			if( eUp.Org === eLo.Org && eUp.Dst === eLo.Dst ) {
				/* A degenerate loop consisting of only two edges -- delete it. */
				Sweep.addWinding( eLo, eUp );
				Sweep.deleteRegion( tess, regUp );
				tess.mesh.delete( eUp );
				regUp = Sweep.regionAbove( regLo );
			}
		}
	}


	//static void ConnectRightVertex( TESStesselator *tess, ActiveRegion *regUp, TESShalfEdge *eBottomLeft )
	Sweep.connectRightVertex = function( tess, regUp, eBottomLeft ) {
		/*
		* Purpose: connect a "right" vertex vEvent (one where all edges go left)
		* to the unprocessed portion of the mesh.  Since there are no right-going
		* edges, two regions (one above vEvent and one below) are being merged
		* into one.  "regUp" is the upper of these two regions.
		*
		* There are two reasons for doing this (adding a right-going edge):
		*  - if the two regions being merged are "inside", we must add an edge
		*    to keep them separated (the combined region would not be monotone).
		*  - in any case, we must leave some record of vEvent in the dictionary,
		*    so that we can merge vEvent with features that we have not seen yet.
		*    For example, maybe there is a vertical edge which passes just to
		*    the right of vEvent; we would like to splice vEvent into this edge.
		*
		* However, we don't want to connect vEvent to just any vertex.  We don''t
		* want the new edge to cross any other edges; otherwise we will create
		* intersection vertices even when the input data had no self-intersections.
		* (This is a bad thing; if the user's input data has no intersections,
		* we don't want to generate any false intersections ourselves.)
		*
		* Our eventual goal is to connect vEvent to the leftmost unprocessed
		* vertex of the combined region (the union of regUp and regLo).
		* But because of unseen vertices with all right-going edges, and also
		* new vertices which may be created by edge intersections, we don''t
		* know where that leftmost unprocessed vertex is.  In the meantime, we
		* connect vEvent to the closest vertex of either chain, and mark the region
		* as "fixUpperEdge".  This flag says to delete and reconnect this edge
		* to the next processed vertex on the boundary of the combined region.
		* Quite possibly the vertex we connected to will turn out to be the
		* closest one, in which case we won''t need to make any changes.
		*/
		var eNew;
		var eTopLeft = eBottomLeft.Onext;
		var regLo = Sweep.regionBelow(regUp);
		var eUp = regUp.eUp;
		var eLo = regLo.eUp;
		var degenerate = false;

		if( eUp.Dst !== eLo.Dst ) {
			Sweep.checkForIntersect( tess, regUp );
		}

		/* Possible new degeneracies: upper or lower edge of regUp may pass
		* through vEvent, or may coincide with new intersection vertex
		*/
		if( Geom.vertEq( eUp.Org, tess.event )) {
			tess.mesh.splice( eTopLeft.Oprev, eUp );
			regUp = Sweep.topLeftRegion( tess, regUp );
			eTopLeft = Sweep.regionBelow( regUp ).eUp;
			Sweep.finishLeftRegions( tess, Sweep.regionBelow(regUp), regLo );
			degenerate = true;
		}
		if( Geom.vertEq( eLo.Org, tess.event )) {
			tess.mesh.splice( eBottomLeft, eLo.Oprev );
			eBottomLeft = Sweep.finishLeftRegions( tess, regLo, null );
			degenerate = true;
		}
		if( degenerate ) {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
			return;
		}

		/* Non-degenerate situation -- need to add a temporary, fixable edge.
		* Connect to the closer of eLo->Org, eUp->Org.
		*/
		if( Geom.vertLeq( eLo.Org, eUp.Org )) {
			eNew = eLo.Oprev;
		} else {
			eNew = eUp;
		}
		eNew = tess.mesh.connect( eBottomLeft.Lprev, eNew );

		/* Prevent cleanup, otherwise eNew might disappear before we've even
		* had a chance to mark it as a temporary edge.
		*/
		Sweep.addRightEdges( tess, regUp, eNew, eNew.Onext, eNew.Onext, false );
		eNew.Sym.activeRegion.fixUpperEdge = true;
		Sweep.walkDirtyRegions( tess, regUp );
	}

	/* Because vertices at exactly the same location are merged together
	* before we process the sweep event, some degenerate cases can't occur.
	* However if someone eventually makes the modifications required to
	* merge features which are close together, the cases below marked
	* TOLERANCE_NONZERO will be useful.  They were debugged before the
	* code to merge identical vertices in the main loop was added.
	*/
	//#define TOLERANCE_NONZERO	FALSE

	//static void ConnectLeftDegenerate( TESStesselator *tess, ActiveRegion *regUp, TESSvertex *vEvent )
	Sweep.connectLeftDegenerate = function( tess, regUp, vEvent ) {
		/*
		* The event vertex lies exacty on an already-processed edge or vertex.
		* Adding the new vertex involves splicing it into the already-processed
		* part of the mesh.
		*/
		var e, eTopLeft, eTopRight, eLast;
		var reg;

		e = regUp.eUp;
		if( Geom.vertEq( e.Org, vEvent )) {
			/* e->Org is an unprocessed vertex - just combine them, and wait
			* for e->Org to be pulled from the queue
			*/
			assert( false /*TOLERANCE_NONZERO*/ );
			Sweep.spliceMergeVertices( tess, e, vEvent.anEdge );
			return;
		}

		if( ! Geom.vertEq( e.Dst, vEvent )) {
			/* General case -- splice vEvent into edge e which passes through it */
			tess.mesh.splitEdge( e.Sym );
			if( regUp.fixUpperEdge ) {
				/* This edge was fixable -- delete unused portion of original edge */
				tess.mesh.delete( e.Onext );
				regUp.fixUpperEdge = false;
			}
			tess.mesh.splice( vEvent.anEdge, e );
			Sweep.sweepEvent( tess, vEvent );	/* recurse */
			return;
		}

		/* vEvent coincides with e->Dst, which has already been processed.
		* Splice in the additional right-going edges.
		*/
		assert( false /*TOLERANCE_NONZERO*/ );
		regUp = Sweep.topRightRegion( regUp );
		reg = Sweep.regionBelow( regUp );
		eTopRight = reg.eUp.Sym;
		eTopLeft = eLast = eTopRight.Onext;
		if( reg.fixUpperEdge ) {
			/* Here e->Dst has only a single fixable edge going right.
			* We can delete it since now we have some real right-going edges.
			*/
			assert( eTopLeft !== eTopRight );   /* there are some left edges too */
			Sweep.deleteRegion( tess, reg );
			tess.mesh.delete( eTopRight );
			eTopRight = eTopLeft.Oprev;
		}
		tess.mesh.splice( vEvent.anEdge, eTopRight );
		if( ! Geom.edgeGoesLeft( eTopLeft )) {
			/* e->Dst had no left-going edges -- indicate this to AddRightEdges() */
			eTopLeft = null;
		}
		Sweep.addRightEdges( tess, regUp, eTopRight.Onext, eLast, eTopLeft, true );
	}


	//static void ConnectLeftVertex( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.connectLeftVertex = function( tess, vEvent ) {
		/*
		* Purpose: connect a "left" vertex (one where both edges go right)
		* to the processed portion of the mesh.  Let R be the active region
		* containing vEvent, and let U and L be the upper and lower edge
		* chains of R.  There are two possibilities:
		*
		* - the normal case: split R into two regions, by connecting vEvent to
		*   the rightmost vertex of U or L lying to the left of the sweep line
		*
		* - the degenerate case: if vEvent is close enough to U or L, we
		*   merge vEvent into that edge chain.  The subcases are:
		*	- merging with the rightmost vertex of U or L
		*	- merging with the active edge of U or L
		*	- merging with an already-processed portion of U or L
		*/
		var regUp, regLo, reg;
		var eUp, eLo, eNew;
		var tmp = new ActiveRegion();

		/* assert( vEvent->anEdge->Onext->Onext == vEvent->anEdge ); */

		/* Get a pointer to the active region containing vEvent */
		tmp.eUp = vEvent.anEdge.Sym;
		/* __GL_DICTLISTKEY */ /* tessDictListSearch */
		regUp = tess.dict.search( tmp ).key;
		regLo = Sweep.regionBelow( regUp );
		if( !regLo ) {
			// This may happen if the input polygon is coplanar.
			return;
		}
		eUp = regUp.eUp;
		eLo = regLo.eUp;

		/* Try merging with U or L first */
		if( Geom.edgeSign( eUp.Dst, vEvent, eUp.Org ) === 0.0 ) {
			Sweep.connectLeftDegenerate( tess, regUp, vEvent );
			return;
		}

		/* Connect vEvent to rightmost processed vertex of either chain.
		* e->Dst is the vertex that we will connect to vEvent.
		*/
		reg = Geom.vertLeq( eLo.Dst, eUp.Dst ) ? regUp : regLo;

		if( regUp.inside || reg.fixUpperEdge) {
			if( reg === regUp ) {
				eNew = tess.mesh.connect( vEvent.anEdge.Sym, eUp.Lnext );
			} else {
				var tempHalfEdge = tess.mesh.connect( eLo.Dnext, vEvent.anEdge);
				eNew = tempHalfEdge.Sym;
			}
			if( reg.fixUpperEdge ) {
				Sweep.fixUpperEdge( tess, reg, eNew );
			} else {
				Sweep.computeWinding( tess, Sweep.addRegionBelow( tess, regUp, eNew ));
			}
			Sweep.sweepEvent( tess, vEvent );
		} else {
			/* The new vertex is in a region which does not belong to the polygon.
			* We don''t need to connect this vertex to the rest of the mesh.
			*/
			Sweep.addRightEdges( tess, regUp, vEvent.anEdge, vEvent.anEdge, null, true );
		}
	};


	//static void SweepEvent( TESStesselator *tess, TESSvertex *vEvent )
	Sweep.sweepEvent = function( tess, vEvent ) {
		/*
		* Does everything necessary when the sweep line crosses a vertex.
		* Updates the mesh and the edge dictionary.
		*/

		tess.event = vEvent;		/* for access in EdgeLeq() */
		Sweep.debugEvent( tess );

		/* Check if this vertex is the right endpoint of an edge that is
		* already in the dictionary.  In this case we don't need to waste
		* time searching for the location to insert new edges.
		*/
		var e = vEvent.anEdge;
		while( e.activeRegion === null ) {
			e = e.Onext;
			if( e == vEvent.anEdge ) {
				/* All edges go right -- not incident to any processed edges */
				Sweep.connectLeftVertex( tess, vEvent );
				return;
			}
		}

		/* Processing consists of two phases: first we "finish" all the
		* active regions where both the upper and lower edges terminate
		* at vEvent (ie. vEvent is closing off these regions).
		* We mark these faces "inside" or "outside" the polygon according
		* to their winding number, and delete the edges from the dictionary.
		* This takes care of all the left-going edges from vEvent.
		*/
		var regUp = Sweep.topLeftRegion( tess, e.activeRegion );
		assert( regUp !== null );
	//	if (regUp == NULL) longjmp(tess->env,1);
		var reg = Sweep.regionBelow( regUp );
		var eTopLeft = reg.eUp;
		var eBottomLeft = Sweep.finishLeftRegions( tess, reg, null );

		/* Next we process all the right-going edges from vEvent.  This
		* involves adding the edges to the dictionary, and creating the
		* associated "active regions" which record information about the
		* regions between adjacent dictionary edges.
		*/
		if( eBottomLeft.Onext === eTopLeft ) {
			/* No right-going edges -- add a temporary "fixable" edge */
			Sweep.connectRightVertex( tess, regUp, eBottomLeft );
		} else {
			Sweep.addRightEdges( tess, regUp, eBottomLeft.Onext, eTopLeft, eTopLeft, true );
		}
	};


	/* Make the sentinel coordinates big enough that they will never be
	* merged with real input features.
	*/

	//static void AddSentinel( TESStesselator *tess, TESSreal smin, TESSreal smax, TESSreal t )
	Sweep.addSentinel = function( tess, smin, smax, t ) {
		/*
		* We add two sentinel edges above and below all other edges,
		* to avoid special cases at the top and bottom.
		*/
		var reg = new ActiveRegion();
		var e = tess.mesh.makeEdge();
	//	if (e == NULL) longjmp(tess->env,1);

		e.Org.s = smax;
		e.Org.t = t;
		e.Dst.s = smin;
		e.Dst.t = t;
		tess.event = e.Dst;		/* initialize it */

		reg.eUp = e;
		reg.windingNumber = 0;
		reg.inside = false;
		reg.fixUpperEdge = false;
		reg.sentinel = true;
		reg.dirty = false;
		reg.nodeUp = tess.dict.insert( reg );
	//	if (reg->nodeUp == NULL) longjmp(tess->env,1);
	}


	//static void InitEdgeDict( TESStesselator *tess )
	Sweep.initEdgeDict = function( tess ) {
		/*
		* We maintain an ordering of edge intersections with the sweep line.
		* This order is maintained in a dynamic dictionary.
		*/
		tess.dict = new Dict( tess, Sweep.edgeLeq );
	//	if (tess->dict == NULL) longjmp(tess->env,1);

		var w = (tess.bmax[0] - tess.bmin[0]);
		var h = (tess.bmax[1] - tess.bmin[1]);

		var smin = tess.bmin[0] - w;
		var smax = tess.bmax[0] + w;
		var tmin = tess.bmin[1] - h;
		var tmax = tess.bmax[1] + h;

		Sweep.addSentinel( tess, smin, smax, tmin );
		Sweep.addSentinel( tess, smin, smax, tmax );
	}


	Sweep.doneEdgeDict = function( tess )
	{
		var reg;
		var fixedEdges = 0;

		while( (reg = tess.dict.min().key) !== null ) {
			/*
			* At the end of all processing, the dictionary should contain
			* only the two sentinel edges, plus at most one "fixable" edge
			* created by ConnectRightVertex().
			*/
			if( ! reg.sentinel ) {
				assert( reg.fixUpperEdge );
				assert( ++fixedEdges == 1 );
			}
			assert( reg.windingNumber == 0 );
			Sweep.deleteRegion( tess, reg );
			/*    tessMeshDelete( reg->eUp );*/
		}
	//	dictDeleteDict( &tess->alloc, tess->dict );
	}


	Sweep.removeDegenerateEdges = function( tess ) {
		/*
		* Remove zero-length edges, and contours with fewer than 3 vertices.
		*/
		var e, eNext, eLnext;
		var eHead = tess.mesh.eHead;

		/*LINTED*/
		for( e = eHead.next; e !== eHead; e = eNext ) {
			eNext = e.next;
			eLnext = e.Lnext;

			if( Geom.vertEq( e.Org, e.Dst ) && e.Lnext.Lnext !== e ) {
				/* Zero-length edge, contour has at least 3 edges */
				Sweep.spliceMergeVertices( tess, eLnext, e );	/* deletes e->Org */
				tess.mesh.delete( e ); /* e is a self-loop */
				e = eLnext;
				eLnext = e.Lnext;
			}
			if( eLnext.Lnext === e ) {
				/* Degenerate contour (one or two edges) */
				if( eLnext !== e ) {
					if( eLnext === eNext || eLnext === eNext.Sym ) { eNext = eNext.next; }
					tess.mesh.delete( eLnext );
				}
				if( e === eNext || e === eNext.Sym ) { eNext = eNext.next; }
				tess.mesh.delete( e );
			}
		}
	}

	Sweep.initPriorityQ = function( tess ) {
		/*
		* Insert all vertices into the priority queue which determines the
		* order in which vertices cross the sweep line.
		*/
		var pq;
		var v, vHead;
		var vertexCount = 0;
		
		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			vertexCount++;
		}
		/* Make sure there is enough space for sentinels. */
		vertexCount += 8; //MAX( 8, tess->alloc.extraVertices );
		
		pq = tess.pq = new PriorityQ( vertexCount, Geom.vertLeq );
	//	if (pq == NULL) return 0;

		vHead = tess.mesh.vHead;
		for( v = vHead.next; v !== vHead; v = v.next ) {
			v.pqHandle = pq.insert( v );
	//		if (v.pqHandle == INV_HANDLE)
	//			break;
		}

		if (v !== vHead) {
			return false;
		}

		pq.init();

		return true;
	}


	Sweep.donePriorityQ = function( tess ) {
		tess.pq = null;
	}


	Sweep.removeDegenerateFaces = function( tess, mesh ) {
		/*
		* Delete any degenerate faces with only two edges.  WalkDirtyRegions()
		* will catch almost all of these, but it won't catch degenerate faces
		* produced by splice operations on already-processed edges.
		* The two places this can happen are in FinishLeftRegions(), when
		* we splice in a "temporary" edge produced by ConnectRightVertex(),
		* and in CheckForLeftSplice(), where we splice already-processed
		* edges to ensure that our dictionary invariants are not violated
		* by numerical errors.
		*
		* In both these cases it is *very* dangerous to delete the offending
		* edge at the time, since one of the routines further up the stack
		* will sometimes be keeping a pointer to that edge.
		*/
		var f, fNext;
		var e;

		/*LINTED*/
		for( f = mesh.fHead.next; f !== mesh.fHead; f = fNext ) {
			fNext = f.next;
			e = f.anEdge;
			assert( e.Lnext !== e );

			if( e.Lnext.Lnext === e ) {
				/* A face with only two edges */
				Sweep.addWinding( e.Onext, e );
				tess.mesh.delete( e );
			}
		}
		return true;
	}

	Sweep.computeInterior = function( tess ) {
		/*
		* tessComputeInterior( tess ) computes the planar arrangement specified
		* by the given contours, and further subdivides this arrangement
		* into regions.  Each region is marked "inside" if it belongs
		* to the polygon, according to the rule given by tess->windingRule.
		* Each interior region is guaranteed be monotone.
		*/
		var v, vNext;

		/* Each vertex defines an event for our sweep line.  Start by inserting
		* all the vertices in a priority queue.  Events are processed in
		* lexicographic order, ie.
		*
		*	e1 < e2  iff  e1.x < e2.x || (e1.x == e2.x && e1.y < e2.y)
		*/
		Sweep.removeDegenerateEdges( tess );
		if ( !Sweep.initPriorityQ( tess ) ) return false; /* if error */
		Sweep.initEdgeDict( tess );

		while( (v = tess.pq.extractMin()) !== null ) {
			for( ;; ) {
				vNext = tess.pq.min();
				if( vNext === null || ! Geom.vertEq( vNext, v )) break;

				/* Merge together all vertices at exactly the same location.
				* This is more efficient than processing them one at a time,
				* simplifies the code (see ConnectLeftDegenerate), and is also
				* important for correct handling of certain degenerate cases.
				* For example, suppose there are two identical edges A and B
				* that belong to different contours (so without this code they would
				* be processed by separate sweep events).  Suppose another edge C
				* crosses A and B from above.  When A is processed, we split it
				* at its intersection point with C.  However this also splits C,
				* so when we insert B we may compute a slightly different
				* intersection point.  This might leave two edges with a small
				* gap between them.  This kind of error is especially obvious
				* when using boundary extraction (TESS_BOUNDARY_ONLY).
				*/
				vNext = tess.pq.extractMin();
				Sweep.spliceMergeVertices( tess, v.anEdge, vNext.anEdge );
			}
			Sweep.sweepEvent( tess, v );
		}

		/* Set tess->event for debugging purposes */
		tess.event = tess.dict.min().key.eUp.Org;
		Sweep.debugEvent( tess );
		Sweep.doneEdgeDict( tess );
		Sweep.donePriorityQ( tess );

		if ( !Sweep.removeDegenerateFaces( tess, tess.mesh ) ) return false;
		tess.mesh.check();

		return true;
	}


	function Tesselator() {

		/*** state needed for collecting the input data ***/
		this.mesh = null;		/* stores the input contours, and eventually
							the tessellation itself */

		/*** state needed for projecting onto the sweep plane ***/

		this.normal = [0.0, 0.0, 0.0];	/* user-specified normal (if provided) */
		this.sUnit = [0.0, 0.0, 0.0];	/* unit vector in s-direction (debugging) */
		this.tUnit = [0.0, 0.0, 0.0];	/* unit vector in t-direction (debugging) */

		this.bmin = [0.0, 0.0];
		this.bmax = [0.0, 0.0];

		/*** state needed for the line sweep ***/
		this.windingRule = Tess2.WINDING_ODD;	/* rule for determining polygon interior */

		this.dict = null;		/* edge dictionary for sweep line */
		this.pq = null;		/* priority queue of vertex events */
		this.event = null;		/* current sweep event being processed */

		this.vertexIndexCounter = 0;
		
		this.vertices = [];
		this.vertexIndices = [];
		this.vertexCount = 0;
		this.elements = [];
		this.elementCount = 0;
	};

	Tesselator.prototype = {

		dot_: function(u, v) {
			return (u[0]*v[0] + u[1]*v[1] + u[2]*v[2]);
		},

		normalize_: function( v ) {
			var len = v[0]*v[0] + v[1]*v[1] + v[2]*v[2];
			assert( len > 0.0 );
			len = Math.sqrt( len );
			v[0] /= len;
			v[1] /= len;
			v[2] /= len;
		},

		longAxis_: function( v ) {
			var i = 0;
			if( Math.abs(v[1]) > Math.abs(v[0]) ) { i = 1; }
			if( Math.abs(v[2]) > Math.abs(v[i]) ) { i = 2; }
			return i;
		},

		computeNormal_: function( norm )
		{
			var v, v1, v2;
			var c, tLen2, maxLen2;
			var maxVal = [0,0,0], minVal = [0,0,0], d1 = [0,0,0], d2 = [0,0,0], tNorm = [0,0,0];
			var maxVert = [null,null,null], minVert = [null,null,null];
			var vHead = this.mesh.vHead;
			var i;

			v = vHead.next;
			for( i = 0; i < 3; ++i ) {
				c = v.coords[i];
				minVal[i] = c;
				minVert[i] = v;
				maxVal[i] = c;
				maxVert[i] = v;
			}

			for( v = vHead.next; v !== vHead; v = v.next ) {
				for( i = 0; i < 3; ++i ) {
					c = v.coords[i];
					if( c < minVal[i] ) { minVal[i] = c; minVert[i] = v; }
					if( c > maxVal[i] ) { maxVal[i] = c; maxVert[i] = v; }
				}
			}

			/* Find two vertices separated by at least 1/sqrt(3) of the maximum
			* distance between any two vertices
			*/
			i = 0;
			if( maxVal[1] - minVal[1] > maxVal[0] - minVal[0] ) { i = 1; }
			if( maxVal[2] - minVal[2] > maxVal[i] - minVal[i] ) { i = 2; }
			if( minVal[i] >= maxVal[i] ) {
				/* All vertices are the same -- normal doesn't matter */
				norm[0] = 0; norm[1] = 0; norm[2] = 1;
				return;
			}

			/* Look for a third vertex which forms the triangle with maximum area
			* (Length of normal == twice the triangle area)
			*/
			maxLen2 = 0;
			v1 = minVert[i];
			v2 = maxVert[i];
			d1[0] = v1.coords[0] - v2.coords[0];
			d1[1] = v1.coords[1] - v2.coords[1];
			d1[2] = v1.coords[2] - v2.coords[2];
			for( v = vHead.next; v !== vHead; v = v.next ) {
				d2[0] = v.coords[0] - v2.coords[0];
				d2[1] = v.coords[1] - v2.coords[1];
				d2[2] = v.coords[2] - v2.coords[2];
				tNorm[0] = d1[1]*d2[2] - d1[2]*d2[1];
				tNorm[1] = d1[2]*d2[0] - d1[0]*d2[2];
				tNorm[2] = d1[0]*d2[1] - d1[1]*d2[0];
				tLen2 = tNorm[0]*tNorm[0] + tNorm[1]*tNorm[1] + tNorm[2]*tNorm[2];
				if( tLen2 > maxLen2 ) {
					maxLen2 = tLen2;
					norm[0] = tNorm[0];
					norm[1] = tNorm[1];
					norm[2] = tNorm[2];
				}
			}

			if( maxLen2 <= 0 ) {
				/* All points lie on a single line -- any decent normal will do */
				norm[0] = norm[1] = norm[2] = 0;
				norm[this.longAxis_(d1)] = 1;
			}
		},

		checkOrientation_: function() {
			var area;
			var f, fHead = this.mesh.fHead;
			var v, vHead = this.mesh.vHead;
			var e;

			/* When we compute the normal automatically, we choose the orientation
			* so that the the sum of the signed areas of all contours is non-negative.
			*/
			area = 0;
			for( f = fHead.next; f !== fHead; f = f.next ) {
				e = f.anEdge;
				if( e.winding <= 0 ) continue;
				do {
					area += (e.Org.s - e.Dst.s) * (e.Org.t + e.Dst.t);
					e = e.Lnext;
				} while( e !== f.anEdge );
			}
			if( area < 0 ) {
				/* Reverse the orientation by flipping all the t-coordinates */
				for( v = vHead.next; v !== vHead; v = v.next ) {
					v.t = - v.t;
				}
				this.tUnit[0] = - this.tUnit[0];
				this.tUnit[1] = - this.tUnit[1];
				this.tUnit[2] = - this.tUnit[2];
			}
		},

	/*	#ifdef FOR_TRITE_TEST_PROGRAM
		#include <stdlib.h>
		extern int RandomSweep;
		#define S_UNIT_X	(RandomSweep ? (2*drand48()-1) : 1.0)
		#define S_UNIT_Y	(RandomSweep ? (2*drand48()-1) : 0.0)
		#else
		#if defined(SLANTED_SWEEP) */
		/* The "feature merging" is not intended to be complete.  There are
		* special cases where edges are nearly parallel to the sweep line
		* which are not implemented.  The algorithm should still behave
		* robustly (ie. produce a reasonable tesselation) in the presence
		* of such edges, however it may miss features which could have been
		* merged.  We could minimize this effect by choosing the sweep line
		* direction to be something unusual (ie. not parallel to one of the
		* coordinate axes).
		*/
	/*	#define S_UNIT_X	(TESSreal)0.50941539564955385	// Pre-normalized
		#define S_UNIT_Y	(TESSreal)0.86052074622010633
		#else
		#define S_UNIT_X	(TESSreal)1.0
		#define S_UNIT_Y	(TESSreal)0.0
		#endif
		#endif*/

		/* Determine the polygon normal and project vertices onto the plane
		* of the polygon.
		*/
		projectPolygon_: function() {
			var v, vHead = this.mesh.vHead;
			var norm = [0,0,0];
			var sUnit, tUnit;
			var i, first, computedNormal = false;

			norm[0] = this.normal[0];
			norm[1] = this.normal[1];
			norm[2] = this.normal[2];
			if( norm[0] === 0.0 && norm[1] === 0.0 && norm[2] === 0.0 ) {
				this.computeNormal_( norm );
				computedNormal = true;
			}
			sUnit = this.sUnit;
			tUnit = this.tUnit;
			i = this.longAxis_( norm );

	/*	#if defined(FOR_TRITE_TEST_PROGRAM) || defined(TRUE_PROJECT)
			// Choose the initial sUnit vector to be approximately perpendicular
			// to the normal.
			
			Normalize( norm );

			sUnit[i] = 0;
			sUnit[(i+1)%3] = S_UNIT_X;
			sUnit[(i+2)%3] = S_UNIT_Y;

			// Now make it exactly perpendicular 
			w = Dot( sUnit, norm );
			sUnit[0] -= w * norm[0];
			sUnit[1] -= w * norm[1];
			sUnit[2] -= w * norm[2];
			Normalize( sUnit );

			// Choose tUnit so that (sUnit,tUnit,norm) form a right-handed frame 
			tUnit[0] = norm[1]*sUnit[2] - norm[2]*sUnit[1];
			tUnit[1] = norm[2]*sUnit[0] - norm[0]*sUnit[2];
			tUnit[2] = norm[0]*sUnit[1] - norm[1]*sUnit[0];
			Normalize( tUnit );
		#else*/
			/* Project perpendicular to a coordinate axis -- better numerically */
			sUnit[i] = 0;
			sUnit[(i+1)%3] = 1.0;
			sUnit[(i+2)%3] = 0.0;

			tUnit[i] = 0;
			tUnit[(i+1)%3] = 0.0;
			tUnit[(i+2)%3] = (norm[i] > 0) ? 1.0 : -1.0;
	//	#endif

			/* Project the vertices onto the sweep plane */
			for( v = vHead.next; v !== vHead; v = v.next ) {
				v.s = this.dot_( v.coords, sUnit );
				v.t = this.dot_( v.coords, tUnit );
			}
			if( computedNormal ) {
				this.checkOrientation_();
			}

			/* Compute ST bounds. */
			first = true;
			for( v = vHead.next; v !== vHead; v = v.next ) {
				if (first) {
					this.bmin[0] = this.bmax[0] = v.s;
					this.bmin[1] = this.bmax[1] = v.t;
					first = false;
				} else {
					if (v.s < this.bmin[0]) this.bmin[0] = v.s;
					if (v.s > this.bmax[0]) this.bmax[0] = v.s;
					if (v.t < this.bmin[1]) this.bmin[1] = v.t;
					if (v.t > this.bmax[1]) this.bmax[1] = v.t;
				}
			}
		},

		addWinding_: function(eDst,eSrc) {
			eDst.winding += eSrc.winding;
			eDst.Sym.winding += eSrc.Sym.winding;
		},
		
		/* tessMeshTessellateMonoRegion( face ) tessellates a monotone region
		* (what else would it do??)  The region must consist of a single
		* loop of half-edges (see mesh.h) oriented CCW.  "Monotone" in this
		* case means that any vertical line intersects the interior of the
		* region in a single interval.  
		*
		* Tessellation consists of adding interior edges (actually pairs of
		* half-edges), to split the region into non-overlapping triangles.
		*
		* The basic idea is explained in Preparata and Shamos (which I don''t
		* have handy right now), although their implementation is more
		* complicated than this one.  The are two edge chains, an upper chain
		* and a lower chain.  We process all vertices from both chains in order,
		* from right to left.
		*
		* The algorithm ensures that the following invariant holds after each
		* vertex is processed: the untessellated region consists of two
		* chains, where one chain (say the upper) is a single edge, and
		* the other chain is concave.  The left vertex of the single edge
		* is always to the left of all vertices in the concave chain.
		*
		* Each step consists of adding the rightmost unprocessed vertex to one
		* of the two chains, and forming a fan of triangles from the rightmost
		* of two chain endpoints.  Determining whether we can add each triangle
		* to the fan is a simple orientation test.  By making the fan as large
		* as possible, we restore the invariant (check it yourself).
		*/
	//	int tessMeshTessellateMonoRegion( TESSmesh *mesh, TESSface *face )
		tessellateMonoRegion_: function( mesh, face ) {
			var up, lo;

			/* All edges are oriented CCW around the boundary of the region.
			* First, find the half-edge whose origin vertex is rightmost.
			* Since the sweep goes from left to right, face->anEdge should
			* be close to the edge we want.
			*/
			up = face.anEdge;
			assert( up.Lnext !== up && up.Lnext.Lnext !== up );

			for( ; Geom.vertLeq( up.Dst, up.Org ); up = up.Lprev )
				;
			for( ; Geom.vertLeq( up.Org, up.Dst ); up = up.Lnext )
				;
			lo = up.Lprev;

			while( up.Lnext !== lo ) {
				if( Geom.vertLeq( up.Dst, lo.Org )) {
					/* up->Dst is on the left.  It is safe to form triangles from lo->Org.
					* The EdgeGoesLeft test guarantees progress even when some triangles
					* are CW, given that the upper and lower chains are truly monotone.
					*/
					while( lo.Lnext !== up && (Geom.edgeGoesLeft( lo.Lnext )
						|| Geom.edgeSign( lo.Org, lo.Dst, lo.Lnext.Dst ) <= 0.0 )) {
							var tempHalfEdge = mesh.connect( lo.Lnext, lo );
							//if (tempHalfEdge == NULL) return 0;
							lo = tempHalfEdge.Sym;
					}
					lo = lo.Lprev;
				} else {
					/* lo->Org is on the left.  We can make CCW triangles from up->Dst. */
					while( lo.Lnext != up && (Geom.edgeGoesRight( up.Lprev )
						|| Geom.edgeSign( up.Dst, up.Org, up.Lprev.Org ) >= 0.0 )) {
							var tempHalfEdge = mesh.connect( up, up.Lprev );
							//if (tempHalfEdge == NULL) return 0;
							up = tempHalfEdge.Sym;
					}
					up = up.Lnext;
				}
			}

			/* Now lo->Org == up->Dst == the leftmost vertex.  The remaining region
			* can be tessellated in a fan from this leftmost vertex.
			*/
			assert( lo.Lnext !== up );
			while( lo.Lnext.Lnext !== up ) {
				var tempHalfEdge = mesh.connect( lo.Lnext, lo );
				//if (tempHalfEdge == NULL) return 0;
				lo = tempHalfEdge.Sym;
			}

			return true;
		},


		/* tessMeshTessellateInterior( mesh ) tessellates each region of
		* the mesh which is marked "inside" the polygon.  Each such region
		* must be monotone.
		*/
		//int tessMeshTessellateInterior( TESSmesh *mesh )
		tessellateInterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Make sure we don''t try to tessellate the new triangles. */
				next = f.next;
				if( f.inside ) {
					if ( !this.tessellateMonoRegion_( mesh, f ) ) return false;
				}
			}

			return true;
		},


		/* tessMeshDiscardExterior( mesh ) zaps (ie. sets to NULL) all faces
		* which are not marked "inside" the polygon.  Since further mesh operations
		* on NULL faces are not allowed, the main purpose is to clean up the
		* mesh so that exterior loops are not represented in the data structure.
		*/
		//void tessMeshDiscardExterior( TESSmesh *mesh )
		discardExterior_: function( mesh ) {
			var f, next;

			/*LINTED*/
			for( f = mesh.fHead.next; f !== mesh.fHead; f = next ) {
				/* Since f will be destroyed, save its next pointer. */
				next = f.next;
				if( ! f.inside ) {
					mesh.zapFace( f );
				}
			}
		},

		/* tessMeshSetWindingNumber( mesh, value, keepOnlyBoundary ) resets the
		* winding numbers on all edges so that regions marked "inside" the
		* polygon have a winding number of "value", and regions outside
		* have a winding number of 0.
		*
		* If keepOnlyBoundary is TRUE, it also deletes all edges which do not
		* separate an interior region from an exterior one.
		*/
	//	int tessMeshSetWindingNumber( TESSmesh *mesh, int value, int keepOnlyBoundary )
		setWindingNumber_: function( mesh, value, keepOnlyBoundary ) {
			var e, eNext;

			for( e = mesh.eHead.next; e !== mesh.eHead; e = eNext ) {
				eNext = e.next;
				if( e.Rface.inside !== e.Lface.inside ) {

					/* This is a boundary edge (one side is interior, one is exterior). */
					e.winding = (e.Lface.inside) ? value : -value;
				} else {

					/* Both regions are interior, or both are exterior. */
					if( ! keepOnlyBoundary ) {
						e.winding = 0;
					} else {
						mesh.delete( e );
					}
				}
			}
		},

		getNeighbourFace_: function(edge)
		{
			if (!edge.Rface)
				return -1;
			if (!edge.Rface.inside)
				return -1;
			return edge.Rface.n;
		},

		outputPolymesh_: function( mesh, elementType, polySize, vertexSize ) {
			var v;
			var f;
			var edge;
			var maxFaceCount = 0;
			var maxVertexCount = 0;
			var faceVerts, i;
			var elements = 0;
			var vert;

			// Assume that the input data is triangles now.
			// Try to merge as many polygons as possible
			if (polySize > 3)
			{
				mesh.mergeConvexFaces( polySize );
			}

			// Mark unused
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
				v.n = -1;

			// Create unique IDs for all vertices and faces.
			for ( f = mesh.fHead.next; f != mesh.fHead; f = f.next )
			{
				f.n = -1;
				if( !f.inside ) continue;

				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					if ( v.n === -1 )
					{
						v.n = maxVertexCount;
						maxVertexCount++;
					}
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				
				assert( faceVerts <= polySize );

				f.n = maxFaceCount;
				++maxFaceCount;
			}

			this.elementCount = maxFaceCount;
			if (elementType == Tess2.CONNECTED_POLYGONS)
				maxFaceCount *= 2;
	/*		tess.elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * maxFaceCount * polySize );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = maxFaceCount * polySize;
			
			this.vertexCount = maxVertexCount;
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															 sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = maxVertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = maxVertexCount;

			
			// Output vertices.
			for ( v = mesh.vHead.next; v !== mesh.vHead; v = v.next )
			{
				if ( v.n != -1 )
				{
					// Store coordinate
					var idx = v.n * vertexSize;
					this.vertices[idx+0] = v.coords[0];
					this.vertices[idx+1] = v.coords[1];
					if ( vertexSize > 2 )
						this.vertices[idx+2] = v.coords[2];
					// Store vertex index.
					this.vertexIndices[v.n] = v.idx;
				}
			}

			// Output indices.
			var nel = 0;
			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;
				
				// Store polygon
				edge = f.anEdge;
				faceVerts = 0;
				do
				{
					v = edge.Org;
					this.elements[nel++] = v.n;
					faceVerts++;
					edge = edge.Lnext;
				}
				while (edge !== f.anEdge);
				// Fill unused.
				for (i = faceVerts; i < polySize; ++i)
					this.elements[nel++] = -1;

				// Store polygon connectivity
				if ( elementType == Tess2.CONNECTED_POLYGONS )
				{
					edge = f.anEdge;
					do
					{
						this.elements[nel++] = this.getNeighbourFace_( edge );
						edge = edge.Lnext;
					}
					while (edge !== f.anEdge);
					// Fill unused.
					for (i = faceVerts; i < polySize; ++i)
						this.elements[nel++] = -1;
				}
			}
		},

	//	void OutputContours( TESStesselator *tess, TESSmesh *mesh, int vertexSize )
		outputContours_: function( mesh, vertexSize ) {
			var f;
			var edge;
			var start;
			var verts;
			var elements;
			var vertInds;
			var startVert = 0;
			var vertCount = 0;

			this.vertexCount = 0;
			this.elementCount = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				start = edge = f.anEdge;
				do
				{
					this.vertexCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elementCount++;
			}

	/*		tess->elements = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSindex) * tess->elementCount * 2 );
			if (!tess->elements)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.elements = [];
			this.elements.length = this.elementCount * 2;
			
	/*		tess->vertices = (TESSreal*)tess->alloc.memalloc( tess->alloc.userData,
															  sizeof(TESSreal) * tess->vertexCount * vertexSize );
			if (!tess->vertices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertices = [];
			this.vertices.length = this.vertexCount * vertexSize;

	/*		tess->vertexIndices = (TESSindex*)tess->alloc.memalloc( tess->alloc.userData,
																    sizeof(TESSindex) * tess->vertexCount );
			if (!tess->vertexIndices)
			{
				tess->outOfMemory = 1;
				return;
			}*/
			this.vertexIndices = [];
			this.vertexIndices.length = this.vertexCount;

			var nv = 0;
			var nvi = 0;
			var nel = 0;
			startVert = 0;

			for ( f = mesh.fHead.next; f !== mesh.fHead; f = f.next )
			{
				if ( !f.inside ) continue;

				vertCount = 0;
				start = edge = f.anEdge;
				do
				{
					this.vertices[nv++] = edge.Org.coords[0];
					this.vertices[nv++] = edge.Org.coords[1];
					if ( vertexSize > 2 )
						this.vertices[nv++] = edge.Org.coords[2];
					this.vertexIndices[nvi++] = edge.Org.idx;
					vertCount++;
					edge = edge.Lnext;
				}
				while ( edge !== start );

				this.elements[nel++] = startVert;
				this.elements[nel++] = vertCount;

				startVert += vertCount;
			}
		},

		addContour: function( size, vertices )
		{
			var e;
			var i;

			if ( this.mesh === null )
			  	this.mesh = new TESSmesh();
	/*	 	if ( tess->mesh == NULL ) {
				tess->outOfMemory = 1;
				return;
			}*/

			if ( size < 2 )
				size = 2;
			if ( size > 3 )
				size = 3;

			e = null;

			for( i = 0; i < vertices.length; i += size )
			{
				if( e == null ) {
					/* Make a self-loop (one vertex, one edge). */
					e = this.mesh.makeEdge();
	/*				if ( e == NULL ) {
						tess->outOfMemory = 1;
						return;
					}*/
					this.mesh.splice( e, e.Sym );
				} else {
					/* Create a new vertex and edge which immediately follow e
					* in the ordering around the left face.
					*/
					this.mesh.splitEdge( e );
					e = e.Lnext;
				}

				/* The new vertex is now e->Org. */
				e.Org.coords[0] = vertices[i+0];
				e.Org.coords[1] = vertices[i+1];
				if ( size > 2 )
					e.Org.coords[2] = vertices[i+2];
				else
					e.Org.coords[2] = 0.0;
				/* Store the insertion number so that the vertex can be later recognized. */
				e.Org.idx = this.vertexIndexCounter++;

				/* The winding of an edge says how the winding number changes as we
				* cross from the edge''s right face to its left face.  We add the
				* vertices in such an order that a CCW contour will add +1 to
				* the winding number of the region inside the contour.
				*/
				e.winding = 1;
				e.Sym.winding = -1;
			}
		},

	//	int tessTesselate( TESStesselator *tess, int windingRule, int elementType, int polySize, int vertexSize, const TESSreal* normal )
		tesselate: function( windingRule, elementType, polySize, vertexSize, normal ) {
			this.vertices = [];
			this.elements = [];
			this.vertexIndices = [];

			this.vertexIndexCounter = 0;
			
			if (normal)
			{
				this.normal[0] = normal[0];
				this.normal[1] = normal[1];
				this.normal[2] = normal[2];
			}

			this.windingRule = windingRule;

			if (vertexSize < 2)
				vertexSize = 2;
			if (vertexSize > 3)
				vertexSize = 3;

	/*		if (setjmp(tess->env) != 0) { 
				// come back here if out of memory
				return 0;
			}*/

			if (!this.mesh)
			{
				return false;
			}

			/* Determine the polygon normal and project vertices onto the plane
			* of the polygon.
			*/
			this.projectPolygon_();

			/* tessComputeInterior( tess ) computes the planar arrangement specified
			* by the given contours, and further subdivides this arrangement
			* into regions.  Each region is marked "inside" if it belongs
			* to the polygon, according to the rule given by tess->windingRule.
			* Each interior region is guaranteed be monotone.
			*/
			Sweep.computeInterior( this );

			var mesh = this.mesh;

			/* If the user wants only the boundary contours, we throw away all edges
			* except those which separate the interior from the exterior.
			* Otherwise we tessellate all the regions marked "inside".
			*/
			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.setWindingNumber_( mesh, 1, true );
			} else {
				this.tessellateInterior_( mesh ); 
			}
	//		if (rc == 0) longjmp(tess->env,1);  /* could've used a label */

			mesh.check();

			if (elementType == Tess2.BOUNDARY_CONTOURS) {
				this.outputContours_( mesh, vertexSize );     /* output contours */
			}
			else
			{
				this.outputPolymesh_( mesh, elementType, polySize, vertexSize );     /* output polygons */
			}

//			tess.mesh = null;

			return true;
		}
	};

/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

(function (global, factory) {
     true ? factory(exports, __webpack_require__(7), __webpack_require__(10), __webpack_require__(13), __webpack_require__(15)) :
    typeof define === 'function' && define.amd ? define(['exports', '@awayjs/core', '@awayjs/scene', '@awayjs/stage', '@awayjs/parsers'], factory) :
    (factory((global.AwayjsPlayer = global.AwayjsPlayer || {}),global.AwayjsCore,global.AwayjsScene,global.AwayjsStage,global._awayjs_parsers));
}(this, (function (exports,_awayjs_core,_awayjs_scene,_awayjs_stage,_awayjs_parsers) { 'use strict';

// also contains global AS2 functions
var AS2ColorAdapter = (function () {
    function AS2ColorAdapter(symbol) {
        this._rgb = 0xffffff;
        this._symbol = symbol;
        this._symbol._blockedByScript = true;
        this._target = symbol.adaptee.transform.colorTransform || (symbol.adaptee.transform.colorTransform = new _awayjs_core.ColorTransform());
        this._transform = { ra: 100, rb: 0, ga: 100, gb: 0, ba: 100, bb: 0, aa: 100, ab: 0 };
    }
    AS2ColorAdapter.prototype.getRGB = function () {
        return this._rgb;
    };
    AS2ColorAdapter.prototype.setRGB = function (value) {
        this._rgb = value;
        var r = (value >> 16) & 0xff;
        var g = (value >> 8) & 0xff;
        var b = value & 0xff;
        this.setTransform({ ra: r / 0xff * 100, ga: g / 0xff * 100, ba: b / 0xff * 100, aa: 100, rb: 0, gb: 0, bb: 0, ab: 0 });
    };
    AS2ColorAdapter.prototype.getTransform = function () {
        return this._transform;
    };
    AS2ColorAdapter.prototype.setTransform = function (value) {
        this._transform = value;
        var ct = this._target;
        ct.redMultiplier = value.ra === undefined ? 1 : value.ra / 100;
        ct.greenMultiplier = value.ga === undefined ? 1 : value.ga / 100;
        ct.blueMultiplier = value.ba === undefined ? 1 : value.ba / 100;
        ct.alphaMultiplier = value.aa === undefined ? 1 : value.aa / 100;
        ct.redOffset = value.rb || 0;
        ct.greenOffset = value.gb || 0;
        ct.blueOffset = value.bb || 0;
        ct.alphaOffset = value.ab || 0;
        this._symbol.adaptee.pInvalidateHierarchicalProperties(_awayjs_scene.HierarchicalProperties.COLOR_TRANSFORM);
    };
    return AS2ColorAdapter;
}());

var AS2KeyAdapter = (function () {
    function AS2KeyAdapter() {
    }
    AS2KeyAdapter.addListener = function (listener) {
        AS2KeyAdapter._listeners.push(listener);
    };
    AS2KeyAdapter.removeListener = function (listener) {
        var listeners = AS2KeyAdapter._listeners;
        var index = listeners.indexOf(listener);
        if (index != -1)
            listeners.splice(index, 1);
    };
    AS2KeyAdapter.isDown = function (code) {
        return AS2KeyAdapter._keys[code];
    };
    AS2KeyAdapter.getCode = function () {
        return AS2KeyAdapter._key;
    };
    AS2KeyAdapter.getAscii = function () {
        return AS2KeyAdapter._char;
    };
    AS2KeyAdapter._onKeyDown = function (event) {
        AS2KeyAdapter._key = event.keyCode;
        AS2KeyAdapter._char = event.charCode;
        AS2KeyAdapter._keys[event.keyCode] = true;
        var len = AS2KeyAdapter._listeners.length;
        for (var i = 0; i < len; i++)
            if (AS2KeyAdapter._listeners[i].onKeyDown)
                AS2KeyAdapter._listeners[i].onKeyDown();
    };
    AS2KeyAdapter._onKeyUp = function (event) {
        AS2KeyAdapter._keys[event.keyCode] = false;
        var len = AS2KeyAdapter._listeners.length;
        for (var i = 0; i < len; i++)
            if (AS2KeyAdapter._listeners[i].onKeyUp)
                AS2KeyAdapter._listeners[i].onKeyUp();
    };
    return AS2KeyAdapter;
}());
AS2KeyAdapter._keys = new Array();
AS2KeyAdapter._listeners = new Array();
AS2KeyAdapter._addListeners = (function () {
    if (typeof document !== "undefined") {
        document.onkeydown = function (event) { return AS2KeyAdapter._onKeyDown(event); };
        document.onkeyup = function (event) { return AS2KeyAdapter._onKeyUp(event); };
    }
})();
/**
 * Constant associated with the key code value for the Backspace key (8).
 */
AS2KeyAdapter.BACKSPACE = 8;
/**
 * Constant associated with the key code value for the Caps Lock key (20).
 */
AS2KeyAdapter.CAPSLOCK = 20;
/**
 * Constant associated with the key code value for the Control key (17).
 */
AS2KeyAdapter.CONTROL = 17;
/**
 * Constant associated with the key code value for the Delete key (46).
 */
AS2KeyAdapter.DELETEKEY = 46;
/**
 * Constant associated with the key code value for the Down Arrow key (40).
 */
AS2KeyAdapter.DOWN = 40;
/**
 * Constant associated with the key code value for the End key (35).
 */
AS2KeyAdapter.END = 35;
/**
 * Constant associated with the key code value for the Enter key (13).
 */
AS2KeyAdapter.ENTER = 13;
/**
 * Constant associated with the key code value for the Escape key (27).
 */
AS2KeyAdapter.ESCAPE = 27;
/**
 * Constant associated with the key code value for the Home key (36).
 */
AS2KeyAdapter.HOME = 36;
/**
 * Constant associated with the key code value for the Insert key (45).
 */
AS2KeyAdapter.INSERT = 45;
/**
 * Constant associated with the key code value for the Left Arrow key (37).
 */
AS2KeyAdapter.LEFT = 37;
/**
 * Constant associated with the key code value for the Page Down key (34).
 */
AS2KeyAdapter.PGDN = 34;
/**
 * Constant associated with the key code value for the Page Up key (33).
 */
AS2KeyAdapter.PGUP = 33;
/**
 * Constant associated with the key code value for the Right Arrow key (39).
 */
AS2KeyAdapter.RIGHT = 39;
/**
 * Constant associated with the key code value for the Shift key (16).
 */
AS2KeyAdapter.SHIFT = 16;
/**
 * Constant associated with the key code value for the Spacebar (32).
 */
AS2KeyAdapter.SPACE = 32;
/**
 * Constant associated with the key code value for the Tab key (9).
 */
AS2KeyAdapter.TAB = 9;
/**
 * Constant associated with the key code value for the Up Arrow key (38).
 */
AS2KeyAdapter.UP = 38;

/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}



















function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
}



function __await(v) {
    return this instanceof __await ? (this.v = v, this) : new __await(v);
}

var AS2MCSoundProps = (function (_super) {
    __extends(AS2MCSoundProps, _super);
    function AS2MCSoundProps() {
        var _this = _super.call(this) || this;
        _this._volume = 1;
        _this._pan = 1;
        _this._changeEvent = new _awayjs_core.AssetEvent(_awayjs_core.AssetEvent.INVALIDATE, _this);
        return _this;
    }
    AS2MCSoundProps.prototype.dispose = function () {
        this._audio = null;
        this._changeEvent = null;
    };
    Object.defineProperty(AS2MCSoundProps.prototype, "volume", {
        get: function () {
            return this._volume;
        },
        set: function (value) {
            if (this._volume != value) {
                this._volume = value;
                this.dispatchEvent(this._changeEvent);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MCSoundProps.prototype, "pan", {
        get: function () {
            return this._pan;
        },
        set: function (value) {
            if (this._pan != value) {
                this._pan = value;
                this.dispatchEvent(this._changeEvent);
            }
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MCSoundProps.prototype, "audio", {
        get: function () {
            return this._audio;
        },
        set: function (value) {
            if (this._audio)
                this._audio.stop();
            this._audio = value;
        },
        enumerable: true,
        configurable: true
    });
    return AS2MCSoundProps;
}(_awayjs_core.AssetBase));

var AS2MouseAdapter = (function () {
    function AS2MouseAdapter() {
    }
    // this does nothing really, just to catch usage in scripts
    AS2MouseAdapter.addListener = function (listener) {
        AS2MouseAdapter._globalListeners.push(listener);
        // TODO: Init actual mouse events here, relative to root MovieClip (I suppose?)
    };
    return AS2MouseAdapter;
}());
AS2MouseAdapter._globalListeners = [];

// also contains global AS2 gunctions
var AS2SymbolAdapter = (function () {
    function AS2SymbolAdapter(adaptee, view) {
        this.__quality = "high";
        this._adaptee = adaptee;
        this._adaptee.adapter = this;
        this._view = view;
        this._blockedByScript = false;
        if (AS2SymbolAdapter.REFERENCE_TIME === -1)
            AS2SymbolAdapter.REFERENCE_TIME = Date.now();
    }
    AS2SymbolAdapter.prototype.isBlockedByScript = function () { return this._blockedByScript; };
    AS2SymbolAdapter.prototype.isVisibilityByScript = function () { return this._visibilityByScript; };
    AS2SymbolAdapter.prototype.freeFromScript = function () { this._blockedByScript = false; this._visibilityByScript = false; };
    AS2SymbolAdapter.prototype.dispose = function () {
        this._adaptee.dispose();
        this._adaptee = null;
        this._view = null;
    };
    AS2SymbolAdapter.prototype.getVersion = function () {
        return 0;
    };
    Object.defineProperty(AS2SymbolAdapter.prototype, "adaptee", {
        get: function () {
            return this._adaptee;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_height", {
        get: function () {
            return this._adaptee.height;
        },
        set: function (value) {
            this._adaptee.height = value;
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_name", {
        get: function () {
            return this._adaptee.name;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_rotation", {
        get: function () {
            return this._adaptee.rotationZ;
        },
        set: function (value) {
            this._adaptee.rotationZ = value;
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_x", {
        get: function () {
            return this._adaptee.x;
        },
        set: function (value) {
            this._adaptee.x = value;
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_xmouse", {
        get: function () {
            return this._view.getLocalMouseX(this._adaptee);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_y", {
        get: function () {
            return this._adaptee.y;
        },
        set: function (value) {
            this._adaptee.y = value;
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_ymouse", {
        get: function () {
            return this._view.getLocalMouseY(this._adaptee);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_xscale", {
        get: function () {
            return this._adaptee.scaleX * 100;
        },
        set: function (value) {
            this._adaptee.scaleX = value / 100;
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_yscale", {
        get: function () {
            return this._adaptee.scaleY * 100;
        },
        set: function (value) {
            this._adaptee.scaleY = value / 100;
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_visible", {
        get: function () {
            return this._adaptee.visible;
        },
        set: function (value) {
            this._adaptee.visible = value;
            this._visibilityByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_width", {
        get: function () {
            return this._adaptee.width;
        },
        set: function (value) {
            this._adaptee.width = value;
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_touchpoints", {
        get: function () {
            return this._view.getLocalTouchPoints(this._adaptee);
        },
        enumerable: true,
        configurable: true
    });
    AS2SymbolAdapter.prototype.getDepth = function () {
        return this._adaptee.z;
    };
    Object.defineProperty(AS2SymbolAdapter.prototype, "_quality", {
        // just assure consistency for scripts, doesn't actually effect rendering.
        get: function () {
            return this.__quality;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "quality", {
        set: function (value) {
            this.__quality = value;
            // this._blockedByScript=true;
        },
        enumerable: true,
        configurable: true
    });
    AS2SymbolAdapter.prototype.trace = function (message) {
        console.log(message);
    };
    // may need proper high-def timer mechanism
    AS2SymbolAdapter.prototype.getTimer = function () {
        return Date.now() - AS2SymbolAdapter.REFERENCE_TIME;
    };
    Object.defineProperty(AS2SymbolAdapter.prototype, "_alpha", {
        get: function () {
            return this.adaptee.transform.colorTransform ? (this.adaptee.transform.colorTransform.alphaMultiplier * 100) : 100;
        },
        set: function (value) {
            if (!this.adaptee.transform.colorTransform)
                this.adaptee.transform.colorTransform = new _awayjs_core.ColorTransform();
            this.adaptee.transform.colorTransform.alphaMultiplier = value / 100;
            this.adaptee.pInvalidateHierarchicalProperties(_awayjs_scene.HierarchicalProperties.COLOR_TRANSFORM);
            this._blockedByScript = true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_url", {
        get: function () {
            return document.URL;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_global", {
        get: function () {
            return null;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_level0", {
        get: function () {
            return this._root;
        },
        enumerable: true,
        configurable: true
    });
    AS2SymbolAdapter.prototype.clearInterval = function (handle) {
        _awayjs_scene.FrameScriptManager.clearInterval(handle); //window.clearInterval(handle);
        return;
    };
    AS2SymbolAdapter.prototype.setInterval = function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var scope;
        var func;
        if (typeof (args[0]) == "function") {
            scope = this;
            func = args[0];
        }
        else {
            //remove scope variable from args
            scope = args.shift();
            //reformat function string to actual function variable in the scope
            func = scope[args[0]];
        }
        //wrap function to maintain scope
        args[0] = function () { func.apply(scope, arguments); };
        return _awayjs_scene.FrameScriptManager.setInterval(args[0]); // window.setInterval.apply(window, args);
    };
    Object.defineProperty(AS2SymbolAdapter.prototype, "_level10301", {
        // temporary:
        get: function () {
            return this._root;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SymbolAdapter.prototype, "_root", {
        get: function () {
            if (!this.__root) {
                var p = this._parent;
                // parents are always MovieClips
                this.__root = p ? p._root : this;
            }
            return this.__root;
        },
        enumerable: true,
        configurable: true
    });
    AS2SymbolAdapter.prototype.random = function (range) {
        return Math.floor(Math.random() * range);
    };
    Object.defineProperty(AS2SymbolAdapter.prototype, "_parent", {
        get: function () {
            var parent = this.adaptee.parent;
            return parent ? parent._adapter : null;
        },
        enumerable: true,
        configurable: true
    });
    return AS2SymbolAdapter;
}());
AS2SymbolAdapter.REFERENCE_TIME = -1;

// also contains global AS2 functions
var AS2SystemAdapter = (function () {
    function AS2SystemAdapter() {
    }
    return AS2SystemAdapter;
}());
AS2SystemAdapter.security = null;
AS2SystemAdapter.capabilities = { version: 6 };

// also contains global AS2 functions
var AS2SoundAdapter = (function () {
    // TODO: Any real Sound stuff should be externalized for AwayJS use. For now use internally since it's only 2D.
    function AS2SoundAdapter(target) {
        var _this = this;
        this._loop = false;
        this._name = "";
        this._id = -1;
        this._playing = false;
        this._volume = 0; // uses this vol property on sound.
        // not sure how to handle target yet
        this._id = AS2SoundAdapter._soundIDCnt++;
        this._target = target;
        this._soundProps = (target != null && target.__pSoundProps) ? this._target.__pSoundProps : AS2SoundAdapter._globalSoundProps;
        this._onGlobalChangeDelegate = function (event) { return _this.onGlobalChange(event); };
        AS2SoundAdapter._globalSoundProps.addEventListener(_awayjs_core.AssetEvent.INVALIDATE, this._onGlobalChangeDelegate);
    }
    Object.defineProperty(AS2SoundAdapter.prototype, "onSoundComplete", {
        set: function (value) {
            this._soundProps.audio.onSoundComplete = value;
        },
        enumerable: true,
        configurable: true
    });
    AS2SoundAdapter.prototype.attachSound = function (id) {
        this._name = id.replace(".wav", "").replace(".mp3", "").replace(/[^a-zA-Z0-9_]/g, '').toLowerCase();
        var asset = _awayjs_core.AssetLibrary.getAsset(this._name);
        if (asset)
            this._soundProps.audio = asset.clone();
        else {
            console.log("audio-asset not found " + this._name);
        }
        this.updateVolume();
    };
    /*getBytesLoaded():number
    {
        return 1;
    }

    getBytesTotal():number
    {
        return 1;
    }*/
    AS2SoundAdapter.prototype.getPan = function () {
        return this._soundProps.pan * 100;
    };
    AS2SoundAdapter.prototype.setPan = function (value) {
        this._soundProps.pan = value / 100;
        if (_awayjs_core.AudioManager.getExternalSoundInterface()) {
        }
        else if (this._soundProps.audio)
            this._soundProps.audio.pan = value / 100;
    };
    /*getTransform():Object
    {
        return this._transform;
    }

    setTransform(value:Object):void
    {
        this._transform = value;
    }*/
    AS2SoundAdapter.prototype.getVolume = function () {
        return this._soundProps.volume * 100;
    };
    AS2SoundAdapter.prototype.setVolume = function (value) {
        this._soundProps.volume = value / 100;
        this.updateVolume();
    };
    /*loadSound(url:string, isStreaming:boolean):void
    {
        this.disposeAudio();
        // how to handle isStreaming == false? Manually?
        this._soundProps.audio = new Audio();
        this._soundProps.audio.src = url;
        this.initAudio();
    }*/
    AS2SoundAdapter.prototype.start = function (offsetInSeconds, loops) {
        if (offsetInSeconds === void 0) { offsetInSeconds = 0; }
        if (loops === void 0) { loops = 0; }
        this._playing = true;
        this._loop = Boolean(loops > 0);
        if (_awayjs_core.AudioManager.getExternalSoundInterface()) {
            _awayjs_stage.ContextGLES.startSound(this._name, this._id, this._volume, this._loop);
            //AudioManager.getExternalSoundInterface().startSound(this._name, this._id, this._volume, this._loop);
            return;
        }
        if (this._soundProps.audio) {
            this._soundProps.audio.play(offsetInSeconds, this._loop);
            return;
        }
        //console.log("Calling AS2SoundAdapter.start() was not successfull. Audio not set for this sound.")
    };
    AS2SoundAdapter.prototype.stop = function (linkageID) {
        if (linkageID === void 0) { linkageID = null; }
        if (!this._playing)
            return;
        this._playing = false;
        if (_awayjs_core.AudioManager.getExternalSoundInterface()) {
            _awayjs_stage.ContextGLES.stopSound(this._id);
            //AudioManager.getExternalSoundInterface().stopSound(this._id);
            return;
        }
        else if (this._soundProps.audio) {
            this._soundProps.audio.stop();
            return;
        }
        //console.log("Calling AS2SoundAdapter.stop() was not successfull. Audio not set for this sound.")
    };
    Object.defineProperty(AS2SoundAdapter.prototype, "position", {
        get: function () {
            if (this._soundProps.audio)
                return this._soundProps.audio.currentTime;
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SoundAdapter.prototype, "duration", {
        get: function () {
            if (this._soundProps.audio)
                return this._soundProps.audio.duration;
            return 0;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2SoundAdapter.prototype, "id3", {
        get: function () {
            return {};
        },
        enumerable: true,
        configurable: true
    });
    AS2SoundAdapter.prototype.onGlobalChange = function (event) {
        this.updateVolume();
    };
    AS2SoundAdapter.prototype.updateVolume = function () {
        var vol = this._soundProps.volume * AS2SoundAdapter._globalSoundProps.volume;
        if (vol > 1)
            vol = 1;
        if (vol < 0)
            vol = 0;
        vol = Math.round(vol * 100) / 100;
        //if(this._volume == vol)
        //	return;
        this._volume = vol;
        if (_awayjs_core.AudioManager.getExternalSoundInterface()) {
            if (this._playing) {
                _awayjs_stage.ContextGLES.updateSound(this._id, this._volume, this._loop);
            }
        }
        else if (this._soundProps.audio)
            this._soundProps.audio.volume = this._volume;
    };
    return AS2SoundAdapter;
}());
AS2SoundAdapter._globalSoundProps = new AS2MCSoundProps();
AS2SoundAdapter._soundIDCnt = 0;

var AS2StageAdapter = (function () {
    function AS2StageAdapter() {
    }
    return AS2StageAdapter;
}());
// this does nothing really, just to catch usage in scripts
AS2StageAdapter.showMenu = true;

var AS2SharedObjectAdapter = (function () {
    function AS2SharedObjectAdapter(name) {
        this._object_name = name;
        if (typeof (Storage) !== "undefined") {
            this.data = JSON.parse(localStorage.getItem(name));
        }
        if (this.data == null) {
            console.log("no shared object found");
            this.data = {};
        }
    }
    // should become a static
    AS2SharedObjectAdapter.getLocal = function (name, localPath, secure) {
        return new AS2SharedObjectAdapter(name);
    };
    // needs to stay as it is
    AS2SharedObjectAdapter.prototype.flush = function () {
        if (typeof (Storage) !== "undefined") {
            localStorage.setItem(this._object_name, JSON.stringify(this.data));
        }
        else {
            console.log("no local storage available");
        }
        // save all local data to wherever it needs to go
    };
    return AS2SharedObjectAdapter;
}());

var includeString = 'var Color			= this._includes.Color;\n' +
    'var System				= this._includes.System;\n' +
    'var Sound				= this._includes.Sound;\n' +
    'var Key				= this._includes.Key;\n' +
    'var Mouse				= this._includes.Mouse;\n' +
    'var Stage				= this._includes.Stage;\n' +
    'var SharedObject		= this._includes.SharedObject;\n' +
    'var int = function (value) { return (value>=0?1:-1)* Math.floor(Math.abs(value))};\n' +
    'var string = function(value) {return value.toString();}\n' +
    'var getURL = function(value) {window.open(value,"_blank");}\n\n';
var AS2MovieClipAdapter = (function (_super) {
    __extends(AS2MovieClipAdapter, _super);
    function AS2MovieClipAdapter(adaptee, view) {
        var _this = 
        // create an empty MovieClip if none is passed
        _super.call(this, adaptee, view) || this;
        _this._includes = {
            Color: AS2ColorAdapter,
            System: AS2SystemAdapter,
            Sound: AS2SoundAdapter,
            Key: AS2KeyAdapter,
            Mouse: AS2MouseAdapter,
            Stage: AS2StageAdapter,
            SharedObject: AS2SharedObjectAdapter
        };
        _this.__pSoundProps = new AS2MCSoundProps();
        _this._onLoaderCompleteDelegate = function (event) { return _this.onLoaderComplete(event); };
        _this._onAssetCompleteDelegate = function (event) { return _this.onAssetComplete(event); };
        return _this;
    }
    AS2MovieClipAdapter.prototype.loadMovie = function (url, method) {
        if (method === void 0) { method = null; }
        this._loader = new _awayjs_scene.LoaderContainer();
        this._loader.addEventListener(_awayjs_core.LoaderEvent.LOAD_COMPLETE, this._onLoaderCompleteDelegate);
        this._loader.addEventListener(_awayjs_core.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        this._loader.load(new _awayjs_core.URLRequest(url));
    };
    AS2MovieClipAdapter.prototype.onLoaderComplete = function (event) {
        console.log("loaded url!");
        this._loader.removeEventListener(_awayjs_core.LoaderEvent.LOAD_COMPLETE, this._onLoaderCompleteDelegate);
        this._loader.removeEventListener(_awayjs_core.AssetEvent.ASSET_COMPLETE, this._onAssetCompleteDelegate);
        this._loader = null;
        //todo: dispose loader ?
    };
    AS2MovieClipAdapter.prototype.onAssetComplete = function (event) {
        event.asset;
        if (event.asset.isAsset(_awayjs_scene.MovieClip)) {
            var awayMC = event.asset;
            // if this is the "Scene 1", we transfer the timeline into the mc that is loading the movie
            if (event.asset.name == "Scene 1" || event.asset.name == "main") {
                //this.adaptee.addChild(awayMC);
                this._adaptee.timeline = awayMC.timeline;
                this._adaptee.reset();
                this.gotoAndPlay(1);
            }
        }
    };
    AS2MovieClipAdapter.prototype.dispose = function () {
        _super.prototype.dispose.call(this);
        this.__pSoundProps.dispose();
        this.__pSoundProps = null;
    };
    Object.defineProperty(AS2MovieClipAdapter.prototype, "_framesloaded", {
        get: function () {
            // not loading frame by frame?
            return this._adaptee.numFrames;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "_currentframe", {
        get: function () {
            return this._adaptee.currentFrameIndex + 1;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "_totalframes", {
        get: function () {
            return this._adaptee.numFrames;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "enabled", {
        get: function () {
            return this._adaptee.mouseEnabled;
        },
        enumerable: true,
        configurable: true
    });
    AS2MovieClipAdapter.prototype.evalScript = function (str) {
        var tag = document.createElement('script');
        tag.text = 'var __framescript__ = function() {\n' + includeString + str + '\n}';
        //add and remove script tag to dom to trigger compilation
        var sibling = document.scripts[0];
        sibling.parentNode.insertBefore(tag, sibling).parentNode.removeChild(tag);
        var script = __framescript__;
        window['__framescript__'] = null;
        return script;
    };
    //attachAudio(id: AS2SoundAdapter):void {	}
    //attachBitmap(bmp: BitmapImage2D, depth: Number, pixelSnapping: String = null, smoothing: boolean = false):void { }
    AS2MovieClipAdapter.prototype.attachMovie = function (id, name, depth, initObject) {
        if (initObject === void 0) { initObject = null; }
        var adapter = new AS2MovieClipAdapter(_awayjs_scene.MovieClip.getNewMovieClip(), this._view);
        _awayjs_core.AssetLibrary.getAsset(id).adaptee.copyTo(adapter.adaptee);
        this._adaptee.addChildAtDepth(adapter.adaptee, depth);
        adapter.adaptee.name = name;
        this.registerScriptObject(adapter.adaptee);
        return adapter;
    };
    //beginBitmapFill(bmp: BitmapImage2D, matrix: Matrix = null, repeat: boolean = false, smoothing: boolean = false):void {}
    //beginFill(rgb: Number, alpha: number = 1.0):void {}
    //beginGradientFill(fillType: string, colors: Array, alphas: Array, ratios: Array, matrix: Object, spreadMethod: string = null, interpolationMethod: string  = null, focalPointRatio: number  = null):void {}
    //clear():void {}
    AS2MovieClipAdapter.prototype.createEmptyMovieClip = function (name, depth) {
        var adapter = new AS2MovieClipAdapter(_awayjs_scene.MovieClip.getNewMovieClip(), this._view);
        adapter.adaptee.name = name;
        this.adaptee.addChildAtDepth(adapter.adaptee, depth);
        this.registerScriptObject(adapter.adaptee);
        return adapter;
    };
    //createTextField(instanceName: String, depth: Number, x: Number, y: Number, width: Number, height: Number):TextField {}
    //curveTo(controlX: number, controlY: number, anchorX: number, anchorY: number):void {}
    AS2MovieClipAdapter.prototype.duplicateMovieClip = function (name, depth, initObject) {
        var duplicate = this.clone();
        duplicate.adaptee.name = name;
        if (initObject)
            for (var key in initObject)
                if (duplicate.hasOwnProperty(key))
                    duplicate[key] = initObject[key];
        this._adaptee.parent.addChildAtDepth(duplicate.adaptee, depth);
        return duplicate;
    };
    //endFill():void {}
    //getBounds(bounds: Object):Object { return null; }
    // not applicable?
    AS2MovieClipAdapter.prototype.getBytesLoaded = function () { return 1; };
    // not applicable?
    AS2MovieClipAdapter.prototype.getBytesTotal = function () { return 1; };
    AS2MovieClipAdapter.prototype.getInstanceAtDepth = function (depth) {
        return this._adaptee.getChildAtDepth(depth);
    };
    AS2MovieClipAdapter.prototype.getNextHighestDepth = function () {
        return this._adaptee.getNextHighestDepth();
    };
    //getRect(bounds: Object):Object { return null; }
    //getSWFVersion():number { return 0; }
    //getTextSnapshot():TextSnapshot {}
    //getURL(url: string, window: string, method: string):void {}
    AS2MovieClipAdapter.prototype.globalToLocal = function (pt) {
        var newPoint = this._adaptee.globalToLocal(new _awayjs_core.Point(pt.x, pt.y));
        pt.x = newPoint.x;
        pt.y = newPoint.y;
    };
    AS2MovieClipAdapter.prototype.gotoAndPlay = function (frame) {
        if (frame == null)
            return;
        this.play();
        this._gotoFrame(frame);
    };
    AS2MovieClipAdapter.prototype.gotoAndStop = function (frame) {
        if (frame == null)
            return;
        this.stop();
        this._gotoFrame(frame);
    };
    AS2MovieClipAdapter.prototype.play = function () {
        this._adaptee.play();
    };
    AS2MovieClipAdapter.prototype.stop = function () {
        this._adaptee.stop();
    };
    AS2MovieClipAdapter.prototype.hitTest = function (x, y, shapeFlag) {
        if (shapeFlag === void 0) { shapeFlag = false; }
        return this._adaptee.hitTestPoint(x, y, shapeFlag);
    };
    //lineGradientStyle(fillType: string, colors: array, alphas: array, ratios: array, matrix: Object, spreadMethod: string = null, interpolationMethod: string, focalPointRatio: number):void {}
    //lineStyle(thickness: number, rgb: number, alpha: number, pixelHinting: boolean, noScale: string, capsStyle: string, jointStyle: string, miterLimit: number):void {}
    //lineTo(x: number, y: number):void {}
    //loadMovie(url: string, method: string = null):void {}
    //loadVariables(url: string, method: string = null):void {}
    AS2MovieClipAdapter.prototype.localToGlobal = function (pt) {
        var newPoint = this._adaptee.localToGlobal(new _awayjs_core.Point(pt.x, pt.y));
        pt.x = newPoint.x;
        pt.y = newPoint.y;
    };
    //moveTo(x: number, y: number):void {}
    AS2MovieClipAdapter.prototype.nextFrame = function () {
        ++this._adaptee.currentFrameIndex;
    };
    AS2MovieClipAdapter.prototype.prevFrame = function () {
        --this._adaptee.currentFrameIndex;
    };
    AS2MovieClipAdapter.prototype.removeMovieClip = function () {
        if (this._adaptee.parent) {
            this._adaptee.parent.removeChild(this._adaptee);
        }
    };
    AS2MovieClipAdapter.prototype.setMask = function (mc) {
        this._adaptee.masks = [mc];
    };
    //startDrag(lockCenter: boolean = false, left: number = 0, top: number = 0, right: number = 0, bottom: number = 0):void {}
    //stopDrag():void {}
    AS2MovieClipAdapter.prototype.swapDepths = function (target) {
        var parent = this._adaptee.parent;
        if (parent != null && target.parent == parent)
            parent.swapChildren(this._adaptee, target);
    };
    //unloadMovie():void {}
    AS2MovieClipAdapter.prototype.clone = function () {
        var clone = new AS2MovieClipAdapter(_awayjs_scene.MovieClip.getNewMovieClip(), this._view);
        this.adaptee.copyTo(clone.adaptee);
        return clone;
    };
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onEnterFrame", {
        /**
         *
         */
        get: function () {
            return this._onEnterFrame;
        },
        set: function (value) {
            this._onEnterFrame = this._replaceEventListener(_awayjs_core.AssetEvent.ENTER_FRAME, this._onEnterFrame, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRollOut", {
        /**
         *
         */
        get: function () {
            return this._onRollOut;
        },
        set: function (value) {
            this._onRollOut = this._replaceEventListener(_awayjs_scene.MouseEvent.MOUSE_OUT, this._onRollOut, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRollOver", {
        /**
         *
         */
        get: function () {
            return this._onRollOver;
        },
        set: function (value) {
            this._onRollOver = this._replaceEventListener(_awayjs_scene.MouseEvent.MOUSE_OVER, this._onRollOver, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onRelease", {
        /**
         *
         */
        get: function () {
            return this._onRelease;
        },
        set: function (value) {
            this._onRelease = this._replaceEventListener(_awayjs_scene.MouseEvent.MOUSE_UP, this._onRelease, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onPress", {
        /**
         *
         */
        get: function () {
            return this._onPress;
        },
        set: function (value) {
            this._onPress = this._replaceEventListener(_awayjs_scene.MouseEvent.MOUSE_DOWN, this._onPress, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onMouseDown", {
        /**
         *
         */
        get: function () {
            return this._onMouseDown;
        },
        set: function (value) {
            this._onMouseDown = this._replaceEventListener(_awayjs_scene.MouseEvent.MOUSE_DOWN, this._onMouseDown, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onMouseUp", {
        /**
         *
         */
        get: function () {
            return this._onMouseUp;
        },
        set: function (value) {
            this._onMouseUp = this._replaceEventListener(_awayjs_scene.MouseEvent.MOUSE_UP, this._onMouseUp, value);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2MovieClipAdapter.prototype, "onMouseWheel", {
        get: function () {
            return this._onMouseWheel;
        },
        set: function (value) {
            var mc = this.adaptee;
            if (this._onMouseWheel)
                mc.removeEventListener(_awayjs_scene.MouseEvent.MOUSE_WHEEL, this._onMouseWheel);
            if (value) {
                var self = this;
                var delegate = function (event) { return value.call(self, event); };
                mc.addEventListener(_awayjs_scene.MouseEvent.MOUSE_WHEEL, delegate);
                this._onMouseWheel = delegate;
            }
        },
        enumerable: true,
        configurable: true
    });
    AS2MovieClipAdapter.prototype.registerScriptObject = function (child) {
        if (child.name)
            this[child.name] = child._adapter ? child.adapter : child;
    };
    AS2MovieClipAdapter.prototype.unregisterScriptObject = function (child) {
        delete this[child.name];
        if (child.isAsset(_awayjs_scene.MovieClip))
            child.removeButtonListeners();
    };
    AS2MovieClipAdapter.prototype._gotoFrame = function (frame) {
        var mc = this.adaptee;
        if (typeof frame === "string")
            mc.jumpToLabel(frame);
        else
            mc.currentFrameIndex = frame - 1;
    };
    AS2MovieClipAdapter.prototype._replaceEventListener = function (eventType, currentListener, newListener) {
        var mc = this.adaptee;
        if (currentListener)
            mc.removeEventListener(eventType, currentListener);
        if (newListener) {
            var self = this;
            var delegate = function () { return newListener.call(self); };
            mc.addEventListener(eventType, delegate);
        }
        return delegate;
    };
    return AS2MovieClipAdapter;
}(AS2SymbolAdapter));

var AS2TextFieldAdapter = (function (_super) {
    __extends(AS2TextFieldAdapter, _super);
    function AS2TextFieldAdapter(adaptee, view) {
        var _this = _super.call(this, adaptee, view) || this;
        adaptee.multiline = true;
        adaptee.wordWrap = true;
        return _this;
    }
    AS2TextFieldAdapter.prototype.clone = function () {
        var clone = new AS2TextFieldAdapter(_awayjs_scene.TextField.getNewTextField(), this._view);
        this.adaptee.copyTo(clone.adaptee);
        return clone;
    };
    Object.defineProperty(AS2TextFieldAdapter.prototype, "textColor", {
        get: function () {
            return this._adaptee.textColor;
        },
        set: function (value) {
            this._adaptee.textColor = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2TextFieldAdapter.prototype, "embedFonts", {
        get: function () {
            return this._embedFonts;
        },
        set: function (value) {
            this._embedFonts = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(AS2TextFieldAdapter.prototype, "text", {
        get: function () {
            return this._adaptee.text;
        },
        set: function (value) {
            this._adaptee.text = value;
        },
        enumerable: true,
        configurable: true
    });
    return AS2TextFieldAdapter;
}(AS2SymbolAdapter));

var AS2SceneGraphFactory = (function (_super) {
    __extends(AS2SceneGraphFactory, _super);
    function AS2SceneGraphFactory(view) {
        var _this = _super.call(this) || this;
        _this._view = view;
        return _this;
    }
    AS2SceneGraphFactory.prototype.createMovieClip = function (timeline) {
        if (timeline === void 0) { timeline = null; }
        return new AS2MovieClipAdapter(new _awayjs_scene.MovieClip(timeline), this._view).adaptee;
    };
    AS2SceneGraphFactory.prototype.createTextField = function () {
        return new AS2TextFieldAdapter(new _awayjs_scene.TextField(), this._view).adaptee;
    };
    return AS2SceneGraphFactory;
}(_awayjs_parsers.DefaultSceneGraphFactory));

exports.AS2ColorAdapter = AS2ColorAdapter;
exports.AS2KeyAdapter = AS2KeyAdapter;
exports.AS2MCSoundProps = AS2MCSoundProps;
exports.AS2MouseAdapter = AS2MouseAdapter;
exports.AS2MovieClipAdapter = AS2MovieClipAdapter;
exports.AS2SharedObjectAdapter = AS2SharedObjectAdapter;
exports.AS2SoundAdapter = AS2SoundAdapter;
exports.AS2StageAdapter = AS2StageAdapter;
exports.AS2SymbolAdapter = AS2SymbolAdapter;
exports.AS2SystemAdapter = AS2SystemAdapter;
exports.AS2TextFieldAdapter = AS2TextFieldAdapter;
exports.AS2SceneGraphFactory = AS2SceneGraphFactory;

Object.defineProperty(exports, '__esModule', { value: true });

})));


/***/ },
/* 21 */,
/* 22 */,
/* 23 */,
/* 24 */,
/* 25 */,
/* 26 */,
/* 27 */,
/* 28 */,
/* 29 */,
/* 30 */,
/* 31 */,
/* 32 */,
/* 33 */,
/* 34 */,
/* 35 */,
/* 36 */,
/* 37 */,
/* 38 */,
/* 39 */,
/* 40 */,
/* 41 */,
/* 42 */,
/* 43 */
/***/ function(module, exports, __webpack_require__) {

module.exports = __webpack_require__(17);


/***/ }
/******/ ]);
//# sourceMappingURL=awayjs-full.bundle.js.map